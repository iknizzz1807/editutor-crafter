{
  "types": {
    "BidRequest": "RTB auction request with user and slot data",
    "BidResponse": "RTB auction response with generated bids",
    "AdSlot": "ad placement with dimensions and pricing",
    "Bid": "campaign bid for specific slot",
    "AuctionType": "FIRST_PRICE=1, SECOND_PRICE=2",
    "AdType": "BANNER=1, VIDEO=2, NATIVE=3, AUDIO=4",
    "AuctionEngine": "profile_store, campaign_store",
    "Metrics": "thread-safe metrics collection",
    "ObjectPool": "factory_func, initial_size",
    "PerformanceMonitor": "high_frequency_buffer_size int, hardware_counters Dict, measurement_buffer CircularBuffer",
    "ConnectionState": "connection metadata for C10M gateway",
    "SPMCRingBuffer": "single producer multiple consumer queue",
    "ConnectionPool": "manages millions of concurrent connections",
    "C10MGateway": "main gateway coordination class",
    "UserProfile": "compact user attributes with bitset encoding",
    "CampaignData": "campaign targeting and budget data",
    "AuctionContext": "per-request auction state",
    "BitsetTargeting": "high-performance targeting evaluation",
    "StorageClient": "shared memory + Aerospike integration",
    "TelemetryEvent": "fraud detection input event",
    "TelemetryEventType": "BID_REQUEST=1, USER_INTERACTION=2, DEVICE_FINGERPRINT=3, NETWORK_TIMING=4",
    "BlacklistEntry": "fraud entity with confidence score",
    "CircularBuffer": "capacity int, mask int, buffer List, head int, tail int",
    "DistributedBlacklist": "instance_id str, blacklist_version int, blacklist_data Dict, lock threading.RWLock, vector_clock Dict",
    "SlidingWindowAnomalyDetector": "window_size int, bucket_size int, buckets_per_window int, ip_windows Dict, user_agent_windows Dict, global_window CircularBuffer",
    "SIMDFraudFilter": "batch_size int, ip_blacklist_array ndarray, user_agent_blacklist_array ndarray, working_ips ndarray, working_hashes ndarray, results ndarray",
    "FinancialEvent": "immutable financial transaction record",
    "GlobalBudgetState": "cross-region budget coordination",
    "RegionalBudgetCache": "local budget tracking per region",
    "SettlementRecord": "record_id str, settlement_date str, advertiser_id str, campaign_id str, region_id str, currency_code str, gross_impressions int, billable_impressions int, total_spend_cents int, exchange_fees_cents int, platform_fees_cents int, net_advertiser_cost_cents int, data_provider_costs_cents int, fraud_filtered_spend_cents int, late_event_adjustments_cents int, settlement_version int, created_timestamp_us int, finalized_timestamp_us int, audit_hash str, source_events List[str]",
    "FinancialEventLog": "log_file_path str, current_batch List[FinancialEvent], batch_size int, last_hash str, sequence_number int, replication_targets List[str], integrity_check_interval int, compression_enabled bool",
    "EventDeduplicator": "fingerprint_cache Dict[str, int], time_buckets List[Set[str]], current_bucket int, acceptance_window_hours int, retention_window_hours int, conflict_events List[FinancialEvent]",
    "RegionHealthMonitor": "region_id str, health_status RegionHealthStatus, last_heartbeat_timestamp int, consecutive_failures int, primary_endpoint_url str, secondary_endpoint_url str, budget_transfer_in_progress bool, assigned_backup_region str, current_active_campaigns int, pending_settlement_events int, last_successful_budget_sync int",
    "BudgetTransferCoordinator": "transfer_id str, source_region str, target_region str, affected_campaigns List[str], transfer_state TransferState, budget_snapshot Dict[str, BudgetSnapshot], transfer_start_timestamp int, transfer_completion_timestamp int, pre_transfer_validation ValidationResult, post_transfer_validation ValidationResult, rollback_plan RollbackPlan",
    "RegionRecoveryOrchestrator": "recovery_id str, recovering_region str, current_active_region str, recovery_phase RecoveryPhase, budget_delta_events List[FinancialEvent], state_sync_progress float, shadow_mode_start_timestamp int, traffic_migration_percentage float, validation_results List[ValidationResult], rollback_triggers List[RollbackTrigger]",
    "ReconciliationReport": "report_id str, reconciliation_type ReconciliationType, time_period_start str, time_period_end str, expected_total_cents int, actual_total_cents int, discrepancy_cents int, discrepancy_percentage float, discrepancy_sources List[DiscrepancyItem], resolution_status ResolutionStatus, assigned_investigator str, resolution_timestamp_us int, resolution_notes str",
    "BudgetEvaluationRequest": "campaign_id str, bid_amount_cents int, auction_id str, region_id str, timestamp_us int",
    "BudgetEvaluationResponse": "decision BudgetDecision, remaining_budget_cents int, confidence_level float, reasoning str",
    "CampaignBudgetState": "campaign_id str, allocated_budget_cents int, confirmed_spend_cents int, pending_spend_cents int, last_updated_timestamp_us int, spend_velocity_tracker SpendVelocityTracker, overspend_buffer_cents int",
    "SpendVelocityTracker": "window_size_minutes int, spend_events List[tuple[int, int]], lock threading.Lock",
    "CircuitBreaker": "failure protection with configurable thresholds",
    "LoadSheddingPolicy": "request admission control under load",
    "CircuitBreakerConfig": "failure_threshold_percentage float, latency_threshold_ms int, minimum_request_count int, evaluation_window_seconds int, recovery_timeout_base_ms int, probe_request_count int, success_threshold_percentage float",
    "LoadTestConfig": "target_qps int, duration_seconds int, num_clients int, endpoint_url str, request_timeout_ms int, warmup_duration_seconds int",
    "LatencyMeasurement": "request_start_ns int, response_received_ns int, request_id str, status_code int, error Optional[str]",
    "PerformanceCollector": "latency measurement and aggregation",
    "BidRequestGenerator": "user_id_counter int, request_id_counter int",
    "LoadTestClient": "client_id int, config LoadTestConfig, collector PerformanceCollector, request_generator BidRequestGenerator, session Optional[aiohttp.ClientSession]",
    "MilestoneValidator": "static class for validation methods",
    "HDRHistogram": "external histogram library for latency measurement",
    "AllocationMonitor": "hot path memory allocation detection",
    "CoordinatedOmissionLoadTester": "config LoadTestConfig, measurements List[LatencyMeasurement], request_generator BidRequestGenerator",
    "AllocationSource": "MALLOC=1, NEW=2, REALLOC=3, MMAP=4",
    "AuctionStrategy": "abstract base class for pluggable auction algorithms with evaluate_auction and get_latency_budget_ms methods",
    "MLModelInterface": "abstract interface for hot-swappable ML models with predict and get_feature_requirements methods",
    "PrivacyProcessor": "base class for privacy-preserving transformations with process_user_data method",
    "ExtensionRegistry": "registry for dynamic loading of extensions with auction strategies, ML models, and privacy processors",
    "FeatureStore": "memory-mapped storage for user features with get_user_features and update_features_batch methods",
    "FPGAAccelerator": "interface for FPGA-based parallel campaign evaluation",
    "DifferentialPrivacyEngine": "privacy-preserving noise addition with configurable epsilon and delta parameters",
    "BlockchainSettlement": "blockchain integration for settlement with submit_settlement_batch method",
    "ExtensionPerformanceMonitor": "monitoring system for extension performance with latency tracking and health reporting",
    "GlossaryValidator": "preferred_terms Dict, deprecated_terms Dict, violation_patterns compiled",
    "TerminologyLinter": "required_patterns Dict",
    "DocumentationGenerator": "static methods for term extraction",
    "OnboardingValidator": "terms Dict, critical_terms Set"
  },
  "methods": {
    "process_bid_request(request: BidRequest) -> Optional[BidResponse]": "core auction processing under 5ms",
    "evaluate_targeting(user_profile: Dict, campaign: Dict, request: BidRequest) -> bool": "targeting rule evaluation under 0.5ms",
    "calculate_bid_price(campaign: Dict, slot: AdSlot, competition_level: float) -> float": "bid price calculation under 0.1ms",
    "get_timestamp_us() -> int": "microsecond timestamp with minimal overhead",
    "fast_hash(data: bytes) -> int": "FNV-1a hash for cache keys",
    "serialize_bid_response(response: BidResponse) -> bytes": "zero-copy serialization under 0.1ms",
    "parse_bid_request(data: bytes) -> BidRequest": "high-speed parsing under 0.2ms",
    "record_request_latency(latency_microseconds: int, request_type: str)": "record latency without locks",
    "record_business_outcome(auction_won: bool, cpm_cents: int, advertiser_id: str)": "record business metrics",
    "register_connection(fd: int, remote_addr: str, remote_port: int) -> bool": "register new connection in pool",
    "get_connection(fd: int) -> Optional[ConnectionState]": "O(1) connection lookup",
    "enqueue(request: BidRequest) -> bool": "producer enqueue operation",
    "dequeue(consumer_id: int) -> Optional[BidRequest]": "consumer dequeue operation",
    "get_user_profile(user_id: str) -> Optional[Dict]": "retrieve user profile with cache fallback",
    "compile_campaign_targeting(campaign: Dict) -> Dict": "compile targeting rules to bitsets",
    "evaluate_user_match(user_profile: Dict, compiled_targeting: Dict) -> bool": "fast bitset targeting evaluation",
    "process_telemetry_batch(events: List[TelemetryEvent]) -> List[Dict]": "process batch of telemetry events and return anomaly alerts",
    "filter_telemetry_batch(events: List[TelemetryEvent]) -> List[TelemetryEvent]": "filter batch using SIMD operations",
    "is_blacklisted(entity_id: str, entity_type: str) -> bool": "fast blacklist lookup without locks",
    "add_entry(entry: BlacklistEntry) -> bool": "add entry with conflict resolution",
    "_simd_blacklist_check(ip_array: ndarray, hash_array: ndarray) -> ndarray": "parallel blacklist lookup using SIMD",
    "_check_ip_volume_anomaly(ip_address: int, current_count: int, bucket_timestamp: int) -> Optional[Dict]": "check if IP volume is anomalous",
    "update_blacklist_arrays(ip_blacklist: Set, hash_blacklist: Set)": "update arrays for SIMD operations",
    "evaluate_budget_availability(request: BudgetEvaluationRequest) -> BudgetEvaluationResponse": "evaluate budget availability under 1ms",
    "sync_with_global_state() -> bool": "synchronize regional budget state with global coordinator every 30 seconds",
    "handle_settlement_confirmation(auction_id: str, final_cost_cents: int) -> bool": "process confirmed spend from settlement system and update budget tracking",
    "append_event(event: FinancialEvent) -> bool": "append financial event with thread safety",
    "is_duplicate(event: FinancialEvent) -> bool": "check if event is a duplicate using content fingerprints",
    "is_event_too_late(event: FinancialEvent) -> bool": "check if event arrived too late to be accepted",
    "record_spend(amount_cents: int, timestamp_us: int)": "record a spend event for velocity calculation",
    "get_current_velocity_cpm() -> float": "calculate current spend velocity in cents per minute",
    "flush() -> bool": "force flush current batch of events to disk",
    "enqueue(item: T) -> bool": "producer enqueue operation",
    "dequeue(consumer_id: int) -> Optional[T]": "consumer dequeue operation",
    "register_consumer(consumer_id: int) -> bool": "register new consumer thread",
    "call(func: Callable, *args, **kwargs) -> Any": "execute function with circuit breaker protection",
    "update_load_level(system_health: dict) -> float": "calculate system load level",
    "get_admission_policy(exchange_tier: str) -> dict": "get admission control policy",
    "call(func, *args, **kwargs) -> Any": "execute function with circuit breaker protection",
    "should_admit_request(request, system_health) -> bool": "determine if request should be accepted based on load",
    "update_load_level(system_health) -> float": "calculate system load level",
    "get_admission_policy(exchange_tier) -> dict": "get admission control policy",
    "process_bid_request(request) -> Optional[BidResponse]": "core auction processing under 5ms",
    "enqueue(item) -> bool": "producer enqueue operation",
    "dequeue(consumer_id) -> Optional[T]": "consumer dequeue operation",
    "record_measurement(measurement: LatencyMeasurement)": "record latency measurement thread-safely",
    "get_summary() -> Dict": "generate performance summary statistics",
    "generate_bid_request() -> Dict": "generate realistic BidRequest for testing",
    "send_request() -> LatencyMeasurement": "send single bid request with precise timing",
    "run_load_pattern()": "execute load pattern with coordinated omission avoidance",
    "validate_milestone_1_gateway(results: Dict) -> bool": "validate C10M Gateway performance criteria",
    "validate_milestone_2_bidding(results: Dict) -> bool": "validate Ultra-Low Latency Bidding criteria",
    "validate_milestone_3_fraud_detection(results: Dict) -> bool": "validate Fraud Detection at Scale criteria",
    "validate_milestone_4_global_state(results: Dict) -> bool": "validate Global State & Settlement criteria",
    "run_load_test(config: LoadTestConfig) -> Dict": "execute comprehensive load test with multiple clients",
    "get_cache_statistics() -> Dict[str, float]": "calculate cache hit ratios from hardware counters",
    "mark_thread_hot_path(thread_id: int)": "mark thread as executing hot path",
    "detect_allocation_violation(size: int, source: AllocationSource) -> bool": "detect allocation in hot path",
    "run_client_pattern(client_id: int) -> List[LatencyMeasurement]": "run load pattern with coordinated omission correction",
    "analyze_coordinated_omission(measurements: List[LatencyMeasurement]) -> Dict[str, float]": "detect and correct coordinated omission",
    "dequeue() -> Optional[T]": "consumer dequeue operation",
    "evaluate_auction(request: BidRequest, campaigns: List[CampaignData]) -> BidResponse": "implement auction-specific logic for bid evaluation",
    "get_latency_budget_ms() -> float": "return maximum allowed processing time for auction strategy",
    "predict(features: Dict[str, float]) -> float": "execute ML model inference within latency budget",
    "get_feature_requirements() -> List[str]": "return list of required feature names and versions",
    "process_user_data(user_profile: UserProfile, consent_level: str) -> UserProfile": "apply privacy transformations based on user consent level",
    "register_auction_strategy(name: str, strategy: AuctionStrategy)": "register new auction strategy with validation",
    "register_ml_model(name: str, model: MLModelInterface)": "register ML model with latency budget compliance check",
    "get_user_features(user_id: str) -> Optional[Dict[str, float]]": "retrieve user features from memory-mapped storage",
    "update_features_batch(user_features: Dict[str, Dict[str, float]])": "atomically update multiple user feature vectors",
    "evaluate_campaigns_parallel(user_profile: UserProfile, campaigns: List[CampaignData]) -> List[bool]": "parallel campaign evaluation using FPGA acceleration",
    "add_privacy_noise(value: float, sensitivity: float) -> float": "add calibrated privacy noise to preserve differential privacy",
    "submit_settlement_batch(events: List[FinancialEvent]) -> str": "submit financial events to blockchain for immutable settlement",
    "record_extension_latency(extension_name: str, latency_ms: float)": "record latency measurement for performance monitoring",
    "get_extension_health() -> Dict[str, str]": "return health status and performance metrics for all extensions",
    "_load_glossary(path) -> Dict": "parse glossary markdown into term dictionary",
    "_load_deprecated_terms() -> Dict": "load old-to-new term mappings",
    "validate_file(file_path) -> List": "check single file for terminology violations",
    "validate_codebase(root_path) -> Dict": "validate entire codebase terminology",
    "check_ast_node(node) -> List": "AST-based terminology validation",
    "extract_terms_from_code(root_path) -> Dict": "extract terminology from source code",
    "generate_code_glossary(term_usage) -> str": "create glossary from code analysis",
    "generate_quiz_questions(difficulty) -> List": "create terminology validation questions",
    "evaluate_targeting(user_profile, campaign, request) -> bool": "targeting evaluation under 0.5ms",
    "setup_connection_pool()": "initialize C10M connection handling"
  },
  "constants": {
    "RTB_LATENCY_BUDGET_MS": "10ms maximum response time",
    "AUCTION_PROCESSING_TARGET_MS": "5ms auction processing target",
    "TARGETING_EVAL_TARGET_MS": "0.5ms targeting evaluation target",
    "SERIALIZATION_TARGET_MS": "0.1ms serialization target",
    "QPS_TARGET": "1,000,000 queries per second",
    "CONCURRENT_CONNECTIONS": "10,000,000 connection target",
    "RING_BUFFER_SIZE": "65536 power-of-2 buffer size"
  },
  "terms": {
    "Real-Time Bidding (RTB)": "automated auction for ad impressions in milliseconds",
    "Demand-Side Platform (DSP)": "platform representing advertisers in RTB auctions",
    "Supply-Side Platform (SSP)": "platform representing publishers in RTB auctions",
    "Ad Exchange": "marketplace coordinating RTB auctions",
    "CPM": "cost per mille - price per thousand impressions",
    "Second-Price Auction": "winner pays second-highest bid price",
    "Zero-Copy I/O": "data transfer without memory copies",
    "Lock-Free Programming": "concurrency without mutex locks",
    "Hot Path": "critical code path executed at high frequency",
    "Tail Latency": "high percentile latency measurements",
    "Circuit Breaker": "fail-fast pattern for service protection",
    "NUMA": "Non-Uniform Memory Access topology",
    "bitset encoding": "compact representation using bit arrays",
    "SIMD-accelerated": "Single Instruction Multiple Data parallel processing",
    "object pools": "pre-allocated memory pools for zero-allocation paths",
    "cache-line aligned": "memory layout optimized for CPU cache access",
    "C10M problem": "handling 10 million concurrent connections",
    "io_uring": "modern Linux async I/O interface",
    "SPMC": "Single Producer Multiple Consumer pattern",
    "memory ordering": "atomic operation synchronization semantics",
    "false sharing": "cache line contention between CPU cores",
    "timing wheel": "efficient timeout detection algorithm",
    "hot path": "critical code path executed at high frequency",
    "second-price auction": "winner pays second-highest bid price",
    "zero-copy I/O": "data transfer without memory copies",
    "sliding window": "time-based data aggregation with continuous updates",
    "vector clocks": "logical timestamps for distributed event ordering",
    "circular buffer": "fixed-size buffer with wraparound for efficient sliding windows",
    "blacklist propagation": "distributing fraud signals across instances",
    "anomaly detection": "statistical identification of unusual patterns",
    "lock-free programming": "concurrency without mutex locks",
    "eventually consistent": "system where data converges to consistency over time",
    "immutable event sourcing": "storing all changes as a sequence of immutable events rather than updating state in place",
    "content fingerprinting": "unique hashes for duplicate detection",
    "predictive budget allocation": "estimating future spend based on velocity trends to prevent overspend",
    "atomic budget transfer": "moving budget responsibility between regions as a single indivisible operation",
    "audit trail": "immutable record of all financial transactions and decisions for compliance",
    "regional failover": "automatically switching traffic and responsibilities to backup regions during failures",
    "settlement reconciliation": "matching raw transaction events with final billing records to ensure accuracy",
    "late event handling": "processing financial events that arrive after normal time windows due to network delays",
    "circuit breaker": "fail-fast pattern for service protection",
    "backpressure": "flow control mechanism to prevent system overload",
    "load shedding": "selective request dropping to maintain system stability",
    "admission control": "policy-based request acceptance",
    "graceful degradation": "maintaining partial functionality under overload",
    "cascade failure": "failure propagation across system components",
    "half-open state": "circuit breaker testing recovery with limited requests",
    "false positive": "incorrectly identifying normal traffic as failure",
    "tail latency": "high percentile latency measurements",
    "coordinated omission": "load testing anti-pattern reducing load when system slows",
    "HDR Histogram": "high dynamic range histogram for latency measurement",
    "observer effect": "measurement process affecting the system being measured",
    "statistical process control": "using statistics to detect performance regressions",
    "hardware performance counters": "CPU registers tracking execution metrics",
    "extension points": "architectural provisions for new capabilities",
    "shadow deployment": "parallel validation without affecting outcomes",
    "plugin-based extensions": "modular architecture allowing new features to be added as isolated components",
    "hot-swappable processing pipelines": "ability to update system components in real-time without service restart",
    "dual-path strategy": "separate fast and slow processing paths for real-time decisions vs complex analysis",
    "memory-mapped shared segments": "shared memory regions for sub-millisecond data access across processes",
    "differential privacy": "privacy-preserving noise addition technique",
    "federated learning": "distributed training without centralizing data",
    "header bidding": "auction technique where multiple ad exchanges compete simultaneously in the browser",
    "private marketplaces": "invitation-only auctions with deal-specific pricing and priority rules",
    "FPGA acceleration": "hardware acceleration using Field Programmable Gate Arrays for parallel computation",
    "blockchain settlement": "using distributed ledger technology for immutable financial transaction recording",
    "zero-copy data pipeline": "data processing without intermediate memory copies for maximum performance",
    "forward-compatible schemas": "data structures designed to accommodate new fields without breaking existing code",
    "event sourcing": "storing changes as immutable event sequence"
  }
}