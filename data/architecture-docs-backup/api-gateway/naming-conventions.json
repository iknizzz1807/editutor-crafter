{
  "types": {
    "Route": "fields: ID string, Description string, Match RouteMatch, UpstreamID string, Plugins []PluginConfig",
    "RouteMatch": "fields: Path string, Method string, Headers map[string]string",
    "Upstream": "fields: ID string, Name string, Endpoints []Endpoint",
    "Endpoint": "fields: ID string, URL string",
    "PluginConfig": "fields: Name string, Config map[string]interface{}",
    "Config": "fields: ListenAddr string, Routes []Route, Upstreams []Upstream",
    "RequestContext": "fields: RequestID string, StartTime time.Time, ClientIP string, Authenticated bool, UserID string, UserRoles []string, AuthMethod string, MatchedRoute *Route, SelectedUpstream *Upstream, SelectedEndpoint *Endpoint, RequestBody []byte, ResponseBody []byte, LogFields map[string]interface{}, CustomMetrics map[string]float64, Error error, HTTPErrorCode int, innerCtx context.Context, cancelFn context.CancelFunc",
    "Pipeline": "fields: preProcess []middleware.Middleware, coreProcess []middleware.Middleware, postProcess []middleware.Middleware",
    "Chain": "fields: middleware []Middleware",
    "RouterImpl": "fields: routes map[string]Route, upstreams map[string]Upstream, tree *radix.Tree, mu sync.RWMutex",
    "GatewayProxy": "fields: proxy *httputil.ReverseProxy",
    "RoundRobinLoadBalancer": "fields: upstreamID string, endpoints []*Endpoint, healthStatus map[string]bool, index uint32, mu sync.RWMutex",
    "CircuitBreaker": "fields: endpointID string, failureThreshold int, openTimeout time.Duration, state CircuitState, failures int, lastFailureTime time.Time, mu sync.Mutex",
    "CircuitState": "constants: StateClosed, StateOpen, StateHalfOpen",
    "HeaderTransformerConfig": "fields: Request HeaderOps, Response HeaderOps",
    "HeaderOps": "fields: Add map[string]string, Remove []string, Rewrite map[string]string",
    "JSONTransformConfig": "fields: Request JSONTransformOps, Response JSONTransformOps",
    "JSONTransformOps": "fields: Mappings []FieldMapping, Remove []string, Add map[string]interface{}",
    "FieldMapping": "fields: From string, To string",
    "LimitedReadCloser": "fields: Reader io.Reader, Closer io.Closer",
    "BodySizeError": "fields: Max int64, Actual int64",
    "RequestTemplateData": "fields: RequestID string, ClientIP string, Timestamp time.Time, UserID string, UserRoles []string, AuthMethod string",
    "HeaderTransformer": "fields: config HeaderTransformerConfig",
    "JSONTransformer": "fields: config JSONTransformConfig, maxBodySize int64",
    "responseWriterWrapper": "fields: ResponseWriter http.ResponseWriter, transformer *HeaderTransformer, ctx *middleware.RequestContext, wroteHeader bool",
    "PluginManager": "fields: mu sync.RWMutex, registry map[string]PluginFactory",
    "MetricsPlugin": "fields: config MetricsConfig, requestCounter *prometheus.CounterVec, requestDuration *prometheus.HistogramVec, requestSize *prometheus.HistogramVec, responseSize *prometheus.HistogramVec",
    "MetricsConfig": "fields: MetricPrefix string, EnableSizeHist bool, NormalizePaths []string",
    "TracingPlugin": "fields: config TracingConfig, tracer trace.Tracer, propagator propagation.TextMapPropagator",
    "WebSocketProxy": "fields: upstream *Upstream, dialer *websocket.Dialer, maxMsgSize int64",
    "GraphQLFederationPlugin": "fields: schema *graphql.Schema, resolvers map[string]Resolver, planner QueryPlanner",
    "GraphQLRoute": "fields: Route Route, SchemaURL string, Resolvers []Resolver, QueryPlanCacheSize int",
    "Resolver": "fields: FieldPath string, BackendType string, Operation ResolverOp, BatchConfig BatchConfig",
    "ConfigChange": "fields: ID string, Timestamp time.Time, User string, Comment string, Config Config, ParentID string"
  },
  "methods": {
    "LoadFromFile(filepath string) (*Config, error)": "reads and parses a YAML configuration file",
    "validate(cfg *Config) error": "performs basic sanity checks on the configuration",
    "NewRequestContext(r *http.Request) *RequestContext": "creates a new context for a request",
    "Context() context.Context": "returns the Go context for cancellation and timeouts",
    "Cancel()": "cancels the request context",
    "AddLogField(key string, value interface{})": "adds a field to the structured log",
    "ElapsedTime() time.Duration": "returns time since request started",
    "NewPipeline(cfg *config.Config) (*Pipeline, error)": "creates a pipeline from configuration",
    "Execute(w http.ResponseWriter, r *http.Request)": "runs the request through the complete pipeline",
    "Name() string": "Returns plugin's unique identifier",
    "Execute(ctx *RequestContext, w http.ResponseWriter, r *http.Request) bool": "Performs plugin logic, returns true to continue chain",
    "Priority() int": "Determines execution order",
    "NewChain(middleware ...Middleware) *Chain": "creates a new middleware chain",
    "FindRoute(r *http.Request) (*Route, *Upstream, *Endpoint, error)": "Matches request to route and selects healthy endpoint.",
    "RegisterRoute(route Route) error": "Adds route to routing table.",
    "RefreshHealth(upstreamID string)": "Triggers health re-evaluation.",
    "SelectEndpoint() (*Endpoint, error)": "Returns a healthy endpoint using round-robin.",
    "AllowRequest() bool": "Determines if circuit breaker allows a request.",
    "RecordSuccess()": "Resets breaker on success.",
    "RecordFailure()": "Records a failure and may trip breaker.",
    "NewHeaderTransformer(cfg map[string]interface{}) (*HeaderTransformer, error)": "Creates a new header transformer from configuration",
    "ExecuteHeaderTemplate(tmplStr string, data *RequestTemplateData) (string, error)": "Expands a template string using request data",
    "ReadRequestBody(r *http.Request, maxBytes int64) ([]byte, error)": "Reads and returns request body with size limit",
    "IsBodySizeError(err error) bool": "checks if error is a body size limit error",
    "transformJSON(data map[string]interface{}, ops JSONTransformOps) map[string]interface{}": "Applies transformations to a JSON object",
    "GlobalManager() *PluginManager": "Returns singleton plugin manager",
    "RegisterPlugin(name string, factory PluginFactory) error": "Registers plugin factory by name",
    "CreatePlugin(name string, config map[string]interface{}) (middleware.Plugin, error)": "Instantiates plugin by name with config",
    "CreateChain(configs []PluginConfig) (*middleware.Chain, error)": "Creates middleware chain from plugin configs",
    "CategorizeError(err error, statusCode int) string": "categorizes errors as client/backend/gateway for metrics and handling",
    "RecoveryMiddleware.Execute(ctx *RequestContext, w http.ResponseWriter, r *http.Request) bool": "recovers from panics and converts to 500 errors",
    "ErrorHandlerMiddleware.Execute(ctx *RequestContext, w http.ResponseWriter, r *http.Request) bool": "formats all errors consistently as JSON responses",
    "HandleUpgrade(w http.ResponseWriter, r *http.Request, ctx *RequestContext) error": "processes HTTP WebSocket upgrade requests",
    "copyClientToBackend(clientConn, backendConn *websocket.Conn, ctx *RequestContext)": "handles messages from client to backend",
    "buildExecutionPlan(query string) (*ExecutionPlan, error)": "creates an optimized plan for a GraphQL query"
  },
  "constants": {
    "StateClosed": "0",
    "StateOpen": "1",
    "StateHalfOpen": "2"
  },
  "terms": {
    "API Gateway": "centralized entry point managing traffic between clients and backend services",
    "Microservices": "architectural style structuring an application as a collection of loosely coupled services",
    "Cross-cutting concerns": "functionality that spans multiple services (e.g., auth, logging)",
    "Concierge Pattern": "mental model comparing the gateway to a hotel concierge",
    "Off-the-shelf": "pre-built, configurable software solutions",
    "Configurable Proxy": "general-purpose proxy software (e.g., NGINX) used as a gateway via configuration",
    "North-South traffic": "traffic between external clients and internal services",
    "East-West traffic": "traffic between internal services",
    "Scope creep": "uncontrolled expansion of a project's goals and features",
    "Stateless": "design where each request is independent",
    "Backend-for-Frontend (BFF)": "a backend service tailored to a specific client type",
    "Pipeline Pattern": "architectural pattern where requests flow through a series of processing stages",
    "Middleware": "Software component that processes requests in a chain",
    "RequestContext": "Object that carries state through the request processing pipeline",
    "Radix Tree": "A compressed prefix tree for efficient string matching.",
    "Assembly Line": "mental model comparing request processing to a manufacturing assembly line",
    "Five Layers": "Ingress, Pre-Processing, Core, Post-Processing, Egress - the logical layers of the gateway",
    "Passive Health Check": "Monitoring backend health based on real request outcomes.",
    "Active Health Check": "Periodically probing backends with synthetic requests.",
    "Circuit Breaker": "A resilience pattern that fails fast after repeated failures.",
    "Director function": "httputil.ReverseProxy callback to modify outgoing requests.",
    "X-Forwarded-For": "HTTP header for passing original client IP through proxies.",
    "Content-Type": "HTTP header indicating the media type of the resource",
    "Content-Length": "HTTP header indicating the size of the entity-body in bytes",
    "JSON Transformation": "Modification of JSON request/response bodies including field renaming, addition, and removal",
    "Header Manipulation": "Addition, removal, or modification of HTTP headers",
    "URL Rewriting": "Modification of request path and query parameters",
    "Request Aggregation": "Combining responses from multiple backend calls into a single client response",
    "Buffer": "Temporary storage area for data being transformed",
    "Streaming": "Processing data as it flows through without complete buffering",
    "Idempotent": "HTTP methods that produce the same result if executed multiple times",
    "Observability": "The ability to understand a system's internal state through its external outputs: logs, metrics, and traces",
    "Plugin": "A self-contained module that implements a standard interface to extend gateway functionality",
    "Plugin Chain": "Ordered sequence of plugins executed during request processing",
    "Structured Logging": "Logging that emits events in a machine-readable format (e.g., JSON) with consistent fields",
    "Metrics": "Quantitative measurements of system behavior over time, exposed for monitoring",
    "Tracing": "Recording the flow of a request through distributed system components",
    "High-Cardinality": "A label dimension with many unique values, problematic for metrics systems",
    "PII": "Personally Identifiable Information, sensitive data that must be protected",
    "Short-circuit": "Early termination of pipeline processing due to error or rejection",
    "Emergency Stop Chain": "mental model for error termination in a pipeline",
    "emergency stop chain": "mental model for error termination in a pipeline",
    "triage nurse": "mental model for categorizing and handling different error types",
    "graceful degradation": "systematically reducing functionality to maintain availability during partial failures",
    "short-circuit": "early termination of pipeline processing due to error or rejection",
    "circuit breaking": "resilience pattern that fails fast after repeated failures to prevent cascading failures",
    "fallback responses": "pre-configured static responses returned when backend services are unavailable",
    "configuration reload races": "concurrency issues when reloading gateway configuration while processing requests",
    "idempotent": "HTTP methods that produce the same result if executed multiple times",
    "exponential backoff": "retry strategy with increasing delays between attempts",
    "copy-on-write": "technique where new configuration is built before atomically swapping with old",
    "Testing Pyramid": "A strategy that uses a large number of unit tests, fewer integration tests, and even fewer end-to-end tests",
    "Quality Assurance Funnel": "Mental model for the testing pyramid where bugs are filtered through multiple layers",
    "Arrange-Act-Assert": "A pattern for structuring unit tests",
    "Mock": "A simulated object that mimics the behavior of real objects in controlled ways",
    "Integration Test": "Test that verifies the interaction between multiple components",
    "End-to-End Test": "Test that verifies the complete system behavior from user perspective",
    "Race Condition": "When the behavior of software depends on the relative timing of events",
    "Code Coverage": "Percentage of code executed by tests",
    "Table-Driven Tests": "Testing pattern where test cases are defined in a table structure",
    "WebSocket Proxying": "extending the gateway to handle bidirectional WebSocket connections",
    "GraphQL Federation": "composing multiple backend services into a unified GraphQL schema",
    "WASM Plugin Runtime": "extending the plugin system to support WebAssembly modules",
    "Administrative REST API": "exposing gateway configuration and controls through a RESTful API",
    "connection pooling": "maintaining a fixed pool of backend connections that client connections share",
    "query planning": "decomposing GraphQL queries into backend requests",
    "WASI Sandbox": "WebAssembly System Interface providing controlled filesystem and network access",
    "configuration atomicity": "updates to multiple related resources applied atomically",
    "Triage nurse": "mental model for categorizing and handling different error types",
    "Graceful degradation": "systematically reducing functionality to maintain availability during partial failures",
    "Circuit breaking": "resilience pattern that fails fast after repeated failures to prevent cascading failures",
    "Fallback responses": "pre-configured static responses returned when backend services are unavailable",
    "Configuration reload races": "concurrency issues when reloading gateway configuration while processing requests",
    "Exponential backoff": "retry strategy with increasing delays between attempts",
    "Copy-on-write": "technique where new configuration is built before atomically swapping with old",
    "Connection pooling": "maintaining a fixed pool of backend connections that client connections share",
    "Query planning": "decomposing GraphQL queries into backend requests",
    "Configuration atomicity": "updates to multiple related resources applied atomically"
  }
}