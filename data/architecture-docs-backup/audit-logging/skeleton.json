{
  "title": "Tamper-Evident Audit Logging System: Design Document",
  "overview": "This system provides a cryptographically-secure, immutable audit trail for compliance, capturing who did what, when, and to which resource. Its key architectural challenge is balancing the need for absolute data integrity and efficient querying of a continuously growing, append-only dataset. It solves this by using a hash chain for tamper detection, immutable storage segments, and indexed time-series queries.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains why audit logging is a critical compliance requirement, the specific challenges of tamper-evidence and query efficiency, and compares existing logging approaches.",
      "subsections": [
        {
          "id": "analogy-compliance-logbook",
          "title": "Mental Model: The Ship's Tamper-Proof Logbook",
          "summary": "Uses the analogy of a ship's logbook sealed with wax to explain the core concepts of an immutable, verifiable audit trail."
        },
        {
          "id": "problem-deep-dive",
          "title": "The Core Problem: Verifiable Integrity at Scale",
          "summary": "Details the requirements from SOC 2/GDPR, the tension between append-only writes and historical queries, and why simple database tables fail."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches and Trade-offs",
          "summary": "Compares database tables, specialized time-series databases, and blockchain-inspired hash chains in a structured table."
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the mandatory system capabilities (Goals) and explicitly scopes out features not required for this project (Non-Goals).",
      "subsections": [
        {
          "id": "goals-list",
          "title": "Goals: What the System Must Achieve",
          "summary": "Lists functional requirements: immutable storage, hash chain integrity, structured event model, efficient time-range queries, and compliance exports."
        },
        {
          "id": "non-goals-list",
          "title": "Non-Goals: Explicit Scoping",
          "summary": "Clarifies that real-time alerting, multi-region replication, and full-text search over all event data are out of scope."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Presents the bird's-eye view of system components (Ingestor, Storage Engine, Query Engine) and their interactions, supported by a component diagram.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview and Responsibilities",
          "summary": "Describes the role of the Ingestor, Storage Engine (with Write-Ahead Log and Segment Manager), and Query Engine."
        },
        {
          "id": "file-structure",
          "title": "Recommended File and Module Structure",
          "summary": "Provides a suggested Go project layout to organize the codebase, separating core models, storage, query logic, and utilities."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the structure of an Audit Event, the Hash Chain Entry, and the Storage Segment. Described with tables for fields, types, and purposes.",
      "subsections": [
        {
          "id": "audit-event-schema",
          "title": "Audit Event Schema (Milestone 1)",
          "summary": "Tables defining core fields (actor, action, resource, timestamp, outcome) and the extensible metadata container."
        },
        {
          "id": "storage-data-structures",
          "title": "Storage Data Structures (Milestone 2)",
          "summary": "Tables defining the Hash Chain Entry (sequence, prev_hash, event_hash, signature) and the Segment manifest file."
        }
      ]
    },
    {
      "id": "component-event-model",
      "title": "Component Design: Event Model & Serialization",
      "summary": "Details the design of the Audit Event, its validation, serialization formats, and handling of PII/sensitive data. Corresponds to Milestone 1.",
      "subsections": [
        {
          "id": "event-model-mental",
          "title": "Mental Model: The Notary's Stamped Form",
          "summary": "Analogy explaining how the event model is like a standardized, timestamped form filled out for every significant action."
        },
        {
          "id": "event-interface",
          "title": "Interface: Event Creation and Validation",
          "summary": "Table of methods for creating, validating, and serializing audit events."
        },
        {
          "id": "adr-serialization-format",
          "title": "ADR: Choosing a Serialization Format",
          "summary": "Decision record comparing JSON, Protobuf, and a custom binary format for event storage."
        },
        {
          "id": "pitfalls-event-model",
          "title": "Common Pitfalls: Context Loss and PII",
          "summary": "Discusses losing async context, logging raw PII, and schema evolution mistakes."
        },
        {
          "id": "impl-guidance-event-model",
          "title": "Implementation Guidance for Event Model",
          "summary": "Provides starter code for validation utilities, PII masking, and skeleton code for the core Event struct and builder in Go."
        }
      ]
    },
    {
      "id": "component-immutable-storage",
      "title": "Component Design: Immutable Storage Engine",
      "summary": "Describes the append-only Write-Ahead Log (WAL), hash chain construction, segment rotation, and integrity verification. Corresponds to Milestone 2.",
      "subsections": [
        {
          "id": "storage-mental-model",
          "title": "Mental Model: The Blockchain Ledger Page",
          "summary": "Analogy comparing storage segments to pages in a ledger, where each entry references the hash of the previous one."
        },
        {
          "id": "storage-interface",
          "title": "Interface: Append and Read Operations",
          "summary": "Table of methods for appending events, reading by offset/sequence, and verifying the hash chain."
        },
        {
          "id": "adr-hash-chain-vs-merkle",
          "title": "ADR: Hash Chain vs. Merkle Tree for Integrity",
          "summary": "Decision record comparing the linear hash chain (simpler, ordered) with Merkle trees (efficient for proofs)."
        },
        {
          "id": "pitfalls-storage",
          "title": "Common Pitfalls: fsync, Clock Skew, Chain Breaks",
          "summary": "Discusses forgetting fsync, using system time for ordering, and breaking the hash chain during backups."
        },
        {
          "id": "impl-guidance-storage",
          "title": "Implementation Guidance for Storage Engine",
          "summary": "Provides starter code for a WAL file wrapper, skeleton code for the segment manager and hash chain logic in Go, with TODOs for core algorithms."
        }
      ]
    },
    {
      "id": "component-query-export",
      "title": "Component Design: Query & Export Engine",
      "summary": "Covers the design of indexed time-range queries, filtering, cursor-based pagination, and streaming exports to compliance formats. Corresponds to Milestone 3.",
      "subsections": [
        {
          "id": "query-mental-model",
          "title": "Mental Model: The Library Index Card System",
          "summary": "Analogy comparing querying to using a library's catalog (indexes) to find books (events) by author, title, or publication date."
        },
        {
          "id": "query-interface",
          "title": "Interface: Query, Paginate, and Export",
          "summary": "Table of methods for executing filtered queries, getting the next page, and generating export files."
        },
        {
          "id": "adr-indexing-strategy",
          "title": "ADR: Indexing Strategy for Time-Series Logs",
          "summary": "Decision record comparing indexing on timestamp+sequence vs. secondary indexes on actor/resource."
        },
        {
          "id": "pitfalls-query",
          "title": "Common Pitfalls: Pagination, Memory, Timezones",
          "summary": "Discusses offset-based pagination inefficiency, loading entire results into memory, and inconsistent UTC handling."
        },
        {
          "id": "impl-guidance-query",
          "title": "Implementation Guidance for Query Engine",
          "summary": "Provides starter code for a time-range iterator and CSV streaming writer, skeleton code for the query builder and export generator in Go."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Traces the journey of an audit event from creation through ingestion, storage, and query, using sequence diagrams and message format tables.",
      "subsections": [
        {
          "id": "sequence-ingestion",
          "title": "Sequence: Event Ingestion and Storage",
          "summary": "Step-by-step walkthrough and sequence diagram showing an event being validated, appended to the WAL, and the hash chain updated."
        },
        {
          "id": "sequence-query",
          "title": "Sequence: Executing a Query and Export",
          "summary": "Step-by-step walkthrough and sequence diagram showing a query being parsed, segments being searched, and results streamed for export."
        }
      ]
    },
    {
      "id": "error-handling-edge-cases",
      "title": "Error Handling and Edge Cases",
      "summary": "Catalogues failure modes (disk full, corrupt segment, clock drift) and defines recovery strategies for each component.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "Failure Modes and Detection",
          "summary": "Table listing potential failures in ingestion, storage, and query phases, along with how to detect them."
        },
        {
          "id": "recovery-strategies",
          "title": "Recovery Strategies",
          "summary": "Describes procedures for handling a broken hash chain, recovering from a full disk, and dealing with non-monotonic sequence numbers."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "summary": "Outlines property-based, integration, and performance tests. Includes specific checkpoint validations for each milestone.",
      "title": "Testing Strategy",
      "subsections": [
        {
          "id": "test-approaches",
          "title": "Test Approaches and Scenarios",
          "summary": "Describes unit tests for validation, property tests for hash chain integrity, integration tests for query correctness, and load tests for ingestion."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Implementation Checkpoints",
          "summary": "For each milestone, provides a concrete command to run and expected output to verify the component is working correctly."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "A practical guide for diagnosing common implementation bugs, with symptom-cause-fix tables and targeted logging advice.",
      "subsections": [
        {
          "id": "common-bugs-table",
          "title": "Common Bugs: Symptom \u2192 Cause \u2192 Fix",
          "summary": "Table listing issues like 'Hash verification fails after restart' or 'Query returns duplicate events' with diagnosis steps and solutions."
        },
        {
          "id": "techniques-tools",
          "title": "Debugging Techniques and Tools",
          "summary": "Recommends adding verbose logging to the hash chain computation, using hex dumps for corrupt files, and building a simple verification CLI tool."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Explores how the design accommodates potential future features like real-time streaming, advanced compression, or integration with SIEM systems.",
      "subsections": [
        {
          "id": "extension-ideas",
          "title": "Possible Enhancements",
          "summary": "Lists ideas: Kafka integration for event streaming, Zstandard compression for old segments, and Bloom filters for faster 'actor-not-found' queries."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of all key terms, acronyms, and domain-specific vocabulary used throughout the document.",
      "subsections": [
        {
          "id": "terms-table",
          "title": "Terms and Definitions",
          "summary": "Alphabetical list of terms like ADR, Hash Chain, PII, Segment, WAL, with clear definitions and reference to their first section."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-component-diagram",
      "title": "System Component Overview",
      "description": "Shows the three main components (Ingestor, Storage Engine, Query Engine), their sub-components (WAL, Segment Manager, Index), and the flow of events and queries between them. Include external systems like the main application and compliance tools.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture"
      ]
    },
    {
      "id": "data-model-class-diagram",
      "title": "Data Model Relationships",
      "description": "Shows the relationship between the core data structures: AuditEvent contains Metadata, multiple AuditEvents are stored in a Segment, and each LogEntry in the hash chain points to an AuditEvent and the previous LogEntry's hash.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "hash-chain-sequence",
      "title": "Hash Chain Construction Sequence",
      "description": "Sequence diagram detailing the steps when appending a new event: 1) Client sends event to Ingestor, 2) Ingestor validates, 3) Storage Engine reads previous hash, 4) Computes new hash, 5) Appends entry to WAL, 6) Acknowledges client.",
      "type": "sequence",
      "relevant_sections": [
        "component-immutable-storage",
        "interactions-data-flow"
      ]
    },
    {
      "id": "segment-rotation-state",
      "title": "Segment File Lifecycle State Machine",
      "description": "State machine showing a segment's lifecycle: ACTIVE (accepting writes), SEALED (read-only, being indexed), ARCHIVED (compressed, offloaded), CORRUPT (integrity check failed). Transitions triggered by size, time, or error.",
      "type": "state-machine",
      "relevant_sections": [
        "component-immutable-storage"
      ]
    },
    {
      "id": "query-execution-flowchart",
      "title": "Query Execution Flowchart",
      "description": "Flowchart for processing a query: Start \u2192 Parse filters \u2192 Identify relevant segments (by time range) \u2192 For each segment, check index \u2192 Read and filter events \u2192 Merge results \u2192 Apply pagination \u2192 Stream to client or export file.",
      "type": "flowchart",
      "relevant_sections": [
        "component-query-export",
        "interactions-data-flow"
      ]
    },
    {
      "id": "integrity-verification-flow",
      "title": "Hash Chain Verification Flow",
      "description": "Flowchart for verifying the integrity of the log from a given start point: Read entry N \u2192 Compute its hash (hash(event_n + prev_hash)) \u2192 Compare with stored hash for entry N \u2192 Move to N+1 \u2192 Repeat until mismatch or end of chain.",
      "type": "flowchart",
      "relevant_sections": [
        "component-immutable-storage",
        "debugging-guide"
      ]
    }
  ]
}