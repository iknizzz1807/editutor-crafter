classes: {
  dark_theme: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: false
  }
  highlight: {
    style.stroke: "#3fb950"
    style.stroke-width: 2
    style.bold: true
  }
  note_style: {
    shape: page
    style.fill: "#0f3460"
    style.stroke: "#8b949e"
    style.font-color: "#c9d1d9"
    style.italic: true
  }
}

title: Data Model Relationships
direction: down

model_container: Data Model {
  shape: rectangle
  style.fill: "#16213e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"

  job: Job {
    shape: class
    class: highlight
    - "id: string (primary_key)"
    - "queue_name: string"
    - "payload: string (serialized)"
    - "status: JobStatus"
    - "priority: int"
    - "created_at: timestamp"
    - "enqueued_at: timestamp"
    - "started_at: timestamp"
    - "completed_at: timestamp"
    - "retry_info: RetryInfo"
    + "serialize(): string"
    + "deserialize(data: string): Job"
  }

  queue: Queue {
    shape: class
    class: dark_theme
    - "name: string"
    - "priority: int"
    - "jobs: List of Job"
    + "enqueue(job: Job): boolean"
    + "dequeue(): Job"
    + "size(): int"
  }

  worker: Worker {
    shape: class
    class: dark_theme
    - "id: string"
    - "hostname: string"
    - "queue_name: string"
    - "current_job_id: string"
    - "status: WorkerStatus"
    - "started_at: timestamp"
    - "last_heartbeat: timestamp"
    + "process(job: Job): void"
    + "heartbeat(): void"
    + "shutdown(): void"
  }

  retry_info: RetryInfo {
    shape: class
    class: dark_theme
    - "max_retries: int"
    - "retry_count: int"
    - "retry_delay: int"
    - "retry_reasons: List of string"
    - "last_error: string"
    - "failed_at: timestamp"
    - "next_retry_at: timestamp"
    + "should_retry(): boolean"
    + "increment(): void"
    + "get_delay(): int"
  }

  schedule: Schedule {
    shape: class
    class: dark_theme
    - "id: string"
    - "job_id: string"
    - "cron_expression: string"
    - "next_run_at: timestamp"
    - "last_run_at: timestamp"
    + "calculate_next(): timestamp"
    + "is_due(): boolean"
  }
}

job -> queue: "belongs to"
worker -> queue: "consumes from"
job -> retry_info: "has one"
job -> schedule: "scheduled by (optional)"
schedule -> job: triggers

redis_notes: "Redis Key Structures" {
  class: note_style

  job_key: "job:(job_id)" {
    class: note_style
    label: |md
**Hash Key: job:(job_id)**
- Fields:
  - payload: serialized JSON
  - status: pending/processing/failed/completed
  - queue: queue_name
  - retry_count: int
  - created_at: timestamp
|
  }

  queue_key: "queue:(name)" {
    class: note_style
    label: |md
**Sorted Set: queue:(name)**
- Score: priority (higher = more important)
- Member: job_id
- Operations: ZADD, ZPOPMAX
|
  }

  schedule_key: schedule {
    class: note_style
    label: |md
**Sorted Set: schedule**
- Score: next_run_at (timestamp)
- Member: job_id
- Operation: ZRANGEBYSCORE for due jobs
|
  }

  worker_key: "worker:(hostname)" {
    class: note_style
    label: |md
**Hash Key: worker:(hostname)**
- Fields:
  - status: idle/working/shutdown
  - current_job: job_id
  - queue: queue_name
  - last_heartbeat: timestamp
|
  }
}

model_container -> redis_notes: "persisted to" {
  style.stroke: "#8b949e"
  style.stroke-dash: 3
}