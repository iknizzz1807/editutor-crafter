{
  "types": {
    "elf_binary_t": "fields: buffer unsigned char*, size size_t, ehdr Elf64_Ehdr*, sections section_t**, section_count size_t, segments segment_t**, segment_count size_t, text_section section_t*, symtab section_t*",
    "section_t": "fields: shdr Elf64_Shdr*, name char*, data unsigned char*",
    "segment_t": "fields: phdr Elf64_Phdr*, data unsigned char*",
    "Elf64_Ehdr": "fields: e_ident unsigned char[16], e_type Elf64_Half, e_machine Elf64_Half, e_version Elf64_Word, e_entry Elf64_Addr, e_phoff Elf64_Off, e_shoff Elf64_Off, e_flags Elf64_Word, e_ehsize Elf64_Half, e_phentsize Elf64_Half, e_phnum Elf64_Half, e_shentsize Elf64_Half, e_shnum Elf64_Half, e_shstrndx Elf64_Half",
    "Elf64_Shdr": "fields: sh_name Elf64_Word, sh_type Elf64_Word, sh_flags Elf64_Xword, sh_addr Elf64_Addr, sh_offset Elf64_Off, sh_size Elf64_Xword, sh_link Elf64_Word, sh_info Elf64_Word, sh_addralign Elf64_Xword, sh_entsize Elf64_Xword",
    "Elf64_Phdr": "fields: p_type Elf64_Word, p_flags Elf64_Word, p_offset Elf64_Off, p_vaddr Elf64_Addr, p_paddr Elf64_Addr, p_filesz Elf64_Xword, p_memsz Elf64_Xword, p_align Elf64_Xword",
    "Elf64_Sym": "fields: st_name Elf64_Word, st_info unsigned char, st_other unsigned char, st_shndx Elf64_Half, st_value Elf64_Addr, st_size Elf64_Xword",
    "patch_site_t": "fields: target_offset uint64_t, original_size size_t, new_bytes unsigned char*, new_size size_t, nop_padding unsigned char*, nop_padding_size size_t, applied int",
    "trampoline_t": "fields: code unsigned char*, code_size size_t, original_prologue unsigned char*, prologue_size size_t, relocated_prologue unsigned char*, relocated_size size_t, hook_address uint64_t, target_function_address uint64_t, trampoline_address uint64_t",
    "injected_section_t": "fields: name char*, data unsigned char*, data_size size_t, vaddr uint64_t, shdr Elf64_Shdr*, requires_relocation int, symbol_dependencies char**, dependency_count size_t",
    "error_t": "fields: code int, message char[256], context char[128]",
    "runtime_session_t": "fields: pid pid_t, attached int, original_regs uint64_t[16]",
    "test_suite_t": "fields: tests test_case_t*, count int, passed int, failed int",
    "test_case_t": "fields: name char[MAX_TEST_NAME], command char[MAX_COMMAND], expected_exit_code int, output_file char[256], expected_output_file char[256]",
    "log_level_t": "enumeration type for logging levels",
    "inline_patch_t": "fields: patch_site_t base, uint64_t saved_registers, uint64_t stack_adjustment, int preserve_flags",
    "exit_trampoline_t": "fields: trampoline_t base, uint64_t return_value_slot, uint64_t stack_cleanup_size, int modifies_return_value",
    "arch_plugin_t": "fields: const char* name, uint16_t elf_machine_id, trampoline_t* (*generate_trampoline)(uint64_t, uint64_t), size_t (*get_instruction_length)(const uint8_t*), int (*is_valid_instruction)(const uint8_t*, size_t), unsigned char* (*generate_nop_sled)(size_t), int (*contains_pic_reference)(const uint8_t*, size_t), uint8_t* (*fixup_pic_instruction)(uint8_t*, size_t, uint64_t, uint64_t), const char** argument_registers, const char* return_register, size_t stack_argument_offset, size_t instruction_alignment, size_t max_instruction_size, uint8_t nop_instruction[8], size_t nop_instruction_size",
    "instrumentation_spec_t": "fields: const char* function_name, hook_type_t type, const char* callback_name, argument_spec_t* arguments, condition_t* conditions, action_t* actions",
    "padding_region_t": "fields: uint64_t file_offset, uint64_t size, uint64_t virtual_addr, int is_executable, const char* source",
    "interval_node_t": "fields: uint64_t start, uint64_t end, interval_node_t* left, interval_node_t* right"
  },
  "methods": {
    "elf_load(filename char*) returns elf_binary_t*": "Load ELF file into memory representation",
    "elf_find_section(binary elf_binary_t*, name char*) returns section_t*": "Find section by name",
    "elf_get_symbol_address(binary elf_binary_t*, symbol_name char*) returns uint64_t": "Get virtual address of symbol",
    "elf_binary_free(binary elf_binary_t*)": "Free ELF binary resources",
    "read_file(filename char*, size size_t*) returns unsigned char*": "Read entire file into buffer",
    "write_file(filename char*, buffer unsigned char*, size size_t) returns int": "Write buffer to file",
    "is_valid_elf(buffer unsigned char*, size size_t) returns int": "Validate ELF file",
    "elf_error(message char*)": "Report ELF error",
    "plan_patch(binary elf_binary_t*, offset uint64_t, new_bytes unsigned char*, new_size size_t) returns patch_site_t*": "Analyzes and plans an instruction patch at given offset",
    "apply_patch(binary elf_binary_t*, patch patch_site_t*) returns int": "Executes planned patch on binary's in-memory representation",
    "generate_nop_sled(count size_t) returns unsigned char*": "Creates sequence of NOP instructions",
    "generate_trampoline(target_addr uint64_t, hook_addr uint64_t) returns trampoline_t*": "Creates a complete trampoline for function hooking",
    "relocate_prologue(original_code unsigned char*, size size_t) returns unsigned char*": "Relocates original function prologue for trampoline",
    "fixup_rip_relative(instruction unsigned char*, old_ip uint64_t, new_ip uint64_t) returns unsigned char*": "Adjusts RIP-relative addressing in relocated instruction",
    "inject_section(binary elf_binary_t*, name char*, data unsigned char*, size size_t, flags uint64_t) returns int": "Primary entry point for section injection",
    "allocate_code_cave(binary elf_binary_t*, size size_t) returns uint64_t": "Find unused space for code injection",
    "resolve_symbol_in_target(binary elf_binary_t*, symbol_name char*) returns uint64_t": "Resolve symbol address in target binary",
    "attach_to_process(pid pid_t) returns int": "Attach to running process via ptrace",
    "read_process_memory(pid pid_t, addr uint64_t, buffer void*, size size_t) returns int": "Read memory from process",
    "write_process_memory(pid pid_t, addr uint64_t, buffer void*, size size_t) returns int": "Write memory to process",
    "make_page_writable(pid pid_t, addr uint64_t, size size_t) returns int": "Change memory protection to writable via mprotect syscall injection",
    "binary_write(binary elf_binary_t*, output_path char*, err error_t*) returns int": "Write modified binary model to disk",
    "trampoline_free(trampoline_t*)": "Free trampoline resources (implied from skeleton)",
    "patch_free(patch_site_t*)": "Free patch resources (implied from skeleton)",
    "elf_binary_free(binary elf_binary_t*) returns": "Free ELF binary resources",
    "patch_free(patch patch_site_t*) returns": "Deallocates patch resources",
    "trampoline_free(trampoline trampoline_t*) returns": "Frees trampoline resources",
    "injected_section_free(section injected_section_t*) returns": "Free injected section resources",
    "error_create() returns error_t*": "Create a new empty error structure",
    "error_free(err error_t*) returns": "Free an error structure",
    "patch_absolute_address(code uint8_t*, code_size size_t, patch_offset uint64_t, old_address uint64_t, new_address uint64_t) returns void": "Patch an absolute address in injected code",
    "is_likely_pic(code const uint8_t*, size size_t) returns int": "Check if code appears to be position-independent",
    "detach_from_process(pid pid_t) returns int": "Detach from process, allowing it to resume",
    "flush_instruction_cache(pid pid_t, addr uint64_t, size size_t) returns int": "Ensure CPU cache coherence after code modification",
    "inject_trampoline_runtime(pid pid_t, target_addr uint64_t, trampoline trampoline_t*) returns int": "Complete runtime hooking workflow",
    "wait_for_stop(pid pid_t, status int*) returns int": "Wait for process to stop after ptrace operation",
    "ptrace_peekdata(pid pid_t, addr uint64_t, error int*) returns uint64_t": "Read a word from process memory",
    "ptrace_pokedata(pid pid_t, addr uint64_t, data uint64_t) returns int": "Write a word to process memory",
    "error_set(error_t* err, int code, const char* message, const char* context) returns void": "Set error details",
    "error_clear(error_t* err) returns void": "Clear error state",
    "error_code_to_string(int code) returns const char*": "Convert error code to human-readable string",
    "test_suite_create() returns test_suite_t*": "Create new test suite",
    "test_suite_add(suite test_suite_t*, name const char*, command const char*, expected_exit int, output_file const char*, expected_output const char*) returns int": "Add test case to suite",
    "run_test_case(test const test_case_t*) returns int": "Execute single test",
    "test_suite_run(suite test_suite_t*) returns void": "Run all tests in suite",
    "test_suite_free(suite test_suite_t*) returns void": "Free test suite resources",
    "log_init(stream FILE*, level log_level_t) returns void": "initialize logging system",
    "log_message(level log_level_t, file const char*, line int, format const char*, ...) returns void": "log a formatted message",
    "log_hexdump(level log_level_t, label const char*, data const void*, size size_t) returns void": "log hex dump of memory",
    "validate_patch(binary const elf_binary_t*, patch const patch_site_t*) returns error_t*": "validate patch before application",
    "validate_trampoline(trampoline const trampoline_t*) returns error_t*": "validate trampoline before injection",
    "compile_policy_to_patches(policy_file char*, target elf_binary_t*, patches patch_site_t***, patch_count size_t*) returns error_t*": "Compile policy DSL to concrete patch specifications",
    "compile_callback_to_pic(c_source char*, function_name char*, code_size size_t*, err error_t*) returns unsigned char*": "Compile C source to position-independent machine code"
  },
  "constants": {
    "EI_NIDENT": "16",
    "SHT_NULL": "0",
    "SHT_PROGBITS": "1",
    "SHT_SYMTAB": "2",
    "SHT_STRTAB": "3",
    "SHT_NOBITS": "8",
    "SHF_WRITE": "0x1",
    "SHF_ALLOC": "0x2",
    "SHF_EXECINSTR": "0x4",
    "PT_LOAD": "1",
    "ELF_MAGIC": "\\x7f\\x45\\x4c\\x46",
    "ERR_SUCCESS": "0 - Operation succeeded",
    "ERR_INVALID_ELF": "1",
    "ERR_FILE_IO": "2",
    "ERR_OUT_OF_MEMORY": "Error code for memory allocation failure",
    "ERR_SECTION_NOT_FOUND": "4",
    "ERR_SYMBOL_NOT_FOUND": "5",
    "ERR_PATCH_OVERLAP": "6 - Patch would overlap existing modification",
    "ERR_INVALID_OFFSET": "7 - Offset not within executable code",
    "INJECT_SECTION_NAME": ".inject",
    "INJECT_SECTION_FLAGS": "SHF_ALLOC | SHF_EXECINSTR",
    "PAGE_SIZE": "0x1000 (4096 bytes, typical page size)",
    "SECTION_ALIGNMENT": "0x10",
    "PF_R": "Read permission flag",
    "PF_X": "Execute permission flag",
    "PROT_READ": "Memory protection flag for read access",
    "PROT_WRITE": "Memory protection flag for write access",
    "PROT_EXEC": "Memory protection flag for execute access",
    "ERR_PTRACE_PERM": "100 - Ptrace permission denied",
    "ERR_MPROTECT_FAILED": "101 - Failed to change memory protection",
    "MAX_TEST_NAME": "256",
    "MAX_COMMAND": "1024",
    "LOG_DEBUG": "debug log level",
    "LOG_INFO": "info log level",
    "LOG_WARN": "warning log level",
    "LOG_ERROR": "error log level",
    "LOG_FATAL": "fatal log level",
    "ERR_INVALID_ARG": "error code for invalid arguments",
    "EM_X86_64": "ELF machine ID for x86-64",
    "EM_AARCH64": "ELF machine ID for ARM 64-bit",
    "MAX_PLUGINS": "Maximum number of architecture plugins"
  },
  "terms": {
    "ELF": "Executable and Linkable Format - standard binary format",
    "trampoline": "Small code sequence that redirects execution flow",
    "prologue": "Function entry code that sets up stack frame",
    "RIP-relative": "x86-64 addressing mode using instruction pointer offset",
    "position-independent code": "Code that can execute correctly regardless of load address",
    "ptrace": "Linux system call for process tracing and debugging",
    "NOP sled": "Sequence of no-operation instructions used for padding",
    "code cave": "Unused space within existing binary segments",
    "binary instrumentation": "Technique of modifying compiled binaries to insert monitoring or behavior hooks",
    "function hooking": "Intercepting function calls to execute custom code",
    "dynamic binary instrumentation": "Runtime modification of executing code",
    "static binary rewriting": "Offline modification of binary files",
    "assembly line": "Analogy for the pipeline architecture",
    "workshop layout": "Analogy for the directory structure",
    "monolithic tool": "Single integrated executable rather than plugin framework",
    "module isolation": "Principle of keeping components independent with clear interfaces",
    "memory ownership": "Clear specification of which structure owns each allocated memory block",
    "section": "Contiguous chunk of binary with specific purpose (code, data, etc.)",
    "segment": "Memory region loaded by OS, contains one or more sections",
    "symbol table": "Mapping of function/variable names to addresses",
    "endianness": "Byte order of multi-byte values in memory",
    "instruction boundary": "starting address of a machine instruction",
    "relative jump": "Branch instruction encoding target as offset from current instruction",
    "ELF structural integrity": "Property that ELF headers and sections remain valid after modification",
    "segment overlap": "When two ELF segments claim overlapping virtual address ranges",
    "PIC": "Position-Independent Code",
    "runtime instrumentation": "Modifying executing code in a running process",
    "memory protection": "Operating system mechanism to control memory access permissions",
    "instruction cache": "CPU cache for recently executed instructions",
    "syscall injection": "Technique of making a process execute a system call via debugger control",
    "YAMA ptrace_scope": "Linux security restricting ptrace",
    "multi-threaded process": "Process with multiple threads of execution",
    "register state": "Current values of CPU registers in a process",
    "ASLR": "Address Space Layout Randomization - security feature randomizing load addresses",
    "ownership hierarchy": "Clear specification of which structure owns each allocated memory block for cleanup",
    "fail early, fail cleanly": "Philosophy of detecting errors as soon as possible and ensuring system never leaves target in unrecoverable state",
    "surgical rollback protocol": "Metaphor for runtime patching cleanup that emphasizes saving original state before modification",
    "error propagation": "Technique of passing error information up the call stack",
    "latent errors": "Errors that don't cause immediate failure in the tool but manifest later when modified binary executes",
    "multi-threaded process complications": "Challenges of patching a process with multiple threads of execution",
    "test runner": "Infrastructure for executing and verifying tests",
    "integration test": "Test that verifies multiple components working together",
    "unit test": "Test that verifies a single function or component in isolation",
    "fixture": "Pre-prepared test data or binary",
    "AddressSanitizer": "Compiler instrumentation for detecting memory errors",
    "dry-run": "simulation mode that shows what would be changed without actually modifying files",
    "hex dump": "display of raw bytes in hexadecimal format",
    "validation mode": "operational mode that performs extensive checks without modification",
    "inline hooking": "Inserting hooks within function body rather than at entry",
    "exit hooking": "Intercepting function return paths",
    "epilogue instrumentation": "Hooking function exit sequences",
    "multi-architecture": "Support for multiple CPU instruction sets",
    "architecture plugin": "Module providing architecture-specific implementations",
    "policy DSL": "Domain-Specific Language for declaring instrumentation policies",
    "segment overlapping": "Using padding within segments for code injection",
    "hot-swappable hooks": "Hooks that can be installed/uninstalled at runtime",
    "sampling mode": "Instrumentation that activates only periodically to reduce overhead",
    "stealth injection": "Injection techniques designed to avoid detection",
    "YAMA": "Linux security module restricting ptrace usage",
    "interval tree": "Data structure for efficiently managing address ranges",
    "PIC optimization": "Making injected code fully position-independent",
    "plugin registry": "System for managing architecture-specific implementations",
    "Address Space Layout Randomization (ASLR)": "Security feature randomizing load addresses",
    "Binary Instrumentation": "Technique of modifying compiled binaries",
    "Code Cave": "Unused space within existing segments",
    "Dynamic Binary Instrumentation (DBI)": "Runtime modification of executing code",
    "ELF Structural Integrity": "Property that ELF remains valid after modification",
    "Endianness": "Byte order of multi-byte values",
    "Epilogue Instrumentation": "Hooking function exit paths",
    "Function Hooking": "Intercepting function calls",
    "Inline Hooking": "Inserting hooks within function body",
    "Instruction Boundary": "Starting address of machine instruction",
    "Instruction Cache": "CPU cache for instructions",
    "Memory Protection": "OS mechanism controlling memory permissions",
    "Module Isolation": "Design principle of independent components",
    "Monolithic Tool": "Single integrated executable",
    "NOP Sled": "Sequence of NOP instructions for padding",
    "Ownership Hierarchy": "Specification of memory ownership",
    "Position-Independent Code (PIC)": "Code executable at any address",
    "Prologue": "Function entry code",
    "Ptrace": "Linux system call for process tracing",
    "Relative Jump": "Branch using offset from current IP",
    "RIP-Relative Addressing": "x86-64 addressing using RIP offset",
    "Runtime Instrumentation": "Modifying executing code",
    "Segment": "Memory region loaded by OS",
    "Segment Overlap": "Invalid overlapping segment ranges",
    "Section": "Contiguous chunk of ELF file",
    "Static Binary Rewriting": "Offline binary modification",
    "Symbol Table": "Mapping names to addresses",
    "Syscall Injection": "Forcing process to execute syscall",
    "Trampoline": "Code sequence redirecting execution",
    "Architecture Plugin": "Module for architecture-specific code",
    "Assembly Line": "Analogy for pipeline architecture",
    "Dry-Run": "Simulation mode without modification",
    "Fail Early, Fail Cleanly": "Error handling philosophy",
    "Fixture": "Pre-prepared test data",
    "Hot-Swappable Hooks": "Hooks installable/uninstallable at runtime",
    "Interval Tree": "Data structure for address ranges",
    "Latent Errors": "Errors manifesting later",
    "Memory Ownership": "Clear specification of memory responsibility",
    "Multi-Threaded Process Complications": "Challenges with multi-threaded targets",
    "Policy DSL": "Domain-Specific Language for policies",
    "Plugin Registry": "System managing architecture plugins",
    "Sampling Mode": "Periodic instrumentation to reduce overhead",
    "Segment Overlapping": "Using padding for injection",
    "Stealth Injection": "Injection avoiding detection",
    "Surgical Rollback Protocol": "Metaphor for runtime cleanup",
    "Test Runner": "Infrastructure for tests",
    "Validation Mode": "Operational mode for checks only",
    "Workshop Layout": "Analogy for directory structure"
  }
}