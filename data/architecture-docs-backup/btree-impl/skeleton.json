{
  "title": "B-tree Implementation: Design Document",
  "overview": "This document outlines the design for implementing a B-tree, a self-balancing tree data structure optimized for systems that read and write large blocks of data like databases and file systems. The key architectural challenge is maintaining the B-tree invariants (node key/child counts, sorted order) during insertions and deletions while ensuring disk-friendly operations through node splitting, merging, and borrowing.",
  "sections": [
    {
      "id": "context",
      "title": "1. Context and Problem Statement",
      "summary": "Explains why B-trees exist, the problem they solve (efficient disk-based data management), and how they compare to in-memory trees like AVL or Red-Black trees.",
      "subsections": [
        {
          "id": "context-problem",
          "title": "The Disk Access Problem and B-tree Solution",
          "summary": "Introduces the high cost of disk I/O and how B-trees minimize disk seeks by packing many keys into each node (page)."
        },
        {
          "id": "context-mental-model",
          "title": "Mental Model: The Library Catalog Analogy",
          "summary": "Uses a library catalog system (card catalog \u2192 section guides \u2192 book locations) to intuitively explain B-tree structure and search."
        },
        {
          "id": "context-comparison",
          "title": "Comparison with Other Tree Structures",
          "summary": "Table comparing B-trees to BSTs, AVL trees, and Red-Black trees on factors like height, disk usage, and use cases."
        }
      ]
    },
    {
      "id": "goals",
      "title": "2. Goals and Non-Goals",
      "summary": "Defines the functional requirements (must support search, insert, delete) and explicit limitations (no persistence, no concurrency control) for this educational implementation.",
      "subsections": [
        {
          "id": "goals-functional",
          "title": "Functional Goals",
          "summary": "List of core operations the B-tree must support and their expected behaviors."
        },
        {
          "id": "goals-non-functional",
          "title": "Non-Functional Goals & Non-Goals",
          "summary": "Performance targets (O(log n)) and explicit exclusions like persistence to disk, concurrency, or variable-length keys."
        }
      ]
    },
    {
      "id": "architecture",
      "title": "3. High-Level Architecture",
      "summary": "Presents the system's component breakdown (Node, BTree, Operations) and how they interact, with a focus on in-memory structure.",
      "subsections": [
        {
          "id": "architecture-components",
          "title": "Component Overview",
          "summary": "Description of the three main logical components: Node (data container), BTree (orchestrator), and Operations (algorithms)."
        },
        {
          "id": "architecture-file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Suggested code organization for C implementation, listing header and source files."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core data structures: BTreeNode (keys, children, metadata) and BTree (root, minimum degree). Describes relationships and invariants.",
      "subsections": [
        {
          "id": "data-model-types",
          "title": "Core Types and Structures",
          "summary": "Tables defining the fields of BTreeNode and BTree, their types, purposes, and the critical invariants linking them."
        },
        {
          "id": "data-model-invariants",
          "title": "B-tree Invariants",
          "summary": "Lists and explains the five core rules that define a valid B-tree (e.g., root key count, leaf node child count, key ordering)."
        }
      ]
    },
    {
      "id": "component-node",
      "title": "5. Component Design: B-tree Node",
      "summary": "Detailed design of the Node component, which stores keys and child pointers. Covers memory layout, capacity management, and leaf vs. internal distinction. (Milestone 1)",
      "subsections": [
        {
          "id": "component-node-mental",
          "title": "Mental Model: A Bookshelf with Dividers",
          "summary": "Analogy comparing a node to a bookshelf where keys are dividers and child pointers point to other shelves or actual books (values at leaves)."
        },
        {
          "id": "component-node-interface",
          "title": "Interface and Operations",
          "summary": "Table of functions for node creation, destruction, key search, insertion, deletion, and splitting."
        },
        {
          "id": "component-node-adr-layout",
          "title": "ADR: Node Memory Layout",
          "summary": "Decision record for storing keys and children in separate arrays versus a unified array of key-pointer pairs."
        },
        {
          "id": "component-node-pitfalls",
          "title": "Common Pitfalls: Node Capacity",
          "summary": "Lists typical mistakes: off-by-one errors in key counts, forgetting to initialize child pointers to NULL, and mis-handling the leaf flag."
        },
        {
          "id": "component-node-implementation",
          "title": "Implementation Guidance",
          "summary": "Starter code for node infrastructure (creation, destruction) and skeleton code with TODOs for core logic like finding a key index."
        }
      ]
    },
    {
      "id": "component-search",
      "title": "6. Component Design: Search Operation",
      "summary": "Design of the search algorithm that navigates from the root to a leaf using binary search within each node. (Milestone 2)",
      "subsections": [
        {
          "id": "component-search-mental",
          "title": "Mental Model: Finding a Topic in a Textbook",
          "summary": "Analogy comparing search to using a textbook's index (root) to find a chapter (internal node), then a section (leaf), and finally the page."
        },
        {
          "id": "component-search-algorithm",
          "title": "Search Algorithm Steps",
          "summary": "Numbered steps for the recursive search procedure: start at root, binary search within node, handle found key, or recurse to child."
        },
        {
          "id": "component-search-adr-recursion",
          "title": "ADR: Recursive vs. Iterative Search",
          "summary": "Decision record for choosing a recursive implementation (clearer for learners) over an iterative one (better for tail optimization)."
        },
        {
          "id": "component-search-pitfalls",
          "title": "Common Pitfalls: Search Logic",
          "summary": "Common errors: incorrect binary search bounds, forgetting to check if a node is leaf before recursing, and mishandling the 'key not found' case."
        },
        {
          "id": "component-search-implementation",
          "title": "Implementation Guidance",
          "summary": "Skeleton code for the binary search helper and the main recursive search function with TODOs mapping to algorithm steps."
        }
      ]
    },
    {
      "id": "component-insert",
      "title": "7. Component Design: Insertion with Splitting",
      "summary": "Design of the insertion algorithm that proactively splits full nodes during descent to maintain B-tree invariants. (Milestone 3)",
      "subsections": [
        {
          "id": "component-insert-mental",
          "title": "Mental Model: Adding a Book to a Full Shelf",
          "summary": "Analogy: Adding a book to a full shelf requires splitting it, taking the middle book to a higher-level index, and creating a new shelf."
        },
        {
          "id": "component-insert-algorithm",
          "title": "Insertion and Split Algorithm Steps",
          "summary": "Numbered steps for the insertion procedure: proactive splitting during descent, insertion into leaf, and handling root split."
        },
        {
          "id": "component-insert-adr-split-strategy",
          "title": "ADR: Proactive vs. Reactive Splitting",
          "summary": "Decision record for splitting full nodes during the downward traversal (proactive) instead of after insertion (reactive)."
        },
        {
          "id": "component-insert-pitfalls",
          "title": "Common Pitfalls: Splitting and Promotion",
          "summary": "Typical mistakes: splitting the wrong node (non-full), incorrectly calculating the median index, and failing to update parent pointers after split."
        },
        {
          "id": "component-insert-implementation",
          "title": "Implementation Guidance",
          "summary": "Skeleton code for the split node function and the main insertion function with TODOs, including the special case for splitting the root."
        }
      ]
    },
    {
      "id": "component-delete",
      "title": "8. Component Design: Deletion with Rebalancing",
      "summary": "Design of the deletion algorithm that handles underflow through borrowing from siblings or merging nodes. (Milestone 4)",
      "subsections": [
        {
          "id": "component-delete-mental",
          "title": "Mental Model: Removing a Book and Consolidating Shelves",
          "summary": "Analogy: Removing a book might leave a shelf below capacity; you first borrow from a neighbor shelf, or if that fails, merge two shelves and update the index."
        },
        {
          "id": "component-delete-algorithm",
          "title": "Deletion and Rebalance Algorithm Steps",
          "summary": "Numbered steps covering: deletion from leaf/internal nodes, underflow detection, borrowing, merging, and root shrinking."
        },
        {
          "id": "component-delete-adr-predecessor-successor",
          "title": "ADR: Predecessor vs. Successor for Internal Delete",
          "summary": "Decision record for choosing the in-order predecessor (or successor) when deleting a key from an internal node."
        },
        {
          "id": "component-delete-pitfalls",
          "title": "Common Pitfalls: Borrow vs. Merge Logic",
          "summary": "Common errors: incorrect conditions for choosing borrow vs. merge, not handling left/right sibling symmetry, and failing to recurse after borrowing/merging."
        },
        {
          "id": "component-delete-implementation",
          "title": "Implementation Guidance",
          "summary": "Skeleton code for helper functions (get predecessor, borrow, merge) and the main delete function with TODOs for each case."
        }
      ]
    },
    {
      "id": "interactions",
      "title": "9. Interactions and Data Flow",
      "summary": "Describes how components collaborate during key operations using sequence diagrams and explains the flow of data through function calls.",
      "subsections": [
        {
          "id": "interactions-sequence",
          "title": "Sequence of Operations",
          "summary": "Walkthroughs of the function call sequences for search, insert (with split), and delete (with borrow/merge)."
        },
        {
          "id": "interactions-state-flow",
          "title": "State Transitions During Operations",
          "summary": "Table showing how a node's state (key count) changes in response to events (insert, delete, borrow, merge)."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "10. Error Handling and Edge Cases",
      "summary": "Covers failure modes (memory allocation, invalid inputs), detection strategies, and recovery approaches for this in-memory implementation.",
      "subsections": [
        {
          "id": "error-handling-cases",
          "title": "Failure Modes and Edge Cases",
          "summary": "Lists potential errors (malloc failure, duplicate key insertion, deleting non-existent key) and how the implementation should handle them."
        },
        {
          "id": "error-handling-invariants",
          "title": "Invariant Verification for Debugging",
          "summary": "Describes a helper function to validate all B-tree invariants, useful for catching bugs during development."
        }
      ]
    },
    {
      "id": "testing",
      "title": "11. Testing Strategy",
      "summary": "Outlines a testing approach using property-based tests, specific scenarios, and milestone checkpoints to verify correctness.",
      "subsections": [
        {
          "id": "testing-approach",
          "title": "Testing Approach and Scenarios",
          "summary": "Recommendations for unit tests, property tests (insert/delete/search maintains order), and edge case tests (root split, merge cascades)."
        },
        {
          "id": "testing-milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "For each milestone, describes what to test, expected output, and how to know the implementation is on track (e.g., 'After Milestone 2, search should find all inserted keys')."
        }
      ]
    },
    {
      "id": "debugging",
      "title": "12. Debugging Guide",
      "summary": "Provides a symptom-cause-fix table for common bugs, debugging techniques (print tree, invariant checker), and tools (Valgrind, GDB) specific to C.",
      "subsections": [
        {
          "id": "debugging-table",
          "title": "Common Bug Symptoms and Fixes",
          "summary": "Table listing symptoms (e.g., 'Segmentation fault after insert'), likely causes (e.g., 'Accessing child pointer beyond count'), and fixes."
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques and Tools",
          "summary": "Recommendations for adding verbose logging, writing a tree visualization function, and using memory debuggers."
        }
      ]
    },
    {
      "id": "extensions",
      "title": "13. Future Extensions",
      "summary": "Suggests possible enhancements like persistence to disk, support for associated values, concurrency control, or different B-tree variants (B+, B*).",
      "subsections": [
        {
          "id": "extensions-ideas",
          "title": "Extension Ideas",
          "summary": "Brief descriptions of how the current design could be extended to support disk I/O, key-value storage, or multi-threading."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "14. Glossary",
      "summary": "Definitions of key terms used throughout the document, such as B-tree, minimum degree (t), node splitting, borrowing, and merging.",
      "subsections": [
        {
          "id": "glossary-terms",
          "title": "Term Definitions",
          "summary": "Alphabetical list of terms with clear, concise definitions and references to where they are first used."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "arch-component",
      "title": "B-tree System Components",
      "description": "Shows the three main logical components (BTree, Node, Operations) and their relationships. BTree contains a root Node and orchestrates Operations (Search, Insert, Delete) which manipulate Nodes.",
      "type": "component",
      "relevant_sections": [
        "architecture"
      ]
    },
    {
      "id": "data-model-class",
      "title": "B-tree Data Model",
      "description": "Class diagram showing the BTree struct (with root pointer and min degree t) and the BTreeNode struct (with keys array, children pointer array, num_keys, is_leaf). Shows containment: BTree has a root Node, Node has child Nodes.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "search-sequence",
      "title": "Search Operation Sequence",
      "description": "Sequence diagram showing the interaction between the caller, BTree search function, and multiple Node instances during a recursive search that descends three levels.",
      "type": "sequence",
      "relevant_sections": [
        "component-search",
        "interactions"
      ]
    },
    {
      "id": "insert-flowchart",
      "title": "Insertion with Splitting Algorithm",
      "description": "Flowchart detailing the steps of the insertion algorithm: start at root, traverse down while splitting full nodes, insert into leaf, and handle the special case of root split.",
      "type": "flowchart",
      "relevant_sections": [
        "component-insert"
      ]
    },
    {
      "id": "delete-state-machine",
      "title": "Node State During Deletion",
      "description": "State machine for a node during deletion. States: Underfull (< t-1 keys), Valid (t-1 to 2t-1 keys), Overfull (>2t-1 keys - should not occur). Transitions triggered by borrow, merge, or direct key removal.",
      "type": "state-machine",
      "relevant_sections": [
        "component-delete",
        "interactions"
      ]
    },
    {
      "id": "split-visual",
      "title": "Node Split and Median Promotion",
      "description": "Visual diagram showing a full node with 5 keys being split into two nodes with 2 keys each, and the middle key (3rd) being promoted to the parent node. Includes before/after key and child pointer arrays.",
      "type": "flowchart",
      "relevant_sections": [
        "component-insert"
      ]
    },
    {
      "id": "borrow-merge-visual",
      "title": "Borrow vs. Merge Operations",
      "description": "Two side-by-side diagrams illustrating borrowing a key from a right sibling versus merging with a left sibling to fix an underflow condition after deletion.",
      "type": "flowchart",
      "relevant_sections": [
        "component-delete"
      ]
    }
  ]
}