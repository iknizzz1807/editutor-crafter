title: Memory Block Layout with Boundary Tags

memory_layout: {
  style: {
    fill: "#0f3460"
    stroke: "#3fb950"
    font-color: "#e6edf3"
  }

  # Previous Block
  prev_block: "Previous Block" {
    style: {
      fill: "#1a1a2e"
    }
  }

  # Current Memory Block - converted from class to container
  current_block: {

    # Header section
    header: Header {
      shape: sql_table
      style.bold: true
      style.stroke: "#3fb950"
      style.fill: "#16213e"
      size: "size_t"
      flags: "uint8_t (FREE/ALLOC)"
      prev: "void* (free blocks only)"
      next: "void* (free blocks only)"
    }

    # User payload with alignment padding
    payload: {
      shape: rectangle
      style.fill: "#2d4263"
      style.stroke: "#8b949e"
      alignment_padding: "Optional padding"
      user_data: "Aligned payload area"
    }

    # Footer section
    footer: Footer {
      shape: sql_table
      style.bold: true
      style.stroke: "#3fb950"
      style.fill: "#16213e"
      size: "size_t (copy of header)"
    }
  }

  # Next Block
  next_block: "Next Block" {
    style: {
      fill: "#1a1a2e"
    }
  }

  # Arrange blocks in sequence
  prev_block -> current_block
  current_block -> next_block

  # Show boundaries
  note: |md
    ## Boundary Tags
    - Headers and footers store identical size information
    - Enable bidirectional traversal for coalescing
    - Footer of previous block = Header of current block
  | {
    shape: page
    style: {
      fill: "#16213e"
      stroke: "#3fb950"
    }
  }

  # Coalescing arrows
  prev_block -> current_block.header: "detect adjacent free blocks"
  current_block.footer -> next_block: "detect adjacent free blocks"
}

# Legend
legend: {
  style: {
    fill: "#1a1a2e"
    stroke: "#8b949e"
  }
  
  metadata: "Metadata (header/footer)" {
    style.fill: "#16213e"
  }
  payload: "User payload (aligned)" {
    style.fill: "#2d4263"
  }
  other: "Adjacent blocks" {
    style.fill: "#1a1a2e"
  }
}
