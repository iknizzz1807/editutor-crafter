title: Flowchart: malloc Decision Logic

direction: down

# ===== START =====
start: malloc(size request) {
  shape: circle
  style.fill: "#1a1a2e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}

# ===== SIZE CALCULATION =====
size_adjustment: Calculate total block size (header + footer + alignment + padding) {
  style.stroke-width: 2
}

start -> size_adjustment

# ===== THREAD CACHE CHECK =====
thread_cache_check: Size fits thread cache AND cache available? {
  shape: diamond
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
  style.stroke-width: 2
}

size_adjustment -> thread_cache_check

thread_cache_hit: Remove block from thread cache
thread_cache_miss: Proceed to segregated lists

thread_cache_check -> thread_cache_hit: Yes
thread_cache_check -> thread_cache_miss: No

# ===== SEGREGATED FREE LISTS =====
segregated_section: {
  find_in_segregated: Search segregated free list by size class {
    style.stroke-width: 2
  }
  
  thread_cache_miss -> find_in_segregated
  
  block_found: Block found in free list? {
    shape: diamond
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.stroke-width: 2
  }
  
  find_in_segregated -> block_found
  
  remove_from_list: Remove block from free list
  block_found -> remove_from_list: Yes
}

# ===== BLOCK SPLITTING PATH =====
check_split: Check if block can be split (size > required + MIN_SPLIT_SIZE) {
  shape: diamond
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
  style.stroke-width: 2
}

remove_from_list -> check_split

perform_split: Split block: create new remainder block with header/footer
check_split -> perform_split: Yes
check_split -> update_metadata: No

update_metadata: Update metadata (header/footer, allocated flag)

perform_split -> update_metadata
update_metadata -> add_to_free_list: Add remainder to appropriate free list
add_to_free_list -> return_block

# ===== OS FALLBACK PATH =====
block_found -> os_fallback: No

os_fallback: Fallback: Request memory from OS (via mmap/sbrk) {
  style.stroke-width: 2
  style.fill: "#0f3460"
}

os_fallback -> os_success: Request succeeded? {
  shape: diamond
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
  style.stroke-width: 2
}

os_success -> setup_new_chunk: Yes
os_success -> allocation_failed: No

setup_new_chunk: Setup new chunk: initialize header/footer, mark as allocated
setup_new_chunk -> return_block

# ===== RETURN PATHS =====
thread_cache_hit -> return_block
return_block: Return pointer to user payload (after header) {
  style.stroke: "#3fb950"
  style.stroke-width: 3
  style.bold: true
}

allocation_failed: Return NULL {
  style.stroke: "#ff7b72"
  style.stroke-width: 2
}

# ===== CONNECTIONS =====
segregated_section.shape: rectangle
segregated_section.style.fill: "#1a1a2e"
segregated_section.style.stroke: "#3fb950"
segregated_section.style.stroke-width: 1
segregated_section.label: Segregated Free Lists Lookup

return_block -> end: Allocation successful
allocation_failed -> end: Allocation failed

end: End {
  shape: circle
  style.fill: "#1a1a2e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}