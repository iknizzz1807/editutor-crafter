{
  "title": "Build Your Own Memory Allocator: Design Document",
  "overview": "This system implements custom malloc and free functions for dynamic memory allocation, a fundamental service provided by the C standard library. The key architectural challenge is designing a data structure and algorithm to manage a finite heap memory region, efficiently satisfying allocation requests of varying sizes while minimizing wasted space (fragmentation) and maximizing performance for concurrent programs.",
  "sections": [
    {
      "id": "context",
      "title": "1. Context and Problem Statement",
      "summary": "Explains why managing a heap is necessary, the core problems of fragmentation and performance, and introduces the concept of a memory allocator as a warehouse manager.",
      "subsections": [
        {
          "id": "context-problem",
          "title": "The Problem: The Heap as an Unguided Warehouse",
          "summary": "Describes the heap's raw, unstructured nature and the need for a manager to track allocations and space. Introduces fragmentation (wasted space) as the primary enemy."
        },
        {
          "id": "context-existing",
          "title": "Existing Approaches & Mental Models",
          "summary": "Compares different allocator strategies (bump, segregated fits, etc.) using the warehouse analogy and presents a comparison table of their trade-offs."
        }
      ]
    },
    {
      "id": "goals",
      "title": "2. Goals and Non-Goals",
      "summary": "Defines the precise functional requirements for our malloc/free implementation and explicitly states what is out of scope.",
      "subsections": [
        {
          "id": "goals-functional",
          "title": "Functional Goals",
          "summary": "List of must-have features aligned with the project milestones: basic allocation/free, free list management, segregated lists, thread safety, and mmap support."
        },
        {
          "id": "goals-non",
          "title": "Non-Goals",
          "summary": "Explicitly states this is not a garbage collector, does not handle virtual memory paging, and is not a production-grade allocator like jemalloc."
        }
      ]
    },
    {
      "id": "high-level",
      "title": "3. High-Level Architecture",
      "summary": "Provides a bird's-eye view of the allocator's components and their interactions, introducing the concept of the 'Heap' managed by a 'Core Allocator' and 'OS Interface'.",
      "subsections": [
        {
          "id": "high-level-components",
          "title": "Component Overview & Responsibilities",
          "summary": "Describes the role of the OS Interface (sbrk/mmap), the Heap Manager, Allocation Strategies, and Thread-Local Caches."
        },
        {
          "id": "high-level-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Suggests a code organization with files for headers (allocator.h), OS abstraction (os_mem.c), core logic (heap.c, free_list.c), strategies (strategies.c), and threading (thread_cache.c)."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core data structures that represent memory blocks, free lists, and allocator state. This is the blueprint for the entire system.",
      "subsections": [
        {
          "id": "data-block-header",
          "title": "Block Header: The 'Shipping Label'",
          "summary": "Describes the metadata structure prepended to every allocated and free block, containing size, status flags, and pointers for free list linkage."
        },
        {
          "id": "data-free-list",
          "title": "Free List Node & Management",
          "summary": "Explains how free blocks are linked together into an explicit doubly-linked list, with nodes embedded in the free memory itself."
        },
        {
          "id": "data-allocator-state",
          "title": "Allocator Global State",
          "summary": "Describes the top-level structure holding the heap base pointer, head of the free list, and configuration parameters (strategy, size classes)."
        }
      ]
    },
    {
      "id": "component-os",
      "title": "5.1 OS Memory Interface Component",
      "summary": "Handles all communication with the operating system to request and release raw memory pages. Covers Milestone 1 and 4.",
      "subsections": [
        {
          "id": "component-os-mental",
          "title": "Mental Model: The Warehouse Landlord",
          "summary": "Analogizes sbrk to requesting more land from the landlord to expand the warehouse, and mmap to renting a separate, dedicated storage unit for oversized items."
        },
        {
          "id": "component-os-adr-sbrk-vs-mmap",
          "title": "ADR: sbrk for Small, mmap for Large Allocations",
          "summary": "Decision record analyzing the trade-off between using sbrk (contiguous, simple) for the main heap and mmap (isolated, flexible) for large blocks to prevent fragmentation and allow independent return."
        },
        {
          "id": "component-os-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides wrapper functions for sbrk and mmap with error handling. Skeleton code for a function that chooses between them based on a size threshold."
        }
      ]
    },
    {
      "id": "component-block",
      "title": "5.2 Block Management & Core Algorithms",
      "summary": "Implements the fundamental operations of finding, splitting, coalescing, and tracking memory blocks. Covers Milestone 1 and 2.",
      "subsections": [
        {
          "id": "component-block-mental",
          "title": "Mental Model: The Warehouse Floor Plan",
          "summary": "Describes the heap as a contiguous floor where each block is a shelf unit with a label (header). Operations involve finding a shelf, dividing a large one, or merging adjacent empty ones."
        },
        {
          "id": "component-block-adr-boundary-tags",
          "title": "ADR: Boundary Tags for Bidirectional Coalescing",
          "summary": "Decision record on placing a footer at the end of each block to enable O(1) merging with the previous free block, trading a small space overhead for significant fragmentation reduction."
        },
        {
          "id": "component-block-algorithm-malloc",
          "title": "Algorithm: The malloc() Walkthrough",
          "summary": "Step-by-step numbered procedure for handling a malloc request: alignment calculation, free list search (first/best/worst-fit), block splitting, and pointer return."
        },
        {
          "id": "component-block-algorithm-free",
          "title": "Algorithm: The free() Walkthrough",
          "summary": "Step-by-step procedure for free: deriving the block header from the user pointer, marking it free, inserting into the free list, and coalescing with neighbors."
        },
        {
          "id": "component-block-implementation",
          "title": "Implementation Guidance",
          "summary": "Skeleton code for core functions: get_header_from_ptr, find_free_block (with strategy switch), split_block, coalesce_block. Includes helper macros for header/footer access."
        }
      ]
    },
    {
      "id": "component-strategy",
      "title": "5.3 Allocation Strategy Component",
      "summary": "Encapsulates the logic for searching the free list (first-fit, best-fit, worst-fit) and managing segregated size classes. Covers Milestone 2 and 3.",
      "subsections": [
        {
          "id": "component-strategy-mental",
          "title": "Mental Model: The Shelf-Finding Strategy",
          "summary": "Compares allocation strategies to different warehouse picking strategies: First-Fit (take the first one you see), Best-Fit (find the tightest fit), Worst-Fit (use the largest shelf)."
        },
        {
          "id": "component-strategy-adr-segregated-lists",
          "title": "ADR: Segregated Free Lists for Common Sizes",
          "summary": "Decision record on using multiple free lists binned by size class (e.g., 16, 32, 64 bytes) to turn an O(n) search into an O(1) lookup for small allocations, at the cost of internal fragmentation."
        },
        {
          "id": "component-strategy-implementation",
          "title": "Implementation Guidance",
          "summary": "Skeleton code for strategy function pointers and a table for size classes. Implementation of `malloc_segregated` that maps a request size to a class index and checks the corresponding free list."
        }
      ]
    },
    {
      "id": "component-concurrency",
      "title": "5.4 Concurrency & Advanced Features",
      "summary": "Adds thread safety, per-thread caches, and debugging support to the allocator. Covers Milestone 4.",
      "subsections": [
        {
          "id": "component-concurrency-mental",
          "title": "Mental Model: Multiple Workers in One Warehouse",
          "summary": "Describes the challenge of multiple threads (workers) accessing shared free lists (tool shelves) simultaneously, leading to race conditions, and introduces thread-local caches (personal toolboxes)."
        },
        {
          "id": "component-concurrency-adr-per-thread-arenas",
          "title": "ADR: Per-Thread Arenas with a Global Fallback",
          "summary": "Decision record on giving each thread a small, private heap (arena) for most allocations to avoid locking, with a slower, locked global arena for larger allocations or when the private arena is exhausted."
        },
        {
          "id": "component-concurrency-implementation",
          "title": "Implementation Guidance",
          "summary": "Starter code for a simple mutex wrapper and thread-local storage key. Skeleton for `malloc_thread_cached` that checks a thread-local free list first before acquiring a lock for the shared arena."
        }
      ]
    },
    {
      "id": "interactions",
      "title": "6. Interactions and Data Flow",
      "summary": "Traces the journey of a malloc and free call through the system components, illustrating the decision flow and data transformations.",
      "subsections": [
        {
          "id": "interactions-sequence-malloc",
          "title": "Sequence: malloc(64) in a Thread-Safe, Segregated Allocator",
          "summary": "Step-by-step narrative: Request size 64 -> check thread cache -> mapped to size class 64 -> check segregated list -> if empty, lock global arena, search, split -> return pointer."
        },
        {
          "id": "interactions-sequence-free",
          "title": "Sequence: free(ptr) with Coalescing",
          "summary": "Narrative: Derive header -> mark free -> attempt coalesce with next block (using footer) -> coalesce with previous block -> insert into appropriate free list (thread-local or global)."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "7. Error Handling and Edge Cases",
      "summary": "Details how the allocator should behave when things go wrong (out of memory) or when faced with unusual requests (zero-size allocation).",
      "subsections": [
        {
          "id": "error-handling-failures",
          "title": "Failure Modes and Recovery",
          "summary": "Covers handling sbrk/mmap failure (return NULL), detecting and handling corrupted heap data (e.g., double-free), and strategies for dealing with memory exhaustion."
        },
        {
          "id": "error-handling-edges",
          "title": "Edge Cases: Zero, One, and Huge",
          "summary": "Specifies behavior for malloc(0) (return NULL or a unique pointer), alignment of very small requests, and handling requests larger than the addressable space."
        }
      ]
    },
    {
      "id": "testing",
      "title": "8. Testing Strategy",
      "summary": "Provides a plan for verifying the allocator works correctly, from unit tests to stress tests, with checkpoints for each milestone.",
      "subsections": [
        {
          "id": "testing-approach",
          "title": "Test Categories and Properties",
          "summary": "Describes unit tests for single operations, integration tests for sequences, fragmentation tests, and concurrent stress tests. Lists properties to verify (no memory leaks, pointer alignment, coalescing works)."
        },
        {
          "id": "testing-milestones",
          "title": "Milestone Implementation Checkpoints",
          "summary": "For each milestone, provides a simple test program the learner can run and the expected output or behavior to confirm they are on the right track (e.g., 'After Milestone 1, this program should run without segfault and show reused memory')."
        }
      ]
    },
    {
      "id": "debugging",
      "title": "9. Debugging Guide",
      "summary": "A practical handbook for diagnosing common bugs encountered while building the allocator, using symptoms to identify root causes.",
      "subsections": [
        {
          "id": "debugging-table",
          "title": "Common Bug Symptom \u2192 Cause \u2192 Fix Table",
          "summary": "Table listing symptoms like 'Segmentation fault on free', 'malloc returns unaligned pointer', 'Memory leak in repeated allocations', with likely causes (off-by-one in header size, missing alignment padding, not adding freed block to free list) and diagnostic steps."
        },
        {
          "id": "debugging-techniques",
          "title": "Allocator-Specific Debugging Techniques",
          "summary": "Suggests methods like adding a 'magic number' to headers to detect corruption, writing a heap visualizer function to print the block layout, and using tools like Valgrind and address sanitizers."
        }
      ]
    },
    {
      "id": "future",
      "title": "10. Future Extensions",
      "summary": "Explores potential enhancements to the design, showing how the current architecture could accommodate them.",
      "subsections": [
        {
          "id": "future-extensions",
          "title": "Possible Enhancements",
          "summary": "Ideas for later: adding a 'realloc' function, implementing more sophisticated size classes (like buddy allocation), adding comprehensive memory debugging/statistics, or implementing a garbage collection pass."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "11. Glossary",
      "summary": "Definitions of key terms and acronyms used throughout the document.",
      "subsections": [
        {
          "id": "glossary-terms",
          "title": "Terms and Definitions",
          "summary": "Table of terms: Allocation, Block, Boundary Tag, Coalescing, External Fragmentation, Free List, Header, Internal Fragmentation, mmap, sbrk, Segregated List, Splitting."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "diagram-system-component",
      "title": "High-Level System Component Diagram",
      "description": "Shows the main components of the allocator (User Program, Allocator API, Core Allocator with Strategies, Thread Cache, OS Interface) and their relationships (calls, manages). Arrows indicate flow of calls and memory.",
      "type": "component",
      "relevant_sections": [
        "high-level"
      ]
    },
    {
      "id": "diagram-block-layout",
      "title": "Memory Block Layout with Boundary Tags",
      "description": "A visual representation of a memory block in the heap, showing the header (size, flags, prev/next pointers for free blocks), user payload (aligned), footer (size), and adjacent blocks. Illustrates how headers/footers enable coalescing.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "component-block"
      ]
    },
    {
      "id": "diagram-free-list",
      "title": "Explicit Free List Structure",
      "description": "Shows multiple free blocks scattered through the heap, linked together via the 'next' and 'prev' pointers stored in their payloads. A global 'free_list_head' pointer points to the first free block.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "component-block"
      ]
    },
    {
      "id": "diagram-segregated-lists",
      "title": "Segregated Free Lists by Size Class",
      "description": "Depicts an array of free list heads, one for each size class (e.g., 16, 32, 64...). Each head points to a chain of free blocks belonging to that size class.",
      "type": "component",
      "relevant_sections": [
        "component-strategy"
      ]
    },
    {
      "id": "diagram-sequence-malloc",
      "title": "Sequence Diagram: malloc with Thread Cache",
      "description": "Sequence diagram showing the interaction between a Thread, its Thread-Local Cache, the Global Locked Arena, and the OS (via sbrk) during a malloc call that misses the cache.",
      "type": "sequence",
      "relevant_sections": [
        "interactions",
        "component-concurrency"
      ]
    },
    {
      "id": "diagram-state-block",
      "title": "Block State Machine",
      "description": "A state machine showing the three states of a memory block: ALLOCATED (in use by user), FREE (in free list), and WILDERNESS (the special block at the end of the heap). Transitions are triggered by malloc, free, split, and coalesce operations.",
      "type": "state-machine",
      "relevant_sections": [
        "component-block"
      ]
    },
    {
      "id": "diagram-flowchart-malloc",
      "title": "Flowchart: malloc Decision Logic",
      "description": "A detailed flowchart for the malloc function, starting from size request, checking thread cache and size class, searching segregated/free lists, attempting split, falling back to OS, and finally returning pointer or NULL.",
      "type": "flowchart",
      "relevant_sections": [
        "component-block",
        "component-strategy",
        "interactions"
      ]
    },
    {
      "id": "diagram-flowchart-coalesce",
      "title": "Flowchart: Coalescing Adjacent Free Blocks",
      "description": "Flowchart for the coalesce_block function. Steps: Check if next block is free (using current block's footer), if yes, merge. Check if previous block is free (using current block's header's prev pointer/footer), if yes, merge. Update headers/footers and free list pointers.",
      "type": "flowchart",
      "relevant_sections": [
        "component-block"
      ]
    }
  ]
}