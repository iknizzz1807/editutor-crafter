{
  "title": "Build Your Own BitTorrent: Design Document",
  "overview": "This document outlines the design for a complete BitTorrent client that can download and seed files in a peer-to-peer network. The key architectural challenge is coordinating concurrent downloads from multiple peers while managing piece verification, peer state machines, and tracker communication protocols.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains the BitTorrent protocol problem space, using library borrowing as an analogy for decentralized file sharing.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "The Library Network Analogy",
          "summary": "Mental model comparing BitTorrent to a network of libraries sharing books through catalogs and inter-library loans"
        },
        {
          "id": "protocol-comparison",
          "title": "File Sharing Approaches",
          "summary": "Comparison table of centralized vs decentralized file sharing with trade-offs"
        },
        {
          "id": "technical-challenges",
          "title": "Core Technical Challenges",
          "summary": "The unique problems BitTorrent solves: peer discovery, content verification, and fair sharing incentives"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what our BitTorrent client will and will not implement, setting clear scope boundaries.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Core BitTorrent functionality: parsing torrents, downloading, seeding, tracker communication"
        },
        {
          "id": "non-functional-goals",
          "title": "Non-Functional Goals",
          "summary": "Performance, reliability, and usability requirements"
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Features we will NOT implement: DHT, magnet links, encryption, web seeding"
        }
      ]
    },
    {
      "id": "architecture-overview",
      "title": "High-Level Architecture",
      "summary": "System component overview showing how the torrent parser, tracker client, peer manager, and piece manager interact.",
      "subsections": [
        {
          "id": "component-responsibilities",
          "title": "Component Responsibilities",
          "summary": "Table of each major component's role and key interfaces"
        },
        {
          "id": "module-structure",
          "title": "Recommended Module Structure",
          "summary": "File and package organization for the Go implementation"
        },
        {
          "id": "data-flow-overview",
          "title": "High-Level Data Flow",
          "summary": "How torrent files flow through parsing, tracker communication, peer discovery, and download orchestration"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Core data structures including torrent metadata, peer information, piece state, and message formats.",
      "subsections": [
        {
          "id": "torrent-structures",
          "title": "Torrent Metadata Structures",
          "summary": "Structures for representing parsed torrent files and their info dictionaries"
        },
        {
          "id": "peer-structures",
          "title": "Peer and Connection State",
          "summary": "Data structures for managing peer connections and their choking/interested state"
        },
        {
          "id": "piece-structures",
          "title": "Piece and Block Management",
          "summary": "Structures for tracking piece download progress and block requests"
        },
        {
          "id": "protocol-messages",
          "title": "Protocol Message Formats",
          "summary": "Wire protocol message structures for peer communication"
        }
      ]
    },
    {
      "id": "torrent-parsing",
      "title": "Torrent File Parsing (Milestone 1)",
      "summary": "Implements Bencode decoding and torrent metadata extraction with proper info hash calculation.",
      "subsections": [
        {
          "id": "bencode-mental-model",
          "title": "Bencode: Binary JSON Analogy",
          "summary": "Mental model comparing Bencode to JSON with binary string support"
        },
        {
          "id": "bencode-decoder",
          "title": "Bencode Decoder Design",
          "summary": "Recursive descent parser for the four Bencode types with proper byte handling"
        },
        {
          "id": "metainfo-extraction",
          "title": "Torrent Metadata Extraction",
          "summary": "Algorithm for extracting announce URL, file info, and piece data from parsed Bencode"
        },
        {
          "id": "info-hash-calculation",
          "title": "Info Hash Calculation",
          "summary": "Critical process of computing SHA1 from exact bencoded bytes of info dictionary"
        },
        {
          "id": "parsing-pitfalls",
          "title": "Common Parsing Pitfalls",
          "summary": "Mistakes with binary strings, info dict boundaries, and encoding edge cases"
        },
        {
          "id": "parsing-implementation",
          "title": "Implementation Guidance",
          "summary": "Go-specific bencode parsing with complete infrastructure code and skeleton for core logic"
        }
      ]
    },
    {
      "id": "tracker-communication",
      "title": "Tracker Communication (Milestone 2)",
      "summary": "Implements HTTP tracker protocol for peer discovery with proper URL encoding and response parsing.",
      "subsections": [
        {
          "id": "tracker-mental-model",
          "title": "Tracker as Matchmaking Service",
          "summary": "Mental model of tracker as a dating app that connects peers interested in the same files"
        },
        {
          "id": "announce-request",
          "title": "Announce Request Protocol",
          "summary": "HTTP GET request format with required parameters and URL encoding rules"
        },
        {
          "id": "peer-list-parsing",
          "title": "Peer List Response Parsing",
          "summary": "Compact peer format decoding and periodic re-announce scheduling"
        },
        {
          "id": "tracker-error-handling",
          "title": "Tracker Error Handling",
          "summary": "Handling tracker failures, retry logic, and fallback strategies"
        },
        {
          "id": "tracker-implementation",
          "title": "Implementation Guidance",
          "summary": "HTTP client setup and tracker protocol implementation with proper error handling"
        }
      ]
    },
    {
      "id": "peer-protocol",
      "title": "Peer Wire Protocol (Milestone 3)",
      "summary": "Implements the BitTorrent peer wire protocol including handshakes, message framing, and state machines.",
      "subsections": [
        {
          "id": "peer-mental-model",
          "title": "Peer Protocol as Conversation Rules",
          "summary": "Mental model of peer protocol as formal conversation rules with greeting, interests, and requests"
        },
        {
          "id": "handshake-protocol",
          "title": "Connection Handshake",
          "summary": "68-byte handshake format and info hash verification process"
        },
        {
          "id": "message-framing",
          "title": "Message Framing and Parsing",
          "summary": "Length-prefixed message format and parsing state machine"
        },
        {
          "id": "peer-state-machine",
          "title": "Peer State Management",
          "summary": "Four-flag state machine for choking and interest states with transition rules"
        },
        {
          "id": "request-pipeline",
          "title": "Request Pipelining",
          "summary": "Managing multiple outstanding block requests for throughput optimization"
        },
        {
          "id": "protocol-pitfalls",
          "title": "Common Protocol Pitfalls",
          "summary": "Endianness issues, partial reads, and blocking on choked peers"
        },
        {
          "id": "protocol-implementation",
          "title": "Implementation Guidance",
          "summary": "TCP connection management and message parsing with proper state tracking"
        }
      ]
    },
    {
      "id": "piece-management",
      "title": "Piece Management & Seeding (Milestone 4)",
      "summary": "Implements piece verification, download scheduling, and upload capabilities for complete BitTorrent functionality.",
      "subsections": [
        {
          "id": "piece-mental-model",
          "title": "Piece Management as Jigsaw Puzzle",
          "summary": "Mental model of download as assembling a jigsaw puzzle with verification and rarity-based selection"
        },
        {
          "id": "piece-verification",
          "title": "Content Verification",
          "summary": "SHA1 hash verification of downloaded pieces and corrupt piece handling"
        },
        {
          "id": "piece-selection",
          "title": "Piece Selection Strategy",
          "summary": "Rarest-first algorithm and endgame mode for efficient downloading"
        },
        {
          "id": "concurrent-downloads",
          "title": "Concurrent Download Management",
          "summary": "Managing downloads from multiple peers with piece coordination"
        },
        {
          "id": "seeding-upload",
          "title": "Upload and Seeding",
          "summary": "Serving piece data to other peers and tracking upload statistics"
        },
        {
          "id": "piece-pitfalls",
          "title": "Common Piece Management Pitfalls",
          "summary": "Race conditions, hash failures, and connection management issues"
        },
        {
          "id": "piece-implementation",
          "title": "Implementation Guidance",
          "summary": "Piece scheduling algorithms and concurrent download coordination"
        }
      ]
    },
    {
      "id": "interactions-dataflow",
      "title": "Interactions and Data Flow",
      "summary": "Describes how all components work together during the complete download lifecycle from torrent to completed file.",
      "subsections": [
        {
          "id": "download-lifecycle",
          "title": "Complete Download Lifecycle",
          "summary": "Step-by-step sequence from torrent parsing to file completion"
        },
        {
          "id": "component-interactions",
          "title": "Inter-Component Communication",
          "summary": "Message passing and shared state between tracker, peer, and piece managers"
        },
        {
          "id": "concurrency-coordination",
          "title": "Concurrency Coordination",
          "summary": "Synchronization points and shared data structure access patterns"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Comprehensive error handling strategies for network failures, corrupt data, and peer misbehavior.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "System Failure Modes",
          "summary": "Catalog of possible failures and their detection mechanisms"
        },
        {
          "id": "recovery-strategies",
          "title": "Recovery and Retry Logic",
          "summary": "How to handle and recover from different types of failures"
        },
        {
          "id": "edge-case-handling",
          "title": "Protocol Edge Cases",
          "summary": "Handling malformed messages, unexpected peer behavior, and corner cases"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy and Milestones",
      "summary": "Testing approach with milestone checkpoints and verification steps for each phase of implementation.",
      "subsections": [
        {
          "id": "unit-testing",
          "title": "Unit Testing Strategy",
          "summary": "Testing individual components like Bencode parsing and piece verification"
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing",
          "summary": "End-to-end testing with real torrents and peer interactions"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "After each milestone, what behavior to verify and expected outputs"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common bugs learners encounter when implementing BitTorrent, with symptom-cause-fix mappings.",
      "subsections": [
        {
          "id": "parsing-debugging",
          "title": "Torrent Parsing Debug Guide",
          "summary": "Debugging Bencode parsing and info hash calculation issues"
        },
        {
          "id": "network-debugging",
          "title": "Network Protocol Debugging",
          "summary": "Diagnosing tracker communication and peer protocol issues"
        },
        {
          "id": "concurrency-debugging",
          "title": "Concurrency and State Issues",
          "summary": "Debugging race conditions and state machine problems"
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools and Techniques",
          "summary": "Logging strategies, packet capture, and state inspection tools"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Advanced BitTorrent features that could be added later, and how the current design accommodates them.",
      "subsections": [
        {
          "id": "advanced-features",
          "title": "Advanced Protocol Features",
          "summary": "DHT, magnet links, encryption, and multi-tracker support"
        },
        {
          "id": "performance-optimizations",
          "title": "Performance Optimizations",
          "summary": "Advanced piece selection, bandwidth management, and connection optimization"
        },
        {
          "id": "ui-integration",
          "title": "User Interface Integration",
          "summary": "How to integrate the core engine with GUI or web interfaces"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of BitTorrent-specific terms, protocols, and technical concepts used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "BitTorrent Client Architecture",
      "description": "High-level component diagram showing TorrentParser, TrackerClient, PeerManager, PieceManager, and their interactions with external entities like trackers and peers",
      "type": "component",
      "relevant_sections": [
        "architecture-overview",
        "interactions-dataflow"
      ]
    },
    {
      "id": "data-model",
      "title": "Core Data Structures",
      "description": "Class diagram showing relationships between Torrent, PeerInfo, PieceState, and Message types with their key fields",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "torrent-parsing"
      ]
    },
    {
      "id": "peer-state-machine",
      "title": "Peer Connection State Machine",
      "description": "State machine diagram showing the four peer states (choked/unchoked \u00d7 interested/not interested) and message transitions between them",
      "type": "state-machine",
      "relevant_sections": [
        "peer-protocol"
      ]
    },
    {
      "id": "download-sequence",
      "title": "Complete Download Flow",
      "description": "Sequence diagram showing the full lifecycle from parsing torrent file through tracker announce, peer handshake, piece requests, and file completion",
      "type": "sequence",
      "relevant_sections": [
        "interactions-dataflow",
        "tracker-communication",
        "peer-protocol"
      ]
    },
    {
      "id": "piece-selection-flow",
      "title": "Piece Selection Algorithm",
      "description": "Flowchart showing rarest-first piece selection logic, including availability counting, piece prioritization, and endgame mode transitions",
      "type": "flowchart",
      "relevant_sections": [
        "piece-management"
      ]
    },
    {
      "id": "message-parsing-flow",
      "title": "Peer Message Parsing",
      "description": "Flowchart showing message parsing state machine from reading length prefix through message type dispatch and payload processing",
      "type": "flowchart",
      "relevant_sections": [
        "peer-protocol"
      ]
    },
    {
      "id": "bencode-parsing",
      "title": "Bencode Parsing State Machine",
      "description": "State machine for the recursive descent Bencode parser, showing transitions for strings, integers, lists, and dictionaries",
      "type": "state-machine",
      "relevant_sections": [
        "torrent-parsing"
      ]
    },
    {
      "id": "concurrent-download",
      "title": "Multi-Peer Download Coordination",
      "description": "Component diagram showing how PieceManager coordinates downloads from multiple PeerConnection instances with shared piece availability and request queues",
      "type": "component",
      "relevant_sections": [
        "piece-management",
        "interactions-dataflow"
      ]
    }
  ]
}