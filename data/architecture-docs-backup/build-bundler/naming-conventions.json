{
  "types": {
    "ModuleNode": "fields: id string, filePath string, dependencies Map<string,string>, dependents Set<string>, exports Set<string>, imports Map<string,ImportSpecifier>, ast object, source string, sideEffects boolean, isEntry boolean, usedExports Set<string>, reexports Map<string,{source: string, exported: string}>, dynamicImports Array<{specifier: string, location: any}>",
    "ModuleGraph": "fields: nodes Map<string,ModuleNode>",
    "BundleChunk": "fields: id string, modules Set<string>, code string, sourceMap SourceMapV3|null",
    "FSCache": "fields: cache Map<string,CacheEntry>, ttl number",
    "CacheEntry": "fields: content string, timestamp number, filePath string",
    "BundlerOptions": "fields: entryPoints string[], outDir string, outFile string, sourceMap boolean, minify boolean",
    "SourceMapV3": "fields: version number, file string, sourceRoot string, sources string[], sourcesContent string[], names string[], mappings string",
    "ImportSpecifier": "fields: specifier string, type 'static'|'dynamic', imported string|'*'|'default'|null, local string, sourceLocation {line: number, column: number}",
    "ExportSpecifier": "fields: exported string, local string|null, source string|null, type 'named'|'default'|'namespace'|'all', sourceLocation {line: number, column: number}",
    "DynamicImport": "fields: specifier string|{type: 'TemplateLiteral'}, sourceLocation {line: number, column: number}, isStaticSpecifier boolean",
    "ResolutionContext": "fields: extensions string[], mainFields string[], preserveSymlinks boolean, fsCache FSCache, resolutionCache Map<string,string>, visitedSymlinks Set<string>",
    "SourceMapManager": "fields: generator SourceMapGenerator, sourceIndexMap Map<string,number>, hasContent boolean",
    "StructuredError": "fields: code string, message string, severity string, location object|null, specifier string|null, importer string|null, suggestions string[], cause Error|null",
    "DiagnosticBag": "fields: diagnostics StructuredError[]",
    "DiagnosticSeverity": "type: 'error' | 'warning' | 'info'",
    "MockFileSystem": "fields: files Map<string,string>, dirs Set<string>",
    "DiagnosticCollector": "fields: bag DiagnosticBag",
    "Plugin": "fields: name string, hooks object, enforce 'pre'|'post'|null",
    "PluginContext": "fields: bundler object, plugin Plugin, warn function, resolve function",
    "HookRegistry": "fields: hooks Map<string,Hook>",
    "IncrementalBuilder": "fields: bundler object, cache Map<string,CacheEntry>, watcher object",
    "ChunkGraph": "fields: chunks Map<string,BundleChunk>, entries Set<string>, asyncBoundaries Map<string,Set<string>>",
    "AssetRegistry": "fields: assets Map<string,AssetEntry>, hashAlgorithm string",
    "AssetEntry": "fields: originalPath string, outputPath string, content Buffer, hash string, type string"
  },
  "methods": {
    "GraphBuilder.build(entryPaths) returns Promise<ModuleGraph>": "Builds complete module graph from entry points",
    "FSCache.readFile(filePath) returns Promise<string>": "Reads file with caching",
    "ModuleNode.addDependency(specifier, moduleId)": "Adds dependency to another module",
    "ModuleNode.addExport(exportName)": "Adds export to module's public interface",
    "ModuleNode.markExportUsed(exportName)": "Marks export as used during tree shaking",
    "ModuleNode.shouldIncludeInBundle() returns boolean": "Determines if module should be included",
    "Bundler.build() returns Promise<BundleChunk[]>": "Main bundling pipeline with integrated error handling",
    "ModuleGraph.addModule(module) returns void": "Adds module to graph, throws if duplicate",
    "ModuleGraph.build(entryPaths) returns Promise<ModuleGraph>": "Builds complete graph from entry points via BFS",
    "ModuleGraph.markUsedExports(entryModuleId) returns void": "Marks all exports reachable from the given entry module",
    "ModuleGraph.shake() returns ModuleGraph": "Removes unused modules and exports from the graph",
    "ModuleGraph.topologicalSort() returns ModuleNode[]": "Sorts modules in dependency order with cycle handling",
    "ModuleNode.addDependency(specifier, moduleId) returns void": "Adds dependency mapping",
    "ModuleNode.addExport(exportName) returns void": "Adds export to public interface",
    "ModuleNode.markExportUsed(exportName) returns void": "Marks export as used in tree shaking",
    "ModuleNode.addDependency(specifier, moduleId) returns": "Records a dependency from this module to another",
    "ModuleNode.addExport(exportName) returns": "Adds an export name to this module's public interface",
    "ModuleNode.markExportUsed(exportName) returns": "Marks an export as used during tree shaking analysis",
    "ModuleNode.shouldIncludeInBundle() returns": "Determines if this module should be included in the final bundle",
    "ModuleGraph.addModule(module) returns": "Adds a module to the graph, ensuring no duplicates",
    "ModuleGraph.getModule(id) returns": "Gets a module by ID",
    "ModuleGraph.linkDependency(importerId, specifier, dependencyId) returns": "Creates a bidirectional link between importer and dependency",
    "ModuleGraph.build(entryPaths) returns": "High-level graph construction from entry points",
    "ModuleGraph.markUsedExports(entryModuleId) returns": "Marks all exports reachable from the given entry module",
    "ModuleGraph.shake() returns": "Removes unused modules and exports from the graph",
    "ModuleGraph.topologicalSort() returns": "Returns modules in topological order (dependencies before dependents)",
    "BundleChunk.addModule(moduleId) returns": "Adds a module to this chunk",
    "BundleChunk.estimateSize() returns": "Estimates the size of this chunk in bytes",
    "BundleChunk.getFileName() returns": "Generates a filename for this chunk",
    "parseModule(sourceCode, filePath) returns": "Parses source code into AST and extracts all dependencies",
    "extractDependencies(ast) returns": "Traverses AST to extract dependency information",
    "createModuleNode(filePath, sourceCode, isEntry) returns ModuleNode": "Factory function that parses source and creates ModuleNode",
    "processImportDeclaration(node) returns Array<ImportSpecifier>": "Extracts import statements from AST nodes",
    "resolve(specifier, fromDir) returns Promise<string>": "Main resolution method",
    "_resolvePath(specifier, fromDir) returns Promise<string>": "Resolve relative/absolute paths",
    "_resolveBareSpecifier(specifier, fromDir) returns Promise<string>": "Resolve bare specifiers",
    "_findPackageDir(packageName, startDir) returns Promise<string>": "Find package in node_modules",
    "_resolveExports(pkg, subpath, packageDir) returns Promise<string|null>": "Handle package.json exports",
    "ModuleGraph.getModule(id) returns ModuleNode|undefined": "Gets module by ID",
    "ModuleGraph.linkDependency(importerId, specifier, dependencyId) returns void": "Creates bidirectional dependency link",
    "generateBundle(moduleGraph, options) returns Promise<BundleChunk[]>": "Main entry point for bundle generation",
    "rewriteModuleAST(moduleNode, moduleGraph) returns Object": "Transforms a module's AST to replace imports/exports with runtime calls",
    "BundleChunk.addModule(moduleId) returns void": "Adds a module to this chunk.",
    "BundleChunk.estimateSize() returns number": "Estimates the size of this chunk in bytes.",
    "BundleChunk.getFileName() returns string": "Generates a filename for this chunk.",
    "SourceMapManager.addSource(sourcePath, sourceContent) returns number": "Adds a source file to the source map.",
    "SourceMapManager.addMapping(mapping) returns void": "Adds a mapping from generated to original position.",
    "SourceMapManager.toJSON() returns SourceMapV3": "Returns the final Source Map V3 object.",
    "SourceMapManager.toBase64() returns string": "Returns source map as base64 string.",
    "SourceMapManager.getComment(outFileName, inline) returns string": "Returns source map comment for bundle.",
    "DiagnosticBag.add(diagnostic, options) returns void": "Adds a diagnostic, applying strict mode and warning handler",
    "DiagnosticBag.hasErrors() returns boolean": "Returns true if any errors exist in the bag",
    "DiagnosticBag.getAll() returns object": "Returns diagnostics grouped by severity",
    "DiagnosticBag.clear() returns void": "Clears all collected diagnostics",
    "resolve(specifier, fromDir, context) returns Promise<string>": "Main resolution method with error wrapping",
    "MockFileSystem.addFile(path, content) returns void": "Adds a file to the mock file system",
    "MockFileSystem.readFile(path, encoding) returns Promise<string|Buffer>": "Simulates file reading",
    "DiagnosticCollector.expectError(code, pattern) returns void": "Asserts that an error with given code exists in the bag",
    "DiagnosticCollector.assertNoErrors() returns void": "Throws if any errors are present in the bag",
    "GraphLogger.printGraph(moduleGraph, options) returns void": "Prints the entire module graph to console",
    "GraphLogger.exportDot(moduleGraph, options) returns string": "Exports graph in DOT format for visualization",
    "PluginContext.warn(message, location) returns void": "Adds warning diagnostic from plugin",
    "PluginContext.resolve(specifier, importer) returns Promise<string>": "Resolves module specifier through bundler",
    "HookRegistry.registerHook(name, options) returns Hook": "Creates new hook in registry",
    "HookRegistry.callHook(name, context, ...args) returns Promise<any>": "Calls hook with arguments",
    "IncrementalBuilder.watch(entryPoints, options) returns Promise<void>": "Starts watch mode with incremental rebuilds",
    "ChunkGraph.addAsyncBoundary(moduleId, importSpecifier) returns void": "Marks dynamic import boundary for chunk splitting",
    "AssetRegistry.registerAsset(filePath, content) returns string": "Registers asset and returns output path"
  },
  "constants": {
    "ERROR_CODES": "Object containing error code constants like MODULE_NOT_FOUND, PARSE_ERROR",
    "HOOK_NAMES": "Array of all available hook names: resolveId, load, transform, moduleParsed, buildEnd, generateBundle",
    "CHUNK_STRATEGIES": "Object with chunk splitting strategies: ENTRY, DYNAMIC, VENDOR, COMMON",
    "ASSET_TYPES": "Object mapping file extensions to asset types: CSS, IMAGE, FONT, OTHER"
  },
  "terms": {
    "AST": "Abstract Syntax Tree - hierarchical representation of code structure",
    "ESM": "ECMAScript Modules - JavaScript's native module system",
    "CommonJS": "Node.js's module system using require() and module.exports",
    "Tree shaking": "Dead code elimination through static analysis",
    "Module resolution": "Process of translating module specifiers to file paths",
    "HMR": "Hot Module Replacement - updating modules at runtime without full reload",
    "IIFE": "Immediately Invoked Function Expression - common bundle wrapper format",
    "Source Map": "File mapping bundled code back to original source locations",
    "Pipeline pattern": "Architectural pattern where data flows through sequential processing stages",
    "Unidirectional data flow": "Design where data moves in one direction through components",
    "directed graph": "Graph with edges having direction from source to target",
    "bidirectional navigation": "Ability to traverse both from dependencies to dependents and vice versa",
    "post-order dependency order": "Topological order where dependencies come before dependents",
    "transitive closure": "Complete set of all modules reachable from starting points",
    "mark-and-sweep": "Garbage collection algorithm adapted for tree shaking",
    "canonical form": "Standardized representation that eliminates superficial differences",
    "live bindings": "JavaScript ESM feature where imports are live references to exports",
    "specifier": "The string in an import/export statement that identifies the module to load",
    "re-export": "An export statement that forwards exports from another module",
    "dynamic import": "The import() function call that loads modules at runtime",
    "bare specifier": "Module specifier without ./ or / prefix",
    "package subpath": "Path within a package like lodash/map",
    "conditional exports": "Package.json exports field with import/require conditions",
    "symlink resolution": "Process of following symbolic links to real files",
    "strongly connected components": "Maximal subgraphs where every node is reachable from every other (cycles)",
    "worklist algorithm": "Algorithm that processes items from a list, adding new items as they're discovered",
    "side effect detection": "Identifying code that modifies global state beyond its exports",
    "circular dependencies": "When two or more modules import each other.",
    "re-export chains": "Multiple layers of modules that forward exports from original source",
    "topological sort": "Sorting where dependencies come before dependents.",
    "factory function": "Wrapper function for a module's code, stored for later execution.",
    "source map mappings": "VLQ-encoded string mapping bundled code positions to original source positions",
    "unidirectional pipeline pattern": "Architectural pattern where data flows through sequential processing stages",
    "fail-fast": "Stopping execution immediately upon encountering a critical error",
    "structured error": "An error object with consistent fields for code, location, and suggestions",
    "diagnostic": "A message about the build, can be error, warning, or info",
    "conservative default": "Assuming the safest (most inclusive) behavior when analysis fails",
    "property-based testing": "Testing technique that verifies properties hold for a large number of randomly generated inputs",
    "snapshot testing": "Testing technique that compares current output to a previously stored 'golden' snapshot",
    "fixture project": "A self-contained temporary project used for integration testing",
    "golden reference": "A known-good output file used for comparison in snapshot testing",
    "module graph": "Directed graph of modules connected by import/export relationships",
    "tree shaking": "Dead code elimination through static analysis",
    "plugin system": "Architecture allowing third-party code to extend bundler functionality via hooks",
    "hot module replacement": "Runtime updating of modules without full page reload",
    "chunk splitting": "Dividing bundle into multiple files for lazy loading",
    "content hash": "Filename suffix derived from file content for cache busting",
    "CSS modules": "CSS scoping technique generating unique class names",
    "incremental rebuild": "Rebuilding only changed modules and dependents",
    "hook points": "Specific lifecycle stages where plugins can intercept processing",
    "async boundary": "Dynamic import point that creates separate chunk",
    "asset registry": "Central tracking of non-JS resources and their output paths",
    "HMR runtime": "Client-side code managing hot updates",
    "chunk manifest": "Mapping from module IDs to chunk files for runtime resolution"
  }
}