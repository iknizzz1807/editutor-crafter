{
  "title": "Build Your Own Bundler: Design Document",
  "overview": "This system transforms a collection of modular JavaScript/TypeScript files into optimized, production-ready bundles. The key architectural challenge is implementing static analysis on a graph of dependencies to perform tree shaking and code splitting, while accurately emulating complex Node.js module resolution rules and maintaining correct runtime semantics.",
  "sections": [
    {
      "id": "context",
      "title": "Context and Problem Statement",
      "summary": "Explains the core problem of managing JavaScript modules for the web, the evolution of module systems, and why building a bundler is a complex but educational challenge.",
      "subsections": [
        {
          "id": "analogy",
          "title": "Mental Model: The Library Consolidation Project",
          "summary": "Frames a bundler as a project to consolidate scattered book chapters (modules) from a library into ordered, minified volumes (bundles)."
        },
        {
          "id": "problem",
          "title": "The Module Management Problem",
          "summary": "Describes the divergence of module formats (ESM, CommonJS) and the need for resolution, concatenation, and optimization for browser delivery."
        },
        {
          "id": "existing",
          "title": "Existing Solutions",
          "summary": "Compares webpack, Rollup, and esbuild with a table focusing on their architecture, plugin systems, and primary optimization strategies."
        }
      ]
    },
    {
      "id": "goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the scope of the educational bundler, specifying what must be implemented and what is explicitly out of scope.",
      "subsections": [
        {
          "id": "goals-list",
          "title": "Goals",
          "summary": "Must support ES Module parsing, Node.js resolution, a basic runtime, tree shaking, and generate a functioning bundle with source maps."
        },
        {
          "id": "non-goals",
          "title": "Non-Goals",
          "summary": "Will not implement hot module replacement (HMR), a full plugin ecosystem, on-disk caching, or support for non-JS assets (CSS, images) without extensions."
        }
      ]
    },
    {
      "id": "architecture",
      "title": "High-Level Architecture",
      "summary": "Presents the component diagram and explains the pipeline from entry point to final bundle, describing each component's role.",
      "subsections": [
        {
          "id": "component-diagram",
          "title": "System Overview",
          "summary": "Describes the core pipeline: Parser \u2192 Resolver \u2192 Graph Builder \u2192 Transformer \u2192 Code Generator."
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "Provides a suggested codebase layout for clarity and separation of concerns, using JavaScript/TypeScript."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the core data structures that represent modules, the dependency graph, and the final bundle.",
      "subsections": [
        {
          "id": "module-node",
          "title": "Module Node",
          "summary": "Describes the object representing a single source file: its ID, absolute path, AST, dependencies, exports, and whether it has side effects."
        },
        {
          "id": "module-graph",
          "title": "Module Graph",
          "summary": "Describes the directed graph structure connecting Module Nodes via import/export relationships."
        },
        {
          "id": "bundle-chunk",
          "title": "Bundle Chunk",
          "summary": "Describes the unit of output, containing a list of module IDs and the generated runtime wrapper code."
        }
      ]
    },
    {
      "id": "component-parser",
      "title": "Component 1: Parser & Dependency Extractor",
      "summary": "Covers the first stage: reading source files, generating an AST, and statically analyzing it to find import/export statements. (Corresponds to Milestone 1)",
      "subsections": [
        {
          "id": "parser-mental",
          "title": "Mental Model: The Code Archaeologist",
          "summary": "Explains parsing as meticulously excavating a code file to map out its formal structure (AST) and record all outward references (imports)."
        },
        {
          "id": "parser-interface",
          "title": "Interface",
          "summary": "Defines the function signatures for parsing a file and extracting its dependencies."
        },
        {
          "id": "parser-algorithm",
          "title": "Parsing Algorithm",
          "summary": "Step-by-step process: Read file, choose parser based on extension, generate AST, traverse for import/export nodes."
        },
        {
          "id": "parser-adr",
          "title": "ADR: Choosing an AST Parser",
          "summary": "Context: Need a reliable parser for JS/TS. Options: Acorn, Babel Parser, TypeScript Compiler API. Decision: Use `@babel/parser` for its robustness and plugin support."
        },
        {
          "id": "parser-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Missing file extensions, confusing re-exports, and failing to handle dynamic `import()` as a code-split point."
        },
        {
          "id": "parser-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for file reading and Babel setup, and skeleton code for the dependency extraction traversal."
        }
      ]
    },
    {
      "id": "component-resolver",
      "title": "Component 2: Module Resolver",
      "summary": "Covers translating module specifiers (like `./utils` or `lodash`) into absolute file system paths. (Corresponds to Milestone 2)",
      "subsections": [
        {
          "id": "resolver-mental",
          "title": "Mental Model: The Address Translator",
          "summary": "Compares module resolution to a postal service that turns a name or relative address into a precise, deliverable location."
        },
        {
          "id": "resolver-interface",
          "title": "Interface",
          "summary": "Defines the `resolve(specifier, fromDir)` function."
        },
        {
          "id": "resolver-algorithm",
          "title": "Resolution Algorithm",
          "summary": "Steps for relative/absolute paths, node_modules traversal, and package.json field (`main`, `exports`) lookup."
        },
        {
          "id": "resolver-adr",
          "title": "ADR: Implementing Node Resolution",
          "summary": "Context: Must mimic Node's algorithm. Options: Implement from spec, use `resolve` npm package. Decision: Implement core algorithm for learning, use `resolve` for advanced cases."
        },
        {
          "id": "resolver-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Infinite loops in symlinks, misordering `package.json` field priority, and incorrect handling of the `exports` map."
        },
        {
          "id": "resolver-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides helper for `package.json` reading and skeleton code for the directory traversal logic."
        }
      ]
    },
    {
      "id": "component-graph",
      "title": "Component 3: Graph Builder & Transformer",
      "summary": "Covers constructing the complete dependency graph, performing tree shaking, and preparing modules for bundling. (Corresponds to Milestones 1, 3 & 4)",
      "subsections": [
        {
          "id": "graph-mental",
          "title": "Mental Model: The Dependency Cartographer",
          "summary": "Explains building the module graph as drawing a map of an island chain (modules) with bridges (imports), then deciding which islands are essential for the treasure (used exports)."
        },
        {
          "id": "graph-interface",
          "title": "Interface",
          "summary": "Defines the `ModuleGraph` class and its methods for adding nodes, marking used exports, and shaking."
        },
        {
          "id": "graph-algorithm",
          "summary": "Steps: 1. Build graph via BFS from entry. 2. Mark used exports from entry. 3. Prune unused nodes/exports. 4. Topologically sort for bundling.",
          "title": "Graph Construction & Shaking Algorithm"
        },
        {
          "id": "graph-adr",
          "title": "ADR: Tree Shaking Algorithm Choice",
          "summary": "Context: Need to eliminate dead code. Options: Mark-and-sweep from entry, Reverse import graph traversal. Decision: Use mark-and-sweep for simplicity and clarity."
        },
        {
          "id": "graph-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Circular dependencies causing sort failure, missing side effects in `package.json`, and incorrectly removing code with global side effects (e.g., polyfills)."
        },
        {
          "id": "graph-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides `ModuleGraph` class skeleton and TODO functions for graph traversal and export marking."
        }
      ]
    },
    {
      "id": "component-generator",
      "title": "Component 4: Code Generator & Runtime",
      "summary": "Covers generating the final bundle code, including the module runtime wrapper and source maps. (Corresponds to Milestone 3)",
      "subsections": [
        {
          "id": "generator-mental",
          "title": "Mental Model: The Play Script Rewriter",
          "summary": "Compares bundling to taking actor scripts (modules), rewriting their character names (imports/exports) to avoid conflicts, and adding stage directions (runtime) for loading them in order."
        },
        {
          "id": "generator-interface",
          "title": "Interface",
          "summary": "Defines the `generateBundle(moduleGraph)` function."
        },
        {
          "id": "generator-algorithm",
          "title": "Code Generation Algorithm",
          "summary": "Steps: 1. Generate runtime loader function. 2. For each module in sorted order, wrap its AST in a factory function. 3. Rewrite imports/exports to use runtime. 4. Print final code and source map."
        },
        {
          "id": "generator-adr",
          "title": "ADR: Module Wrapping Strategy",
          "summary": "Context: Need to isolate module scope. Options: IIFE per module, Function wrapper with parameters. Decision: Use function wrapper for clarity and ease of implementing live bindings."
        },
        {
          "id": "generator-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Incorrectly rewriting default vs named exports, breaking source map mappings, and creating runtime errors due to misordered execution."
        },
        {
          "id": "generator-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides complete starter code for a basic source map generator and skeleton code for the module wrapping and import/export rewriting logic."
        }
      ]
    },
    {
      "id": "interactions",
      "title": "Interactions and Data Flow",
      "summary": "Describes the sequence of operations when the bundler runs, from CLI invocation to writing the output file.",
      "subsections": [
        {
          "id": "sequence",
          "title": "Bundling Sequence",
          "summary": "Step-by-step walkthrough of the main pipeline with a focus on data transformation between components."
        },
        {
          "id": "message-formats",
          "title": "Internal Message Formats",
          "summary": "Describes the structure of errors, warnings, and logging events passed between components."
        }
      ]
    },
    {
      "id": "errors",
      "title": "Error Handling and Edge Cases",
      "summary": "Covers how the system detects and recovers from (or fails gracefully on) common errors and edge cases.",
      "subsections": [
        {
          "id": "failures",
          "title": "Failure Modes",
          "summary": "Lists errors like unresolved modules, parse errors, circular dependencies, and missing `package.json`."
        },
        {
          "id": "recovery",
          "title": "Recovery Strategies",
          "summary": "Explains strategies: fail-fast with descriptive errors, warnings for non-critical issues, and configurable bail-out options."
        }
      ]
    },
    {
      "id": "testing",
      "title": "Testing Strategy",
      "summary": "Outlines how to test the bundler, with specific checkpoints for each milestone to verify progress.",
      "subsections": [
        {
          "id": "strategy",
          "title": "Testing Approach",
          "summary": "Recommends unit tests for resolvers and parsers, integration tests with fixture projects, and snapshot testing for generated bundles."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "For each milestone, specifies a command to run and the expected output or behavior to confirm successful implementation."
        }
      ]
    },
    {
      "id": "debugging",
      "title": "Debugging Guide",
      "summary": "Provides a symptom-cause-fix table for common bugs learners encounter, along with targeted debugging techniques.",
      "subsections": [
        {
          "id": "symptom-table",
          "title": "Common Bug Table",
          "summary": "Table listing symptoms (e.g., 'Runtime Error: module not found'), likely causes, and fixes."
        },
        {
          "id": "techniques",
          "title": "Debugging Techniques",
          "summary": "Suggests methods: logging the module graph, inspecting generated AST, and using the Node.js debugger."
        }
      ]
    },
    {
      "id": "extensions",
      "title": "Future Extensions",
      "summary": "Suggests possible enhancements to the project, such as plugins, watch mode, and different output formats.",
      "subsections": [
        {
          "id": "ideas",
          "title": "Extension Ideas",
          "summary": "Lists features like a plugin system, support for CSS modules, on-disk caching for performance, and dev server with HMR."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Defines key terms used throughout the document, such as AST, ESM, tree shaking, and specifier.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-components",
      "title": "Bundler System Component Diagram",
      "description": "Shows the main components (CLI, Parser, Resolver, Graph, Transformer, Generator) and the data flow between them. Include arrows for the primary pipeline and feedback for graph resolution.",
      "type": "component",
      "relevant_sections": [
        "architecture"
      ]
    },
    {
      "id": "data-model-types",
      "title": "Core Data Type Relationships",
      "description": "A class diagram showing the ModuleNode, ModuleGraph, and BundleChunk types and their relationships (e.g., ModuleGraph contains ModuleNodes, ModuleNode has dependencies to other ModuleNodes).",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "resolution-sequence",
      "title": "Module Resolution Sequence",
      "description": "A sequence diagram showing the interaction between the Resolver and the file system when resolving a bare specifier like 'lodash'. Include steps: check node_modules, read package.json, evaluate exports field.",
      "type": "sequence",
      "relevant_sections": [
        "component-resolver",
        "interactions"
      ]
    },
    {
      "id": "tree-shaking-flow",
      "title": "Tree Shaking Process Flowchart",
      "description": "A flowchart illustrating the mark-and-sweep algorithm for tree shaking. Start from entry point, mark used exports, traverse imports, then prune unmarked nodes and exports.",
      "type": "flowchart",
      "relevant_sections": [
        "component-graph"
      ]
    },
    {
      "id": "bundle-runtime-state",
      "title": "Runtime Module Registry State Machine",
      "description": "A state machine for a module within the runtime: UNLOADED -> LOADING -> LOADED (with exports). Include transitions for `require(id)` and the factory function execution.",
      "type": "state-machine",
      "relevant_sections": [
        "component-generator"
      ]
    }
  ]
}