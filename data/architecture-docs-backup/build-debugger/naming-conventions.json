{
  "types": {
    "DebuggedProcess": "fields: pid pid_t, state ProcessState, regs struct user_regs_struct, executable_path char*, symbols SymbolTable*, breakpoints BreakpointList*, signal_pending int",
    "Breakpoint": "fields: address uintptr_t, original_byte uint8_t, is_enabled bool, hit_count uint32_t, location_description char*, next struct Breakpoint*",
    "DebugResult": "enum: DEBUG_SUCCESS, DEBUG_PTRACE_FAILED, DEBUG_PROCESS_EXITED, DEBUG_INVALID_ADDRESS, DEBUG_SYMBOL_NOT_FOUND, DEBUG_BREAKPOINT_EXISTS, DEBUG_PERMISSION_DENIED, DEBUG_CORRUPT_DEBUG_INFO, DEBUG_RESOURCE_EXHAUSTED, DEBUG_INVALID_DWARF, DEBUG_UNSUPPORTED_FEATURE",
    "DebugError": "fields: code DebugResult, message char[256], function const char*, line int, system_errno int",
    "ProcessState": "enum: RUNNING, STOPPED, EXITED",
    "Command": "fields: name const char*, help const char*, handler function pointer",
    "SymbolTable": "fields: name_hash_table Symbol**, hash_table_size size_t, address_mappings AddressMapping*, mapping_count size_t, mapping_capacity size_t",
    "BreakpointList": "fields: head Breakpoint*, count size_t, hit_breakpoint Breakpoint*, single_step_restore Breakpoint*",
    "VariableInfo": "forward declaration for variable metadata",
    "Symbol": "fields: name char*, demangled_name char*, address uintptr_t, size uintptr_t, symbol_type int, binding int, next struct Symbol*",
    "SourceLocation": "fields: filename char*, directory char*, line_number uint32_t, column_number uint32_t",
    "AddressMapping": "fields: address uintptr_t, location SourceLocation",
    "ElfFile": "fields: file FILE*, header Elf64_Ehdr, section_headers Elf64_Shdr*, section_names char*, is_64bit int, is_little_endian int",
    "Elf64_Ehdr": "fields: e_ident uint8_t[16], e_type uint16_t, e_machine uint16_t, e_version uint32_t, e_entry uint64_t, e_phoff uint64_t, e_shoff uint64_t, e_flags uint32_t, e_ehsize uint16_t, e_phentsize uint16_t, e_phnum uint16_t, e_shentsize uint16_t, e_shnum uint16_t, e_shstrndx uint16_t",
    "Elf64_Shdr": "fields: sh_name uint32_t, sh_type uint32_t, sh_flags uint64_t, sh_addr uint64_t, sh_offset uint64_t, sh_size uint64_t, sh_link uint32_t, sh_info uint32_t, sh_addralign uint64_t, sh_entsize uint64_t",
    "VariableLocation": "fields: type LocationType, address uintptr_t, register_number int, piece_count size_t",
    "TypeInfo": "fields: dwarf_offset uint32_t, base_type_encoding uint8_t, byte_size size_t, is_pointer bool",
    "LocationType": "enum: LOCATION_REGISTER, LOCATION_MEMORY, LOCATION_COMPOSITE",
    "MemoryCache": "fields: base_address uintptr_t, data uint8_t[4096], valid_bytes size_t, is_valid bool",
    "MemoryReader": "fields: target_pid pid_t, cache MemoryCache, cache_hits uint64_t, cache_misses uint64_t",
    "TypeDescriptor": "unified type representation with lazy attribute resolution",
    "CrashAnalysis": "fields: signal_number int, fault_address void*, registers struct user_regs_struct, stack_dump uint8_t[4096], instruction_context uint8_t[64], crash_summary char[512]",
    "TestResults": "fields: total_tests int, passed_tests int, failed_tests int, current_test char[256]",
    "TestProcess": "fields: target_pid pid_t, debugger_pid pid_t, status int, executable_path char[1024]",
    "DiagnosticError": "fields: code DebugResult, message char[256], function const char*, line int, system_errno int, timestamp uint64_t, debugger_pid pid_t, target_pid pid_t, context_address uintptr_t",
    "ProcessStateTracker": "fields: target_pid pid_t, expected_state ProcessState, actual_state ProcessState, last_signal int, state_change_count uint64_t, last_state_change struct timespec",
    "DwarfParsingStats": "fields: compilation_units_parsed uint32_t, dies_parsed uint32_t, parsing_errors uint32_t, version_mismatches uint32_t, last_error_context char[512]",
    "ThreadInfo": "fields: thread_id pid_t, thread_state ThreadState, registers struct user_regs_struct, stack_pointer uintptr_t, program_counter uintptr_t, signal_pending int, single_step_active bool, next struct ThreadInfo*",
    "ThreadList": "fields: head ThreadInfo*, count size_t",
    "ThreadEvent": "fields: thread_id pid_t, event_type int, event_data void*",
    "GlobalBreakpoint": "fields: address uintptr_t, affects_all_threads bool",
    "ThreadLocalBreakpoint": "fields: address uintptr_t, target_thread pid_t",
    "ThreadState": "enum: THREAD_RUNNING, THREAD_STOPPED, THREAD_EXITED",
    "DebuggerClient": "fields: connection NetworkConnection*, symbol_cache SymbolTable*",
    "DebuggerServer": "fields: processes ProcessList*, listen_socket int",
    "ProtocolHandler": "fields: message_buffer uint8_t*, serializer MessageSerializer*",
    "StateSync": "fields: local_state ProcessState, remote_state ProcessState",
    "WatchType": "enum: WATCH_READ, WATCH_WRITE, WATCH_ACCESS",
    "WatchpointHit": "fields: address uintptr_t, old_value uint64_t, new_value uint64_t",
    "NetworkConnection": "fields: socket_fd int, protocol_version uint16_t"
  },
  "methods": {
    "ptrace": "System call for process tracing and control",
    "waitpid": "Wait for process state changes",
    "fork": "Create child process",
    "exec": "Replace process image",
    "ptrace(request, pid, addr, data)": "system call for process tracing and control",
    "waitpid(pid, status, options)": "wait for process state changes",
    "fork()": "create child process",
    "exec()": "Replace process image",
    "debug_error_create(code, message, function, line, errno)": "create structured error with context",
    "debug_error_print(error)": "display formatted error message",
    "cmd_break(proc, args)": "Set breakpoint command handler",
    "cmd_continue(proc, args)": "Continue execution command handler",
    "cmd_step(proc, args)": "Single step command handler",
    "process_start(executable_path, argv, proc)": "Start new process under debugger control",
    "process_attach(target_pid, proc)": "attach to existing process for debugging",
    "process_continue(proc)": "resume execution until next signal",
    "process_single_step(proc)": "execute exactly one instruction",
    "process_read_memory(proc, address, buffer, size)": "read memory from debuggee",
    "process_write_memory(proc, address, data, size)": "write memory to debuggee",
    "breakpoint_set(proc, address, description)": "set breakpoint at address",
    "breakpoint_handle_hit(proc, address)": "process breakpoint hit",
    "symbols_resolve_address(symbols, address, filename, line)": "convert address to source location",
    "symbols_resolve_function(symbols, function_name, address)": "convert function name to address",
    "process_create(executable_path, argv, proc)": "create new process under debugger control",
    "symbols_load_from_elf(executable_path, symbols)": "load symbol table from ELF file",
    "breakpoint_set(pid, list, address, description)": "set breakpoint at address with description",
    "breakpoint_remove(pid, list, address)": "Remove breakpoint at specified address",
    "breakpoint_handle_hit(pid, list, hit_address)": "Process breakpoint hit and update state",
    "breakpoint_continue_past_hit(pid, list)": "Prepare for single-step past breakpoint",
    "breakpoint_find(list, address)": "locate breakpoint by address in list",
    "process_read_byte(pid, address, value)": "Read single byte from process memory",
    "process_write_byte(pid, address, value)": "Write single byte to process memory",
    "symbols_create(symbols, hash_size)": "initialize symbol table with hash table",
    "symbols_add_symbol(symbols, name, address, size, type)": "add symbol to hash table",
    "elf_open(filename, elf)": "open and parse ELF file headers",
    "elf_find_section(elf, name, section)": "locate ELF section by name",
    "elf_read_section_data(elf, section, data, size)": "read section content into memory",
    "elf_close(elf)": "close ELF file and free resources",
    "dwarf_parse_compilation_unit(debug_info_data, offset, debug_abbrev_data)": "parse DWARF compilation unit",
    "dwarf_parse_die(data, offset, abbrev_code)": "parse debug information entry",
    "variable_inspect_by_name(proc, var_name, output_buffer, buffer_size)": "locate and display variable by name",
    "location_resolver_evaluate(expr_bytes, expr_length, regs, result)": "execute DWARF location expression to find variable location",
    "type_interpreter_format_value(type, raw_bytes, byte_count, output, output_size)": "convert raw bytes to readable string using type information",
    "memory_reader_create(pid, reader)": "create memory reader with caching for target process",
    "memory_reader_read_bytes(reader, address, buffer, size)": "read bytes from process memory with cache",
    "memory_reader_invalidate_cache(reader)": "invalidate cached memory contents",
    "register_reader_get_all(pid, regs)": "retrieve complete CPU register set",
    "register_reader_get_by_dwarf_number(pid, dwarf_reg_num, value)": "get register value by DWARF register number",
    "command_processor_init()": "initialize command registry with built-in commands",
    "command_processor_register(name, help, handler)": "register new command with processor",
    "command_processor_execute(proc, input)": "process complete command line input",
    "command_processor_show_help(command)": "display help for all or specific command",
    "breakpoint_handle_hit(pid, list, address)": "process breakpoint hit and update state",
    "symbols_resolve_function(symbols, name, address)": "convert function name to address",
    "dwarf_validate_debug_info(debug_info_data, data_size, debug_abbrev_data, abbrev_size)": "validate DWARF debug information structure",
    "symbols_load_with_fallbacks(executable_path, symbols)": "load symbol table with graceful degradation",
    "crash_handle_and_analyze(proc, wait_status, analysis)": "analyze and handle target process crash",
    "test_framework_init()": "initialize test framework and global state",
    "test_framework_cleanup()": "clean up test processes and resources",
    "test_run(test_name, test_func)": "execute single test with name and result tracking",
    "test_print_summary()": "display final test results summary",
    "test_process_create(executable, argv, proc)": "create test target process under debugger control",
    "test_process_cleanup(proc)": "terminate test process and clean resources",
    "test_memory_read_byte(pid, address, value)": "read single byte from process memory for verification",
    "test_memory_verify_pattern(pid, address, pattern, length)": "verify memory contains expected byte pattern",
    "diagnostic_error_create(code, message, function, line, sys_errno, address)": "create diagnostic error with full context including timestamps and process IDs",
    "validate_breakpoint_consistency(list, target_pid)": "verify breakpoint internal state matches target process memory contents",
    "validate_memory_access(target_pid, address, size, required_perms)": "check memory region permissions and bounds for ptrace access",
    "process_ptrace_with_retry(request, pid, addr, data, max_retries)": "ptrace wrapper with error handling and retry logic for transient failures",
    "process_wait_with_validation(tracker, status, options)": "waitpid wrapper with state machine validation and transition checking",
    "dwarf_parse_with_validation(debug_info_data, data_size, abbrev_data, abbrev_size, stats)": "DWARF parser with comprehensive error checking and statistics collection",
    "symbols_verify_integrity(symbols)": "validate symbol table internal consistency and cross-references",
    "kill(pid, signal)": "send signal to process for existence checking",
    "clock_gettime(clock_id, timespec)": "get high-resolution timestamp",
    "threads_enumerate(proc)": "list all threads in process",
    "thread_attach(proc, tid)": "attach to specific thread",
    "thread_stop_all(proc)": "stop all threads in process",
    "thread_continue_all(proc)": "resume all stopped threads",
    "thread_single_step(proc, tid)": "step specific thread",
    "thread_get_state(proc, tid)": "get thread-specific state",
    "watchpoint_set(proc, address, size, type)": "create new memory watchpoint",
    "watchpoint_check_changes(proc, watchpoint_list)": "scan for memory changes",
    "watchpoint_hardware_allocate(address, size, type)": "allocate hardware debug register",
    "watchpoint_software_enable(proc, watchpoint)": "enable software memory monitoring",
    "expression_evaluate(proc, expression, result)": "evaluate condition expression",
    "expression_parse(expression_text, ast)": "parse expression into AST",
    "expression_resolve_variables(proc, ast)": "resolve variable references",
    "expression_execute(proc, ast, result)": "execute parsed expression",
    "checkpoint_create(proc, checkpoint)": "create full process checkpoint",
    "checkpoint_restore(proc, checkpoint)": "restore process to checkpoint state",
    "checkpoint_cleanup(checkpoint_list)": "free old checkpoint memory",
    "replay_forward(proc, checkpoint, target_pc)": "replay from checkpoint to target",
    "threading_init(proc)": "initialize multi-threading support",
    "protocol_handle_message(conn, message, length)": "handle remote protocol message",
    "watchpoint_evaluate_condition(proc, watch, should_trigger)": "evaluate watchpoint condition"
  },
  "constants": {
    "PTRACE_TRACEME": "enable tracing of calling process",
    "PTRACE_ATTACH": "attach to existing process",
    "PTRACE_CONT": "continue execution",
    "PTRACE_SINGLESTEP": "single instruction execution",
    "PTRACE_PEEKDATA": "read process memory",
    "PTRACE_POKEDATA": "write process memory",
    "PTRACE_GETREGS": "get CPU registers",
    "SIGTRAP": "breakpoint or single-step signal",
    "INT3": "0xCC x86 breakpoint instruction",
    "DEBUG_ERROR": "error creation macro with function and line info",
    "DW_TAG_compile_unit": "DWARF compilation unit tag",
    "DW_TAG_subprogram": "DWARF function tag",
    "DW_TAG_variable": "DWARF variable tag",
    "DW_TAG_formal_parameter": "DWARF function parameter DIE tag",
    "DW_TAG_base_type": "DWARF primitive type DIE tag",
    "DW_TAG_pointer_type": "DWARF pointer type DIE tag",
    "DW_TAG_structure_type": "DWARF struct type DIE tag",
    "DW_TAG_member": "DWARF struct member DIE tag",
    "DW_LNS_advance_pc": "DWARF line number program opcode",
    "DW_LNS_advance_line": "DWARF line number program opcode",
    "DW_LNS_copy": "DWARF line number program opcode",
    "DW_AT_ranges": "DWARF attribute for address ranges",
    "DW_AT_comp_dir": "DWARF compilation directory attribute",
    "DW_OP_reg0": "DWARF register 0 operator",
    "DW_OP_fbreg": "DWARF frame base operator",
    "DW_OP_piece": "DWARF location expression piece operator",
    "DW_OP_deref": "DWARF location expression dereference operator",
    "DW_OP_plus": "DWARF location expression addition operator",
    "DW_OP_breg0": "DWARF location expression register indirect operator",
    "DW_ATE_signed": "DWARF signed integer encoding",
    "DW_ATE_unsigned": "DWARF unsigned integer encoding",
    "DW_ATE_float": "DWARF floating point encoding",
    "DW_ATE_boolean": "DWARF boolean encoding",
    "DW_ATE_address": "DWARF address/pointer encoding",
    "DW_ATE_signed_char": "DWARF signed character encoding",
    "DEBUG_SUCCESS": "successful operation",
    "DEBUG_PTRACE_FAILED": "ptrace operation failed",
    "DEBUG_PROCESS_EXITED": "target process has exited",
    "DEBUG_INVALID_ADDRESS": "invalid memory address",
    "DEBUG_PERMISSION_DENIED": "insufficient permissions for operation",
    "DEBUG_CORRUPT_DEBUG_INFO": "debug information is corrupted",
    "DEBUG_RESOURCE_EXHAUSTED": "system resources exhausted",
    "DEBUG_INVALID_DWARF": "invalid DWARF format",
    "DEBUG_UNSUPPORTED_FEATURE": "feature not supported",
    "SIGSEGV": "segmentation violation signal",
    "SIGBUS": "bus error signal",
    "SIGFPE": "floating point exception",
    "SIGABRT": "abort signal",
    "SIGILL": "illegal instruction signal",
    "EPERM": "operation not permitted",
    "ESRCH": "no such process",
    "EAGAIN": "resource temporarily unavailable",
    "EINTR": "interrupted system call",
    "SIGSTOP": "stop signal for process control",
    "SIGINT": "interrupt signal",
    "DEBUG_SYMBOL_NOT_FOUND": "symbol not found in debug information",
    "DEBUG_BREAKPOINT_EXISTS": "breakpoint already exists at address",
    "RUNNING": "process executing normally",
    "STOPPED": "process stopped by debugger",
    "EXITED": "process has terminated",
    "WIFSTOPPED": "macro to check if process stopped",
    "WSTOPSIG": "macro to get stop signal number",
    "PTRACE_DETACH": "detach from traced process",
    "SIGCHLD": "child process state change signal",
    "EFAULT": "bad memory address",
    "WNOHANG": "waitpid option for non-blocking wait",
    "THREAD_RUNNING": "thread executing normally",
    "THREAD_STOPPED": "thread stopped by debugger",
    "THREAD_EXITED": "thread has terminated",
    "WATCH_READ": "trigger on memory read access",
    "WATCH_WRITE": "trigger on memory write access",
    "WATCH_ACCESS": "trigger on read or write access",
    "MSG_PROCESS_CONTROL": "process control message type",
    "MSG_EXECUTION": "execution control message type",
    "MSG_MEMORY_ACCESS": "memory access message type",
    "MSG_BREAKPOINT": "breakpoint management message type",
    "MSG_REGISTER": "register access message type",
    "MSG_SYMBOL_LOOKUP": "symbol lookup message type"
  },
  "terms": {
    "ptrace": "Unix system call for process control",
    "DWARF": "debug information format",
    "ELF": "Executable and Linkable Format",
    "symbol table": "name to address mapping",
    "debug information": "compiler metadata for debugging",
    "breakpoint": "execution stop point using INT3 patching",
    "process control": "starting, stopping, stepping execution",
    "symbol resolution": "address to source location mapping",
    "software breakpoint": "breakpoint using instruction patching",
    "instruction patching": "replacing bytes with INT3",
    "process attachment": "gaining debugger control over target process via ptrace",
    "single-step execution": "advancing one instruction at time",
    "signal management": "handling and forwarding signals between debugger and debuggee",
    "restore-step-repatch": "sequence for continuing past breakpoint: restore original instruction, single-step, re-patch INT3",
    "breakpoint lifecycle": "states a breakpoint goes through from creation to deletion",
    "hit detection": "determining when and which breakpoint was triggered by SIGTRAP signal",
    "instruction pointer adjustment": "correcting IP after INT3 execution to point back to breakpoint location",
    "Debug Information Entry": "DWARF record describing program element",
    "abbreviation table": "DWARF template definitions for DIE structure",
    "compilation unit": "DWARF tree representing one source file",
    "location expression": "DWARF bytecode for variable location",
    "line number program": "DWARF bytecode for address-to-source mapping",
    "address-to-source mapping": "translation from memory address to source location",
    "name-to-address resolution": "translation from symbol name to memory address",
    "location expressions": "DWARF bytecode programs that calculate variable locations",
    "type-aware interpretation": "converting bytes to typed values",
    "composite type handling": "navigating structs, arrays, and pointers with field access",
    "variable location resolution": "interpreting DWARF expressions to find variables in memory/registers",
    "endianness conversion": "byte order transformation between target and host architectures",
    "location expression evaluator": "DWARF bytecode interpreter for variable location calculation",
    "type descriptor": "unified representation of DWARF type information",
    "value formatter": "component that converts raw bytes to display strings",
    "memory access caching": "optimization strategy for reducing expensive ptrace calls",
    "circular reference detection": "preventing infinite loops in self-referential data structures",
    "command processing flow": "how user commands flow through system and trigger component interactions",
    "breakpoint hit workflow": "complete sequence from breakpoint trigger to user notification",
    "symbol lookup flow": "how symbol resolution requests flow between components with caching",
    "lazy loading strategy": "parsing debug information on-demand rather than at startup",
    "graceful degradation": "reduced functionality with core operation maintained",
    "crash analysis": "examination of process state at time of failure",
    "error classification": "categorizing errors by type, severity, and recovery options",
    "post-mortem debugging": "analyzing program state after crash without restart",
    "stack unwinding": "reconstructing function call sequence from stack memory",
    "permission validation": "checking access rights before attempting operations",
    "corruption detection": "identifying invalid data structures or memory contents through consistency checking",
    "recovery strategy": "planned approach for handling specific error conditions",
    "fail-fast": "immediate failure when problems detected",
    "error context": "additional information about circumstances of failure",
    "integration testing": "testing component interactions with realistic scenarios",
    "test program design": "creating sample programs with known behavior for testing",
    "milestone verification": "specific tests to verify correct implementation of each milestone",
    "error propagation": "how errors flow between components during testing",
    "test framework": "infrastructure for running and verifying debugger tests",
    "process isolation": "preventing test interference through process separation",
    "memory verification": "checking memory state changes during debugging operations",
    "system call tracing": "monitoring debugger's kernel interactions using strace to diagnose ptrace and signal issues",
    "binary analysis": "examining executable file structure with objdump and readelf to validate symbol resolution",
    "meta-debugging": "using GDB to debug the debugger",
    "instruction boundary verification": "confirming breakpoints align with complete instruction starts using disassembly",
    "signal handling coordination": "managing signal delivery between debugger, target process, and meta-debugger",
    "memory consistency validation": "comparing debugger internal state with actual target process memory contents",
    "DWARF parsing validation": "verifying debug information structure integrity and version compatibility",
    "diagnostic error context": "comprehensive error information including timestamps, process IDs, and failure locations",
    "process state synchronization": "coordinating debugger expectations with actual target process state transitions",
    "breakpoint memory patches": "INT3 instruction modifications in target process executable memory",
    "symbol resolution verification": "comparing debugger symbol output with external tools like readelf",
    "race condition diagnosis": "using timing analysis and state checkpoints to identify timing-dependent bugs",
    "error propagation tracking": "following error conditions through component interactions during debugging operations",
    "all-stop model": "stops all threads when any thread hits breakpoint",
    "non-stop model": "allows other threads to continue execution when one hits breakpoint",
    "thread synchronization": "coordinating execution state across multiple threads",
    "software watchpoint": "memory monitoring using page protection and trap handling",
    "hardware watchpoint": "memory monitoring using CPU debug registers",
    "conditional breakpoint": "breakpoint that triggers only when specified conditions are met",
    "expression evaluation": "calculating values from C-like expressions in program context",
    "reverse debugging": "stepping backward through program execution to previous states",
    "checkpoint-based debugging": "saving program state snapshots for reverse execution",
    "deterministic replay": "reproducing exact execution sequence from recorded state",
    "remote debugging protocol": "network communication format for distributed debugging",
    "client-server architecture": "splitting debugger into user interface and process control components",
    "state synchronization": "maintaining consistency between distributed debugger components",
    "thread-local storage": "per-thread memory regions with separate instances per thread",
    "hardware debug register": "CPU feature for monitoring memory access without performance overhead",
    "variable inspection": "reading typed variable values"
  }
}