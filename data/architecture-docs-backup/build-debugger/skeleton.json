{
  "title": "Build Your Own Debugger: Design Document",
  "overview": "This system implements a source-level debugger similar to GDB that can attach to processes, set breakpoints, and inspect variables. The key architectural challenge is coordinating between multiple complex subsystems: ptrace-based process control, binary format parsing for debug information, and real-time program state inspection.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains what debuggers do, why they're architecturally complex, and how existing solutions approach the multi-layered challenge of program introspection.",
      "subsections": [
        {
          "id": "debugging-mental-model",
          "title": "The Detective Analogy",
          "summary": "Mental model comparing debugging to detective work with evidence collection and crime scene investigation"
        },
        {
          "id": "technical-challenges",
          "title": "Core Technical Challenges",
          "summary": "Process control, binary format parsing, symbol resolution, and real-time state inspection"
        },
        {
          "id": "existing-approaches",
          "title": "Existing Debugger Architectures",
          "summary": "Comparison of GDB, LLDB, and other debugger design approaches"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what our debugger will and will not support, focusing on core debugging primitives while avoiding advanced features.",
      "subsections": [
        {
          "id": "functional-requirements",
          "title": "Functional Requirements",
          "summary": "Process attachment, breakpoints, single-stepping, and variable inspection capabilities"
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Multi-threading, remote debugging, GUI, and advanced optimization handling"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Component overview showing the four main subsystems and their interactions, with recommended project structure.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Process controller, breakpoint manager, symbol resolver, and variable inspector components"
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "Organization of source files, headers, and build configuration for the debugger project"
        },
        {
          "id": "component-interactions",
          "title": "Inter-Component Communication",
          "summary": "How the four main components coordinate and share information during debugging sessions"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Core data structures representing processes, breakpoints, symbols, and variables with their relationships.",
      "subsections": [
        {
          "id": "process-state",
          "title": "Process State Representation",
          "summary": "Structures for tracking debuggee process state, registers, and memory layout"
        },
        {
          "id": "breakpoint-structures",
          "title": "Breakpoint Data Structures",
          "summary": "How breakpoints are represented, stored, and managed in memory"
        },
        {
          "id": "symbol-information",
          "title": "Symbol and Debug Information",
          "summary": "Structures for DWARF data, function symbols, and source-to-address mappings"
        }
      ]
    },
    {
      "id": "process-control",
      "title": "Process Control Component",
      "summary": "Handles ptrace-based process attachment, execution control, and signal management. Corresponds to Milestone 1.",
      "subsections": [
        {
          "id": "ptrace-mental-model",
          "title": "The Puppet Master Analogy",
          "summary": "Mental model comparing ptrace to controlling a marionette puppet"
        },
        {
          "id": "attachment-lifecycle",
          "title": "Process Attachment Lifecycle",
          "summary": "Fork, attach, and initialization sequence for gaining control of target process"
        },
        {
          "id": "execution-control",
          "title": "Execution Control Operations",
          "summary": "Single-step, continue, and stop operations with signal handling"
        },
        {
          "id": "signal-management",
          "title": "Signal Management",
          "summary": "Handling and forwarding signals between debugger and debuggee"
        },
        {
          "id": "process-control-adrs",
          "title": "Architecture Decisions",
          "summary": "ADRs for ptrace vs other APIs, signal handling approach, and process lifecycle management"
        },
        {
          "id": "process-control-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Race conditions, zombie processes, and signal handling mistakes"
        }
      ]
    },
    {
      "id": "breakpoint-manager",
      "title": "Breakpoint Manager Component",
      "summary": "Implements software breakpoints using INT3 instruction patching and manages breakpoint lifecycle. Corresponds to Milestone 2.",
      "subsections": [
        {
          "id": "breakpoint-mental-model",
          "title": "The Tripwire Analogy",
          "summary": "Mental model comparing breakpoints to security tripwires that detect when something passes through"
        },
        {
          "id": "software-breakpoints",
          "title": "Software Breakpoint Implementation",
          "summary": "INT3 instruction patching, original byte preservation, and restoration mechanism"
        },
        {
          "id": "breakpoint-lifecycle",
          "title": "Breakpoint Lifecycle Management",
          "summary": "Setting, hitting, disabling, and removing breakpoints with state tracking"
        },
        {
          "id": "multiple-breakpoints",
          "title": "Multiple Breakpoint Coordination",
          "summary": "Managing collections of breakpoints without conflicts or memory corruption"
        },
        {
          "id": "breakpoint-adrs",
          "title": "Architecture Decisions",
          "summary": "ADRs for software vs hardware breakpoints, storage strategy, and hit detection"
        },
        {
          "id": "breakpoint-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Instruction boundaries, concurrent access, and restoration timing issues"
        }
      ]
    },
    {
      "id": "symbol-resolver",
      "title": "Symbol Resolver Component",
      "summary": "Parses ELF and DWARF debug information to provide source-level debugging capabilities. Corresponds to Milestone 3.",
      "subsections": [
        {
          "id": "debug-info-mental-model",
          "title": "The Rosetta Stone Analogy",
          "summary": "Mental model comparing debug information to translation dictionaries between machine and source code"
        },
        {
          "id": "elf-parsing",
          "title": "ELF Format Parsing",
          "summary": "Reading ELF headers and locating debug-related sections"
        },
        {
          "id": "dwarf-processing",
          "title": "DWARF Debug Information Processing",
          "summary": "Parsing compilation units, debug information entries, and attribute structures"
        },
        {
          "id": "address-mapping",
          "title": "Address-to-Source Mapping",
          "summary": "Building bidirectional mappings between memory addresses and source locations"
        },
        {
          "id": "symbol-tables",
          "title": "Symbol Table Management",
          "summary": "Function and variable symbol resolution with scope handling"
        },
        {
          "id": "symbol-adrs",
          "title": "Architecture Decisions",
          "summary": "ADRs for DWARF version support, caching strategy, and lazy vs eager parsing"
        },
        {
          "id": "symbol-pitfalls",
          "title": "Common Pitfalls",
          "summary": "DWARF version incompatibilities, optimized code handling, and memory management"
        }
      ]
    },
    {
      "id": "variable-inspector",
      "title": "Variable Inspector Component",
      "summary": "Reads and displays variable values using debug information and process memory access. Corresponds to Milestone 4.",
      "subsections": [
        {
          "id": "variable-mental-model",
          "title": "The X-Ray Vision Analogy",
          "summary": "Mental model comparing variable inspection to medical imaging that reveals internal structure"
        },
        {
          "id": "location-resolution",
          "title": "Variable Location Resolution",
          "summary": "Interpreting DWARF location expressions to find variables in registers, stack, or memory"
        },
        {
          "id": "memory-access",
          "title": "Memory and Register Access",
          "summary": "Using ptrace to read process memory and CPU registers safely"
        },
        {
          "id": "type-interpretation",
          "title": "Type-Aware Value Interpretation",
          "summary": "Converting raw bytes to typed values using DWARF type information"
        },
        {
          "id": "composite-types",
          "title": "Composite Type Handling",
          "summary": "Navigating structs, arrays, and pointers with field access and bounds checking"
        },
        {
          "id": "variable-adrs",
          "title": "Architecture Decisions",
          "summary": "ADRs for type system representation, value formatting, and optimized variable handling"
        },
        {
          "id": "variable-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Optimized-out variables, complex location expressions, and endianness issues"
        }
      ]
    },
    {
      "id": "interactions-dataflow",
      "title": "Interactions and Data Flow",
      "summary": "How components communicate during typical debugging operations like setting breakpoints and stepping through code.",
      "subsections": [
        {
          "id": "command-processing",
          "title": "Command Processing Flow",
          "summary": "How user commands flow through the system and trigger component interactions"
        },
        {
          "id": "breakpoint-workflow",
          "title": "Breakpoint Hit Workflow",
          "summary": "Complete sequence from breakpoint trigger to user notification and control return"
        },
        {
          "id": "symbol-lookup-flow",
          "title": "Symbol Lookup Flow",
          "summary": "How symbol resolution requests flow between components with caching"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Failure modes, error detection strategies, and recovery mechanisms for robust debugging sessions.",
      "subsections": [
        {
          "id": "ptrace-failures",
          "title": "ptrace Operation Failures",
          "summary": "Handling permission denials, process deaths, and syscall failures"
        },
        {
          "id": "malformed-debug-info",
          "title": "Malformed Debug Information",
          "summary": "Graceful degradation when debug information is incomplete or corrupted"
        },
        {
          "id": "target-process-crashes",
          "title": "Target Process Crashes",
          "summary": "Detecting and handling when the debugged process crashes or exits unexpectedly"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Testing approaches for each milestone with specific verification criteria and expected behaviors.",
      "subsections": [
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "Specific tests and expected outputs for each milestone to verify correct implementation"
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing Approach",
          "summary": "Testing component interactions with realistic debugging scenarios"
        },
        {
          "id": "test-programs",
          "title": "Test Program Design",
          "summary": "Creating sample programs with known behavior for testing debugger functionality"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common bugs encountered when building the debugger, with symptom-cause-fix tables and debugging techniques.",
      "subsections": [
        {
          "id": "ptrace-debugging",
          "title": "Process Control Debugging",
          "summary": "Diagnosing ptrace failures, signal handling issues, and process synchronization problems"
        },
        {
          "id": "breakpoint-debugging",
          "title": "Breakpoint Issues",
          "summary": "Troubleshooting breakpoint setting, hitting, and restoration problems"
        },
        {
          "id": "symbol-debugging",
          "title": "Symbol Resolution Problems",
          "summary": "Debugging DWARF parsing failures and symbol lookup issues"
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools and Techniques",
          "summary": "Using strace, objdump, readelf, and other tools to debug the debugger itself"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements and how the current architecture accommodates future features.",
      "subsections": [
        {
          "id": "multi-threading",
          "title": "Multi-Threading Support",
          "summary": "How to extend the design to handle multi-threaded target processes"
        },
        {
          "id": "remote-debugging",
          "title": "Remote Debugging Protocol",
          "summary": "Adding network protocol support for debugging processes on remote machines"
        },
        {
          "id": "advanced-features",
          "title": "Advanced Debugging Features",
          "summary": "Watchpoints, conditional breakpoints, and reverse debugging capabilities"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of technical terms, acronyms, and domain-specific vocabulary used throughout the document.",
      "subsections": [
        {
          "id": "debugging-terms",
          "title": "Debugging Terminology",
          "summary": "Common debugging concepts and their definitions"
        },
        {
          "id": "system-terms",
          "title": "System Programming Terms",
          "summary": "Unix processes, signals, and ptrace-related terminology"
        },
        {
          "id": "binary-format-terms",
          "title": "Binary Format Terms",
          "summary": "ELF, DWARF, and symbol table terminology"
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "System Architecture Overview",
      "description": "Shows the four main components (Process Controller, Breakpoint Manager, Symbol Resolver, Variable Inspector) and their relationships, along with external interfaces to ptrace, ELF files, and user commands",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-dataflow"
      ]
    },
    {
      "id": "data-model",
      "title": "Core Data Structures",
      "description": "Class diagram showing key data structures like DebuggedProcess, Breakpoint, Symbol, Variable and their relationships and composition",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "process-lifecycle",
      "title": "Process Control State Machine",
      "description": "State transitions for debugged process from creation through attachment, running, stopped, and termination states with triggering events",
      "type": "state-machine",
      "relevant_sections": [
        "process-control"
      ]
    },
    {
      "id": "breakpoint-hit-sequence",
      "title": "Breakpoint Hit Sequence",
      "description": "Sequence diagram showing interaction between Process Controller, Breakpoint Manager, and user when a breakpoint is hit, including signal handling and instruction pointer adjustment",
      "type": "sequence",
      "relevant_sections": [
        "breakpoint-manager",
        "interactions-dataflow"
      ]
    },
    {
      "id": "symbol-resolution-flow",
      "title": "Symbol Resolution Flow",
      "description": "Flowchart showing the process of resolving symbols from ELF/DWARF information, including section parsing, DIE traversal, and cache lookup",
      "type": "flowchart",
      "relevant_sections": [
        "symbol-resolver",
        "interactions-dataflow"
      ]
    },
    {
      "id": "variable-inspection-sequence",
      "title": "Variable Inspection Sequence",
      "description": "Sequence diagram showing how Variable Inspector coordinates with Symbol Resolver and Process Controller to locate and read variable values",
      "type": "sequence",
      "relevant_sections": [
        "variable-inspector",
        "interactions-dataflow"
      ]
    },
    {
      "id": "command-processing",
      "title": "Command Processing Flow",
      "description": "Flowchart showing how user commands are parsed, validated, and dispatched to appropriate components with error handling",
      "type": "flowchart",
      "relevant_sections": [
        "interactions-dataflow"
      ]
    },
    {
      "id": "error-handling-flow",
      "title": "Error Handling and Recovery",
      "description": "Flowchart showing error detection, classification, and recovery strategies across all components",
      "type": "flowchart",
      "relevant_sections": [
        "error-handling"
      ]
    }
  ]
}