{
  "types": {
    "Key": "string type for keys",
    "Value": "[]byte type for values",
    "KeyValue": "fields: Key Key, Value Value, Timestamp time.Time, VectorClock VectorClock, TTL time.Duration, Version int64",
    "VectorClockEntry": "fields: NodeID string, Counter int64",
    "VectorClock": "slice of VectorClockEntry",
    "Request": "fields: Method string, Args interface{}, RequestID string, SourceNode string",
    "Response": "fields: Result interface{}, Error string, OK bool, RequestID string, Forwarded bool",
    "Client": "fields: baseURL string, httpClient *http.Client, timeout time.Duration",
    "Server": "fields: config *Config, logger *slog.Logger, storageEngine storage.Engine, hashingRing *hashing.Ring, clusterManager *cluster.MembershipManager, replicationMgr *replication.Manager, transactionMgr *transaction.Manager, rpcServer *transport.RPCServer, shutdownCh chan struct{}, doneCh chan struct{}",
    "Config": "fields: NodeID string, ListenAddr string, SeedNodes []string, DataDir string, ReplicationFactor int, VirtualNodes int",
    "PutRequest": "fields: Key Key, Value Value, Consistency string, RequireCAS bool, ExpectedVersion int64, TTL time.Duration",
    "GetRequest": "fields: Key Key, Consistency string, Version int64",
    "NodeState": "type alias for int with StateAlive, StateSuspect, StateDead constants",
    "MembershipChange": "fields: NodeID string, OldState NodeState, NewState NodeState, Timestamp time.Time, Incarnation int64",
    "RebalanceTask": "fields: FromNode string, ToNode string, StartKey uint64, EndKey uint64",
    "HintedWrite": "fields: Key Key, Value Value, TargetNode string, Timestamp time.Time, ExpiresAt time.Time",
    "PutResponse": "fields: Success bool, Version int64, VectorClock VectorClock, Replicas []string",
    "GetResponse": "fields: KeyValue KeyValue, Found bool, StaleReplicas []string",
    "GossipMessage": "fields: NodeID string, Incarnation int64, Membership []MembershipChange, Digest []string, Timestamp time.Time",
    "JoinRequest": "fields: NodeID string, ListenAddr string, Capacity int64",
    "JoinResponse": "fields: Accepted bool, RingTokens []uint64, SeedNodes []string, Config Config",
    "PrepareRequest": "fields: TransactionID string, Operations []TxOperation, Timeout time.Duration",
    "Vote": "fields: TransactionID string, Participant string, Vote string, Reason string",
    "DecisionRequest": "fields: TransactionID string, Decision string, Participants []string",
    "AckResponse": "fields: TransactionID string, Acknowledged bool, Error string",
    "WALWriter": "fields: file *os.File, mu sync.Mutex, seq uint64, bufPool sync.Pool",
    "SSTableBuilder": "fields: entries []Entry, blockSize int",
    "Entry": "fields: Key []byte, Value []byte, Version uint64, Timestamp int64, TTL int64",
    "RingProvider": "interface: AddNode, RemoveNode, GetNode, GetReplicas, GetAllNodes, GetTokenPositions, NotifyNodeFailure",
    "RingNode": "fields: NodeID string, VirtualNodes int, Weight int, Tokens []uint64, Status NodeState",
    "VirtualNode": "fields: Token uint64, PhysicalNodeID string, Index int",
    "RingSnapshot": "fields: Timestamp time.Time, Nodes map[string]RingNode, VirtualNodes []VirtualNode, SortedTokens []uint64",
    "Ring": "fields: currentSnapshot atomic.Value, versionCounter uint64, config *RingConfig, mu sync.RWMutex",
    "RingConfig": "fields: VirtualNodesPerWeight int, HashFunc func(string) uint64",
    "ReplicaSet": "fields: Key Key, PrimaryNode string, ReplicaNodes []string, Version int64, LastUpdated time.Time",
    "PendingWrite": "fields: Key Key, Value Value, VectorClock VectorClock, RequiredAcks int, AcksReceived int, AckNodes map[string]bool, Timeout time.Time, Callback func(bool, error)",
    "ReadOperation": "fields: Key Key, RequiredResponses int, Responses []KeyValue, ReceivedFrom map[string]bool, Timeout time.Time, Callback func(KeyValue, []string, error)",
    "ReplicaSyncTask": "fields: FromNode string, ToNode string, KeyRangeStart uint64, KeyRangeEnd uint64, Priority int, StartedAt time.Time",
    "MembershipManager": "fields: config *Config, logger *slog.Logger, localNodeID string, membership map[string]*memberState, mu sync.RWMutex, changeSubs []chan<- MembershipChange, gossipTicker *time.Ticker, shutdownCh chan struct{}, doneCh chan struct{}, fd *failureDetector, hintStore HintStore, rebalanceCh chan RebalanceTask",
    "HeartbeatHistory": "fields: intervals []float64, mu sync.RWMutex, windowSize int, sum float64, sumSquares float64",
    "memberState": "internal type tracking node state",
    "TxOperation": "fields: Type TxOperationType, Key Key, Value Value, ExpectedVersion int64, ReadVersion int64",
    "Transaction": "fields: ID string, State TxState, Operations []TxOperation, Participants []string, Coordinator string, Timeout time.Time, StartVersion int64",
    "TxParticipant": "fields: NodeID string, Vote Vote, DecisionAcked bool, LockedKeys []Key, LastContact time.Time",
    "TxCoordinator": "fields: nodeID string, wal *TransactionWAL, txMap map[string]*Transaction, participants map[string]TxParticipant, mu sync.RWMutex, rpcClient transport.RPCClient, timeout time.Duration",
    "TxParticipantHandler": "fields: nodeID string, wal *TransactionWAL, lockManager *LockManager, storage storage.Engine, activeTx map[string]TxParticipantState, mu sync.RWMutex",
    "LockManager": "fields: keyLocks map[Key]*LockEntry, transactionLocks map[string][]Key, mu sync.RWMutex",
    "LockEntry": "fields: transactionID string, lockType LockType, waitQueue []*LockRequest",
    "MVCCVersion": "fields: Value Value, Version int64, TransactionID string, CommitTimestamp time.Time, ExpireTimestamp time.Time",
    "Snapshot": "fields: Version int64, keys map[Key]MVCCVersion, created time.Time",
    "WALRecord": "fields: Timestamp int64, EntryType WALEntryType, TransactionID string, Data []byte, Checksum uint32",
    "TransactionWAL": "fields: file *os.File, filePath string, mu sync.Mutex, seq uint64, bufPool sync.Pool",
    "PendingOperation": "internal type for tracking pending operations",
    "FaultConfig": "fields: DropProbability float64, DelayMinMS int, DelayMaxMS int, DuplicateProbability float64, CorruptProbability float64",
    "FaultyRPCClient": "fields: realClient transport.RPCClient, config FaultConfig, rng *rand.Rand, mu sync.RWMutex",
    "SystemInvariant": "interface: Name() string, Check(cluster *TestCluster) (bool, string)",
    "InvariantRegistry": "fields: invariants []SystemInvariant, violations []string",
    "DataPreservationInvariant": "struct{}",
    "DebugServer": "fields: addr string, server *http.Server, ringProvider hashing.RingProvider, membershipMgr *cluster.MembershipManager, replicationMgr *replication.Manager, transactionMgr *transaction.Manager, storageEngine storage.Engine, mu sync.RWMutex, logger *slog.Logger",
    "MetricsCollector": "fields: mu sync.RWMutex, requestCounts map[string]int64, requestErrors map[string]int64, requestLatency map[string][]time.Duration, startTime time.Time",
    "DebugClient": "fields: BaseURL string, HTTPClient *http.Client",
    "EnhancedMetricsCollector": "fields: mu sync.RWMutex, requestCounter *prometheus.CounterVec, requestDuration *prometheus.HistogramVec, requestErrors *prometheus.CounterVec, clusterSize prometheus.Gauge, replicationLag prometheus.Gauge, startTime time.Time, nodeID string",
    "LocalSecondaryIndex": "fields: mu sync.RWMutex, indexes map[string]map[string][]string, keyIndexes map[string]map[string]string, nodeID string, ring hashing.RingProvider, client transport.RPCClient"
  },
  "methods": {
    "NewClient(addr string, timeout time.Duration) *Client": "creates a new RPC client",
    "Client.Call(ctx context.Context, method string, args interface{}, result interface{}) error": "sends an RPC request and decodes response",
    "NewServer() *Server": "creates a new RPC server",
    "Server.RegisterHandler(method string, handler func(args json.RawMessage) (interface{}, error))": "registers a handler for an RPC method",
    "Server.ServeHTTP(w http.ResponseWriter, r *http.Request)": "implements http.Handler interface",
    "VectorClock.Compare(vc2 VectorClock) int": "compares two vector clocks",
    "VectorClock.Merge(vc2 VectorClock) VectorClock": "merges two vector clocks",
    "VectorClock.Increment(nodeID string) VectorClock": "increments counter for given node",
    "NewServer(config *Config, logger *slog.Logger) (*Server, error)": "creates and initializes server with all components",
    "Server.Start() error": "starts all components in proper order",
    "Server.Stop() error": "stops all components in reverse order",
    "Server.WaitForShutdown()": "waits for shutdown signal",
    "Server.registerHandlers()": "registers RPC handlers for all components",
    "Server.handlePut(args json.RawMessage) (interface{}, error)": "handles client Put requests",
    "Server.handleGet(args json.RawMessage) (interface{}, error)": "handles client Get requests",
    "NewWALWriter(path string) (*WALWriter, error)": "creates a new WAL writer",
    "WALWriter.WriteEntry(entryType uint8, key, value []byte, version uint64, ttl time.Duration, vectorClock []byte) error": "writes an entry to WAL with checksum and fsync",
    "WALWriter.Close() error": "closes the WAL file",
    "VectorClock.Compare(other VectorClock) int": "compares two vector clocks (-1 before, 0 equal, 1 after, 2 concurrent)",
    "VectorClock.toMap() map[string]int64": "converts vector clock to map",
    "VectorClock.Merge(other VectorClock) VectorClock": "merges two vector clocks taking maximum counters",
    "KeyValue.MarshalBinary() ([]byte, error)": "serializes KeyValue to binary format",
    "KeyValue.UnmarshalBinary(data []byte) error": "deserializes binary data to KeyValue",
    "SSTableBuilder.Add(key, value []byte, version uint64, timestamp int64, ttl int64)": "adds an entry to SSTable builder",
    "SSTableBuilder.Build(w io.Writer) error": "builds and writes SSTable to writer",
    "AddNode(nodeID string, weight int) ([]uint64, error)": "Adds node with weight to ring",
    "RemoveNode(nodeID string) (bool, error)": "Removes node from ring",
    "GetNode(key Key) (string, error)": "Returns primary node for key",
    "GetReplicas(key Key, n int) ([]string, error)": "Returns N distinct replica nodes",
    "HashKey(key string) uint64": "Computes 64-bit hash of key",
    "HashNode(nodeID string, index int) uint64": "Computes deterministic hash for virtual node",
    "ReplicationManager.Put(ctx context.Context, key Key, value Value, consistency string, requireCAS bool, expectedVersion int64, ttl time.Duration) (*PutResponse, error)": "Main replicated write operation",
    "ReplicationManager.Get(ctx context.Context, key Key, consistency string, version int64) (*GetResponse, error)": "Main replicated read operation",
    "ReplicationManager.performReadRepair(key Key, correctValue KeyValue, staleReplicas []string) error": "Updates stale replicas with correct value",
    "GetAllNodes() []string": "Returns all alive node IDs",
    "GetNodeState(nodeID string) (NodeState, error)": "Returns state of specified node",
    "GetNodeAddress(nodeID string) (string, error)": "Returns network address for node",
    "SubscribeChanges() <-chan MembershipChange": "Returns channel for membership change events",
    "IsLocalNode(nodeID string) bool": "Checks if nodeID is local node",
    "GetLocalNodeID() string": "Returns local node ID",
    "JoinCluster(seedNodes []string) error": "Initiates join process",
    "LeaveCluster() error": "Gracefully removes node",
    "ForceRemoveNode(nodeID string) error": "Administratively removes node",
    "GetClusterStatus() map[string]NodeState": "Returns complete membership table",
    "TriggerRebalance() error": "Manually triggers rebalancing",
    "handleGossipMessage(msg GossipMessage) error": "Processes incoming gossip",
    "markNodeAlive(nodeID string, incarnation int64)": "Marks node as alive",
    "markNodeSuspect(nodeID string, incarnation int64)": "Marks node as suspect",
    "markNodeDead(nodeID string, incarnation int64)": "Marks node as dead",
    "scheduleHintedHandoff(nodeID string, writes []HintedWrite)": "Saves writes for unavailable node",
    "Start() error": "Starts gossip and failure detection",
    "gossipLoop()": "Periodic gossip routine",
    "failureDetectionLoop()": "Failure detection evaluation loop",
    "handleNodeJoin(nodeID string, addr string, incarnation int64) error": "Processes node join",
    "GetReplicasForHint(key Key, targetNode string, n int) ([]string, error)": "Returns alternative nodes for hinted handoff",
    "serializeMembershipChanges(changes []MembershipChange) ([]byte, error)": "Converts changes to JSON",
    "createGossipDigest(membership map[string]*memberState) []string": "Creates compact membership digest",
    "compareDigests(localDigest, remoteDigest []string) (needFromRemote, needToRemote []string)": "Identifies state differences",
    "NewHeartbeatHistory(windowSize int) *HeartbeatHistory": "Creates new history tracker",
    "HeartbeatHistory.Add(interval time.Duration)": "Adds interval to history",
    "HeartbeatHistory.Phi(atTime time.Time, lastHeartbeat time.Time) float64": "Calculates phi value for failure probability",
    "BeginTransaction(ctx context.Context, timeout time.Duration) (string, error)": "Starts new transaction, returns transaction ID",
    "CommitTransaction(ctx context.Context, txID string) (Decision, error)": "Executes 2PC to commit or abort transaction",
    "HandlePrepare(ctx context.Context, req PrepareRequest) (Vote, error)": "Processes PrepareRequest, returns vote",
    "HandleDecision(ctx context.Context, req DecisionRequest) error": "Processes DecisionRequest, applies commit/abort",
    "ReadWriteCoordinator.PerformQuorumWrite(ctx context.Context, req PutRequest) (*PutResponse, error)": "executes quorum write across replicas",
    "ReadWriteCoordinator.PerformQuorumRead(ctx context.Context, req GetRequest) (*GetResponse, error)": "executes quorum read across replicas",
    "RPCClient.Call(ctx context.Context, method string, args interface{}, result interface{}) error": "sends RPC request and decodes response",
    "TxParticipantHandler.handlePrepareTimeout(txID string) error": "Executes termination protocol after prepare timeout",
    "calculateAdaptiveTimeout(nodeID string, baseTimeout time.Duration) time.Duration": "Computes adaptive timeout based on recent RTT measurements",
    "NewFaultyRPCClient(realClient transport.RPCClient, seed int64) *FaultyRPCClient": "creates a new fault-injecting client",
    "FaultyRPCClient.Call(ctx context.Context, method string, args interface{}, result interface{}) error": "makes RPC call with injected faults",
    "FaultyRPCClient.SetConfig(config FaultConfig)": "updates fault configuration",
    "InvariantRegistry.CheckAll(cluster *TestCluster) bool": "checks all registered invariants",
    "DataPreservationInvariant.Name() string": "returns invariant name",
    "DataPreservationInvariant.Check(cluster *TestCluster) (bool, string)": "checks data preservation invariant",
    "NewDebugServer(addr string, ring hashing.RingProvider, membership *cluster.MembershipManager, replication *replication.Manager, transaction *transaction.Manager, storage storage.Engine, logger *slog.Logger) *DebugServer": "creates a new debug server",
    "DebugServer.Start() error": "begins serving debug endpoints",
    "DebugServer.Stop() error": "gracefully shuts down debug server",
    "DebugServer.handleRing(w http.ResponseWriter, r *http.Request)": "returns current ring state as JSON",
    "DebugServer.handleMembership(w http.ResponseWriter, r *http.Request)": "returns current membership view",
    "DebugServer.handleTransactions(w http.ResponseWriter, r *http.Request)": "lists active transactions",
    "DebugServer.handleHealth(w http.ResponseWriter, r *http.Request)": "returns liveness status",
    "DebugServer.handleReady(w http.ResponseWriter, r *http.Request)": "returns readiness status",
    "DebugServer.handleMetrics(w http.ResponseWriter, r *http.Request)": "returns Prometheus metrics",
    "DebugServer.handleLogLevel(w http.ResponseWriter, r *http.Request)": "allows dynamic log level changes",
    "NewMetricsCollector() *MetricsCollector": "creates a new metrics collector",
    "MetricsCollector.RecordRequest(method string, duration time.Duration, err error)": "records a completed request",
    "MetricsCollector.GetStats() map[string]interface{}": "returns current metrics",
    "EnhancedMetricsCollector.RecordRequest(method string, consistency string, duration time.Duration, err error)": "tracks a completed request with enhanced metrics",
    "EnhancedMetricsCollector.UpdateClusterSize(size int)": "updates the cluster size gauge",
    "EnhancedMetricsCollector.UpdateReplicationLag(lag time.Duration)": "updates the replication lag gauge",
    "EnhancedMetricsCollector.ServeMetrics(addr string) error": "starts the Prometheus metrics HTTP endpoint",
    "LocalSecondaryIndex.UpdateIndex(key string, value []byte, oldValue []byte) error": "updates secondary indexes for a key-value pair",
    "LocalSecondaryIndex.QueryByField(ctx context.Context, fieldName string, fieldValue string, consistency string) ([]string, error)": "finds keys where the specified field equals the given value",
    "LocalSecondaryIndex.RangeQuery(ctx context.Context, fieldName string, startValue string, endValue string, consistency string) ([]string, error)": "finds keys where the specified field value is within [start, end]"
  },
  "constants": {
    "ConsistencyOne": "Read/write requires only one replica",
    "ConsistencyQuorum": "Read/write requires quorum of replicas",
    "ConsistencyAll": "Read/write requires all replicas",
    "StateAlive": "Node is alive and responsive",
    "StateSuspect": "Node is suspected of failure",
    "StateDead": "Node is confirmed dead",
    "DefaultVirtualNodes": "256",
    "DefaultWeight": "1",
    "WALEntryBegin": "1",
    "WALEntryPrepareStart": "2",
    "WALEntryVote": "3",
    "WALEntryDecision": "4",
    "WALEntryCommit": "5",
    "WALEntryAbort": "6",
    "TxInitializing": "initial transaction state",
    "TxPreparing": "preparing state in 2PC",
    "TxPrepared": "prepared state after voting",
    "TxCommitting": "committing state",
    "TxCommitted": "committed final state",
    "TxAborting": "aborting state",
    "TxAborted": "aborted final state",
    "TxRecovering": "recovery state",
    "VotePending": "vote not yet cast",
    "VoteCommit": "vote to commit",
    "VoteAbort": "vote to abort",
    "DecisionCommit": "decision to commit",
    "DecisionAbort": "decision to abort",
    "SUSPECT_THRESHOLD": "5.0 - phi value threshold for marking node as suspect",
    "DEAD_THRESHOLD": "8.0 - phi value threshold for marking node as dead"
  },
  "terms": {
    "CAP Theorem": "trade-off between Consistency, Availability, and Partition Tolerance",
    "Vector Clock": "data structure tracking causal history in distributed systems",
    "Consistent Hashing": "hashing technique minimizing rebalancing during membership changes",
    "Quorum": "minimum replicas required for operation success",
    "Gossip Protocol": "epidemic protocol for information dissemination",
    "2PC": "Two-Phase Commit protocol for distributed transactions",
    "MVCC": "Multi-Version Concurrency Control",
    "Hinted Handoff": "temporary storage of writes for unavailable nodes",
    "Phi-Accrual": "Adaptive failure detection algorithm using statistical probability",
    "Linearizability": "strong consistency with instantaneous effect appearance",
    "RingProvider": "interface for key-to-node mapping via consistent hashing",
    "MembershipProvider": "interface for cluster membership management",
    "ReplicationProvider": "interface for replicated read/write operations",
    "TransactionProvider": "interface for distributed transaction management",
    "StorageEngine": "interface for local persistent storage",
    "Transport": "interface for RPC communication between nodes",
    "Hybrid Synchronous-Asynchronous Model": "communication model using both sync calls and async channels",
    "Log-Structured Merge Tree": "storage engine design that buffers writes in memory and merges to disk in sorted files",
    "Write-Ahead Log": "log where changes are recorded before being applied",
    "Checksum-at-Head": "checksum placement at record start for early corruption detection",
    "Hybrid Logical Clocks": "clocks combining physical time with logical counters",
    "Virtual Nodes": "Multiple tokens per physical node for load distribution",
    "Hash Ring": "circular hash space for consistent hashing",
    "Token": "position on hash ring representing virtual node",
    "Snapshot": "immutable view of ring state or database version",
    "Anti-Entropy": "background process to detect and fix replica inconsistencies",
    "Sloppy Quorum": "writes to non-preferred replicas when preferred unavailable",
    "Merkle Tree": "hash tree for efficient dataset comparison",
    "Rebalancing": "redistributing data during membership changes",
    "Incarnation Number": "monotonically increasing generation number for node state",
    "Membership Change": "event representing node state transition",
    "Digest": "compact representation of cluster membership state",
    "Sliding Window": "fixed-size buffer of recent measurements",
    "Two-Phase Commit": "distributed transaction protocol with prepare and commit phases",
    "Multi-Version Concurrency Control": "concurrency control method using multiple versions of data",
    "Snapshot Isolation": "isolation level with consistent snapshot reads",
    "Blocking Protocol": "protocol where participants may block waiting for messages",
    "Uncertainty Window": "period after voting YES but before receiving decision in 2PC",
    "Wait-for Graph": "graph showing which transactions wait for which locks",
    "Phi-Accrual Detection": "adaptive failure detection using statistical probability",
    "Hybrid Rebalancing": "rebalancing with write-duplication during transitions",
    "Termination Protocol": "protocol for participants to resolve transaction outcome after coordinator crash",
    "Read Repair": "fixing stale replicas during read operations",
    "Hybrid Logical Clock": "clocks combining physical time with logical counters for versioning",
    "Property-Based Testing": "testing verifying properties for random inputs",
    "Chaos Testing": "intentional injection of failures to test system resilience",
    "Invariant": "condition that must always hold true",
    "Model Checking": "exhaustive state space exploration for verification",
    "Deterministic Testing": "tests producing identical results on every run",
    "Golden File": "reference output file for test comparison",
    "Race Detector": "tool detecting concurrent access without synchronization",
    "Test Pyramid": "testing strategy with more unit than integration than system tests",
    "Flight Recorder": "analogy for structured logging capturing complete context",
    "phi-accrual detection": "adaptive failure detection algorithm using statistical probability",
    "hybrid rebalancing": "rebalancing approach with write-duplication during node join/leave transition",
    "wait-for graph": "graph showing which transactions are waiting for which locks",
    "split-brain": "scenario where network partition causes subsets of cluster to operate independently",
    "CAS operation": "Compare-and-Swap atomic operation for conditional updates",
    "vector clock pruning": "removing old entries from vector clocks to prevent unbounded growth",
    "deterministic reproduction": "technique to reproduce timing-dependent bugs by controlling non-deterministic inputs",
    "structured logging": "logging approach that uses consistent, machine-readable formats with contextual fields",
    "debug endpoints": "HTTP endpoints exposed for inspecting system state and debugging",
    "CRDTs": "Conflict-Free Replicated Data Types - data structures that guarantee convergence without coordination",
    "Prometheus": "open-source monitoring and alerting toolkit",
    "OpenTelemetry": "observability framework for traces, metrics, logs",
    "Cross-Region Replication": "replication across geographically distant data centers",
    "Secondary Indexing": "creating indexes on values for non-primary-key queries",
    "Multi-Tenancy": "single instance serving multiple isolated tenants",
    "Connection Pooling": "reusing established connections rather than creating new ones for each request",
    "Online Reconfiguration": "changing configuration without stopping system",
    "Tiered Storage": "storing data in different media based on access patterns",
    "Bloom Filters": "probabilistic data structure for testing set membership",
    "2PC (Two-Phase Commit)": "distributed transaction protocol with prepare and commit phases",
    "Atomicity": "property that transactions execute completely or not at all",
    "Availability": "system remains operational and responsive",
    "Bloom Filter": "probabilistic data structure for set membership testing",
    "CAS (Compare-and-Swap) Operation": "atomic conditional update operation",
    "Cluster": "group of interconnected KVoyage nodes",
    "Concurrent Writes": "writes without happens-before relationship",
    "Consensus": "process of achieving agreement among distributed nodes",
    "Consistency": "guarantee that all nodes see the same data",
    "Conflict Resolution": "process of reconciling concurrent writes",
    "Coordinator": "node that initiates and manages distributed transactions",
    "CRDTs (Conflict-Free Replicated Data Types)": "data structures guaranteeing eventual consistency without coordination",
    "Data Model": "structure and organization of data in the system",
    "Deadlock": "transactions waiting circularly for each other's locks",
    "Decision": "outcome of a transaction (commit or abort)",
    "Distributed System": "collection of autonomous elements appearing as single system",
    "Durability": "committed transactions persist after failures",
    "Eventual Consistency": "consistency model where accesses eventually return last update",
    "Failure Detection": "process of identifying crashed/unresponsive nodes",
    "Isolation": "property that concurrent transactions don't interfere",
    "Key": "string identifier for a value",
    "Load Balancing": "even workload distribution across nodes",
    "Log-Structured Merge Tree (LSM Tree)": "storage engine design with memtables and SSTables",
    "Mental Model": "intuitive analogy for understanding complex concepts",
    "Multi-Version Concurrency Control (MVCC)": "concurrency control with multiple data versions",
    "Node": "single server instance in the cluster",
    "Participant": "node involved in distributed transaction",
    "Partitioning": "splitting data across nodes (sharding)",
    "Partition Tolerance": "system operates despite network partitions",
    "Physical Node": "actual server instance (vs virtual node)",
    "Replica": "copy of key-value pair for redundancy",
    "Replication Factor (N)": "number of copies per key-value pair",
    "Serializability": "strongest isolation level equivalent to serial execution",
    "Shard": "partition of key space assigned to a node",
    "Split-Brain": "cluster subsets operating independently due to partition",
    "SSTable (Sorted String Table)": "immutable sorted file of key-value pairs",
    "Structured Logging": "logging with consistent machine-readable formats",
    "Transaction": "sequence of operations executed atomically and in isolation",
    "Vector Clock Pruning": "removing old entries from vector clocks",
    "Virtual Node": "multiple logical nodes per physical node on hash ring",
    "Write-Ahead Log (WAL)": "log recording changes before application to data structures",
    "Write Duplication": "writing to both old and new owners during rebalancing"
  }
}