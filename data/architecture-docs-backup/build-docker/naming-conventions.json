{
  "types": {
    "Container": "fields: ID string, Name string, State ContainerState, Config ContainerConfig, Pid int, CreatedAt time.Time",
    "ContainerConfig": "fields: Image string, Cmd []string, Env []string, WorkingDir string, Hostname string, Limits ResourceLimits, Network NetworkConfig",
    "ContainerState": "enum: Created, Running, Paused, Stopped, Removed",
    "ResourceLimits": "fields: MemoryMB int, CPUShares int, PidsLimit int",
    "NetworkConfig": "fields: Mode string, BridgeName string, IPAddress string, PortMappings []PortMapping",
    "PortMapping": "fields: HostPort int, ContainerPort int, Protocol string",
    "Image": "fields: Name string, Digest string, Layers []ImageLayer, Config ImageConfig",
    "ImageLayer": "fields: Digest string, Size int64, Path string",
    "ImageConfig": "fields: Entrypoint []string, Cmd []string, Env []string, WorkingDir string",
    "ContainerStore": "fields: basePath string",
    "NamespaceManager": "fields: none (or internal references to namespace paths)",
    "ChildFunc": "type: func() int",
    "CgroupManager": "fields: version int, basePath string, controllers map[string]bool, mountPoints map[string]string",
    "ControllerInfo": "fields: Version CgroupVersion, Controllers map[string]bool, MountPoints map[string]string",
    "CgroupStats": "fields: MemoryUsage int64, CPUUsage int64, PidCount int",
    "CgroupVersion": "enum: CgroupV1, CgroupV2, CgroupUnknown",
    "FilesystemManager": "fields: basePath string, imageStore ImageStore",
    "MountInfo": "fields: not specified in detail",
    "MountConfig": "fields: not specified in detail",
    "OverlayManager": "fields: storageBase string",
    "LayerCache": "fields: mu sync.RWMutex, layers map[string]int",
    "NetworkManager": "fields: baseBridgeName string, bridgeIPNet *net.IPNet, ipam *IPAM, helper *NetlinkHelper",
    "IPAM": "fields: subnet *net.IPNet, allocated map[string]bool",
    "NetlinkHelper": "fields: none",
    "IPTablesManager": "fields: none",
    "ImageStore": "fields: basePath string",
    "RegistryClient": "fields: baseURL string, httpClient *http.Client",
    "Manifest": "fields: (from OCI spec, not defined in conventions)",
    "StateManager": "fields: mu sync.RWMutex, containers map[string]*types.Container, store ContainerStore",
    "CleanupFunc": "type: func()",
    "CleanupStack": "fields: funcs []CleanupFunc, mu sync.Mutex, done bool",
    "CleanupManager": "fields: containerStacks map[string]*CleanupStack, globalStack *CleanupStack, mu sync.RWMutex",
    "ContainerInspector": "fields: basePath string, logger *logrus.Logger",
    "ContainerRuntime": "fields: debugMode bool",
    "SeccompProfile": "fields: DefaultAction string, Architectures []string, Syscalls []SyscallRule",
    "SyscallRule": "fields: Names []string, Action string, Args []Arg",
    "Volume": "fields: Name string, Driver string, Mountpoint string, Options map[string]interface{}, Labels map[string]string, CreatedAt time.Time",
    "VolumeDriver": "interface: Create(name string, opts map[string]interface{}) (Volume, error), Remove(name string) error, Mount(name string) (string, error), Unmount(name string) error, Path(name string) (string, error), DriverName() string",
    "VolumeManager": "fields: drivers map[string]VolumeDriver, volumes map[string]Volume, baseDir string, mu sync.RWMutex",
    "HealthCheckConfig": "fields: Test []string, Interval time.Duration, Timeout time.Duration, StartPeriod time.Duration, Retries int",
    "ContainerHealth": "fields: Status string, FailingStreak int, Log []HealthCheckResult",
    "HealthMonitor": "fields: containers map[string]*ContainerHealthTracker, executor HealthCheckExecutor, mu sync.RWMutex",
    "ContainerMetrics": "fields: Timestamp time.Time, CPU CPUMetrics, Memory MemoryMetrics, BlockIO BlockIOMetrics, Network NetworkMetrics, PIDs PIDMetrics",
    "MetricsCollector": "fields: cgroupManager *CgroupManager, networkManager *NetworkManager, interval time.Duration, subscribers []MetricsSubscriber, containers map[string]*ContainerMetricsHistory",
    "NetworkDriver": "interface: CreateNetwork(name string, opts map[string]interface{}) (Network, error), DeleteNetwork(name string) error, SetupContainerNetwork(containerID string, netnsPath string, config NetworkConfig) error, TeardownContainerNetwork(containerID string, netnsPath string, config NetworkConfig) error",
    "VolumeMount": "fields: Source string, Destination string, Type string, Options []string",
    "RegistryAuth": "fields: Username string, Password string, Auth string, Server string",
    "AuthStore": "interface: GetCredentials(registry string) (RegistryAuth, error), SetCredentials(registry string, auth RegistryAuth) error",
    "AuthenticatedRegistryClient": "fields: baseClient *RegistryClient, authStore AuthStore, tokenCache map[string]string, mu sync.RWMutex"
  },
  "methods": {
    "NewContainerRuntime() ContainerRuntime": "creates a new container runtime instance",
    "Runtime.CreateContainer(config ContainerConfig) (Container, error)": "creates a new container with given configuration",
    "Runtime.StartContainer(id string) error": "starts a created container",
    "Runtime.StopContainer(id string) error": "stops a running container",
    "Runtime.RemoveContainer(id string) error": "removes a stopped container",
    "NamespaceManager.CreateNamespaces(flags int) (int, error)": "creates new namespaces with given flags",
    "CgroupManager.CreateGroup(path string) error": "creates a new cgroup hierarchy",
    "CgroupManager.SetLimits(path string, limits ResourceLimits) error": "applies resource limits to cgroup",
    "FilesystemManager.SetupRootfs(image Image, containerID string) (string, error)": "sets up container root filesystem",
    "NetworkManager.SetupNetwork(nsPath string, config NetworkConfig) error": "configures container network namespace",
    "NewContainerRuntime(storePath string) (*ContainerRuntime, error)": "creates a new container runtime instance with persistence store",
    "Runtime.CreateContainer(config ContainerConfig, name string) (*Container, error)": "creates a new container with given configuration and name",
    "Runtime.StopContainer(id string, force bool) error": "stops a running container (force uses SIGKILL)",
    "ContainerStore.Save(container *Container) error": "saves container to persistent storage",
    "ContainerStore.Load(id string) (*Container, error)": "loads container from persistent storage",
    "ContainerStore.Delete(id string) error": "deletes container from storage (must be in removed state)",
    "uuid.Generate() (string, error)": "generates a random 128-bit hex ID",
    "uuid.Short() string": "generates a random 64-bit hex ID with fallback",
    "RunInNamespaces(flags int, childFunc ChildFunc) (int, error)": "creates new process in new namespaces and runs the child function",
    "ChildEntryPoint(childFunc ChildFunc)": "entry point for the child process re-executed via /proc/self/exe",
    "NamespaceManager.CreateNamespaces(cmd *exec.Cmd, flags int) (int, error)": "configures and starts a command in new namespaces, returns host PID",
    "NamespaceManager.GetNamespacePath(pid int, nsType string) (string, error)": "returns /proc/pid/ns/type path",
    "NamespaceManager.JoinNetworkNamespace(cmd *exec.Cmd, nsPath string) error": "configures command to join an existing network namespace",
    "NewCgroupManager() returns (*CgroupManager, error)": "Factory function that detects cgroup version and available controllers",
    "CreateCgroup(containerID string) returns error": "Creates cgroup hierarchy for the container",
    "ApplyLimits(containerID string, limits ResourceLimits) returns error": "Writes resource limits to cgroup control files",
    "AddProcess(containerID string, pid int) returns error": "Moves a process into the container's cgroup",
    "RemoveCgroup(containerID string) returns error": "Recursively removes the container's cgroup",
    "GetStats(containerID string) returns (*CgroupStats, error)": "Reads current resource usage statistics",
    "DetectCgroupInfo() returns (*ControllerInfo, error)": "Detects cgroup version and available controllers",
    "SetupRootfs(image Image, containerID string) returns (string, error)": "Extracts image layers and prepares root filesystem",
    "IsolateFilesystem(rootfsPath string) returns error": "Performs pivot_root and mounts essential filesystems",
    "CleanupFilesystem(containerID string) returns error": "Unmounts and removes container filesystem resources",
    "MountProc(rootfsPath string) returns error": "Mounts proc filesystem at rootfsPath/proc",
    "MountSys(rootfsPath string) returns error": "Mounts sysfs at rootfsPath/sys read-only",
    "SetupDev(rootfsPath string) returns error": "Creates /dev directory and basic device nodes",
    "PivotRoot(rootfs string) returns error": "Switches to new root filesystem using pivot_root",
    "NewOverlayManager(storageBase string) returns (*OverlayManager, error)": "creates new OverlayFS manager",
    "MountOverlay(containerID string, lowerDirs []string, upperDir, workDir string) returns (string, error)": "creates OverlayFS mount",
    "UnmountOverlay(mergedDir string) returns error": "unmounts OverlayFS",
    "GetLayerPath(digest string) returns string": "returns path where layer is stored",
    "NewLayerCache() returns *LayerCache": "creates new layer cache",
    "AddReference(digest string) returns": "increments reference count",
    "ReleaseReference(digest string) returns bool": "decrements reference count",
    "IsLayerCached(digest string) returns bool": "checks if layer exists in cache",
    "ExtractLayer(layerPath, destDir string) returns (string, error)": "extracts compressed tar layer",
    "PrepareLayersForContainer(image *oci.Image, containerID string) returns ([]string, string, string, error)": "prepares layers for container",
    "setupLayeredRootfs(image *oci.Image, containerID string) returns (string, error)": "sets up container rootfs using OverlayFS",
    "cleanupLayeredRootfs(containerID string) returns error": "cleans up OverlayFS mount",
    "NetworkManager.SetupNetwork(nsPath string, config container.NetworkConfig) error": "configures network namespace for container",
    "NetworkManager.CleanupNetwork(containerID string, config container.NetworkConfig) error": "removes network resources for container",
    "IPAM.Allocate(requestedIP string) (net.IP, error)": "allocates IP address from subnet",
    "IPAM.Release(ip net.IP) error": "releases IP address back to pool",
    "NetlinkHelper.CreateBridge(name string, ipNet *net.IPNet) error": "creates Linux bridge",
    "NetlinkHelper.CreateVethPair(hostVethName, containerVethName string, mtu int) error": "creates veth pair",
    "NetlinkHelper.MoveInterfaceToNamespace(ifaceName string, nsPath string) error": "moves interface to network namespace",
    "NetlinkHelper.ConfigureInterfaceInNamespace(ifaceName string, ipNet *net.IPNet, gateway net.IP) error": "configures interface inside namespace",
    "NetlinkHelper.LockOSThreadAndExecute(nsPath string, fn func() error) error": "executes function in specified namespace",
    "IPTablesManager.SetupMasquerade(bridgeName string) error": "sets up NAT masquerading",
    "IPTablesManager.AddPortForwarding(hostPort, containerPort int, protocol, containerIP string) error": "adds port forwarding rule",
    "IPTablesManager.RemovePortForwarding(hostPort, containerPort int, protocol, containerIP string) error": "removes port forwarding rule",
    "ImageStore.StoreBlob(src io.Reader, expectedDigest string) returns (string, error)": "saves a blob to the store, verifies digest, returns computed digest",
    "ImageStore.GetBlob(digest string) returns (io.ReadCloser, error)": "opens a blob for reading",
    "ImageStore.GetManifest(ref string) returns (*oci.Manifest, error)": "reads and parses a manifest",
    "ImageStore.StoreManifest(ref string, manifest *oci.Manifest) returns error": "saves a manifest and creates a tag reference",
    "RegistryClient.getManifest(imageRef, tag string) returns ([]byte, string, error)": "fetches raw manifest bytes and its digest",
    "RegistryClient.PullManifest(imageRef, tag string) returns (*oci.Manifest, string, error)": "fetches and parses a manifest",
    "RegistryClient.PullLayer(imageRef, digest string, w io.Writer) returns error": "downloads a layer blob",
    "ContainerRuntime.PullImage(imageRef string) returns (*image.Image, error)": "downloads an image from a registry to local store",
    "ContainerRuntime.CreateContainerFromImage(imageName string, userConfig ContainerConfig) returns (*Container, error)": "creates a container from a local image",
    "RunCommand(r *runtime.ContainerRuntime, imageRef string, userCmd []string) returns error": "CLI command to run a container",
    "StartCommand(r *runtime.ContainerRuntime, containerID string) returns error": "CLI command to start a created container",
    "StopCommand(r *runtime.ContainerRuntime, containerID string, force bool) returns error": "CLI command to stop a running container",
    "RemoveCommand(r *runtime.ContainerRuntime, containerID string) returns error": "CLI command to remove a stopped container",
    "createContainerSequence(config ContainerConfig, name string) (*Container, error)": "orchestrates the 8-phase container creation",
    "Transition(containerID string, fromState, toState ContainerState) error": "validates and executes state changes",
    "PullImage(imageRef string) (*Image, error)": "orchestrates downloading an image from registry",
    "CleanupStack.Push(f CleanupFunc)": "adds cleanup function to stack",
    "CleanupStack.Execute()": "runs all cleanup functions in reverse order",
    "CleanupStack.DeferOnError(err *error) func()": "returns function that executes cleanup stack if error is non-nil",
    "CleanupManager.RegisterContainerCleanup(containerID string) *CleanupStack": "creates cleanup stack for container",
    "CleanupManager.ExecuteContainerCleanup(containerID string)": "runs cleanup for specific container",
    "CleanupManager.ExecuteAllCleanup()": "runs cleanup for all containers and global resources",
    "ContainerRuntime.createContainerSequence(config ContainerConfig, name string) (*Container, error)": "orchestrates container creation with error handling",
    "NewCgroupManager() (*CgroupManager, error)": "Factory function that detects cgroup version and available controllers",
    "CreateCgroup(containerID string) error": "Creates cgroup hierarchy for the container",
    "ApplyLimits(containerID string, limits ResourceLimits) error": "Writes resource limits to cgroup control files",
    "AddProcess(containerID string, pid int) error": "Moves a process into the container's cgroup",
    "RemoveCgroup(containerID string) error": "Recursively removes the container's cgroup",
    "GetStats(containerID string) (*CgroupStats, error)": "Reads current resource usage statistics",
    "DetectCgroupInfo() (*ControllerInfo, error)": "Detects cgroup version and available controllers",
    "SetupRootfs(image Image, containerID string) (string, error)": "Extracts image layers and prepares root filesystem",
    "IsolateFilesystem(rootfsPath string) error": "Performs pivot_root and mounts essential filesystems",
    "CleanupFilesystem(containerID string) error": "Unmounts and removes container filesystem resources",
    "MountProc(rootfsPath string) error": "Mounts proc filesystem at rootfsPath/proc",
    "MountSys(rootfsPath string) error": "Mounts sysfs at rootfsPath/sys read-only",
    "SetupDev(rootfsPath string) error": "Creates /dev directory and basic device nodes",
    "PivotRoot(rootfs string) error": "Switches to new root filesystem using pivot_root",
    "NewOverlayManager(storageBase string) (*OverlayManager, error)": "creates new OverlayFS manager",
    "MountOverlay(containerID string, lowerDirs []string, upperDir, workDir string) (string, error)": "creates OverlayFS mount",
    "UnmountOverlay(mergedDir string) error": "unmounts OverlayFS",
    "GetLayerPath(digest string) string": "returns path where layer is stored",
    "NewLayerCache() *LayerCache": "creates new layer cache",
    "AddReference(digest string)": "increments reference count",
    "ReleaseReference(digest string) bool": "decrements reference count",
    "IsLayerCached(digest string) bool": "checks if layer exists in cache",
    "ExtractLayer(layerPath, destDir string) (string, error)": "extracts compressed tar layer",
    "PrepareLayersForContainer(image *oci.Image, containerID string) ([]string, string, string, error)": "prepares layers for container",
    "setupLayeredRootfs(image *oci.Image, containerID string) (string, error)": "sets up container rootfs using OverlayFS",
    "cleanupLayeredRootfs(containerID string) error": "cleans up OverlayFS mount",
    "ImageStore.StoreBlob(src io.Reader, expectedDigest string) (string, error)": "saves a blob to the store, verifies digest, returns computed digest",
    "ImageStore.GetBlob(digest string) (io.ReadCloser, error)": "opens a blob for reading",
    "ImageStore.GetManifest(ref string) (*oci.Manifest, error)": "reads and parses a manifest",
    "ImageStore.StoreManifest(ref string, manifest *oci.Manifest) error": "saves a manifest and creates a tag reference",
    "RegistryClient.getManifest(imageRef, tag string) ([]byte, string, error)": "fetches raw manifest bytes and its digest",
    "RegistryClient.PullManifest(imageRef, tag string) (*oci.Manifest, string, error)": "fetches and parses a manifest",
    "RegistryClient.PullLayer(imageRef, digest string, w io.Writer) error": "downloads a layer blob",
    "ContainerRuntime.PullImage(imageRef string) (*image.Image, error)": "downloads an image from a registry to local store",
    "ContainerRuntime.CreateContainerFromImage(imageName string, userConfig ContainerConfig) (*Container, error)": "creates a container from a local image",
    "RunCommand(r *runtime.ContainerRuntime, imageRef string, userCmd []string) error": "CLI command to run a container",
    "StartCommand(r *runtime.ContainerRuntime, containerID string) error": "CLI command to start a created container",
    "StopCommand(r *runtime.ContainerRuntime, containerID string, force bool) error": "CLI command to stop a running container",
    "RemoveCommand(r *runtime.ContainerRuntime, containerID string) error": "CLI command to remove a stopped container",
    "NewContainerInspector(basePath string) *ContainerInspector": "creates a new inspector instance",
    "InspectContainer(containerID string) (map[string]interface{}, error)": "gathers comprehensive debugging information about a container",
    "findContainerPID(containerID string) (int, error)": "searches for the container's main process",
    "collectNamespaceInfo(pid int) (map[string]string, error)": "reads namespace IDs from /proc/<pid>/ns/",
    "DumpToFile(containerID string, outputPath string) error": "writes inspection results to a JSON file",
    "NewDebugCommand(r *runtime.ContainerRuntime) *cobra.Command": "creates the debug command tree",
    "EnableDebugLogging()": "enables verbose debugging logging",
    "CollectDebugInfo(containerID string) (string, error)": "gathers system-wide debug information",
    "LoadProfile(path string) returns (*SeccompProfile, error)": "Loads a seccomp profile from JSON file",
    "ApplyProfile(profile *SeccompProfile) returns error": "Applies the seccomp profile to the current process",
    "DefaultProfile() returns *SeccompProfile": "Returns a default seccomp profile for containers",
    "NewVolumeManager(baseDir string) returns (*VolumeManager, error)": "Creates a new volume manager",
    "CreateVolume(name, driver string, opts map[string]interface{}) returns (Volume, error)": "Creates a new volume",
    "MountVolume(name, containerID string) returns (string, error)": "Mounts a volume for use by a container",
    "UnmountVolume(name, containerID string) returns error": "Unmounts a volume after container stops",
    "GetVolume(name string) returns (Volume, error)": "Returns volume information",
    "ListVolumes() returns []Volume": "Returns all volumes",
    "RemoveVolume(name string) returns error": "Removes a volume"
  },
  "constants": {
    "CLONE_NEWPID": "syscall.CLONE_NEWPID",
    "CLONE_NEWNET": "syscall.CLONE_NEWNET",
    "CLONE_NEWNS": "syscall.CLONE_NEWNS",
    "CLONE_NEWUTS": "syscall.CLONE_NEWUTS",
    "CLONE_NEWIPC": "syscall.CLONE_NEWIPC",
    "CLONE_NEWUSER": "syscall.CLONE_NEWUSER",
    "OCI_IMAGE_SPEC_VERSION": "v1.0.2",
    "StateCreated": "ContainerState value 'created'",
    "StateRunning": "ContainerState value 'running'",
    "StatePaused": "ContainerState value 'paused'",
    "StateStopped": "ContainerState value 'stopped'",
    "StateRemoved": "ContainerState value 'removed'",
    "CgroupV1": "cgroup version 1 constant",
    "CgroupV2": "cgroup version 2 constant",
    "CgroupUnknown": "unknown cgroup version constant",
    "MS_NOSUID": "mount flag: disable suid",
    "MS_NODEV": "mount flag: disable device files",
    "MS_NOEXEC": "mount flag: disable execution",
    "MS_RDONLY": "mount flag: read-only mount",
    "MS_PRIVATE": "mount flag: private propagation",
    "MNT_DETACH": "unmount flag: detach mount",
    "SCMP_ACT_ALLOW": "seccomp action: allow syscall",
    "SCMP_ACT_ERRNO": "seccomp action: return error from syscall",
    "SCMP_ACT_KILL": "seccomp action: kill process",
    "SCMP_ACT_KILL_PROCESS": "seccomp action: kill entire process group",
    "SCMP_ACT_TRACE": "seccomp action: notify tracing process",
    "SCMP_ARCH_X86_64": "x86_64 architecture constant for seccomp",
    "SCMP_ARCH_X86": "x86 architecture constant for seccomp",
    "SCMP_ARCH_ARM": "ARM architecture constant for seccomp",
    "SCMP_ARCH_AARCH64": "ARM64 architecture constant for seccomp"
  },
  "terms": {
    "namespace": "Linux kernel feature that isolates global system resources",
    "cgroup": "Linux kernel feature for resource limiting and accounting",
    "pivot_root": "system call that changes the root filesystem",
    "veth pair": "virtual Ethernet device pair connecting network namespaces",
    "OverlayFS": "union filesystem that layers directories",
    "rootfs": "root filesystem for container",
    "OCI": "Open Container Initiative - standardization body for containers",
    "state machine": "a system with finite states and defined transitions between them",
    "content-addressable storage": "storage where content is accessed by its hash rather than location",
    "copy-on-write": "technique where copies are deferred until modification occurs",
    "clone()": "system call to create a new process with shared execution context",
    "SysProcAttr": "Go struct to set process creation attributes",
    "/proc/self/exe": "symbolic link to the current executable",
    "controller": "cgroup subsystem that manages a specific resource type",
    "OOM killer": "kernel mechanism that terminates processes when memory is exhausted",
    "cgroup v1": "original cgroup implementation with separate hierarchies",
    "cgroup v2": "unified cgroup hierarchy with improved API",
    "RSS": "Resident Set Size - physical memory used by a process",
    "mount namespace": "Linux namespace that isolates mount points",
    "chroot": "system call that changes root directory",
    "procfs": "proc filesystem showing process information",
    "sysfs": "sys filesystem showing kernel information",
    "tmpfs": "temporary in-memory filesystem",
    "bind mount": "mount that makes directory available at another location",
    "device node": "special file representing hardware device",
    "lowerdir": "OverlayFS mount option specifying read-only lower layers",
    "upperdir": "OverlayFS mount option specifying writable upper layer",
    "workdir": "OverlayFS mount option specifying working directory",
    "whiteout": "special file marking deletion in union filesystem",
    "layer": "read-only filesystem snapshot in container image",
    "merged view": "unified filesystem view presented to container",
    "Linux bridge": "virtual switch connecting multiple network interfaces",
    "iptables": "Linux firewall and NAT tool",
    "network namespace": "Linux kernel feature that isolates network stack",
    "NAT masquerading": "network address translation making container traffic appear from host",
    "port forwarding": "mapping host port to container port",
    "IPAM": "IP Address Management for allocating container IPs",
    "registry": "server that stores and distributes container images",
    "manifest": "JSON document describing an image's layers and configuration",
    "digest": "cryptographic hash (e.g., sha256) used to uniquely identify content",
    "blob": "binary large object, e.g., a layer tar or config JSON",
    "tag": "human-readable alias pointing to a specific image manifest",
    "sequence diagram": "visual representation of component interactions over time",
    "state transition": "change from one state to another in a state machine",
    "rollback": "reversal of partially completed operations on failure",
    "reference counting": "technique to track usage of shared resources",
    "configuration merging": "combining settings from multiple sources with precedence rules",
    "authentication flow": "process of obtaining credentials for accessing secured resources",
    "compensating transactions": "for every operation that modifies system state, there is a corresponding cleanup operation",
    "cleanup stack": "pattern where operations push cleanup functions onto a stack as they succeed",
    "idempotent cleanup": "cleanup operations that can be safely called multiple times",
    "orphan detection": "finding resources not associated with any container",
    "transaction logging": "writing intentions to a log before performing operations for crash recovery",
    "content integrity": "ensuring downloaded or stored content hasn't been corrupted",
    "property-based testing": "testing methodology that verifies properties hold for automatically generated inputs",
    "fuzz testing": "testing technique that provides random, unexpected, or invalid inputs to a program",
    "integration test": "test that combines multiple components to verify they work together",
    "system test": "end-to-end test of the complete system",
    "mock": "test double that simulates the behavior of a real component",
    "test fixture": "fixed state used as a baseline for running tests",
    "race condition": "defect where output depends on sequence/timing of uncontrollable events",
    "test pyramid": "concept describing the ideal distribution of unit, integration, and system tests",
    "namespace ID": "unique identifier for a Linux namespace instance",
    "cgroup hierarchy": "tree structure of cgroups controlling resource allocation",
    "mount propagation": "how mount operations propagate between mount namespaces",
    "whiteout file": "special character device marking file deletion in union filesystems",
    "packet tracing": "monitoring network packets through the networking stack",
    "process tree": "hierarchical relationship between parent and child processes",
    "structured logging": "logging with key-value fields instead of plain text",
    "inspection command": "CLI subcommand for examining container internal state",
    "debug mode": "runtime mode with verbose logging and additional diagnostics",
    "system call tracing": "monitoring system calls made by a process",
    "resource accounting": "tracking resource usage by containers",
    "user namespace": "Linux namespace that isolates user and group IDs",
    "seccomp": "Linux kernel feature for filtering system calls",
    "capabilities": "fine-grained permissions that divide root privileges",
    "volume": "persistent storage unit that can be mounted into containers",
    "health check": "periodic command execution to verify container health",
    "metrics": "quantitative measurements of container resource usage",
    "build system": "toolchain for creating container images from source",
    "checkpoint/restore": "process of saving and restoring container state",
    "CNI": "Container Network Interface - plugin standard for container networking",
    "plugin architecture": "system design that supports interchangeable components via defined interfaces",
    "dual-stack": "networking that supports both IPv4 and IPv6 simultaneously",
    "credential store": "secure storage for authentication credentials",
    "token authentication": "bearer token-based authentication for API access"
  }
}