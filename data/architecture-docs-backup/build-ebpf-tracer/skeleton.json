{
  "title": "eBPF Tracing Tool: Design Document",
  "overview": "This system is a dynamic kernel observability tool that uses eBPF to safely and efficiently collect data from deep within the operating system. The key architectural challenge is designing a high-performance data pipeline from kernel-space to user-space with minimal overhead, while providing a flexible, programmable interface for tracing various system events.",
  "sections": [
    {
      "id": "context",
      "title": "Context and Problem Statement",
      "summary": "Explores the challenge of observing a running kernel, introduces eBPF as a solution, and compares it to traditional tracing methods. Covers Milestone 1.",
      "subsections": [
        {
          "id": "context-problem",
          "title": "The Kernel Observability Problem",
          "summary": "Describes why understanding kernel behavior is difficult, using the analogy of trying to diagnose a car engine's internal workings while it's running at full speed."
        },
        {
          "id": "context-existing",
          "title": "Existing Approaches and Limitations",
          "summary": "Compares traditional tools (strace, SystemTap, ftrace) and explains their performance, safety, and usability trade-offs."
        },
        {
          "id": "context-ebpf-intro",
          "title": "eBPF as a Solution",
          "summary": "Introduces the eBPF virtual machine and its core principles: safety via verifier, efficiency via JIT compilation, and programmability."
        }
      ]
    },
    {
      "id": "goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the scope of the project, specifying what the system must achieve and what is explicitly out of scope.",
      "subsections": [
        {
          "id": "goals-functional",
          "title": "Functional Goals",
          "summary": "Lists required capabilities: attaching to kprobes/tracepoints, efficient data transfer, aggregation, and a user-facing dashboard."
        },
        {
          "id": "goals-non-functional",
          "title": "Non-Functional Goals",
          "summary": "Specifies performance, safety, and usability requirements like minimal overhead, verifier-safe code, and clear output."
        },
        {
          "id": "goals-out-of-scope",
          "title": "Non-Goals",
          "summary": "Clarifies what is not included, such as production-grade stability, GUI, or modification of kernel data."
        }
      ]
    },
    {
      "id": "high-level-arch",
      "title": "High-Level Architecture",
      "summary": "Presents the bird's-eye view of the system components and their interactions, using a component diagram. Covers all Milestones.",
      "subsections": [
        {
          "id": "arch-overview",
          "title": "Architectural Overview",
          "summary": "Describes the three-layer architecture: Kernel eBPF Programs, User-space Loader/Manager, and Terminal Dashboard."
        },
        {
          "id": "arch-components",
          "title": "Component Responsibilities",
          "summary": "Breaks down the role of each major component: eBPF programs, maps, ring buffer, loader, and dashboard."
        },
        {
          "id": "arch-file-structure",
          "title": "Recommended File Structure",
          "summary": "Provides a suggested directory layout for organizing C source, eBPF bytecode, and user-space code."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the key data structures flowing through the system, both in kernel and user space. Covers Milestones 1-4.",
      "subsections": [
        {
          "id": "data-kernel-events",
          "title": "Kernel-Space Event Structures",
          "summary": "Describes the structs defined in eBPF C programs for events (syscall entry, TCP state change, etc.)."
        },
        {
          "id": "data-maps",
          "title": "BPF Map Data Structures",
          "summary": "Details the types and purposes of BPF maps used: hash maps for latency tracking, per-CPU arrays, and ring buffers."
        },
        {
          "id": "data-user-structs",
          "title": "User-Space Aggregation Structures",
          "summary": "Defines structures used in the dashboard for holding aggregated metrics, histograms, and connection state."
        }
      ]
    },
    {
      "id": "component-ebpf-programs",
      "title": "Component Design: eBPF Programs",
      "summary": "Deep dive into the design of the kernel-side eBPF programs, including kprobes, tracepoints, and map interactions. Covers Milestones 1-4.",
      "subsections": [
        {
          "id": "component-ebpf-mental",
          "title": "Mental Model: Kernel Event Listeners",
          "summary": "Analogy of eBPF programs as tiny, safe, in-kernel microservices that are triggered by specific events and write to shared memory."
        },
        {
          "id": "component-ebpf-interface",
          "title": "Program Interface and Context",
          "summary": "Explains the function signature for different program types (kprobe, tracepoint) and how to access context data."
        },
        {
          "id": "component-ebpf-algorithm",
          "title": "Internal Behavior Algorithm",
          "summary": "Step-by-step logic for a generic eBPF tracer program: context read, filtering, data extraction, and map update."
        },
        {
          "id": "component-ebpf-adrs",
          "title": "Architecture Decision Records (ADRs)",
          "summary": "Key decisions: Ring Buffer vs Perf Buffer, Hash Map vs LRU Map, In-Kernel Aggregation vs User-Space Aggregation."
        },
        {
          "id": "component-ebpf-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Covers verifier rejections, safe memory reads with bpf_probe_read, map capacity, and time source selection."
        },
        {
          "id": "component-ebpf-impl",
          "title": "Implementation Guidance",
          "summary": "Provides skeleton eBPF C code with TODOs, libbpf helper usage, and compilation instructions."
        }
      ]
    },
    {
      "id": "component-userspace-manager",
      "title": "Component Design: User-space Manager",
      "summary": "Design of the component that loads, attaches, and manages the lifecycle of eBPF programs. Covers Milestones 1-4.",
      "subsections": [
        {
          "id": "component-manager-mental",
          "title": "Mental Model: eBPF Program Orchestrator",
          "summary": "Analogy of a stage manager that loads scripts (eBPF bytecode), positions actors on stage (attaches to probes), and collects their output."
        },
        {
          "id": "component-manager-interface",
          "title": "Manager Interface",
          "summary": "Describes the API for loading a program, polling ring buffers, reading maps, and handling signals."
        },
        {
          "id": "component-manager-algorithm",
          "title": "Lifecycle Management Algorithm",
          "summary": "Steps for initializing libbpf, loading object files, configuring maps, attaching programs, and the main event loop."
        },
        {
          "id": "component-manager-adrs",
          "title": "Architecture Decision Records (ADRs)",
          "summary": "Decisions: Libbpf skeletons vs raw syscalls, Synchronous vs Asynchronous ring buffer consumption, Centralized vs Decentralized program management."
        },
        {
          "id": "component-manager-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Covers map pinning, ring buffer loss, program dependency, and cleanup on exit."
        },
        {
          "id": "component-manager-impl",
          "title": "Implementation Guidance",
          "summary": "Skeleton C code for a program loader and manager, using libbpf skeletons and ring buffer polling."
        }
      ]
    },
    {
      "id": "component-dashboard",
      "title": "Component Design: Terminal Dashboard",
      "summary": "Design of the user-facing terminal UI that displays live metrics, histograms, and top-N lists. Covers Milestone 4.",
      "subsections": [
        {
          "id": "component-dashboard-mental",
          "title": "Mental Model: Live Sports Telemetry Overlay",
          "summary": "Analogy of a live-updating sports broadcast graphic that overlays real-time statistics (counters, histograms) on top of the main event."
        },
        {
          "id": "component-dashboard-interface",
          "title": "Dashboard Layout and Controls",
          "summary": "Describes the screen layout, refresh mechanism, and user input handling for runtime configuration."
        },
        {
          "id": "component-dashboard-algorithm",
          "title": "Rendering and Update Algorithm",
          "summary": "Steps for aggregating per-CPU map data, formatting histograms, updating the terminal screen, and handling resize events."
        },
        {
          "id": "component-dashboard-adrs",
          "title": "Architecture Decision Records (ADRs)",
          "summary": "Decisions: Curses library vs raw ANSI codes, Fixed vs Adaptive refresh rates, In-memory vs external configuration store."
        },
        {
          "id": "component-dashboard-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Covers screen flicker, high CPU usage from frequent updates, incorrect per-CPU aggregation, and signal handling for clean exit."
        },
        {
          "id": "component-dashboard-impl",
          "title": "Implementation Guidance",
          "summary": "Starter code using ncurses, skeleton functions for drawing histograms and tables, and integration with the manager."
        }
      ]
    },
    {
      "id": "interactions",
      "title": "Interactions and Data Flow",
      "summary": "Traces the journey of a single event from kernel trigger to screen display. Covers all Milestones.",
      "subsections": [
        {
          "id": "interactions-sequence",
          "title": "End-to-End Sequence",
          "summary": "Step-by-step walkthrough of a syscall trace: kernel execution, eBPF program run, ring buffer enqueue, user-space poll, aggregation, and display."
        },
        {
          "id": "interactions-concurrency",
          "title": "Concurrency and Parallelism",
          "summary": "Explains how multiple CPUs, concurrent eBPF programs, and the user-space event loop interact without locks."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Strategies for dealing with failures at various layers: verifier rejection, map full, lost events, and user errors.",
      "subsections": [
        {
          "id": "error-kernel",
          "title": "Kernel-Space Error Handling",
          "summary": "How eBPF programs handle errors (return codes, map update failures) and what the verifier catches."
        },
        {
          "id": "error-userspace",
          "title": "User-Space Error Handling",
          "summary": "Handling load failures, ring buffer overflow, map read errors, and signal interruption."
        },
        {
          "id": "error-edge-cases",
          "title": "Edge Cases",
          "summary": "Dealing with PID reuse, short-lived connections, IPv4 vs IPv6, and system clock adjustments."
        }
      ]
    },
    {
      "id": "testing",
      "title": "Testing Strategy",
      "summary": "Approaches to verifying the system works correctly, from unit tests to integration tests and milestone checkpoints.",
      "subsections": [
        {
          "id": "testing-approach",
          "title": "Testing Approach",
          "summary": "Recommends a combination of userspace unit tests, integration tests with a mock kernel, and live system verification."
        },
        {
          "id": "testing-milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "For each milestone, describes the expected behavior, a command to run, and sample output to verify success."
        }
      ]
    },
    {
      "id": "debugging",
      "title": "Debugging Guide",
      "summary": "A practical guide for diagnosing and fixing common problems encountered during development.",
      "subsections": [
        {
          "id": "debugging-symptom-table",
          "title": "Symptom \u2192 Cause \u2192 Fix Table",
          "summary": "Structured table for common issues like 'verifier rejects program', 'no events received', 'dashboard shows wrong data'."
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools and Techniques",
          "summary": "How to use bpftool, kernel logs (dmesg), printf debugging with bpf_printk, and userspace logging."
        }
      ]
    },
    {
      "id": "future",
      "title": "Future Extensions",
      "summary": "Ideas for expanding the tool beyond the project's scope, showing how the design accommodates evolution.",
      "subsections": [
        {
          "id": "future-extensions-list",
          "title": "Possible Extensions",
          "summary": "Suggestions: more probe types (uprobes, USDT), export to external monitoring systems, advanced filtering DSL, or BPF CO-RE for portability."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key terms, acronyms, and concepts used throughout the document.",
      "subsections": [
        {
          "id": "glossary-terms",
          "title": "Term Definitions",
          "summary": "Alphabetical list of terms: eBPF, JIT, Kprobe, Libbpf, Ring Buffer, Tracepoint, Verifier, etc."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "diagram-system-component",
      "title": "System Component Overview",
      "description": "Shows the three main layers (Kernel eBPF, User-space Manager, Terminal Dashboard) and the data flow between them via BPF maps and ring buffers.",
      "type": "component",
      "relevant_sections": [
        "high-level-arch",
        "interactions"
      ]
    },
    {
      "id": "diagram-event-sequence",
      "title": "Event Lifecycle Sequence Diagram",
      "description": "Traces a single syscall event from kernel trigger through eBPF program, ring buffer, user-space consumption, aggregation, to screen update. Includes swim lanes for Kernel, eBPF VM, User-space, and Terminal.",
      "type": "sequence",
      "relevant_sections": [
        "interactions"
      ]
    },
    {
      "id": "diagram-data-model",
      "title": "Data Model Relationships",
      "description": "Class diagram showing key structures: kernel event structs (syscall_event, tcp_event), BPF map types (hash, per_cpu_array, ringbuf), and user-space aggregate structs (histogram, connection_track). Shows containment and reference relationships.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "diagram-ebpf-program-flow",
      "title": "eBPF Program Internal Flowchart",
      "description": "Flowchart for a typical eBPF tracing program: start with context, perform filter check, read kernel data safely, process data, update map or ring buffer, return.",
      "type": "flowchart",
      "relevant_sections": [
        "component-ebpf-programs"
      ]
    },
    {
      "id": "diagram-tcp-state-machine",
      "title": "TCP State Machine for Connection Tracking",
      "description": "State machine diagram showing TCP states (LISTEN, SYN_SENT, ESTABLISHED, etc.) and the transitions tracked by the tracepoint. Highlights the transitions we care about for measuring connection lifetime.",
      "type": "state-machine",
      "relevant_sections": [
        "component-ebpf-programs",
        "data-model"
      ]
    },
    {
      "id": "diagram-manager-lifecycle",
      "title": "User-space Manager Lifecycle State Machine",
      "description": "State machine for the manager: INIT, LOADING, RUNNING, PAUSED, SHUTTING_DOWN, ERROR. Shows events like SIGINT, load success/failure, and configuration update.",
      "type": "state-machine",
      "relevant_sections": [
        "component-userspace-manager"
      ]
    },
    {
      "id": "diagram-dashboard-layout",
      "title": "Terminal Dashboard Layout",
      "description": "Component diagram of the terminal screen layout, showing regions for syscall histogram, top TCP connections, event counter table, and control status line.",
      "type": "component",
      "relevant_sections": [
        "component-dashboard"
      ]
    }
  ]
}