{
  "types": {
    "event_loop": "fields: epoll_fd int, events struct epoll_event*, max_events int, running int, timer_wheel struct timer_wheel*, task_queue struct deferred_task*",
    "epoll_event": "fields: events uint32_t, data union {void *ptr, int fd, uint32_t u32, uint64_t u64}",
    "connection": "fields: fd int, read_buffer char*, write_buffer char*, timer_ref void*, write_timer_ref void*, state int, proto_state int, read_buffer_used int, write_buffer_used int, write_buffer_sent int, proto_data void*, loop struct event_loop*",
    "timer": "fields: expires_at uint64_t, callback timer_callback_t, user_data void*, next struct timer*",
    "timer_wheel": "fields: levels int, slots_per_level int, resolution_ms uint64_t, current_time uint64_t, wheel struct timer***, count uint64_t",
    "deferred_task": "fields: callback task_callback_t, user_data void*, next struct deferred_task*",
    "http_parser": "fields: state enum, buffer char*, buffer_used int, content_length int, headers_complete int, current_header struct",
    "error_category_t": "enum type for error classification",
    "struct connection": "fields: fd int, read_buffer char*, write_buffer char*, timer_ref void*, write_timer_ref void*, state int, proto_state int, read_buffer_used int, write_buffer_used int, write_buffer_sent int, proto_data void*, loop struct event_loop*",
    "reactor_thread": "fields: thread pthread_t, loop struct event_loop*, thread_id int, event_fd int, pending_connections struct connection_queue*, connections_handled uint64_t, events_processed uint64_t",
    "reactor_pool": "fields: thread_count int, threads reactor_thread*, next_thread_idx int, accept_mutex pthread_mutex_t, shared_timer_wheel struct timer_wheel*, running int",
    "protocol_handler": "fields: name const char*, handle_read protocol_handle_read_t, handle_write protocol_handle_write_t, handle_timeout protocol_handle_timeout_t, can_upgrade protocol_can_upgrade_t, upgrade protocol_upgrade_t, proto_data void*, inner_handler struct protocol_handler*",
    "tls_protocol_data": "fields: ssl SSL*, rbio BIO*, wbio BIO*, handshake_complete int, handshake_state int, pending_decrypted char*, pending_len int"
  },
  "methods": {
    "event_loop_create(max_events int) returns struct event_loop*": "Creates and initializes event loop with given capacity",
    "event_loop_register_fd(loop struct event_loop*, fd int, events uint32_t, user_data void*) returns int": "Registers FD with epoll for specified events",
    "event_loop_run(loop struct event_loop*, timeout_ms int) returns int": "Main event loop dispatch function",
    "set_nonblocking(fd int) returns int": "Sets file descriptor to non-blocking mode",
    "create_listening_socket(port int, backlog int) returns int": "Creates, binds, listens, and sets non-blocking on listening socket",
    "connection_create(fd int) returns struct connection*": "Allocates and initializes connection structure",
    "connection_destroy(conn struct connection*) returns void": "Frees connection resources",
    "connection_read(conn struct connection*) returns int": "Performs non-blocking read with full error handling",
    "connection_write(conn struct connection*) returns int": "Handles write with backpressure and EPOLLOUT registration",
    "timer_wheel_create() returns struct timer_wheel*": "Creates and initializes timer wheel",
    "timer_wheel_add(wheel struct timer_wheel*, timeout_ms uint64_t, callback timer_callback_t, user_data void*) returns void*": "Adds timer, returns reference for cancellation",
    "timer_wheel_remove(wheel struct timer_wheel*, timer_ref void*) returns void": "Removes/cancels timer",
    "timer_wheel_next_expiration(wheel struct timer_wheel*) returns uint64_t": "Returns ms until next timer expires",
    "timer_wheel_tick(wheel struct timer_wheel*) returns void": "Processes expired timers",
    "event_loop_create(max_events int) returns": "Creates and initializes event loop with given capacity",
    "event_loop_register_fd(loop struct event_loop*, fd int, events uint32_t, user_data void*) returns": "Registers FD with epoll for specified events",
    "event_loop_run(loop struct event_loop*, timeout_ms int) returns": "Main event loop dispatch function",
    "set_nonblocking(fd int) returns": "Sets file descriptor to non-blocking mode",
    "create_listening_socket(port int, backlog int) returns": "Creates, binds, listens, and sets non-blocking on listening socket",
    "connection_create(fd int) returns": "Allocates and initializes connection structure",
    "connection_destroy(conn struct connection*) returns": "Frees connection resources",
    "connection_read(conn struct connection*) returns": "Performs non-blocking read with full error handling",
    "connection_write(conn struct connection*) returns": "Handles write with backpressure and EPOLLOUT registration",
    "timer_wheel_create() returns": "Creates and initializes timer wheel",
    "timer_wheel_add(wheel struct timer_wheel*, timeout_ms uint64_t, callback timer_callback_t, user_data void*) returns": "Adds timer, returns reference for cancellation",
    "timer_wheel_remove(wheel struct timer_wheel*, timer_ref void*) returns": "Removes/cancels timer",
    "timer_wheel_next_expiration(wheel struct timer_wheel*) returns": "Returns ms until next timer expires",
    "timer_wheel_tick(wheel struct timer_wheel*) returns": "Processes expired timers",
    "event_loop_modify_fd(loop struct event_loop*, fd int, events uint32_t, user_data void*) returns": "Modifies existing FD registration",
    "event_loop_unregister_fd(loop struct event_loop*, fd int) returns": "Removes FD from epoll monitoring",
    "event_loop_stop(loop struct event_loop*) returns": "Sets running to 0 to break out of loop",
    "event_loop_register_read(loop struct event_loop*, fd int, callback read_callback_t, user_data void*) returns": "Registers read interest, internal wrapper for event_loop_register_fd",
    "event_loop_register_write(loop struct event_loop*, fd int, callback write_callback_t, user_data void*) returns": "Registers write interest (often done dynamically when buffer full)",
    "event_loop_deregister(loop struct event_loop*, fd int, events uint32_t) returns": "Removes specific event interests",
    "event_loop_defer_task(loop struct event_loop*, callback task_callback_t, user_data void*) returns": "Adds task to deferred queue for next loop iteration",
    "timer_wheel_add_repeating(wheel struct timer_wheel*, interval_ms uint64_t, callback timer_callback_t, user_data void*) returns": "Adds timer that automatically reschedules after firing",
    "timer_wheel_current_time(wheel struct timer_wheel*) returns": "Returns current time in milliseconds for relative calculations",
    "http_connection_create(fd int) returns": "Creates connection with HTTP parser initialized",
    "http_handle_read(conn struct connection*) returns": "Read callback: reads data, feeds parser, generates response if request complete",
    "http_handle_write(conn struct connection*) returns": "Write callback: sends response bytes from write buffer",
    "http_generate_response(conn struct connection*, request struct http_request*) returns": "Generates appropriate HTTP response into connection's write buffer",
    "http_parser_feed(parser struct http_parser*, data char*, len int) returns": "Incrementally parses data, returns bytes consumed",
    "event_loop_modify_fd(loop struct event_loop*, fd int, events uint32_t, user_data void*) returns int": "Modifies existing FD registration",
    "event_loop_unregister_fd(loop struct event_loop*, fd int) returns int": "Removes FD from epoll monitoring",
    "event_loop_stop(loop struct event_loop*) returns void": "Sets running to 0 to break out of loop",
    "http_handle_read(conn struct connection*) returns int": "Read callback: reads data, feeds parser, generates response if request complete",
    "http_handle_write(conn struct connection*) returns int": "Write callback: sends response bytes from write buffer",
    "http_generate_response(conn struct connection*, request struct http_request*) returns void": "Generates appropriate HTTP response into connection's write buffer",
    "http_parser_feed(parser struct http_parser*, data char*, len int) returns int": "Incremental parses data, returns bytes consumed",
    "categorize_error(errno_value int) returns error_category_t": "Categorizes errno into retryable/connection-fatal/system-fatal",
    "check_socket_error(fd int) returns int": "Gets pending socket error using getsockopt",
    "disable_sigpipe() returns void": "Disables SIGPIPE signal for process",
    "safe_write(fd int, buf const void*, count size_t) returns ssize_t": "Write that prevents SIGPIPE signal",
    "write_timeout_callback(user_data void*) returns void": "Callback for slow client write timeout",
    "event_loop_register_read(loop struct event_loop*, fd int, callback read_callback_t, user_data void*) returns int": "Registers read interest, internal wrapper for event_loop_register_fd",
    "event_loop_register_write(loop struct event_loop*, fd int, callback write_callback_t, user_data void*) returns int": "Registers write interest (often done dynamically when buffer full)",
    "event_loop_deregister(loop struct event_loop*, fd int, events uint32_t) returns int": "Removes specific event interests",
    "event_loop_defer_task(loop struct event_loop*, callback task_callback_t, user_data void*) returns int": "Adds task to deferred queue for next loop iteration",
    "timer_wheel_add_repeating(wheel struct timer_wheel*, interval_ms uint64_t, callback timer_callback_t, user_data void*) returns void*": "Adds timer that automatically reschedules after firing",
    "http_connection_create(fd int) returns struct connection*": "Creates connection with HTTP parser initialized",
    "categorize_error(errno_value int) returns": "Categorizes errno into retryable/connection-fatal/system-fatal",
    "check_socket_error(fd int) returns": "Gets pending socket error using getsockopt",
    "disable_sigpipe() returns": "Disables SIGPIPE signal for process",
    "safe_write(fd int, buf const void*, count size_t) returns": "Write that prevents SIGPIPE signal",
    "write_timeout_callback(user_data void*) returns": "Callback for slow client write timeout",
    "reactor_pool_create(thread_count int, max_events_per_thread int) returns": "Creates reactor thread pool",
    "reactor_pool_start(pool reactor_pool*) returns": "Starts all reactor threads",
    "reactor_pool_stop(pool reactor_pool*) returns": "Stops reactor threads gracefully",
    "reactor_pool_dispatch_connection(pool reactor_pool*, client_fd int) returns": "Distributes connection to reactor thread",
    "reactor_pool_get_least_loaded(pool reactor_pool*) returns": "Returns least loaded thread",
    "http_protocol_create() returns": "Creates HTTP protocol handler",
    "websocket_protocol_create() returns": "Creates WebSocket protocol handler",
    "tls_protocol_create(inner protocol_handler*) returns": "Creates TLS wrapper handler",
    "connection_set_protocol(conn struct connection*, handler protocol_handler*) returns": "Sets connection's protocol handler",
    "connection_get_protocol(conn struct connection*) returns": "Gets connection's protocol handler",
    "reactor_pool_create(thread_count int, max_events_per_thread int) returns reactor_pool*": "Creates reactor thread pool",
    "reactor_pool_start(pool reactor_pool*) returns int": "Starts all reactor threads",
    "reactor_pool_stop(pool reactor_pool*) returns void": "Stops reactor threads gracefully",
    "reactor_pool_dispatch_connection(pool reactor_pool*, client_fd int) returns int": "Distributes connection to reactor thread",
    "reactor_pool_get_least_loaded(pool reactor_pool*) returns reactor_thread*": "Returns least loaded thread",
    "http_protocol_create() returns protocol_handler*": "Creates HTTP protocol handler",
    "websocket_protocol_create() returns protocol_handler*": "Creates WebSocket protocol handler",
    "tls_protocol_create(inner protocol_handler*) returns protocol_handler*": "Creates TLS wrapper handler",
    "connection_set_protocol(conn struct connection*, handler protocol_handler*) returns void": "Sets connection's protocol handler",
    "connection_get_protocol(conn struct connection*) returns protocol_handler*": "Gets connection's protocol handler"
  },
  "constants": {
    "EPOLLIN": "Data available to read",
    "EPOLLOUT": "Ready for writing",
    "EPOLLET": "Edge-triggered mode",
    "EPOLL_CLOEXEC": "Close-on-exec flag",
    "EAGAIN": "Resource temporarily unavailable (would block)",
    "EWOULDBLOCK": "Operation would block",
    "SOCK_NONBLOCK": "Flag for accept4 to set non-blocking",
    "READ_BUFFER_SIZE": "4096",
    "WRITE_BUFFER_SIZE": "4096",
    "MAX_EVENTS": "1024",
    "STATE_ACCEPTED": "Connection accepted but not yet reading",
    "STATE_READING": "Reading request data",
    "STATE_WRITING": "Writing response data",
    "STATE_CLOSING": "Connection state: being closed",
    "HTTP_READING": "HTTP-specific state: reading request",
    "HTTP_WRITING": "HTTP state: writing response",
    "HTTP_KEEPALIVE": "HTTP state: keep-alive waiting for next request",
    "EPOLLERR": "Error condition happened on the associated file descriptor",
    "EPOLLHUP": "Hang up happened on the associated file descriptor",
    "ERROR_RETRYABLE": "Error category for retryable errors (EAGAIN, EINTR)",
    "ERROR_CONNECTION_FATAL": "Error category for connection-fatal errors (ECONNRESET, EPIPE)",
    "ERROR_SYSTEM_FATAL": "Error category for system-fatal errors (ENOMEM, EMFILE)",
    "ERROR_PROGRAMMING": "Error category for programming errors (EBADF, EFAULT)",
    "ERROR_UNKNOWN": "Error category for unknown errors",
    "IDLE_TIMEOUT_MS": "Default idle timeout in milliseconds (e.g., 30000)",
    "WRITE_TIMEOUT_MS": "Default write timeout in milliseconds (e.g., 30000)",
    "STATE_PROCESSING": "Connection state: CPU-intensive processing offloaded to worker",
    "HTTP_UPGRADING": "HTTP state: upgrading to another protocol (WebSocket)"
  },
  "terms": {
    "C10K problem": "Challenge of handling 10,000 concurrent connections",
    "Reactor pattern": "Event-driven pattern for service handlers",
    "I/O multiplexing": "Monitoring multiple I/O sources simultaneously",
    "Non-blocking I/O": "I/O operations that return immediately without waiting",
    "Edge-triggered": "Notification only on state change",
    "Level-triggered": "Notification while condition is true",
    "hierarchical timer wheel": "Multi-level data structure for O(1) timer operations",
    "callback API": "Programming interface based on function callbacks for events",
    "incremental processing": "Handling partial data as it arrives rather than waiting for complete messages",
    "connection state machine": "Finite state machine tracking connection lifecycle",
    "timer cascading": "Process of moving timers from higher to lower wheel levels",
    "buffer management": "Tracking used/available space in I/O buffers",
    "backpressure": "Mechanism to slow down data producers when consumers cannot keep up",
    "keep-alive": "HTTP feature to reuse connection for multiple requests",
    "finite state machine": "A computational model with a finite number of states and transitions between them",
    "monotonic clock": "A clock that only increases, unaffected by system time changes",
    "event loop tick": "A single iteration of the event loop's dispatch cycle",
    "half-closed connection": "TCP connection where one side has sent FIN but the other hasn't",
    "slow loris attack": "Denial-of-service attack that opens many connections and sends data slowly",
    "error categorization": "Classifying errors by severity and appropriate recovery action",
    "write timeout": "Timer that closes connection if write cannot complete within time limit",
    "idle timeout": "Timer that closes connection if no activity within time period",
    "buffer watermark": "Threshold indicating when buffer is nearly full/empty for flow control",
    "multi-threaded reactor": "Multiple threads each running event loops, sharing workload",
    "protocol handler interface": "Common interface for different protocol implementations",
    "bump-in-the-stack": "TLS implementation pattern where encryption sits between socket and application",
    "work-stealing": "Load balancing technique where idle threads take work from busy threads",
    "SO_REUSEPORT": "Socket option allowing multiple processes/threads to bind to same port",
    "thread-local storage": "Variables with separate instances per thread",
    "CPU affinity": "Binding threads to specific CPU cores for cache efficiency",
    "ALPN": "Application-Layer Protocol Negotiation (TLS extension)",
    "SPSC/MPSC": "Single/Multi Producer Single Consumer ring buffer"
  }
}