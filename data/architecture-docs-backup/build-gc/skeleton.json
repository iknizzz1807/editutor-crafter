{
  "title": "Build Your Own Garbage Collector: Design Document",
  "overview": "This system implements a multi-strategy garbage collector with mark-sweep, generational, and concurrent collection capabilities. The key architectural challenge is automatically reclaiming memory while maintaining correctness and minimizing application pause times through sophisticated marking algorithms and concurrent execution.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains the fundamental memory management problem and why automatic garbage collection is challenging, using analogies to make concepts intuitive.",
      "subsections": [
        {
          "id": "memory-management-analogy",
          "title": "The Library Analogy",
          "summary": "Mental model comparing memory management to a library system with book checkout, return, and shelf organization"
        },
        {
          "id": "existing-approaches",
          "title": "Existing GC Approaches",
          "summary": "Comparison table of reference counting, mark-sweep, copying, and generational collectors"
        },
        {
          "id": "core-challenges",
          "title": "Core Challenges",
          "summary": "Technical difficulties including root identification, concurrent access, and pause time minimization"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what the garbage collector must accomplish and explicitly excludes advanced features like real-time guarantees.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Correctness, completeness, and performance requirements"
        },
        {
          "id": "non-goals",
          "title": "Non-Goals",
          "summary": "Explicitly excluded features like real-time collection and language integration"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Component overview showing heap manager, object tracker, collection engine, and their interactions with clear responsibility boundaries.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Main components and their primary responsibilities"
        },
        {
          "id": "module-structure",
          "title": "Recommended Module Structure",
          "summary": "File organization and module boundaries for the codebase"
        },
        {
          "id": "component-interactions",
          "title": "Component Interactions",
          "summary": "How components communicate and depend on each other"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Core data structures including object headers, free lists, remembered sets, and collection metadata with their relationships.",
      "subsections": [
        {
          "id": "object-representation",
          "title": "Object Representation",
          "summary": "Object header layout and metadata fields"
        },
        {
          "id": "heap-organization",
          "title": "Heap Organization",
          "summary": "Memory layout for young/old generations and free space management"
        },
        {
          "id": "collection-metadata",
          "title": "Collection Metadata",
          "summary": "Root sets, remembered sets, and marking state structures"
        }
      ]
    },
    {
      "id": "heap-manager",
      "title": "Heap Manager Component",
      "summary": "Manages memory allocation and deallocation with free list maintenance and heap expansion policies.",
      "subsections": [
        {
          "id": "heap-mental-model",
          "title": "Mental Model: Memory as Real Estate",
          "summary": "Analogy comparing heap management to real estate development and lot subdivision"
        },
        {
          "id": "allocation-strategy",
          "title": "Allocation Strategy",
          "summary": "Free list management and allocation algorithms"
        },
        {
          "id": "heap-adrs",
          "title": "Architecture Decision Records",
          "summary": "Key decisions around heap layout, allocation strategies, and expansion policies"
        },
        {
          "id": "heap-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Typical mistakes in heap management implementation"
        },
        {
          "id": "heap-implementation",
          "title": "Implementation Guidance",
          "summary": "Code structure, starter utilities, and skeleton functions for heap management"
        }
      ]
    },
    {
      "id": "mark-sweep-collector",
      "title": "Mark-Sweep Collector Component",
      "summary": "Implements basic garbage collection through graph traversal marking and memory reclamation sweeping phases.",
      "subsections": [
        {
          "id": "mark-sweep-mental-model",
          "title": "Mental Model: House Cleaning",
          "summary": "Analogy comparing mark-sweep to systematic house cleaning with tagging and disposal"
        },
        {
          "id": "root-identification",
          "title": "Root Set Identification",
          "summary": "Algorithm for finding all GC roots from stack, globals, and registers"
        },
        {
          "id": "marking-algorithm",
          "title": "Marking Algorithm",
          "summary": "Depth-first traversal for reachability analysis"
        },
        {
          "id": "sweeping-algorithm",
          "title": "Sweeping Algorithm",
          "summary": "Heap scanning and memory reclamation process"
        },
        {
          "id": "mark-sweep-adrs",
          "title": "Architecture Decision Records",
          "summary": "Decisions around marking strategies and sweep implementations"
        },
        {
          "id": "mark-sweep-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Issues with root finding, marking loops, and incomplete sweeping"
        },
        {
          "id": "mark-sweep-implementation",
          "title": "Implementation Guidance",
          "summary": "Stack walking utilities and collection algorithm skeletons"
        }
      ]
    },
    {
      "id": "tricolor-marking",
      "title": "Tri-Color Marking Component",
      "summary": "Implements incremental collection using tri-color abstraction with write barriers to maintain correctness during concurrent execution.",
      "subsections": [
        {
          "id": "tricolor-mental-model",
          "title": "Mental Model: Paint-by-Numbers",
          "summary": "Analogy comparing tri-color marking to systematic painting with color progression"
        },
        {
          "id": "color-transitions",
          "title": "Color State Transitions",
          "summary": "State machine for white/gray/black object progression"
        },
        {
          "id": "worklist-management",
          "title": "Worklist Management",
          "summary": "Gray object queue processing for incremental marking"
        },
        {
          "id": "write-barriers",
          "title": "Write Barrier Implementation",
          "summary": "Intercepting pointer updates to maintain tri-color invariant"
        },
        {
          "id": "tricolor-adrs",
          "title": "Architecture Decision Records",
          "summary": "Decisions around barrier types and incremental scheduling"
        },
        {
          "id": "tricolor-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Write barrier bugs and invariant violations"
        },
        {
          "id": "tricolor-implementation",
          "title": "Implementation Guidance",
          "summary": "Barrier instrumentation and worklist data structures"
        }
      ]
    },
    {
      "id": "generational-collector",
      "title": "Generational Collector Component",
      "summary": "Implements age-based collection with nursery and old generation spaces, object promotion, and remembered set tracking.",
      "subsections": [
        {
          "id": "generational-mental-model",
          "title": "Mental Model: Workplace Hierarchy",
          "summary": "Analogy comparing generational collection to employee promotion and department management"
        },
        {
          "id": "generation-management",
          "title": "Generation Management",
          "summary": "Young and old generation heap organization"
        },
        {
          "id": "minor-collection",
          "title": "Minor Collection Algorithm",
          "summary": "Fast young generation collection process"
        },
        {
          "id": "object-promotion",
          "title": "Object Promotion Policy",
          "summary": "Criteria and process for moving objects to old generation"
        },
        {
          "id": "remembered-sets",
          "title": "Remembered Set Management",
          "summary": "Tracking cross-generational pointers for collection accuracy"
        },
        {
          "id": "generational-adrs",
          "title": "Architecture Decision Records",
          "summary": "Decisions around generation sizing and promotion thresholds"
        },
        {
          "id": "generational-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Missing remembered set updates and promotion timing issues"
        },
        {
          "id": "generational-implementation",
          "title": "Implementation Guidance",
          "summary": "Generation allocation and remembered set data structures"
        }
      ]
    },
    {
      "id": "concurrent-collector",
      "title": "Concurrent Collector Component",
      "summary": "Enables parallel collection execution with application threads through safepoints and snapshot-at-beginning barriers.",
      "subsections": [
        {
          "id": "concurrent-mental-model",
          "title": "Mental Model: Traffic Management",
          "summary": "Analogy comparing concurrent collection to traffic coordination with signals and right-of-way"
        },
        {
          "id": "concurrent-marking",
          "title": "Concurrent Marking Algorithm",
          "summary": "Parallel object graph traversal while application runs"
        },
        {
          "id": "safepoints",
          "title": "Safepoint Coordination",
          "summary": "Thread synchronization for GC handshakes"
        },
        {
          "id": "satb-barriers",
          "title": "SATB Write Barriers",
          "summary": "Snapshot-at-beginning consistency maintenance"
        },
        {
          "id": "concurrent-adrs",
          "title": "Architecture Decision Records",
          "summary": "Decisions around concurrency models and barrier implementations"
        },
        {
          "id": "concurrent-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Race conditions and synchronization bugs"
        },
        {
          "id": "concurrent-implementation",
          "title": "Implementation Guidance",
          "summary": "Threading utilities and synchronization primitives"
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Describes how components coordinate during allocation, collection triggers, and the sequence of operations for each collection type.",
      "subsections": [
        {
          "id": "allocation-flow",
          "title": "Allocation Flow",
          "summary": "Sequence from allocation request to object creation"
        },
        {
          "id": "collection-triggers",
          "title": "Collection Triggers",
          "summary": "Conditions that initiate different types of collection"
        },
        {
          "id": "collection-sequences",
          "title": "Collection Sequences",
          "summary": "Step-by-step flow for mark-sweep, generational, and concurrent collections"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Covers failure modes, detection strategies, and recovery mechanisms for collection errors and memory exhaustion scenarios.",
      "subsections": [
        {
          "id": "memory-exhaustion",
          "title": "Memory Exhaustion Handling",
          "summary": "Out-of-memory detection and recovery strategies"
        },
        {
          "id": "collection-failures",
          "title": "Collection Failures",
          "summary": "Handling corrupted object graphs and collection errors"
        },
        {
          "id": "consistency-checks",
          "title": "Consistency Validation",
          "summary": "Invariant checking and debugging support"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Outlines testing approaches for correctness, performance, and stress scenarios with milestone checkpoints for each implementation phase.",
      "subsections": [
        {
          "id": "correctness-testing",
          "title": "Correctness Testing",
          "summary": "Verifying collection accuracy and memory reclamation"
        },
        {
          "id": "performance-testing",
          "title": "Performance Testing",
          "summary": "Measuring pause times and throughput characteristics"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "Expected behavior and verification steps for each milestone"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common symptoms, diagnostic techniques, and debugging tools specific to garbage collector implementation issues.",
      "subsections": [
        {
          "id": "common-symptoms",
          "title": "Common Bug Symptoms",
          "summary": "Memory leaks, premature collection, and performance issues"
        },
        {
          "id": "diagnostic-techniques",
          "title": "Diagnostic Techniques",
          "summary": "Logging strategies and state inspection methods"
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools",
          "summary": "Heap viewers and collection analyzers"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements including compacting collection, parallel collection, and integration with programming language runtimes.",
      "subsections": [
        {
          "id": "compacting-collection",
          "title": "Compacting Collection",
          "summary": "Adding memory compaction to reduce fragmentation"
        },
        {
          "id": "parallel-collection",
          "title": "Parallel Collection",
          "summary": "Multi-threaded collection for improved performance"
        },
        {
          "id": "language-integration",
          "title": "Language Runtime Integration",
          "summary": "Embedding the collector in a programming language"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key terms including reachability, tri-color invariant, remembered sets, and other garbage collection concepts.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "System Architecture Overview",
      "description": "Shows the main components (Heap Manager, Object Tracker, Mark-Sweep Engine, Generational Manager, Concurrent Controller) and their interfaces. Include data flow arrows for allocation requests, collection triggers, and memory reclamation.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-data-flow"
      ]
    },
    {
      "id": "object-data-model",
      "title": "Object and Heap Data Model",
      "description": "Class diagram showing object header structure, heap organization with young/old generations, free list nodes, and remembered set entries. Include relationships and cardinalities between structures.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "heap-manager",
        "generational-collector"
      ]
    },
    {
      "id": "tricolor-state-machine",
      "title": "Tri-Color Marking State Machine",
      "description": "State machine showing white/gray/black object states with transitions triggered by discovery, scanning, and write barrier events. Include conditions for each transition.",
      "type": "state-machine",
      "relevant_sections": [
        "tricolor-marking"
      ]
    },
    {
      "id": "mark-sweep-sequence",
      "title": "Mark-Sweep Collection Sequence",
      "description": "Sequence diagram showing interactions between application, heap manager, and collector during a complete mark-sweep cycle. Include root identification, marking phase, and sweep phase steps.",
      "type": "sequence",
      "relevant_sections": [
        "mark-sweep-collector",
        "interactions-data-flow"
      ]
    },
    {
      "id": "generational-collection-flow",
      "title": "Generational Collection Flow",
      "description": "Flowchart showing decision points for minor vs major collection, object promotion criteria, and remembered set updates. Include memory threshold checks and promotion policies.",
      "type": "flowchart",
      "relevant_sections": [
        "generational-collector",
        "interactions-data-flow"
      ]
    },
    {
      "id": "concurrent-coordination",
      "title": "Concurrent Collection Coordination",
      "description": "Sequence diagram showing safepoint handshakes between mutator threads and GC thread, SATB barrier interactions, and concurrent marking coordination.",
      "type": "sequence",
      "relevant_sections": [
        "concurrent-collector",
        "interactions-data-flow"
      ]
    },
    {
      "id": "heap-layout",
      "title": "Memory Heap Layout",
      "description": "Component diagram showing physical memory organization with young generation (eden/survivor spaces), old generation, and metadata areas. Include allocation pointers and generation boundaries.",
      "type": "component",
      "relevant_sections": [
        "data-model",
        "heap-manager",
        "generational-collector"
      ]
    },
    {
      "id": "collection-triggers",
      "title": "Collection Trigger Decision Tree",
      "description": "Flowchart showing conditions that trigger different collection types based on heap occupancy, allocation rate, and generation fullness thresholds.",
      "type": "flowchart",
      "relevant_sections": [
        "interactions-data-flow",
        "generational-collector"
      ]
    }
  ]
}