{
  "types": {
    "Repository": "git_dir Path, work_tree Path",
    "Path": "pathlib Path object",
    "bytes": "binary data",
    "TreeEntry": "Tuple[str, str, str] for mode, name, hash",
    "ObjectStore": "objects_dir Path",
    "Index": "git_dir Path, index_path Path, entries List[IndexEntry]",
    "ReferenceManager": "git_dir Path, refs_dir Path, heads_dir Path, tags_dir Path, head_file Path",
    "WorkingDirectory": "file system interface component",
    "GitObject": "content bytes",
    "BlobObject": "extends GitObject",
    "TreeObject": "extends GitObject",
    "CommitObject": "extends GitObject",
    "IndexEntry": "ctime_sec int, ctime_nsec int, mtime_sec int, mtime_nsec int, device int, inode int, mode int, uid int, gid int, size int, object_hash str, flags int, path str",
    "StatusCalculator": "repo_root: Path, git_dir: Path",
    "BinaryReader": "data: bytes, offset: int",
    "BinaryWriter": "data: bytearray",
    "Edit": "type: EditType, old_line: Optional[int], new_line: Optional[int], content: str",
    "EditType": "INSERT, DELETE, MATCH enum values",
    "DiffHunk": "old_start: int, old_count: int, new_start: int, new_count: int, lines: List[str]",
    "FileDiff": "old_path: Optional[str], new_path: Optional[str], is_binary: bool, hunks: List[DiffHunk]",
    "DiffStats": "files_changed: int, insertions: int, deletions: int, binary_files: int",
    "MyersDiff": "old_lines: List[str], new_lines: List[str], M: int, N: int",
    "UnifiedDiffFormatter": "context_lines: int",
    "MergeBaseCalculator": "object_store",
    "ThreeWayMerge": "object_store, diff_algorithm",
    "MergeResult": "status: MergeStatus, merged_content: Optional[str], conflicts: List[ConflictRegion], files_changed: int, lines_added: int, lines_deleted: int",
    "ConflictRegion": "start_line: int, end_line: int, conflict_type: ConflictType, ours_content: List[str], theirs_content: List[str], base_content: List[str]",
    "MergeStatus": "CLEAN, CONFLICTED enum",
    "ConflictType": "CONTENT, ADD_ADD, DELETE_MODIFY, MODE_CHANGE enum",
    "WorkflowResult": "status: WorkflowStatus, message: str, files_changed: int, conflicts: List[str], warnings: List[str]",
    "WorkflowStatus": "SUCCESS, PARTIAL, CONFLICT, ERROR enum",
    "ProgressReporter": "total_items: int, completed_items: int, current_operation: str",
    "CommitWorkflow": "repository, object_store, index, references",
    "MergeWorkflow": "repository, object_store, index, references, merge_algorithm",
    "GitError": "message: str, error_code: str, recoverable: bool, timestamp: float",
    "CorruptionError": "extends GitError, component: str, corruption_type: str, details: str",
    "MergeConflictError": "extends GitError, conflicted_files: List[str], conflict_count: int",
    "ConcurrencyError": "extends GitError, resource: str, operation: str, retry_possible: bool",
    "FileLock": "lock_path: Path, timeout: float, lock_fd: Optional[int], acquired: bool",
    "ValidationLevel": "enum: MINIMAL, STANDARD, COMPREHENSIVE",
    "ValidationResult": "is_valid: bool, violations: List[str], warnings: List[str], validation_time: float",
    "GitDebugger": "git_dir: Path, objects_dir: Path, refs_dir: Path, index_path: Path, head_path: Path, logger",
    "RemoteRepository": "url: str, name: str, transport_type: str",
    "RemoteReferenceStore": "refs_dir: Path, remote_refs: Dict[str, str]",
    "TransferProtocol": "transport: HTTPTransport, timeout: float",
    "PackProtocol": "wants: List[str], haves: List[str]",
    "RefSpec": "source: str, destination: str, force: bool",
    "PackFile": "pack_path: Path, index_path: Path",
    "PackIndex": "fanout_table: List[int], object_hashes: List[str], pack_offsets: List[int]",
    "DeltaObject": "base_offset: int, delta_data: bytes",
    "GarbageCollector": "repository: Repository, reachable_objects: Set[str]",
    "RemoteConfig": "git_dir: Path, config_path: Path",
    "HTTPTransport": "base_url: str, username: str, password: str",
    "PackFileReader": "pack_path: Path, index_data: Dict",
    "PackFileWriter": "output_path: Path, objects: List",
    "FetchOperation": "repository: Repository, remote_config: RemoteConfig",
    "PushOperation": "repository: Repository, reference_manager: ReferenceManager"
  },
  "methods": {
    "compute_sha1(content: bytes) -> str": "compute SHA-1 hash",
    "compute_object_hash(object_type: str, content: bytes) -> str": "compute Git object hash with header",
    "Repository.init(path: Path) -> Repository": "initialize new Git repository",
    "find_git_directory(start_path: Path) -> Optional[Path]": "locate .git directory by walking up tree",
    "object_path_from_hash(git_dir: Path, object_hash: str) -> Path": "convert hash to file system path",
    "store_object(object_type: str, content: bytes) -> str": "store object in content-addressable store",
    "retrieve_object(object_hash: str) -> tuple[str, bytes]": "retrieve object content and type",
    "object_exists(object_hash: str) -> bool": "check if object exists in store",
    "object_path_from_hash(object_hash: str) -> Path": "convert hash to file system path",
    "IndexEntry.from_file(file_path: Path, object_hash: str, repo_root: Path) -> IndexEntry": "create index entry from working directory file",
    "IndexEntry.serialize() -> bytes": "serialize entry to binary format",
    "IndexEntry.deserialize(reader: BinaryReader) -> IndexEntry": "deserialize entry from binary format",
    "Index.load()": "load index from .git/index file",
    "Index.save()": "save index to .git/index file with atomic write",
    "Index.add_file(file_path: Path, repo_root: Path, object_store)": "stage a file by adding it to index",
    "Index.remove_file(file_path: str)": "remove file from index (unstage)",
    "Index.get_entry(file_path: str) -> Optional[IndexEntry]": "get index entry for specified path",
    "Index.get_all_paths() -> Set[str]": "get set of all paths in index",
    "StatusCalculator.calculate_status() -> Dict[str, str]": "perform three-way comparison and return file statuses",
    "get_file_metadata(file_path: Path) -> Dict[str, Any]": "get complete file metadata for index storage",
    "atomic_write_file(file_path: Path, content: bytes)": "write file atomically using temp file + rename",
    "resolve_reference(ref_name: str) -> Optional[str]": "resolve reference name to commit hash",
    "create_branch(branch_name: str, target_commit: str) -> bool": "create new branch pointing to commit",
    "switch_branch(branch_name: str) -> bool": "switch HEAD to point to branch",
    "checkout_commit(commit_hash: str) -> bool": "enter detached HEAD state",
    "get_current_branch() -> Optional[str]": "get current branch name or None",
    "list_branches() -> Set[str]": "list all local branch names",
    "delete_branch(branch_name: str, force: bool) -> bool": "delete branch reference",
    "branch_exists(branch_name: str) -> bool": "check if branch exists",
    "is_detached_head() -> bool": "check if HEAD is detached",
    "validate_branch_name(name: str) -> List[str]": "validate branch name and return errors",
    "read_reference_file(ref_path: Path) -> str": "read Git reference file content",
    "validate_sha1_hash(hash_str: str) -> bool": "validate SHA-1 hash format",
    "compute_diff() -> List[Edit]": "main entry point for Myers diff algorithm",
    "_find_shortest_edit_distance() -> int": "core Myers algorithm implementation",
    "_backtrack_edit_script(edit_distance: int) -> List[Edit]": "reconstruct edit sequence from search",
    "format_file_diff(file_diff: FileDiff) -> str": "generate unified diff output",
    "edits_to_hunks(edits, old_lines, new_lines) -> List[DiffHunk]": "convert edits to hunks with context",
    "is_binary_content(content: bytes) -> bool": "detect binary file content",
    "read_file_lines(file_path: Path) -> Tuple[List[str], bool]": "read file with binary detection",
    "_group_edits_into_regions(edits: List[Edit]) -> List[List[Edit]]": "group consecutive changes",
    "_create_hunk_with_context(region_edits, old_lines, new_lines) -> DiffHunk": "build single hunk with context",
    "_merge_adjacent_hunks(hunks, old_lines, new_lines) -> List[DiffHunk]": "combine overlapping hunks",
    "find_merge_base(commit_a, commit_b)": "Find lowest common ancestor between commits",
    "merge_commits(base_commit, our_commit, their_commit)": "Merge two commits using three-way algorithm",
    "merge_file_content(base_content, our_content, their_content, file_path)": "Perform line-by-line three-way merge",
    "_detect_conflicts(base_lines, our_lines, their_lines)": "Identify conflicting regions",
    "_generate_conflict_markers(conflict, our_branch, their_branch)": "Generate Git conflict markers",
    "_expand_parents(commit_hash, queue, visited, distances)": "Add commit parents to BFS queue",
    "_is_binary_content(content)": "Detect binary file content",
    "stage_files(file_paths: List[Path]) -> WorkflowResult": "stage multiple files for commit",
    "build_tree_from_index() -> str": "build tree object hierarchy from index",
    "create_commit(tree_hash: str, message: str, parent_hashes: List[str]) -> str": "create commit object with tree and parents",
    "execute_commit(message: str, stage_all: bool) -> WorkflowResult": "complete commit workflow orchestration",
    "discover_merge_base(our_commit: str, their_commit: str) -> Optional[str]": "find lowest common ancestor between commits",
    "analyze_merge_conflicts(base_commit: str, our_commit: str, their_commit: str) -> Dict[str, str]": "categorize merge requirements for all files",
    "execute_three_way_merge(base_commit: str, our_commit: str, their_commit: str) -> WorkflowResult": "perform three-way merge with conflict detection",
    "resolve_conflicts_and_commit(message: str) -> WorkflowResult": "complete merge after manual conflict resolution",
    "validate_repository_state(git_dir: Path) -> List[str]": "validate repository consistency",
    "atomic_workflow_operation(operation_name: str, operation_func, cleanup_func)": "decorator for atomic operations with cleanup",
    "recover_corrupted_object(object_hash: str, object_store, working_dir: Path) -> bool": "attempt object recovery from corruption",
    "resolve_merge_conflicts(conflicted_files: List[str], merge_info: Dict) -> WorkflowResult": "interactive conflict resolution workflow",
    "generate_conflict_markers(conflict: ConflictRegion, our_branch: str, their_branch: str) -> str": "create standard Git conflict markers",
    "FileLock.acquire() -> bool": "acquire advisory file lock with timeout",
    "FileLock.release()": "release held file lock",
    "inspect_object(object_hash: str) -> Dict[str, Any]": "comprehensive object inspection with format validation",
    "validate_repository(level: ValidationLevel) -> ValidationResult": "comprehensive repository validation with configurable depth",
    "trace_object_relationships(start_hash: str, max_depth: int) -> Dict[str, Any]": "trace object relationships from starting object",
    "diagnose_merge_failure(our_commit: str, their_commit: str) -> Dict[str, Any]": "comprehensive merge failure diagnosis",
    "_get_object_path(object_hash: str) -> Path": "convert object hash to filesystem path",
    "_preview_content(content: bytes, obj_type: str) -> str": "generate human-readable content preview",
    "_parse_tree_entries(content: bytes) -> List[Dict[str, str]]": "parse tree object entries for inspection",
    "_parse_commit_info(content: bytes) -> Dict[str, Any]": "parse commit object for inspection",
    "add_remote(name: str, url: str, fetch_refspec: str) -> bool": "add remote repository configuration",
    "discover_refs(service: str) -> List[Tuple[str, str]]": "discover available references on remote",
    "fetch(remote_name: str, refspecs: List[str]) -> Dict[str, str]": "fetch objects and references from remote",
    "push(remote_name: str, refspecs: List[str], force: bool) -> Dict[str, str]": "push local references to remote",
    "read_object(object_hash: str) -> Optional[Tuple[str, bytes]]": "read object from pack file",
    "write_pack() -> Tuple[Path, Path]": "write pack file and index to disk",
    "collect_garbage(aggressive: bool) -> Dict[str, int]": "run garbage collection cycle",
    "_resolve_delta_chain(offset: int) -> bytes": "resolve delta chain to get final content",
    "_negotiate_objects(remote_refs: List) -> Set[str]": "determine which objects need transfer",
    "_generate_pack_file(required_objects: Set[str]) -> Path": "create pack file for network transfer"
  },
  "constants": {
    "SHA1_HEX_LENGTH": "40 characters",
    "OBJECT_HEADER_FORMAT": "{type} {size}\\0{content}",
    "BLOB_TYPE": "blob",
    "TREE_TYPE": "tree",
    "COMMIT_TYPE": "commit",
    "INDEX_VERSION": "2",
    "FILE_MODE_REGULAR": "0o100644",
    "INVALID_REF_CHARS": "regex pattern for invalid reference characters",
    "RESERVED_REF_NAMES": "set of reserved Git reference names",
    "CONTEXT_LINES": "3 - context lines around conflicts",
    "BINARY_DETECTION_SIZE": "1024 - bytes to check for binary",
    "PRINTABLE_RATIO_THRESHOLD": "0.75 - minimum ratio for text",
    "PACK_SIGNATURE": "PACK magic signature for pack files",
    "PACK_VERSION": "2 - current pack file format version",
    "DELTA_CHAIN_LIMIT": "50 - maximum delta chain length",
    "PACK_SIZE_LIMIT": "2GB - maximum pack file size",
    "FANOUT_TABLE_SIZE": "256 - entries in pack index fanout table",
    "DEFAULT_FETCH_REFSPEC": "+refs/heads/*:refs/remotes/origin/* - default fetch mapping"
  },
  "terms": {
    "content-addressable storage": "Git's object storage system using SHA-1 hashes",
    "object store": "Git's storage backend for blobs, trees, and commits",
    "working directory": "file system directory containing checked-out project files",
    "git directory": "the .git folder containing repository metadata and objects",
    "immutable history": "property that historical commits cannot be changed",
    "staging area": "intermediate layer between working directory and repository",
    "symbolic reference": "reference that points to another reference rather than directly to a commit",
    "directed acyclic graph": "Git's commit history structure",
    "three-way comparison": "comparing working directory, index, and HEAD to determine file states",
    "binary format": "compact binary representation of index data for performance",
    "metadata caching": "storing file system metadata to quickly detect changes",
    "atomic write": "writing to temporary file then renaming for consistency",
    "direct reference": "reference containing raw commit SHA-1 hash",
    "detached HEAD": "HEAD pointing directly to commit hash instead of branch",
    "reference resolution": "process of following references to find target commit hash",
    "branch namespace": "organizing branches with path separators like feature/login",
    "Myers algorithm": "optimal diff algorithm finding shortest edit script",
    "edit script": "sequence of insert/delete operations to transform one file to another",
    "unified diff format": "industry standard for presenting file differences",
    "hunk": "contiguous block of changes with context lines",
    "context lines": "unchanged lines shown around modifications",
    "diagonal move": "matching elements in Myers algorithm grid",
    "edit distance": "minimum number of insert/delete operations needed",
    "binary file detection": "identifying non-text files through heuristics",
    "greedy extension": "Myers algorithm optimization following matches as far as possible",
    "merge base": "lowest common ancestor commit between branches",
    "three-way merge": "merge algorithm comparing base, ours, and theirs versions",
    "conflict markers": "special text markers delimiting merge conflicts",
    "breadth-first search": "graph traversal algorithm for finding merge base",
    "lowest common ancestor": "most recent shared commit in branch histories",
    "change attribution": "determining which branch made each modification",
    "hash mismatches": "when computed hash doesn't match expected value",
    "compression problems": "issues with zlib compression/decompression in object storage",
    "conflict detection": "identifying overlapping changes during merge",
    "repository consistency": "validation that repository satisfies Git invariants",
    "object relationships": "references between commits, trees, and blobs forming DAG",
    "diagnostic tools": "utilities for inspecting and validating Git internals",
    "remote repository": "Git repository accessible over network for collaboration",
    "pack file": "compressed bundle of Git objects for efficient storage and transfer",
    "delta compression": "storage technique using diffs between similar objects",
    "remote-tracking branch": "local reference showing last known state of remote branch",
    "fetch operation": "retrieving objects and references from remote without merging",
    "push operation": "sending local objects and reference updates to remote repository",
    "want/have negotiation": "protocol to minimize object transfer by identifying missing objects",
    "fast-forward update": "reference update where new commit is descendant of old commit",
    "pack index": "lookup table for efficient random access to objects in pack file",
    "garbage collection": "process of removing unreachable objects and optimizing storage"
  }
}