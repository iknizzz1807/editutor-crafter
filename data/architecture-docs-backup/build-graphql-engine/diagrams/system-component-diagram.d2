direction: right

title: GraphQL Engine System Components

graphql_engine: {
  style.fill: "#0f3460"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
  
  parser: Parser {
    shape: parallelogram
    style.bold: true
  }
  
  type_system: Type System {
    shape: diamond
    style.bold: true
  }
  
  execution_engine: Execution Engine {
    shape: hexagon
    style.bold: true
  }
  
  schema_reflection: Schema Reflection {
    shape: cloud
    style.bold: true
  }
  
  sql_compiler: SQL Compiler {
    shape: cylinder
    style.bold: true
  }

  parser -> type_system: AST
  type_system -> execution_engine: Validated Query
  execution_engine -> sql_compiler: Query Plan
  schema_reflection -> type_system: Type Definitions
}

http_server: HTTP Server {
  shape: rectangle
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}

database_adapter: Database Adapter {
  shape: package
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}

database: Database {
  shape: cylinder
  style.fill: "#1a1a2e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
}

http_server -> graphql_engine.parser: GraphQL Query
graphql_engine.execution_engine -> http_server: GraphQL Response
graphql_engine.sql_compiler -> database_adapter: Optimized SQL
database_adapter -> database: SQL Query
database -> database_adapter: Query Results
database_adapter -> graphql_engine.execution_engine: Data
graphql_engine.schema_reflection -> database_adapter: Introspection Query
database_adapter -> graphql_engine.schema_reflection: Schema Metadata

note: |md
  ## Data Flow
  1. HTTP Server receives GraphQL query
  2. Parser creates Abstract Syntax Tree (AST)
  3. Type System validates against schema
  4. Execution Engine creates query plan
  5. SQL Compiler generates optimized SQL
  6. Database Adapter executes SQL
  7. Results flow back through chain
| {
  shape: page
  style.fill: "#1a1a2e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
}