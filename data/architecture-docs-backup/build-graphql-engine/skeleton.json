{
  "title": "Build Your Own GraphQL Engine: Design Document",
  "overview": "This system builds a complete GraphQL execution engine that can parse GraphQL queries, reflect database schemas automatically, and compile queries to efficient SQL. The key architectural challenge is bridging the conceptual gap between GraphQL's hierarchical query model and relational databases' tabular structure while maintaining performance and type safety.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains why building a GraphQL engine is challenging, existing solutions, and the gap this project addresses for educational purposes.",
      "subsections": [
        {
          "id": "analogy-context",
          "title": "Mental Model: Restaurant Menu vs. Kitchen",
          "summary": "GraphQL as a customizable menu, the engine as the kitchen that translates orders into efficient cooking instructions"
        },
        {
          "id": "problem-definition",
          "title": "The GraphQL-Database Translation Problem",
          "summary": "Why GraphQL queries don't map directly to database queries and the challenges this creates"
        },
        {
          "id": "existing-approaches",
          "title": "Existing Solutions Comparison",
          "summary": "Comparison of Hasura, PostGraphile, and custom implementations with trade-offs"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Clear scope definition of what the system must achieve and explicit boundaries of what it won't handle.",
      "subsections": [
        {
          "id": "must-requirements",
          "title": "Must-Have Requirements",
          "summary": "Core functionality: parsing, type system, execution, schema reflection, SQL compilation"
        },
        {
          "id": "quality-goals",
          "title": "Quality Attributes",
          "summary": "Performance, correctness, extensibility, and educational value priorities"
        },
        {
          "id": "explicit-exclusions",
          "title": "Explicit Non-Goals",
          "summary": "Features deliberately excluded from scope (authz, subscriptions, etc.)"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Overview of system components, their responsibilities, and how data flows between them.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "System Component Diagram",
          "summary": "Bird's-eye view of the five major components and their interactions"
        },
        {
          "id": "file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Directory layout and module organization for clean separation of concerns"
        },
        {
          "id": "data-flow-summary",
          "title": "End-to-End Data Flow",
          "summary": "How a GraphQL query becomes a database result through the pipeline"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Core data structures representing GraphQL queries, schemas, and execution state.",
      "subsections": [
        {
          "id": "ast-types",
          "title": "AST Node Types",
          "summary": "Data structures for parsed GraphQL queries: operations, fields, fragments, directives"
        },
        {
          "id": "type-system-types",
          "title": "Type System Types",
          "summary": "Representations of GraphQL types: scalars, objects, interfaces, unions, enums"
        },
        {
          "id": "execution-state",
          "title": "Execution Context and State",
          "summary": "Data structures for tracking resolver execution, errors, and context"
        },
        {
          "id": "sql-ir",
          "title": "SQL Intermediate Representation",
          "summary": "Structures that bridge GraphQL operations to SQL queries"
        }
      ]
    },
    {
      "id": "parser-component",
      "title": "Component 1: GraphQL Parser",
      "summary": "Parses GraphQL query strings into Abstract Syntax Trees (ASTs). Corresponds to Milestone 1.",
      "subsections": [
        {
          "id": "parser-responsibility",
          "title": "Responsibility and Scope",
          "summary": "What the parser does (lexing, parsing, AST construction) and doesn't do (validation)"
        },
        {
          "id": "parser-mental-model",
          "title": "Mental Model: Language Translator",
          "summary": "Parser as a translator converting human-readable queries into machine-understandable trees"
        },
        {
          "id": "parser-interface",
          "title": "Parser Interface",
          "summary": "Public API: parse_query, parse_schema methods with inputs and outputs"
        },
        {
          "id": "parser-algorithm",
          "title": "Parsing Algorithm",
          "summary": "Step-by-step recursive descent parsing with backtracking for selections"
        },
        {
          "id": "parser-adr",
          "title": "Architecture Decision: Parser Approach",
          "summary": "Why recursive descent over parser generators or PEG, trade-offs for educational value"
        },
        {
          "id": "parser-pitfalls",
          "title": "Common Parser Pitfalls",
          "summary": "Tokenization errors, bracket matching, Unicode handling, location tracking"
        },
        {
          "id": "parser-implementation",
          "title": "Implementation Guidance",
          "summary": "File structure, tokenizer/parser skeleton, milestone checkpoint"
        }
      ]
    },
    {
      "id": "type-system-component",
      "title": "Component 2: Schema & Type System",
      "summary": "Builds and validates GraphQL type definitions, handles introspection. Corresponds to Milestone 2.",
      "subsections": [
        {
          "id": "typesys-responsibility",
          "title": "Responsibility and Scope",
          "summary": "Type definition, validation, schema building, introspection implementation"
        },
        {
          "id": "typesys-mental-model",
          "title": "Mental Model: Building Inspector",
          "summary": "Type system as building plans that define what structures are valid and how they connect"
        },
        {
          "id": "typesys-interface",
          "title": "Type System Interface",
          "summary": "Methods for defining types, building schemas, type resolution, introspection"
        },
        {
          "id": "typesys-algorithm",
          "title": "Schema Building Algorithm",
          "summary": "Step-by-step type validation, circular reference detection, interface verification"
        },
        {
          "id": "typesys-adr",
          "title": "Architecture Decision: Type Representation",
          "summary": "Object-oriented vs. functional type representation, mutable vs. immutable schemas"
        },
        {
          "id": "typesys-pitfalls",
          "title": "Common Type System Pitfalls",
          "summary": "Circular references, interface implementation gaps, input/output type confusion"
        },
        {
          "id": "typesys-implementation",
          "title": "Implementation Guidance",
          "summary": "Type classes, validation logic, introspection skeleton, milestone checkpoint"
        }
      ]
    },
    {
      "id": "execution-component",
      "title": "Component 3: Query Execution Engine",
      "summary": "Executes queries against schemas using resolver functions. Corresponds to Milestone 3.",
      "subsections": [
        {
          "id": "execution-responsibility",
          "title": "Responsibility and Scope",
          "summary": "Resolver invocation, error propagation, parallel execution, null handling"
        },
        {
          "id": "execution-mental-model",
          "title": "Mental Model: Assembly Line",
          "summary": "Execution as an assembly line where each station (resolver) processes parts of the data"
        },
        {
          "id": "execution-interface",
          "title": "Execution Interface",
          "summary": "execute_query method with schema, query AST, variables, context"
        },
        {
          "id": "execution-algorithm",
          "title": "Execution Algorithm",
          "summary": "Depth-first field resolution with parallelism, null propagation rules"
        },
        {
          "id": "execution-adr",
          "title": "Architecture Decision: Execution Strategy",
          "summary": "Synchronous vs. async execution, DataLoader pattern vs. naive batching"
        },
        {
          "id": "execution-pitfalls",
          "title": "Common Execution Pitfalls",
          "summary": "N+1 queries, missing null propagation, error handling, resolver timing"
        },
        {
          "id": "execution-implementation",
          "title": "Implementation Guidance",
          "summary": "Executor class, resolver registry, DataLoader skeleton, milestone checkpoint"
        }
      ]
    },
    {
      "id": "reflection-component",
      "title": "Component 4: Database Schema Reflection",
      "summary": "Auto-generates GraphQL schemas from database metadata. Corresponds to Milestone 4.",
      "subsections": [
        {
          "id": "reflection-responsibility",
          "title": "Responsibility and Scope",
          "summary": "Database introspection, type mapping, relationship detection, field generation"
        },
        {
          "id": "reflection-mental-model",
          "title": "Mental Model: Mirror",
          "summary": "Reflection as a mirror that shows the database structure as a GraphQL schema"
        },
        {
          "id": "reflection-interface",
          "title": "Reflection Interface",
          "summary": "reflect_schema method with connection info, configuration options"
        },
        {
          "id": "reflection-algorithm",
          "title": "Reflection Algorithm",
          "summary": "Steps: connect, introspect tables/columns, detect relationships, build GraphQL types"
        },
        {
          "id": "reflection-adr",
          "title": "Architecture Decision: Reflection Strategy",
          "summary": "Static vs. dynamic reflection, naming conventions, pluralization rules"
        },
        {
          "id": "reflection-pitfalls",
          "title": "Common Reflection Pitfalls",
          "summary": "Type mapping errors, circular relationships, naming conflicts, permission issues"
        },
        {
          "id": "reflection-implementation",
          "title": "Implementation Guidance",
          "summary": "Database adapters, metadata queries, naming utilities, milestone checkpoint"
        }
      ]
    },
    {
      "id": "compilation-component",
      "title": "Component 5: Query to SQL Compilation",
      "summary": "Compiles GraphQL queries to optimized SQL statements. Corresponds to Milestone 5.",
      "subsections": [
        {
          "id": "compilation-responsibility",
          "title": "Responsibility and Scope",
          "summary": "AST-to-SQL translation, JOIN generation, parameterization, batching"
        },
        {
          "id": "compilation-mental-model",
          "title": "Mental Model: Travel Planner",
          "summary": "Compiler as a travel planner that finds the most efficient route through related data"
        },
        {
          "id": "compilation-interface",
          "title": "Compiler Interface",
          "summary": "compile_to_sql method taking query AST and returning SQL with parameters"
        },
        {
          "id": "compilation-algorithm",
          "title": "Compilation Algorithm",
          "summary": "Steps: analyze selections, generate joins, apply filters/pagination, parameterize"
        },
        {
          "id": "compilation-adr",
          "title": "Architecture Decision: Compilation Approach",
          "summary": "Single-query JOINs vs. batched queries, ORM vs. raw SQL generation"
        },
        {
          "id": "compilation-pitfalls",
          "title": "Common Compilation Pitfalls",
          "summary": "Cartesian products, N+1 queries, missing indexes, injection vulnerabilities"
        },
        {
          "id": "compilation-implementation",
          "title": "Implementation Guidance",
          "summary": "SQL builder, join optimizer, parameter binder, milestone checkpoint"
        }
      ]
    },
    {
      "id": "interactions-flow",
      "title": "Interactions and Data Flow",
      "summary": "How components communicate, message formats, and sequence of operations.",
      "subsections": [
        {
          "id": "happy-path-sequence",
          "title": "Happy Path: Query Execution Flow",
          "summary": "End-to-end sequence from HTTP request to SQL execution and response"
        },
        {
          "id": "schema-building-flow",
          "title": "Schema Building and Reflection Flow",
          "summary": "How database reflection integrates with type system building"
        },
        {
          "id": "message-formats",
          "title": "Message and Data Formats",
          "summary": "Structures passed between components: parsed queries, execution plans, SQL IR"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Failure modes, detection strategies, and recovery approaches.",
      "subsections": [
        {
          "id": "error-categories",
          "title": "Error Categories and Handling",
          "summary": "Parse errors, validation errors, execution errors, database errors"
        },
        {
          "id": "null-handling",
          "title": "Null and Optional Value Handling",
          "summary": "GraphQL null propagation rules and database NULL mapping"
        },
        {
          "id": "edge-case-scenarios",
          "title": "Edge Case Scenarios",
          "summary": "Empty selections, circular references, deeply nested queries, large results"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Verification approaches for each component and milestone checkpoint validation.",
      "subsections": [
        {
          "id": "testing-approaches",
          "title": "Testing Approaches by Component",
          "summary": "Unit tests for parsers, integration tests for execution, golden tests for SQL"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "After each milestone: what to test, expected outputs, verification steps"
        },
        {
          "id": "property-testing",
          "title": "Property-Based Testing Opportunities",
          "summary": "Invariants like parse-then-print identity, schema round-trip consistency"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common bugs, symptoms, causes, and fixes for learners building this system.",
      "subsections": [
        {
          "id": "common-bugs",
          "title": "Common Bugs Table",
          "summary": "Symptom \u2192 Likely Cause \u2192 Diagnosis \u2192 Fix for frequent issues"
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques",
          "summary": "AST visualization, SQL logging, resolver tracing, type inspection"
        },
        {
          "id": "tools-approaches",
          "title": "Tools and Diagnostic Approaches",
          "summary": "Debug logging, GraphiQL integration, database explain plans"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "What could be added later and how the design accommodates evolution.",
      "subsections": [
        {
          "id": "planned-extensions",
          "title": "Planned Extension Points",
          "summary": "Schema stitching, subscriptions, custom directives, query caching"
        },
        {
          "id": "design-accommodations",
          "title": "Design Accommodations",
          "summary": "How current architecture enables future features without breaking changes"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key terms, acronyms, and domain vocabulary.",
      "subsections": [
        {
          "id": "graphql-terms",
          "title": "GraphQL Terminology",
          "summary": "AST, resolver, introspection, selection set, fragment, directive"
        },
        {
          "id": "database-terms",
          "title": "Database Terminology",
          "summary": "Foreign key, JOIN, parameterization, N+1, cartesian product"
        },
        {
          "id": "compiler-terms",
          "title": "Compiler Terminology",
          "summary": "Lexer, parser, token, IR, optimization, traversal"
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "system-component-diagram",
      "title": "GraphQL Engine System Components",
      "description": "Shows the five main components (Parser, Type System, Execution Engine, Schema Reflection, SQL Compiler) and their relationships. Include HTTP server, database adapter, and data flow arrows.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-flow"
      ]
    },
    {
      "id": "ast-class-diagram",
      "title": "AST Node Class Diagram",
      "description": "Shows inheritance hierarchy of AST nodes: Document \u2192 OperationDefinition \u2192 SelectionSet \u2192 Field \u2192 Argument, plus FragmentDefinition and FragmentSpread. Include type references.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "parser-component"
      ]
    },
    {
      "id": "type-system-class-diagram",
      "title": "Type System Class Diagram",
      "description": "Shows GraphQL type hierarchy: GraphQLType \u2192 ScalarType, ObjectType, InterfaceType, UnionType, EnumType, InputObjectType. Include fields, arguments, and wrappers (List, NonNull).",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "type-system-component"
      ]
    },
    {
      "id": "parsing-sequence",
      "title": "Query Parsing Sequence Diagram",
      "description": "Sequence from HTTP request through lexing, parsing, AST construction, validation. Show tokens flowing from lexer to parser, AST nodes being created.",
      "type": "sequence",
      "relevant_sections": [
        "parser-component",
        "interactions-flow"
      ]
    },
    {
      "id": "execution-flowchart",
      "title": "Query Execution Flowchart",
      "description": "Flowchart showing resolver execution: start at root, traverse selection set, resolve fields, handle errors, propagate nulls, return results. Include parallel execution branches.",
      "type": "flowchart",
      "relevant_sections": [
        "execution-component",
        "interactions-flow"
      ]
    },
    {
      "id": "sql-compilation-sequence",
      "title": "GraphQL to SQL Compilation Sequence",
      "description": "Sequence showing AST analysis, join generation, WHERE clause building, parameter binding. Include database reflection feeding schema info to compiler.",
      "type": "sequence",
      "relevant_sections": [
        "compilation-component",
        "interactions-flow"
      ]
    },
    {
      "id": "reflection-state-machine",
      "title": "Schema Reflection State Machine",
      "description": "States: disconnected \u2192 connecting \u2192 introspecting tables \u2192 detecting relationships \u2192 building types \u2192 ready. Include error states and transitions.",
      "type": "state-machine",
      "relevant_sections": [
        "reflection-component",
        "error-handling"
      ]
    },
    {
      "id": "data-flow-end-to-end",
      "title": "End-to-End Data Flow Diagram",
      "description": "Data transformation flow: GraphQL string \u2192 tokens \u2192 AST \u2192 validated query \u2192 execution plan \u2192 SQL \u2192 database results \u2192 JSON response. Show data formats at each stage.",
      "type": "flowchart",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-flow"
      ]
    }
  ]
}