{
  "types": {
    "Token": "fields: type TokenType, lexeme String, literal Object, line int",
    "AST": "abstract representation of program syntax",
    "Expr": "abstract base class",
    "Stmt": "abstract base class",
    "Environment": "fields: enclosing Environment, values Map<String, Object>",
    "TokenType": "enum of token types",
    "Scanner": "fields: source String, tokens List<Token>, start int, current int, line int",
    "Parser": "fields: tokens List<Token>, current int",
    "Interpreter": "fields: globals Environment, environment Environment, locals Map<Expr, Integer>, indentLevel int (debug)",
    "LoxFunction": "fields: declaration Stmt.Function, closure Environment, isInitializer boolean",
    "LoxClass": "fields: name String, methods Map<String, LoxFunction>, superclass LoxClass",
    "LoxInstance": "fields: klass LoxClass, fields Map<String, Object>",
    "RuntimeError": "fields: token Token, message String",
    "ParseError": "fields: token Token, message String",
    "Binary": "fields: left Expr, operator Token, right Expr",
    "Unary": "fields: operator Token, right Expr",
    "Grouping": "fields: expression Expr",
    "Literal": "fields: value Object",
    "Variable": "fields: name Token",
    "Assign": "fields: name Token, value Expr",
    "Logical": "fields: left Expr, operator Token, right Expr",
    "Call": "fields: callee Expr, paren Token, arguments List<Expr>",
    "Get": "fields: object Expr, name Token",
    "Set": "fields: object Expr, name Token, value Expr",
    "This": "fields: keyword Token",
    "Super": "fields: keyword Token, method Token",
    "Expression": "fields: expression Expr",
    "Print": "fields: expression Expr",
    "Var": "fields: name Token, initializer Expr",
    "Block": "fields: statements List<Stmt>",
    "If": "fields: condition Expr, thenBranch Stmt, elseBranch Stmt",
    "While": "fields: condition Expr, body Stmt",
    "Function": "fields: name Token, params List<Token>, body List<Stmt>",
    "Return": "fields: keyword Token, value Expr",
    "Class": "fields: name Token, superclass Expr.Variable, methods List<Stmt.Function>",
    "ScanError": "fields: line int, message String",
    "LoxNil": "fields: singleton instance",
    "AstPrinter": "fields: none, implements Expr.Visitor<String> and Stmt.Visitor<String>",
    "LoxCallable": "interface with arity() and call() methods",
    "NativeCallable": "interface for Java-implemented functions",
    "NativeRegistry": "fields: functions Map<String, NativeCallable>",
    "ConstantFolder": "implements Expr.Visitor<Expr>, Stmt.Visitor<Stmt>",
    "Repl": "fields: interpreter Interpreter, scanner Scanner, hadError boolean, inMultilineMode boolean, multilineBuffer StringBuilder",
    "LoxArray": "runtime type for arrays, fields: elements List<Object>",
    "LoxModule": "runtime type for modules, fields: environment Environment",
    "OpCode": "enum of bytecode instructions",
    "Chunk": "fields: code List<Integer>, constants List<Object>",
    "VM": "fields: stack List<Object>, frames List<CallFrame>",
    "BreakException": "runtime exception for break statements",
    "ContinueException": "runtime exception for continue statements"
  },
  "methods": {
    "Scanner.scanTokens() returns List<Token>": "converts source string into a list of tokens",
    "Parser.parse() returns List<Stmt>": "parses tokens into a list of statement AST nodes",
    "Interpreter.interpret(List<Stmt>) returns void": "executes the program by walking the AST",
    "Lox.runFile(String) returns void": "reads and executes a Lox file",
    "Lox.runPrompt() returns void": "starts an interactive REPL",
    "Lox.run(String) returns void": "runs a single source string",
    "Environment.define(String, Object) returns void": "defines a new variable in the current scope",
    "Environment.get(Token) returns Object": "gets the value of a variable, searching outward through enclosing scopes",
    "Environment.assign(Token, Object) returns void": "assigns a new value to an existing variable, searching outward",
    "Expr.accept(Visitor<R>) returns R": "accepts a visitor for double dispatch",
    "Stmt.accept(Visitor<V>) returns V": "accepts a visitor for double dispatch",
    "Scanner(source) returns Scanner": "Creates scanner for given source",
    "scanTokens() returns List<Token>": "Scans entire source, returns token list",
    "interpret(List<Stmt>) returns void": "Main entry point, executes a list of statements",
    "evaluate(Expr) returns Object": "Evaluates an expression node and returns its runtime value",
    "execute(Stmt) returns void": "Executes a statement node",
    "executeBlock(List<Stmt>, Environment) returns void": "Executes a block of statements within a given environment",
    "visitLiteralExpr(Expr.Literal) returns Object": "Visitor for literal expressions",
    "visitBinaryExpr(Expr.Binary) returns Object": "Visitor for binary expressions",
    "visitUnaryExpr(Expr.Unary) returns Object": "Visitor for unary expressions",
    "visitGroupingExpr(Expr.Grouping) returns Object": "Visitor for grouping expressions",
    "visitVariableExpr(Expr.Variable) returns Object": "Visitor for variable expressions",
    "visitAssignExpr(Expr.Assign) returns Object": "Visitor for assignment expressions",
    "visitLogicalExpr(Expr.Logical) returns Object": "Visitor for logical expressions",
    "visitExpressionStmt(Stmt.Expression) returns Void": "Visitor for expression statements",
    "visitPrintStmt(Stmt.Print) returns Void": "Visitor for print statements",
    "visitVarStmt(Stmt.Var) returns Void": "Visitor for variable declaration statements",
    "visitBlockStmt(Stmt.Block) returns Void": "Visitor for block statements",
    "visitIfStmt(Stmt.If) returns Void": "Visitor for if statements",
    "visitWhileStmt(Stmt.While) returns Void": "Visitor for while statements",
    "isTruthy(Object) returns boolean": "Applies Lox's truthiness rule",
    "isEqual(Object, Object) returns boolean": "Deep equality check for Lox values",
    "stringify(Object) returns String": "Converts a Lox runtime value to its string representation",
    "LoxFunction.call(Interpreter, List<Object>) returns Object": "executes the function body with given arguments",
    "LoxFunction.arity() returns int": "returns number of parameters",
    "Interpreter.visitCallExpr(Expr.Call) returns Object": "Evaluates a function call expression",
    "Interpreter.visitFunctionStmt(Stmt.Function) returns Void": "Handles function declaration",
    "Interpreter.visitReturnStmt(Stmt.Return) returns Void": "Handles return statement",
    "LoxClass.call(Interpreter, List<Object>) returns Object": "creates new instance and invokes initializer",
    "LoxClass.findMethod(String) returns LoxFunction": "looks up method in class and superclass chain",
    "LoxInstance.get(String) returns Object": "returns field value or bound method",
    "LoxInstance.set(String, Object) returns void": "sets field value",
    "LoxFunction.bind(LoxInstance) returns LoxFunction": "returns new function bound to given instance",
    "Interpreter.visitClassStmt(Stmt.Class) returns Void": "Evaluates class declaration",
    "Interpreter.visitGetExpr(Expr.Get) returns Object": "Evaluates property access",
    "Interpreter.visitSetExpr(Expr.Set) returns Object": "Evaluates property assignment",
    "Interpreter.visitThisExpr(Expr.This) returns Object": "Evaluates 'this' keyword",
    "Interpreter.visitSuperExpr(Expr.Super) returns Object": "evaluates super expression",
    "Interpreter.evaluate(Expr) returns Object": "evaluates an expression node and returns its runtime value",
    "Interpreter.execute(Stmt) returns void": "executes a statement node",
    "Interpreter.executeBlock(List<Stmt>, Environment) returns void": "executes a block of statements within a given environment",
    "Lox.error(int, String) returns void": "Report scanning/parsing error at line",
    "Lox.error(Token, String) returns void": "Report error at token location",
    "Lox.runtimeError(RuntimeError) returns void": "Report runtime error",
    "Parser.synchronize() returns void": "panic-mode error recovery",
    "Interpreter.checkNumberOperand(Token, Object) returns void": "Verify operand is number for unary op",
    "Interpreter.checkNumberOperands(Token, Object, Object) returns void": "Verify operands are numbers for binary op",
    "Interpreter.stringify(Object) returns String": "Convert Lox value to string representation",
    "Interpreter.isEqual(Object, Object) returns boolean": "Deep equality check with epsilon for numbers",
    "Scanner.scanTokens()": "converts source string into a list of tokens",
    "Parser.parse()": "parses tokens into a list of statement AST nodes",
    "Interpreter.interpret(List<Stmt>)": "executes the program by walking the AST",
    "Interpreter.evaluate(Expr)": "evaluates an expression node and returns its runtime value",
    "Interpreter.execute(Stmt)": "executes a statement node",
    "Interpreter.executeBlock(List<Stmt>, Environment)": "executes a block of statements within a given environment",
    "Environment.define(String, Object)": "defines a new variable in the current scope",
    "Environment.get(Token)": "gets the value of a variable, searching outward through enclosing scopes",
    "Environment.assign(Token, Object)": "assigns a new value to an existing variable, searching outward",
    "LoxFunction.call(Interpreter, List<Object>)": "executes the function body with given arguments",
    "LoxFunction.arity()": "returns number of parameters",
    "LoxClass.call(Interpreter, List<Object>)": "creates new instance and invokes initializer",
    "LoxClass.findMethod(String)": "looks up method in class and superclass chain",
    "LoxInstance.get(String)": "returns field value or bound method",
    "LoxInstance.set(String, Object)": "sets field value",
    "LoxFunction.bind(LoxInstance)": "returns new function bound to given instance",
    "AstPrinter.print(Expr) returns String": "prints expression as S-expression",
    "AstPrinter.print(Stmt) returns String": "prints statement as S-expression",
    "AstPrinter.print(List<Stmt>) returns String": "prints list of statements",
    "Environment.dump() returns void": "prints environment chain to stdout",
    "Environment.dump(int) returns void": "recursive dump with indentation",
    "Interpreter.log(String) returns void": "logs debug message if DEBUG enabled",
    "Scanner.string() returns void": "scans a string literal",
    "Interpreter.visitBinaryExpr(Expr.Binary) returns Object": "evaluates binary expression with logging",
    "Interpreter.visitLogicalExpr(Expr.Logical) returns Object": "evaluates logical expression with short-circuit",
    "checkNumberOperand(Token, Object) returns void": "checks operand is a number",
    "checkNumberOperands(Token, Object, Object) returns void": "checks both operands are numbers",
    "NativeCallable.arity() returns int": "number of arguments expected",
    "NativeCallable.call(Interpreter, List<Object>) returns Object": "execute native function",
    "NativeRegistry.register(String, NativeCallable) returns void": "register a native function",
    "NativeRegistry.installInto(Environment) returns void": "add all native functions to global environment",
    "ConstantFolder.fold(List<Stmt>) returns List<Stmt>": "apply constant folding to statements",
    "Repl.run() returns void": "start the REPL loop",
    "LoxArray.get(int) returns Object": "get element at index with bounds check",
    "LoxArray.set(int, Object) returns void": "set element at index with bounds check",
    "LoxArray.length() returns int": "number of elements in array",
    "VM.interpret(Chunk) returns void": "execute bytecode chunk",
    "Compiler.compile(Expr) returns Chunk": "compile expression to bytecode"
  },
  "constants": {
    "EOF": "End-of-file token type",
    "LEFT_PAREN": "Left parenthesis token type",
    "RIGHT_PAREN": "Right parenthesis token type",
    "LEFT_BRACE": "Left brace token type",
    "RIGHT_BRACE": "Right brace token type",
    "COMMA": "Comma token type",
    "DOT": "Dot token type",
    "MINUS": "Minus token type",
    "PLUS": "Plus token type",
    "SEMICOLON": "Semicolon token type",
    "SLASH": "Slash token type",
    "STAR": "Star token type",
    "BANG": "Bang token type",
    "BANG_EQUAL": "Bang equal token type",
    "EQUAL": "Equal token type",
    "EQUAL_EQUAL": "Equal equal token type",
    "GREATER": "Greater token type",
    "GREATER_EQUAL": "Greater equal token type",
    "LESS": "Less token type",
    "LESS_EQUAL": "Less equal token type",
    "IDENTIFIER": "Identifier token type",
    "STRING": "String literal token type",
    "NUMBER": "Number literal token type",
    "AND": "And keyword token type",
    "CLASS": "Class keyword token type",
    "ELSE": "Else keyword token type",
    "FALSE": "False keyword token type",
    "FUN": "Fun keyword token type",
    "FOR": "For keyword token type",
    "IF": "If keyword token type",
    "NIL": "Nil keyword token type",
    "OR": "Or keyword token type",
    "PRINT": "Print keyword token type",
    "RETURN": "Return keyword token type",
    "SUPER": "Super keyword token type",
    "THIS": "This keyword token type",
    "TRUE": "True keyword token type",
    "VAR": "Var keyword token type",
    "WHILE": "While keyword token type",
    "DEBUG": "static boolean flag in Interpreter for enabling debug logs",
    "LEFT_BRACKET": "token type for [",
    "RIGHT_BRACKET": "token type for ]",
    "BREAK": "keyword token type for break",
    "CONTINUE": "keyword token type for continue",
    "SWITCH": "keyword token type for switch",
    "CASE": "keyword token type for case",
    "DEFAULT": "keyword token type for default",
    "TRY": "keyword token type for try",
    "CATCH": "keyword token type for catch",
    "IMPORT": "keyword token type for import"
  },
  "terms": {
    "Tree-walking interpreter": "An interpreter that executes code by recursively traversing the Abstract Syntax Tree",
    "Abstract Syntax Tree (AST)": "A hierarchical tree representation of the grammatical structure of source code",
    "Token": "Categorized lexical unit from source code",
    "Lexical Analysis": "The process of converting a sequence of characters into a sequence of tokens",
    "Syntactic Analysis": "The process of analyzing a sequence of tokens to determine its grammatical structure",
    "Semantic Analysis": "The process of interpreting the meaning of valid syntactic structures",
    "Visitor Pattern": "A behavioral design pattern used to separate operations from the object structure they operate on",
    "Lox": "The programming language being implemented",
    "Closure": "A function that captures its lexical environment",
    "REPL": "Read-Eval-Print Loop interactive environment",
    "grammar rules": "The formal specification that defines which sequences of tokens constitute valid programs",
    "panic-mode recovery": "parsing error recovery by discarding tokens until synchronization point",
    "truthiness": "Boolean interpretation of values in conditional contexts",
    "lexical scoping": "Variable resolution based on where variables are defined in source code",
    "environment chain": "Linked list of Environment objects representing nested scopes",
    "Scanner": "Component that performs lexical analysis, converting source code to tokens",
    "lexer": "Synonym for scanner",
    "lexeme": "The raw text of a token as it appears in source",
    "literal": "The runtime value of a token (for literals like strings and numbers)",
    "lexical analysis": "Process of converting character stream to token stream",
    "Parser": "Component that performs syntactic analysis, converting tokens to AST",
    "recursive descent parsing": "A top-down parsing technique where each nonterminal in the grammar is implemented as a function",
    "tree-walking interpreter": "An interpreter that executes code by recursively traversing the Abstract Syntax Tree",
    "environment": "A runtime data structure mapping variable names to values within a specific scope",
    "short-circuit evaluation": "evaluating right operand of logical operator only if needed",
    "runtime error": "An error that occurs during program execution, such as a type mismatch or undefined variable",
    "closure": "A function that captures its lexical environment",
    "first-class function": "A function that can be treated like any other value",
    "arity": "The number of parameters a function expects",
    "defining environment": "The environment active when a function is declared, captured by closures",
    "class": "Blueprint and factory for creating instances",
    "instance": "Runtime object created from a class with its own fields",
    "inheritance": "Mechanism where a class derives behavior from a superclass",
    "method": "Function defined within a class, implicitly bound to instances",
    "initializer": "Special method named 'init' called when instance is created",
    "this": "Keyword referring to the current instance within a method",
    "super": "Keyword for calling a method from the superclass within a subclass method",
    "property": "Field or method accessed via dot notation on an instance",
    "method resolution order": "Order in which classes are searched when looking up a method",
    "fail-fast": "Runtime error strategy that halts execution immediately upon semantic violation",
    "synchronization point": "Token where parsing can resume after error recovery (e.g., statement boundaries)",
    "deep equality": "Equality comparison that compares values rather than references",
    "AST Printer": "visitor that converts AST to human-readable string",
    "Environment Dumper": "utility to print all variable bindings in the environment chain",
    "Execution Log": "trace of interpreter's step-by-step evaluation",
    "Token Stream Visualizer": "prints list of tokens from scanner",
    "S-expression": "parenthesized notation for representing tree structures",
    "left-recursive grammar": "grammar rule that refers to itself as its first element, causing infinite recursion in naive recursive descent",
    "constant folding": "compile-time evaluation of constant expressions",
    "environment flattening": "optimization converting chain of scopes to flat array",
    "method caching": "caching method lookup results at call sites",
    "string interning": "sharing storage for identical strings",
    "tail call optimization": "reusing stack frame for tail-recursive calls",
    "upvalue": "variable captured from enclosing scope",
    "bytecode": "compact representation of program for VM execution",
    "standard library": "built-in functions available to all programs",
    "native function": "function implemented in host language (Java)",
    "FFI": "Foreign Function Interface for calling host code",
    "module": "self-contained unit of code with exports",
    "import": "statement to load modules",
    "array": "indexed collection data type",
    "exception": "error value that can be thrown and caught",
    "switch statement": "multi-way conditional statement",
    "break statement": "exit innermost loop immediately",
    "continue statement": "skip to next iteration of loop",
    "optimization pass": "transformation of AST/bytecode to improve performance",
    "stack VM": "virtual machine using operand stack",
    "register VM": "virtual machine using named registers",
    "JIT compilation": "Just-In-Time compilation to native code"
  }
}