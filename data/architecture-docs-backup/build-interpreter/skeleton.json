{
  "title": "Building a Tree-Walking Interpreter for Lox: Design Document",
  "overview": "This document outlines the architecture for a complete interpreter for the Lox programming language, implementing a tree-walking evaluation strategy. The key architectural challenge is designing a clean separation between the static structure of the code (lexing, parsing) and its dynamic execution (environment-based evaluation), while managing state, scope, and first-class functions in a way that is both correct and educational for the implementer.",
  "sections": [
    {
      "id": "context",
      "title": "1. Context and Problem Statement",
      "summary": "Defines the problem of interpreting a high-level language, introduces the tree-walking strategy, and positions it against other interpreter architectures like bytecode VMs.",
      "subsections": [
        {
          "id": "context-analogy",
          "title": "Mental Model: The Tour Guide",
          "summary": "A tree-walking interpreter is like a tour guide leading you through a map (the AST) of a city (the program), performing actions at each landmark according to a rulebook (the language semantics)."
        },
        {
          "id": "context-problem",
          "title": "The Core Challenge: Bridging Syntax and Runtime",
          "summary": "Explains the fundamental gap between source code text and executable behavior, and why a multi-phase design (Scanner\u2192Parser\u2192Interpreter) is necessary."
        },
        {
          "id": "context-approaches",
          "title": "Existing Interpreter Architectures",
          "summary": "Compares tree-walking interpreters (simple, direct) with bytecode virtual machines (faster, more complex) and ahead-of-time compilers."
        }
      ]
    },
    {
      "id": "goals",
      "title": "2. Goals and Non-Goals",
      "summary": "Specifies the required features of the Lox language that must be supported and clarifies what is explicitly out of scope for this educational project.",
      "subsections": [
        {
          "id": "goals-functional",
          "title": "Functional Goals",
          "summary": "Complete support for Lox syntax: variables, control flow, functions, closures, classes, and single inheritance."
        },
        {
          "id": "goals-non-functional",
          "title": "Non-Functional Goals & Non-Goals",
          "summary": "Prioritizes clarity and learning over performance; excludes a REPL, standard library, garbage collection, and native extensions."
        }
      ]
    },
    {
      "id": "high-level-arch",
      "title": "3. High-Level Architecture",
      "summary": "Provides a bird's-eye view of the three main pipeline components (Scanner, Parser, Interpreter) and their data flow, along with the foundational Environment system.",
      "subsections": [
        {
          "id": "arch-components",
          "title": "Component Overview and Data Flow",
          "summary": "Describes the linear pipeline where source code becomes Tokens, then an AST, and is finally evaluated, with the Environment providing runtime state."
        },
        {
          "id": "arch-file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Suggests a package structure organizing components by their phase in the interpretation pipeline (scanning, parsing, ast, interpreting)."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core immutable data structures that represent the program at different stages: Tokens, AST Nodes, and Runtime Values.",
      "subsections": [
        {
          "id": "data-tokens",
          "title": "Tokens: The Lexical Atoms",
          "summary": "Describes the Token type, its fields (type, lexeme, literal, line), and its role as the scanner's output."
        },
        {
          "id": "data-ast-nodes",
          "title": "AST Nodes: The Program's Skeleton",
          "summary": "Defines the hierarchy of Expr and Stmt abstract classes and their concrete implementations, forming the tree structure."
        },
        {
          "id": "data-runtime-values",
          "title": "Runtime Values: The Interpreter's Currency",
          "summary": "Explains the Object type hierarchy (LoxNumber, LoxString, LoxBoolean, LoxNil, LoxFunction, LoxClass, LoxInstance) that represents values during execution."
        },
        {
          "id": "data-environments",
          "title": "Environments: The Scoped Namespace",
          "summary": "Describes the Environment class as a chain of hash maps, linking variable names to their current runtime values."
        }
      ]
    },
    {
      "id": "component-scanner",
      "title": "5.1 Component Design: Scanner (Lexer) [Milestone 1]",
      "summary": "Design of the component that performs lexical analysis, converting a stream of characters into a stream of meaningful tokens.",
      "subsections": [
        {
          "id": "scanner-mental-model",
          "title": "Mental Model: The Tokenizer",
          "summary": "The scanner is like a translator breaking a sentence into individual words and punctuation, categorizing each piece."
        },
        {
          "id": "scanner-interface",
          "title": "Interface and State",
          "summary": "Defines the Scanner constructor and scanTokens method. Internal state includes the source string, current position, and line tracking."
        },
        {
          "id": "scanner-algorithm",
          "title": "Scanning Algorithm",
          "summary": "Step-by-step process: advance through source, identify token type via first character, handle literals and operators, skip whitespace/comments."
        },
        {
          "id": "scanner-adr-visitor",
          "title": "ADR: Visitor vs. Procedural Scanning",
          "summary": "Decision to use a simple procedural loop over a state machine or visitor pattern for simplicity and clarity in an educational context."
        },
        {
          "id": "scanner-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Incorrect handling of multi-character operators (>=), unterminated strings, and number literals; forgetting to track line numbers for errors."
        },
        {
          "id": "scanner-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for Token and TokenType enums, and skeleton code for the Scanner class with TODOs for core logic."
        }
      ]
    },
    {
      "id": "component-parser",
      "title": "5.2 Component Design: Parser & AST [Milestones 2 & 3]",
      "summary": "Design of the recursive descent parser that consumes tokens to build an Abstract Syntax Tree, and the definition of the AST node classes.",
      "subsections": [
        {
          "id": "parser-mental-model",
          "title": "Mental Model: The Sentence Diagrammer",
          "summary": "The parser acts like a grammarian diagramming a sentence, identifying subjects, verbs, and objects, and nesting them according to rules of precedence."
        },
        {
          "id": "parser-ast-visitor",
          "title": "AST Definition and the Visitor Pattern",
          "summary": "Explains the use of the Visitor pattern to define operations on the heterogeneous AST node types without instanceof checks."
        },
        {
          "id": "parser-algorithm",
          "title": "Parsing Expression Grammar (PEG) & Recursive Descent",
          "summary": "Details the chain of parsing methods (expression \u2192 equality \u2192 comparison \u2192 term \u2192 factor \u2192 unary \u2192 primary) that mirrors operator precedence."
        },
        {
          "id": "parser-adr-pratt",
          "title": "ADR: Recursive Descent vs. Pratt Parsing",
          "summary": "Decision to use classic recursive descent for its explicitness and direct mapping to the grammar, making it easier to learn."
        },
        {
          "id": "parser-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Left-recursion causing infinite loops, incorrect precedence/associativity, poor error reporting and recovery, and visitor pattern boilerplate."
        },
        {
          "id": "parser-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides complete starter code for the AST node classes and Visitor interfaces, and skeleton code for the Parser with TODO steps for each grammar rule."
        }
      ]
    },
    {
      "id": "component-interpreter-core",
      "title": "5.3 Component Design: Core Interpreter [Milestones 4, 5, 6]",
      "summary": "Design of the tree-walking Interpreter that evaluates expressions and executes statements, including state via Environments and control flow.",
      "subsections": [
        {
          "id": "interpreter-mental-model",
          "title": "Mental Model: The Tree-Walking Executor",
          "summary": "The interpreter is a puppeteer walking the AST marionette, making each node 'act out' its meaning\u2014calculating, branching, or looping."
        },
        {
          "id": "interpreter-interface",
          "title": "Interface: The Evaluate and Execute Methods",
          "summary": "Defines the core methods: evaluate(Expr) for expressions and execute(Stmt) for statements, plus the runtime environment stack."
        },
        {
          "id": "interpreter-algorithm",
          "title": "Evaluation and Execution Algorithms",
          "summary": "Step-by-step logic for evaluating each expression type (binary, unary, literal, variable, assign) and executing each statement type (print, var, block, if, while)."
        },
        {
          "id": "interpreter-adr-dynamic-typing",
          "title": "ADR: Dynamic Type Checking Strategy",
          "summary": "Decision to perform type checks at runtime within each evaluation method, rejecting operations on incompatible types with a runtime error."
        },
        {
          "id": "interpreter-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Confusing Java null with Lox nil, improper scoping leading to variable shadowing bugs, forgetting short-circuit evaluation in logical operators, and infinite loops."
        },
        {
          "id": "interpreter-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for the RuntimeError exception and skeleton for the Interpreter class with TODOs for each visit method."
        }
      ]
    },
    {
      "id": "component-functions-closures",
      "title": "5.4 Component Design: Functions and Closures [Milestones 7 & 8]",
      "summary": "Extends the interpreter to support first-class functions, calls, returns, and lexical scoping via closures.",
      "subsections": [
        {
          "id": "functions-mental-model",
          "title": "Mental Model: The Function as a Recipe with a Kitchen",
          "summary": "A function is a recipe (body) and a list of ingredients (parameters). A closure is that recipe bundled with a snapshot of the kitchen (defining environment) it was written in."
        },
        {
          "id": "functions-callable",
          "title": "LoxFunction: A Callable Wrapper",
          "summary": "Describes the LoxFunction class that wraps the AST function node and its defining environment, implementing a call() method."
        },
        {
          "id": "functions-algorithm",
          "title": "Function Call and Return Algorithm",
          "summary": "Steps: evaluate arguments, create new environment for the call with the closure's environment as parent, bind parameters, execute body, handle return statements."
        },
        {
          "id": "closures-adr-capture",
          "title": "ADR: Environment Capture for Closures",
          "summary": "Decision to capture the *defining* environment by reference, not by copy, allowing closures to see and modify variables from outer scopes."
        },
        {
          "id": "functions-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Not creating a new environment per call (breaking recursion), incorrectly binding 'this', forgetting to propagate return values through the call stack, and memory leaks from captured environments."
        },
        {
          "id": "functions-implementation",
          "title": "Implementation Guidance",
          "summary": "Skeleton code for the LoxFunction class and the implementation of visitCallExpr and visitReturnStmt methods in the interpreter."
        }
      ]
    },
    {
      "id": "component-classes-inheritance",
      "title": "5.5 Component Design: Classes and Inheritance [Milestones 9 & 10]",
      "summary": "Extends the interpreter to support class declarations, instances with fields and methods, and single inheritance with super calls.",
      "subsections": [
        {
          "id": "classes-mental-model",
          "title": "Mental Model: The Class as a Blueprint and Factory",
          "summary": "A class is a blueprint (defining methods) and a factory function. An instance is a house built from the blueprint, with its own storage rooms (fields). Inheritance is creating a modified copy of the blueprint."
        },
        {
          "id": "classes-structures",
          "title": "LoxClass and LoxInstance Structures",
          "summary": "Describes LoxClass (holds name, methods, superclass) and LoxInstance (holds a reference to its class and a map of fields)."
        },
        {
          "id": "classes-algorithm",
          "title": "Instantiation, Property Access, and Method Resolution",
          "summary": "Steps: evaluate class declaration to create LoxClass, call it to create LoxInstance and run initializer; property lookups check instance fields then class methods; super calls walk the inheritance chain."
        },
        {
          "id": "inheritance-adr-super",
          "title": "ADR: Storing a Dedicated 'super' Environment",
          "summary": "Decision to store a reference to the superclass directly in the environment chain used for method execution to efficiently resolve 'super' calls."
        },
        {
          "id": "classes-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Forgetting to bind 'this' in methods, improper initialization order (fields vs. init), incorrect method resolution order (instance \u2192 class \u2192 superclass), and cycles in inheritance."
        },
        {
          "id": "classes-implementation",
          "title": "Implementation Guidance",
          "summary": "Skeleton code for LoxClass and LoxInstance, and TODOs for visitClassStmt, visitGetExpr, visitSetExpr, and visitSuperExpr in the interpreter."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "6. Interactions and Data Flow",
      "summary": "Traces the complete journey of a Lox program from source text to executed output, illustrating how components hand off data.",
      "subsections": [
        {
          "id": "interactions-sequence",
          "title": "End-to-End Sequence for a Sample Program",
          "summary": "Walks through the step-by-step flow for a program like 'var x = 1 + 2; print x;', showing tokenization, parsing, and evaluation."
        },
        {
          "id": "interactions-message-formats",
          "title": "Internal Data Handoffs",
          "summary": "Details the data structures passed between components: String \u2192 List<Token> \u2192 List<Stmt> \u2192 side effects/printed output."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "7. Error Handling and Edge Cases",
      "summary": "Defines the strategies for reporting and recovering from lexical, syntactic, and runtime errors at different phases.",
      "subsections": [
        {
          "id": "error-types",
          "title": "Error Classification and Reporting",
          "summary": "Categorizes errors (ScanError, ParseError, RuntimeError) and specifies how to report them with line numbers and helpful messages."
        },
        {
          "id": "error-recovery",
          "title": "Error Recovery Strategies",
          "summary": "Describes panic-mode recovery for the parser (synchronizing to next statement) and the interpreter's strategy of halting on runtime errors."
        },
        {
          "id": "edge-cases",
          "title": "Specific Edge Cases and Semantics",
          "summary": "Clarifies behavior for division by zero, string + non-string concatenation, truthiness rules, accessing undefined fields, and calling non-functions."
        }
      ]
    },
    {
      "id": "testing",
      "title": "8. Testing Strategy",
      "summary": "Provides a methodology for verifying the correctness of each component and the system as a whole, aligned with the project milestones.",
      "subsections": [
        {
          "id": "testing-unit",
          "title": "Unit and Integration Testing",
          "summary": "Recommends writing tests for the Scanner, Parser, and Interpreter in isolation, then testing the integrated pipeline."
        },
        {
          "id": "testing-milestone-checkpoints",
          "title": "Milestone Checkpoints (Verification Guide)",
          "summary": "For each milestone, lists a concrete test command and expected output the learner can use to verify their implementation is on track."
        }
      ]
    },
    {
      "id": "debugging",
      "title": "9. Debugging Guide",
      "summary": "A practical troubleshooting reference listing common symptoms, their likely causes, and steps to diagnose and fix them.",
      "subsections": [
        {
          "id": "debugging-table",
          "title": "Symptom \u2192 Cause \u2192 Fix Table",
          "summary": "Structured table addressing issues like 'Parser goes into infinite loop', 'Variable not found in closure', or 'Method call returns nil'."
        },
        {
          "id": "debugging-techniques",
          "title": "Effective Debugging Techniques",
          "summary": "Suggests adding AST printers, environment dumpers, and step-by-step evaluation logs to trace execution flow."
        }
      ]
    },
    {
      "id": "extensions",
      "title": "10. Future Extensions",
      "summary": "Outlines potential enhancements to the interpreter that the current architecture could accommodate, for further learning.",
      "subsections": [
        {
          "id": "extensions-features",
          "title": "Possible Feature Additions",
          "summary": "Suggests adding a REPL, a standard library, native functions, more control flow (break/continue), or even compiling to bytecode."
        },
        {
          "id": "extensions-optimizations",
          "title": "Performance Optimizations",
          "summary": "Discusses potential optimizations like constant folding, environment flattening, or method caching, without changing the core design."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "11. Glossary",
      "summary": "Definitions of key technical terms, acronyms, and domain-specific vocabulary used throughout this document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "diagram-system",
      "title": "High-Level System Component Diagram",
      "description": "Shows the three main pipeline components (Scanner, Parser, Interpreter) and their data flow: Source Code \u2192 Tokens \u2192 AST \u2192 Output. Includes the Environment as a persistent component attached to the Interpreter, and arrows indicating the direction of data transformation.",
      "type": "component",
      "relevant_sections": [
        "high-level-arch"
      ]
    },
    {
      "id": "diagram-ast-hierarchy",
      "title": "AST Node Class Hierarchy",
      "description": "A class diagram showing the abstract Expr and Stmt base classes at the top, with concrete subclasses branching below (e.g., Binary, Unary, Literal under Expr; Print, Var, Block under Stmt). Shows the key fields for each concrete class (e.g., Binary has left, operator, right).",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "component-parser"
      ]
    },
    {
      "id": "diagram-environment-chain",
      "title": "Environment Chain for Closures",
      "description": "Shows a sequence of nested Environment objects (boxes) linked in a chain. Illustrates a global environment, a function definition environment, and a function call environment. Arrows show the 'enclosing' parent links. Highlights how a closure's 'defining environment' is captured and used as the parent for its call environments.",
      "type": "component",
      "relevant_sections": [
        "component-functions-closures"
      ]
    },
    {
      "id": "diagram-class-inheritance",
      "title": "Class and Instance Relationships",
      "description": "Shows LoxClass objects linked via a 'superclass' pointer. LoxInstance objects point to their class. A method call flow is shown: Instance \u2192 Class.methods \u2192 Superclass.methods. Includes a separate box for the 'this' binding within a method's environment.",
      "type": "class",
      "relevant_sections": [
        "component-classes-inheritance"
      ]
    },
    {
      "id": "diagram-parser-precedence",
      "title": "Parser Expression Precedence Flowchart",
      "description": "A flowchart illustrating the cascade of recursive calls in the expression parser. Starts with 'expression()', which calls 'equality()', which calls 'comparison()', and so on down to 'primary()'. Arrows show the flow of control and how higher-precedence operators are parsed deeper in the call stack.",
      "type": "flowchart",
      "relevant_sections": [
        "component-parser"
      ]
    },
    {
      "id": "diagram-function-call-sequence",
      "title": "Sequence Diagram: Function Call and Return",
      "description": "A sequence diagram showing interactions between the Interpreter, a LoxFunction, and Environments during a call: 1. Interpreter calls function.call(). 2. LoxFunction creates new Environment. 3. Body statements are executed in that environment. 4. A Return exception is thrown and caught, returning the value to the caller.",
      "type": "sequence",
      "relevant_sections": [
        "component-functions-closures",
        "interactions-data-flow"
      ]
    }
  ]
}