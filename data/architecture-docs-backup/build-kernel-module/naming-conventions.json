{
  "types": {
    "struct file_operations": "fields: owner module*, open function, release function, read function, write function, unlocked_ioctl function, poll function",
    "struct mydevice_data": "fields: dev_num dev_t, cdev struct cdev, dev_class struct class*, device struct device*, buffer char*, buffer_size size_t, data_size size_t, lock struct mutex, wait_queue_head_t waitq, is_shutting_down bool",
    "struct proc_ops": "fields: proc_open function, proc_read function, proc_write function, proc_lseek function, proc_release function",
    "struct mutex": "fields: (opaque kernel structure)",
    "wait_queue_head_t": "fields: (opaque kernel structure)",
    "struct pollfd": "fields: fd int, events short, revents short",
    "struct mydevice_instance": "fields: struct list_head list, struct mydevice_data data, int instance_id",
    "struct mydevice_global": "fields: struct list_head instances, struct mutex instances_lock, int next_instance_id",
    "struct circular_buffer": "fields: char* data, size_t size, size_t read_pos, size_t write_pos, unsigned long overwrite_count, struct mutex lock"
  },
  "methods": {
    "module_init(init_function)": "macro to declare module initialization function",
    "module_exit(cleanup_function)": "macro to declare module cleanup function",
    "printk(fmt, ...)": "kernel printf equivalent with log levels",
    "copy_to_user(to, from, n)": "copy n bytes from kernel-space to userspace, returns bytes NOT copied",
    "copy_from_user(to, from, n)": "copy n bytes from userspace to kernel-space, returns bytes NOT copied",
    "alloc_chrdev_region(dev, baseminor, count, name)": "allocate range of char device numbers",
    "class_create(owner, name)": "create device class in sysfs",
    "device_create(class, parent, devt, drvdata, fmt, ...)": "create device node in /dev",
    "mutex_lock(lock)": "acquire mutex, may sleep",
    "mutex_unlock(lock)": "release mutex",
    "wait_event_interruptible(wq, condition)": "sleep until condition is true, interruptible by signals",
    "wake_up_interruptible(wq)": "wake processes sleeping on wait queue",
    "buffer_resize(dev, new_size)": "resize internal buffer, returns 0 on success",
    "buffer_init(dev, initial_size)": "initialize buffer with default size",
    "buffer_cleanup(dev)": "free buffer memory",
    "mydevice_init()": "module initialization function",
    "mydevice_exit()": "module cleanup function",
    "mydevice_open(inode, filp)": "handle device open operation",
    "mydevice_release(inode, filp)": "handle device release operation",
    "mydevice_read(filp, buf, count, f_pos)": "read data from device to userspace",
    "mydevice_write(filp, buf, count, f_pos)": "write data from userspace to device",
    "mydevice_poll(filp, wait)": "support poll/select on device",
    "mydevice_ioctl(filp, cmd, arg)": "handle ioctl commands",
    "mydevice_proc_show(m, v)": "display device statistics in /proc entry",
    "mydevice_proc_open(inode, file)": "open /proc entry",
    "buffer_init(dev, initial_size) returns int": "allocate and initialize linear buffer",
    "buffer_cleanup(dev) returns void": "free buffer memory",
    "buffer_resize(dev, new_size) returns int": "resize internal buffer with data preservation",
    "mydevice_init() returns int": "module initialization function with rollback on error",
    "mydevice_exit() returns void": "module cleanup function with shutdown coordination",
    "mydevice_open(inode, filp) returns int": "handle device open operation",
    "mydevice_release(inode, filp) returns int": "handle device close operation",
    "mydevice_write(filp, buf, count, f_pos) returns ssize_t": "write data from userspace to device with error handling",
    "mydevice_read(filp, buf, count, f_pos) returns ssize_t": "read data from device to userspace with error handling",
    "mydevice_poll(filp, wait) returns __poll_t": "support poll/select on device",
    "mydevice_ioctl(filp, cmd, arg) returns long": "handle ioctl commands with validation",
    "mydevice_proc_show(m, v) returns int": "display device statistics in /proc entry",
    "mydevice_proc_open(inode, file) returns int": "open /proc entry",
    "mutex_lock(lock) returns void": "acquire mutex, may sleep",
    "mutex_unlock(lock) returns void": "release mutex",
    "mutex_init(lock) returns void": "initialize mutex",
    "init_waitqueue_head(wq) returns void": "initialize wait queue",
    "wait_event_interruptible(wq, condition) returns int": "sleep until condition true, interruptible by signals",
    "wake_up_interruptible(wq) returns void": "wake processes sleeping on wait queue",
    "poll_wait(file, wait_address, poll_table) returns void": "register wait queue for poll notifications",
    "copy_to_user(to, from, n) returns unsigned long": "copy n bytes from kernel-space to userspace, returns bytes NOT copied",
    "copy_from_user(to, from, n) returns unsigned long": "copy n bytes from userspace to kernel-space, returns bytes NOT copied",
    "poll_wait(file, wait_address, poll_table)": "register wait queue for poll notifications",
    "dmesg": "command to view kernel log buffer",
    "insmod": "command to insert/load kernel module",
    "rmmod": "command to remove/unload kernel module",
    "modinfo": "command to show module information",
    "strace": "userspace system call tracer",
    "addr2line": "tool to convert addresses to source code lines",
    "circular_buffer_init(cb, size) returns int": "initialize circular buffer",
    "circular_buffer_cleanup(cb) returns void": "clean up circular buffer",
    "circular_buffer_data_available(cb) returns size_t": "get readable bytes in buffer",
    "circular_buffer_free_space(cb) returns size_t": "get writable space in buffer",
    "circular_buffer_write(cb, user_buf, count) returns size_t": "write data to circular buffer",
    "circular_buffer_read(cb, user_buf, count) returns size_t": "read data from circular buffer",
    "circular_buffer_clear(cb) returns void": "clear all data in buffer",
    "circular_buffer_resize(cb, new_size) returns int": "resize circular buffer preserving data",
    "mydevice_mmap(filp, vma) returns int": "handle mmap system call for device memory",
    "mutex_init(lock)": "initialize mutex",
    "init_waitqueue_head(wq)": "initialize wait queue",
    "circular_buffer_init(cb, size)": "initialize circular buffer",
    "circular_buffer_cleanup(cb)": "clean up circular buffer",
    "circular_buffer_data_available(cb)": "get readable bytes in buffer",
    "circular_buffer_free_space(cb)": "get writable space in buffer",
    "circular_buffer_write(cb, user_buf, count)": "write data to circular buffer",
    "circular_buffer_read(cb, user_buf, count)": "read data from circular buffer",
    "circular_buffer_clear(cb)": "clear all data in buffer",
    "circular_buffer_resize(cb, new_size)": "resize circular buffer preserving data",
    "mydevice_mmap(filp, vma)": "handle mmap system call for device memory",
    "cdev_init(cdev, fops)": "initialize a cdev structure with file_operations",
    "cdev_add(cdev, dev, count)": "add a character device to the system",
    "proc_create(name, mode, parent, proc_ops)": "create a /proc filesystem entry",
    "single_open(file, show, data)": "helper for creating simple single-page /proc entries",
    "virt_to_phys(address)": "convert kernel virtual address to physical address",
    "remap_pfn_range(vma, addr, pfn, size, prot)": "map physical pages to userspace"
  },
  "constants": {
    "MODULE_LICENSE": "macro to declare module license",
    "MODULE_AUTHOR": "macro to declare module author",
    "MODULE_DESCRIPTION": "macro to declare module description",
    "KERN_INFO": "printk log level for informational messages",
    "KERN_ERR": "printk log level for error messages",
    "_IOR(type, nr, size)": "macro to define ioctl read command",
    "_IOW(type, nr, size)": "macro to define ioctl write command",
    "_IOWR(type, nr, size)": "macro to define ioctl read/write command",
    "MODULE_VERSION": "macro to declare module version",
    "_IO(type, nr)": "macro to define ioctl command with no argument",
    "MYDEVICE_IOC_MAGIC": "'k' (magic number for ioctl)",
    "MYDEVICE_IOCTL_RESIZE": "_IOW(MYDEVICE_IOC_MAGIC, 4, size_t) command for buffer resize",
    "MYDEVICE_IOCTL_CLEAR": "_IO(MYDEVICE_IOC_MAGIC, 3) command for buffer clear",
    "MYDEVICE_IOCTL_GET_SIZE": "_IOR(MYDEVICE_IOC_MAGIC, 1, size_t) command for buffer size query",
    "MYDEVICE_IOCTL_GET_MAX_CAPACITY": "_IOR(MYDEVICE_IOC_MAGIC, 2, size_t)",
    "MAX_BUFFER_SIZE": "1024*1024 (1 MiB maximum buffer size)",
    "DEVICE_NAME": "'mychardev' device name string",
    "GFP_KERNEL": "flag for normal kernel memory allocation",
    "BUFFER_SIZE": "1024 initial buffer capacity",
    "POLLIN": "mask bit for readable",
    "POLLOUT": "mask bit for writable",
    "POLLRDNORM": "normal data readable",
    "POLLWRNORM": "normal data writable",
    "ERESTARTSYS": "512 (error code indicating system call should be restarted)",
    "ENOSPC": "28 (error code for no space left)",
    "EFAULT": "14 (error code for bad address)",
    "ENOMEM": "12 (error code for out of memory)",
    "EINVAL": "22 (error code for invalid argument)",
    "EAGAIN": "11 (error code for try again)",
    "ENOTTY": "25 (error code for inappropriate ioctl for device)",
    "O_NONBLOCK": "file flag for non-blocking I/O",
    "POLLERR": "mask bit for error condition",
    "POLLHUP": "mask bit for hang up",
    "KERN_DEBUG": "printk log level for debug messages",
    "DEBUG": "preprocessor macro to enable debug prints",
    "MYDEVICE_IOCTL_GET_OVERWRITES": "_IOR(MYDEVICE_IOC_MAGIC, 5, unsigned long)",
    "MYDEVICE_IOCTL_SET_CIRCULAR_MODE": "_IOW(MYDEVICE_IOC_MAGIC, 6, int)",
    "MYDEVICE_IOCTL_GET_AVAILABLE_SPACE": "_IOR(MYDEVICE_IOC_MAGIC, 7, size_t)",
    "MYDEVICE_IOCTL_CREATE_INSTANCE": "new ioctl for instance creation",
    "MYDEVICE_IOCTL_DESTROY_INSTANCE": "new ioctl for instance destruction",
    "MYDEVICE_IOCTL_SET_LOCKING_MODE": "new ioctl for selecting lock type"
  },
  "terms": {
    "VFS": "Virtual File System - abstraction layer for file operations",
    "ProcFS": "/proc filesystem for process and system information",
    "SysFS": "/sys filesystem for exposing device attributes and configuration",
    "ioctl": "I/O control - device-specific command interface",
    "major number": "device type identifier in /dev",
    "minor number": "device instance identifier in /dev",
    "wait queue": "kernel mechanism for putting processes to sleep and waking them",
    "mutex": "mutual exclusion lock for sleeping contexts",
    "spinlock": "busy-wait lock for non-sleeping contexts",
    "kbuild": "Linux kernel build system",
    "dmesg": "command to view kernel log buffer",
    "insmod": "command to insert/load kernel module",
    "rmmod": "command to remove/unload kernel module",
    "modinfo": "command to show module information",
    "kernel taint": "state indicating non-GPL or problematic module loaded",
    "out-of-tree module": "kernel module built outside the kernel source tree",
    "singleton pattern": "design pattern where only one instance of a structure exists",
    "errno": "error numbers defined in Linux, negative values in kernel space",
    "magic number": "unique identifier for ioctl commands to prevent collisions",
    "linear buffer": "contiguous memory block with data stored sequentially from start",
    "state machine": "system with defined states and transitions between them",
    "kernel module": "loadable piece of code that extends the Linux kernel",
    "printk": "kernel printf equivalent with log levels",
    "character device": "byte-stream oriented device accessed via file operations",
    "alloc_chrdev_region": "function to dynamically allocate a range of char device numbers",
    "class_create": "function to create device class in sysfs",
    "device_create": "function to create device node in /dev",
    "cdev_init": "initialize a cdev structure with file_operations",
    "cdev_add": "add a character device to the system",
    "resource leak": "failure to release allocated kernel resources",
    "file_operations": "structure mapping system calls to driver handler functions",
    "copy_from_user": "kernel function to safely copy data from user-space to kernel-space",
    "copy_to_user": "kernel function to safely copy data from kernel-space to user-space",
    "dev_t": "kernel type combining major and minor device numbers",
    "cdev": "kernel structure representing a character device",
    "class": "sysfs concept grouping devices with similar characteristics",
    "device node": "file in /dev providing access to a device",
    "partial transfer": "read/write operation that completes with fewer bytes than requested",
    "seq_file": "kernel interface for generating multi-page /proc files",
    "single_open": "helper for creating simple single-page /proc entries",
    "proc_ops": "structure for /proc file operations",
    "spurious wakeup": "when a process is awakened from a wait queue even though its condition isn't true",
    "priority inversion": "scheduling problem where high-priority task waits for low-priority task",
    "memory barrier": "CPU instruction enforcing ordering of memory operations",
    "critical section": "code segment that accesses shared resources and must be executed atomically",
    "TOCTOU": "Time-Of-Check-Time-Of-Use race condition",
    "error propagation": "passing error codes from kernel to user-space through return values",
    "rollback": "undoing partial initialization when an error occurs",
    "shutdown coordination": "ensuring all operations complete before module removal",
    "signal interruption": "when a system call is interrupted by delivery of a signal",
    "blocking I/O": "I/O operations that wait for data/space to become available",
    "SMP": "Symmetric Multi-Processing - multi-core system where race conditions are more likely",
    "Oops": "kernel error that allows continued operation with possible corruption",
    "panic": "fatal kernel error that halts the system",
    "call trace": "stack trace showing function call sequence at time of kernel error",
    "flight data recorder": "analogy for kernel's printk and dmesg logging system",
    "race condition": "bug where output depends on sequence/timing of uncontrollable events",
    "reference count": "counter tracking how many entities are using a kernel object",
    "circular buffer": "buffer where data wraps around to beginning when end is reached",
    "mmap": "memory mapping that allows direct access to kernel memory from userspace",
    "Device Tree": "hardware description data structure used by modern Linux kernels",
    "read-write lock": "synchronization primitive allowing multiple readers or single writer",
    "asynchronous I/O": "I/O operations that complete without blocking the calling thread",
    "platform driver": "kernel driver model for devices discovered via platform bus",
    "page frame number": "physical page number used for memory mapping",
    "virt_to_phys": "kernel function converting virtual address to physical address",
    "remap_pfn_range": "kernel function mapping physical pages to userspace",
    "of_match_table": "Device Tree compatible string matching table",
    "probe function": "driver function called when Device Tree node is matched",
    "work queue": "kernel mechanism for deferring work to kernel threads",
    "kiocb": "kernel I/O control block for asynchronous I/O operations",
    "epoll": "Linux I/O event notification facility",
    "O_NONBLOCK": "file flag enabling non-blocking I/O operations"
  }
}