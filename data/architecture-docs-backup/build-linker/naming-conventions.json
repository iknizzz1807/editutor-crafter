{
  "types": {
    "Elf64_Ehdr": "fields: e_ident unsigned char[16], e_type uint16_t, e_machine uint16_t, e_version uint32_t, e_entry uint64_t, e_phoff uint64_t, e_shoff uint64_t, e_flags uint32_t, e_ehsize uint16_t, e_phentsize uint16_t, e_phnum uint16_t, e_shentsize uint16_t, e_shnum uint16_t, e_shstrndx uint16_t",
    "Elf64_Shdr": "fields: sh_name uint32_t, sh_type uint32_t, sh_flags uint64_t, sh_addr uint64_t, sh_offset uint64_t, sh_size uint64_t, sh_link uint32_t, sh_info uint32_t, sh_addralign uint64_t, sh_entsize uint64_t",
    "Elf64_Sym": "fields: st_name uint32_t, st_info unsigned char, st_other unsigned char, st_shndx uint16_t, st_value uint64_t, st_size uint64_t",
    "Elf64_Rela": "fields: r_offset uint64_t, r_info uint64_t, r_addend int64_t",
    "ObjectFile": "fields: filename char*, header Elf64_Ehdr, sections ElfSection*, num_sections uint16_t, symbols ElfSymbol*, num_symbols uint32_t, relocations ElfRelocation*, num_relocations uint32_t, shstrtab char*, strtab char*",
    "MergedSections": "fields: sections OutputSection*, num_sections uint32_t, mappings InputSectionMapping*, num_mappings uint32_t",
    "SymbolTable": "opaque structure containing global symbol hash table",
    "OutputExecutable": "fields: header Elf64_Ehdr, phdrs Elf64_Phdr*, num_phdrs uint16_t, segment_data uint8_t**, segment_sizes size_t*, entry_point uint64_t, text_segment_vaddr uint64_t, data_segment_vaddr uint64_t",
    "ElfSection": "fields: header Elf64_Shdr, name char*, data uint8_t*, data_size size_t",
    "ElfSymbol": "fields: sym Elf64_Sym, name char*, section ElfSection*",
    "ElfRelocation": "fields: rela Elf64_Rela, symbol ElfSymbol*, target_section ElfSection*",
    "OutputSection": "fields: name char*, sh_type uint64_t, sh_flags uint64_t, sh_addralign uint64_t, file_offset uint64_t, virtual_addr uint64_t, size uint64_t, data uint8_t*",
    "InputSectionMapping": "fields: file_index uint32_t, section_index uint32_t, output_offset uint64_t",
    "SymbolEntry": "fields: name char*, value uint64_t, size uint64_t, binding uint8_t, type uint8_t, defined bool, is_common bool, output_section OutputSection*, offset_in_section uint64_t, src_file ObjectFile*, src_symbol_idx uint32_t",
    "InputSectionRef": "fields: file_idx uint32_t, sect_idx uint32_t, next InputSectionRef*",
    "OutputSectionGroup": "fields: name char*, sh_type uint64_t, sh_flags uint64_t, sh_addralign uint64_t, first_input InputSectionRef*, last_input InputSectionRef*, input_count uint32_t",
    "MergerState": "fields: groups OutputSectionGroup*, groups_capacity uint32_t, groups_count uint32_t, total_input_sections uint32_t",
    "SymbolState": "fields: entry SymbolEntry, strength SymbolStrength, file_index uint32_t, sym_index uint32_t",
    "HashTable": "opaque structure for hash table implementation",
    "HashEntry": "fields: key char*, value void*, occupied bool, deleted bool",
    "HashTableIterator": "opaque iterator structure",
    "LinkContext": "fields: ObjectFile** objects, uint32_t object_count, MergedSections* merged, SymbolTable* symbols, OutputExecutable* executable",
    "ErrorCategory": "enum: ERROR_NONE, ERROR_INPUT_VALIDATION, ERROR_SYMBOL_RESOLUTION, ERROR_RELOCATION, ERROR_LAYOUT, ERROR_RESOURCE, ERROR_INTERNAL",
    "RelocationHandler": "fields: type uint32_t, name const char*, handler RelocHandlerFunc, width_bits uint8_t, is_pc_relative bool, is_signed bool, check_overflow bool",
    "ArchitectureInfo": "fields: machine uint16_t, word_size uint8_t, endianness uint8_t, reloc_handlers RelocationHandler*, num_handlers uint32_t",
    "RelocationContext": "fields: arch const ArchitectureInfo*, reloc_type uint32_t, handler const RelocationHandler*",
    "ArchiveFile": "fields: filename char*, file_handle FILE*, members ArchiveMember*, num_members uint32_t, symbol_index ArchiveSymbol*, num_symbols uint32_t",
    "ArchiveMember": "fields: header ArchiveMemberHeader, name char*, offset uint64_t, size uint64_t, object ObjectFile*",
    "ArchiveSymbol": "fields: name char*, member_index uint32_t, offset_in_member uint64_t",
    "DebugSectionInfo": "fields: name char*, requires_processing bool, is_string_table bool, merge_strategy DebugMergeStrategy",
    "DebugLinkState": "fields: debug_sections OutputSectionGroup*, num_debug_sections uint32_t, string_table_offsets HashTable*",
    "Architecture": "fields: name const char*, machine uint16_t, ops ArchitectureOps*"
  },
  "methods": {
    "read_elf_file(filename) returns ObjectFile*": "parse single ELF object file",
    "merge_all_sections(objects, count) returns MergedSections*": "merge sections from all object files",
    "resolve_all_symbols(objects, count, merged) returns SymbolTable*": "resolve symbols across all files",
    "apply_all_relocations(objects, count, merged, symbols) returns void": "apply relocations using resolved symbols",
    "generate_executable(merged, symbols) returns OutputExecutable*": "create in-memory executable representation",
    "write_executable(exec, filename) returns void": "write executable to disk as valid ELF file",
    "align_to(value, alignment) returns uint64_t": "align value to given boundary",
    "fatal_error(fmt, ...) returns void": "print error and exit",
    "read_elf_file(filename) returns": "parse single ELF object file into ObjectFile*",
    "free_object_file(obj) returns": "free memory allocated for ObjectFile",
    "merge_all_sections(objects, count) returns": "merge sections from all object files into MergedSections*",
    "resolve_all_symbols(objects, count, merged) returns": "main symbol resolution entry point, returns SymbolTable*",
    "apply_all_relocations(objects, count, merged, symbols) returns": "Main entry point for relocation processing",
    "generate_executable(merged, symbols) returns": "create executable with headers into OutputExecutable*",
    "write_executable(exec, filename) returns": "write executable to file",
    "align_to(value, alignment) returns": "align value to given boundary",
    "fatal_error(fmt, ...) returns": "print error and exit",
    "create_object_file(filename) returns ObjectFile*": "allocate and initialize ObjectFile structure",
    "free_object_file(obj) returns void": "free memory allocated for ObjectFile",
    "create_merged_sections() returns MergedSections*": "allocate empty merged sections structure",
    "free_merged_sections(merged) returns void": "free MergedSections and contained data",
    "xmalloc(size) returns void*": "safe memory allocation with error checking",
    "xcalloc(count, size) returns void*": "safe zero-initialized allocation",
    "xrealloc(ptr, size) returns void*": "safe reallocation",
    "get_section_by_name(obj, name) returns ElfSection*": "retrieve section by name (helper)",
    "get_section_by_index(obj, index) returns ElfSection*": "retrieve section by index (helper)",
    "validate_elf_header(header) returns int": "internal validation function",
    "load_string_table(file, shdr) returns char*": "load string table from section",
    "load_section(file, shdr, name) returns ElfSection*": "load single section data",
    "load_symbols(obj, file, symtab_section) returns void": "load symbol table",
    "load_relocations(obj, file, rela_section) returns void": "load relocation table",
    "free_merged_sections(MergedSections* merged) returns void": "deallocate merged sections and all contained data",
    "add_sections_from_object(MergedSections* merged, const ObjectFile* obj, uint32_t file_index) returns void": "process allocatable sections from object file into internal groups",
    "compute_merged_layout(MergedSections* merged) returns void": "finalize layout, compute offsets and addresses",
    "get_output_section_data(const MergedSections* merged, uint32_t out_sect_index, uint8_t** data, size_t* size) returns void": "retrieve concatenated data for output section",
    "find_symbol(table, name) returns": "lookup symbol in resolved table",
    "free_symbol_table(table) returns": "deallocate symbol table",
    "report_undefined(table) returns": "diagnostic to print undefined symbols",
    "hash_table_create(initial_capacity) returns": "create new hash table",
    "hash_table_destroy(table) returns": "destroy hash table",
    "hash_table_insert(table, key, value) returns": "insert key-value pair",
    "hash_table_lookup(table, key) returns": "lookup value by key",
    "hash_table_remove(table, key) returns": "remove key",
    "hash_table_iterate(table) returns": "create iterator",
    "hash_table_next(iter, key, value) returns": "advance iterator",
    "hash_table_iterator_destroy(iter) returns": "destroy iterator",
    "apply_relocation_to_section(rela, symbol_addr, section_base, patch_addr) returns": "Internal function to apply single relocation",
    "compute_absolute_relocation(symbol_addr, addend) returns": "Compute value for absolute relocation",
    "compute_pcrel_relocation(symbol_addr, section_base, rel_offset, addend) returns": "Compute value for PC-relative relocation",
    "write_value_at_address(patch_addr, value, width_bytes) returns": "Write value to memory with specified width",
    "write_le64(ptr, value) returns": "Write 64-bit value in little-endian order",
    "write_le32(ptr, value) returns": "Write 32-bit value in little-endian order",
    "read_le64(ptr) returns": "Read 64-bit value in little-endian order",
    "fits_in_int32(value) returns": "Check if value fits in signed 32-bit range",
    "free_output_executable(exec) returns void": "Deallocates OutputExecutable and all its resources",
    "section_belongs_in_text_segment(sect) returns int": "Helper to determine segment placement based on section flags",
    "link_files(input_files, file_count, output_file) returns int": "Main linking orchestration with error handling",
    "report_error(category, component, format, ...) returns void": "Format and print error message to stderr",
    "report_warning(component, format, ...) returns void": "Format and print warning to stderr",
    "fatal_error(format, ...) returns void": "Print error and terminate program",
    "has_errors() returns bool": "Check if any errors reported",
    "get_error_count() returns int": "Get total errors reported",
    "reset_error_counters() returns void": "Reset error and warning counts",
    "cleanup_all(objects, count, merged, symbols, exec) returns void": "Orchestrated cleanup of all resources",
    "resolve_symbol_conflict(existing, new_symbol, objects, file_idx) returns void": "Handle symbol definition conflicts",
    "fits_in_int32(value) returns bool": "Check if value fits in signed 32-bit range",
    "dump_elf_header(hdr) returns void": "Print ELF header for debugging",
    "dump_merged_layout(merged) returns void": "Display merged section layout and mappings",
    "dump_symbol_table(table) returns void": "Print resolved symbol table",
    "hexdump(data, size, base_addr) returns void": "Display hex and ASCII representation of binary data",
    "set_debug_level(level) returns void": "Set verbosity of debug output",
    "parse_archive_file(filename) returns ArchiveFile*": "Parse BSD archive file format",
    "extract_archive_member(archive, member_idx) returns ObjectFile*": "Extract and parse object file from archive member",
    "free_archive_file(archive) returns void": "Deallocate archive file and members",
    "find_relocation_handler(arch, reloc_type) returns const RelocationHandler*": "Look up handler for relocation type in architecture",
    "handle_R_X86_64_32(ctx, symbol_addr, addend) returns uint64_t": "Handler for 32-bit absolute relocation",
    "apply_relocation_with_handler(ctx, handler, patch_addr, symbol_addr, addend) returns void": "Apply relocation using registered handler"
  },
  "constants": {
    "EI_NIDENT": "16",
    "ELFMAG0": "0x7F",
    "ELFMAG1": "'E'",
    "ELFMAG2": "'L'",
    "ELFMAG3": "'F'",
    "ELFCLASS64": "2",
    "ELFDATA2LSB": "1",
    "EV_CURRENT": "1",
    "ET_REL": "1",
    "EM_X86_64": "62",
    "SHT_PROGBITS": "1 - section holds program data",
    "SHT_SYMTAB": "2",
    "SHT_STRTAB": "3",
    "SHT_RELA": "4",
    "SHT_NOBITS": "8 - section occupies no file space (e.g., .bss)",
    "SHF_ALLOC": "0x2 - section occupies memory during execution",
    "SHF_EXECINSTR": "0x4 - section contains executable instructions",
    "SHF_WRITE": "0x1 - section is writable",
    "STB_LOCAL": "0 - local symbol binding",
    "STB_GLOBAL": "1 - global symbol binding",
    "STB_WEAK": "2 - weak symbol binding",
    "STT_NOTYPE": "0",
    "STT_OBJECT": "1",
    "STT_FUNC": "2",
    "STT_SECTION": "3",
    "R_X86_64_64": "1 - 64-bit absolute relocation",
    "R_X86_64_PC32": "2 - 32-bit PC-relative relocation",
    "SHN_UNDEF": "0 - undefined section index",
    "SHN_ABS": "0xfff1",
    "SHN_COMMON": "0xfff2 - COMMON symbol section index",
    "SYM_NO_DEF": "no definition yet",
    "SYM_WEAK_DEF": "weak definition",
    "SYM_STRONG_DEF": "strong definition",
    "SYM_COMMON_DEF": "COMMON symbol definition",
    "SYM_UNDEFINED": "undefined symbol",
    "INT32_MIN": "-2147483648",
    "INT32_MAX": "2147483647",
    "ET_EXEC": "2 (executable file type)",
    "PT_LOAD": "1 - loadable program segment",
    "PF_X": "1 - execute permission",
    "PF_W": "2 - write permission",
    "PF_R": "4 - read permission",
    "ERROR_NONE": "0",
    "ERROR_INPUT_VALIDATION": "1 - input validation error category",
    "ERROR_SYMBOL_RESOLUTION": "2 - symbol resolution error category",
    "ERROR_RELOCATION": "3 - relocation error category",
    "ERROR_LAYOUT": "4 - layout error category",
    "ERROR_RESOURCE": "5",
    "ERROR_INTERNAL": "6",
    "EI_MAG0": "0",
    "EI_MAG1": "1",
    "EI_MAG2": "2",
    "EI_MAG3": "3",
    "UINT64_MAX": "maximum 64-bit unsigned value",
    "DEBUG_LEVEL_NONE": "0",
    "DEBUG_LEVEL_ERROR": "1",
    "DEBUG_LEVEL_WARNING": "2",
    "DEBUG_LEVEL_INFO": "3",
    "DEBUG_LEVEL_DEBUG": "4",
    "ENDIAN_LITTLE": "Little-endian byte order",
    "ENDIAN_BIG": "Big-endian byte order",
    "R_X86_64_32": "10 (32-bit absolute relocation)",
    "R_X86_64_32S": "11 (32-bit signed absolute relocation)",
    "R_X86_64_PLT32": "4 (PLT-relative 32-bit relocation)",
    "R_X86_64_GOTPCREL": "9 (GOT-relative 32-bit relocation)",
    "R_AARCH64_ABS64": "257 (ARM64 64-bit absolute)",
    "R_AARCH64_PREL32": "261 (ARM64 32-bit PC-relative)",
    "EM_AARCH64": "183 (ARM64 machine type)"
  },
  "terms": {
    "static linker": "program that combines object files into executable",
    "ELF": "Executable and Linkable Format",
    "relocation": "instruction to patch addresses in code",
    "symbol resolution": "process of matching symbol references to definitions",
    "section merging": "concatenating similar sections from multiple files",
    "PT_LOAD": "program header type for loadable segments",
    "strong symbol": "primary definition that overrides weak symbols",
    "weak symbol": "secondary definition overridden by strong symbols",
    "COMMON symbol": "uninitialized global with special merging rules",
    "pipeline architecture": "components arranged in sequence where output of one is input to next",
    "component": "self-contained module with specific responsibility in the linker",
    "SHT_NOBITS": "section type that occupies memory but no file space",
    "sh_addralign": "section alignment requirement field",
    "InputSectionMapping": "structure mapping input sections to output locations",
    "section": "contiguous chunk of data or code in ELF file",
    "symbol": "named reference to memory location",
    "endianness": "byte ordering of multi-byte values",
    "alignment padding": "empty bytes inserted to meet alignment requirements",
    "Symbol Resolver": "component that builds global symbol table across object files",
    "two-pass resolution": "algorithm that collects definitions first then resolves references",
    "symbol binding": "ELF attribute indicating local/global/weak visibility",
    "tentative definition": "COMMON symbol that may be merged with others",
    "PC-relative": "addressing relative to the program counter",
    "addend": "constant value added in relocation calculation",
    "truncation overflow": "when a value doesn't fit in the target field",
    "little-endian": "byte order where least significant byte comes first",
    "relocation site": "location in code/data where address needs patching",
    "program headers": "ELF structures describing how parts of the file should be loaded into memory",
    "page alignment": "requirement that addresses/offsets be multiples of the system page size (typically 4096)",
    "PT_LOAD segment": "loadable program segment that will be mapped into memory",
    "entry point": "virtual address where execution begins",
    "p_filesz": "size of segment in the file",
    "p_memsz": "size of segment in memory",
    "data flow": "movement of data structures between components during linking",
    "linking sequence": "ordered steps of the linking process from input files to executable",
    "relocation calculation": "process of computing address values for patching into code",
    "fail-fast": "immediately terminate on first error with detailed diagnostics",
    "defense-in-depth": "multiple validation layers at different abstraction levels",
    "error category": "classification of errors by origin and nature",
    "diagnostic context": "additional information included in error messages to aid debugging",
    "graceful degradation": "clean resource cleanup and informative output before termination",
    "cascading errors": "secondary errors caused by an earlier unresolved issue",
    "ownership semantics": "clear rules for which component is responsible for freeing resources",
    "validation layer": "component that checks specific constraints before processing continues",
    "error propagation": "mechanism for errors to prevent further processing in pipeline",
    "cleanup orchestration": "coordinated deallocation of all resources on error or success",
    "debugging": "process of diagnosing and fixing linker errors",
    "diagnostic": "information produced to aid debugging",
    "hexdump": "tool displaying binary data in hexadecimal and ASCII",
    "archive member extraction": "process of selectively loading object files from archive based on symbol needs",
    "relocation handler registry": "table mapping relocation types to handler functions",
    "debug section pass-through": "strategy of copying debug sections without processing internal references",
    "architecture abstraction layer": "interface that isolates architecture-specific operations from core linking logic",
    "symbol-driven pull": "archive processing approach where members are extracted only when their symbols are needed",
    "BSD archive format": "traditional Unix archive format with global header and member headers",
    "DWARF": "Debugging With Arbitrary Record Format, standard for debug information",
    "cross-architecture linking": "linking object files for different CPU architectures",
    "toolchain integration": "coordinating with compiler, assembler, and other build tools",
    "response files": "files containing command-line arguments to overcome length limits"
  }
}