{
  "types": {
    "JsonRpcMessage": "jsonrpc: '2.0', id?: string | number, method?: string, params?: any",
    "JsonRpcRequest": "extends JsonRpcMessage with method: string",
    "JsonRpcNotification": "extends JsonRpcMessage with method: string",
    "JsonRpcResponse": "extends JsonRpcMessage with id: string | number",
    "ServerCapabilities": "textDocumentSync?: number, completionProvider?: object, hoverProvider?: boolean",
    "DocumentManager": "manages document state and synchronization",
    "LanguageEngine": "analyzeDocument, findSymbolAt, findDefinition, getCompletionItems, getHoverInformation, getDiagnostics",
    "LspServer": "main protocol handler and coordinator",
    "TextDocumentItem": "uri: string, languageId: string, version: number, text: string",
    "Position": "line: number, character: number",
    "Range": "start: Position, end: Position",
    "Diagnostic": "range: Range, severity?: number, message: string",
    "CompletionItem": "label: string, kind?: number, detail?: string, documentation?: string, insertText?: string",
    "Symbol": "name: string, kind: number, range: Range, selectionRange: Range",
    "Scope": "kind string, range Range, symbols Map<string, Symbol>, parent Scope, children Scope[]",
    "MessageFramer": "buffer: string, contentLength: number",
    "MessageDispatcher": "routes messages to handlers and manages responses",
    "StreamTransport": "coordinates framing and dispatching over stdin/stdout",
    "ProtocolState": "manages server state transitions",
    "CapabilityNegotiator": "analyzes client capabilities and builds server response",
    "ClientCapabilities": "client-declared feature support",
    "ServerState": "enum of server lifecycle states",
    "InitializeResult": "response to initialize request with server capabilities",
    "DocumentSnapshot": "version: number, text: string, timestamp: number",
    "TextDocumentContentChangeEvent": "range?: Range, rangeLength?: number, text: string",
    "DidChangeTextDocumentParams": "textDocument: {uri: string, version: number}, contentChanges: TextDocumentContentChangeEvent[]",
    "ChangeListener": "callback function for document changes",
    "ASTNode": "kind: string, range: Range, parent: ASTNode, children: ASTNode[]",
    "CacheEntry": "value: T, lastAccessed: number, accessCount: number, tier: string",
    "IdentifierNode": "extends ASTNode, kind Identifier, name string",
    "FunctionDeclarationNode": "extends ASTNode, kind FunctionDeclaration, name IdentifierNode, parameters ParameterNode[], body BlockStatementNode",
    "VariableDeclarationNode": "extends ASTNode, kind VariableDeclaration, declarations VariableDeclaratorNode[]",
    "CompletionContext": "triggerKind: number, triggerCharacter?: string, partialIdentifier: string, enclosingNode: ASTNode",
    "Hover": "contents: MarkupContent, range?: Range",
    "MarkupContent": "kind: 'plaintext' | 'markdown', value: string",
    "Location": "uri: string, range: Range",
    "JsonRpcError": "code: JsonRpcErrorCode, message: string, data?: any",
    "ErrorContext": "requestId?: string | number, method?: string, originalError?: Error, additionalInfo?: Record<string, any>",
    "LspError": "extends Error with code: JsonRpcErrorCode, data?: any, context?: ErrorContext",
    "ConnectionHealth": "state: ConnectionState, lastMessageTime: Date, errorCount: number, bytesSent: number, bytesReceived: number",
    "RecoveryPoint": "position: number, strategy: RecoveryStrategy, confidence: number, context: string",
    "ParseError": "position: number, expected: string[], actual: string, message: string, recoveryHints: string[]",
    "ErrorRegion": "start: number, end: number, errorType: string, recoveryAttempted: boolean, originalText: string",
    "PartialASTNode": "extends ASTNode with isComplete: boolean, errorRegions: ErrorRegion[], confidence: number, partialInfo?: Record<string, any>",
    "LspTestClient": "serverCommand: string, serverArgs: string[], process: ChildProcess, framer: MessageFramer",
    "PerformanceProfiler": "measurements: Map<string, number[]>, startTimes: Map<string, number>",
    "PerformanceReport": "operation: string, sampleCount: number, meanLatency: number, medianLatency: number",
    "ConcurrencyTestResult": "concurrency: number, successRate: number, averageLatency: number",
    "Milestone1Tests": "client: LspTestClient",
    "SymbolIndexEntry": "name string, kind SymbolKind, containerName string, location Location, score number",
    "WorkspaceSymbolIndex": "symbolsByName Map, symbolsByFile Map",
    "SemanticTokenProvider": "tokenTypes string[], tokenModifiers string[]",
    "InlayHint": "position Position, label string, kind InlayHintKind, textEdits TextEdit[], tooltip MarkupContent, paddingLeft boolean, paddingRight boolean",
    "WorkspaceEdit": "textDocument changes Map, documentChanges array, changeAnnotations Map",
    "DocumentSymbol": "name string, kind SymbolKind, range Range, selectionRange Range, children Symbol[], detail string, deprecated boolean"
  },
  "methods": {
    "handleData(chunk: string)": "processes incoming data chunks and extracts JSON-RPC messages",
    "processMessage(message: JsonRpcMessage)": "routes parsed messages to appropriate handlers",
    "onRequest(method: string, handler: Function)": "registers request handlers for specific methods",
    "sendRequest(method: string, params: any)": "sends JSON-RPC request and returns Promise",
    "sendNotification(method: string, params: any)": "sends JSON-RPC notification",
    "handleInitialize(params: any)": "processes LSP initialize request and returns capabilities",
    "setupHandlers()": "registers all JSON-RPC method handlers",
    "start()": "begins LSP server operation",
    "handleDidOpen(params: any)": "stores document on open",
    "handleDidChange(params: any)": "applies document edits",
    "handleDidClose(params: any)": "removes document from storage",
    "setDocument(document: TextDocumentItem)": "stores document with version validation",
    "getDocument(uri: string) returns TextDocumentItem?": "retrieves document by URI",
    "applyChanges(uri: string, version: number, changes: any[])": "applies incremental text changes",
    "offsetToPosition(text: string, offset: number) returns Position": "converts byte offset to LSP position",
    "positionToOffset(text: string, position: Position) returns number": "converts LSP position to byte offset",
    "findSymbolAt(position: Position) returns Symbol?": "finds symbol at cursor position",
    "buildFromAST(ast: any, sourceText: string)": "builds symbol table from parsed AST",
    "frameMessage(message: JsonRpcMessage)": "adds Content-Length header to JSON-RPC message",
    "tryExtractMessage()": "attempts to extract complete message from buffer",
    "handleInitialize(params: any) returns Promise<any>": "processes LSP initialize request and returns capabilities",
    "handleInitialized(params: any) returns void": "processes initialized notification",
    "handleShutdown(params: any) returns Promise<any>": "processes shutdown request and cleans up resources",
    "handleExit(params: any) returns void": "processes exit notification and terminates process",
    "setupHandlers() returns void": "registers all JSON-RPC method handlers",
    "start() returns Promise<void>": "begins LSP server operation",
    "canTransition(to: ServerState) returns boolean": "validates state transition legality",
    "transition(to: ServerState) returns void": "performs state transition with validation",
    "analyzeClientCapabilities(clientCapabilities: ClientCapabilities) returns object": "extracts client feature support",
    "buildServerCapabilities(clientAnalysis: object) returns ServerCapabilities": "constructs server capability response",
    "handleDidOpen(params)": "stores document on open",
    "handleDidChange(params)": "applies document edits",
    "handleDidClose(params)": "removes document from storage",
    "getDocument(uri) returns TextDocumentItem?": "retrieves document by URI",
    "applyChanges(uri, version, changes)": "applies incremental text changes",
    "positionToOffset(text, position) returns number": "converts LSP position to byte offset",
    "offsetToPosition(text, offset) returns Position": "converts byte offset to LSP position",
    "createSnapshot(uri, document)": "creates versioned document snapshot",
    "getSnapshot(uri, version)": "retrieves specific version snapshot",
    "addChangeListener(listener)": "registers change notification callback",
    "removeChangeListener(listener)": "unregisters change notification callback",
    "analyzeDocument(document: TextDocumentItem)": "parses document and builds symbol table",
    "findSymbolAt(uri: string, position: Position)": "finds symbol at cursor position",
    "findDefinition(uri: string, position: Position)": "returns declaration range for symbol",
    "getCompletionItems(uri: string, position: Position)": "returns context-aware completion items",
    "getHoverInformation(uri: string, position: Position)": "returns type and documentation info",
    "getDiagnostics(uri: string)": "returns syntax and semantic errors",
    "resolveSymbol(uri: string, identifier: IdentifierNode)": "resolves identifier to symbol declaration",
    "buildSymbolTable(uri: string, ast: ASTNode)": "builds scope tree and symbol map from AST",
    "walkAST(node: ASTNode, visitor: Function)": "traverses AST with visitor pattern",
    "findNodeAt(root: ASTNode, position: Position)": "finds AST node at position",
    "invalidateCache(uri: string)": "removes cached AST and symbols",
    "provideCompletions(uri, position)": "generates context-aware completion items",
    "getSymbolsInScope(uri, position)": "collects visible symbols at position",
    "filterByPrefix(symbols, prefix)": "applies fuzzy matching to filter symbols",
    "provideHover(uri, position)": "generates hover information for symbol",
    "formatHoverContent(typeInfo, docs)": "formats information into MarkupContent",
    "provideDefinition(uri, position)": "finds definition locations for symbol",
    "resolveImportedSymbol(uri, symbolName)": "follows import chains to find definition",
    "publishDiagnostics(uri, document)": "analyzes document and publishes diagnostics",
    "analyzeSyntax(uri, text)": "fast syntax validation",
    "analyzeSemantics(uri, ast)": "semantic validation using symbol resolution",
    "positionToOffset(text, position)": "converts LSP position to byte offset",
    "offsetToPosition(text, offset)": "converts byte offset to LSP position",
    "sendResponse()": "sends JSON-RPC response back to client",
    "handleDidChange(params: DidChangeTextDocumentParams)": "applies document edits",
    "debounce(key: string, delay: number, callback: () => void)": "schedules debounced callback execution",
    "validateDocumentAndPosition(uri: string, position: Position)": "validates document exists and position is valid",
    "ensureCurrentAnalysis(uri: string)": "triggers re-analysis if document has changed",
    "analyzeAndPublishDiagnostics(uri: string)": "performs analysis and publishes diagnostic results",
    "handleError(error: Error, context: ErrorContext)": "converts exceptions to JSON-RPC error responses",
    "classifyError(error: Error, context: ErrorContext)": "determines appropriate JSON-RPC error code",
    "shouldDegradeCapability(method: string)": "decides if capability should be temporarily disabled",
    "updateState(newState: ConnectionState, reason?: string)": "transitions connection state machine",
    "recordMessage(direction: 'sent' | 'received', byteCount: number)": "tracks successful message transmission",
    "recordError(error: Error, context: string)": "logs transport errors for state management",
    "recoverFromError(error: ParseError, tokens: Token[], currentPos: number)": "attempts parse error recovery using multiple strategies",
    "createPartialNode(kind: string, range: Range, errorInfo: ErrorRegion[])": "creates AST node marked as incomplete",
    "extractPartialSemantics(node: PartialASTNode)": "extracts semantic information from incomplete nodes",
    "sendRequest(method: string, params: any) returns Promise<any>": "sends JSON-RPC request and awaits response",
    "sendNotification(method: string, params: any) returns void": "sends JSON-RPC notification without response",
    "initialize(clientCapabilities: any) returns Promise<any>": "performs LSP initialization handshake",
    "shutdown() returns Promise<void>": "performs LSP shutdown sequence",
    "frameMessage(content: string) returns string": "adds Content-Length header to message",
    "testInitializationHandshake() returns Promise<void>": "verifies LSP initialize/initialized sequence",
    "testMessageFraming() returns Promise<void>": "validates JSON-RPC message boundary handling",
    "testShutdownSequence() returns Promise<void>": "confirms clean shutdown behavior",
    "startMeasurement(operation: string) returns void": "begins performance timing",
    "endMeasurement(operation: string) returns void": "completes performance timing",
    "getPerformanceReport(operation: string) returns PerformanceReport": "calculates latency statistics",
    "runConcurrencyTest() returns Promise<ConcurrencyTestResult>": "executes concurrent load testing",
    "handleMessage(message: any) returns void": "processes incoming JSON-RPC messages",
    "setupMessageHandling() returns void": "configures stdout message processing",
    "onNotification(method: string, handler: Function) returns void": "registers notification handler",
    "applyChanges(uri: version, changes)": "applies incremental text changes",
    "addDocument(uri, symbols)": "adds document symbols to workspace index",
    "removeDocument(uri)": "removes document from symbol index",
    "search(query, limit)": "searches symbols by name with fuzzy matching",
    "provideSemanticTokens(uri)": "generates semantic tokens for document",
    "encodeTokens(tokens)": "compresses token array using delta encoding",
    "organizeImports()": "removes unused and adds missing import statements",
    "extractMethod(range)": "extracts code block into separate function",
    "renameSymbol(position, newName)": "renames symbol and updates all references"
  },
  "constants": {
    "CONTENT_LENGTH_HEADER": "Content-Length header for message framing",
    "JSONRPC_VERSION": "2.0 - JSON-RPC protocol version",
    "INCREMENTAL_SYNC": "2 - incremental document synchronization",
    "METHOD_NOT_FOUND": "-32601 JSON-RPC error code",
    "INTERNAL_ERROR": "-32603 JSON-RPC error code",
    "FULL_SYNC": "1 - full document synchronization",
    "DIAGNOSTIC_SEVERITY": "Error/Warning/Information/Hint levels",
    "COMPLETION_ITEM_KIND": "TEXT/METHOD/FUNCTION/VARIABLE completion types",
    "PARSE_ERROR": "-32700 JSON-RPC error code",
    "INVALID_REQUEST": "-32600 JSON-RPC error code",
    "CONTENT_LENGTH_PATTERN": "regex for parsing Content-Length headers",
    "HEADER_SEPARATOR": "CRLF CRLF sequence separating headers from payload",
    "hotCapacity": "100 maximum hot cache entries",
    "warmCapacity": "500 maximum warm cache entries",
    "INVALID_PARAMS": "-32602 JSON-RPC error code",
    "SYMBOL_KIND_FUNCTION": "6 - function symbol type",
    "SYMBOL_KIND_CLASS": "5 - class symbol type",
    "SYMBOL_KIND_VARIABLE": "13 - variable symbol type",
    "TOKEN_TYPE_FUNCTION": "function semantic token type",
    "TOKEN_MODIFIER_STATIC": "static token modifier",
    "INLAY_HINT_PARAMETER": "1 - parameter name hint",
    "INLAY_HINT_TYPE": "2 - type annotation hint"
  },
  "terms": {
    "LSP": "Language Server Protocol for IDE integration",
    "JSON-RPC": "remote procedure call protocol using JSON",
    "language server": "process that provides language analysis and IDE features",
    "language client": "editor that connects to language server",
    "capability negotiation": "client-server feature agreement process",
    "document synchronization": "keeping server's document state in sync with editor",
    "Content-Length framing": "HTTP-style message boundary detection",
    "initialization handshake": "initialize request followed by initialized notification",
    "NÃ—M integration problem": "exponential growth of editor-language combinations without standardization",
    "symbol table": "data structure mapping identifiers to declarations",
    "scope": "visibility boundary for symbol declarations",
    "UTF-16 code units": "character encoding used by LSP for positions",
    "incremental synchronization": "sending only changed document ranges",
    "symbol resolution": "process of finding declaration for identifier reference",
    "message framing": "Content-Length header processing for JSON-RPC",
    "message dispatching": "routing messages to appropriate handlers based on method",
    "handler registration": "mapping method names to handler functions",
    "bidirectional communication": "both client and server can send requests to each other",
    "streaming parser": "parser that processes data incrementally as it arrives",
    "buffer management": "accumulating partial messages across multiple read operations",
    "server lifecycle": "state transitions from startup through shutdown",
    "protocol state machine": "finite state machine managing server lifecycle",
    "progressive enhancement": "features work with older clients via capability checking",
    "version tracking": "preventing race conditions with document version numbers",
    "position conversion": "transforming between line/character and byte offset coordinates",
    "snapshot isolation": "stable document versions for concurrent analysis",
    "change application": "applying range-based text edits to document content",
    "Language Engine": "core component that parses code and performs semantic analysis",
    "AST": "abstract syntax tree representing parsed code structure",
    "incremental parsing": "parsing only changed portions of code",
    "cache invalidation": "removing stale cached data",
    "semantic analysis": "type checking and error detection beyond syntax",
    "Feature Providers": "specialized components implementing specific IDE capabilities",
    "contextual filtering": "progressive narrowing from all possible to relevant completions",
    "MarkupContent": "LSP structure for rich formatted hover responses",
    "diagnostic severity": "error level classification for issues",
    "incremental analysis": "updating only changed code portions for performance",
    "scope hierarchy": "nested visibility boundaries for symbol declarations",
    "cross-file resolution": "following import chains to find definitions",
    "request-response flow": "synchronous interaction pattern for language feature requests",
    "document change flow": "asynchronous processing of document updates and analysis",
    "debouncing": "delaying analysis until changes stop arriving",
    "diagnostic publishing": "sending error and warning information to client",
    "analysis scheduling": "coordinating when to perform language analysis",
    "error recovery": "graceful handling of failures without state corruption",
    "protocol-level errors": "failures in JSON-RPC communication layer",
    "parse error recovery": "strategies for continuing analysis despite syntax errors",
    "transport layer failures": "connection and framing problems in stdin/stdout communication",
    "capability degradation": "temporarily disabling features due to repeated errors",
    "partial AST construction": "building incomplete but usable abstract syntax trees",
    "graceful feature degradation": "maintaining reduced functionality when full features fail",
    "confidence-based filtering": "prioritizing results based on parse success reliability",
    "error production rules": "grammar rules that match common syntax error patterns",
    "panic mode recovery": "skipping to synchronization points after parse failures",
    "milestone checkpoints": "verification procedures after each development phase",
    "integration testing": "testing with real LSP clients and realistic scenarios",
    "protocol compliance": "adherence to LSP specification requirements",
    "performance integration testing": "load and latency testing under realistic conditions",
    "client compatibility testing": "verification with multiple LSP client implementations",
    "end-to-end workflow testing": "testing complete developer usage scenarios",
    "concurrent request handling": "processing multiple overlapping LSP requests",
    "tail latency": "high percentile response times that affect user experience",
    "state consistency": "maintaining correct server state across operations",
    "protocol debugging": "diagnosing JSON-RPC communication issues",
    "performance debugging": "identifying and fixing responsiveness issues",
    "race conditions": "timing-dependent bugs in concurrent systems",
    "latency budgets": "target response times for different operations",
    "symbol index": "data structure for fast workspace-wide symbol search",
    "semantic highlighting": "context-aware syntax coloring using language analysis",
    "inlay hints": "inline information display without source code modification",
    "workspace edit": "atomic multi-file operation with undo support",
    "background analysis": "expensive operations moved to background threads",
    "distributed analysis": "spreading analysis work across multiple processes",
    "build system integration": "understanding project dependencies and compilation settings",
    "contextual diagnostics": "error analysis adapted to development context"
  }
}