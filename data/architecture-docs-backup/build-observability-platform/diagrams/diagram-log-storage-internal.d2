title: Log Storage Internal Architecture
classes: {
  container: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.border-radius: 5
  }
  process: {
    style.fill: "#0f3460"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
    style.border-radius: 3
  }
  data: {
    shape: cylinder
    style.fill: "#16213e"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  index: {
    style.fill: "#0a1929"
    style.stroke: "#58a6ff"
    style.font-color: "#e6edf3"
    style.bold: true
  }
}

engine: Log Storage Engine {
  class: container
  
  ingestion: Ingestion Path {
    incoming: "Incoming Log Batches" {
      class: process
      style.font-size: 16
      style.bold: true
    }
    
    wal: Write-Ahead Log (WAL) {
      shape: page
      class: data
      style.fill: "#1b3a4b"
    }
    
    mem_segment: In-Memory Segment {
      class: data
      style.fill: "#2c5f2d"
    }
    
    incoming -> wal: "append with\nbatch metadata" {
      style.stroke-dash: 0
      style.stroke: "#3fb950"
    }
    wal -> mem_segment: "replay on restart" {
      style.stroke-dash: 3
      style.stroke: "#8b949e"
    }
    incoming -> mem_segment: "write current batch" {
      style.stroke-dash: 0
      style.stroke: "#3fb950"
    }
  }
  
  compaction: Background Compaction {
    class: container
    style.fill: "#1a1a2e"
    
    compaction_process: Compaction Process {
      class: process
    }
    
    disk_segments: On-Disk Segments {
      class: data
    }
    
    mem_segment -> compaction_process: "trigger when full"
    compaction_process -> disk_segments: "write merged segments"
  }
  
  indexing: Indexing Layer {
    class: container
    style.fill: "#1a1a2e"
    
    ft_index: Full-Text Index {
      class: index
      shape: sql_table
      "- token: string"
      "- segment_id: string"
      "- positions: int[]"
    }
    
    field_index: Field Index {
      class: index
      shape: sql_table
      "- field_name: string"
      "- field_value: string"
      "- segment_id: string"
      "- record_ids: int[]"
    }
    
    mem_segment -> ft_index: "tokenize & index" {
      style.stroke-dash: 2
    }
    mem_segment -> field_index: "extract structured fields" {
      style.stroke-dash: 2
    }
    disk_segments -> ft_index
    disk_segments -> field_index
  }
  
  query: Query Path {
    query_interface: Query Interface {
      class: process
    }
    
    query_interface -> ft_index: "full-text search"
    query_interface -> field_index: "field filtering"
    query_interface -> disk_segments: "retrieve matched logs"
    
    ft_index -> disk_segments: "lookup by segment_id"
    field_index -> disk_segments: "lookup by segment_id"
  }
}

note: |md
  ## Data Flow
  1. Incoming batches go to WAL (for durability) and memory segment
  2. Memory segment triggers compaction when full
  3. Indexes are built from both memory and disk segments
  4. Queries use indexes to locate data in disk segments
| {
  shape: page
  class: container
  style.fill: "#2d3748"
  near: top-right
}