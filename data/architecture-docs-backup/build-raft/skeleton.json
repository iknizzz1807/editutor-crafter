{
  "title": "Build Your Own Raft: Consensus Algorithm Design Document",
  "overview": "This system implements the Raft consensus algorithm, enabling multiple servers to agree on a sequence of log entries despite partial failures and network delays. The key architectural challenge is maintaining safety (correctness) while maximizing availability and understandability for developers learning distributed systems fundamentals.",
  "sections": [
    {
      "id": "context-and-problem",
      "title": "1. Context and Problem Statement",
      "summary": "Explains the fundamental problem of distributed consensus, why it's difficult, and how Raft provides an understandable solution.",
      "subsections": [
        {
          "id": "analogy-mental-model",
          "title": "1.1 The Replicated State Machine Analogy",
          "summary": "Introduces consensus through the analogy of a team of accountants keeping identical ledgers, highlighting the need for a single leader to sequence operations."
        },
        {
          "id": "the-hard-parts",
          "title": "1.2 Why Consensus is Difficult: The CAP Perspective",
          "summary": "Describes the trade-offs between Consistency, Availability, and Partition tolerance, positioning Raft as a CP system for real-world applications like key-value stores and configuration managers."
        },
        {
          "id": "existing-approaches",
          "title": "1.3 Pre-Raft Landscape: Paxos and its Challenges",
          "summary": "Briefly compares Raft to Paxos, using a table to contrast their understandability, decomposition, and implementation complexity, establishing Raft's pedagogical value."
        }
      ]
    },
    {
      "id": "goals-and-non-goals",
      "title": "2. Goals and Non-Goals",
      "summary": "Defines the scope of the educational implementation, specifying what must be achieved and what is intentionally out of scope.",
      "subsections": [
        {
          "id": "goals",
          "title": "2.1 Goals (What We Must Build)",
          "summary": "Lists the core Raft protocol components: leader election, log replication, safety properties, and cluster membership changes, aligned with the project milestones."
        },
        {
          "id": "non-goals",
          "summary": "2.2 Non-Goals (What We Leave Out)",
          "title": "Clarifies that production-grade features like persistent storage, sophisticated network layers, and client libraries are out of scope for this learning-focused implementation."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "3. High-Level Architecture",
      "summary": "Presents the overall system component diagram and module structure, showing how a Raft node is composed and connected.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "3.1 Component Overview",
          "summary": "Describes the five core internal components of a Raft node (State Machine, Log Store, Consensus Module, etc.) and their responsibilities."
        },
        {
          "id": "file-structure",
          "title": "3.2 Recommended File/Module Structure",
          "summary": "Provides a suggested Go package and file layout to organize the codebase cleanly, separating core logic from infrastructure."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines all key data structures (Persistent State, Volatile State, Log Entry, RPC arguments) using tables to describe their fields and purposes.",
      "subsections": [
        {
          "id": "persistent-state",
          "title": "4.1 Persistent State",
          "summary": "Details the state that must survive crashes: currentTerm, votedFor, and the log entries. Explains why each piece is crucial for safety."
        },
        {
          "id": "volatile-state",
          "title": "4.2 Volatile State",
          "summary": "Defines the in-memory state like commitIndex and lastApplied that can be reconstructed after a restart."
        },
        {
          "id": "messages-and-rpcs",
          "title": "4.3 Messages and RPC Structures",
          "summary": "Specifies the exact fields for RequestVote and AppendEntries RPCs, including term numbers and log matching information."
        }
      ]
    },
    {
      "id": "leader-election",
      "title": "5. Component Design: Leader Election (Milestone 1)",
      "summary": "Deep dive into the leader election mechanism, including state transitions, timeout logic, and the voting protocol.",
      "subsections": [
        {
          "id": "mental-model-election",
          "title": "5.1 Mental Model: The Student Council Election",
          "summary": "Explains leader election using an analogy of a student council where candidates campaign and voters check candidate qualifications."
        },
        {
          "id": "election-adrs",
          "title": "5.2 Architecture Decision Records for Election",
          "summary": "Contains ADRs for key decisions: randomized election timeouts (vs. fixed), granting votes based on log completeness, and handling split votes."
        },
        {
          "id": "common-pitfalls-election",
          "title": "5.3 Common Pitfalls in Leader Election",
          "summary": "Lists typical mistakes like forgetting to reset the election timer, incorrect term comparison, and mishandling the votedFor field."
        },
        {
          "id": "impl-guidance-election",
          "title": "5.4 Implementation Guidance for Milestone 1",
          "summary": "Provides starter code for timer infrastructure and skeleton code with TODOs for the Raft node's main loop, candidate transition, and RequestVote RPC handler."
        }
      ]
    },
    {
      "id": "log-replication",
      "title": "6. Component Design: Log Replication (Milestone 2)",
      "summary": "Details how the leader replicates commands to followers, ensures log consistency, and determines when entries are committed.",
      "subsections": [
        {
          "id": "mental-model-replication",
          "title": "6.1 Mental Model: The Assembly Line with Quality Control",
          "summary": "Compares log replication to an assembly line where the leader issues orders, followers verify previous steps match, and a quorum sign-off commits the work."
        },
        {
          "id": "replication-adrs",
          "title": "6.2 Architecture Decision Records for Replication",
          "summary": "Contains ADRs for the design of AppendEntries RPC (heartbeat and replication), the log matching property, and the commit index advancement rule."
        },
        {
          "id": "common-pitfalls-replication",
          "title": "6.3 Common Pitfalls in Log Replication",
          "summary": "Highlights issues like off-by-one errors in log indices, incorrectly applying entries before they are committed, and not handling log inconsistencies during recovery."
        },
        {
          "id": "impl-guidance-replication",
          "title": "6.4 Implementation Guidance for Milestone 2",
          "summary": "Provides starter code for a basic log storage interface and skeleton code with TODOs for the leader's replication loop and the AppendEntries RPC handler logic."
        }
      ]
    },
    {
      "id": "safety-properties",
      "title": "7. Component Design: Safety Properties (Milestone 3)",
      "summary": "Explains the formal guarantees Raft provides (Election Safety, Leader Completeness, State Machine Safety) and how the protocol ensures them.",
      "subsections": [
        {
          "id": "mental-model-safety",
          "title": "7.1 Mental Model: The Chain of Custody for Legal Evidence",
          "summary": "Analogizes safety to maintaining a tamper-proof chain of custody for evidence, where every transfer is logged and verified to prevent alteration or loss."
        },
        {
          "id": "safety-adrs",
          "title": "7.2 Architecture Decision Records for Safety",
          "summary": "Contains an ADR for the key safety rule: a leader only commits entries from its own term (or, the Raft paper's Section 5.4.2 rule to avoid the 'Figure 8' problem)."
        },
        {
          "id": "common-pitfalls-safety",
          "title": "7.3 Common Pitfalls in Safety Properties",
          "summary": "Focuses on the 'Figure 8' scenario, incorrectly committing entries from old terms, and violating the State Machine Safety property by applying entries out of order."
        },
        {
          "id": "impl-guidance-safety",
          "title": "7.4 Implementation Guidance for Milestone 3",
          "summary": "Provides skeleton code with TODOs for the critical commit index advancement logic that enforces the safety rule, and the state machine applier routine."
        }
      ]
    },
    {
      "id": "cluster-membership",
      "title": "8. Component Design: Cluster Membership Changes (Milestone 4)",
      "summary": "Describes the joint consensus protocol for safely adding or removing servers from the cluster without compromising availability.",
      "subsections": [
        {
          "id": "mental-model-membership",
          "title": "8.1 Mental Model: Changing the Locks on a Bank Vault",
          "summary": "Compares membership changes to changing the locks on a bank vault, requiring coordination so that neither the old nor new key set alone can open the vault during the transition."
        },
        {
          "id": "membership-adrs",
          "title": "8.2 Architecture Decision Records for Membership",
          "summary": "Contains an ADR for choosing the Joint Consensus approach over a simpler single-server changes, weighing safety against implementation complexity."
        },
        {
          "id": "common-pitfalls-membership",
          "title": "8.3 Common Pitfalls in Membership Changes",
          "summary": "Discusses risks like creating disjoint majorities (two leaders), getting stuck in an intermediate configuration, and not properly isolating removed nodes."
        },
        {
          "id": "impl-guidance-membership",
          "title": "8.4 Implementation Guidance for Milestone 4",
          "summary": "Provides starter code for a configuration structure and skeleton code with TODOs for handling configuration log entries and the joint consensus majority calculation."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "9. Interactions and Data Flow",
      "summary": "Illustrates the end-to-end flow of a client command through the system, from proposal to commitment and application.",
      "subsections": [
        {
          "id": "sequence-normal-case",
          "title": "9.1 Sequence Diagram: Normal Case Operation",
          "summary": "Shows the step-by-step interaction between Client, Leader, and Followers for a successful command replication and commit."
        },
        {
          "id": "message-formats",
          "title": "9.2 Detailed Message Formats",
          "summary": "Provides expanded tables for RPC request/response structures, including all fields and their precise semantics."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "10. Error Handling and Edge Cases",
      "summary": "Covers failure detection, recovery strategies, and handling of network partitions, message loss, and server crashes.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "10.1 Failure Modes and Detection",
          "summary": "Catalogues types of failures (crash-stop, network partition, Byzantine) and explains which ones Raft is designed to tolerate via timeouts and RPC retries."
        },
        {
          "id": "recovery-strategies",
          "title": "10.2 Recovery and State Reconciliation",
          "summary": "Describes how a restarted or partitioned node catches up using the AppendEntries consistency check and term comparison."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "11. Testing Strategy",
      "summary": "Outlines how to verify correctness, including property-based tests, scenario tests, and milestone-by-milestone verification checkpoints.",
      "subsections": [
        {
          "id": "milestone-checkpoints",
          "title": "11.1 Milestone Verification Checkpoints",
          "summary": "For each milestone, provides a concrete test scenario, expected log output, and commands to run to verify the implementation is working correctly."
        },
        {
          "id": "property-testing",
          "title": "11.2 Property-Based Testing Approach",
          "summary": "Suggests safety and liveness invariants to test (e.g., 'no two leaders in same term') and how to structure randomized network failure tests."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "12. Debugging Guide",
      "summary": "Provides a symptom-cause-fix table for common bugs, along with techniques for adding diagnostic logging and inspecting node state.",
      "subsections": [
        {
          "id": "symptom-table",
          "title": "12.1 Common Bug Symptoms and Fixes",
          "summary": "Structured table listing symptoms (e.g., 'Elections never complete', 'Log entries are lost'), likely causes, and step-by-step fixes."
        },
        {
          "id": "debug-techniques",
          "title": "12.2 Debugging Techniques for Raft",
          "summary": "Recommends adding structured logs for state transitions and RPCs, and building a simple state inspector tool to visualize node status."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "13. Future Extensions",
      "summary": "Discusses potential enhancements like log compaction (snapshotting), leader lease reads for linearizability, and integration with a real key-value store.",
      "subsections": [
        {
          "id": "extensions-list",
          "title": "13.1 Possible Extension Projects",
          "summary": "Lists and briefly describes advanced features that build upon the completed Raft core, suggesting them as next learning steps."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "14. Glossary",
      "summary": "Definitions of all key technical terms, acronyms, and domain-specific vocabulary used in the document.",
      "subsections": [
        {
          "id": "terms",
          "title": "14.1 Term Definitions",
          "summary": "Alphabetical list of terms (e.g., Term, Quorum, Commit Index, State Machine) with clear, concise definitions and references to where they are first explained."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-comp-diag",
      "title": "Raft Node Internal Component Diagram",
      "description": "Shows the five internal components of a Raft node (Consensus Module, Log Store, State Machine, Transport, Persistence) and their interactions. Include bi-directional arrows for internal calls and network arrows for RPCs to other nodes.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture"
      ]
    },
    {
      "id": "raft-state-machine",
      "title": "Raft Node State Machine Diagram",
      "description": "A state machine diagram showing the three Raft states (Follower, Candidate, Leader), the transitions between them (election timeout, receive votes, discover higher term), and the actions taken on each transition.",
      "type": "state-machine",
      "relevant_sections": [
        "leader-election"
      ]
    },
    {
      "id": "log-replication-seq",
      "title": "Sequence Diagram: Log Replication",
      "description": "A sequence diagram with columns for Client, Leader, Follower1, Follower2. Shows the flow: 1) Client sends command to Leader, 2) Leader appends to log, 3) Leader sends AppendEntries RPCs, 4) Followers respond, 5) Leader updates commitIndex and applies, 6) Leader notifies client. Include retry logic for a slow follower.",
      "type": "sequence",
      "relevant_sections": [
        "log-replication",
        "interactions-data-flow"
      ]
    },
    {
      "id": "log-structure",
      "title": "Log Entry and Index Relationship Diagram",
      "description": "A visual representation of the log as an array of entries. Annotate key indices: lastApplied, commitIndex, lastLogIndex. Show how each entry contains Term, Command, and Index. Illustrate the 'prevLogIndex' and 'prevLogTerm' pointers from the AppendEntries RPC.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "log-replication"
      ]
    },
    {
      "id": "joint-consensus-flow",
      "title": "Flowchart: Joint Consensus Configuration Change",
      "description": "A flowchart detailing the steps for a membership change from config C_old to C_new using joint consensus (C_old,new). Steps include: leader logs C_old,new entry, committing it in both majorities, logging C_new, and finally committing C_new.",
      "type": "flowchart",
      "relevant_sections": [
        "cluster-membership"
      ]
    },
    {
      "id": "network-partition",
      "title": "Component Diagram: Network Partition Scenario",
      "description": "A diagram showing a 5-node cluster split by a network partition (3 nodes on one side, 2 on the other). Illustrate which side can elect a leader (the majority side), and how the minority side's candidates increment their terms but cannot win. Show partition healing and term reconciliation.",
      "type": "component",
      "relevant_sections": [
        "error-handling",
        "safety-properties"
      ]
    },
    {
      "id": "figure-8-scenario",
      "title": "Sequence Diagram: The Figure 8 Safety Issue",
      "description": "A sequence diagram depicting the scenario from Raft paper Figure 8. Show a leader (S1) replicating an entry from term 2, then crashing. A new leader (S5) from term 3 overwrites it. Illustrate how the safety rule (leader only commits entries from its own term) prevents this entry from being committed incorrectly.",
      "type": "sequence",
      "relevant_sections": [
        "safety-properties"
      ]
    }
  ]
}