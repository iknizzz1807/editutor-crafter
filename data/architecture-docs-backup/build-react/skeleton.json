{
  "title": "Build Your Own React: Design Document",
  "overview": "This document outlines the architecture for a React-like UI library built from scratch. It tackles the core challenge of declarative, high-performance UI updates by implementing a Virtual DOM, a reconciliation diffing algorithm, an interruptible Fiber-based renderer, and a Hooks system for state and side effects. The key architectural challenge is managing the complexity of tree updates while maintaining performance and developer ergonomics.",
  "sections": [
    {
      "id": "context-and-problem",
      "title": "1. Context and Problem Statement",
      "summary": "Explains the problem of efficiently updating web UIs and introduces the Virtual DOM pattern, contrasting imperative vs. declarative approaches.",
      "subsections": [
        {
          "id": "analogy-dom-manipulation",
          "title": "The Problem: Direct DOM Manipulation is Painful",
          "summary": "Uses the analogy of physically rebuilding a Lego set vs. describing the desired final state to explain the move from imperative to declarative UI."
        },
        {
          "id": "existing-solutions",
          "title": "Existing Approaches and React's Solution",
          "summary": "Compares naive re-renders, manual diffing, and React's Virtual DOM with reconciliation."
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "2. Goals and Non-Goals",
      "summary": "Defines the scope of the educational library, specifying what we will and will not implement.",
      "subsections": [
        {
          "id": "goals-list",
          "title": "Goals (Must-Have Features)",
          "summary": "Lists the core features: declarative API, efficient updates via diffing, non-blocking renders, hooks API."
        },
        {
          "id": "non-goals-list",
          "title": "Non-Goals (Out of Scope)",
          "summary": "Explicitly excludes features like server-side rendering, synthetic events, portals, and the full React API surface."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "3. High-Level Architecture",
      "summary": "Provides a bird's-eye view of the system's main components: the renderer, reconciler, and the fiber tree. Describes the recommended file structure for the project.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview and Responsibilities",
          "summary": "Introduces the four pillars: Virtual DOM creation, Reconciliation diffing, Fiber scheduler, and Hooks runtime."
        },
        {
          "id": "file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Outlines the directory and file layout for the codebase, separating concerns like core, reconciler, and hooks."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core data structures: Virtual DOM nodes, Fiber nodes, Hook instances, and the work-in-progress tree.",
      "subsections": [
        {
          "id": "vnode-structure",
          "title": "Virtual Node (VNode) Structure",
          "summary": "Details the properties of a VNode (type, props, children)."
        },
        {
          "id": "fiber-structure",
          "title": "Fiber Node Structure",
          "summary": "Describes the expanded Fiber node with parent/child/sibling links, alternate pointer, effect tag, and hook queue."
        },
        {
          "id": "hook-structure",
          "title": "Hook Instance Structure",
          "summary": "Defines the linked list node for a hook, storing state, queue, and cleanup function."
        }
      ]
    },
    {
      "id": "virtual-dom-component",
      "title": "5.1 Component Design: Virtual DOM and Renderer (Milestone 1)",
      "summary": "Designs the createElement and render functions. Covers the mental model of a blueprint (VNode) vs. the physical building (DOM).",
      "subsections": [
        {
          "id": "vdom-mental-model",
          "title": "Mental Model: Blueprints and Builders",
          "summary": "Explains VNodes as lightweight blueprints and the render function as the builder that constructs the real DOM."
        },
        {
          "id": "vdom-interface",
          "title": "Interface: createElement and render",
          "summary": "Specifies the function signatures and expected behaviors."
        },
        {
          "id": "vdom-adr-jsx",
          "title": "ADR: JSX Transformation",
          "summary": "Discusses options for handling JSX (Babel plugin vs. direct function calls) and recommends the simpler approach for education."
        },
        {
          "id": "vdom-pitfalls",
          "title": "Common Pitfalls: Text Nodes and Event Listeners",
          "summary": "Highlights forgetting to create text nodes and incorrectly attaching event handlers (e.g., using 'onclick' vs 'onClick')."
        },
        {
          "id": "vdom-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides skeleton code for createElement and render, with TODOs for creating elements and handling props."
        }
      ]
    },
    {
      "id": "reconciliation-component",
      "title": "5.2 Component Design: Reconciliation Engine (Milestone 2)",
      "summary": "Designs the diffing algorithm and patch application. Uses the mental model of finding differences between two trees of blueprints.",
      "subsections": [
        {
          "id": "recon-mental-model",
          "title": "Mental Model: Tree Diffing and Surgical Updates",
          "summary": "Compares the diffing process to a 'git diff' for UI trees, aiming to find the minimal edit distance."
        },
        {
          "id": "recon-algorithm",
          "title": "Algorithm: Recursive Tree Diff",
          "summary": "Outlines the steps for comparing old and new VNodes, handling type changes, prop updates, and list reconciliation with keys."
        },
        {
          "id": "recon-adr-diff-strategy",
          "title": "ADR: Diffing Strategy (Full vs. Heuristic)",
          "summary": "Compares a simple recursive O(n^3) algorithm to React's O(n) heuristic based on element type and key, choosing the latter for practicality."
        },
        {
          "id": "recon-pitfalls",
          "title": "Common Pitfalls: Key Misuse and DOM Reference Loss",
          "summary": "Warns about using array indices as keys and losing references to DOM nodes during updates."
        },
        {
          "id": "recon-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides skeleton for the diff/patch function and keyed list reconciliation logic."
        }
      ]
    },
    {
      "id": "fiber-architecture-component",
      "title": "5.3 Component Design: Fiber Architecture (Milestone 3)",
      "summary": "Designs the Fiber tree, work loop, and commit phase. The mental model is a task list that can be paused and resumed.",
      "subsections": [
        {
          "id": "fiber-mental-model",
          "title": "Mental Model: Task Lists and Unit-of-Work",
          "summary": "Frames fibers as individual tasks on a to-do list. The work loop picks tasks, can be interrupted, and the commit phase is the final 'delivery' of all completed work."
        },
        {
          "id": "fiber-workloop",
          "title": "Work Loop and Scheduling",
          "summary": "Describes the main loop using requestIdleCallback, the phases (render/reconcile, commit), and the linked list traversal of fibers."
        },
        {
          "id": "fiber-adr-scheduling",
          "title": "ADR: Scheduling with requestIdleCallback vs. Scheduler",
          "summary": "Compares using the browser's native requestIdleCallback to a custom scheduler, choosing the former for simplicity and educational clarity."
        },
        {
          "id": "fiber-pitfalls",
          "title": "Common Pitfalls: Infinite Loops and State Management",
          "summary": "Discusses creating cycles in the fiber tree and incorrectly managing the workInProgress tree and alternate pointers."
        },
        {
          "id": "fiber-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides skeleton for the Fiber node class, work loop, and commit phase functions."
        }
      ]
    },
    {
      "id": "hooks-component",
      "title": "5.4 Component Design: Hooks System (Milestone 4)",
      "summary": "Designs useState and useEffect hooks. Mental model: hooks are a way to 'hook into' the fiber's lifecycle and state storage.",
      "subsections": [
        {
          "id": "hooks-mental-model",
          "title": "Mental Model: Function Component Memory",
          "summary": "Explains how hooks provide a 'memory cell' for function components, attached to the fiber node, to persist state across renders."
        },
        {
          "id": "hooks-interface",
          "title": "Interface: useState and useEffect",
          "summary": "Details the API contract, return values, and dependency array behavior."
        },
        {
          "id": "hooks-adr-storage",
          "title": "ADR: Hook Storage (Array vs. Linked List)",
          "summary": "Compares storing hooks in an array versus a linked list per fiber, choosing a linked list for its simplicity in insertions and alignment with fiber concepts."
        },
        {
          "id": "hooks-pitfalls",
          "title": "Common Pitfalls: Stale Closures and Conditional Hooks",
          "summary": "Explains the stale closure problem in effects and the rule of hooks violation when calling hooks conditionally."
        },
        {
          "id": "hooks-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides skeleton code for the useState and useEffect implementations and the hook dispatcher."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "6. Interactions and Data Flow",
      "summary": "Traces the journey of a state update from setState call through re-render, reconciliation, and commit.",
      "subsections": [
        {
          "id": "sequence-state-update",
          "title": "Sequence: Triggering a State Update",
          "summary": "Step-by-step walkthrough of setState, scheduling work, performing reconciliation, and committing changes."
        },
        {
          "id": "flow-effect-execution",
          "title": "Flow: Side Effect Scheduling and Cleanup",
          "summary": "Describes how effects are tagged during render and executed in the correct order during commit."
        }
      ]
    },
    {
      "id": "error-handling-edge-cases",
      "title": "7. Error Handling and Edge Cases",
      "summary": "Addresses failure modes like runtime errors in render, invalid hooks calls, and handling of null/undefined children.",
      "subsections": [
        {
          "id": "error-boundaries-strategy",
          "title": "Strategy: Error Boundaries (Conceptual)",
          "summary": "Discusses the concept (though not implemented) and how our architecture could be extended to support it."
        },
        {
          "id": "edge-cases-nodes",
          "title": "Edge Cases in VNode Creation and Diffing",
          "summary": "Covers handling of falsey children, SVG namespace, and removing event listeners."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "8. Testing Strategy",
      "summary": "Outlines a property-based and integration testing approach with specific checkpoints for each milestone.",
      "subsections": [
        {
          "id": "testing-approach",
          "title": "Testing Approach and Tools",
          "summary": "Recommends using a test runner (Jest) and a DOM testing library (JSDOM) for unit and integration tests."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Implementation Checkpoints",
          "summary": "For each milestone, describes a simple test application and the expected visual/console output to verify correct implementation."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "9. Debugging Guide",
      "summary": "A symptom-cause-fix table for common bugs encountered during implementation.",
      "subsections": [
        {
          "id": "debug-table",
          "title": "Common Bug Symptoms and Fixes",
          "summary": "Table listing issues like 'DOM not updating', 'Infinite re-render loop', 'State resets', with diagnosis steps and solutions."
        },
        {
          "id": "debug-techniques",
          "title": "Debugging Techniques: Logging and Inspection",
          "summary": "Suggests adding console logs to the work loop and using browser dev tools to inspect the fiber tree and hook list."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "10. Future Extensions",
      "summary": "Proposes possible enhancements like useReducer, useContext, concurrent features, and a custom JSX pragma.",
      "subsections": [
        {
          "id": "extensions-list",
          "title": "Potential Features to Implement",
          "summary": "Lists and briefly describes advanced features that build naturally on the current architecture."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "11. Glossary",
      "summary": "Definitions of key terms used throughout the document.",
      "subsections": [
        {
          "id": "terms-definitions",
          "title": "Terminology Reference",
          "summary": "Table of terms like Virtual DOM, Reconciliation, Fiber, Hooks, Effect, etc."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "system-component-diagram",
      "title": "System Component Diagram",
      "description": "Shows the high-level components: the public API (createElement, render), the reconciler with its diffing and fiber tree, and the renderer that talks to the DOM. Arrows show data flow (VNode trees, update queues).",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-data-flow"
      ]
    },
    {
      "id": "vnode-fiber-tree",
      "title": "VNode Tree vs. Fiber Tree",
      "description": "Compares the simple parent-child VNode tree to the Fiber tree's linked structure with parent, child, sibling, and alternate pointers. Shows how a component hierarchy maps to both.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "fiber-architecture-component"
      ]
    },
    {
      "id": "reconciliation-flowchart",
      "title": "Reconciliation Diffing Algorithm",
      "description": "A flowchart of the diffing logic for a single fiber. Decision diamonds for 'type changed?', 'props changed?', 'has keys?'. Paths lead to actions like 'replace node', 'update props', or 'reconcile children array'.",
      "type": "flowchart",
      "relevant_sections": [
        "reconciliation-component"
      ]
    },
    {
      "id": "work-loop-sequence",
      "title": "Work Loop and Commit Phase Sequence",
      "description": "A sequence diagram showing the interaction between the browser's main thread, the work loop (with requestIdleCallback), the reconciliation of individual fibers, and the final batch commit to the DOM.",
      "type": "sequence",
      "relevant_sections": [
        "fiber-architecture-component",
        "interactions-data-flow"
      ]
    },
    {
      "id": "hooks-linked-list",
      "title": "Hooks Linked List in a Fiber",
      "description": "Shows a single fiber node with a 'memoizedState' pointer linking to a chain of hook instances (useState, useEffect). Each hook node shows its memoizedState, queue, and next pointer.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "hooks-component"
      ]
    },
    {
      "id": "state-update-flow",
      "title": "State Update Data Flow",
      "description": "A flowchart tracing a setState call: triggers update -> added to hook queue -> marks fiber as dirty -> scheduler picks up work -> work loop processes -> reconciliation -> commit -> DOM update.",
      "type": "flowchart",
      "relevant_sections": [
        "interactions-data-flow",
        "hooks-component"
      ]
    }
  ]
}