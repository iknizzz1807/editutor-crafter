{
  "title": "Build Your Own SQLite: Design Document",
  "overview": "This document outlines the design of an embedded, file-based SQL database engine. The key architectural challenge is efficiently organizing, querying, and persisting structured data on disk while supporting a subset of SQL and maintaining data integrity, all within a single-file architecture that balances simplicity with performance.",
  "sections": [
    {
      "id": "context",
      "title": "1. Context and Problem Statement",
      "summary": "Explores the fundamental problem of structured data persistence and retrieval, introduces the mental model of a digital filing cabinet, and contrasts existing approaches like full RDBMS vs. simple file storage.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "Mental Model: The Digital Filing Cabinet"
        },
        {
          "id": "problem",
          "title": "The Core Challenge: Structured Data on Disk"
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches and Their Trade-offs"
        }
      ]
    },
    {
      "id": "goals",
      "title": "2. Goals and Non-Goals",
      "summary": "Defines the scope of the educational SQLite implementation, specifying required features and explicit exclusions to maintain focus and feasibility.",
      "subsections": [
        {
          "id": "goals-list",
          "title": "Goals (Must-Have Features)"
        },
        {
          "id": "non-goals-list",
          "title": "Non-Goals (Explicitly Out of Scope)"
        }
      ]
    },
    {
      "id": "architecture",
      "title": "3. High-Level Architecture",
      "summary": "Presents the top-level system components, their responsibilities, and how they interact, visualized in a component diagram.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview and Responsibilities"
        },
        {
          "id": "file-structure",
          "title": "Recommended File/Module Structure"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core in-memory and on-disk data structures, including tokens, AST nodes, B-tree pages, and row formats.",
      "subsections": [
        {
          "id": "in-memory-structures",
          "title": "In-Memory Structures"
        },
        {
          "id": "on-disk-structures",
          "title": "On-Disk (Binary) Structures"
        }
      ]
    },
    {
      "id": "components-parser",
      "title": "5.1 Component: SQL Parser (Milestone 1, 2)",
      "summary": "Design for the lexer and parser that convert SQL text into an Abstract Syntax Tree (AST). Covers tokenization and recursive descent parsing.",
      "subsections": [
        {
          "id": "parser-mental-model",
          "title": "Mental Model: The Language Translator"
        },
        {
          "id": "parser-interface",
          "title": "Interface and Public API"
        },
        {
          "id": "parser-behavior",
          "title": "Internal Behavior: Lexing and Parsing"
        },
        {
          "id": "parser-adr-grammar",
          "title": "ADR: Recursive Descent vs. Parser Generator"
        },
        {
          "id": "parser-pitfalls",
          "title": "Common Pitfalls"
        },
        {
          "id": "parser-implementation",
          "title": "Implementation Guidance"
        }
      ]
    },
    {
      "id": "components-btree-storage",
      "title": "5.2 Component: B-tree Storage Engine (Milestone 3, 4)",
      "summary": "Design for the on-disk B-tree structure that stores tables and indexes, handling page layout, serialization, and node splits.",
      "subsections": [
        {
          "id": "btree-mental-model",
          "title": "Mental Model: The Phone Book Index"
        },
        {
          "id": "btree-interface",
          "title": "Interface and Public API"
        },
        {
          "id": "btree-behavior",
          "title": "Internal Behavior: Page Operations"
        },
        {
          "id": "btree-adr-page-size",
          "title": "ADR: Fixed vs. Variable-Length Page Sizes"
        },
        {
          "id": "btree-pitfalls",
          "title": "Common Pitfalls"
        },
        {
          "id": "btree-implementation",
          "title": "Implementation Guidance"
        }
      ]
    },
    {
      "id": "components-query-engine",
      "title": "5.3 Component: Query Execution Engine (Milestone 5, 6, 7, 8)",
      "summary": "Design for executing SQL operations, including table scans, data modification, index lookups, and basic query planning.",
      "subsections": [
        {
          "id": "query-mental-model",
          "title": "Mental Model: The Assembly Line"
        },
        {
          "id": "query-interface",
          "title": "Interface and Public API"
        },
        {
          "id": "query-behavior",
          "title": "Internal Behavior: Operators and Planning"
        },
        {
          "id": "query-adr-index-selection",
          "title": "ADR: Cost-Based vs. Heuristic Index Selection"
        },
        {
          "id": "query-pitfalls",
          "title": "Common Pitfalls"
        },
        {
          "id": "query-implementation",
          "title": "Implementation Guidance"
        }
      ]
    },
    {
      "id": "components-transactions",
      "title": "5.4 Component: Transactions & WAL (Milestone 9, 10)",
      "summary": "Design for ACID transactions using a rollback journal or Write-Ahead Log (WAL), ensuring atomicity and durability.",
      "subsections": [
        {
          "id": "tx-mental-model",
          "title": "Mental Model: The Bank Ledger"
        },
        {
          "id": "tx-interface",
          "title": "Interface and Public API"
        },
        {
          "id": "tx-behavior",
          "title": "Internal Behavior: Journaling and Recovery"
        },
        {
          "id": "tx-adr-journal-type",
          "title": "ADR: Rollback Journal vs. Write-Ahead Log (WAL)"
        },
        {
          "id": "tx-pitfalls",
          "title": "Common Pitfalls"
        },
        {
          "id": "tx-implementation",
          "title": "Implementation Guidance"
        }
      ]
    },
    {
      "id": "interactions",
      "title": "6. Interactions and Data Flow",
      "summary": "Describes the end-to-end flow for key operations like SELECT and INSERT, showing how components sequence and pass data.",
      "subsections": [
        {
          "id": "flow-select",
          "title": "Data Flow: SELECT Query"
        },
        {
          "id": "flow-insert",
          "title": "Data Flow: INSERT with Transaction"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "7. Error Handling and Edge Cases",
      "summary": "Defines failure modes, recovery strategies, and how to handle edge cases like malformed SQL, disk full, or corrupted pages.",
      "subsections": [
        {
          "id": "error-categories",
          "title": "Error Categories and Recovery"
        },
        {
          "id": "edge-cases",
          "title": "Key Edge Cases"
        }
      ]
    },
    {
      "id": "testing",
      "title": "8. Testing Strategy",
      "summary": "Provides a testing approach with milestone checkpoints to validate each component's behavior and integration.",
      "subsections": [
        {
          "id": "testing-approach",
          "title": "Testing Approach and Tools"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints"
        }
      ]
    },
    {
      "id": "debugging",
      "title": "9. Debugging Guide",
      "summary": "Offers a symptom-cause-fix table for common bugs and techniques for inspecting database state during development.",
      "subsections": [
        {
          "id": "common-bugs",
          "title": "Common Bugs: Symptom \u2192 Cause \u2192 Fix"
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques and Tools"
        }
      ]
    },
    {
      "id": "future",
      "title": "10. Future Extensions",
      "summary": "Suggests potential enhancements to the system, such as JOINs, prepared statements, or a VFS layer, and how the design could accommodate them.",
      "subsections": [
        {
          "id": "extension-ideas",
          "title": "Possible Extension Ideas"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "11. Glossary",
      "summary": "Defines key technical terms, acronyms, and domain-specific vocabulary used throughout this document.",
      "subsections": [
        {
          "id": "terms",
          "title": "Terms and Definitions"
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-component",
      "title": "System Component Diagram",
      "description": "Shows the high-level components of the SQLite engine (Parser, Query Engine, B-tree Storage, Transaction Manager) and their interaction with the Database File and optional WAL file.",
      "type": "component",
      "relevant_sections": [
        "architecture",
        "components-parser",
        "components-btree-storage",
        "components-query-engine",
        "components-transactions"
      ]
    },
    {
      "id": "data-model-diagram",
      "title": "Data Model Class Diagram",
      "description": "Shows key in-memory structures (Token, AST nodes for SELECT/INSERT/CREATE, Row, Cursor) and on-disk structures (PageHeader, LeafCell, InternalCell, JournalHeader) and their relationships.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "components-parser",
        "components-btree-storage"
      ]
    },
    {
      "id": "btree-page-layout",
      "title": "B-tree Page Layout Diagram",
      "description": "Visual breakdown of a 4096-byte page: header section (type, cell count, freeblock offset), cell pointer array, and cell content area with variable-length key-value cells.",
      "type": "component",
      "relevant_sections": [
        "components-btree-storage"
      ]
    },
    {
      "id": "select-sequence",
      "title": "SELECT Query Execution Sequence",
      "description": "Sequence diagram showing: Client -> Parser (SQL to AST) -> Query Planner (choose plan) -> B-tree Cursor (open, next) -> Storage (read page) -> Projection/Filter -> Result Set -> Client.",
      "type": "sequence",
      "relevant_sections": [
        "interactions",
        "components-query-engine"
      ]
    },
    {
      "id": "transaction-state",
      "title": "Transaction State Machine",
      "description": "State machine for a transaction: IDLE -> (BEGIN) -> ACTIVE -> (COMMIT) -> COMMITTING -> (Journal flush) -> IDLE; ACTIVE -> (ROLLBACK) -> IDLE. Includes error transitions to ROLLBACK.",
      "type": "state-machine",
      "relevant_sections": [
        "components-transactions"
      ]
    },
    {
      "id": "wal-checkpoint-flow",
      "title": "WAL Checkpoint Flowchart",
      "description": "Flowchart for checkpoint process: Start -> Acquire lock -> Read WAL frames -> Write pages to main DB -> Sync DB -> Update WAL header -> Release lock -> Truncate WAL if no active readers.",
      "type": "flowchart",
      "relevant_sections": [
        "components-transactions"
      ]
    }
  ]
}