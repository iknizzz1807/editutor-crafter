{
  "types": {
    "erow": "fields: size int, chars char*, rsize int, render char*, tokens Token*, token_count int, token_capacity int, color unsigned char*",
    "editor_config": "fields: cx int, cy int, rx int, rowoff int, coloff int, screenrows int, screencols int, numrows int, row erow*, dirty int, filename char*, statusmsg char[80], statusmsg_time time_t",
    "termios": "system structure for terminal attributes with c_iflag, c_oflag, c_lflag, c_cflag, c_cc fields",
    "EditorKey": "enumeration of special key codes",
    "EditorMode": "enumeration of editor input modes",
    "CommandType": "enum: CMD_INSERT_CHAR, CMD_DELETE_CHAR, CMD_INSERT_NEWLINE, CMD_DELETE_NEWLINE, CMD_INSERT_ROW, CMD_DELETE_ROW, CMD_COMPOUND",
    "MoveDirection": "enumeration of cursor movement directions",
    "CommandParams": "union: char_op CharOperation, line_op LineOperation, compound_op CompoundOperation",
    "Command": "fields: type CommandType, params CommandParams, timestamp time_t",
    "FileLoadResult": "fields: lines char**, line_count int, ending_type LineEndingType, success int, error_message char[256]",
    "LineEndingType": "enum: LINE_ENDING_UNIX, LINE_ENDING_WINDOWS, LINE_ENDING_MAC",
    "FrameBuffer": "fields: buffer char*, capacity size_t, length size_t",
    "Viewport": "fields: row_offset int, col_offset int, screen_rows int, screen_cols int",
    "UndoStack": "fields: commands Command*, capacity size_t, count size_t, current_position int, group_threshold_ms long, save_point_position int",
    "CharOperation": "fields: ch int, row int, col int",
    "LineOperation": "fields: row int, content char*, length size_t, cursor_col int",
    "CompoundOperation": "fields: sub_commands Command*, count int, capacity int",
    "SearchState": "enum: SEARCH_INACTIVE, SEARCH_ACTIVE",
    "SearchDirection": "enum: SEARCH_FORWARD, SEARCH_BACKWARD",
    "SearchMatch": "fields: row int, start_col int, end_col int, match_len int",
    "SearchSystem": "fields: state SearchState, query char[256], query_len int, matches SearchMatch*, match_count int, match_capacity int, current_match int, direction SearchDirection, case_sensitive int, wrap_around int, saved_cx int, saved_cy int",
    "TokenType": "enum: TOKEN_NORMAL, TOKEN_KEYWORD, TOKEN_STRING, TOKEN_COMMENT, TOKEN_NUMBER, TOKEN_OPERATOR, TOKEN_TYPE, TOKEN_PREPROCESSOR",
    "Token": "fields: start int, end int, type TokenType",
    "LanguageDefinition": "fields: name char*, extensions char**, keywords char**, single_comment char*, multi_comment_start char*, multi_comment_end char*, string_chars char*, flags int",
    "SyntaxState": "fields: current_language LanguageDefinition*, in_multi_comment int, highlight_enabled int",
    "EditorError": "fields: code ErrorCode, message char[256], context char[128], timestamp time_t, file const char*, line int",
    "ErrorCode": "enum: ERR_NONE, ERR_TERMINAL_RAW_MODE_FAILED, ERR_TERMINAL_RESTORE_FAILED, ERR_FILE_NOT_FOUND, ERR_FILE_PERMISSION_DENIED, ERR_FILE_TOO_LARGE, ERR_OUT_OF_MEMORY, ERR_CURSOR_OUT_OF_BOUNDS, ERR_LINE_TOO_LONG, ERR_BUFFER_CORRUPTED, ERR_INVALID_UTF8",
    "BufferLimits": "fields: max_lines int, max_line_length int, total_memory_limit size_t, current_lines int, current_memory size_t",
    "FileContent": "fields: content char*, size size_t, line_count int, endings LineEndingType",
    "BufferBounds": "fields: min_row int, max_row int, min_col int, max_col int, total_lines int, memory_used size_t, memory_limit size_t",
    "MockTerminal": "test helper structure for capturing terminal output",
    "TestResults": "fields: tests_run int, tests_passed int, tests_failed int, current_test_name char[256], start_time clock_t",
    "InputSimulator": "test helper for simulating keyboard input",
    "UndoTestContext": "test helper for undo system verification",
    "debug_level_t": "enum: DEBUG_OFF, DEBUG_ERROR, DEBUG_WARN, DEBUG_INFO, DEBUG_TRACE",
    "BufferPool": "fields: buffers BufferState*, buffer_count int, buffer_capacity int, active_buffer int, max_memory_mb int, current_memory_kb int",
    "BufferState": "fields: rows erow*, numrows int, cx int, cy int, rx int, rowoff int, coloff int, filename char*, dirty int, undo_stack UndoStack*, last_access time_t",
    "ConfigSystem": "fields: entries ConfigEntry*, entry_count int, entry_capacity int, config_file_path char*, last_modified time_t",
    "ConfigEntry": "fields: key char*, type ConfigType, value union, source_file char*, line_number int",
    "ConfigType": "enum: CONFIG_INT, CONFIG_STRING, CONFIG_BOOL, CONFIG_COLOR",
    "PerformanceMetric": "fields: start_time clock_t, end_time clock_t, operation char[64], buffer_id int, memory_used size_t",
    "PluginManager": "fields: plugins Plugin*, plugin_count int, api_registry PluginAPI*",
    "WindowManager": "fields: panes WindowPane*, pane_count int, active_pane int, layout PaneLayout*",
    "LanguageClient": "fields: server_process pid_t, input_fd int, output_fd int, capabilities LSPCapabilities*"
  },
  "methods": {
    "enable_raw_mode() int": "switches terminal to raw mode for character-by-character input",
    "disable_raw_mode() void": "restores terminal to original cooked mode",
    "get_window_size(int*, int*) int": "retrieves current terminal dimensions",
    "clear_screen() void": "sends ANSI sequence to clear entire screen",
    "position_cursor(int, int) void": "moves cursor to specified row and column",
    "hide_cursor() void": "makes cursor invisible during screen updates",
    "show_cursor() void": "makes cursor visible after screen updates",
    "editor_read_key() int": "reads and parses keyboard input including escape sequences",
    "editor_insert_char(int) void": "insert character with undo support",
    "editor_refresh_screen() void": "redraws entire screen content",
    "die(const char*) void": "cleanup and exit on fatal error",
    "editor_update_row(erow*) void": "updates render representation after chars change",
    "editor_row_insert_char(erow*, int, int) void": "inserts character at position in row",
    "editor_row_del_char(erow*, int) void": "deletes character at position in row",
    "editor_insert_row(int, char*, size_t) void": "inserts new row at position",
    "editor_del_row(int) void": "deletes row at position",
    "editor_scroll() void": "adjust viewport to keep cursor visible",
    "cx_to_rx(erow*, int, int) int": "converts logical to visual cursor position",
    "rx_to_cx(erow*, int, int) int": "converts visual to logical cursor position",
    "setup_signal_handlers() void": "installs signal handlers for graceful cleanup",
    "input_to_command(int) Command": "converts raw key input to editor command",
    "execute_command(Command*) void": "executes parsed command by routing to appropriate handler",
    "set_editor_mode(EditorMode) void": "changes editor mode and updates key mapping",
    "get_editor_mode() EditorMode": "returns current editor mode",
    "editor_delete_char(void) void": "delete character with undo support",
    "editor_insert_newline(void) void": "splits line at cursor position",
    "editor_open(char*) void": "loads file into buffer",
    "editor_save(void) void": "saves buffer to disk",
    "editor_rows_to_string(int*) char*": "serializes buffer to string",
    "load_file_lines(const char*) FileLoadResult*": "loads file and splits into lines",
    "save_file_lines(const char*, char**, int, LineEndingType) int": "saves lines to file with specified endings",
    "detect_line_endings(const char*, size_t) LineEndingType": "detects line ending format in content",
    "cx_to_rx(erow*, int) int": "converts logical to visual cursor position",
    "rx_to_cx(erow*, int) int": "converts visual to logical cursor position",
    "frame_buffer_create(size_t) FrameBuffer*": "creates frame buffer with initial capacity",
    "frame_buffer_append(FrameBuffer*, const char*, size_t) int": "appends content to frame buffer",
    "frame_buffer_flush(FrameBuffer*, int) int": "sends complete frame buffer to terminal",
    "frame_buffer_reset(FrameBuffer*) void": "clears frame buffer for next frame",
    "format_cursor_position(char*, int, int) int": "generates cursor positioning escape sequence",
    "undo_stack_create(size_t) UndoStack*": "Initialize undo stack with specified capacity",
    "undo_stack_free(UndoStack*) void": "Free undo stack and all associated memory",
    "undo_stack_mark_save_point(UndoStack*) void": "Mark current position as save point for dirty flag management",
    "undo_stack_is_clean(UndoStack*) int": "Check if current position matches save point",
    "undo_record_char_insert(UndoStack*, int, int, int) void": "record character insertion before buffer modification",
    "undo_record_char_delete(UndoStack*, int, int, int) void": "Record character deletion before buffer modification",
    "undo_execute(UndoStack*) int": "Execute undo operation, return 1 for success",
    "redo_execute(UndoStack*) int": "Execute redo operation, return 1 for success",
    "search_init() void": "initialize search system state",
    "search_cleanup() void": "Free search system memory",
    "search_activate() void": "Enter search mode",
    "search_deactivate(int) void": "Exit search mode",
    "search_add_char(int) void": "Add character to search query",
    "search_delete_char() void": "Remove character from search query",
    "search_next_match() void": "Navigate to next search match",
    "search_prev_match() void": "Navigate to previous search match",
    "search_is_active() int": "Check if search mode is active",
    "search_update_matches() void": "Find all matches for current query",
    "search_char_in_match(int, int, int*) int": "Check if character position is in search match",
    "search_move_to_match(int) void": "Move cursor to specified match",
    "editor_set_status_message() void": "Update status bar message",
    "syntax_init() void": "initialize syntax highlighting system",
    "syntax_cleanup() void": "Free syntax highlighting resources",
    "detect_language(const char*) LanguageDefinition*": "Detect language from filename extension",
    "tokenize_row(erow*, LanguageDefinition*, int) void": "Tokenize single row with language rules",
    "apply_syntax_colors(erow*) void": "Apply ANSI color codes to tokenized row",
    "is_keyword(const char*, LanguageDefinition*) int": "Check if word is language keyword",
    "is_separator(int) int": "Check if character is word boundary",
    "validate_cursor_position(int, int) int": "validates cursor coordinates within buffer bounds",
    "emergency_cleanup(int) void": "async-signal-safe terminal restoration",
    "load_file_safely(const char*) FileContent*": "safe file loading with comprehensive error handling",
    "save_file_atomically(const char*, const FileContent*) int": "atomic file saving with backup creation",
    "validate_buffer_operation(int, int, int) int": "validates operations at buffer boundaries",
    "check_memory_limits(size_t) int": "prevents memory exhaustion during operations",
    "mock_terminal_create(int, int) MockTerminal*": "creates mock terminal with specified dimensions",
    "mock_terminal_write(MockTerminal*, const char*, size_t) int": "writes data to mock terminal and updates state",
    "mock_terminal_verify_sequence(MockTerminal*, const char*) int": "verifies that expected ANSI sequence was written",
    "test_framework_init() void": "initializes test framework and result tracking",
    "create_input_simulator(const char*) InputSimulator*": "creates input simulator with predefined keystroke sequence",
    "simulate_keypress(InputSimulator*) int": "simulates next keypress from sequence",
    "debug_init(const char*) void": "initialize debugging system",
    "debug_cleanup() void": "cleanup debugging system",
    "debug_printf(const char*, int, const char*, const char*, const char*, ...) void": "core debug logging function",
    "debug_dump_buffer_state() void": "dumps text buffer state to debug log",
    "debug_hex_dump(const char*, const unsigned char*, size_t) void": "hex dump of binary data",
    "buffer_pool_create(int, int) BufferPool*": "initialize multi-buffer system with capacity and memory limits",
    "buffer_pool_open_file(BufferPool*, const char*) int": "open file in new buffer or switch to existing",
    "buffer_pool_switch_to(BufferPool*, int) int": "switch to buffer by index",
    "config_load_from_file(ConfigSystem*, const char*) int": "load configuration from file",
    "config_get_int(ConfigSystem*, const char*, int) int": "get integer configuration value with default",
    "perf_start(PerformanceMetric*, const char*) void": "start performance measurement",
    "perf_end(PerformanceMetric*, int) void": "end performance measurement and log if over threshold"
  },
  "constants": {
    "STDIN_FILENO": "0",
    "STDOUT_FILENO": "file descriptor 1",
    "VMIN": "minimum characters for non-canonical read",
    "VTIME": "timeout for non-canonical read",
    "TAB_SIZE": "typically 8 characters per tab stop",
    "ESCAPE_CHAR": "ASCII 27 escape character",
    "ARROW_LEFT": "1000",
    "ARROW_RIGHT": "1001",
    "ARROW_UP": "1002",
    "ARROW_DOWN": "1003",
    "DELETE_KEY": "1004",
    "HOME_KEY": "1005",
    "END_KEY": "1006",
    "PAGE_UP": "1007",
    "PAGE_DOWN": "1008",
    "ESC_KEY": "27",
    "BACKSPACE": "127",
    "ANSI_CLEAR_SCREEN": "\\x1b[2J escape sequence",
    "ANSI_CURSOR_HIDE": "\\x1b[?25l escape sequence",
    "ANSI_CURSOR_SHOW": "\\x1b[?25h escape sequence",
    "ANSI_COLOR_RESET": "\\x1b[m escape sequence",
    "DEFAULT_GROUP_THRESHOLD_MS": "1000 milliseconds for operation grouping",
    "SEARCH_HIGHLIGHT": "ANSI code for search match highlighting",
    "CURRENT_MATCH_HIGHLIGHT": "ANSI code for current match highlighting",
    "COLOR_NORMAL": "\\x1b[0m ANSI reset sequence",
    "COLOR_KEYWORD": "\\x1b[34m blue color for keywords",
    "COLOR_STRING": "\\x1b[32m green color for strings",
    "COLOR_COMMENT": "\\x1b[90m gray color for comments",
    "COLOR_NUMBER": "\\x1b[33m yellow color for numbers",
    "COLOR_OPERATOR": "\\x1b[35m magenta color for operators",
    "COLOR_TYPE": "\\x1b[36m cyan color for types",
    "DEBUG_TERMINAL": "0x01",
    "DEBUG_INPUT": "0x02",
    "DEBUG_RENDER": "0x04",
    "DEBUG_BUFFER": "0x08",
    "DEBUG_COORDS": "0x10",
    "LSP_PROTOCOL_VERSION": "language server protocol version",
    "MAX_BUFFERS_DEFAULT": "default maximum number of open buffers",
    "CONFIG_FILE_NAME": ".kilorc configuration file name",
    "BUFFER_EVICTION_THRESHOLD": "memory threshold for buffer eviction"
  },
  "terms": {
    "raw mode": "terminal mode where input is not line-buffered or echoed",
    "canonical mode": "normal terminal mode with line buffering and echo",
    "cooked mode": "synonym for canonical mode",
    "ANSI escape sequences": "control codes for cursor positioning and screen manipulation",
    "immediate mode rendering": "drawing approach where each frame is explicitly constructed",
    "retained mode rendering": "drawing approach where framework maintains display state",
    "modal architecture": "UI design with distinct input interpretation modes",
    "frame buffer": "accumulated screen output sent as single atomic update",
    "text buffer": "in-memory representation of file content as array of lines",
    "viewport": "visible portion of document displayed on terminal screen",
    "logical coordinates": "cursor position in terms of characters and lines in document",
    "visual coordinates": "cursor position in terms of screen columns accounting for tab expansion",
    "render representation": "processed version of line content with tabs expanded for display",
    "async-signal-safe": "functions that can be safely called from signal handlers",
    "termios": "POSIX structure containing terminal I/O settings",
    "VT100": "terminal standard that established escape sequence conventions",
    "timeout-based parsing": "technique for distinguishing escape key from escape sequences using timing",
    "command dispatching": "routing parsed commands to appropriate handler components",
    "keypress parsing": "process of converting raw input bytes into logical key events",
    "atomic write": "file operation that either completes fully or leaves original unchanged",
    "line joining": "operation that combines two adjacent lines into single line",
    "line splitting": "operation that divides one line into two lines at cursor position",
    "flicker prevention": "technique to avoid partial screen updates during rendering",
    "command pattern": "design pattern where operations are encapsulated as objects with execute and undo methods",
    "linear history": "undo model where new edits discard undone operations",
    "operation recording": "capturing reversible representations of edit commands",
    "undo stack management": "managing history of operations and current position",
    "compound operation": "grouped operations that undo as single unit",
    "time-based grouping": "merging consecutive similar operations within time threshold",
    "save point": "position in undo stack when file was last saved",
    "incremental search": "Search that updates results as user types each character",
    "match highlighting": "Visual marking of search results using color codes",
    "search state machine": "State-driven design controlling search behavior",
    "current match": "The search match that cursor will navigate to",
    "case sensitivity": "Whether search distinguishes between upper and lower case",
    "wrap around": "Whether search continues from beginning after reaching end",
    "syntax highlighting": "Visual coloring of code elements based on language semantics",
    "tokenization": "Process of breaking text into meaningful language elements",
    "language detection": "Determining programming language from file characteristics",
    "token": "Individual syntactic element with type and position",
    "color application": "Process of applying ANSI color codes during rendering",
    "state machine": "Algorithm that tracks context while parsing text",
    "ANSI color codes": "Terminal escape sequences for text coloring",
    "language definition": "Structure containing syntax rules for specific programming language",
    "event loop": "central coordination mechanism that processes input and updates display",
    "immediate-mode rendering": "drawing approach where each frame is explicitly constructed",
    "backpressure": "natural flow control that prevents system overload",
    "boundary conditions": "edge cases at limits of data structures or operations",
    "terminal state recovery": "restoring terminal to original mode after editor exit or crash",
    "pseudo-terminals": "programmatic terminal interfaces that allow automated testing of terminal applications",
    "component-level unit testing": "testing individual modules in isolation without terminal dependencies",
    "integration testing framework": "system for testing complete workflows from input to screen output",
    "milestone verification checkpoints": "quality gates that verify specific behavioral requirements after each development milestone",
    "mock terminals": "test doubles that simulate terminal behavior for automated testing",
    "input simulation": "programmatic generation of keystroke sequences for testing",
    "test scenario scripting": "defining test cases as sequences of input actions and expected results",
    "stress testing": "verification that editor remains stable under extreme conditions",
    "performance benchmarks": "measurement of response times for interactive operations",
    "continuous integration testing": "automated testing in headless CI environments",
    "buffer pool": "collection management system for multiple open file buffers",
    "LRU eviction": "least recently used algorithm for removing old buffers from memory",
    "plugin architecture": "extensible system allowing third-party code modules",
    "language server protocol": "standardized communication protocol for language intelligence",
    "version control integration": "features connecting editor with source control systems",
    "project workspace": "collection of related files with shared configuration and tools",
    "paged buffer system": "memory management approach loading file content in fixed-size chunks",
    "incremental rendering": "screen update optimization updating only changed display regions",
    "configuration hierarchy": "layered system of settings with precedence rules",
    "split view": "display mode showing multiple file buffers simultaneously in separate panes",
    "dirty flag": "indicator whether buffer has unsaved modifications"
  }
}