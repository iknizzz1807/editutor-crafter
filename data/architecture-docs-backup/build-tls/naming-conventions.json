{
  "types": {
    "TlsError": "enum with ProtocolError variant",
    "ContentType": "enum with Handshake ApplicationData variants",
    "TlsRecord": "fields: content_type ContentType, protocol_version u16, payload Vec<u8>",
    "EcdhKeyExchange": "fields: private_key [u8; 32], public_key Vec<u8>",
    "TlsStream": "fields: stream TcpStream, read_buffer Vec<u8>, write_buffer Vec<u8>",
    "TlsResult": "Result<T TlsError> type alias",
    "HandshakeType": "enum with ClientHello ServerHello variants",
    "ClientHello": "fields: client_version u16, random [u8; 32], session_id Vec<u8>, cipher_suites Vec<u16>, compression_methods Vec<u8>, extensions Vec<Extension>",
    "Extension": "fields: extension_type u16, extension_data Vec<u8>",
    "HandshakeState": "extended with PskResumption, PskKeyExchange variants",
    "ConnectionState": "extended with resumption_master_secret Option<SecureBytes>, session_ticket Option<Vec<u8>>",
    "RecordHandler": "fn(&[u8], &mut ConnectionState) -> TlsResult<Vec<TlsRecord>>",
    "RecordProcessor": "fields: handlers HashMap<ContentType, RecordHandler>",
    "AeadProcessor": "fields: encryption_key, decryption_key, write_iv, read_iv",
    "SecureBytes": "secure wrapper for sensitive byte data with automatic cleanup",
    "ServerHello": "fields: server_version u16, random [u8; 32], session_id Vec<u8>, cipher_suite u16, compression_method u8, extensions Vec<Extension>",
    "FinishedMessage": "fields: verify_data [u8; 32]",
    "ConnectionRole": "enum with Client, Server variants",
    "X509Certificate": "fields: tbs_certificate Vec<u8>, subject DistinguishedName, issuer DistinguishedName, serial_number Vec<u8>, validity_period ValidityPeriod, public_key PublicKeyInfo, signature_algorithm SignatureAlgorithm, signature Vec<u8>, extensions HashMap<String, CertificateExtension>",
    "DistinguishedName": "fields: common_name Option<String>, organization Option<String>, organizational_unit Option<String>, country Option<String>, state_or_province Option<String>, locality Option<String>",
    "ValidityPeriod": "fields: not_before SystemTime, not_after SystemTime",
    "PublicKeyInfo": "fields: algorithm PublicKeyAlgorithm, key_data Vec<u8>",
    "CertificateError": "enum with ParseError, ChainBuildingFailed, SignatureVerificationFailed, ExpiredCertificate, InvalidHostname, UntrustedRoot, InvalidKeyUsage, CriticalExtensionNotSupported variants",
    "SignatureAlgorithm": "enum with RsaPkcs1Sha256, RsaPkcs1Sha384, RsaPkcs1Sha512, RsaPssSha256, RsaPssSha384, RsaPssSha512, EcdsaSha256, EcdsaSha384, EcdsaSha512 variants",
    "PublicKeyAlgorithm": "enum with Rsa, EcdsaP256, EcdsaP384 variants",
    "CertificateExtension": "fields: critical bool, data Vec<u8>",
    "ValidationResult": "fields: valid bool, error Option<CertificateError>, validated_chain Vec<X509Certificate>",
    "TrustStore": "fields: root_certificates HashMap<DistinguishedName, X509Certificate>",
    "ConnectionManager": "thread-safe connection state manager",
    "RecordPipeline": "complete record processing pipeline",
    "KeyDistributor": "secure key distribution system",
    "TlsAlert": "fields: level u8, description u8",
    "NetworkErrorHandler": "fields: retry_attempts u32, base_delay Duration, max_delay Duration, total_timeout Duration",
    "TlsTestVectors": "test vector container",
    "HandshakeTrafficTest": "RFC 8448 test vector",
    "X25519TestVector": "RFC 7748 test vector",
    "MockTlsConnection": "test harness for state machine testing",
    "HandshakeEvent": "debugging event structure",
    "HandshakeEventType": "enum for different trace event types",
    "HandshakeTracer": "handshake tracing utility",
    "ProtocolValidator": "protocol compliance validation utility",
    "ResumptionTicket": "fields: encrypted_state Vec<u8>, ticket_lifetime Duration, issue_time SystemTime",
    "SessionState": "fields: cipher_suite u16, master_secret Vec<u8>, client_identity Option<Vec<u8>>, issue_time SystemTime, negotiated_protocols Vec<String>",
    "ResumptionManager": "fields: ticket_encryption_key SecureBytes, ticket_lifetime Duration, max_early_data u32",
    "BufferSize": "enum with Small=1024, Medium=8192, Large=16384",
    "PooledBuffer": "fields: buffer Vec<u8>, pool Arc<RecordBufferPool>, size_category BufferSize",
    "RecordBufferPool": "fields: small_buffers Mutex<VecDeque<Vec<u8>>>, medium_buffers Mutex<VecDeque<Vec<u8>>>, large_buffers Mutex<VecDeque<Vec<u8>>>, max_pooled usize",
    "AeadAlgorithm": "trait with encrypt, decrypt, key_size, nonce_size, tag_size methods",
    "ChaCha20Poly1305": "struct implementing AeadAlgorithm trait",
    "EcCurveType": "enum identifying elliptic curve types",
    "CertificateRequest": "fields: certificate_request_context Vec<u8>, extensions Vec<Extension>, signature_algorithms Vec<u16>, certificate_authorities Vec<DistinguishedName>",
    "TerminologyValidator": "fields: protocol_terms HashMap<String String>, crypto_terms HashMap<String String>, certificate_terms HashMap<String String>",
    "ComplianceValidator": "fields: terminology TerminologyValidator",
    "TerminologyDebugger": "fields: validator TerminologyValidator"
  },
  "methods": {
    "ContentType::from_u8(value: u8) -> TlsResult<Self>": "convert u8 to ContentType enum variant",
    "TlsRecord::parse_header(header_bytes: &[u8]) -> TlsResult<(ContentType, u16, u16)>": "parse 5-byte record header",
    "TlsRecord::fragment_message(content_type: ContentType, message: &[u8]) -> Vec<TlsRecord>": "split large messages into multiple records",
    "TlsRecord::reassemble_fragments(records: &[TlsRecord]) -> TlsResult<Vec<u8>>": "combine fragmented records into complete message",
    "EcdhKeyExchange::new() -> TlsResult<Self>": "generate new ECDH key pair",
    "EcdhKeyExchange::public_key_bytes(&self) -> &[u8]": "return public key bytes for transmission",
    "EcdhKeyExchange::compute_shared_secret(self, peer_public_key: &[u8]) -> TlsResult<Vec<u8>>": "compute ECDH shared secret",
    "TlsStream::read_exact_bytes(&mut self, count: usize) -> TlsResult<Vec<u8>>": "read exact number of bytes from network",
    "TlsStream::write_all_bytes(&mut self, data: &[u8]) -> TlsResult<()>": "write all bytes to network",
    "ConnectionState::advance_state(&mut self, message_type: HandshakeType) -> TlsResult<()>": "validate state transition and advance state machine",
    "ConnectionState::update_transcript(&mut self, message_bytes: &[u8])": "add handshake message to transcript hash",
    "TlsRecord::read_from_stream(stream: &mut dyn std::io::Read) -> TlsResult<Self>": "read complete TLS record from byte stream",
    "TlsRecord::write_to_stream(&self, stream: &mut dyn std::io::Write) -> TlsResult<()>": "write complete TLS record to byte stream",
    "RecordProcessor::process_record(&self, record: &TlsRecord, state: &mut ConnectionState) -> TlsResult<Vec<TlsRecord>>": "route record to appropriate protocol handler",
    "AeadProcessor::encrypt_record(&self, record: &mut TlsRecord, sequence_number: u64) -> TlsResult<()>": "encrypt record using AEAD with sequence number nonce",
    "EcdhKeyExchange::compute_shared_secret(self, peer_public_key: &[u8]) -> TlsResult<SecureBytes>": "compute ECDH shared secret with peer's public key",
    "TlsKeyDerivation::extract(salt: Option<&[u8]>, ikm: &[u8]) -> TlsResult<SecureBytes>": "HKDF-Extract to concentrate entropy into PRK",
    "TlsKeyDerivation::expand(prk: &[u8], info: &[u8], length: usize) -> TlsResult<SecureBytes>": "HKDF-Expand to generate output key material",
    "TlsKeyDerivation::derive_handshake_keys(shared_secret: &[u8], transcript_hash: &[u8]) -> TlsResult<(SecureBytes, SecureBytes, SecureBytes, SecureBytes)>": "generate TLS 1.3 handshake traffic keys from shared secret",
    "HandshakeType::from_u8(value: u8) -> TlsResult<Self>": "convert u8 to HandshakeType enum variant",
    "ClientHello::new(hostname: Option<&str>) -> TlsResult<Self>": "construct ClientHello with extensions and key material",
    "ClientHello::to_bytes(&self) -> Vec<u8>": "serialize ClientHello to wire format",
    "ServerHello::parse(bytes: &[u8]) -> TlsResult<Self>": "parse ServerHello from wire format",
    "ServerHello::validate_against_client_hello(&self, client_hello: &ClientHello) -> TlsResult<()>": "validate server selections against client offer",
    "ServerHello::extract_server_key_share(&self) -> TlsResult<(u16, Vec<u8>)>": "extract server's public key from key_share extension",
    "FinishedMessage::compute_verify_data(handshake_secret: &[u8], transcript_hash: &[u8], label: &str) -> TlsResult<[u8; 32]>": "compute HMAC of transcript hash using finished key",
    "FinishedMessage::verify_finished_message(received_verify_data: &[u8; 32], expected_verify_data: &[u8; 32]) -> bool": "constant-time comparison of verify_data fields",
    "FinishedMessage::new(handshake_secret: &[u8], transcript: &[u8], is_client: bool) -> TlsResult<Self>": "create finished message with computed verify_data",
    "FinishedMessage::to_bytes(&self) -> Vec<u8>": "serialize finished message to wire format",
    "CertificateParser::parse_certificate(&mut self) -> TlsResult<X509Certificate>": "parse complete X.509 certificate from DER bytes",
    "CertificateParser::parse_tlv(&mut self) -> TlsResult<(u8, usize, Vec<u8>)>": "parse ASN.1 tag, length, and value",
    "ChainBuilder::build_chain(&self, server_cert: &X509Certificate, intermediate_certs: &[X509Certificate]) -> TlsResult<Vec<X509Certificate>>": "build certificate chain from server certificate to trusted root",
    "SignatureVerifier::verify_certificate_signature(cert: &X509Certificate, issuer_public_key: &PublicKeyInfo) -> TlsResult<bool>": "verify certificate signature using issuer's public key",
    "ValidityChecker::validate_certificate_chain(&self, chain: &[X509Certificate]) -> TlsResult<()>": "perform complete certificate validity checking",
    "TlsAlert::new(description: u8) -> Self": "create fatal alert with specified description",
    "TlsAlert::to_bytes(&self) -> Vec<u8>": "serialize alert to 2-byte format",
    "TlsAlert::from_bytes(bytes: &[u8]) -> TlsResult<Self>": "parse alert from received bytes",
    "TlsStream::send_alert_and_close(&mut self, alert_code: u8, error_message: &str) -> TlsResult<()>": "send alert and terminate connection",
    "TlsStream::read_exact_bytes_with_retry(&mut self, count: usize) -> TlsResult<Vec<u8>>": "read exact bytes with retry logic",
    "AeadProcessor::handle_decryption_failure(&mut self, record: &TlsRecord, error: &str) -> TlsResult<()>": "handle AEAD decryption failures securely",
    "NetworkErrorHandler::should_retry(&self, error: &io::Error, attempt: u32) -> bool": "determine if network error warrants retry",
    "hex_decode(hex_str: &str) -> Vec<u8>": "decode hex string to bytes",
    "assert_bytes_equal(actual: &[u8], expected: &[u8], context: &str)": "compare byte arrays with detailed diff output",
    "HandshakeTracer::log_record_received(&mut self, content_type: ContentType, length: usize)": "log incoming TLS record",
    "HandshakeTracer::log_state_transition(&mut self, from: HandshakeState, to: HandshakeState, trigger: HandshakeType)": "log handshake state machine transition",
    "HandshakeTracer::log_key_derivation(&mut self, operation: &str, input_size: usize, output_size: usize, success: bool)": "log key derivation operation",
    "ProtocolValidator::validate_client_hello(client_hello: &ClientHello) -> TlsResult<()>": "validate ClientHello message format and content",
    "ProtocolValidator::validate_server_hello(server_hello: &ServerHello, client_hello: &ClientHello) -> TlsResult<()>": "validate ServerHello against ClientHello",
    "ProtocolValidator::validate_message_ordering(current_state: HandshakeState, message_type: HandshakeType) -> TlsResult<()>": "validate handshake message ordering",
    "TlsTestVectors::validate_rfc8448_handshake() -> TlsResult<()>": "validate against RFC 8448 test vectors",
    "TlsTestVectors::validate_x25519_test_vectors() -> TlsResult<()>": "validate X25519 operations against test vectors",
    "TlsTestVectors::validate_key_derivation_test_vectors() -> TlsResult<()>": "validate key derivation against test vectors",
    "ResumptionManager::new(key_material: &[u8]) -> TlsResult<Self>": "create resumption manager with encryption key",
    "ResumptionManager::generate_ticket(&self, state: &ConnectionState) -> TlsResult<ResumptionTicket>": "generate encrypted resumption ticket",
    "ResumptionManager::validate_ticket(&self, ticket: &ResumptionTicket) -> TlsResult<SessionState>": "validate and decrypt resumption ticket",
    "RecordBufferPool::new(max_pooled_per_size: usize) -> Arc<Self>": "create thread-safe buffer pool",
    "RecordBufferPool::acquire_buffer(self: &Arc<Self>, min_size: usize) -> PooledBuffer": "acquire buffer from pool",
    "PooledBuffer::as_mut_slice(&mut self) -> &mut [u8]": "get mutable buffer slice",
    "AeadAlgorithm::encrypt(&self, key: &[u8], nonce: &[u8], aad: &[u8], plaintext: &[u8]) -> TlsResult<Vec<u8>>": "authenticated encryption",
    "AeadAlgorithm::decrypt(&self, key: &[u8], nonce: &[u8], aad: &[u8], ciphertext: &[u8]) -> TlsResult<Vec<u8>>": "authenticated decryption",
    "AeadAlgorithm::key_size(&self) -> usize": "required key length",
    "AeadAlgorithm::nonce_size(&self) -> usize": "required nonce length",
    "AeadAlgorithm::tag_size(&self) -> usize": "authentication tag length",
    "TerminologyValidator::new() -> Self": "create terminology validator with loaded definitions",
    "validate_term_usage(&self, term: &str, context: &str) -> Result<(), String>": "validate terminology usage in context",
    "is_valid_term(&self, term: &str) -> bool": "check if term exists in terminology database",
    "get_definition(&self, term: &str) -> Option<&String>": "return definition for specified term",
    "ComplianceValidator::validate_handshake_sequence(&self, messages: &[HandshakeType]) -> TlsResult<()>": "validate handshake message ordering",
    "validate_content_type_usage(&self, content_type: ContentType, context: &str) -> TlsResult<()>": "validate content type usage",
    "TerminologyDebugger::explain_error(&self, error_message: &str) -> String": "provide detailed error explanations",
    "suggest_fix(&self, term: &str, error_context: &str) -> Vec<String>": "suggest fixes for terminology issues"
  },
  "constants": {
    "TLS_MAX_RECORD_SIZE": "16640 bytes maximum total record size",
    "MAX_FRAGMENT_SIZE": "16384 bytes maximum fragment size",
    "TLS_1_2_VERSION": "0x0303 protocol version for compatibility",
    "X25519_KEY_SIZE": "32 bytes for X25519 keys and shared secrets",
    "TLS_RECORD_HEADER_SIZE": "5 bytes for record header",
    "UNEXPECTED_MESSAGE": "10",
    "BAD_RECORD_MAC": "20",
    "RECORD_OVERFLOW": "22",
    "HANDSHAKE_FAILURE": "40",
    "BAD_CERTIFICATE": "42",
    "CERTIFICATE_EXPIRED": "45",
    "ILLEGAL_PARAMETER": "47",
    "PROTOCOL_VERSION": "70",
    "INTERNAL_ERROR": "80",
    "TLS_AES_128_GCM_SHA256": "mandatory TLS 1.3 cipher suite",
    "TLS_AES_256_GCM_SHA384": "AES-256-GCM cipher suite",
    "TLS_CHACHA20_POLY1305_SHA256": "ChaCha20-Poly1305 cipher suite"
  },
  "terms": {
    "ECDHE": "Elliptic Curve Diffie-Hellman Ephemeral key exchange",
    "AEAD": "Authenticated Encryption with Associated Data providing confidentiality and authenticity",
    "HKDF": "HMAC-based Key Derivation Function",
    "Perfect Forward Secrecy": "past communications remain secure even if long-term keys compromised",
    "Record Layer": "TLS sublayer handling fragmentation encryption and routing",
    "Handshake Protocol": "TLS sublayer that negotiates connection parameters and establishes shared secrets",
    "Content Type": "field in TLS record header identifying protocol layer",
    "X.509": "standard format for public key certificates",
    "PKI": "Public Key Infrastructure for certificate-based authentication",
    "fragmentation": "splitting large messages into multiple records",
    "reassembly": "combining fragmented records into complete messages",
    "dispatch table": "mapping content types to handler functions for routing",
    "nonce": "number used once for encryption randomization",
    "Associated Data": "data authenticated but not encrypted in AEAD",
    "X25519": "elliptic curve key exchange algorithm based on Curve25519",
    "bit clamping": "setting specific bits in X25519 private keys for security",
    "shared secret": "value computed by both parties that serves as input to key derivation",
    "ephemeral keys": "temporary key pairs generated for single use and then destroyed",
    "key derivation": "process of expanding shared secrets into multiple cryptographically independent keys",
    "transcript hash": "cryptographic hash of all handshake messages",
    "verify_data": "HMAC field in finished message proving possession of correct keys",
    "state machine": "control structure enforcing correct handshake message sequencing",
    "extension": "optional data fields in handshake messages for protocol negotiation",
    "cipher suite": "combination of key exchange, encryption, and MAC algorithms",
    "ASN.1": "Abstract Syntax Notation One standard for describing data structures",
    "DER": "Distinguished Encoding Rules for ASN.1",
    "Distinguished Name": "hierarchical naming structure in X.509 certificates",
    "Certificate Authority": "entity that issues digital certificates",
    "Subject Alternative Name": "extension containing additional identity information",
    "Basic Constraints": "extension identifying CA certificates and path length limits",
    "Key Usage": "extension specifying allowed cryptographic operations",
    "Extended Key Usage": "extension specifying high-level certificate purposes",
    "certificate chain": "sequence of certificates linking server to trusted root",
    "trust store": "collection of trusted root CA certificates",
    "signature verification": "cryptographic validation of certificate authenticity",
    "path validation": "RFC 5280 certificate chain validation process",
    "TLS alerts": "protocol communication mechanism for error conditions",
    "protocol violations": "messages that violate TLS specification requirements",
    "cryptographic errors": "failures in mathematical security operations",
    "network errors": "transport layer connection and I/O failures",
    "fail-fast principle": "terminate connections immediately upon detecting violations",
    "alert amplification": "vulnerability where alerts generate more alerts in loops",
    "sequence number overflow": "reuse of AEAD nonces due to counter wraparound",
    "information leakage": "exposing sensitive data through error messages or timing",
    "state machine enforcement": "validating handshake message ordering",
    "graceful degradation": "handling recoverable errors without terminating connections",
    "side-channel attacks": "extracting information through error timing or patterns",
    "resource cleanup": "proper memory and connection cleanup during error conditions",
    "unit tests": "testing individual components in isolation",
    "protocol compliance": "verifying correct handshake sequences and message formatting",
    "interoperability testing": "testing against multiple TLS implementations",
    "milestone validation": "specific tests and behaviors to verify after completing each milestone",
    "test vectors": "known input/output pairs for cryptographic validation",
    "handshake tracing": "systematic logging of TLS handshake message flow",
    "cryptographic state inspection": "examining cryptographic operations without compromising security",
    "protocol compliance validation": "checking adherence to TLS specification requirements",
    "symptom-to-cause mapping": "systematic diagnosis of TLS failure symptoms",
    "session resumption": "reusing cryptographic material from previous connections",
    "PSK resumption": "Pre-Shared Key based session resumption in TLS 1.3",
    "resumption ticket": "encrypted session state for stateless resumption",
    "client certificate authentication": "bidirectional authentication using client certificates",
    "ALPN": "Application-Layer Protocol Negotiation",
    "memory pool": "pre-allocated buffer reuse system",
    "batched key derivation": "computing multiple keys in single HKDF operation",
    "cipher suite negotiation": "selecting cryptographic algorithms during handshake",
    "elliptic curve": "mathematical structure for public key cryptography",
    "constant-time operation": "execution time independent of secret values",
    "downgrade attack": "forcing selection of weaker cryptographic algorithms",
    "point validation": "verifying elliptic curve points are mathematically valid",
    "State Machine": "control structure enforcing correct handshake message sequencing",
    "Certificate Chain": "sequence of certificates linking server to trusted root CA",
    "Key Derivation": "process of expanding shared secrets into cryptographically independent keys",
    "Protocol Negotiation": "process where client and server agree on compatible algorithms",
    "Transcript Hash": "running cryptographic hash of all handshake messages",
    "Trust Store": "collection of trusted root CA certificates"
  }
}