shape: sequence_diagram

client: VPN Client {
  style.fill: "#1a1a2e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
  style.bold: true
}

server: VPN Server {
  style.fill: "#1a1a2e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
  style.bold: true
}

client -> client: Generate private key (a)\nand public key (g^a mod p)
server -> server: Generate private key (b)\nand public key (g^b mod p)

client -> server: KEY_EXCHANGE_INIT\n+ client_public_key (g^a mod p)\n+ supported algorithms
server -> client: KEY_EXCHANGE_RESPONSE\n+ server_public_key (g^b mod p)\n+ selected algorithms

client -> client: Compute shared secret:\nK = (g^b)^a mod p
server -> server: Compute shared secret:\nK = (g^a)^b mod p

client -> client: Derive session keys:\nKDF(K, nonces, session_id)\n→ encryption_key, mac_key
server -> server: Derive session keys:\nKDF(K, nonces, session_id)\n→ encryption_key, mac_key

client -> server: KEY_EXCHANGE_CONFIRM\n+ MAC(session_data)
server -> client: KEY_EXCHANGE_ACK\n+ MAC(confirmation)

client -> client: Session established\nKeys installed
server -> server: Session established\nKeys installed

client <-> server: Encrypted tunnel traffic {
  style.stroke: "#3fb950"
  style.bold: true
}

client -> server: REKEY_REQUEST (optional)\nAfter key lifetime expires
server -> client: REKEY_RESPONSE (optional)\nNew ephemeral keys

style: {
  fill: "#0f3460"
  stroke: "#8b949e"
  font-color: "#e6edf3"
}