shape: sequence_diagram
title: "Function Call Sequence Diagram: Bytecode Virtual Machine"
description: "Sequence diagram showing the interaction between the VM, the operand stack, and the call frame stack during a CALL instruction, execution of the function body, and a RETURN."

vm: VM
op_stack: "Operand Stack" {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}
frame_stack: "Call Frame Stack" {
  style.fill: "#0f3460"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}

note: |md
  ### Phase 1: CALL Instruction
  1. VM fetches CALL opcode
  2. Reads function address operand
  3. Sets up new call frame
| {
  style.fill: "#1a1a2e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
}

vm -> op_stack: PUSH args (n values)
vm -> frame_stack: "PUSH new Frame (return_address, locals, stack_ptr)"
frame_stack -> vm: Frame ready
vm -> vm: Set IP to function entry

note2: |md
  ### Phase 2: Function Body Execution
  VM executes instructions within the function:
  - PUSH/POP values on operand stack
  - Local variable access
  - Arithmetic operations
| {
  style.fill: "#1a1a2e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
}

vm -> op_stack: PUSH constant
vm -> op_stack: PUSH local_var
vm -> op_stack: BINARY_OP (pop 2, push 1)
op_stack -> vm: Result value

note3: |md
  ### Phase 3: RETURN Instruction
  1. VM fetches RETURN opcode
  2. Pops return value from operand stack
  3. Restores previous frame context
  4. Pushes return value to caller's stack
| {
  style.fill: "#1a1a2e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
}

vm -> op_stack: POP return value
vm -> frame_stack: POP current Frame
frame_stack -> vm: "Restore previous Frame (IP, locals, stack_ptr)"
vm -> op_stack: PUSH return value
vm -> vm: Resume execution at return_address
