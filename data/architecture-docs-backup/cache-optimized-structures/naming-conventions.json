{
  "types": {
    "CacheInfo": "fields: l1_size size_t, l2_size size_t, l3_size size_t, line_size size_t",
    "CacheAlignedStruct": "fields: data int[16]",
    "TimingStats": "fields: iterations size_t, total_ns uint64_t, min_ns uint64_t, max_ns uint64_t, avg_ns double, stddev_ns double",
    "PerfCounterData": "fields: l1_cache_misses uint64_t, l1_cache_refs uint64_t, llc_cache_misses uint64_t, llc_cache_refs uint64_t, instructions_retired uint64_t, cpu_cycles uint64_t",
    "RunMetrics": "fields: config_label char[256], timing TimingStats, perf_counters PerfCounterData, cache_info CacheInfo",
    "BenchmarkResult": "fields: benchmark_name char[256], system_info char[1024], num_runs size_t, runs RunMetrics*",
    "Particle": "fields: x double, y double, z double, vx double, vy double, vz double",
    "ParticleSystemSoA": "fields: capacity size_t, size size_t, x double*, y double*, z double*, vx double*, vy double*, vz double*",
    "HashTableEntry": "fields: key uint64_t, value void*, probe_distance uint32_t",
    "vEBTree": "fields: data int*, size size_t, height size_t, root_index size_t",
    "Matrix": "fields: data double*, rows size_t, cols size_t, stride size_t",
    "PerfCounterGroup": "fields: leader_fd int, num_counters int, counter_fds int[MAX_PERF_COUNTERS], counter_types uint32_t[MAX_PERF_COUNTERS], counter_configs uint64_t[MAX_PERF_COUNTERS]",
    "CacheFriendlyHashTable": "fields: keys uint64_t*, values void**, metadata uint8_t*, capacity size_t, size size_t, tombstones size_t, max_load_factor double",
    "DerivedMetrics": "fields: l1_hit_rate double, llc_hit_rate double, ipc double, data_rate double, efficiency_score double",
    "ComparisonResult": "fields: speedup double, l1_miss_reduction double, llc_miss_reduction double, effective int, insight char[256]",
    "PlotData": "fields: x_values double*, y_series double**, num_points size_t, num_series size_t, series_labels char**",
    "AccessTrace": "fields: addresses uintptr_t*, capacity size_t, count size_t",
    "PaddedLock": "fields: lock pthread_spinlock_t, padding uint8_t[CACHE_LINE_SIZE - sizeof(pthread_spinlock_t)]",
    "StripedHashTable": "fields: base_table CacheFriendlyHashTable, stripes PaddedLock[STRIPE_COUNT]"
  },
  "methods": {
    "align_to_cache_line(void* ptr) returns void*": "align pointer to cache line boundary",
    "aligned_alloc_cache_line(size_t size) returns void*": "allocate cache-line aligned memory",
    "aligned_free_cache_line(void* ptr) returns void": "free cache-line aligned memory",
    "get_time_ns() returns uint64_t": "Get high-resolution monotonic timestamp in nanoseconds",
    "detect_cache_sizes() returns CacheInfo": "Detect cache hierarchy sizes by measuring access latency",
    "particle_system_soa_init(ParticleSystemSoA* sys, size_t capacity) returns int": "Initializes a SoA particle system",
    "perf_counters_start(PerfCounterGroup* group) returns void": "Start all performance counters in a group",
    "perf_counters_stop(PerfCounterGroup* group, PerfCounterData* data) returns void": "Stop counters and read values into data structure",
    "perf_counters_init_standard(PerfCounterGroup* group) returns int": "Initialize standard counter group for cache benchmarking",
    "perf_counters_cleanup(PerfCounterGroup* group) returns void": "Clean up performance counter resources",
    "run_benchmark(const char* config_label, void (*operation)(void*), void* operation_data, size_t iterations, size_t num_measurements) returns RunMetrics": "Run a benchmark with timing and performance counter collection",
    "particle_system_aos_init(Particle* array, size_t capacity) returns int": "Allocates and initializes an AoS particle array",
    "particle_system_aos_update_positions(Particle* particles, size_t count, double dt) returns void": "Updates all particle positions using their velocities",
    "particle_system_aos_update_velocities_y(Particle* particles, size_t count, double gravity) returns void": "Applies gravity to only the y-velocity component",
    "particle_system_soa_destroy(ParticleSystemSoA* sys) returns void": "Destroys a SoA particle system and frees memory",
    "particle_system_soa_update_positions(ParticleSystemSoA* sys, double dt) returns void": "Updates all positions using velocities in SoA layout",
    "particle_system_soa_update_velocities_y(ParticleSystemSoA* sys, double gravity) returns void": "Applies gravity to only the y-velocity array",
    "particle_system_soa_simd_update_positions(ParticleSystemSoA* sys, double dt) returns void": "SIMD-optimized version of position update for SoA",
    "hash_table_create(size_t initial_capacity) returns CacheFriendlyHashTable*": "Creates a new cache-friendly hash table with given initial capacity",
    "hash_table_destroy(CacheFriendlyHashTable* ht) returns void": "Destroys hash table and frees all resources",
    "hash_table_insert(CacheFriendlyHashTable* ht, uint64_t key, void* value) returns int": "Inserts key-value pair using Robin Hood hashing, returns 0 on success",
    "hash_table_lookup(CacheFriendlyHashTable* ht, uint64_t key) returns void*": "Looks up key and returns associated value or NULL",
    "hash_table_delete(CacheFriendlyHashTable* ht, uint64_t key) returns int": "Deletes key, marking slot as tombstone, returns 0 if found",
    "veb_tree_build(sorted_input, size) returns vEBTree": "Builds a vEB tree from a sorted array",
    "veb_tree_search(tree, key) returns int": "Searches for a key in the vEB tree, returns index or -1",
    "veb_tree_free(tree) returns void": "Frees the vEB tree's data array.",
    "complete_tree_height(n) returns size_t": "Calculates height of a complete tree with n nodes.",
    "perfect_tree_size(h) returns size_t": "Calculates nodes in a perfect tree of height h.",
    "veb_top_size(h) returns size_t": "Calculates size of top subtree in vEB split.",
    "veb_bottom_size(h) returns size_t": "Calculates size of one bottom subtree in vEB split.",
    "veb_layout_recursive(src, src_start, n, height, dest, dest_start) returns void": "Recursively lays out a subtree into vEB order.",
    "matrix_allocate(rows, cols, align_elements) returns Matrix": "Allocates a matrix with aligned rows",
    "matrix_free(mat) returns void": "Frees matrix memory",
    "matrix_fill_random(mat) returns void": "Fills matrix with random values",
    "matrix_equals(a, b, tolerance) returns int": "Compares two matrices within tolerance",
    "matrix_multiply_naive(a, b, c) returns void": "Baseline naive matrix multiplication",
    "matrix_multiply_blocked(a, b, c, block_size) returns void": "Cache-blocked matrix multiplication",
    "matrix_transpose_blocked(src, dst, block_size) returns void": "Blocked matrix transposition",
    "autotune_block_size(matrix_size) returns size_t": "Empirically determines optimal block size",
    "calculate_derived_metrics(const RunMetrics* metrics, DerivedMetrics* derived) returns void": "Calculate derived cache efficiency metrics from raw measurements",
    "compare_benchmark_results(const RunMetrics* baseline, const RunMetrics* optimized, ComparisonResult* comparison) returns int": "Compare two benchmark configurations and calculate speedup",
    "generate_cache_size_sweep_plot(const RunMetrics* results, size_t num_results, PlotData* plot_data) returns void": "Generate visualization data for cache behavior analysis",
    "run_full_benchmark_suite(const char* output_dir, int quick_mode) returns int": "Run complete benchmark suite across all milestones",
    "run_milestone2_benchmarks(const CacheInfo* cache_info, PerfCounterGroup* perf_group, int quick_mode) returns RunMetrics*": "Run Milestone 2 benchmark suite and return results",
    "align_to_cache_line(ptr) returns void*": "align pointer to cache line boundary",
    "aligned_alloc_cache_line(size) returns void*": "allocate cache-line aligned memory",
    "particle_system_soa_init(sys, capacity) returns int": "Initializes a SoA particle system",
    "perf_counters_start(group) returns void": "Start all performance counters in a group",
    "perf_counters_stop(group, data) returns void": "Stop counters and read values into data structure",
    "run_benchmark(config_label, operation, operation_data, iterations, num_measurements) returns RunMetrics": "Run a benchmark with timing and performance counter collection",
    "hash_table_create(initial_capacity) returns CacheFriendlyHashTable*": "Creates a new cache-friendly hash table with given initial capacity",
    "hash_table_insert(ht, key, value) returns int": "Inserts key-value pair using Robin Hood hashing, returns 0 on success",
    "hash_table_lookup(ht, key) returns void*": "Looks up key and returns associated value or NULL",
    "calculate_derived_metrics(metrics, derived) returns void": "Calculate derived cache efficiency metrics from raw measurements",
    "compare_benchmark_results(baseline, optimized, comparison) returns int": "Compare two benchmark configurations and calculate speedup",
    "generate_cache_size_sweep_plot(results, num_results, plot_data) returns void": "Generate visualization data for cache behavior analysis",
    "run_full_benchmark_suite(output_dir, quick_mode) returns int": "Run complete benchmark suite across all milestones",
    "run_milestone2_benchmarks(cache_info, perf_group, quick_mode) returns RunMetrics*": "Run Milestone 2 benchmark suite and return results",
    "particle_system_soa_update_positions(sys, dt) returns void": "Updates all positions using velocities in SoA layout",
    "particle_system_aos_update_positions(particles, count, dt) returns void": "Updates all particle positions using their velocities",
    "print_cache_line(addr) returns void": "Prints the 64-byte cache line containing the given address",
    "print_hash_table_state(ht) returns void": "Prints the internal state of a hash table for debugging",
    "access_trace_create(capacity) returns AccessTrace*": "Creates a new memory access tracer",
    "access_trace_record(trace, addr) returns void": "Records a memory access in the trace",
    "access_trace_dump(trace, filename) returns void": "Writes trace data to a file",
    "access_trace_free(trace) returns void": "Frees trace resources",
    "detect_false_sharing(num_threads, iterations) returns": "benchmark to demonstrate false sharing effects",
    "striped_hash_table_insert(sht, key, value) returns": "thread-safe insertion with striped locking",
    "striped_hash_table_lookup(sht, key) returns": "thread-safe lookup with striped locking",
    "cache_oblivious_merge(src, left_len, right_len, dst) returns": "recursive cache-oblivious merge algorithm",
    "cache_oblivious_mergesort(arr, n, buffer) returns": "main cache-oblivious sorting routine"
  },
  "constants": {
    "CACHE_LINE_SIZE": "64",
    "CLOCK_MONOTONIC": "System-wide monotonic clock identifier for clock_gettime",
    "MAX_LABEL_LEN": "256",
    "MAX_SYS_INFO_LEN": "1024",
    "MAX_PERF_COUNTERS": "Maximum number of performance counters in a group (e.g., 8)",
    "PERF_TYPE_HW_CACHE": "Hardware cache event type for perf_event_open",
    "PERF_COUNT_HW_CACHE_L1D": "L1 data cache identifier",
    "PERF_COUNT_HW_CACHE_OP_READ": "Cache read operation",
    "PERF_COUNT_HW_CACHE_RESULT_MISS": "Cache miss result",
    "PERF_COUNT_HW_CACHE_RESULT_ACCESS": "Cache access result",
    "USE_SIMD": "Preprocessor flag for SIMD compilation",
    "SLOT_OCCUPIED": "0x80 (metadata flag)",
    "SLOT_TOMBSTONE": "0x40 (metadata flag)",
    "PREFETCH_DISTANCE": "4 (cache lines to prefetch ahead)",
    "BLOCK_SIZE": "Candidate tile dimension for blocking (not a single constant, but a parameter)",
    "DEBUG": "Preprocessor flag to enable debug prints",
    "TRACE_ACCESSES": "Preprocessor flag to enable memory access tracing",
    "STRIPE_COUNT": "number of lock stripes (power of two)"
  },
  "terms": {
    "spatial locality": "Tendency to access nearby memory locations",
    "temporal locality": "Tendency to access same memory locations repeatedly",
    "cache line": "Unit of data transfer between cache levels and main memory (typically 64 bytes)",
    "prefetching": "Predictive loading of data into cache before it's explicitly requested",
    "false sharing": "multiple cores modifying different variables in same cache line, causing unnecessary cache invalidations",
    "row-major order": "Matrix storage where elements of a row are contiguous in memory",
    "probe distance": "Number of slots an entry is from its ideal hash position",
    "vEB layout": "van Emde Boas layout, a recursive memory ordering for trees",
    "pointer-chasing": "Access pattern where each memory access provides the address for the next access, defeating hardware prefetching",
    "performance counters": "CPU hardware registers that count microarchitectural events like cache misses",
    "SIMD": "Single Instruction Multiple Data, parallel processing of multiple data elements with one instruction",
    "vectorization": "Process of converting scalar operations to SIMD operations",
    "open addressing": "Hash collision resolution where all entries are stored directly in the array",
    "linear probing": "Open addressing by checking consecutive slots",
    "Robin Hood hashing": "Variance-reducing technique swapping entries during insertion",
    "load factor": "Ratio of occupied slots to total capacity",
    "tombstone": "Marker for deleted slot that preserves probe chain",
    "cache-oblivious": "Algorithm designed to perform well across any cache hierarchy without explicit tuning",
    "van Emde Boas layout": "A recursive memory ordering for binary trees that minimizes cache misses",
    "complete binary tree": "A binary tree where every level is fully filled except possibly the last, which is filled left to right.",
    "perfect binary tree": "A binary tree where all internal nodes have two children and all leaves are at the same depth.",
    "loop tiling": "Restructuring loops to operate on data blocks that fit in cache",
    "cache blocking": "Same as loop tiling, applied to exploit cache hierarchy",
    "stride": "Number of elements between successive rows in a matrix, allowing for padding and alignment",
    "measure-modify-verify cycle": "Systematic approach to optimization: measure baseline, implement change, verify improvement",
    "property-based testing": "Testing approach that verifies invariants hold for randomly generated inputs",
    "statistical significance": "Statistical measure indicating whether an observed difference is likely real rather than due to random variation",
    "confidence interval": "Range of values that is likely to contain the true value of a parameter",
    "performance regression": "Unintended degradation in performance after a code change",
    "cache miss ratio": "Percentage of cache accesses that result in misses",
    "instructions per cycle (IPC)": "Measure of how many instructions are executed per CPU clock cycle",
    "forensic scientist": "Mental model for debugging cache issues by analyzing indirect evidence",
    "cache microscope": "Mental model for tools that reveal cache behavior at different levels of detail",
    "coalesced memory access": "GPU threads in a warp accessing contiguous memory addresses for efficient memory transactions",
    "cache-oblivious sorting": "sorting algorithms designed to be cache-efficient without knowledge of cache parameters",
    "striped locking": "locking scheme where locks are assigned to fixed-size segments (stripes) of a data structure",
    "bank conflict": "GPU shared memory access pattern where multiple threads access the same memory bank simultaneously, causing serialization"
  }
}