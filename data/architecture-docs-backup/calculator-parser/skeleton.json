{
  "title": "Calculator Parser: Design Document",
  "overview": "This system parses and evaluates mathematical expressions, transforming a string like \"2 + 3 * (4 - 1)\" into a numeric result. The key architectural challenge is designing a parser that correctly interprets operator precedence (multiplication before addition) and associativity (left-to-right versus right-to-left), requiring a structured approach to dissect and evaluate expressions.",
  "sections": [
    {
      "id": "context",
      "title": "1. Context and Problem Statement",
      "summary": "Explains why evaluating expressions from a string is a non-trivial parsing problem, introduces key concepts like precedence and associativity with analogies, and compares common parsing strategies.",
      "subsections": [
        {
          "id": "analogy",
          "title": "Mental Model: The Order of Operations Puzzle",
          "summary": "Uses the analogy of a chef following a recipe with nested instructions to explain why a simple left-to-right scan is insufficient for evaluating expressions."
        },
        {
          "id": "problem-statement",
          "title": "Core Problem: From String to Structure",
          "summary": "Defines the challenge of converting a flat sequence of characters into a hierarchical structure (an expression tree) that encodes the intended order of calculations."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Parsing Strategies",
          "summary": "Compares Recursive Descent and Pratt (Operator-Precedence) parsing methods with a table of their trade-offs, suitable for a beginner's implementation journey."
        }
      ]
    },
    {
      "id": "goals",
      "title": "2. Goals and Non-Goals",
      "summary": "Defines the mandatory features (arithmetic, unary, variables) and explicit limitations (no loops, custom functions) to scope the project for learners.",
      "subsections": [
        {
          "id": "must-do",
          "title": "Goals (Must-Have Features)",
          "summary": "Lists the arithmetic operators, precedence rules, unary negation, exponentiation, variables, and built-in functions the calculator must support, mapped to the three milestones."
        },
        {
          "id": "wont-do",
          "title": "Non-Goals (Explicitly Out of Scope)",
          "summary": "Clarifies that this is not a general-purpose language; excludes user-defined functions, loops, conditionals, and advanced data types to keep the project focused."
        }
      ]
    },
    {
      "id": "high-level-arch",
      "title": "3. High-Level Architecture",
      "summary": "Presents the core pipeline of Lexer, Parser, and Evaluator components, describes their data flow, and provides a recommended file structure for the codebase.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Architecture Pipeline: Lex, Parse, Evaluate",
          "summary": "Describes the three-stage transformation of an input string into a result, explaining the role of each component in the pipeline."
        },
        {
          "id": "file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Suggests a clean Python project layout with modules for tokens, lexer, parser, AST nodes, evaluator, and environment, promoting separation of concerns."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core data types: Tokens (the lexical units), AST Node types (the expression tree structure), and the Environment (a symbol table for variables).",
      "subsections": [
        {
          "id": "tokens",
          "title": "Token Types",
          "summary": "Lists and describes all token types (NUMBER, PLUS, MINUS, IDENTIFIER, etc.) that the lexer produces from the input string."
        },
        {
          "id": "ast-nodes",
          "title": "Abstract Syntax Tree (AST) Nodes",
          "summary": "Describes the class hierarchy for AST nodes (Number, UnaryOp, BinaryOp, Assign, Variable, FunctionCall) that represent the parsed expression structure."
        },
        {
          "id": "environment",
          "title": "Environment (Symbol Table)",
          "summary": "Describes the dictionary-like structure that maps variable names to their stored numeric values during evaluation."
        }
      ]
    },
    {
      "id": "lexer",
      "title": "5. Component Design: Lexer (Tokenizer)",
      "summary": "Details the component that scans the input string character by character to produce a sequence of meaningful tokens.",
      "subsections": [
        {
          "id": "lexer-mental-model",
          "title": "Mental Model: The Text Scanner",
          "summary": "Compares the lexer to a person reading a sentence and identifying individual words and punctuation marks, ignoring whitespace."
        },
        {
          "id": "lexer-interface",
          "title": "Interface",
          "summary": "Defines the primary method `tokenize()` that consumes a string and returns a list of Token objects."
        },
        {
          "id": "lexer-algorithm",
          "title": "Internal Algorithm",
          "summary": "Step-by-step procedure for scanning characters, building multi-character tokens like numbers and identifiers, and handling edge cases."
        },
        {
          "id": "lexer-adr",
          "title": "ADR: Lexer Token Granularity",
          "summary": "Decision record on whether to treat `-` as a single token type or distinguish between unary and binary minus at the lexer stage."
        },
        {
          "id": "lexer-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Covers issues like mishandling floating-point numbers, forgetting to skip whitespace, and correctly detecting the end of input."
        },
        {
          "id": "lexer-implementation",
          "title": "Implementation Guidance (Python)",
          "summary": "Provides skeleton code for the `Lexer` class and `Token` dataclass with TODOs for the core scanning logic."
        }
      ]
    },
    {
      "id": "parser",
      "title": "6. Component Design: Parser",
      "summary": "Details the component that consumes tokens to build an Abstract Syntax Tree (AST) according to grammar rules for precedence and associativity.",
      "subsections": [
        {
          "id": "parser-mental-model",
          "title": "Mental Model: The Grammar Rule Enforcer",
          "summary": "Uses the analogy of a traffic controller assigning vehicles to lanes based on priority to explain how precedence is enforced."
        },
        {
          "id": "parser-interface",
          "title": "Interface",
          "summary": "Defines the primary method `parse()` that consumes a list of tokens and returns the root AST Node."
        },
        {
          "id": "parser-algorithm",
          "title": "Internal Algorithm (Recursive Descent)",
          "summary": "Step-by-step recursive procedures for parsing expressions, handling binary operators, unary operators, primary literals, and parentheses."
        },
        {
          "id": "parser-adr",
          "title": "ADR: Parser Strategy Choice",
          "summary": "Decision record comparing Recursive Descent vs. Pratt Parsing and justifying the choice of Recursive Descent for clarity and beginner-friendliness."
        },
        {
          "id": "parser-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Covers infinite recursion, incorrect precedence handling, misinterpreting associativity, and failing to report syntax errors with context."
        },
        {
          "id": "parser-implementation",
          "title": "Implementation Guidance (Python)",
          "summary": "Provides skeleton code for the `Parser` class with recursive methods (`parse_expression`, `parse_term`, etc.) and AST node classes with TODOs."
        }
      ]
    },
    {
      "id": "evaluator",
      "title": "7. Component Design: Evaluator",
      "summary": "Details the component that traverses the AST, executing the operations it represents to produce a final numeric value.",
      "subsections": [
        {
          "id": "evaluator-mental-model",
          "title": "Mental Model: The Tree Walker",
          "summary": "Compares evaluating the AST to a warehouse worker following a nested packing slip, opening each box (node) to perform its operation."
        },
        {
          "id": "evaluator-interface",
          "title": "Interface",
          "summary": "Defines the `evaluate()` method that takes an AST Node and an Environment, returning a numeric result."
        },
        {
          "id": "evaluator-algorithm-steps",
          "summary": "Step-by-step visitor-like procedure for recursively evaluating each type of AST node (Number, BinaryOp, UnaryOp, etc.).",
          "title": "Internal Algorithm"
        },
        {
          "id": "evaluator-adr",
          "title": "ADR: Evaluation Strategy",
          "summary": "Decision record on using a recursive tree walk versus compiling to bytecode, favoring simplicity for educational purposes."
        },
        {
          "id": "evaluator-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Covers division by zero, incorrect handling of variable assignment vs. lookup, and floating-point precision issues in power operations."
        },
        {
          "id": "evaluator-implementation",
          "title": "Implementation Guidance (Python)",
          "summary": "Provides skeleton code for the `Evaluator` class with an `evaluate` method and helper functions for built-ins, with TODOs for each node type."
        }
      ]
    },
    {
      "id": "interactions",
      "title": "8. Interactions and Data Flow",
      "summary": "Describes the step-by-step sequence of how components interact to process an expression, using a concrete example.",
      "subsections": [
        {
          "id": "sequence-walkthrough",
          "title": "End-to-End Walkthrough: \"x = 2 + 3 * 4\"",
          "summary": "Traces the flow of data from the input string through lexing, parsing, and evaluation, showing the state of tokens, AST, and environment at each stage."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "9. Error Handling and Edge Cases",
      "summary": "Categorizes potential errors (lexical, syntactic, semantic, runtime) and defines strategies for detection and user-friendly reporting.",
      "subsections": [
        {
          "id": "error-categories",
          "title": "Error Categories and Detection",
          "summary": "Defines Lexical (unknown character), Syntactic (mismatched parens), Semantic (undefined variable), and Runtime (division by zero) errors, and where they are caught."
        },
        {
          "id": "recovery-reporting",
          "title": "Recovery and User Reporting",
          "summary": "Advises on providing clear, contextual error messages (e.g., pointing to the location in input) and whether to attempt recovery (not required for this project)."
        }
      ]
    },
    {
      "id": "testing",
      "title": "10. Testing Strategy",
      "summary": "Provides a structured approach to verifying correctness, from unit tests for individual components to integration tests for full expressions, with milestone checkpoints.",
      "subsections": [
        {
          "id": "testing-approach",
          "title": "Testing Approach",
          "summary": "Recommends writing unit tests for Lexer, Parser, and Evaluator in isolation, followed by integration tests for the full pipeline."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "For each of the three milestones, lists example expressions to test and the expected results, helping learners validate their progress."
        }
      ]
    },
    {
      "id": "debugging",
      "title": "11. Debugging Guide",
      "summary": "A symptom-cause-fix table for common bugs, along with techniques for inspecting the token stream and AST structure.",
      "subsections": [
        {
          "id": "common-bugs",
          "title": "Common Bugs: Symptom \u2192 Cause \u2192 Fix",
          "summary": "Table listing issues like \"2+3*4 equals 20\", \"--5 causes error\", or \"variable not found\", with their likely causes and corrective actions."
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques",
          "summary": "Suggests adding debug prints to output the token list and a visual representation of the AST to verify the parser's output."
        }
      ]
    },
    {
      "id": "extensions",
      "title": "12. Future Extensions",
      "summary": "Suggests potential advanced features learners could add later, like more operators, functions, or a REPL, noting design accommodations.",
      "subsections": [
        {
          "id": "potential-features",
          "title": "Potential Features",
          "summary": "Lists ideas for extending the calculator: additional math functions, constants (pi, e), comparison operators, a REPL interface, or persistent variables."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "13. Glossary",
      "summary": "Defines key technical terms used throughout the document, such as AST, Precedence, Associativity, and Recursive Descent.",
      "subsections": [
        {
          "id": "terms",
          "title": "Terms and Definitions",
          "summary": "Alphabetical list of terms with clear definitions and references to the section where they are first introduced."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-comp",
      "title": "System Component Diagram",
      "description": "Shows the three main components (Lexer, Parser, Evaluator) and their data flow: Input String \u2192 Tokens \u2192 AST \u2192 Number. Also shows the Environment (symbol table) interacting with the Evaluator.",
      "type": "component",
      "relevant_sections": [
        "high-level-arch"
      ]
    },
    {
      "id": "ast-example",
      "title": "Example Abstract Syntax Tree (AST)",
      "description": "A class diagram showing the hierarchy of AST Node types (Number, BinaryOp, UnaryOp, etc.) and a concrete tree visualization for the expression \"2 + 3 * (4 - 1)\".",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "parser"
      ]
    },
    {
      "id": "parsing-flow",
      "title": "Parsing Expression Flowchart",
      "description": "A flowchart depicting the recursive descent parsing algorithm for an expression, showing the call chain from parse_expression down to parse_primary and the precedence climbing logic.",
      "type": "flowchart",
      "relevant_sections": [
        "parser"
      ]
    },
    {
      "id": "eval-sequence",
      "title": "Evaluation Sequence Diagram",
      "description": "A sequence diagram showing the interaction between the Evaluator and the AST nodes during the evaluation of a binary operation like addition, including recursive calls to evaluate child nodes.",
      "type": "sequence",
      "relevant_sections": [
        "evaluator",
        "interactions"
      ]
    }
  ]
}