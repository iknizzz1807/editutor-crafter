{
  "types": {
    "DbError": "enumeration of all possible database errors",
    "Database": "core struct holding all subsystem components",
    "QueryResult": "enum representing result of query",
    "TableMeta": "table_id: u32, name: String, columns: Vec<ColumnMeta>, primary_key: Option<Vec<u32>>, num_rows: u64, first_heap_page: PageId, created_at: u64",
    "ColumnMeta": "column_id: u32, name: String, data_type: DataType, nullable: bool, default_value: Option<Value>, is_unique: bool",
    "IndexMeta": "index_id: u32, name: String, table_id: u32, columns: Vec<u32>, is_unique: bool, root_page_id: PageId, index_type: IndexType",
    "ConstraintMeta": "constraint_id: u32, name: String, table_id: u32, constraint_type: ConstraintType, columns: Vec<u32>, referenced_table: Option<u32>, referenced_columns: Option<Vec<u32>>, check_expr: Option<Expr>",
    "PageHeader": "page_id: PageId, page_type: PageType, lsn: Lsn, checksum: u32, next_page_id: PageId",
    "DataPageHeader": "extends PageHeader, slot_count: u16, free_space_start: u16, free_space_end: u16",
    "SlotEntry": "offset: u16, length: u16",
    "Record": "flags: u8, xmin: TransactionId, xmax: TransactionId, data: [u8]",
    "BTreeNodeHeader": "extends PageHeader, node_type: NodeType, key_count: u16, level: u16, next_leaf: PageId",
    "LeafEntry": "key: Vec<u8>, record_id: RecordId",
    "InternalEntry": "key: Vec<u8>, child_page_id: PageId",
    "LogRecord": "lsn: Lsn, prev_lsn: Lsn, transaction_id: TransactionId, type: LogRecordType, page_id: PageId, data_len: u32, data: [u8]",
    "LogicalPlan": "root: LogicalOp, output_schema: Vec<ColumnMeta]",
    "PhysicalPlan": "root: Box<dyn PhysicalOp>, output_schema: Vec<ColumnMeta>",
    "QueryContext": "txn_id: TransactionId, snapshot: Snapshot, catalog: Arc<RwLock<Database>>, buffer_pool: Arc<BufferPool>, temp_directory: PathBuf",
    "Transaction": "txn_id: TransactionId, state: TransactionState, snapshot: Snapshot, read_only: bool, write_set: Vec<PageId>, undo_log: Vec<UndoRecord>",
    "Snapshot": "snapshot_id: u64, active_txns: Vec<TransactionId>",
    "UndoRecord": "page_id: PageId, slot_id: u16, old_data: Vec<u8>",
    "RecordId": "(PageId, u16)",
    "Row": "values: Vec<Value>, record_id: RecordId, xmin: TransactionId, xmax: TransactionId",
    "Value": "enum: Null, Int(i32), BigInt(i64), Float(f64), Bool(bool), String(String), Timestamp(i64)",
    "Statement": "enum root of parsed query",
    "SelectStmt": "distinct: bool, projection: Vec<SelectItem>, from: Vec<TableWithJoins>, where_clause: Option<Expr>, group_by: Vec<Expr>, having: Option<Expr>, order_by: Vec<OrderByExpr>, limit: Option<Expr>, offset: Option<Expr>",
    "SelectItem": "enum: Wildcard or Expr with alias",
    "TableWithJoins": "relation: TableFactor, joins: Vec<Join>",
    "TableFactor": "enum: Table { name: String, alias: Option<String> } or Subquery",
    "Join": "join_operator: JoinOperator, relation: TableFactor, condition: JoinCondition",
    "Expr": "enum: ColumnRef { name: String, table: Option<String> }, Literal(Value), BinaryOp { left: Box<Expr>, op: BinaryOperator, right: Box<Expr> }, UnaryOp { op: UnaryOperator, expr: Box<Expr> }, FunctionCall { name: String, args: Vec<Expr> }, Wildcard",
    "LogicalOp": "enum: Scan(ScanOp), Filter(FilterOp), Project(ProjectOp), Join(JoinOp), Aggregate(AggregateOp), Sort(SortOp), Limit(LimitOp)",
    "ScanOp": "table_name: String, table_id: u32, output_schema: Vec<ColumnMeta>",
    "FilterOp": "condition: Expr, input: Box<LogicalOp>",
    "ProjectOp": "expressions: Vec<Expr>, input: Box<LogicalOp>",
    "CatalogManager": "tables: RwLock<HashMap<u32, Arc<TableMeta>>>, table_name_to_id: RwLock<HashMap<String, u32>>, next_table_id: AtomicU32, ...",
    "LogicalPlanner": "catalog: &'a CatalogManager, current_scope: Vec<ScopeEntry>",
    "ScopeEntry": "struct for tracking table aliases during planning",
    "Frame": "page_id: PageId, data: [u8; PAGE_SIZE], pin_count: u32, is_dirty: bool, ref_bit: bool",
    "BufferPool": "frames: Vec<Frame>, page_table: HashMap<PageId, FrameId>, clock_hand: usize, free_list: Vec<FrameId>, disk_manager: Arc<DiskManager>",
    "BufferGuard": "pool: Arc<Mutex<BufferPool>>, frame_id: FrameId, page_id: PageId, data: MutexGuard<[u8; PAGE_SIZE]>",
    "DataPage": "methods only",
    "BTreeIndex": "methods only",
    "BTreeIterator": "methods only",
    "SeqScan": "methods only",
    "TableHeap": "methods only",
    "PhysicalOp": "trait with open(), next(), close()",
    "HashJoin": "build_input: Box<dyn PhysicalOp>, probe_input: Box<dyn PhysicalOp>, build_keys: Vec<usize>, probe_keys: Vec<usize>, hash_table: HashMap<Vec<Value>, Vec<Row>>, phase: HashJoinPhase, current_probe_row: Option<Row>, current_matches: Vec<Row>, match_index: usize, output_schema: Vec<ColumnMeta>",
    "HashJoinPhase": "enum: Building, Probing, Done",
    "Aggregate": "input: Box<dyn PhysicalOp>, group_by_exprs: Vec<Expr>, aggregate_exprs: Vec<AggExpr>, groups: HashMap<Vec<Value>, Vec<Accumulator>>, output_iterator: Option<std::vec::IntoIter<Row>>",
    "WalSegment": "file: File, path: PathBuf, current_offset: u64, segment_id: u32",
    "TransactionManager": "next_txn_id: AtomicU64, active_txns: RwLock<HashMap<TransactionId, TransactionState>>, wal_writer: Arc<WalWriter>",
    "WalWriter": "current_segment: Mutex<WalSegment>, next_lsn: AtomicU64, wal_dir: PathBuf, max_segment_size: u64",
    "RecoveryManager": "wal_dir: PathBuf, buffer_pool: Arc<BufferPool>, catalog: Arc<CatalogManager>",
    "DirtyPageTable": "type alias for HashMap<PageId, Lsn>",
    "TransactionTable": "type alias for HashMap<TransactionId, (Lsn, TransactionStatus)>",
    "MessageFramer": "methods: try_parse, encode",
    "ClientMessage": "enum: Startup, Query, Parse, Bind, Execute",
    "StartupMessage": "protocol_version: i32, parameters: Vec<(String, String)>",
    "QueryMessage": "query_string: String",
    "PgTypeInfo": "oid: u32, name: &'static str, len: i16, modifier: i32",
    "Session": "id: u64, database: Arc<Database>, transaction_status: char, prepared_statements: HashMap<String, PreparedStatement>",
    "ParserError": "enum: Syntax { position: usize, message: String }, Unsupported { feature: String }, UnexpectedEof",
    "StorageError": "enum: ChecksumMismatch { page_id: PageId, expected: u32, actual: u32 }, CorruptPage { page_id: PageId, reason: String }, DiskFull { page_id: PageId }, Io { page_id: PageId, source: io::Error }",
    "TestHarness": "temp_dir: TempDir, db: Database",
    "BTreeOperation": "enum: Insert { key: i32, value: String }, Delete { key: i32 }, Lookup { key: i32 }",
    "DiagnosticsRegistry": "counters: HashMap<&'static str, AtomicU64>",
    "ExplainDebugExecutor": "struct with methods",
    "DebugCommand": "enum: BufferPool, BTree { index_name: String }, Transactions, Page { page_id: u32 }, Wal { since_lsn: Option<u64> }",
    "PreparedStatement": "name: String, sql_text: String, statement: Statement, logical_plan: LogicalPlan, param_types: Vec<Value>, created_at: Instant",
    "StatementCache": "cache: RwLock<LruCache<String, Arc<PreparedStatement>>>, max_size: usize",
    "CacheStats": "size: usize, max_size: usize, hit_rate: f64",
    "VectorizedFilter": "input: Box<dyn PhysicalOp>, condition: Expr, current_batch: Option<Batch>, selected_indices: Vec<usize>, current_index: usize",
    "QueryParams": "positional: Vec<Value>, named: HashMap<String, Value>",
    "LockFreeStatementCache": "cache: dashmap::DashMap<String, PreparedStatement>",
    "ShardManager": "shards: HashMap<ShardId, ShardInfo>, routing_table: RangeMap<ShardKey, ShardId>",
    "ShardInfo": "node_address: String, key_range: Range<ShardKey>, status: ShardStatus",
    "ColumnarTable": "columns: HashMap<ColumnId, ColumnChunk>, row_groups: Vec<RowGroupMeta>",
    "ColumnChunk": "data: Vec<u8>, null_bitmap: Vec<u8>, dictionary: Option<Vec<Value>>, stats: ColumnStats",
    "Batch": "columns: Vec<ColumnVector>, size: usize"
  },
  "methods": {
    "Database::new(data_dir: &str) -> Result<Self>": "initializes database from data directory",
    "Database::execute(sql: &str) -> Result<QueryResult>": "parses, plans, executes SQL statement",
    "Database::shutdown(self) -> Result<()>": "gracefully shuts down database",
    "DataPage::insert_record(&mut self, record: &[u8], flags: u8, xmin: TransactionId, xmax: TransactionId) -> Result<u16, DbError>": "inserts record into page",
    "Snapshot::is_visible(&self, row_xmin: TransactionId, row_xmax: TransactionId, current_txn_id: TransactionId) -> bool": "determines row visibility",
    "BTreeIndex::get(&self, key: &[u8], txn_id: TransactionId) -> Result<Option<RecordId>, DbError>": "finds RecordId for key",
    "Parser::new(sql: &str) -> Result<Self>": "constructs parser",
    "Parser::parse_statement(&mut self) -> Result<Statement>": "parses SQL statement",
    "CatalogManager::get_table_by_name(&self, name: &str) -> Result<Arc<TableMeta>>": "looks up table by name",
    "CatalogManager::create_table(&self, stmt: &CreateTableStmt, txn_id: TransactionId) -> Result<u32>": "creates table in catalog",
    "LogicalPlanner::build_plan(&mut self, stmt: &Statement) -> Result<LogicalPlan>": "transforms AST to logical plan",
    "LogicalPlanner::resolve_column_ref(&self, col: &ColumnRef) -> Result<(u32, u32)>": "resolves column reference",
    "BufferPool::new(num_frames: usize, disk_manager: Arc<DiskManager>) -> Self": "creates buffer pool",
    "BufferPool::fetch_page(page_id: PageId) -> Result<BufferGuard, DbError>": "fetches page from buffer pool",
    "BufferPool::find_victim(&mut self) -> Option<usize>": "finds victim frame using clock algorithm",
    "DataPage::insert_record(&mut self, record: &[u8], flags: u8, xmin: u64, xmax: u64) -> Result<u16, DbError>": "inserts record into page",
    "DataPage::compact(&mut self) -> Result<(), DbError>": "compacts page",
    "PhysicalOp::open(&mut self, context: &QueryContext) -> Result<()>": "initializes operator state",
    "PhysicalOp::next(&mut self, context: &QueryContext) -> Result<Option<Row>>": "returns next row",
    "PhysicalOp::close(&mut self, context: &QueryContext) -> Result<()>": "cleans up resources",
    "execute_plan(plan: &mut PhysicalPlan, context: &QueryContext) -> Result<Vec<Row>>": "executes entire plan",
    "Snapshot::is_visible(row_xmin: TransactionId, row_xmax: TransactionId, current_txn_id: TransactionId) -> bool": "determines row visibility",
    "TransactionManager::begin_transaction(read_only: bool) -> Result<Transaction, DbError>": "starts new transaction",
    "TransactionManager::commit_transaction(txn: &mut Transaction) -> Result<(), DbError>": "commits transaction",
    "TransactionManager::abort_transaction(txn: &mut Transaction) -> Result<(), DbError>": "aborts transaction",
    "TransactionManager::create_snapshot() -> Snapshot": "creates snapshot",
    "TransactionManager::is_visible(snapshot: &Snapshot, xmin: TransactionId, xmax: TransactionId, current_txn_id: TransactionId) -> bool": "checks row visibility",
    "WalWriter::append_record(record: &LogRecord) -> Result<Lsn, DbError>": "appends record to WAL",
    "WalWriter::append_and_sync(record: &LogRecord) -> Result<Lsn, DbError>": "appends and forces to disk",
    "WalWriter::checkpoint() -> Result<(), DbError>": "creates checkpoint",
    "RecoveryManager::recover() -> Result<(), DbError>": "performs crash recovery",
    "RecoveryManager::analysis_pass(checkpoint_lsn: Lsn) -> Result<(DirtyPageTable, TransactionTable), DbError>": "analysis phase of recovery",
    "RecoveryManager::redo_pass(redo_lsn: Lsn, dirty_page_table: &DirtyPageTable) -> Result<(), DbError>": "redo phase",
    "RecoveryManager::undo_pass(transaction_table: &TransactionTable) -> Result<(), DbError>": "undo phase",
    "WalSegment::create(path: &Path, segment_id: u32) -> Result<Self, DbError>": "creates new WAL segment",
    "WalSegment::open(path: &Path, segment_id: u32) -> Result<Self, DbError>": "opens existing segment",
    "WalSegment::append(data: &[u8]) -> Result<u64, DbError>": "appends data to segment",
    "WalSegment::sync() -> Result<(), DbError>": "forces segment to disk",
    "WalSegment::read_record(offset: u64) -> Result<Vec<u8>, DbError>": "reads record at offset",
    "WalSegment::is_full() -> bool": "checks if segment full",
    "Session::handle_message(message) returns Result<Vec<ServerMessage>, DbError>": "processes client message",
    "Session::row_to_data_row(row) returns DataRow": "converts row to protocol DataRow",
    "Session::build_row_description(columns) returns RowDescription": "builds field descriptions",
    "BufferPool::fetch_page(page_id: PageId) returns Result<BufferGuard, DbError>": "fetches page with checksum validation",
    "BufferPool::recover_page_from_wal(page_id: PageId) returns Result<Vec<u8>, DbError>": "recovers corrupt page from WAL",
    "DiskManager::read_page(page_id: PageId) returns Result<[u8; PAGE_SIZE], DbError>": "reads page with checksum verification",
    "TestHarness::new() returns TestHarness": "creates test database",
    "TestHarness::exec(sql &str) returns Vec<Vec<String>>": "executes SQL and returns string results",
    "TestHarness::assert_query(sql &str, expected &[&[&str]]) returns ()": "compares query results",
    "DiagnosticsRegistry::new() returns Self": "creates registry",
    "DiagnosticsRegistry::register_counter(name) returns": "adds counter",
    "DiagnosticsRegistry::increment(name) returns": "increments counter",
    "DiagnosticsRegistry::get_all() returns HashMap<&'static str, u64>": "returns all counter values",
    "ExplainDebugExecutor::execute(command, catalog, buffer_pool, txn_mgr) returns Result<String, DbError>": "executes debug command",
    "StatementCache::new(max_size usize) returns Self": "creates cache",
    "StatementCache::get(name &str) returns Option<Arc<PreparedStatement>>": "gets prepared statement",
    "StatementCache::put(stmt PreparedStatement) returns Result<(), DbError>": "stores prepared statement",
    "StatementCache::remove(name &str) returns Option<Arc<PreparedStatement>>": "removes statement",
    "StatementCache::clear() returns ()": "clears cache",
    "StatementCache::stats() returns CacheStats": "gets cache statistics",
    "VectorizedFilter::new(input Box<dyn PhysicalOp>, condition Expr) returns Self": "creates vectorized filter",
    "VectorizedFilter::evaluate_batch(batch &Batch, context &QueryContext) returns Result<Vec<usize>, DbError>": "evaluates filter on batch",
    "VectorizedFilter::next_batch(context &QueryContext, output_batch &mut Batch) returns Result<usize, DbError>": "gets next batch of filtered rows",
    "validate_params(param_types &[DataType], params &QueryParams) returns Result<(), DbError>": "validates parameters"
  },
  "constants": {
    "INVALID_PAGE_ID": "0xFFFFFFFF",
    "PAGE_SIZE": "4096",
    "WAL_SEGMENT_SIZE": "16MB",
    "WAL_HEADER_SIZE": "32 bytes",
    "PG_TYPE_INT4": "oid 23, name 'int4', len 4",
    "PG_TYPE_TEXT": "oid 25, name 'text', len -1"
  },
  "terms": {
    "Monolithic Single-Node": "all DBMS components run in single process",
    "ACID": "Atomicity, Consistency, Isolation, Durability",
    "MVCC": "Multi-Version Concurrency Control",
    "WAL": "Write-Ahead Log",
    "B-tree": "self-balancing tree for sorted data",
    "Snapshot Isolation": "isolation level with consistent snapshot",
    "Write Skew": "snapshot isolation anomaly",
    "Result": "std::result::Result<T, DbError>",
    "PageId": "u32 identifier for page",
    "TransactionId": "u64 identifier for transaction",
    "Lsn": "u64 Log Sequence Number",
    "Abstract Syntax Tree (AST)": "tree representation of SQL syntax",
    "Recursive Descent Parser": "top-down parser with recursive procedures",
    "System Catalog": "metadata about database objects",
    "Logical Plan": "relational algebra operators tree",
    "Binding": "associating names with metadata objects",
    "Slotted Page Layout": "page with slot directory at front",
    "Clock Algorithm": "approximate LRU eviction algorithm",
    "B+ Tree": "B-tree variant with all keys in leaves",
    "Table Heap": "unordered collection of data pages",
    "Sequential Scan": "iterator reading all rows from heap",
    "Volcano Iterator Model": "pull-based execution model",
    "Blocking Operator": "operator consuming all input first",
    "Cost-Based Optimizer": "planner choosing cheapest plan",
    "Selectivity": "fraction of rows satisfying condition",
    "Cardinality": "estimated number of rows",
    "Interesting Orders": "sorted output avoiding later sorts",
    "ARIES": "Algorithm for Recovery and Isolation Exploiting Semantics",
    "LSN": "Log Sequence Number",
    "Dirty Page Table": "map of modified pages",
    "Transaction Table": "map of active transactions",
    "Compensation Log Record": "record written during undo",
    "Fuzzy Checkpoint": "checkpoint without quiescent state",
    "RedoLSN": "oldest LSN for redo start",
    "Visibility Rules": "MVCC logic for row visibility",
    "Version Chain": "linked list of row versions",
    "PostgreSQL wire protocol": "binary client-server protocol",
    "Object Identifiers (OIDs)": "numeric type identifiers",
    "Session": "runtime context for client",
    "ReadyForQuery": "protocol ready message",
    "RowDescription": "protocol column description",
    "DataRow": "protocol row data message",
    "CommandComplete": "protocol command end message",
    "checksum": "hash for corruption detection",
    "fail-fast": "abort immediately on error",
    "best-effort": "continue with degraded functionality",
    "compensation log record (CLR)": "WAL record for undo redoability",
    "graceful degradation": "continue with reduced functionality",
    "property-based testing": "testing with random inputs",
    "fault injection": "deliberately introducing faults",
    "test harness": "framework managing test environment",
    "integration test": "testing multiple components together",
    "mock object": "test double simulating behavior",
    "structured logging": "logging with consistent format",
    "diagnostic interface": "API for inspecting internal state",
    "metrics counters": "atomic integers tracking counts",
    "page inspection": "examining raw page contents",
    "WAL visualization": "graphical WAL representation",
    "tracing spans": "contextual logging scopes",
    "fill factor": "percentage of page space used",
    "hybrid hash join": "hash join spilling to disk",
    "visibility rules": "MVCC logic for row visibility",
    "reduction": "simplifying test case to minimal",
    "Prepared Statements": "parsed/planned once, executed many",
    "Vectorized Execution": "processing batches of rows",
    "Secondary Indexes": "indexes on non-primary key columns",
    "Foreign Keys": "referential integrity constraints",
    "Read Replicas": "secondary nodes for reads",
    "Sharding": "horizontal data partitioning",
    "Two-Phase Commit (2PC)": "distributed transaction protocol",
    "Hybrid Logical Clocks": "clock combining physical/logical",
    "Columnar Storage": "column-wise data storage",
    "Replication Slot": "persistent replication tracking",
    "Batch Processing": "processing data in groups",
    "SIMD": "Single Instruction, Multiple Data",
    "LRU Cache": "Least Recently Used cache",
    "Query Routing": "directing queries to shards",
    "Scatter/Gather": "distributed query pattern"
  }
}