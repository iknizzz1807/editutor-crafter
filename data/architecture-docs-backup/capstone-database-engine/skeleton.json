{
  "title": "Capstone: Complete Database Engine - Design Document",
  "overview": "This project designs and builds a complete, from-scratch relational database management system (RDBMS) supporting SQL queries, ACID transactions, and client connectivity. The key architectural challenge is integrating complex subsystems\u2014parsing, planning, storage, concurrency control, and networking\u2014into a single, coherent, and correct system, much like constructing a skyscraper where every floor must perfectly align with the foundation and the electrical, plumbing, and structural systems.",
  "sections": [
    {
      "id": "context",
      "title": "Context and Problem Statement",
      "summary": "Explains the fundamental problem of data management, why building a database is complex, and compares existing architectural approaches.",
      "subsections": [
        {
          "id": "analogy",
          "title": "The Library Analogy for a Database",
          "summary": "Intuitive mental model comparing a database to a library with a catalog, shelves, librarians, and checkout system."
        },
        {
          "id": "problem",
          "title": "The Core Technical Challenge",
          "summary": "Defines the problem as reliably and efficiently storing, querying, and concurrently modifying structured data."
        },
        {
          "id": "approaches",
          "title": "Existing Architectural Approaches",
          "summary": "Compares monolithic (SQLite), client-server (PostgreSQL), and shared-nothing distributed (Google Spanner) architectures."
        }
      ]
    },
    {
      "id": "goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the scope and constraints of the educational database engine.",
      "subsections": [
        {
          "id": "must",
          "title": "Must-Have Goals",
          "summary": "Functional and non-functional requirements the system must fulfill."
        },
        {
          "id": "wont",
          "title": "Explicit Non-Goals",
          "summary": "Complex features explicitly excluded to keep the project tractable and educational."
        }
      ]
    },
    {
      "id": "high-level",
      "title": "High-Level Architecture",
      "summary": "Presents the top-level component diagram and explains the flow of a query from client to result.",
      "subsections": [
        {
          "id": "component-map",
          "title": "Architectural Component Map",
          "summary": "Overview of the five major subsystems and their responsibilities."
        },
        {
          "id": "query-flow",
          "title": "Life of a Query",
          "summary": "Step-by-step walkthrough of a SELECT statement's journey through the system."
        },
        {
          "id": "file-structure",
          "title": "Recommended Codebase Structure",
          "summary": "Suggests a modular Rust crate/workspace layout to mirror the architecture."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the core in-memory and on-disk data structures that represent schemas, data, transactions, and logs.",
      "subsections": [
        {
          "id": "catalog-types",
          "title": "Catalog and Metadata",
          "summary": "Structures for tables, columns, indexes, and constraints stored in the system catalog."
        },
        {
          "id": "storage-types",
          "title": "Storage and Page Layout",
          "summary": "Format of pages, slotted records, B-tree nodes, and WAL records on disk."
        },
        {
          "id": "execution-types",
          "title": "Execution and Transactions",
          "summary": "Structures for query plans, operator state, transaction snapshots, and MVCC metadata."
        }
      ]
    },
    {
      "id": "frontend",
      "title": "Component: SQL Frontend & Catalog (Milestone 1)",
      "summary": "Handles parsing SQL, managing metadata, and producing an initial logical query plan.",
      "subsections": [
        {
          "id": "parser",
          "title": "SQL Parser & AST",
          "summary": "Translates a string of SQL text into a structured Abstract Syntax Tree (AST)."
        },
        {
          "id": "catalog",
          "title": "System Catalog Manager",
          "summary": "The database's 'phone book', storing all metadata about tables, columns, and indexes."
        },
        {
          "id": "logical-planner",
          "title": "Logical Query Planner",
          "summary": "Transforms an AST into a naive logical plan tree of relational operators."
        }
      ]
    },
    {
      "id": "storage",
      "title": "Component: Storage Engine & B-tree (Milestone 2)",
      "summary": "Manages the durable storage of data on disk, caching, and indexed access via B+ trees.",
      "subsections": [
        {
          "id": "disk-manager",
          "title": "Disk Manager & Page Layout",
          "summary": "Abstracts the database file, reading/writing fixed-size pages with a slotted format for rows."
        },
        {
          "id": "buffer-pool",
          "title": "Buffer Pool Manager",
          "summary": "The database's 'RAM cache', keeping frequently used pages in memory and deciding which to evict."
        },
        {
          "id": "b-tree",
          "title": "B+ Tree Index",
          "summary": "A self-balancing, sorted index structure enabling fast point lookups and ordered range scans."
        },
        {
          "id": "table-heap",
          "title": "Table Heap & Scans",
          "summary": "Manages the unordered collection of row data (the heap file) and provides a sequential scan iterator."
        }
      ]
    },
    {
      "id": "execution",
      "title": "Component: Query Execution & Optimization (Milestone 3)",
      "summary": "Executes query plans efficiently using a pull-based model and optimizes them using cost estimates.",
      "subsections": [
        {
          "id": "volcano",
          "title": "Volcano Iterator Model",
          "summary": "The 'assembly line' execution model where each operator implements a simple next() interface."
        },
        {
          "id": "physical-operators",
          "title": "Physical Operators",
          "summary": "Implementations of SeqScan, IndexScan, HashJoin, SortMergeJoin, Aggregation, and Sorting."
        },
        {
          "id": "optimizer",
          "title": "Cost-Based Optimizer",
          "summary": "The 'query planner', which rewrites logical plans, picks join orders, and selects indexes based on estimated cost."
        }
      ]
    },
    {
      "id": "transactions",
      "title": "Component: Transactions & Crash Recovery (Milestone 4)",
      "summary": "Provides ACID guarantees through Multi-Version Concurrency Control (MVCC) and Write-Ahead Logging (WAL).",
      "subsections": [
        {
          "id": "mvcc-model",
          "title": "MVCC and Snapshot Isolation",
          "summary": "Allows readers and writers to not block each other by maintaining multiple versions of each row."
        },
        {
          "id": "transaction-manager",
          "title": "Transaction Manager",
          "summary": "Assigns IDs, tracks active transactions, and manages the visibility rules for snapshots."
        },
        {
          "id": "write-ahead-log",
          "title": "Write-Ahead Log (WAL)",
          "summary": "The 'flight recorder', logging all changes before they hit the main database files for crash safety."
        },
        {
          "id": "recovery",
          "title": "Crash Recovery Algorithm",
          "summary": "Process to bring the database back to a consistent state after a crash by replaying the WAL."
        }
      ]
    },
    {
      "id": "client",
      "title": "Component: Wire Protocol & Client Interface (Milestone 5)",
      "summary": "Exposes the database over the network using the PostgreSQL wire protocol for compatibility.",
      "subsections": [
        {
          "id": "protocol",
          "title": "PostgreSQL Wire Protocol",
          "summary": "The 'language' the server speaks over TCP to communicate with clients like psql."
        },
        {
          "id": "session",
          "title": "Connection and Session Management",
          "summary": "Handles client connections, authentication, query dispatch, and result serialization."
        }
      ]
    },
    {
      "id": "interactions",
      "title": "Interactions and Data Flow",
      "summary": "Describes key cross-component workflows with detailed sequence diagrams.",
      "subsections": [
        {
          "id": "select-flow",
          "title": "End-to-End SELECT with JOIN",
          "summary": "Detailed sequence of steps for a complex read query."
        },
        {
          "id": "txn-commit-flow",
          "title": "Transaction COMMIT with WAL",
          "summary": "Steps to durably commit a transaction, involving the WAL and buffer pool."
        }
      ]
    },
    {
      "id": "errors",
      "title": "Error Handling and Edge Cases",
      "summary": "Strategies for dealing with failures, corrupt data, and unexpected conditions.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "Common Failure Modes",
          "summary": "Categorizes errors from I/O failures to logic errors in query execution."
        },
        {
          "id": "recovery-strategies",
          "title": "Recovery and Graceful Degradation",
          "summary": "How different components should respond to and recover from errors."
        }
      ]
    },
    {
      "id": "testing",
      "title": "Testing Strategy",
      "summary": "A guide on how to verify the correctness and robustness of the database engine.",
      "subsections": [
        {
          "id": "verification",
          "title": "Verification Approach",
          "summary": "Recommends unit, integration, property-based, and fault-injection testing techniques."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "Specific commands and expected outputs to validate progress after each milestone."
        }
      ]
    },
    {
      "id": "debugging",
      "title": "Debugging Guide",
      "summary": "A manual for diagnosing and fixing common issues encountered during development.",
      "subsections": [
        {
          "id": "common-bugs",
          "title": "Symptom \u2192 Cause \u2192 Fix",
          "summary": "Table of frequent bugs, their root causes, and solutions."
        },
        {
          "id": "techniques",
          "title": "Diagnostic Techniques and Tools",
          "summary": "Recommendations for logging, inspection, and tracing within the database."
        }
      ]
    },
    {
      "id": "extensions",
      "title": "Future Extensions",
      "summary": "Ideas for how to extend the database engine beyond the core project.",
      "subsections": [
        {
          "id": "features",
          "title": "Potential Feature Additions",
          "summary": "Describes possible next steps like secondary indexes, prepared statements, or a REPL."
        },
        {
          "id": "scale",
          "title": "Scaling and Distribution",
          "summary": "Discusses pathways to a distributed or high-performance version."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key technical terms, acronyms, and domain-specific vocabulary used in this document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "sys-component",
      "title": "Database System Component Overview",
      "description": "A high-level component diagram showing the five main subsystems (Frontend, Storage, Execution, Transactions, Client) and their key interactions. Include data flow arrows for queries, pages, log records, and network messages.",
      "type": "component",
      "relevant_sections": [
        "high-level"
      ]
    },
    {
      "id": "data-model-erd",
      "title": "Core Data Model Entity Relationship Diagram",
      "description": "A class diagram showing key in-memory and on-disk data structures: Catalog (Database, Table, Column), Storage (Page, SlottedRecord, BTreeNode, WALRecord), and Transactions (Transaction, Snapshot). Show relationships (e.g., Table has many Columns, Page contains many SlottedRecords).",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "select-sequence",
      "title": "Sequence Diagram: Processing a SELECT Query",
      "description": "A sequence diagram tracing a SELECT statement from the Client through the Protocol Server, Parser, Planner/Optimizer, Executor (accessing Storage and B-tree), and back. Actors: Client, ProtocolServer, Parser, Optimizer, Executor, BufferPool, DiskManager.",
      "type": "sequence",
      "relevant_sections": [
        "interactions",
        "frontend",
        "execution",
        "storage"
      ]
    },
    {
      "id": "txn-state",
      "title": "Transaction State Machine",
      "description": "A state machine diagram for a database transaction. States: Active, Partially Committed (after WAL write), Committed, Aborted, Failed. Events/Transitions: Begin, Execute Statement, Commit Request, WAL Flush Success/Failure, Abort Request, Rollback Complete.",
      "type": "state-machine",
      "relevant_sections": [
        "transactions"
      ]
    },
    {
      "id": "wal-recovery-flow",
      "title": "Flowchart: WAL-Based Crash Recovery",
      "description": "A flowchart detailing the crash recovery process. Start at 'Crash Detected'. Steps: Identify last checkpoint, read WAL from checkpoint, Analysis pass (build dirty page table), Redo pass (reapply all updates), Undo pass (rollback uncommitted transactions), finalize. Decision points for log record types.",
      "type": "flowchart",
      "relevant_sections": [
        "transactions"
      ]
    },
    {
      "id": "btree-ops",
      "title": "B+ Tree Insert and Page Split",
      "description": "A sequence of diagrams (1-4) showing the state of a B+ tree before insert, during an insert causing a leaf split, the propagation of the split up the tree, and the final state after a root split. Focus on key movements and new page allocation.",
      "type": "flowchart",
      "relevant_sections": [
        "storage"
      ]
    },
    {
      "id": "volcano-pipeline",
      "title": "Volcano Iterator Model Pipeline",
      "description": "A diagram showing a sample query plan tree (e.g., Projection -> HashJoin -> SeqScan & IndexScan) with data flow arrows. Illustrate the pull-based model: the Projection node calls next() on its child (HashJoin), which in turn pulls from its two children.",
      "type": "component",
      "relevant_sections": [
        "execution"
      ]
    }
  ]
}