direction: right

style: {
  fill: "#1a1a2e"
  stroke: "#3fb950"
  font-color: "#e6edf3"
}

# AST Node Hierarchy
ast: AST Nodes {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  
  node: Node {
    shape: class
    span: Span
    + accept(visitor)
  }
  
  expr: Expression {
    shape: class
    type: Type?
    + eval_type()
  }
  
  stmt: Statement {
    shape: class
    + execute()
  }
  
  # Expression Types
  literal: Literal {
    shape: class
    value: Value
  }
  
  binary: BinaryOp {
    shape: class
    "left": Expression
    op: Operator
    "right": Expression
  }
  
  var: Variable {
    shape: class
    name: String
    binding: Symbol?
  }
  
  call: FunctionCall {
    shape: class
    func: Expression
    args: List<Expression>
  }
  
  # Statement Types
  let_stmt: LetStatement {
    shape: class
    pattern: Pattern
    type_hint: Type?
    value: Expression
  }
  
  if_stmt: IfStatement {
    shape: class
    condition: Expression
    then_block: Block
    else_block: Block?
  }
  
  block: Block {
    shape: class
    statements: List<Statement>
    expression: Expression?
  }
  
  # Inheritance relationships
  node -> expr: inherits
  node -> stmt: inherits
  expr -> literal: inherits
  expr -> binary: inherits
  expr -> var: inherits
  expr -> call: inherits
  stmt -> let_stmt: inherits
  stmt -> if_stmt: inherits
  stmt -> block: inherits
}

# Type System
types: Type System {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  
  type_node: Type {
    shape: class
    + unify(other: Type): Result
    + substitute(subst: Subst)
    + occurs_check(var: TypeVar)
  }
  
  primitive: PrimitiveType {
    shape: class
    kind: PrimitiveKind
  }
  
  type_var: TypeVariable {
    shape: class
    id: u32
    bound: Type?
    constraints: Set<Constraint>
  }
  
  function_type: FunctionType {
    shape: class
    params: List<Type>
    return_type: Type
  }
  
  generic: GenericType {
    shape: class
    base: Type
    args: List<Type>
  }
  
  # Type relationships
  type_node -> primitive: inherits
  type_node -> type_var: inherits
  type_node -> function_type: inherits
  type_node -> generic: inherits
}

# Symbol Table
symbols: Symbol Table {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  
  symbol_table: SymbolTable {
    shape: class
    scopes: Vec<Scope>
    + enter_scope()
    + exit_scope()
    + define(name, symbol)
    + lookup(name): Symbol?
  }
  
  scope: Scope {
    shape: class
    bindings: HashMap<String, Symbol>
    parent: Scope?
  }
  
  symbol: Symbol {
    shape: class
    name: String
    type: Type
    kind: SymbolKind
    span: Span
  }
  
  symbol_kind: SymbolKind {
    shape: class
    Variable
    Function
    Type
    Parameter
  }
  
  # Symbol table relationships
  symbol_table -> scope: contains
  scope -> symbol: contains
  symbol -> symbol_kind: has
}

# Constraint System
constraints: Constraint System {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  
  constraint_set: ConstraintSet {
    shape: class
    constraints: Vec<Constraint>
    + add(constraint)
    + solve(): Result<Substitution>
  }
  
  constraint_node: Constraint {
    shape: class
    "left": Type
    "right": Type
    span: Span
  }
  
  substitution: Substitution {
    shape: class
    mappings: HashMap<TypeVar, Type>
    + apply(type): Type
    + compose(other): Substitution
  }
  
  # Constraint relationships
  constraint_set -> constraint_node: contains
  constraint_set -> substitution: produces
}

# Cross-component relationships
ast.expr -> types.type_node: "has type"
ast.var -> symbols.symbol: "references"
symbols.symbol -> types.type_node: "has type"
types.type_var -> constraints.constraint_node: "generates"