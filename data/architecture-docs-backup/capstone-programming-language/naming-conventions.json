{
  "types": {
    "SourceMap": "files HashMap<FileId, SourceFile>, next_file_id usize",
    "FileId": "wrapper around usize",
    "SourceFile": "name String, content String, line_starts Vec<usize>",
    "SourceSpan": "file_id FileId, start usize, end usize",
    "LineColumn": "line usize, column usize",
    "StringInterner": "strings Vec<String>, indices HashMap<String, usize>",
    "InternedString": "wrapper around usize",
    "Scanner": "source String, file_id FileId, current usize, start usize, line usize",
    "Token": "kind TokenKind, span SourceSpan",
    "LexError": "kind LexErrorKind, span SourceSpan",
    "Parser": "tokens Vec<Token>, current usize, errors Vec<ParseError>",
    "ParseError": "message String, span SourceSpan, expected Option<Vec<TokenKind>>, found TokenKind",
    "TokenKind": "enum of all token types",
    "Expr": "enum of expression AST nodes",
    "Stmt": "enum of statement AST nodes",
    "Type": "enum with Primitive, Variable, Function, Generic, Constrained variants",
    "PrimitiveType": "enum with Int, Float, String, Bool, Unit",
    "TypeVar": "id usize, name Option<InternedString>",
    "Program": "items Vec<Item>",
    "TypeInference": "constraint tracking and unification state",
    "Substitution": "bindings HashMap<TypeVar, Type>",
    "TypeError": "enum with Mismatch, UndefinedVariable, InfiniteType variants",
    "SemanticAnalyzer": "scope_stack Vec<SymbolTable>, control flow tracking",
    "TraitConstraint": "trait_name InternedString, associated_types",
    "Constraint": "type equation for unification",
    "TypeEnvironment": "maps expressions to types",
    "SymbolTable": "tracks variable bindings in scope",
    "ControlFlowGraph": "execution path analysis",
    "TypedProgram": "AST with type annotations",
    "SemanticError": "semantic analysis errors",
    "BytecodeChunk": "instructions Vec<u8>, constants Vec<ConstantValue>, source_map Vec<(usize, SourceSpan)>, local_count usize, parameter_count usize",
    "OpCode": "enum representing bytecode instructions",
    "ConstantValue": "enum for constant pool values",
    "LocalSlot": "index: usize, name: InternedString, var_type: Type, is_parameter: bool",
    "JumpPatch": "instruction_offset: usize, target_label: String",
    "BytecodeCompiler": "chunk BytecodeChunk, constants_map HashMap, locals HashMap, local_count usize, jump_patches Vec<JumpPatch>",
    "OptimizationPipeline": "passes: Vec<Box<dyn OptimizationPass>>, max_iterations: usize",
    "CompileError": "enum for compilation errors",
    "VirtualMachine": "operand_stack Vec<RuntimeValue>, call_stack Vec<CallFrame>, globals HashMap<InternedString, RuntimeValue>, heap Heap",
    "RuntimeValue": "enum with Integer(i64), Float(f64), Boolean(bool), String(ObjectRef), Function(ObjectRef), Struct(ObjectRef), Array(ObjectRef), Unit",
    "CallFrame": "chunk &BytecodeChunk, instruction_pointer usize, stack_base usize, local_slots Vec<RuntimeValue>, closure_upvalues Vec<UpvalueRef>, return_address usize, function_name InternedString",
    "RuntimeError": "enum with TypeError, ArithmeticError, StackOverflow, OutOfMemory variants",
    "ObjectRef": "ptr NonNull<u8>",
    "Heap": "memory: NonNull<u8>, current: *mut u8, end: *mut u8, size: usize, stats: HeapStats",
    "ObjectHeader": "size: usize, object_type: ObjectType, mark_bit: bool, generation: u8",
    "MarkSweepCollector": "heap Heap, mark_stack Vec<ObjectRef>, config CollectorConfig",
    "WriteBarrier": "incremental_enabled: bool, generational_enabled: bool, remembered_set: HashMap<ObjectRef, Vec<ObjectRef>>",
    "ObjectType": "enum with String, Array, Struct, Function, Closure variants",
    "CollectorConfig": "heap_threshold: f64, incremental_quantum: usize, generational_enabled: bool",
    "HeapStats": "objects_allocated: usize, bytes_allocated: usize, collections_performed: usize, bytes_freed: usize",
    "OutOfMemory": "error type for allocation failure",
    "StandardLibrary": "modules HashMap<InternedString, Module>, native_functions HashMap<InternedString, NativeFunction>",
    "Module": "name InternedString, functions HashMap<InternedString, FunctionSignature>, types HashMap<InternedString, Type>, constants HashMap<InternedString, RuntimeValue>",
    "FunctionSignature": "name InternedString, parameter_types Vec<Type>, return_type Type, is_native bool",
    "File": "handle NativeResource, path String, mode FileMode, position u64",
    "FileMode": "enum with Read, Write, ReadWrite variants",
    "HashMap": "buckets Vec<Option<(RuntimeValue, RuntimeValue)>>, size usize, capacity usize",
    "NativeResource": "handle *mut c_void, cleanup fn(*mut c_void), resource_type ResourceType",
    "NativeFunctionRegistry": "functions HashMap<String, NativeFunctionDescriptor>",
    "NativeFunctionDescriptor": "name String, parameter_types Vec<NativeType>, return_type NativeType, function_ptr *const fn(), marshaling_info MarshalingInfo",
    "NativeType": "enum with Int, Float, String, Pointer, Array variants",
    "MarshalingInfo": "parameter_marshalers Vec<fn(&RuntimeValue) -> Result<*const u8, RuntimeError>>, return_unmarshaler fn(*const u8) -> Result<RuntimeValue, RuntimeError>",
    "ReplSession": "vm VirtualMachine, type_env TypeEnvironment, compiler BytecodeCompiler, globals HashMap<InternedString, RuntimeValue>, history CommandHistory, config ReplConfig, input_buffer String, line_number usize",
    "ReplCommand": "input String, timestamp SystemTime, result ReplResult, execution_time Duration",
    "SymbolInfo": "name InternedString, symbol_type Type, kind SymbolKind, location SymbolLocation, is_mutable bool",
    "InputHistory": "entries Vec<HistoryEntry>, current_index Option<usize>, max_entries usize, temp_input Option<String>, search_state Option<SearchState>",
    "HistoryEntry": "command String, timestamp SystemTime, session_id usize, result_summary String, execution_time Duration, working_directory PathBuf",
    "CompletionEngine": "symbol_resolver SymbolResolver, type_resolver TypeResolver, file_system FileSystemProvider, command_registry CommandRegistry, current_completions Vec<CompletionItem>, completion_index usize, original_input String, completion_start usize",
    "CompletionItem": "text String, display_text String, item_type CompletionType, priority i32, documentation Option<String>, signature Option<String>",
    "DebugInspector": "vm VirtualMachine, type_environment TypeEnvironment, symbol_table SymbolTable, heap Heap, trace_enabled bool, breakpoints HashMap<SourceSpan, BreakpointInfo>, watch_expressions Vec<WatchExpression>",
    "InspectionResult": "value RuntimeValue, value_type Type, memory_info MemoryInfo, debug_info DebugInfo",
    "MemoryInfo": "size_bytes usize, reference_count usize, gc_generation u8, heap_address ObjectRef, is_marked bool",
    "MetaCommandProcessor": "command_registry HashMap<String, MetaCommand>, session ReplSession, config ReplConfig",
    "MetaCommand": "name String, aliases Vec<String>, description String, usage String, examples Vec<String>, handler CommandHandler, requires_args bool",
    "Diagnostic": "severity Severity, code Option<String>, message String, primary_span SourceSpan, labels Vec<DiagnosticLabel>, suggestions Vec<Suggestion>",
    "DiagnosticLabel": "span SourceSpan, message String, is_primary bool",
    "Suggestion": "message String, confidence f32, edits Vec<Edit>",
    "Edit": "span SourceSpan, replacement String",
    "TypeRecovery": "assumed_types HashMap<String, Type>, recovery_context RecoveryContext",
    "DiagnosticFormatter": "source_map SourceMap, use_colors bool, max_context_lines usize",
    "SelfHostingValidator": "bootstrap_compiler PathBuf, self_hosted_source PathBuf, test_programs Vec<PathBuf>",
    "MilestoneValidator": "test_programs TestProgramSuite",
    "TestProgramSuite": "valid_programs Vec<TestProgram>, invalid_programs Vec<TestProgram>",
    "TestProgram": "source String, expected_behavior ExpectedBehavior, description String",
    "LexerParserTest": "source_map SourceMap",
    "LexerDebugger": "source_map SourceMap, trace_enabled bool, token_history Vec<TokenTrace>, error_context_lines usize",
    "TokenTrace": "token Token, source_text String, line_column (usize, usize), scanner_state ScannerState",
    "ScannerState": "current_pos usize, start_pos usize, line usize, column usize",
    "ErrorAnalysis": "error_type String, context_lines Vec<String>, suggestions Vec<String>, similar_errors Vec<String>",
    "ValidationResult": "passed bool, span_errors Vec<SpanError>, total_tokens usize, invalid_spans usize",
    "SpanError": "token_index usize, expected_text String, actual_text String, span SourceSpan",
    "TypeDebugger": "constraint_trace Vec<ConstraintStep>, substitution_history Vec<SubstitutionStep>, unification_calls Vec<UnificationCall>, error_context HashMap<String, TypeContext>",
    "ConstraintStep": "step_id usize, constraint Constraint, source_expr String, generated_at String, dependencies Vec<usize>",
    "SubstitutionStep": "step_id usize, substitution Substitution, applied_to Vec<Type>, result_types Vec<Type>, triggered_by String",
    "UnificationCall": "call_id usize, type1 Type, type2 Type, result Result<Substitution, String>, occurs_check_performed bool, nested_calls Vec<usize>",
    "UnificationTracer": "debugger *mut TypeDebugger, call_id usize",
    "VMDebugger": "instruction_trace Vec<InstructionTrace>, stack_snapshots Vec<StackSnapshot>, call_trace Vec<CallTrace>, gc_events Vec<GCEvent>, breakpoints HashMap<usize, Breakpoint>",
    "InstructionTrace": "instruction_offset usize, opcode OpCode, operands Vec<u8>, stack_before Vec<RuntimeValue>, stack_after Vec<RuntimeValue>, execution_time_nanos u64",
    "StackSnapshot": "timestamp std::time::Instant, operand_stack Vec<RuntimeValue>, call_stack Vec<CallFrameSnapshot>, heap_objects usize, heap_bytes usize",
    "CallFrameSnapshot": "function_name String, instruction_pointer usize, local_variables HashMap<String, RuntimeValue>, stack_base usize",
    "HotspotDetector": "execution_counts HashMap, compilation_threshold u32, compiled_functions HashMap",
    "SimpleJITCompiler": "code_buffer Vec<u8>, constant_pool Vec<RuntimeValue>, label_patches Vec",
    "CompiledCode": "machine_code *const u8, code_size usize, entry_point *const fn(), deopt_handlers Vec",
    "TaskScheduler": "ready_queue Vec<Box<dyn Task>>, sleeping_tasks Vec<SleepingTask>, current_task Option<Box<dyn Task>>",
    "LanguageFuture": "vm_state VMState, bytecode BytecodeChunk, locals Vec<RuntimeValue>, stack Vec<RuntimeValue>, instruction_pointer usize",
    "LanguageServer": "connection Connection, documents HashMap<Url, TextDocument>, workspace WorkspaceState, capabilities ServerCapabilities",
    "TextDocument": "uri Url, version i32, content String, ast Option<Program>, type_env TypeEnvironment, diagnostics Vec<Diagnostic>",
    "ProjectManifest": "name String, version Version, dependencies HashMap<String, VersionReq>",
    "PackageManager": "registry_url String, local_cache PathBuf, project_root PathBuf",
    "DependencyResolver": "available_versions HashMap<String, Vec<Version>>, constraints HashMap<String, VersionReq>",
    "Pattern": "enum with Literal, Variable, Constructor, Guard, Array, Wildcard variants",
    "MatchExpression": "scrutinee Box<Expr>, arms Vec<MatchArm>, span SourceSpan, exhaustive bool",
    "MatchArm": "pattern Pattern, guard Option<Box<Expr>>, body Box<Expr>, span SourceSpan",
    "AsyncRuntime": "scheduler TaskScheduler, executor LocalExecutor, reactor IOReactor, timer_wheel TimerWheel",
    "Future": "state FutureState, waker Option<Waker>, poll_fn function pointer",
    "Task": "future Box<dyn Future>, priority TaskPriority, creation_time Instant, scheduled_time Option<Instant>",
    "MacroExpander": "macro_definitions HashMap, expansion_stack Vec<ExpansionFrame>, hygiene_context HygieneContext, syntax_extensions SyntaxExtensionRegistry",
    "MacroDefinition": "name InternedString, parameters Vec<MacroParameter>, body MacroBody, hygiene_scope HygieneScope",
    "Workspace": "root_uri Url, source_files HashMap<Url, Document>, project_config ProjectConfig, symbol_index GlobalSymbolIndex, dependency_graph DependencyGraph",
    "Document": "uri Url, version i32, content String, ast Option<Program>, diagnostics Vec<Diagnostic>, symbols Vec<SymbolInfo>",
    "Package": "name String, version Version, dependencies Vec<Dependency>, source_files Vec<SourceFile>, metadata PackageMetadata",
    "IDEServer": "language_server LanguageServer, debugger IntegratedDebugger, refactoring_engine RefactoringEngine, test_runner TestRunner, profiler_integration ProfilerIntegration",
    "RefactoringEngine": "symbol_resolver SymbolResolver, transformation_engine CodeTransformationEngine, safety_analyzer RefactoringSafetyAnalyzer, preview_generator RefactoringPreviewGenerator",
    "IntegratedDebugger": "vm_connection VMDebugConnection, breakpoint_manager BreakpointManager, variable_inspector VariableInspector, stack_trace_analyzer StackTraceAnalyzer"
  },
  "methods": {
    "add_file(name, content) -> FileId": "adds source file and returns ID",
    "span_to_line_column(span) -> Option<(LineColumn, LineColumn)>": "converts byte spans to line/column positions",
    "intern(s) -> InternedString": "interns string and returns handle",
    "resolve(interned) -> &str": "resolves interned string to original text",
    "scan_tokens(source, file_id) -> Result<Vec<Token>, Vec<LexError>>": "tokenize source with error recovery",
    "parse() -> Result<Ast, Vec<ParseError>>": "parses tokens into AST with error recovery",
    "parse() -> Result<Program, Vec<ParseError>>": "parse tokens into AST",
    "advance() -> char": "returns current character and advances scanner position",
    "peek() -> char": "returns current character without advancing",
    "make_token(kind) -> Token": "creates token with current source span",
    "parse_expression() -> Result<Expr, ParseError>": "parses expression with operator precedence",
    "parse_primary() -> Result<Expr, ParseError>": "parses primary expressions like literals and identifiers",
    "synchronize()": "error recovery at synchronization points",
    "infer_types(program) -> Result<TypedProgram, Vec<TypeError>>": "main type inference entry point",
    "unify(t1, t2) -> Result<Substitution, TypeError>": "unify types with constraint solving",
    "occurs_check(var, type) -> bool": "prevent infinite types",
    "unify(t1, t2) -> Result<(), TypeError>": "unifies two types in constraint system",
    "generate_constraints(expr) -> Result<Type, TypeError>": "creates type constraints for expressions",
    "apply(type) -> Type": "applies substitution to replace type variables",
    "compose(other) -> Substitution": "combines two substitutions",
    "bind(var, type)": "adds new type variable binding",
    "fresh_type_var() -> Type": "generates unique type variable",
    "analyze(program) -> Result<(), Vec<SemanticError>>": "main semantic analysis entry point",
    "resolve_names(expr) -> Result<(), SemanticError>": "binds name references to declarations",
    "check_initialization(stmt) -> Result<(), SemanticError>": "verifies variables initialized before use",
    "emit_simple(opcode, span)": "emit instruction with no operands",
    "emit_byte(opcode, operand, span)": "emit instruction with byte operand",
    "emit_word(opcode, operand, span)": "emit instruction with word operand",
    "add_constant(value) -> u16": "add to constant pool and return index",
    "current_offset() -> usize": "get instruction offset for jump patching",
    "patch_jump(jump_offset, target_offset)": "patch jump instruction with target",
    "compile(program) -> Result<BytecodeChunk, CompileError>": "main compilation entry point",
    "compile_function(func) -> Result<(), CompileError>": "compile function definition",
    "compile_stmt(stmt) -> Result<(), CompileError>": "compile statement",
    "compile_expr(expr) -> Result<(), CompileError>": "compile expression",
    "allocate_local(name, var_type) -> usize": "allocate local variable slot",
    "binary_op_instruction(op) -> OpCode": "get instruction for binary operator",
    "optimize(chunk) -> bool": "optimization pass interface returning change indicator",
    "run(chunk) -> Result<RuntimeValue, RuntimeError>": "execute bytecode in VM",
    "execute_loop() -> Result<(), RuntimeError>": "core instruction execution loop",
    "current_frame() -> Result<&mut CallFrame, RuntimeError>": "get mutable reference to current call frame",
    "push(value) -> Result<(), RuntimeError>": "push value on operand stack",
    "pop() -> Result<RuntimeValue, RuntimeError>": "pop value from operand stack",
    "op_add() -> Result<(), RuntimeError>": "add two values or concatenate strings",
    "op_call() -> Result<(), RuntimeError>": "call function with argument count",
    "op_return() -> Result<bool, RuntimeError>": "return from current function",
    "type_name() -> &'static str": "get runtime type name for value",
    "is_truthy() -> bool": "evaluate value in boolean context",
    "as_integer() -> Result<i64, RuntimeError>": "extract integer value with type check",
    "as_object_ref() -> Result<ObjectRef, RuntimeError>": "extract object reference with type check",
    "allocate_object(size, object_type) -> Result<ObjectRef, OutOfMemory>": "allocate heap space with initialized header",
    "get_object_header(object_ref) -> &ObjectHeader": "access object metadata for GC operations",
    "get_object_header_mut(object_ref) -> &mut ObjectHeader": "access mutable object metadata",
    "collect(vm) -> Result<usize, RuntimeError>": "perform garbage collection",
    "mark_phase() -> Result<(), RuntimeError>": "traverse object graph marking reachable objects",
    "sweep_phase() -> Result<usize, RuntimeError>": "reclaim memory from unmarked objects",
    "enumerate_roots(vm) -> Result<(), RuntimeError>": "identify all root references from VM state",
    "scan_object_references(object_ref) -> Result<(), RuntimeError>": "scan references within object by type",
    "record_store(container, offset, value) -> Result<(), RuntimeError>": "process write barrier for reference assignment",
    "call_function(vm, module_name, function_name, arguments) -> Result<RuntimeValue, RuntimeError>": "dispatch function calls to standard library modules",
    "open(path, mode) -> Result<File, RuntimeError>": "opens file with specified access mode",
    "read_all() -> Result<String, RuntimeError>": "reads entire file content as string",
    "write_string(content) -> Result<(), RuntimeError>": "writes string content to file",
    "close() -> Result<(), RuntimeError>": "closes file handle explicitly",
    "insert(key, value) -> Option<RuntimeValue>": "inserts key-value pair in hash map",
    "get(key) -> Option<&RuntimeValue>": "retrieves value for key if present",
    "marshal_string(value) -> Result<CString, RuntimeError>": "converts language string to C string",
    "unmarshal_string(c_str) -> Result<RuntimeValue, RuntimeError>": "converts C string to language string",
    "register_function(descriptor)": "registers native function in FFI registry",
    "call_native(function_name, arguments) -> Result<RuntimeValue, RuntimeError>": "dispatches call to registered native function",
    "run() -> Result<(), ReplError>": "main REPL loop processing user input",
    "read_input() -> Result<InputResult, ReplError>": "reads and processes user input with completion detection",
    "is_input_complete() -> Result<bool, ReplError>": "determines if current input buffer forms complete statement",
    "process_input(input) -> Result<(), ReplError>": "processes complete input through compilation pipeline",
    "evaluate_input(input) -> Result<(), ReplError>": "evaluates input through lexer, parser, type checker, compiler, and VM",
    "process_meta_command(command) -> Result<(), ReplError>": "handles REPL meta-commands beginning with colon",
    "generate_completions(input, cursor_pos) -> Vec<CompletionItem>": "generates context-aware completion suggestions",
    "inspect_value(value) -> InspectionResult": "provides detailed inspection of runtime values",
    "trace_execution(bytecode) -> ExecutionTrace": "traces step-by-step execution with state capture",
    "analyze_error(error) -> ErrorAnalysis": "analyzes runtime errors with recovery suggestions",
    "synchronize() -> bool": "panic mode recovery by skipping to synchronization points",
    "assume_variable_type(name, context_type) -> Type": "creates type assumption for error recovery",
    "recover_from_mismatch(expected, found) -> Type": "handles type mismatch with recovery",
    "unwind_stack(vm, error) -> Result<(), RuntimeError>": "unwinds call stack during error handling",
    "format_diagnostic(diagnostic) -> String": "formats diagnostic into human-readable string",
    "emit_diagnostic(diagnostic, writer) -> io::Result<()>": "outputs formatted diagnostic to writer",
    "scan_tokens() -> Result<Vec<Token>, Vec<LexError>>": "tokenizes entire source file with error recovery",
    "validate_self_hosting() -> Result<(), String>": "execute complete self-hosting validation sequence",
    "compile_with_bootstrap() -> Result<PathBuf, String>": "use bootstrap compiler to compile self-hosted source",
    "validate_milestone_1() -> Result<(), String>": "validate Milestone 1: Language Design & Lexer/Parser",
    "parse_program(source) -> Result<Program, String>": "parse source code through complete lexer->parser pipeline",
    "assert_tokens_match(source, expected)": "verify token sequences match expected patterns",
    "create_test_scanner(source) -> (Scanner, FileId)": "test helper for creating scanner with source text",
    "enable_tracing(enabled: bool)": "configure debug tracing output",
    "trace_token_scan(scanner: &Scanner, token: &Token)": "record token recognition with context",
    "analyze_lex_error(error: &LexError, source: &str) -> ErrorAnalysis": "generate detailed lexical error analysis",
    "validate_token_spans(tokens: &[Token], source: &str) -> ValidationResult": "check token span accuracy",
    "visualize_tokenization(tokens: &[Token], source: &str) -> String": "create visual token boundary display",
    "trace_constraint_generation(expr: &Expr, constraint: &Constraint)": "record constraint creation from expressions",
    "trace_unification(type1: &Type, type2: &Type) -> UnificationTracer": "monitor unification attempts",
    "visualize_inference_graph() -> InferenceGraph": "generate type inference visualization",
    "analyze_type_error(error: &TypeError) -> TypeErrorAnalysis": "provide type error analysis",
    "validate_invariants(inference: &TypeInference) -> InvariantCheck": "check type system consistency",
    "record_binding(var: &str, typ: &Type)": "log variable binding in unification",
    "record_occurs_failure(var: &str, typ: &Type)": "log infinite type detection",
    "trace_instruction(vm: &VirtualMachine, offset: usize, opcode: OpCode)": "record instruction execution",
    "validate_stack_state(vm: &VirtualMachine) -> StackValidation": "check stack consistency",
    "trace_function_call(function_name: &str, args: &[RuntimeValue])": "record function call events",
    "trace_gc_event(event_type: &str, heap: &Heap)": "monitor garbage collection",
    "set_breakpoint(offset: usize, condition: Option<String>)": "configure execution breakpoint",
    "generate_performance_report() -> PerformanceReport": "create execution analysis report",
    "record_execution(bytecode_offset: usize) -> Option<*const u8>": "hotspot detection and compilation triggering",
    "compile_function(bytecode: &[u8]) -> Result<CompiledCode, JITError>": "JIT compilation of bytecode to machine code",
    "emit_add_reg_reg(dest: Register, src: Register)": "emit x86-64 ADD instruction",
    "poll(&mut self, cx: &mut Context) -> Poll<RuntimeValue>": "task polling for cooperative scheduling",
    "run() -> Result<(), Box<dyn std::error::Error>>": "main LSP message loop",
    "handle_request(req: Request) -> Result<(), Box<dyn std::error::Error>>": "LSP request dispatching",
    "resolve_dependencies() -> Result<LockFile, PackageError>": "dependency resolution with constraint solving",
    "publish_package(manifest: &ProjectManifest) -> Result<(), PackageError>": "package publishing to registry",
    "solve() -> Result<HashMap<String, Version>, ResolverError>": "dependency constraint solving algorithm",
    "scan_tokens(source, file_id)": "tokenize source with error recovery",
    "parse()": "parse tokens into AST with error recovery",
    "infer_types(program)": "main type inference entry point",
    "unify(t1, t2)": "unify types with constraint solving",
    "compile(program)": "main compilation entry point",
    "run(chunk)": "execute bytecode in VM",
    "collect(vm)": "perform garbage collection",
    "mark_phase()": "traverse object graph marking reachable objects",
    "sweep_phase()": "reclaim memory from unmarked objects"
  },
  "constants": {
    "EOF": "end of file token",
    "LoadLocal": "0x10 bytecode instruction",
    "StoreLocal": "0x11 bytecode instruction",
    "Add": "0x20 arithmetic instruction",
    "Jump": "0x40",
    "Call": "0x50 function call instruction",
    "Return": "0x51 function return instruction",
    "LoadConstant": "0x10",
    "Halt": "halt instruction",
    "MAX_STACK_SIZE": "1024 * 1024 operand stack limit",
    "MAX_CALL_DEPTH": "1024 maximum call stack depth",
    "MAX_MARK_STACK_SIZE": "10000 objects maximum for overflow detection",
    "DEFAULT_HEAP_SIZE": "1024 * 1024 initial heap size",
    "HEAP_GROWTH_FACTOR": "2.0 multiplier for heap expansion",
    "COLLECTION_THRESHOLD": "0.75 heap utilization for GC trigger",
    "INITIAL_CAPACITY": "16",
    "LOAD_FACTOR_THRESHOLD": "0.75",
    "PI": "3.141592653589793",
    "E": "2.718281828459045",
    "MAX_HISTORY_SIZE": "1000",
    "DEFAULT_PROMPT": ">>>",
    "CONTINUATION_PROMPT": "...",
    "MAX_CONTEXT_LINES": "maximum source lines in error context",
    "DEFAULT_CONFIDENCE": "0.5 default suggestion confidence",
    "SYNC_TOKENS": "parser synchronization points",
    "compilation_threshold": "execution count threshold for JIT compilation"
  },
  "terms": {
    "compilation pipeline": "multi-stage translation from source to executable code",
    "bytecode virtual machine": "stack-based interpreter executing compact instruction sequences",
    "tree-walking interpreter": "direct AST execution through recursive traversal",
    "native compilation": "direct translation to machine code",
    "transpilation": "source-to-source translation to another high-level language",
    "mark-and-sweep": "garbage collection algorithm tracing reachable objects",
    "source span": "byte range in source file with file ID",
    "string interning": "deduplication of repeated string values",
    "error recovery": "graceful handling of errors while maintaining session state",
    "static typing with local inference": "type safety with automatic type deduction for variables",
    "expression-oriented design": "language where most constructs evaluate to values",
    "parametric polymorphism": "generic types and functions with type parameters",
    "self-hosting": "language implementation written in the language itself",
    "panic mode recovery": "skipping tokens until synchronization point after parse error",
    "recursive descent parser": "parser implementation mirroring grammar rules as methods",
    "operator precedence": "rules determining evaluation order of expressions",
    "Hindley-Milner type inference": "automatic type deduction through unification",
    "Abstract Syntax Tree": "hierarchical representation of program structure",
    "semantic analysis": "validation of program meaning beyond syntax",
    "bytecode": "platform-independent instruction format for virtual machines",
    "root set": "directly accessible objects for garbage collection",
    "occurs check": "prevents infinite types during unification",
    "type variable": "placeholder for unknown types during inference",
    "constraint system": "set of type equations to solve",
    "unification": "making types equal through substitution",
    "type environment": "mapping from expressions to their types",
    "scope resolution": "binding name references to declarations",
    "control flow analysis": "tracking execution paths through program",
    "use-before-define": "accessing uninitialized variables",
    "pattern exhaustiveness": "ensuring all cases covered in match expressions",
    "type substitution": "replacing type variables with concrete types",
    "constraint generation": "creating type equations from expressions",
    "generic instantiation": "creating concrete types from generic templates",
    "stack-based VM": "virtual machine using runtime stack for operand storage",
    "constant folding": "compile-time evaluation of expressions with known values",
    "dead code elimination": "removal of unreachable or unused instructions",
    "register allocation": "optimization of local variable slot usage",
    "jump patching": "resolving forward references in control flow instructions",
    "constant pool": "centralized storage for literal values and type descriptors",
    "instruction encoding": "binary format for representing bytecode operations",
    "code generation": "transformation from AST to bytecode instructions",
    "optimization pass": "analysis and transformation phase for performance improvement",
    "stack-based virtual machine": "bytecode interpreter using runtime stack for operand storage",
    "instruction dispatch": "routing bytecode instructions to implementation handlers",
    "operand stack": "runtime stack holding intermediate computation values",
    "call frame": "execution context for function invocation",
    "upvalue": "reference to captured variable in closure",
    "runtime value": "typed value that can exist during program execution",
    "instruction pointer": "current position in bytecode being executed",
    "call stack": "stack of function activation records",
    "exception unwinding": "propagating errors up call stack to find handlers",
    "GC root enumeration": "identifying all reachable object references for garbage collection",
    "write barrier": "mechanism tracking object reference updates",
    "stack frame corruption": "invalid call frame state causing execution errors",
    "upvalue promotion": "converting stack variables to heap storage for closure capture",
    "tri-color marking": "incremental collection abstraction with white/gray/black object states",
    "generational hypothesis": "observation that most objects die young",
    "remembered set": "tracking structure for cross-generational references",
    "conservative scanning": "treating unknown values as potential object references",
    "incremental collection": "spreading collection work across multiple allocation cycles",
    "stop-the-world": "pausing program execution during garbage collection",
    "object reachability": "ability to access object through reference paths",
    "standard library": "collection of modules providing essential functionality for programs",
    "foreign function interface": "bridge between language and native system APIs",
    "module system": "hierarchical organization of related functionality",
    "type marshaling": "converting between language types and native types",
    "resource wrapper objects": "managed objects that handle native resource cleanup",
    "impedance matching": "translating between different execution models safely",
    "native function registry": "system for registering and dispatching native function calls",
    "hierarchical namespace design": "organizing modules in tree structure with dot notation",
    "Read-Eval-Print-Loop": "interactive programming environment for immediate execution",
    "persistent VM state": "maintaining execution environment across multiple inputs",
    "incremental compilation": "compiling individual inputs within persistent context",
    "tab completion": "context-aware suggestion system for identifiers and symbols",
    "command history": "persistent storage and recall of previous REPL inputs",
    "meta-commands": "special REPL commands beginning with colon for session control",
    "interactive debugging": "runtime inspection and analysis capabilities within REPL",
    "expression inspection": "detailed analysis of values, types, and execution behavior",
    "line editing": "advanced text input capabilities with cursor movement and history",
    "diagnostic reporting": "system for formatting and presenting errors",
    "error classification": "categorization of errors by type and compilation phase",
    "synchronization points": "safe locations to resume parsing after errors",
    "cascading errors": "spurious errors caused by incorrect recovery assumptions",
    "stack unwinding": "propagating errors up call stack to find handlers",
    "phrase-level recovery": "fixing specific syntax errors rather than skipping",
    "suggestion system": "automated generation of error fix recommendations",
    "testing pyramid": "layered structure balancing comprehensive coverage with execution efficiency",
    "unit tests": "validate individual components in isolation using controlled inputs",
    "integration tests": "validate component interactions and data transformations",
    "end-to-end tests": "validate complete user scenarios through entire pipeline",
    "property-based testing": "generates diverse inputs and validates universal invariants",
    "cross-compilation": "rewriting compiler in target language using bootstrap compiler",
    "bootstrap compiler": "initial implementation in host language for self-hosting foundation",
    "milestone validation": "structured acceptance testing for development phases",
    "test fixtures": "controlled test data and mock dependencies",
    "snapshot testing": "approval workflow for expected outputs",
    "regression testing": "preventing previously fixed bugs from reoccurring",
    "stack overflow": "exceeding maximum call depth or operand stack size",
    "memory leak": "objects not collected despite being unreachable",
    "premature collection": "live objects collected causing dangling references",
    "instruction tracing": "logging each executed instruction with state",
    "constraint tracing": "recording type constraint generation and solving",
    "unification tracing": "monitoring type unification algorithm steps",
    "stack validation": "checking operand stack consistency",
    "breakpoint debugging": "interactive execution control and inspection",
    "garbage collection tracing": "monitoring memory allocation and collection events",
    "error propagation": "how errors cascade through compilation phases",
    "just-in-time compilation": "dynamic compiler generating native code during execution",
    "hotspot detection": "identifying frequently executed code regions for optimization",
    "escape analysis": "determining object lifetime to enable stack allocation",
    "tiered compilation": "progressive optimization with multiple compilation levels",
    "pattern matching": "conditional logic with data extraction and type refinement",
    "exhaustiveness checking": "ensuring pattern matches cover all possible values",
    "async/await": "asynchronous programming with suspension and resumption",
    "cooperative scheduling": "voluntary yielding of control between tasks",
    "macro system": "compile-time code generation and transformation",
    "hygiene": "preventing identifier capture in macro expansions",
    "Language Server Protocol": "standardized editor integration for language features",
    "incremental analysis": "efficient updating of analysis results as code changes",
    "package manager": "dependency resolution and code sharing infrastructure",
    "constraint solving": "finding compatible versions satisfying all requirements",
    "IDE integration": "sophisticated development environment features",
    "refactoring tools": "safe automated code transformations",
    "garbage collection": "automatic memory management by reclaiming unreachable objects",
    "bootstrap compilation": "initial implementation in host language for self-hosting foundation"
  }
}