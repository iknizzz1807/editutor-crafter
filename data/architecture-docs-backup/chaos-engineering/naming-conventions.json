{
  "types": {
    "Experiment": "fields: ID string, Name string, Description string, Hypothesis Hypothesis, Faults []Fault, Schedule Schedule, Duration time.Duration, BlastRadius BlastRadius, SafetyRules []SafetyRule, Status ExperimentStatus, CreatedAt time.Time, StartedAt *time.Time, CompletedAt *time.Time",
    "Hypothesis": "fields: Description string, Metrics []MetricThreshold",
    "MetricThreshold": "fields: Name string, Query string, Min *float64, Max *float64, Duration string",
    "Fault": "fields: Type FaultType, Target Target, Parameters FaultParams",
    "BlastRadius": "fields: Percentage float64, Services []string, Namespaces []string",
    "SafetyRule": "fields: Metric string, Condition string, Duration string",
    "CleanupEnsurer": "fields: mu sync.RWMutex, wal *persistence.WAL, activeFaults map[string]FaultRecord",
    "FaultRecord": "fields: ExperimentID string, FaultID string, Target string, FaultType string, InjectTime time.Time, CleanupCmd string",
    "Orchestrator": "fields: experiments map[string]*ExperimentInstance, mu sync.RWMutex, metricsCollector metrics.Collector, safetyMonitor safety.Monitor, faultInjector fault.Injector",
    "ExperimentInstance": "fields: Experiment types.Experiment, State ExperimentState, CancelFunc context.CancelFunc, MetricsBaseline map[string]float64, ResultsChan chan<- types.ExperimentResult",
    "ExperimentStatus": "type alias for string constants",
    "ExperimentFilter": "fields: Status *ExperimentStatus, CreatedAfter *time.Time, CreatedBefore *time.Time, NamePrefix string, Limit int, Offset int",
    "ExperimentResult": "fields: ExperimentID string, Status ResultStatus, StartTime time.Time, EndTime time.Time, HypothesisValidation HypothesisValidation, SafetyEvents []SafetyEvent, Observations []Observation, FaultInjections []FaultInjectionRecord, Error *string",
    "HypothesisValidation": "fields: MetricResults []MetricValidationResult, Overall bool",
    "MetricValidationResult": "fields: MetricName string, Threshold MetricThreshold, Before MetricSample, During MetricSample, After MetricSample, Passed bool, ViolationPeriods []TimeRange",
    "MetricSample": "fields: Min float64, Max float64, Mean float64, P95 float64, DataPoints int, Duration time.Duration",
    "SafetyEvent": "fields: Rule SafetyRule, Timestamp time.Time, Value float64, Triggered bool, DurationMet bool, ActionTaken string, Error *string",
    "Observation": "fields: Time time.Time, Source string, Message string, Severity string",
    "FaultInjectionRecord": "fields: FaultID string, FaultType FaultType, Target string, Parameters map[string]string, InjectTime time.Time, CleanupTime *time.Time, Status string, Error *string",
    "Schedule": "fields: Type ScheduleType, When *time.Time, CronExpression string, TimeZone string",
    "Target": "fields: Type string, Selector map[string]string, Count int",
    "FaultStatus": "fields: FaultID string, ExperimentID string, Type FaultType, Target string, State FaultState, InjectTime *time.Time, CleanupTime *time.Time, Commands []ExecutedCommand, Error *string",
    "FaultInstance": "fields: FaultID string, ExperimentID string, Fault Fault, State FaultState, Status FaultStatus, CancelFunc context.CancelFunc",
    "ExecutedCommand": "fields: Command string, Output string, Error string, Timestamp time.Time",
    "FaultState": "type alias for string constants: PENDING, INJECTING, ACTIVE, CLEANING, DONE, FAILED",
    "Scenario": "fields: ID string, Name string, Description string, Steps []ScenarioStep, ObserverBriefing ObserverBriefing, CreatedAt time.Time, ScheduledFor *time.Time, BlastRadiusLimit BlastRadius, SafetyOverride []SafetyRule",
    "ScenarioStep": "fields: Type StepType, Name string, Description string, Experiment *Experiment, RunbookTask *RunbookTask, PauseDuration *time.Duration, InjectMessage *string, RequiresApproval bool, AutoProceedAfter *time.Duration",
    "ScenarioStatus": "type alias for string constants",
    "RunbookTask": "struct",
    "ObserverBriefing": "struct",
    "GameDayReport": "struct",
    "GameDayController": "struct",
    "scenarioInstance": "fields: Scenario Scenario, Status ScenarioStatus, CurrentStep int, StartedAt time.Time, EndedAt *time.Time, Observations []types.Observation",
    "StepType": "type alias for string constants",
    "Event": "fields: ID string, Type string, Timestamp time.Time, Source string, CorrelationID string, Payload json.RawMessage",
    "InMemoryPubSub": "fields: subscribers map[string][]func(Event), mu sync.RWMutex",
    "Client": "fields: baseURL string, httpClient *http.Client, maxRetries int, retryDelay time.Duration",
    "WAL": "fields: mu sync.Mutex, file *os.File, writer *bufio.Writer, path string",
    "MetricsChecker": "fields: collector metrics.Collector, failureCounters map[string]int, failureThreshold int, heartbeatQuery string",
    "SystemInfo": "placeholder for system analysis information",
    "ResilienceReport": "placeholder for resilience analytics report",
    "PredictedImpact": "placeholder for predicted metric impact",
    "AnalyticsEvent": "placeholder for analytics processing events"
  },
  "methods": {
    "NewCleanupEnsurer(dataDir string) (*CleanupEnsurer, error)": "Creates cleanup ensurer with persistent WAL",
    "RegisterFault(record FaultRecord) error": "Records a fault that will need cleanup",
    "CompleteFault(faultID string) error": "Removes a fault from cleanup registry",
    "StartExperiment(exp types.Experiment, resultsChan chan<- types.ExperimentResult) error": "Begins execution of a defined experiment",
    "executeStateMachine(instance *ExperimentInstance)": "Internal state machine driver",
    "AbortExperiment(experimentID string, reason string) error": "Forcefully stops an experiment and rolls back faults",
    "CreateExperiment(Experiment) (ExperimentID, error)": "Validates and stores new experiment",
    "StartExperiment(experimentID string) error": "Begins execution of approved experiment",
    "GetExperimentStatus(experimentID string) (ExperimentStatus, error)": "Returns current state and progress",
    "ListExperiments(filter ExperimentFilter) ([]Experiment, error)": "Returns experiments matching criteria",
    "InjectFault(Fault, ExperimentID string) (FaultID string, error)": "Applies specified fault to target system",
    "CleanupFault(FaultID string) error": "Removes previously injected fault",
    "GetFaultStatus(FaultID string) (FaultStatus, error)": "Returns current state of fault",
    "ListActiveFaults(ExperimentID string) ([]FaultStatus, error)": "Returns all active faults for experiment",
    "GetMetric(query string, start time.Time, end time.Time, step time.Duration) ([]MetricPoint, error)": "Returns time-series metric data",
    "GetCurrentValue(query string) (float64, error)": "Returns most recent value for metric",
    "ValidateThreshold(threshold MetricThreshold, duration string) (bool, error)": "Checks if metric meets threshold for duration",
    "ValidateHypothesis(hypothesis Hypothesis, startTime time.Time, endTime time.Time, metricsCollector MetricsCollector) (*HypothesisValidation, error)": "Validates hypothesis against collected metrics",
    "InjectFault(fault Fault, experimentID string) (string, error)": "Applies specified fault to target system",
    "CleanupFault(faultID string) error": "Removes previously injected fault",
    "GetFaultStatus(faultID string) (FaultStatus, error)": "Returns current state of fault",
    "ListActiveFaults(experimentID string) ([]FaultStatus, error)": "Returns all active faults for experiment",
    "ValidateFault(fault Fault) ([]ValidationError, error)": "Validates fault definition before injection",
    "RecoverOrphanedFaults() error": "Cleans up faults that were active during crash",
    "validateHypothesis(hypothesis Hypothesis, baseline map[string]float64, duringMetrics map[string][]MetricPoint) (*HypothesisValidation, error)": "Validates steady-state hypothesis against collected metrics",
    "checkSafetyRules(rules []SafetyRule, metricsCollector metrics.Collector) ([]SafetyEvent, bool, error)": "Continuously monitors safety rules during fault injection",
    "injectAllFaults(faults []Fault, experimentID string) ([]FaultInjectionRecord, error)": "Coordinates injection of all faults defined in experiment",
    "cleanupAllFaults(faults []FaultInstance) ([]FaultInjectionRecord, error)": "Ensures all injected faults are cleaned up",
    "LoadScenario(scenario Scenario) (scenarioID string, error)": "Validates and registers a new scenario definition",
    "StartScenario(scenarioID string) error": "Begins execution of a loaded scenario",
    "PauseScenario(scenarioID string, reason string) error": "Pauses the scenario at the current step",
    "ResumeScenario(scenarioID string) error": "Resumes a paused scenario",
    "ApproveStep(scenarioID string, stepIndex int, approvalNotes string) error": "Provides manual approval for a step marked RequiresApproval",
    "AbortScenario(scenarioID string, reason string) error": "Aborts the entire scenario",
    "GetScenarioStatus(scenarioID string) (ScenarioStatus, *ScenarioStep, error)": "Returns current status and active step",
    "AddObservation(scenarioID string, observation Observation) error": "Allows observers to attach notes to the scenario's report",
    "GenerateReport(scenarioID string) (*GameDayReport, error)": "Compiles a final report",
    "ListScenarios(filter ScenarioFilter) ([]Scenario, error)": "Retrieves scenarios matching filter criteria",
    "LoadScenarioFromFile(filePath string) (*Scenario, error)": "Reads a YAML file and returns a Scenario struct",
    "SaveScenarioToFile(scenario *Scenario, filePath string) error": "Writes a Scenario struct to a YAML file",
    "executeScenario(scenarioID string) error": "Main loop for running a scenario",
    "NewInMemoryPubSub() *InMemoryPubSub": "Creates an in-memory event bus",
    "Publish(eventType string, payload interface{}, correlationID string) error": "Publishes an event",
    "Subscribe(eventTypes []string, handler func(Event)) (func() error, error)": "Subscribes to event types",
    "NewClient(baseURL string) *Client": "Creates an HTTP RPC client",
    "Call(ctx context.Context, method string, request, response interface{}) error": "Makes an RPC call with retries",
    "validateBaseline(instance *ExperimentInstance) error": "Validates baseline hypothesis",
    "injectFaults(instance *ExperimentInstance) error": "Injects all faults for experiment",
    "monitorExperiment(instance *ExperimentInstance)": "Monitors experiment during fault injection",
    "CheckSafetyRules(rules []SafetyRule) ([]SafetyEvent, bool, error)": "Evaluates safety rules with metrics failure detection",
    "ExperimentGenerator.Generate(context.Context, SystemInfo) ([]types.Experiment, error)": "generates experiment scenarios based on system analysis",
    "ExperimentGenerator.Name() string": "returns generator display name",
    "ExperimentGenerator.Version() string": "returns generator version",
    "FaultInjectorPlugin.FaultType() types.FaultType": "returns fault type plugin handles",
    "FaultInjectorPlugin.Inject(context.Context, types.Fault, types.Target) (string, error)": "applies fault to target",
    "FaultInjectorPlugin.Cleanup(context.Context, string) error": "removes fault",
    "FaultInjectorPlugin.Validate(types.Fault) []error": "validates fault definition",
    "MetricsAnalyzer.AnalyzeTrends(context.Context, []types.MetricPoint, map[string]float64) (*ResilienceReport, error)": "analyzes metric trends for resilience insights",
    "MetricsAnalyzer.PredictImpact(context.Context, types.Fault, map[string]float64) (map[string]PredictedImpact, error)": "predicts fault impact on metrics",
    "RegisterExperimentGenerator(ExperimentGenerator) error": "registers experiment generator extension",
    "RegisterFaultInjectorPlugin(FaultInjectorPlugin) error": "registers fault injector plugin",
    "GetExperimentGenerators() []ExperimentGenerator": "returns all registered experiment generators",
    "GitHubIntegration.CreateCheckRun(context.Context, types.Experiment, string) (string, error)": "creates GitHub check run for experiment",
    "GitHubIntegration.UpdateCheckRun(context.Context, string, types.ExperimentResult) error": "updates GitHub check run with results",
    "GitHubIntegration.HandleWebhook([]byte, string) error": "handles GitHub webhook events"
  },
  "constants": {
    "StateDraft": "DRAFT",
    "StateBaselineValidation": "BASELINE_VALIDATION",
    "StateInjecting": "INJECTING",
    "StateMonitoring": "MONITORING",
    "StateRollback": "ROLLBACK",
    "StateAnalysis": "ANALYSIS",
    "StateCompleted": "COMPLETED",
    "StateAborted": "ABORTED",
    "FaultTypeLatency": "LATENCY",
    "FaultTypePacketLoss": "PACKET_LOSS",
    "FaultTypeProcessKill": "PROCESS_KILL",
    "FaultTypeCPUStress": "CPU_STRESS",
    "FaultTypeMemoryStress": "MEMORY_STRESS",
    "FaultTypeNetworkPartition": "NETWORK_PARTITION",
    "ScheduleImmediate": "IMMEDIATE",
    "ScheduleOneTime": "ONE_TIME",
    "ScheduleCron": "CRON",
    "PENDING": "ScenarioStatus constant",
    "INJECTING": "FaultState constant",
    "ACTIVE": "FaultState constant for active fault",
    "CLEANING": "FaultState constant",
    "DONE": "FaultState constant",
    "FAILED": "FaultState constant",
    "RUNNING": "ScenarioStatus constant",
    "PAUSED_MANUAL": "ScenarioStatus constant",
    "PAUSED_OBSERVER": "ScenarioStatus constant",
    "COMPLETED": "ScenarioStatus constant",
    "ABORTED": "ScenarioStatus constant",
    "EXPERIMENT": "StepType constant",
    "MANUAL_TASK": "StepType constant",
    "PAUSE": "StepType constant",
    "INJECT": "StepType constant",
    "ROLLBACK": "Experiment state for rolling back faults"
  },
  "terms": {
    "chaos engineering": "Practice of intentionally injecting failures to test system resilience",
    "steady-state hypothesis": "Expected system behavior expressed as metric thresholds",
    "blast radius": "Scope limitation for chaos experiments",
    "GameDay": "Orchestrated event running multiple chaos experiments",
    "fault injection": "Controlled introduction of failures into a system",
    "auto-rollback": "Automatic reversal of faults when safety thresholds breached",
    "safety monitor": "Component that watches metrics and triggers abort conditions",
    "cleanup ensurer": "Mechanism guaranteeing fault reversal even after crashes",
    "command-and-control architecture": "Architecture pattern with central coordination and remote execution",
    "idempotent operations": "Operations that can be applied multiple times without changing result beyond initial application",
    "sidecar agent model": "Architecture pattern where a helper component runs alongside each service instance",
    "CAP_NET_ADMIN": "Linux capability required for network configuration operations",
    "runbook": "A predefined set of instructions for responding to an incident",
    "shadow integration": "Using a dedicated test environment within production tooling for simulations",
    "inject": "A simulated external event during a GameDay to increase realism",
    "air traffic control tower": "Mental model for component coordination",
    "flight plans": "Analogy for experiment definitions",
    "clearance delivery": "Analogy for orchestrator validation",
    "ground control": "Analogy for fault injector management",
    "tower control": "Analogy for safety monitor",
    "flight recorders": "Analogy for result analyzer",
    "circuit breaker": "Pattern to fail fast when a dependent service is failing",
    "write-ahead log (WAL)": "Durable log where changes are recorded before being applied",
    "dead man's switch": "Safety mechanism that triggers automatically when a heartbeat stops",
    "property-based testing": "Testing method that verifies properties hold for all generated inputs",
    "test double": "Test substitute for a real component (mock, stub, fake)",
    "chaos maturity progression": "evolution from manual experiments to continuous resilience validation",
    "shift-left resilience testing": "testing resilience earlier in development lifecycle",
    "cryptographic signing": "using digital signatures to ensure authenticity and non-repudiation",
    "append-only WAL": "write-ahead log that only allows appending, not modification",
    "hash chain": "linked sequence of cryptographic hashes for tamper evidence",
    "resilience score": "quantitative measure of system resilience",
    "feature engineering": "process of creating ML model features from raw data",
    "Server-Sent Events (SSE)": "technology for server-to-client real-time updates over HTTP",
    "WebSocket": "protocol for full-duplex communication over TCP",
    "cgo": "Go mechanism for calling C code",
    "exponential backoff": "retry strategy with increasing delay between attempts"
  }
}