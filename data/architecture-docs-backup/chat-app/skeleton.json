{
  "title": "Real-time Chat Application: Design Document",
  "overview": "This document outlines the architecture for a real-time chat application using WebSockets. It solves the key architectural challenge of maintaining persistent, bi-directional communication channels between a server and multiple web clients, enabling instant message delivery, user presence, and conversation history. The design balances simplicity for learning with scalable patterns used in production systems.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explores the fundamental challenge of real-time communication on the web, contrasting the request-response model of HTTP with the persistent, two-way channel model of WebSockets.",
      "subsections": [
        {
          "id": "analogy-mental-model",
          "title": "Mental Model: The Telephone vs. The Mailbox",
          "summary": "Introduces HTTP as a postal service (request-response) and WebSockets as a telephone call (persistent two-way connection)."
        },
        {
          "id": "problem-definition",
          "title": "The Core Problem: Stateful Connections at Scale",
          "summary": "Defines the technical hurdles of managing thousands of concurrent, stateful connections, handling disconnections gracefully, and synchronizing state across clients."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches and Trade-offs",
          "summary": "Compares naive polling, long-polling, Server-Sent Events (SSE), and WebSockets using a structured table."
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Clearly defines the required features (Functional Goals) and quality attributes (Non-Functional Goals) of the system, as well as explicit exclusions to manage scope.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals (What it MUST do)",
          "summary": "Lists core features: real-time messaging, multiple rooms, user presence, message history, and typing indicators."
        },
        {
          "id": "non-functional-goals",
          "title": "Non-Functional Goals (How it should behave)",
          "summary": "Specifies desired system qualities: low latency, connection resilience, basic security, and debuggability."
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals (What it does NOT do)",
          "summary": "Manages expectations by stating exclusions like video/voice chat, file sharing, advanced moderation, or horizontal scaling."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Presents the macro-level component view of the system, showing how the server, clients, and external services interact.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview and Responsibilities",
          "summary": "Describes the four main pillars: the WebSocket Server, the Room & Presence Manager, the Client Application, and the Persistence Layer."
        },
        {
          "id": "file-module-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Provides a suggested directory layout for organizing the Node.js/TypeScript codebase to separate concerns."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the core data structures that flow through the system, including messages, users, rooms, and sessions.",
      "subsections": [
        {
          "id": "core-types-tables",
          "title": "Core Types and Structures",
          "summary": "Detailed tables describing the shape of ChatMessage, User, Room, and ClientSession objects."
        },
        {
          "id": "wire-format-protocol",
          "title": "Wire Format and Event Protocol",
          "summary": "Specifies the JSON-based protocol for client-server communication, listing standard event types and their payloads."
        }
      ]
    },
    {
      "id": "component-websocket-server",
      "title": "Component Design: WebSocket Server & Connection Manager",
      "summary": "Details the server component responsible for accepting connections, managing their lifecycle, and routing messages. (Covers Milestone 1)",
      "subsections": [
        {
          "id": "websocket-responsibility",
          "title": "Responsibility and Scope",
          "summary": "Handles the low-level WebSocket protocol, connection state, and acts as the entry point for all real-time traffic."
        },
        {
          "id": "mental-model-phone-operator",
          "title": "Mental Model: The Telephone Switchboard Operator",
          "summary": "Explains the server's role as a switchboard, connecting callers (clients) and routing their conversations (messages) to the correct room."
        },
        {
          "id": "interface-lifecycle",
          "title": "Interface and Connection Lifecycle",
          "summary": "Describes the events (connect, message, disconnect) and the state machine for a WebSocket connection."
        },
        {
          "id": "adr-connection-management",
          "title": "ADR: Managing Active Connections",
          "summary": "Architecture Decision Record evaluating in-memory Set vs. Map for tracking clients, choosing a Map for direct socket access."
        },
        {
          "id": "common-pitfalls-server",
          "title": "Common Pitfalls: Memory Leaks and Silent Failures",
          "summary": "Highlights failures to clean up disconnected clients, missing error handlers, and not implementing heartbeats."
        },
        {
          "id": "implementation-guidance-server",
          "title": "Implementation Guidance (Layer 2)",
          "summary": "Provides starter code for HTTP upgrade handling and skeleton for the core Connection Manager with TODOs."
        }
      ]
    },
    {
      "id": "component-message-broker",
      "title": "Component Design: Message Broker & Room Manager",
      "summary": "Details the component that orchestrates message broadcasting, room membership, and presence. (Covers Milestones 2 & 3)",
      "subsections": [
        {
          "id": "broker-responsibility",
          "title": "Responsibility and Scope",
          "summary": "Manages rooms, routes messages to appropriate subscribers, and tracks user presence (online/typing)."
        },
        {
          "id": "mental-model-pub-sub",
          "title": "Mental Model: The Publishing House and Subscribers",
          "summary": "Frames rooms as publications (topics) and users as subscribers; sending a message is publishing to a topic."
        },
        {
          "id": "interface-events",
          "title": "Interface: Core Methods and Events",
          "summary": "Table of methods like joinRoom, leaveRoom, broadcastToRoom, and getRoomList."
        },
        {
          "id": "adr-room-storage",
          "title": "ADR: In-Memory vs. External Room State",
          "summary": "Evaluates storing room data in server memory versus a shared database, choosing in-memory for simplicity in the learning context."
        },
        {
          "id": "common-pitfalls-broker",
          "title": "Common Pitfalls: Broadcast Storms and Zombie Rooms",
          "summary": "Discusses accidentally broadcasting to sender, not sanitizing room names, and rooms persisting after all users leave."
        },
        {
          "id": "implementation-guidance-broker",
          "title": "Implementation Guidance (Layer 2)",
          "summary": "Provides skeleton code for the Room and Presence Manager class with TODOs for key algorithms."
        }
      ]
    },
    {
      "id": "component-persistence-auth",
      "title": "Component Design: Persistence & Authentication Service",
      "summary": "Details the components for storing message history and managing user identity. (Covers Milestone 4)",
      "subsections": [
        {
          "id": "persistence-responsibility",
          "title": "Responsibility and Scope",
          "summary": "Handles user registration/login (auth), session validation, and storing/retrieving chat messages from a database."
        },
        {
          "id": "mental-model-library-archivist",
          "title": "Mental Model: The Library Archivist and Security Guard",
          "summary": "Compares the message store to a library archive (persistent, indexed) and authentication to a security guard checking IDs."
        },
        {
          "id": "adr-auth-timing",
          "title": "ADR: When to Authenticate - HTTP vs. WebSocket",
          "summary": "Evaluates authenticating during the HTTP upgrade vs. a custom WebSocket message, choosing upgrade for security and simplicity."
        },
        {
          "id": "common-pitfalls-persistence",
          "title": "Common Pitfalls: Unbounded History and Session Leaks",
          "summary": "Highlights loading entire message history without pagination, not expiring old sessions, and storing passwords in plain text."
        },
        {
          "id": "implementation-guidance-persistence",
          "title": "Implementation Guidance (Layer 2)",
          "summary": "Provides starter code for a simple in-message store wrapper and skeleton for the Auth Service with TODOs."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Traces the journey of a chat message from typing to display, and the flow for a user joining a room.",
      "subsections": [
        {
          "id": "sequence-send-message",
          "title": "Sequence: Sending and Receiving a Message",
          "summary": "Step-by-step walkthrough from client keypress to message broadcast and rendering on other clients."
        },
        {
          "id": "sequence-join-room",
          "title": "Sequence: Joining a Room and Loading History",
          "summary": "Step-by-step walkthrough from user requesting to join a room through receiving member list and past messages."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Describes how the system detects, responds to, and recovers from expected failures and unexpected conditions.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "Common Failure Modes and Recovery",
          "summary": "Covers network drops, server crashes, malformed messages, and full memory, with strategies like heartbeats, reconnection, and validation."
        },
        {
          "id": "edge-case-analysis",
          "title": "Edge Case Analysis",
          "summary": "Analyzes scenarios like two users with the same name, very long messages, rapid join/leave events, and clock skew."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Outlines a practical approach to verifying the system works correctly, with a focus on integration and manual checkpoint testing for learners.",
      "subsections": [
        {
          "id": "test-approach",
          "title": "Testing Approach and Property Verification",
          "summary": "Recommends testing layers (unit, integration) and key properties to verify (e.g., messages are ordered, users are removed on disconnect)."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Implementation Checkpoints",
          "summary": "For each of the four milestones, describes the expected behavior, commands to run, and outputs to verify progress."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "A practical handbook for diagnosing and fixing the most common issues learners face when building this system.",
      "subsections": [
        {
          "id": "symptom-cause-fix-table",
          "title": "Common Bugs: Symptom \u2192 Cause \u2192 Fix",
          "summary": "Structured table listing issues like 'Messages not appearing', 'User count wrong', 'Server crashes on disconnect' with diagnosis steps."
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques and Tools",
          "summary": "Suggests adding strategic log statements, using browser WebSocket inspector, and simulating network failures."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Explores potential enhancements to the system, showing how the current design accommodates or would need modification for them.",
      "subsections": [
        {
          "id": "potential-features",
          "title": "Potential Features and Scaling Paths",
          "summary": "Lists ideas like direct messaging, reactions, read receipts, bot integrations, and moving to a multi-server architecture."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key technical terms, acronyms, and domain-specific vocabulary used throughout this document.",
      "subsections": [
        {
          "id": "terms-definitions",
          "title": "Terms and Definitions",
          "summary": "Alphabetical list of terms from 'Authentication' to 'WebSocket', with clear, concise definitions."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-component-diagram",
      "title": "System Component Overview",
      "description": "Shows the four main components (WebSocket Server, Room Manager, Auth/Persistence Service, Client Browser) and their interactions. Include bidirectional WebSocket connections between Server and Clients, and data access arrows between Server components and the Auth/Persistence Service.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture"
      ]
    },
    {
      "id": "data-model-diagram",
      "title": "Core Data Relationships",
      "description": "Class diagram showing relationships between User, ClientSession, Room, and ChatMessage. User has-many ClientSessions (for multiple devices). Room has-many Users (members). Room has-many ChatMessages. ChatMessage belongs to one Room and one User (sender).",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "conn-state-machine",
      "title": "WebSocket Connection State Machine",
      "description": "State machine for a client connection: Starting state 'Connecting'. On successful upgrade -> 'Connected'. From 'Connected', on receiving a valid 'join' message -> 'Joined' (to a room). From any state, on socket close/error -> 'Disconnected'. Include actions like 'start heartbeat timer' on Connected, 'broadcast leave' on Disconnected from Joined.",
      "type": "state-machine",
      "relevant_sections": [
        "component-websocket-server"
      ]
    },
    {
      "id": "seq-send-message",
      "title": "Sequence: Broadcasting a Chat Message",
      "description": "Sequence diagram with actors: Client A, WebSocket Server, Room Manager, Persistence, and Client B. Show: 1) Client A sends 'chat' message. 2) Server validates & forwards to Room Manager. 3) Room Manager stores via Persistence. 4) Room Manager retrieves list of members in room (excluding sender). 5) Room Manager instructs Server to send message to each member's socket. 6) Server sends message to Client B.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "component-message-broker"
      ]
    },
    {
      "id": "seq-join-room",
      "title": "Sequence: User Joining a Room",
      "description": "Sequence diagram with actors: New Client, WebSocket Server, Room Manager, Persistence. Show: 1) Client sends 'join' message with room name. 2) Server validates session. 3) Server calls Room Manager's joinRoom. 4) Room Manager adds user to room member list. 5) Room Manager fetches last N messages from Persistence. 6) Room Manager broadcasts 'user_joined' to existing room members. 7) Server sends 'room_joined' success response + message history to the New Client.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "component-message-broker",
        "component-persistence-auth"
      ]
    },
    {
      "id": "flowchart-message-handling",
      "title": "Flowchart: Server Message Handling",
      "description": "Flowchart for the server's main message handler. Start: 'Receive raw message from socket'. Step 1: 'Parse JSON, catch error -> send error response'. Step 2: 'Validate required fields (type, payload)'. Step 3: 'Look up handler for message type'. Step 4: 'Execute handler (e.g., broadcast, join)'. Step 5: 'Catch any handler error -> log and send error'. End.",
      "type": "flowchart",
      "relevant_sections": [
        "component-websocket-server",
        "error-handling"
      ]
    }
  ]
}