{
  "types": {
    "Intent": "fields: name str, required_slots List[str], optional_slots List[str]",
    "Entity": "fields: type str, value str, start int, end int, confidence float, normalized Any",
    "UserUtterance": "fields: raw_text str, cleaned_text str, intent Optional[Intent], confidence float, entities List[Entity], slots Dict[str, Any]",
    "DialogState": "fields: session_id str, current_intent Optional[Intent], filled_slots Dict[str, Any], missing_slots List[str], confirmation_required bool, last_activity datetime, conversation_history List[Dict]",
    "ResponseTemplate": "fields: template_string str, required_slots List[str], variation_group str",
    "EntityNormalizer": "fields: none (static methods)",
    "EntityExtractor": "fields: patterns Dict[str, List[str]], nlp Optional[spacy model]",
    "SlotFiller": "fields: slot_mappings Dict[str, Dict[str, str]]",
    "InMemorySessionStore": "fields: _store Dict[str, DialogState], _lock threading.RLock, timeout_seconds int",
    "StructuredLogger": "fields: logger logging.Logger",
    "StateInspector": "fields: none (static methods)",
    "ChatbotTestHarness": "fields: dm DialogManager, conversation_log List[Dict]",
    "DialogManager": "fields: intent_classifier IntentClassifier, entity_extractor EntityExtractor, slot_filler SlotFiller, response_generator ResponseGenerator, session_store InMemorySessionStore, logger logging.Logger, debug_mode bool, debug_info Dict",
    "LLMFallbackClassifier": "fields: primary_classifier IntentClassifier, llm_client OpenAIClient, confidence_threshold float, use_cache bool, cache Dict, logger logging.Logger",
    "OpenAIClient": "fields: client openai.OpenAI, model str, logger logging.Logger",
    "VoiceEnabledDialogManager": "fields: stt_service Any, (inherits from DialogManager)",
    "TerminologyValidator": "fields: root_dir Path, violations List[Tuple[str, int, str]]"
  },
  "methods": {
    "Intent.__init__(name, required_slots, optional_slots) returns": "Creates an intent with required and optional slots",
    "DialogState.update_activity() returns": "Updates last_activity timestamp to now",
    "DialogState.is_expired(timeout_seconds) returns bool": "Checks if session has expired due to inactivity",
    "DialogState.reset() returns": "Clears conversation context",
    "UserUtterance.update_slots_from_entities(slot_mapping) returns": "Helper to fill slots dict from entities",
    "EntityExtractor.extract_entities(text) returns List[Entity]": "Extract all entities from text",
    "EntityExtractor._load_patterns() returns Dict[str, List[str]]": "Load regex patterns for entity types",
    "EntityExtractor._load_spacy_model() returns None": "Lazy load spaCy NER model",
    "EntityExtractor._map_spacy_label(spacy_label) returns Optional[str]": "Map spaCy entity labels to our types",
    "EntityExtractor._resolve_overlaps(entities) returns List[Entity]": "Resolve overlapping entity spans",
    "EntityExtractor._normalize_entities(entities) returns List[Entity]": "Normalize entity values to canonical formats",
    "SlotFiller.fill_slots(utterance, intent, state) returns Dict[str, Any]": "Map entities to slots and update dialog state",
    "DialogManager.process_utterance(session_id: str, user_input: str) returns DialogState": "Central method to process a user message and update dialog state",
    "DialogManager._get_or_create_state(session_id: str) returns DialogState": "Internal helper to retrieve or create a session state",
    "DialogManager._handle_global_commands(text: str, state: DialogState) returns bool": "Check for and process global commands like 'reset'",
    "generate_response(state) returns str": "Main public method of ResponseGenerator. Given the current dialog state, selects template, fills variables, returns response.",
    "TemplateRegistry._load_templates(file_path) returns None": "Load templates from a YAML file into the registry.",
    "TemplateRegistry.get_templates_for_group(group) returns List[ResponseTemplate]": "Return all templates belonging to a specific variation group.",
    "TemplateRegistry.get_random_template_for_group(group) returns ResponseTemplate": "Randomly select one template from a variation group.",
    "ResponseGenerator._format_slot_value(value) returns str": "Converts a slot value into a user-friendly string for insertion into a response template.",
    "DialogManager.process_utterance(session_id: str, user_input: str) returns Tuple[DialogState, str]": "Main orchestrator method to process a user message",
    "IntentClassifier.predict(text: str, state: Optional[DialogState]) returns UserUtterance": "Classifies intent (with optional context)",
    "ResponseGenerator.generate_response(state) returns str": "Construct response based on dialog state",
    "InMemorySessionStore.get(session_id) returns Optional[DialogState]": "Retrieve session if not expired",
    "InMemorySessionStore.set(session_id, state) returns None": "Store or update session",
    "StateInspector.dump_state(state, include_history) returns Dict[str, Any]": "Serialize DialogState to dictionary for debugging.",
    "StateInspector.format_state_for_display(state) returns str": "Create human-readable state summary.",
    "StateInspector.analyze_utterance(utterance) returns Dict[str, Any]": "Analyze a UserUtterance for debugging.",
    "ChatbotTestHarness.simulate_turn(session_id, user_input) returns str": "Process one user turn and return response.",
    "ChatbotTestHarness.run_conversation(session_id, script) returns None": "Run a complete conversation script.",
    "ChatbotTestHarness.diagnose_issue(session_id, problematic_input) returns str": "Run diagnostics on problematic input.",
    "DialogManager._log_debug_info() returns None": "Log detailed debug information if in debug mode.",
    "DialogManager.get_debug_info() returns Dict": "Retrieve debug information from last processed utterance.",
    "LLMFallbackClassifier.predict(text, state) returns UserUtterance": "Predict intent with primary classifier, fall back to LLM if low confidence",
    "LLMFallbackClassifier._get_context_string(state) returns str": "Extract relevant context from dialog state for LLM prompt",
    "OpenAIClient.classify_intent(text, possible_intents, context) returns Dict": "Use LLM to classify intent from text",
    "OpenAIClient._build_classification_prompt(text, intents, context) returns str": "Build prompt for intent classification",
    "VoiceEnabledDialogManager.process_audio_chunk(session_id, audio_chunk) returns DialogState": "Process audio chunk, transcribe when utterance complete",
    "TerminologyValidator.scan_file(file_path) returns None": "Scan a single file for terminology violations.",
    "TerminologyValidator._check_line(file_path, line_num, line) returns None": "Check a single line for terminology issues.",
    "TerminologyValidator.scan_directory(directory, extensions) returns None": "Recursively scan directory for files with given extensions.",
    "TerminologyValidator.print_violations() returns None": "Print all found violations in a readable format.",
    "TerminologyValidator.validate_glossary_coverage() returns None": "Check if all required terms appear somewhere in the codebase.",
    "validate_term(term) returns bool": "Validate that a term follows Project Athena conventions.",
    "get_term_variations(term) returns List[str]": "Get all valid variations of a term (different cases, spacings)."
  },
  "constants": {
    "INTENT_CONFIDENCE_THRESHOLD": "0.7",
    "SESSION_TIMEOUT_SECONDS": "300",
    "INTENT_CONCEPT": "\"intent\"",
    "ENTITY_CONCEPT": "\"entity\"",
    "SLOT_CONCEPT": "\"slot\"",
    "DIALOG_STATE_CONCEPT": "\"dialog state\"",
    "SESSION_CONCEPT": "\"session\"",
    "INTENT_TYPE": "\"Intent\"",
    "ENTITY_TYPE": "\"Entity\"",
    "USER_UTTERANCE_TYPE": "\"UserUtterance\"",
    "DIALOG_STATE_TYPE": "\"DialogState\"",
    "RESPONSE_TEMPLATE_TYPE": "\"ResponseTemplate\"",
    "CLASSIFICATION_METHODS": "\"classification methods\"",
    "EXTRACTION_METHODS": "\"extraction methods\"",
    "DIALOG_METHODS": "\"dialog management methods\"",
    "RESPONSE_METHODS": "\"response generation methods\"",
    "ERROR_INTENT_UNKNOWN": "\"intent_unknown\"",
    "ERROR_ENTITY_MISSING": "\"entity_missing\"",
    "ERROR_SLOT_CONFLICT": "\"slot_conflict\"",
    "ERROR_SESSION_EXPIRED": "\"session_expired\""
  },
  "terms": {
    "Intent": "User's goal or purpose behind an utterance",
    "Entity": "Specific piece of structured information extracted from text",
    "Slot": "Named parameter that an intent requires",
    "Dialog State": "Complete representation of a conversation's current context",
    "TF-IDF": "Term Frequency-Inverse Document Frequency, text vectorization method",
    "NER": "Named Entity Recognition, identifying entities like people, dates, locations",
    "Modular Pipeline": "Architectural pattern with independent components in sequential chain",
    "Entity Extraction": "Process of identifying and extracting entities from text",
    "Entity Normalization": "Converting extracted entity text to canonical data formats",
    "Slot Filling": "Mapping extracted entities to intent slots",
    "Regex Patterns": "Regular expressions for structured entity extraction",
    "Conflict Resolution": "Strategy for handling overlapping entity spans",
    "Hybrid Extraction": "Entity extraction combining rule-based patterns and ML NER",
    "Session": "Unique conversation instance between user and bot",
    "State Machine": "Model defining dialog states and transitions",
    "Context Carryover": "Maintaining conversation context across multiple turns",
    "Response Generator": "Component constructing natural language responses",
    "Template": "Short for response template",
    "Placeholder": "Syntax markers in response templates for dynamic content",
    "Variable Substitution": "Replacing placeholders with slot values",
    "Variation Group": "Identifier grouping multiple alternative templates",
    "Fallback Response": "Generic response for unrecognized or ambiguous input",
    "Happy Path": "Single-turn conversation with complete information",
    "Multi-Turn Dialogue": "Conversation spanning multiple exchanges to collect information",
    "Session Store": "Component persisting dialog state between requests",
    "Orchestrator": "The DialogManager as central coordinator",
    "Global Command": "User utterance that interrupts normal dialog flow for system actions",
    "Assembly Line": "Mental model for modular pipeline architecture with sequential processing stages",
    "Debugging": "Process of identifying, diagnosing, and fixing defects",
    "Logging": "Recording system events and state for diagnosis",
    "Structured Logging": "Logging in machine-parsable format",
    "Test Harness": "Framework for automated testing of components",
    "State Inspection": "Examining internal component state for debugging",
    "modular conversation factory": "Metaphor for the chatbot's extensible architecture",
    "Reference Librarian": "Mental model for knowledge base integration",
    "LLM Fallback": "Using Large Language Model as backup classifier",
    "Multi-Modal": "Supporting multiple input/output modalities beyond text",
    "Proactive Suggestions": "System-initiated turns based on conversation context",
    "Semantic Slot Filling": "Extracting entities based on meaning and context",
    "Context-Aware Classification": "Intent classification using dialog state as context",
    "Confidence Threshold": "Numerical cutoff for distinguishing reliable predictions from uncertain ones",
    "Conversation History": "Chronological record of exchanges within a session",
    "Mental Model": "Intuitive analogy explaining component purpose and behavior",
    "Modular Conversation Factory": "Metaphor for extensible chatbot architecture",
    "Named Entity Recognition (NER)": "Identifying and classifying entities in text",
    "Response Template": "Pre-written text pattern with placeholders",
    "Term Frequency-Inverse Document Frequency (TF-IDF)": "Text vectorization method weighting word importance",
    "Unknown Intent": "Special label for low-confidence intent predictions"
  }
}