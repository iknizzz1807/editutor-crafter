{
  "title": "Project Athena: Design Document for Intent-Based Chatbot",
  "overview": "This document outlines the architecture for an intent-based chatbot that interprets user messages to understand goals (intents) and extract key information (entities), managing multi-turn conversations without using Large Language Models (LLMs). The key architectural challenge is designing a modular, maintainable system that accurately interprets user input while gracefully handling ambiguity, missing information, and conversational context.",
  "sections": [
    {
      "id": "context-problem",
      "title": "1. Context and Problem Statement",
      "summary": "Defines the core problem of understanding natural language without LLMs, introduces the mental model of a helpful concierge, and compares existing solution approaches like rule-based systems and ML classifiers.",
      "subsections": [
        {
          "id": "context-analogy",
          "title": "The Concierge Mental Model"
        },
        {
          "id": "problem-definition",
          "title": "Defining Intent and Entity Understanding"
        },
        {
          "id": "existing-approaches",
          "title": "Comparison of Existing Approaches"
        }
      ]
    },
    {
      "id": "goals-nongoals",
      "title": "2. Goals and Non-Goals",
      "summary": "Establishes the functional and non-functional requirements for the system, clearly scoping what the chatbot will and will not do.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals (What it MUST do)"
        },
        {
          "id": "non-functional-goals",
          "title": "Non-Functional Goals (Quality Attributes)"
        },
        {
          "id": "explicit-nongoals",
          "title": "Explicit Non-Goals (What it does NOT do)"
        }
      ]
    },
    {
      "id": "high-level-arch",
      "title": "3. High-Level Architecture",
      "summary": "Provides a bird's-eye view of the system components, their responsibilities, and how data flows between them, accompanied by a component diagram.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Responsibilities and Data Flow"
        },
        {
          "id": "recommended-file-structure",
          "title": "Recommended File and Module Structure"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Describes the core data structures, including UserUtterance, Intent, Entity, DialogState, and ResponseTemplate, defining the information that flows through the system.",
      "subsections": [
        {
          "id": "core-type-definitions",
          "title": "Core Type Definitions and Relationships"
        },
        {
          "id": "training-data-format",
          "title": "Training Data Format for Intents and Entities"
        }
      ]
    },
    {
      "id": "component-intent-classifier",
      "title": "5.1 Component: Intent Classifier",
      "summary": "Details the design of the component that maps user text to an intent label, covering the mental model, training pipeline, and prediction logic with confidence thresholds. (Milestone 1)",
      "subsections": [
        {
          "id": "classifier-mental-model",
          "title": "Mental Model: The Sorting Hat"
        },
        {
          "id": "classifier-interface",
          "title": "Interface and Behavior"
        },
        {
          "id": "classifier-adr-tfidf",
          "title": "ADR: Choosing TF-IDF over Word Embeddings"
        },
        {
          "id": "classifier-pitfalls",
          "title": "Common Pitfalls and Mitigations"
        },
        {
          "id": "classifier-implementation",
          "title": "Implementation Guidance"
        }
      ]
    },
    {
      "id": "component-entity-extractor",
      "title": "5.2 Component: Entity Extractor and Slot Filler",
      "summary": "Explains how the system identifies and extracts structured information from text using rule-based patterns and NER models, then maps them to intent parameters. (Milestone 2)",
      "subsections": [
        {
          "id": "extractor-mental-model",
          "title": "Mental Model: The Form Filler"
        },
        {
          "id": "extractor-interface",
          "title": "Interface and Behavior"
        },
        {
          "id": "extractor-adr-hybrid",
          "title": "ADR: Hybrid Rule-Based and ML NER Approach"
        },
        {
          "id": "extractor-pitfalls",
          "title": "Common Pitfalls and Mitigations"
        },
        {
          "id": "extractor-implementation",
          "title": "Implementation Guidance"
        }
      ]
    },
    {
      "id": "component-dialog-manager",
      "title": "5.3 Component: Dialog Manager",
      "summary": "Describes the stateful component that orchestrates conversations, tracks context, manages slot filling, and determines the next system action. (Milestone 3)",
      "subsections": [
        {
          "id": "dialog-mental-model",
          "title": "Mental Model: The Conversation Conductor"
        },
        {
          "id": "dialog-interface",
          "title": "Interface and State Machine"
        },
        {
          "id": "dialog-adr-session",
          "title": "ADR: In-Memory Session Store vs. Persistent Storage"
        },
        {
          "id": "dialog-pitfalls",
          "title": "Common Pitfalls and Mitigations"
        },
        {
          "id": "dialog-implementation",
          "title": "Implementation Guidance"
        }
      ]
    },
    {
      "id": "component-response-generator",
      "title": "5.4 Component: Response Generator",
      "summary": "Covers the template-based system for constructing natural language responses, including variable substitution, variation, and fallback handling. (Milestone 4)",
      "subsections": [
        {
          "id": "response-mental-model",
          "title": "Mental Model: The Mad Libs Assembler"
        },
        {
          "id": "response-interface",
          "title": "Interface and Template Design"
        },
        {
          "id": "response-adr-templates",
          "title": "ADR: String Templates vs. Templating Engine"
        },
        {
          "id": "response-pitfalls",
          "title": "Common Pitfalls and Mitigations"
        },
        {
          "id": "response-implementation",
          "title": "Implementation Guidance"
        }
      ]
    },
    {
      "id": "interactions-dataflow",
      "title": "6. Interactions and Data Flow",
      "summary": "Walks through the end-to-end sequence of processing a user message, from raw input to final response, highlighting component hand-offs.",
      "subsections": [
        {
          "id": "happy-path-sequence",
          "title": "Happy Path: Complete Intent Fulfillment"
        },
        {
          "id": "multi-turn-sequence",
          "title": "Multi-Turn: Slot Filling Dialogue"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "7. Error Handling and Edge Cases",
      "summary": "Documents strategies for handling ambiguous input, low-confidence predictions, missing entities, session expiration, and unexpected user commands.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "Common Failure Modes and Recovery"
        },
        {
          "id": "edge-case-strategies",
          "title": "Edge Case Handling Strategies"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "8. Testing Strategy",
      "summary": "Outlines a tiered testing approach from unit tests for components to integration tests for dialog flows, including milestone verification checkpoints.",
      "subsections": [
        {
          "id": "testing-pyramid",
          "title": "Testing Pyramid for Chatbot Systems"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "9. Debugging Guide",
      "summary": "Provides a symptom-cause-fix table for common implementation bugs, along with techniques for logging and inspecting system state.",
      "subsections": [
        {
          "id": "symptom-cause-fix",
          "title": "Common Bug Table: Symptom \u2192 Cause \u2192 Fix"
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques and Logging"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "10. Future Extensions",
      "summary": "Suggests potential enhancements to the system, such as integrating an LLM for fallback, adding a knowledge base, or supporting voice interfaces.",
      "subsections": [
        {
          "id": "enhancement-ideas",
          "title": "Ideas for Enhancement and Scaling"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "11. Glossary",
      "summary": "Defines key terms used throughout the document, such as Intent, Entity, Slot, Dialog State, TF-IDF, and NER.",
      "subsections": [
        {
          "id": "term-definitions",
          "title": "Term Definitions and References"
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-component-diagram",
      "title": "System Component Diagram",
      "description": "Shows the four core components (Intent Classifier, Entity Extractor, Dialog Manager, Response Generator) and their interactions. Include the User and a potential external API as actors. Arrows should indicate the primary data flow direction.",
      "type": "component",
      "relevant_sections": [
        "high-level-arch",
        "interactions-dataflow"
      ]
    },
    {
      "id": "data-model-diagram",
      "title": "Data Model Relationship Diagram",
      "description": "Illustrates the relationships between key data types: DialogState contains a current Intent and a map of Slots (key-value pairs). An Intent has a name and a list of required Slot names. An Entity has a type and a raw value. A ResponseTemplate has a template string and a list of required Slot names for substitution.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "dialog-state-machine",
      "title": "Dialog Manager State Machine",
      "description": "A state machine showing the dialog states: IDLE, INTENT_IDENTIFIED, COLLECTING_SLOTS, CONFIRMING, and READY_TO_EXECUTE. Transitions are triggered by events like 'intent_detected', 'slot_received', 'confirmation_yes', 'confirmation_no', 'reset'. Include actions like 'prompt_for_slot' and 'generate_response' on transitions.",
      "type": "state-machine",
      "relevant_sections": [
        "component-dialog-manager"
      ]
    },
    {
      "id": "intent-classification-flowchart",
      "title": "Intent Classification and Fallback Flowchart",
      "description": "A flowchart detailing the steps from receiving user text to outputting an intent label or 'unknown'. Steps include: vectorize input, predict with probabilities, check max confidence against threshold, if below threshold return 'unknown', else return the intent with highest confidence.",
      "type": "flowchart",
      "relevant_sections": [
        "component-intent-classifier"
      ]
    },
    {
      "id": "conversation-sequence-diagram",
      "title": "Sequence Diagram: Multi-Turn Slot Filling",
      "description": "A sequence diagram showing the interaction between User, Dialog Manager, Intent Classifier, and Entity Extractor across two turns. First turn: user provides partial info, DM gets intent, extracts some entities, identifies missing slot, prompts user. Second turn: user provides missing info, DM extracts entity, updates state, all slots filled, DM triggers response generation.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-dataflow",
        "component-dialog-manager"
      ]
    }
  ]
}