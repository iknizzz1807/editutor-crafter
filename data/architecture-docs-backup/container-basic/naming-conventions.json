{
  "types": {
    "container_config_t": "fields: rootfs_path char*, hostname char*, memory_limit_bytes size_t, cpu_percent int, max_processes int",
    "container_instance_t": "fields: child_pid pid_t, namespace_fds int[6], cgroup_path char*",
    "cleanup_list_t": "fields: cleanup_func void(*)(void*), data void*, next struct cleanup_list*",
    "device_node": "fields: path char*, mode mode_t, device dev_t",
    "filesystem_info": "fields: name char*, supports_pivot_root int, default_options char*",
    "container_sync_t": "fields: parent_pipe int[2], child_pipe int[2]",
    "container_error_t": "enum for error types and codes",
    "container_error_context_t": "structure containing error type, component, operation, system errno, details, and recovery status",
    "test_container_config_t": "fields: test_name char*, rootfs_path char*, memory_limit_bytes size_t, cpu_percent int, max_processes int, enable_network int, cleanup_on_exit int",
    "test_result_t": "fields: success int, failure_reason char*, expected_value int, actual_value int, verification_details char*",
    "test_cleanup_item_t": "fields: cleanup_func void(*)(void*), cleanup_data void*, description char*, next struct test_cleanup_item*",
    "namespace_info_t": "fields: ns_type char[16], ns_path char[256], ns_inode ino_t, accessible int",
    "enforcement_report_t": "fields: enforcement_working int, memory_usage size_t, cpu_throttle_percent int, process_count int, recommendations char*",
    "image_layer_t": "fields: layer_id char[64], parent_layer_id char[64], layer_path char[256], layer_size size_t, change_type layer_change_t",
    "container_image_t": "fields: image_id char[64], image_name char[128], layer_count int, layers image_layer_t*, total_size size_t",
    "overlay_mount_t": "fields: lower_dirs char**, upper_dir char*, work_dir char*, merged_dir char*",
    "service_endpoint_t": "fields: service_name char[64], container_id char[64], ip_address char[16], port uint16_t, health_status endpoint_health_t, last_heartbeat time_t",
    "service_registry_t": "fields: services service_endpoint_t**, service_count int, registry_lock pthread_mutex_t",
    "service_query_t": "fields: service_name char[64], preferred_zone char[32], load_balancing lb_strategy_t, timeout_ms int",
    "container_spec_t": "fields: container_name char[64], image_name char[128], replicas int, dependencies char**, service_ports port_mapping_t*, resource_limits container_config_t",
    "deployment_spec_t": "fields: deployment_name char[64], container_specs container_spec_t*, spec_count int, network_name char[64]",
    "deployment_state_t": "fields: spec deployment_spec_t, running_containers container_instance_t**, container_count int, state_lock pthread_mutex_t",
    "service_connection_t": "fields: source_container char[64], target_service char[64], connection_type connection_type_t, load_balancer load_balancer_t*",
    "load_balancer_t": "fields: strategy lb_strategy_t, endpoints service_endpoint_t*, endpoint_count int, current_index int"
  },
  "methods": {
    "container_create(config, container) returns int": "creates container with namespaces and cgroups",
    "container_wait(container) returns int": "waits for container process to exit",
    "container_destroy(container) returns int": "cleans up container resources",
    "safe_clone(fn, stack, flags, arg) returns pid_t": "wrapper for clone() syscall with error checking",
    "safe_mount(source, target, type, flags, data) returns int": "wrapper for mount() syscall with error reporting",
    "register_cleanup(list, func, data)": "registers cleanup function for failure recovery",
    "execute_cleanup(list)": "executes all registered cleanup functions",
    "create_pid_namespace(config, container) returns int": "creates new PID namespace using clone()",
    "container_init_process(arg) returns int": "entry point for container process as PID 1",
    "setup_init_signals() returns int": "configures signal handlers for zombie reaping",
    "create_mount_namespace(config, container) returns int": "creates new mount namespace and sets up isolated filesystem view",
    "setup_container_rootfs(rootfs_path, old_root) returns int": "prepares container root filesystem directory structure",
    "pivot_to_container_root(new_root, old_root) returns int": "switches filesystem root using pivot_root syscall",
    "mount_essential_filesystems() returns int": "mounts /proc, /sys, and /dev inside container namespace",
    "setup_mount_propagation() returns int": "configures mount propagation to prevent host leakage",
    "bind_mount_host_directories(config) returns int": "creates bind mounts for shared host directories",
    "ensure_directory_exists(path, mode) returns int": "creates directory and parent directories if needed",
    "create_device_node(path, mode, device) returns int": "creates device node with proper permissions",
    "is_mount_point(path) returns int": "checks if path is currently a mount point",
    "set_mount_propagation(path, type) returns int": "sets mount propagation type for path",
    "create_network_namespace(config, container) returns int": "creates new network namespace and stores namespace file descriptor",
    "setup_container_networking(config, container_pid) returns int": "configures veth pair and assigns container end to target namespace",
    "create_veth_pair(host_if_name, container_if_name) returns int": "creates virtual ethernet pair with specified interface names",
    "assign_veth_to_namespace(if_name, target_pid) returns int": "moves network interface to target process namespace",
    "configure_container_interface(if_name, ip_address, netmask) returns int": "sets IP address and brings interface up inside container namespace",
    "attach_to_bridge(if_name, bridge_name) returns int": "adds host veth end to specified bridge for inter-container communication",
    "setup_default_route(gateway_ip) returns int": "configures default route inside container namespace",
    "cleanup_network_namespace(container) returns int": "removes veth interfaces and closes namespace file descriptors",
    "allocate_container_ip(bridge_name, requested_ip) returns char*": "allocates available IP address from bridge subnet",
    "create_container_cgroup(config, container) returns int": "creates cgroup hierarchy for container and configures resource limits",
    "assign_process_to_cgroup(cgroup_path, pid) returns int": "assigns process to cgroup by writing PID to tasks file",
    "set_memory_limit(cgroup_path, limit_bytes) returns int": "configures memory limit and OOM behavior for cgroup",
    "set_cpu_limit(cgroup_path, cpu_percent) returns int": "configures CPU quota and period to limit CPU usage percentage",
    "set_process_limit(cgroup_path, max_processes) returns int": "configures maximum number of processes/threads in cgroup",
    "cleanup_container_cgroup(cgroup_path) returns int": "removes cgroup directory and cleans up kernel resources",
    "detect_cgroup_version() returns int": "detects whether system uses cgroups v1 or v2 and returns version",
    "get_cgroup_path(container_id, controller) returns char*": "constructs filesystem path for container's cgroup in specified controller",
    "verify_controller_available(controller) returns int": "checks if specified cgroup controller is available and enabled",
    "read_cgroup_stat(cgroup_path, stat_name) returns long": "reads current resource usage statistics from cgroup",
    "write_cgroup_file(path, value) returns int": "safely writes value to cgroup control file with error checking",
    "create_sync_pipes(sync) returns int": "creates parent-child synchronization pipes",
    "wait_for_child_ready(sync) returns int": "parent waits for child setup completion",
    "signal_parent_ready(sync) returns int": "child signals setup completion",
    "handle_container_error(container, error) returns int": "coordinates error cleanup and reporting",
    "propagate_child_error(child_pid, child_status) returns int": "interprets child exit status as error type",
    "create_error_context(type, component, operation)": "creates detailed error context",
    "classify_namespace_error(errno_val)": "classifies system errors into container error types",
    "check_memory_pressure(cgroup_path, pressure_level)": "monitors memory pressure in cgroup",
    "check_cpu_throttling(cgroup_path, throttled_time)": "monitors CPU throttling statistics",
    "detect_oom_condition(container_pid, oom_occurred)": "checks for OOM killer activity",
    "create_test_container(config) returns pid_t": "creates test container with specified configuration",
    "verify_pid_isolation(container_pid) returns test_result_t": "verifies PID namespace isolation",
    "verify_mount_isolation(container_pid, test_file) returns test_result_t": "verifies mount namespace filesystem isolation",
    "verify_network_isolation(container_pid) returns test_result_t": "verifies network namespace isolation",
    "verify_resource_limits(container_pid, config) returns test_result_t": "verifies cgroup limits enforcement",
    "register_test_cleanup(list, func, data, desc)": "registers cleanup function",
    "execute_test_cleanup(list)": "executes all registered cleanup functions",
    "test_pid_namespace_isolation() returns int": "test PID namespace isolation",
    "test_mount_namespace_isolation() returns int": "test mount namespace isolation",
    "test_network_namespace_isolation() returns int": "test network namespace isolation",
    "test_cgroup_resource_limits() returns int": "test cgroup resource limits",
    "diagnose_container_state(container, config, buffer, size) returns int": "comprehensive container state analysis and diagnosis",
    "verify_resource_enforcement(cgroup_path, config, report) returns int": "check if cgroup limits are working correctly",
    "inspect_process_namespaces(pid, ns_info, max_ns) returns int": "inspect all namespaces for given process",
    "read_cgroup_stats(cgroup_path, controller, buffer, size) returns int": "read resource usage statistics from cgroup",
    "test_network_connectivity(container_pid, target_ip) returns int": "test network connectivity from container namespace",
    "create_user_namespace(config, container) returns int": "creates user namespace with CLONE_NEWUSER flag",
    "setup_user_mappings(config, child_pid) returns int": "establishes UID/GID mappings from parent process",
    "write_uid_map(child_pid, inside_uid, outside_uid, length) returns int": "writes user ID mapping to /proc/[pid]/uid_map",
    "write_gid_map(child_pid, inside_gid, outside_gid, length) returns int": "writes group ID mapping to /proc/[pid]/gid_map",
    "verify_user_isolation(container_pid) returns int": "verifies user namespace isolation is working",
    "create_uts_namespace(config, container) returns int": "creates UTS namespace with CLONE_NEWUTS flag",
    "setup_container_hostname(hostname) returns int": "sets hostname inside UTS namespace using sethostname()",
    "setup_container_domainname(domainname) returns int": "sets domain name inside UTS namespace using setdomainname()",
    "get_container_identity(hostname_buf, domain_buf) returns int": "retrieves current hostname and domain name",
    "create_ipc_namespace(config, container) returns int": "creates IPC namespace with CLONE_NEWIPC flag",
    "list_ipc_objects(objects, max_objects) returns int": "lists System V IPC objects in current namespace",
    "cleanup_ipc_namespace(container) returns int": "removes any remaining IPC objects before namespace destruction",
    "setup_overlay_mount(image, container_id, overlay) returns int": "prepares and mounts overlay filesystem for container",
    "prepare_image_layers(image, layer_dirs) returns int": "extracts or mounts all image layers to separate directories",
    "create_overlay_dirs(container_id, upper, work, merged) returns int": "creates upper, work, and merged directories for overlay mount",
    "mount_overlay_filesystem(overlay) returns int": "mounts overlay filesystem with specified layer configuration",
    "cleanup_overlay_mount(overlay) returns int": "unmounts overlay filesystem and cleans up directories",
    "commit_container_changes(overlay, new_layer) returns int": "creates new image layer from container's upper directory",
    "pull_image_layers(image_name, registry_url) returns int": "downloads image layers from remote registry",
    "extract_layer_archive(layer_path, extract_dir) returns int": "extracts compressed layer archive to directory",
    "verify_layer_integrity(layer_path, expected_hash) returns int": "verifies layer content matches expected SHA256 hash",
    "store_image_manifest(image_name, manifest) returns int": "stores image manifest in local image store",
    "load_image_manifest(image_name, manifest) returns int": "loads image manifest from local image store",
    "garbage_collect_layers(retain_days) returns int": "removes unused layers older than specified days",
    "list_available_images(images, max_images) returns int": "lists all images available in local image store",
    "register_service(service_name, container_id, ip, port) returns int": "registers new service endpoint in registry",
    "deregister_service(service_name, container_id) returns int": "removes service endpoint from registry",
    "discover_service(query, endpoints, max_endpoints) returns int": "queries registry for available service endpoints",
    "update_service_health(service_name, container_id, health) returns int": "updates health status of registered service",
    "list_services(services, max_services) returns int": "lists all services currently registered",
    "cleanup_expired_services(max_age_seconds) returns int": "removes services that haven't sent heartbeats",
    "create_deployment(spec, deployment) returns int": "creates new multi-container deployment",
    "update_deployment(deployment, new_spec) returns int": "updates existing deployment with new specification",
    "delete_deployment(deployment) returns int": "stops all containers and deletes deployment",
    "reconcile_deployment_state(deployment) returns int": "ensures actual state matches desired state",
    "scale_container_replicas(deployment, container_name, replicas) returns int": "changes number of replicas for specific container",
    "restart_failed_containers(deployment) returns int": "restarts containers that have failed or stopped",
    "check_container_dependencies(spec, container_name) returns int": "verifies all dependencies are running and healthy",
    "create_service_network(network_name, subnet) returns int": "creates dedicated network for service communication",
    "connect_container_to_service(container, service_name, connection) returns int": "establishes connection to named service",
    "setup_load_balancer(service_name, strategy, balancer) returns int": "creates load balancer for service with multiple endpoints",
    "route_service_request(connection, request) returns int": "routes request to appropriate service endpoint",
    "handle_endpoint_failure(balancer, failed_endpoint) returns int": "removes failed endpoint from load balancer rotation",
    "update_service_endpoints(balancer, new_endpoints) returns int": "updates load balancer with current healthy endpoints",
    "clone() system call": "creates new process with specified namespace isolation",
    "pivot_root": "operation that changes filesystem root directory"
  },
  "constants": {
    "STACK_SIZE": "1024*1024 bytes for clone() stack",
    "CONTAINER_NS_FLAGS": "CLONE_NEWPID|CLONE_NEWNS|CLONE_NEWNET|CLONE_NEWUTS|CLONE_NEWIPC",
    "CGROUPS_V1_PATH": "/sys/fs/cgroup",
    "CGROUPS_V2_PATH": "/sys/fs/cgroup/unified",
    "CONTAINER_CGROUP_PREFIX": "container-basic",
    "CLONE_NEWPID": "flag for creating new PID namespace",
    "CLONE_NEWNS": "flag for creating new mount namespace",
    "MS_PRIVATE": "mount propagation flag for private mounts",
    "MS_BIND": "mount flag for bind mounts",
    "MS_REC": "mount flag for recursive operations",
    "MNT_DETACH": "umount flag for lazy unmounting",
    "CLONE_NEWNET": "flag for creating new network namespace",
    "IFNAMSIZ": "maximum network interface name length",
    "CONTAINER_ERROR_NONE": "no error occurred",
    "CONTAINER_ERROR_VALIDATION": "configuration validation failed",
    "CONTAINER_ERROR_NAMESPACES": "namespace creation failed",
    "CONTAINER_ERROR_MOUNT": "mount operations failed",
    "CONTAINER_ERROR_NETWORK": "network setup failed",
    "CONTAINER_ERROR_CGROUPS": "cgroup setup failed",
    "CONTAINER_ERROR_OOM": "out of memory condition",
    "CONTAINER_ERROR_PRIVILEGES": "insufficient permissions",
    "CONTAINER_ERROR_KERNEL_FEATURE": "kernel feature unavailable",
    "CONTAINER_ERROR_RESOURCE_LIMIT": "system resource limit hit",
    "CONTAINER_ERROR_CLEANUP": "cleanup operation failed",
    "CONTAINER_ERROR_TIMEOUT": "operation timeout",
    "CONTAINER_NS_FLAGS_EXTENDED": "CLONE_NEWPID|CLONE_NEWNS|CLONE_NEWNET|CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWUSER",
    "CLONE_NEWUSER": "flag for creating new user namespace",
    "CLONE_NEWUTS": "flag for creating new UTS namespace",
    "CLONE_NEWIPC": "flag for creating new IPC namespace",
    "MAX_SERVICE_NAME": "64 bytes maximum service name length",
    "MAX_CONTAINER_ID": "64 bytes maximum container identifier length",
    "MAX_ENDPOINTS_PER_SERVICE": "16 maximum endpoints per service",
    "ENDPOINT_HEALTHY": "service endpoint is responding correctly",
    "ENDPOINT_UNHEALTHY": "service endpoint is not responding",
    "ENDPOINT_UNKNOWN": "service endpoint health status unknown"
  },
  "terms": {
    "process isolation": "separating processes so they cannot interfere with each other",
    "namespace": "kernel feature that provides isolated views of system resources",
    "cgroups": "kernel feature that limits and controls resource usage",
    "clone() system call": "creates new process with specified namespace isolation",
    "pivot_root": "operation that changes filesystem root directory",
    "veth pair": "virtual ethernet device pair for container networking",
    "PID namespace": "isolates process ID numbering",
    "mount namespace": "isolates filesystem mount points",
    "network namespace": "isolates network interfaces and routing",
    "cleanup list": "mechanism for tracking resource cleanup functions",
    "container configuration": "structure defining container parameters and resource limits",
    "namespace handles": "references to active namespaces and their cleanup requirements",
    "zombie reaping": "collecting exit status from terminated child processes",
    "mount propagation": "how mount events spread between namespaces",
    "bind mount": "mounts existing directory at different location",
    "essential filesystems": "kernel virtual filesystems like /proc and /sys needed by containers",
    "filesystem isolation": "preventing container from accessing host filesystem",
    "old root": "previous root filesystem after pivot_root operation",
    "bridge networking": "connecting multiple veth pairs for inter-container communication",
    "NAT": "Network Address Translation for external connectivity",
    "resource controllers": "cgroup subsystems that manage specific resource types",
    "memory controller": "cgroup controller that tracks and limits memory usage",
    "CPU controller": "cgroup controller that limits CPU time allocation",
    "process controller": "cgroup controller that limits number of processes",
    "OOM killer": "kernel mechanism that terminates processes when memory exhausted",
    "CPU quota": "maximum CPU time allocation within a scheduling period",
    "hierarchical cleanup": "cleanup strategy that terminates processes before removing cgroups",
    "controller availability": "whether specific cgroup controllers are enabled on the system",
    "container startup sequence": "step-by-step process of creating all namespaces and resource limits",
    "container cleanup sequence": "proper teardown order to avoid resource leaks",
    "error propagation": "how errors in one component affect others during setup",
    "parent-child synchronization": "coordination between host and container processes during setup",
    "execution context": "whether operations occur in host or container namespace",
    "dependency relationships": "how namespaces and cgroups form cleanup ordering requirements",
    "resource exhaustion": "condition where system resources are depleted",
    "partial cleanup": "cleanup scenario where some operations succeed while others fail",
    "cleanup ordering dependencies": "sequence requirements for resource cleanup operations",
    "isolation verification tests": "tests that verify namespaces create genuine boundaries",
    "resource limit testing": "verification that cgroups prevent containers from exceeding allocations",
    "milestone checkpoints": "concrete verification steps after each implementation phase",
    "PID namespace isolation": "process ID separation between container and host",
    "mount namespace isolation": "filesystem view separation",
    "network namespace isolation": "network stack separation",
    "memory limit enforcement": "cgroup memory controller preventing excess allocation",
    "CPU limit enforcement": "cgroup CPU controller restricting CPU usage percentage",
    "process limit enforcement": "cgroup process controller limiting number of processes",
    "cgroup enforcement": "kernel mechanism ensuring resource limits are respected",
    "resource pressure": "condition approaching but not exceeding limits",
    "cleanup verification": "ensuring all container resources are properly removed",
    "integration testing": "verifying complete container system with all isolation mechanisms",
    "user namespace": "isolates user and group ID mappings between container and host",
    "UTS namespace": "isolates system hostname and domain name",
    "IPC namespace": "isolates System V IPC objects and POSIX message queues",
    "container image layers": "read-only filesystem layers that stack to form complete container filesystem",
    "overlay filesystem": "union filesystem that combines multiple layers",
    "copy-on-write": "filesystem behavior where files are copied to writable layer when modified",
    "content-addressable storage": "storage system where data is accessed using content hash rather than location",
    "service discovery": "mechanism for containers to locate and communicate with other services",
    "container orchestration": "coordination system managing multiple containers",
    "deployment specification": "configuration describing desired state of multi-container application",
    "control loop": "continuous process comparing desired state with actual state and taking corrective action",
    "load balancing": "distributing requests across multiple service endpoints for performance and availability",
    "inter-container communication": "networking mechanisms allowing containers to communicate with each other",
    "service registry": "database of available services and their current network endpoints",
    "container lifecycle management": "coordination of container startup, monitoring, failure handling, and shutdown",
    "dependency management": "ensuring containers start in correct order based on service dependencies",
    "hierarchical resource allocation": "multi-level resource distribution from orchestrator to deployments to containers"
  }
}