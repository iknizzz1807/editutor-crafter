{
  "types": {
    "disasm_result_t": "enum for error codes",
    "byte_cursor_t": "fields: data pointer, size, position",
    "processor_mode_t": "enum: MODE_32BIT, MODE_64BIT",
    "instruction_prefixes_t": "fields: operand_size_override bool, address_size_override bool, lock_prefix bool, repne_prefix bool, rep_prefix bool, segment_override uint8_t, rex_present bool, rex_w bool, rex_r bool, rex_x bool, rex_b bool",
    "operand_type_t": "enum: NONE, REGISTER, MEMORY, IMMEDIATE, RELATIVE",
    "register_id_t": "enum for all x86 registers AL through R15",
    "memory_operand_t": "fields: base_register register_id_t, index_register register_id_t, scale uint8_t, displacement int32_t, rip_relative bool",
    "operand_t": "fields: type operand_type_t, size uint8_t, data union",
    "instruction_t": "fields: address uint64_t, bytes uint8_t array, length uint8_t, prefixes instruction_prefixes_t, mnemonic char array, operands operand_t array, operand_count uint8_t, is_valid bool",
    "output_format_t": "enum for assembly syntax options",
    "binary_info_t": "fields: format, architecture, entry_point, sections, symbol_table",
    "section_info_t": "fields: name, virtual_address, file_offset, size, flags",
    "symbol_entry_t": "fields: name, address, size, type",
    "opcode_info_t": "fields: mnemonic char[16], operand_types operand_type_t[4], operand_sizes uint8_t[4], operand_count uint8_t, flags uint32_t, group_index uint8_t",
    "opcode_table_t": "fields: primary opcode_info_t[256], extended opcode_info_t[256], groups opcode_info_t*[32], group_count uint8_t",
    "segment_override_t": "enum: DEFAULT, CS, SS, DS, ES, FS, GS",
    "error_context_t": "fields: error_code disasm_result_t, component_name const char*, cursor_position size_t, problematic_bytes uint8_t[16], problematic_byte_count size_t, processor_mode processor_mode_t, prefixes instruction_prefixes_t, virtual_address uint64_t, description char[256]",
    "error_collector_t": "fields: errors error_context_t*, error_count size_t, error_capacity size_t",
    "test_data_t": "fields: data uint8_t*, size size_t, description char*",
    "debug_level_t": "enum: DEBUG_ERROR, DEBUG_WARN, DEBUG_INFO, DEBUG_TRACE",
    "debug_component_t": "enum: DEBUG_LOADER, DEBUG_PREFIX, DEBUG_OPCODE, DEBUG_OPERAND, DEBUG_FORMAT, DEBUG_ALL",
    "test_case_t": "fields: name char[128], test_function bool pointer, passed bool, error_message char[256]",
    "extension_interface_t": "fields: name const char*, can_handle bool pointer, initialize disasm_result_t pointer, process_instruction disasm_result_t pointer, finalize disasm_result_t pointer, cleanup void pointer"
  },
  "methods": {
    "cursor_init(cursor, data, size)": "initialize cursor for safe byte reading",
    "cursor_read_u8(cursor, value) returns bool": "read single byte with bounds checking",
    "cursor_read_u16_le(cursor, value) returns bool": "read 16-bit little-endian value",
    "cursor_read_u32_le(cursor, value) returns bool": "read 32-bit little-endian value",
    "cursor_read_u64_le(cursor, value) returns bool": "read 64-bit little-endian value",
    "cursor_has_bytes(cursor, count) returns bool": "check if count bytes remain",
    "cursor_position(cursor) returns size_t": "get current cursor position",
    "cursor_peek_u8(cursor, value) returns bool": "peek at byte without advancing cursor",
    "disasm_error_string(error) returns const char*": "convert error code to string",
    "disassemble_instruction(cursor, mode, address, instruction) returns disasm_result_t": "decode single instruction from byte stream",
    "disassemble_section(data, size, base_address, mode, format) returns disasm_result_t": "main disassembly loop for code sections",
    "decode_prefixes(cursor, prefixes) returns disasm_result_t": "decode instruction prefixes",
    "decode_opcode(cursor, prefixes, mnemonic, operand_types, operand_count) returns disasm_result_t": "decode opcode and determine instruction type",
    "decode_operands(cursor, prefixes, mode, expected_types, operand_count, operands) returns disasm_result_t": "decode instruction operands",
    "format_instruction(instruction, format, binary_info, output, output_size) returns disasm_result_t": "format instruction to string",
    "load_binary_file(filename, binary_info) returns disasm_result_t": "load and parse executable file",
    "find_section_by_address(binary_info, address) returns section_info_t*": "get section containing virtual address",
    "virtual_to_file_offset(binary_info, virtual_address, file_offset) returns disasm_result_t": "convert virtual address to file offset",
    "resolve_symbol_name(binary_info, address) returns const char*": "resolve address to symbol name",
    "decode_prefixes(cursor, mode, prefixes) returns disasm_result_t": "decode instruction prefixes from byte stream",
    "validate_prefix_combination(prefixes, mode) returns disasm_result_t": "validate prefix consistency and detect conflicts",
    "decode_opcode(cursor, prefixes, mode, mnemonic, operand_types, operand_count) returns disasm_result_t": "decode opcode and determine instruction type",
    "opcode_lookup_primary(opcode) returns const opcode_info_t*": "lookup single-byte opcode",
    "opcode_lookup_extended(opcode) returns const opcode_info_t*": "lookup two-byte opcode",
    "opcode_lookup_group(group_index, reg_field) returns const opcode_info_t*": "lookup group extension",
    "opcode_is_valid(opcode, mode) returns bool": "check opcode validity for processor mode",
    "opcode_tables_init() returns disasm_result_t": "initialize and validate opcode tables",
    "decode_modrm_operand(cursor, prefixes, mode, expected_type, operand_size, operand) returns disasm_result_t": "decode ModRM-based operand",
    "decode_immediate_operand(cursor, operand_size, operand) returns disasm_result_t": "decode immediate value operand",
    "determine_operand_size(prefixes, mode, default_size) returns uint8_t": "calculate effective operand size",
    "extend_register_encoding(base_encoding, rex_extension, operand_size) returns register_id_t": "apply REX extension to register encoding",
    "format_address(address, mode, buffer, size)": "format address as hex string",
    "format_instruction_bytes(instruction, buffer, size)": "format raw bytes as hex",
    "sb_init(sb, buffer, size)": "initialize string builder",
    "sb_append(sb, text) returns bool": "append text to string builder",
    "sb_append_format(sb, format, ...) returns bool": "append formatted text",
    "disassemble_file(filename, format) returns disasm_result_t": "main entry point for file disassembly",
    "find_section_by_name(binary_info, name) returns section_info_t*": "get section by name",
    "cleanup_binary_info(binary_info)": "free allocated binary info memory",
    "report_error_with_context(ctx)": "display detailed error information",
    "find_next_instruction_boundary(cursor, mode) returns disasm_result_t": "recover from decode errors",
    "error_context_init(ctx, code, component, cursor, mode, prefixes)": "initialize error context with current state",
    "find_next_instruction_boundary(cursor, mode, max_distance) returns disasm_result_t": "recover from decode errors",
    "cursor_peek_at_offset(cursor, offset, value) returns bool": "peek at byte at offset without advancing",
    "load_test_data(filename) returns test_data_t*": "load test instruction sequences from binary files",
    "create_prefixed_instruction(prefixes, prefix_count, opcode, params, param_count) returns uint8_t*": "create instruction sequences for testing specific features",
    "compare_with_objdump(binary_file, address, our_output) returns int": "reference validation against objdump output",
    "RUN_TEST(test_func)": "execute test function with result reporting",
    "debug_dump_bytes(data, size, label)": "format bytes as hex dump with label",
    "debug_dump_instruction_state(instruction, cursor)": "show complete instruction decode state",
    "validate_against_golden_file(test_name, our_output) returns bool": "compare against stored reference output",
    "run_single_test(name, test_func) returns bool": "execute individual test with error capture",
    "run_test_suite(tests, test_count)": "execute array of test cases",
    "debug_component_name(component) returns const char*": "get string name for debug component",
    "debug_level_name(level) returns const char*": "get string name for debug level",
    "debug_dump_binary_info(info)": "display executable file parsing results",
    "debug_dump_prefixes(prefixes, raw_bytes)": "show detailed prefix interpretation",
    "debug_dump_operand_decode(operand, modrm_byte, sib_byte)": "trace operand decoding process",
    "register_extension(extension) returns disasm_result_t": "register extension with core system",
    "enable_extension(name) returns disasm_result_t": "activate named extension",
    "disable_extension(name) returns disasm_result_t": "deactivate named extension",
    "can_handle(binary) returns bool": "check if extension supports binary format",
    "initialize(binary, context) returns disasm_result_t": "initialize extension with binary context",
    "process_instruction(context, instruction) returns disasm_result_t": "process single instruction through extension",
    "finalize(context) returns disasm_result_t": "complete extension processing",
    "cleanup(context)": "free extension resources"
  },
  "constants": {
    "MAX_INSTRUCTION_LENGTH": "15 bytes maximum x86-64 instruction length",
    "DISASM_SUCCESS": "0 successful operation",
    "DISASM_ERROR_FILE_NOT_FOUND": "file not found error",
    "DISASM_ERROR_INVALID_FORMAT": "invalid executable format error",
    "DISASM_ERROR_TRUNCATED_FILE": "truncated file error",
    "DISASM_ERROR_INVALID_INSTRUCTION": "invalid instruction encoding error",
    "DISASM_ERROR_UNSUPPORTED_FEATURE": "unsupported feature error",
    "DISASM_ERROR_OUT_OF_MEMORY": "out of memory error",
    "PREFIX_OPERAND_SIZE": "0x66 operand size prefix",
    "PREFIX_ADDRESS_SIZE": "0x67 address size prefix",
    "PREFIX_LOCK": "0xF0 lock prefix",
    "PREFIX_REPNE": "0xF2 repeat while not equal prefix",
    "PREFIX_REP": "0xF3 repeat while equal prefix",
    "REX_PREFIX_BASE": "0x40 base value for REX prefix range",
    "REX_W_BIT": "0x08 REX.W bit for 64-bit operands",
    "REX_R_BIT": "0x04 REX.R bit for register extension",
    "REX_X_BIT": "0x02 REX.X bit for index extension",
    "REX_B_BIT": "0x01 REX.B bit for base extension",
    "OPCODE_FLAG_REQUIRES_MODRM": "0x0001 instruction needs ModRM byte",
    "OPCODE_FLAG_GROUP_EXTENSION": "0x0010 uses ModRM.reg for instruction selection",
    "DISASM_ERROR_TRUNCATED_INSTRUCTION": "insufficient bytes for complete instruction",
    "DISASM_ERROR_INVALID_ADDRESSING_MODE": "illegal ModRM/SIB combination",
    "DISASM_ERROR_UNSUPPORTED_OPERAND": "operand type not implemented",
    "MODRM_MOD": "extract mod field from ModRM byte",
    "MODRM_REG": "extract reg field from ModRM byte",
    "MODRM_RM": "extract rm field from ModRM byte",
    "SIB_SCALE": "extract scale field from SIB byte",
    "SIB_INDEX": "extract index field from SIB byte",
    "SIB_BASE": "extract base field from SIB byte",
    "MODE_32BIT": "32-bit processor mode",
    "MODE_64BIT": "64-bit processor mode",
    "DEBUG_ERROR": "1 error level debug output",
    "DEBUG_WARN": "2 warning level debug output",
    "DEBUG_INFO": "3 info level debug output",
    "DEBUG_TRACE": "4 trace level debug output",
    "DEBUG_LOADER": "0x01 binary loader debug component",
    "DEBUG_PREFIX": "0x02 prefix decoder debug component",
    "DEBUG_OPCODE": "0x04 opcode decoder debug component",
    "DEBUG_OPERAND": "0x08 operand decoder debug component",
    "DEBUG_FORMAT": "0x10 output formatter debug component",
    "DEBUG_ALL": "0xFF all debug components enabled"
  },
  "terms": {
    "disassembler": "tool that converts machine code back to assembly",
    "variable-length encoding": "instruction format where different instructions use different byte counts",
    "instruction prefixes": "optional bytes that modify how following instruction bytes are interpreted",
    "opcode": "operation code byte that identifies the fundamental instruction type",
    "ModRM byte": "byte encoding addressing mode and register selection",
    "SIB byte": "scale-index-base byte for complex memory addressing",
    "REX prefix": "64-bit mode prefix that extends register encoding",
    "linear sweep": "disassembly strategy that processes instructions sequentially",
    "table-driven": "disassembly approach using lookup tables for instruction patterns",
    "recursive descent": "parsing approach using separate functions for each encoding component",
    "control flow analysis": "advanced technique for reconstructing program execution paths",
    "educational tool": "learning-focused implementation prioritizing clarity over performance",
    "pipeline architecture": "design where data flows through sequential processing stages",
    "component isolation": "design principle where components have minimal dependencies",
    "byte cursor": "structure for safe sequential byte reading",
    "discriminated union": "data structure with type field indicating which union member is valid",
    "executable as container": "viewing executable files as structured containers with headers and sections",
    "virtual addresses": "addresses in process memory space",
    "file offsets": "positions in executable file on disk",
    "format detection": "identifying ELF vs PE executable format",
    "section extraction": "locating and reading executable code sections",
    "symbol resolution": "mapping addresses to function names and variable names",
    "binary loader": "component that parses executable files",
    "bounds checking": "validating data access against buffer limits",
    "endianness": "byte ordering in multi-byte values",
    "legacy prefixes": "single-byte modifiers inherited from original 8086 processor",
    "operand size prefix": "66h prefix that toggles between 16-bit and 32-bit operand sizes",
    "address size prefix": "67h prefix that changes addressing mode calculations",
    "segment override prefixes": "prefixes that specify which segment register to use for memory operands",
    "lock prefix": "F0h prefix that ensures atomic memory operations",
    "repeat prefixes": "F2h/F3h prefixes that cause string instructions to repeat",
    "prefix validation": "checking for invalid prefix combinations and ordering requirements",
    "processor mode": "16-bit, 32-bit, or 64-bit execution mode affecting instruction interpretation",
    "opcode extensions": "mechanism using ModRM.reg field for additional instruction selection",
    "group extensions": "opcodes that represent multiple instructions based on ModRM.reg field",
    "two-byte opcodes": "instructions starting with 0x0F escape byte",
    "peek-ahead": "examining bytes without consuming them from input stream",
    "hierarchical table structure": "nested lookup tables following x86 encoding evolution",
    "addressing modes as recipes": "mental model explaining addressing modes as instructions for computing memory addresses",
    "displacement": "constant offset value added to address calculations",
    "immediate": "literal constant value embedded in instruction",
    "register extension": "REX prefix mechanism to access r8-r15 registers",
    "RIP-relative addressing": "64-bit addressing mode using instruction pointer as base",
    "operand size determination": "process of calculating effective operand size from prefixes",
    "sign extension": "preserving numeric value when increasing operand size",
    "little-endian": "byte ordering where least significant byte comes first",
    "output formatter": "component that formats decoded instructions into readable assembly",
    "assembly syntax": "convention for writing assembly instructions",
    "Intel syntax": "destination-first operand ordering",
    "AT&T syntax": "source-first operand ordering with sigil prefixes",
    "synthetic labels": "generated labels for jump targets not in symbol table",
    "effective address": "calculated memory address after applying addressing mode",
    "operand reordering": "changing operand sequence between syntax modes",
    "error propagation": "systematic forwarding of error conditions through component layers",
    "assembly line processing": "mental model of sequential data transformation stages",
    "linear flow": "unidirectional data movement through processing pipeline",
    "stage": "individual processing step in the disassembly pipeline",
    "sub-stage": "component-level processing within a pipeline stage",
    "interface contract": "specification of component input/output behavior",
    "error classification": "categorization of errors by severity and recovery strategy",
    "graceful degradation": "continuing operation with reduced functionality after errors",
    "recovery checkpoint": "points where pipeline can reset and retry processing",
    "fallback mode": "simplified processing when normal methods fail",
    "pipeline orchestration": "coordination of component interactions and data flow",
    "instruction boundary": "point between discrete machine code instructions",
    "error accumulation": "collection of non-fatal errors for diagnostic reporting",
    "diagnostic information": "detailed context about error conditions and system state",
    "error cascade": "secondary errors that result from initial failure",
    "error context": "diagnostic information captured when error occurs",
    "boundary recovery": "finding next instruction start after decode failure",
    "pattern matching": "detecting instruction boundaries using common byte patterns",
    "confidence scoring": "rating likelihood of correct boundary detection",
    "component unit testing": "testing individual components with known inputs and expected outputs",
    "milestone validation": "systematic checkpoints that verify cumulative functionality",
    "reference validation": "comparison against authoritative disassembler output",
    "test corpus": "comprehensive collection of test binaries and instruction sequences",
    "golden file testing": "comparison against stored known-good reference outputs",
    "cross-milestone validation": "integration testing across component boundaries",
    "archaeological verification": "mental model of testing as verifying interpretation correctness",
    "specification compliance": "correctness measured against processor architecture manual",
    "integration testing": "testing complete pipeline functionality",
    "symptom-based debugging": "categorizing observable behavior and following decision trees to identify root causes",
    "cascade failures": "errors propagating through pipeline stages creating multiple symptoms masking original problem",
    "reference disassembler": "authoritative implementation used for output validation and correctness verification",
    "error injection": "systematic introduction of invalid inputs to test error handling robustness",
    "instruction boundary recovery": "finding next valid instruction start after decode failure",
    "diagnostic context": "comprehensive state information captured when errors occur",
    "memory corruption": "buffer overruns or invalid memory access during byte parsing",
    "endianness confusion": "incorrect interpretation of multi-byte values due to byte ordering mistakes",
    "archaeological investigation": "systematic examination of artifacts to reconstruct what happened during failed operations",
    "fuzzing": "testing with randomly generated inputs to discover edge cases",
    "cross-validation": "comparing results across multiple reference implementations",
    "VEX prefix": "Vector Extensions encoding that replaces legacy prefixes for AVX instructions",
    "EVEX prefix": "Enhanced Vector Extensions encoding supporting 512-bit operations",
    "function boundary detection": "identifying entry points and ranges of individual functions",
    "jump table": "array of addresses used for efficient multi-way branching",
    "optimization pattern detection": "identifying compiler transformations in assembly code",
    "inlining detection": "recognizing where function calls were replaced with direct code inclusion",
    "loop unrolling": "compiler optimization that duplicates loop bodies to reduce branch overhead",
    "vectorization": "replacing scalar operations with SIMD instructions for parallel processing",
    "debug information integration": "leveraging DWARF debug data for source-level context",
    "multi-architecture support": "extending disassembler to handle ARM, RISC-V, and other processors",
    "parallel processing architecture": "redesigning pipeline to leverage multiple processor cores",
    "incremental analysis": "updating analysis when binary contents change rather than full reprocessing",
    "interactive learning mode": "guided tutorial system that explains decoding steps and patterns",
    "extension framework": "plugin architecture allowing modular enhancement of core functionality"
  }
}