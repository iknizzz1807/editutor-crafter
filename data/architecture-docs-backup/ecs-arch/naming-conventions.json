{
  "types": {
    "EntityID": "uint32_t entity identifier",
    "Generation": "uint32_t generation counter",
    "Entity": "fields: id EntityID, generation Generation",
    "ComponentTypeID": "uint32_t component type identifier",
    "EntityManager": "manages entity lifecycle and ID recycling",
    "ComponentStorage": "template class for type-specific component storage",
    "IComponentStorage": "base interface for type-erased component operations",
    "System": "fields: name_ string, priority_ int, enabled_ bool",
    "SystemManager": "fields: systems_ vector<unique_ptr<System>>, systems_sorted_ bool",
    "World": "ECS coordinator class",
    "Position": "fields: x float, y float",
    "Velocity": "fields: dx float, dy float",
    "Health": "sample component with current,maximum health",
    "ComponentTypeInfo": "fields: typeID ComponentTypeID, name string, size size_t, alignment size_t, destructor function pointer, moveConstructor function pointer",
    "ComponentTypeRegistry": "singleton managing component type metadata",
    "SparseSet": "template class with dense array T, sparse array indices, entities array",
    "ArchetypeInfo": "fields: archetypeID uint32_t, componentMask ComponentMask, componentTypes vector",
    "ArchetypeChunk": "fields: data byte array, entities vector, entityCount uint32_t, capacity uint32_t, archetype pointer",
    "ComponentMask": "bitset of MAX_COMPONENTS size",
    "QueryIterator<Components...>": "fields: world_ World*, entities_ vector<Entity>, current_index_ size_t",
    "ArchetypeStorage": "manages archetype creation and entity transitions",
    "ChunkAllocator": "memory pool for efficient chunk allocation",
    "ArchetypeQueryIterator": "template iterator spanning multiple archetypes",
    "EntityLifecycleManager": "complete entity lifecycle management implementation",
    "FrameTimer": "high-precision delta time calculation",
    "EntityValidator": "validation strategies with configurable safety levels",
    "ValidationResult": "fields: valid bool, entity_id EntityID, expected_generation Generation",
    "ValidationLevel": "enum: NONE, BASIC, STANDARD, COMPREHENSIVE",
    "EntityValidationException": "exception for entity validation failures",
    "TypeSafeComponentAccess": "template class for type-safe component operations",
    "ComponentTypeVerifier": "runtime type verification for dynamic operations",
    "TypeMismatchInfo": "fields: expected_type ComponentTypeID, actual_type ComponentTypeID, expected_name string, actual_name string, entity_id EntityID",
    "SystemCircuitBreaker": "circuit breaker pattern for system error recovery",
    "State": "enum: HEALTHY, MONITORING, OPEN, HALF_OPEN",
    "ErrorThreshold": "fields: max_errors size_t, time_window float, recovery_timeout float",
    "SystemHealthInfo": "fields: state State, error_count size_t, last_error_time float, state_change_time float, recent_errors vector",
    "ErrorRecoverySystemManager": "enhanced SystemManager with error handling",
    "QueryIterator": "template iterator for component queries",
    "CacheMissCounter": "performance monitoring utility",
    "MovementSystem": "test system for physics updates",
    "HealthSystem": "test system for health processing",
    "CacheStats": "cache performance metrics structure",
    "SystemExecutionTracer": "system dependency analysis tool",
    "ComponentAccess": "system component access record",
    "PerformanceMonitor": "performance regression detection system",
    "SystemPerformanceData": "individual system performance tracking",
    "AllocationTracker": "memory allocation monitoring",
    "AllocationInfo": "individual allocation record"
  },
  "methods": {
    "createEntity() -> Entity": "generates new entity with unique ID",
    "destroyEntity(Entity)": "marks entity destroyed and recycles ID",
    "isAlive(Entity) -> bool": "validates entity ID and generation",
    "addComponent<T>(Entity, T&&) -> T&": "attaches component to entity",
    "removeComponent<T>(Entity)": "detaches component from entity",
    "getComponent<T>(Entity) -> T&": "retrieves component reference",
    "hasComponent<T>(Entity) -> bool": "checks if entity has component",
    "query<Components...>() -> QueryIterator": "creates component query iterator",
    "update(World&, float)": "system frame update with delta time",
    "registerSystem<T>(int, Args...)": "adds system with priority",
    "getAllEntities() -> vector<Entity>": "returns all currently alive entities",
    "getAliveEntityCount() -> size_t": "counts living entities",
    "registerDestroyCallback(callback)": "registers cleanup callback for entity destruction",
    "insert(EntityID, T&&) -> T&": "adds component to sparse set",
    "remove(EntityID) -> bool": "removes component using swap-remove",
    "contains(EntityID) -> bool": "checks component existence",
    "get(EntityID) -> T&": "retrieves component reference or throws",
    "tryGet(EntityID) -> T*": "safely retrieves component pointer or nullptr",
    "addComponent<T>(EntityID, Args...) -> T&": "attaches component to entity",
    "removeComponent<T>(EntityID) -> bool": "detaches component from entity",
    "getComponent<T>(EntityID) -> T&": "retrieves component reference",
    "hasComponent<T>(EntityID) -> bool": "checks if entity has component",
    "registerComponentType<T>() -> ComponentTypeID": "registers component type with metadata",
    "update(World&, float) -> void": "main system execution method",
    "registerSystem<T>(int, Args...) -> T*": "registers system with priority",
    "updateAllSystems(World&, float) -> void": "executes all systems in priority order",
    "getName() -> const string&": "returns system name",
    "getPriority() -> int": "returns execution priority",
    "isEnabled() -> bool": "checks if system should execute",
    "setEnabled(bool) -> void": "enables or disables system",
    "getSystem<T>() -> T*": "retrieves registered system instance",
    "getSystemCount() -> size_t": "returns number of registered systems",
    "operator*() -> tuple<Components&...>": "dereferences query iterator",
    "operator++() -> QueryIterator&": "advances query iterator",
    "entity() -> Entity": "returns current entity from iterator",
    "getOrCreateArchetype() -> ArchetypeInfo*": "finds existing archetype or creates new one for component combination",
    "transitionEntity(Entity, ArchetypeInfo*) -> void": "moves entity between archetypes when components change",
    "findMatchingArchetypes() -> vector<ArchetypeInfo*>": "locates archetypes containing required component types",
    "calculateArchetypeLayout(ArchetypeInfo*) -> void": "computes memory layout and offsets for archetype",
    "allocateNewChunk(ArchetypeInfo*) -> ArchetypeChunk*": "creates new chunk with proper memory layout",
    "getComponentArray<T>() -> T*": "returns typed pointer to component array in chunk",
    "addEntity(Entity) -> void": "adds entity to archetype chunk",
    "removeEntity(size_t) -> void": "removes entity using swap-remove semantics",
    "compactChunk() -> void": "removes gaps from entity removal",
    "processDestroyQueue()": "processes queued entity destructions",
    "registerCreationCallback()": "registers entity creation callback",
    "tick() -> float": "calculates frame delta time",
    "validateEntity(manager, entity, level) -> ValidationResult": "validates entity reference with configurable checking",
    "isValidQuick(manager, entity) -> bool": "fast validation for hot paths",
    "getComponent<T>(storage, entity) -> T&": "type-safe component access with exceptions",
    "tryGetComponent<T>(storage, entity) -> T*": "safe component access returning nullptr on failure",
    "hasComponent<T>(storage, entity) -> bool": "component existence check without data access",
    "verifyComponentType(entity, expected_type, storage, mismatch_info) -> bool": "runtime type verification",
    "validateTypeRegistry() -> vector<string>": "validates component type registry consistency",
    "recordError(system_name, error_message)": "records system error and updates circuit state",
    "shouldExecuteSystem(system_name) -> bool": "checks if system should execute this frame",
    "recordSuccess(system_name)": "records successful execution for recovery",
    "getSystemHealth(system_name) -> SystemHealthInfo": "gets current system health status",
    "updateTime(delta_time)": "updates circuit breaker timing",
    "addSystemDependency(dependent, dependency)": "declares system dependency relationship",
    "getSystemHealthReport() -> vector<pair<string, SystemHealthInfo>>": "gets error statistics for all systems",
    "startMonitoring()": "begins cache miss tracking",
    "stopMonitoring() -> CacheStats": "ends monitoring and returns statistics",
    "recordEntityCreation(Entity)": "logs entity creation for validation tracking",
    "recordEntityDestruction(Entity)": "logs entity destruction for validation tracking",
    "recordMemoryAccess(address, size)": "logs memory access for cache analysis",
    "recordComponentAccess(system, type, entity, write)": "logs component access for dependency tracking",
    "analyzeDependencies() -> vector<string>": "identifies system execution order issues",
    "recordSystemExecution(system, time)": "logs system performance data",
    "establishBaseline(system)": "sets performance baseline for regression detection",
    "getPerformanceWarnings() -> vector<string>": "returns systems with performance regressions",
    "recordAllocation(ptr, size, file, line)": "tracks memory allocation",
    "recordDeallocation(ptr)": "tracks memory deallocation"
  },
  "constants": {
    "INVALID_ENTITY": "sentinel value for invalid entity references",
    "DEFAULT_GENERATION": "starting generation value for new entities",
    "INVALID_ENTITY_ID": "maximum EntityID value as invalid marker",
    "MAX_COMPONENTS": "64 - maximum component types supported",
    "PERMANENT_GENERATION": "maximum generation preventing ID recycling",
    "MAX_FREE_LIST_SIZE": "limit on recycled entity ID storage",
    "SIZE_MAX": "sentinel value for invalid sparse array entries",
    "PRIORITY_INPUT": "100",
    "PRIORITY_LOGIC": "200",
    "PRIORITY_PHYSICS": "300",
    "PRIORITY_ANIMATION": "400",
    "PRIORITY_RENDERING": "500",
    "PRIORITY_AUDIO": "600",
    "PRIORITY_DEBUG": "700",
    "CHUNK_SIZE": "16384 - 16KB chunks for cache efficiency",
    "INVALID_ARCHETYPE_ID": "0 - sentinel value for invalid archetype",
    "VALIDATION_NONE": "no validation for release builds",
    "VALIDATION_BASIC": "generation counter validation only",
    "VALIDATION_STANDARD": "generation plus alive status checking",
    "VALIDATION_COMPREHENSIVE": "all validation including bounds checking",
    "ECS_MAX_PERFORMANCE_SAMPLES": "maximum performance samples per system",
    "ECS_MAX_TRACE_EVENTS": "maximum system trace events to keep",
    "ECS_PERFORMANCE_REGRESSION_THRESHOLD": "percentage threshold for performance warnings"
  },
  "terms": {
    "cache locality": "organizing data for CPU cache efficiency",
    "sparse set": "bidirectional mapping between sparse IDs and dense storage",
    "archetype": "grouping entities by identical component combinations",
    "SIMD": "Single Instruction Multiple Data vectorized processing",
    "data-oriented design": "organizing code around data access patterns",
    "composition over inheritance": "building objects from components rather than class hierarchies",
    "swap-remove": "removing array elements by swapping with last element",
    "generation counter": "version number preventing stale entity references",
    "component mask": "bitset indicating which component types are present",
    "structure-of-arrays": "memory layout storing all instances of each type contiguously",
    "archetype explosion": "performance problem from too many unique component combinations",
    "free list": "queue of recycled entity IDs available for reuse",
    "stale reference": "entity reference pointing to destroyed entity",
    "ID recycling": "reusing entity IDs from destroyed entities",
    "ABA problem": "accessing wrong data when IDs are reused without versioning",
    "entity lifecycle": "creation, active usage, and destruction phases of entities",
    "dense array": "contiguous storage for cache-friendly iteration",
    "sparse array": "maps entity IDs to dense array positions",
    "type erasure": "runtime polymorphism without knowing specific types",
    "template specialization": "compile-time type-specific code generation",
    "bidirectional mapping": "mapping that works in both directions for O(1) operations",
    "assembly line stations": "mental model for specialized system processing",
    "component query mechanism": "system for finding entities with specific component combinations",
    "priority-based scheduling": "execution ordering using integer priority values",
    "deferred modification pattern": "collecting changes during iteration and applying after",
    "iterator invalidation": "corruption of iterators during container modification",
    "template parameter pack": "variadic template for specifying multiple component types",
    "system execution framework": "infrastructure coordinating system updates each frame",
    "chunk-based storage": "fixed-size memory blocks storing multiple entities",
    "archetype transition": "moving entity between archetypes when components change",
    "entity stride": "total memory size per entity including all components",
    "chunk utilization": "percentage of chunk capacity filled with entities",
    "SIMD processing": "vectorized operations on contiguous component data",
    "system update cycle": "frame-by-frame execution flow of all systems",
    "component query": "mechanism for finding entities with specific component combinations",
    "sparse set intersection": "finding common entities across multiple component types",
    "entity validation": "preventing access to destroyed entities through stale references",
    "component type safety": "preventing runtime errors from component type mismatches",
    "type ID verification": "runtime checking of component type identifiers",
    "circuit breaker pattern": "isolating failing systems to prevent cascading errors",
    "error threshold": "maximum errors before disabling system",
    "recovery timeout": "time before attempting to re-enable failed system",
    "dependency cascading": "disabling dependent systems when requirements fail",
    "validation level": "configurable amount of safety checking performed",
    "type mismatch": "accessing component with wrong type information",
    "resource leak": "failure to release memory or handles in error conditions",
    "cache miss ratio": "percentage of memory accesses that miss CPU cache",
    "performance regression": "code changes that reduce system performance",
    "integration testing": "testing component interactions together",
    "checkpoint testing": "validation after each milestone completion",
    "benchmark infrastructure": "tools for measuring system performance",
    "stale entity reference": "entity reference pointing to destroyed entity",
    "system dependency": "requirement for one system to execute before another",
    "allocation hotspot": "code locations causing frequent memory allocations",
    "component storage corruption": "inconsistent state in sparse set data structures",
    "system execution bottleneck": "systems taking disproportionate frame time",
    "cache miss": "CPU cache lookup failure requiring slower main memory access",
    "sentinel value": "special value indicating invalid or missing data",
    "memory pool": "pre-allocated memory blocks for efficient allocation",
    "delta time": "time elapsed since the last frame",
    "frame": "single update cycle of the game loop"
  }
}