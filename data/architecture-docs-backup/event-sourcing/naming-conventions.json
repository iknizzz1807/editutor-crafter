{
  "types": {
    "EventStore": "appendEvents, readEvents, getCurrentVersion",
    "DomainEvent": "eventId String, occurredAt Timestamp, aggregateId String, eventType String, eventVersion Integer",
    "AggregateRoot": "aggregateId String, version Long, uncommittedChanges List, isLoaded Boolean",
    "EventEnvelope": "eventId String, streamId String, version Long, eventType String, data ByteArray, timestamp Timestamp, contentType String, causationId String, correlationId String",
    "ConcurrencyException": "streamId String, expectedVersion Long, actualVersion Long",
    "Account": "accountId AccountId, customerName String, balance BigDecimal, status AccountStatus, dailyWithdrawalLimit BigDecimal",
    "ProjectionCheckpoint": "projectionId String, currentPosition Long, lastUpdatedAt Timestamp, status ProjectionStatus, errorCount Integer, lastErrorMessage String",
    "ProjectionStatus": "ACTIVE, FAILED, REBUILDING, STOPPED enum",
    "ProjectionHandler": "getProjectionId, canHandle, handle, reset methods",
    "ProjectionEngine": "eventStore EventStore, checkpointRepository CheckpointRepository, projectionRegistry ProjectionRegistry, executorService ExecutorService",
    "CheckpointRepository": "dataSource DataSource with findByProjectionId, save methods",
    "SnapshotMetadata": "aggregateId String, aggregateType String, eventVersion long, createdAt Instant, schemaVersion String, checksum String, compressedSize long, uncompressedSize long",
    "SnapshotData": "metadata SnapshotMetadata, aggregateState Object",
    "SnapshotStrategy": "eventThresholds Map, timeThresholds Map, defaultEventThreshold int, defaultTimeThreshold Duration, compressionEnabled boolean, maxRetainedSnapshots int",
    "SnapshotStore": "interface with saveSnapshot, loadLatestSnapshot methods",
    "SnapshotProcessor": "snapshotStore SnapshotStore, snapshotStrategy SnapshotStrategy, executorService ExecutorService",
    "SnapshotCreationTask": "aggregateId String, eventVersion long, aggregateState Object",
    "CommandResult": "success status and result data",
    "CommandHandler": "generic command processing flow",
    "IntegrityCheckResult": "validation results for corruption detection",
    "SystemIntegrityReport": "comprehensive store integrity status",
    "CircuitBreakerState": "CLOSED, OPEN, HALF_OPEN enum",
    "TestEventStore": "in-memory implementation for testing",
    "EventBuilder": "fluent builder for test event creation",
    "ProjectionTestUtils": "async testing utilities",
    "EventStoreInspector": "event stream analysis and corruption detection utility",
    "ProjectionHealthMonitor": "projection lag monitoring and health checks",
    "AggregateDebugger": "eventStore EventStore, ruleRegistry BusinessRuleRegistry",
    "PartitionRouter": "clusterTopology ClusterTopology, hashRing ConsistentHashRing, healthMonitor HealthMonitor",
    "ClusterCoordinator": "consensus ConsensusProtocol, migrationManager MigrationManager",
    "SagaInstance": "sagaId String, status SagaStatus, currentStep int, processData Map, compensationQueue List",
    "TimeoutScheduler": "pendingTimeouts PriorityQueue, scheduler ScheduledExecutorService",
    "TemporalProjectionBuilder": "eventStore EventStore, snapshotStore SnapshotStore, projectionRegistry ProjectionRegistry",
    "PartitionLocation": "nodeId String, partitionId int, replicaNodes List",
    "SagaStep": "stepId String, actionCommand Command, compensationCommand Command",
    "CompensationAction": "stepId String, command Command, attempts int",
    "TimeoutRequest": "sagaId String, stepId String, timeoutAt Instant",
    "AggregateTimeline": "aggregateId String, events List, stateTransitions List",
    "DecisionExplanation": "timestamp Instant, businessRules List, availableData Map, decision String",
    "AccountStatus": "ACTIVE, SUSPENDED, CLOSED, PENDING_ACTIVATION enum",
    "SagaStatus": "RUNNING, COMPLETED, COMPENSATING, COMPENSATED, FAILED enum",
    "EventStoreException": "operation String, streamId String, cause Throwable"
  },
  "methods": {
    "appendEvents(streamId, expectedVersion, events)": "appends events with optimistic concurrency control",
    "readEvents(streamId)": "reads all events from stream in chronological order",
    "fromHistory(aggregateType, events)": "reconstitutes aggregate by replaying events",
    "raiseEvent(event)": "applies event and tracks as uncommitted change",
    "getUncommittedChanges()": "returns events pending persistence",
    "fromHistory(events) void": "reconstitutes aggregate by replaying event history",
    "raiseEvent(event) void": "applies event and tracks as uncommitted change",
    "getUncommittedChanges() List": "returns events pending persistence",
    "markChangesAsCommitted() void": "clears uncommitted changes after successful persistence",
    "getCurrentVersion(streamId)": "returns current stream version",
    "registerProjection(handler) void": "adds handler to registry and starts polling loop",
    "processEventBatch(handler, events) void": "processes events atomically with checkpoint updates",
    "startProjectionLoop(handler) void": "main polling loop for projection event processing",
    "rebuildProjection(projectionId) CompletableFuture": "resets projection and reprocesses all events",
    "canHandle(eventType) boolean": "determines if projection should process event type",
    "handle(event) void": "processes single event to update read model",
    "reset() void": "clears read model data for projection rebuild",
    "findByProjectionId(projectionId) Optional": "retrieves checkpoint for projection",
    "save(checkpoint) void": "persists checkpoint with atomic semantics",
    "saveSnapshot(aggregateId, aggregateType, eventVersion, aggregateState, schemaVersion) void": "persists snapshot with metadata and integrity checking",
    "loadLatestSnapshot(aggregateId, aggregateType) Optional<SnapshotData>": "retrieves most recent valid snapshot for aggregate",
    "shouldCreateSnapshot(aggregateType, currentVersion, lastSnapshotVersion, lastSnapshotTime) boolean": "determines if snapshot creation threshold reached",
    "createSnapshotAsync(aggregateId, aggregateType, eventVersion, aggregateState) CompletableFuture<Void>": "schedules background snapshot creation",
    "getSnapshotKey() String": "generates unique identifier for snapshot storage",
    "calculateChecksum(data) String": "computes SHA-256 hash for integrity verification",
    "compress(data) byte[]": "applies GZIP compression to snapshot data",
    "decompress(compressedData) byte[]": "decompresses GZIP snapshot data",
    "registerProjection(handler)": "adds handler to registry and starts polling loop",
    "processEventBatch(handler, events)": "processes events atomically with checkpoint updates",
    "startProjectionLoop(handler)": "main polling loop for projection event processing",
    "canHandle(eventType)": "determines if projection should process event type",
    "handle(event)": "processes single event to update read model",
    "findByProjectionId(projectionId)": "retrieves checkpoint for projection",
    "save(checkpoint)": "persists checkpoint with atomic semantics",
    "handleCommandWithRetry": "executes command with automatic conflict resolution",
    "validateEventIntegrity(streamId)": "checks event checksums and structural validity",
    "performFullIntegrityScan()": "comprehensive background integrity validation",
    "rebuildProjection(projectionId)": "clears read model and reprocesses all events",
    "recordSuccess(projectionId)": "resets error counters for successful processing",
    "recordFailure(projectionId, error)": "tracks processing failures and circuit breaker state",
    "fromHistory(events)": "reconstitutes aggregate by replaying event history",
    "waitForProjectionPosition": "waits for projection to reach specified position",
    "assertProjectionHealthy": "verifies projection is active and processing",
    "markChangesAsCommitted()": "clears uncommitted changes after successful persistence",
    "verifyStateReconstruction": "compares multiple aggregate load attempts for consistency",
    "traceCommandExecution": "records command processing steps for debugging",
    "getPartitionForAggregate(aggregateId)": "determines partition assignment using consistent hashing",
    "rebalancePartitions(availableNodes)": "coordinates partition redistribution across cluster nodes",
    "advanceToNextStep()": "moves saga to next step with timeout scheduling",
    "compensateFailedSaga()": "executes compensation actions in reverse order",
    "scheduleTimeout(sagaId, timeoutAt, stepId)": "adds timeout request to scheduler queue",
    "buildPointInTimeProjection(projectionType, targetTimestamp)": "creates temporal projection for historical state queries",
    "traceEvolution(aggregateId, fromTime, toTime)": "traces aggregate state changes over time period",
    "explainHistoricalDecision(aggregateId, timestamp, commandType)": "explains business decision with historical context",
    "reset()": "clears read model data for projection rebuild",
    "saveSnapshot(aggregateId, aggregateType, eventVersion, aggregateState, schemaVersion)": "persists snapshot with metadata and integrity checking",
    "loadLatestSnapshot(aggregateId, aggregateType)": "retrieves most recent valid snapshot for aggregate"
  },
  "constants": {
    "NEW_STREAM_VERSION": "-1 indicates new stream creation",
    "DEFAULT_EVENT_THRESHOLD": "100 events before snapshot creation",
    "DEFAULT_TIME_THRESHOLD": "24 hours maximum snapshot age",
    "MAX_RETAINED_SNAPSHOTS": "5 historical snapshots per aggregate",
    "MAX_CONSECUTIVE_ERRORS": "10 threshold for circuit breaker activation",
    "CIRCUIT_BREAKER_TIMEOUT": "5 minutes before retry attempts",
    "SAGA_TIMEOUT_DEFAULT": "30 minutes for step completion",
    "TEMPORAL_CACHE_RETENTION": "24 hours for temporal query results",
    "PARTITION_MIGRATION_TIMEOUT": "5 minutes for dual-write phase",
    "MAX_COMPENSATION_RETRIES": "3 attempts for failed compensations"
  },
  "terms": {
    "event sourcing": "storing events as primary data instead of current state",
    "CQRS": "Command Query Responsibility Segregation pattern",
    "optimistic concurrency": "version-based conflict detection for concurrent updates",
    "projection": "read model derived from events for efficient querying",
    "reconstitution": "rebuilding aggregate state by replaying events",
    "state loss problem": "traditional CRUD destroys historical information",
    "domain event": "immutable fact representing something that happened in the business domain",
    "event stream": "chronologically ordered sequence of events for a single aggregate",
    "aggregate root": "domain entity that maintains consistency boundaries and emits events",
    "event envelope": "persistence wrapper containing domain event plus storage metadata",
    "event store": "append-only storage for domain events",
    "append-only log": "immutable storage where new data is only added at the end",
    "stream version": "monotonically increasing number tracking events in a stream",
    "global sequence": "total ordering mechanism across all event streams",
    "fsync": "system call to force data from memory to persistent storage",
    "eventually consistent": "read models follow events with some delay",
    "checkpoint": "position tracking last successfully processed event",
    "idempotency": "processing same event multiple times produces same result",
    "at-least-once delivery": "events never lost but may be delivered multiple times",
    "pull-based subscription": "projections poll for events rather than receive push notifications",
    "checkpoint-based idempotency": "leverages event ordering to limit duplicate scope",
    "projection registry": "tracks active projections and processing status",
    "read model": "queryable data structure derived from events",
    "snapshot": "serialized aggregate state at specific event version for performance optimization",
    "snapshot strategy": "configurable rules determining when snapshots are created",
    "incremental event replay": "applying only events since last snapshot during aggregate loading",
    "snapshot schema evolution": "backward compatibility handling for snapshots across code changes",
    "snapshot metadata": "version and integrity information stored with snapshot data",
    "asynchronous snapshot creation": "background processing to avoid blocking command operations",
    "graceful degradation": "system continues operating with reduced functionality during failures",
    "snapshot retention policy": "rules for cleaning up old snapshots to manage storage",
    "snapshot compression": "reducing storage costs through data compression",
    "checkpoint-based loading": "using snapshots as starting points for aggregate reconstitution",
    "concurrency conflict": "version mismatch when multiple processes modify same aggregate",
    "optimistic concurrency control": "version-based conflict detection for concurrent updates",
    "circuit breaker pattern": "stops processing during repeated failures to prevent resource waste",
    "poison message": "corrupted or incompatible event that breaks projection processing",
    "integrity scanning": "background validation of stored event data for corruption",
    "checkpoint-based recovery": "resuming processing from last known good position",
    "exponential backoff": "increasing delay between retry attempts to reduce load",
    "unit testing": "testing individual components in isolation",
    "integration testing": "testing component interactions and data flows",
    "milestone verification": "checkpoint tests validating implementation stages",
    "given-when-then": "test structure pattern for event-based scenarios",
    "distributed event storage": "horizontally scalable event store across multiple nodes",
    "partition-based distribution": "splitting aggregates across nodes using hash-based assignment",
    "dual-write migration": "temporary write to both old and new partitions during rebalancing",
    "saga": "long-running business transaction with compensatable actions",
    "process manager": "stateful workflow coordinator for complex business processes",
    "compensation action": "reverse operation to undo effects of completed saga step",
    "temporal query": "querying system state as it existed at specific point in time",
    "point-in-time projection": "read model built from events up to specific timestamp",
    "time travel debugging": "tracing historical aggregate evolution and decision points",
    "temporal snapshot": "historical state capture for efficient temporal query starting points",
    "business rule versioning": "tracking changes to validation logic over time",
    "consistent hashing": "partition assignment strategy that minimizes redistribution during scaling"
  }
}