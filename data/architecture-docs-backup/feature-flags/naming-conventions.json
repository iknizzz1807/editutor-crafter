{
  "types": {
    "FlagKey": "string identifier for flags",
    "UserID": "stable user identifier",
    "Variant": "fields: Key string, Value interface{}, Weight int",
    "UserContext": "fields: UserID, Attributes map[string]interface{}, Segments []string",
    "EvaluationResult": "fields: FlagKey, Value interface{}, Variant string, Reason string, Source string",
    "FlagUpdate": "flag change notification",
    "FlagExposure": "fields: EventID string, FlagKey FlagKey, UserID UserID, Variant string, Value interface{}, UserContext UserContext, Timestamp time.Time, Source string, Reason string, ExperimentID string, SessionID string, RequestID string",
    "SignificanceResult": "fields: ExperimentID string, MetricName string, AnalysisTime time.Time, VariantResults []VariantStatistics, Comparisons []PairwiseComparison",
    "FlagDefinition": "fields: FlagKey, Name, Description, Variants, DefaultVariant, Rules, Dependencies",
    "TargetingRule": "fields: Conditions, Operator, Allocation",
    "Condition": "single attribute condition",
    "VariantAllocation": "percentage allocation for variant",
    "PercentageRule": "default percentage allocation",
    "FlagChange": "audit record of flag modifications",
    "ValidationError": "fields: Field string, Message string",
    "ValidationErrors": "fields: Errors []ValidationError",
    "AttributeValue": "type-safe attribute wrapper",
    "ConnectionState": "enum for connection states",
    "FlagUpdateEvent": "fields: EventType string, EventID string, Timestamp time.Time, FlagKey string, Payload interface{}, ChangeType string",
    "SSEServer": "fields: clients map, eventBuffer []FlagUpdateEvent, bufferSize int, mu sync.RWMutex, eventCounter int64",
    "SSEClient": "fields: ID string, ResponseWriter http.ResponseWriter, Flusher http.Flusher, LastEventID string, Connected bool, mu sync.Mutex",
    "ConnectionManager": "fields: serverURL string, clientID string, lastEventID string, state ConnectionState, retryCount int, maxRetries int, baseDelay time.Duration, maxDelay time.Duration",
    "FlagCache": "fields: memoryCache map, localStorage LocalStorage, mu sync.RWMutex, stats CacheStats",
    "CachedFlag": "fields: Definition *FlagDefinition, Version string, Timestamp time.Time, Source string",
    "CacheStats": "fields: Hits int64, Misses int64, Invalidations int64, mu sync.RWMutex",
    "LocalStorage": "interface with Store, Load, Delete, List methods",
    "ExperimentVariant": "fields: Key string, Name string, Description string, Allocation float64, Configuration interface{}, IsControl bool",
    "VariantStatistics": "fields: Variant string, SampleSize int64, ConversionCount int64, ConversionRate float64, StandardError float64, ConfidenceInterval ConfidenceInterval, ZScore float64, RelativeImprovement float64",
    "PairwiseComparison": "fields: VariantA string, VariantB string, PValue float64, Significant bool, TestStatistic float64, DegreesOfFreedom int, EffectSize float64, PowerAchieved float64",
    "ConfidenceInterval": "fields: Lower float64, Upper float64",
    "ExperimentManager": "fields: storage ExperimentStorage, assignments AssignmentStorage, calculator *SignificanceCalculator, mu sync.RWMutex",
    "Experiment": "fields: ExperimentID string, Name string, Hypothesis string, FlagKey FlagKey, Variants []ExperimentVariant, PrimaryMetric string, SecondaryMetrics []string, StartDate time.Time, EndDate *time.Time, MinSampleSize int, SignificanceLevel float64, PowerLevel float64, TargetingRules []TargetingRule, Status string",
    "ExposureTracker": "fields: queue chan FlagExposure, batchSize int, flushPeriod time.Duration, storage ExposureStorage, aggregator *RealTimeAggregator, shutdown chan struct{}, wg sync.WaitGroup",
    "SignificanceCalculator": "fields: storage ExperimentStorage",
    "EvaluationOrchestrator": "coordinates complete flag evaluation flow",
    "UpdatePropagationService": "manages complete update distribution flow",
    "ClientConnection": "represents connected SDK client",
    "PropagationMetrics": "tracks update distribution performance",
    "EvaluationMetrics": "tracks performance and behavior of evaluation flows",
    "FlagError": "fields: Type ErrorType, FlagKey string, Message string, Cause error, Context map[string]interface{}, Timestamp time.Time, Recoverable bool",
    "CircuitBreaker": "fields: name string, maxFailures int, resetTimeout time.Duration, state CircuitState, failures int, lastFailTime time.Time, successCount int, mu sync.RWMutex",
    "FallbackHandler": "fields: primaryAPI FlagAPI, memoryCache *MemoryCache, localStorage LocalStorage, circuitBreaker *CircuitBreaker, metrics *FallbackMetrics",
    "ComponentHealth": "fields: Status HealthStatus, LastCheck time.Time, LastError string, CheckCount int64, ErrorCount int64",
    "HealthChecker": "fields: components map[string]HealthComponent, status map[string]ComponentHealth, mu sync.RWMutex, interval time.Duration, stopCh chan struct{}",
    "FallbackMetrics": "fields: APIAttempts int64, CacheHits int64, LocalStorageHits int64, DefaultValueHits int64, mu sync.RWMutex",
    "ErrorType": "string enum for error classification",
    "CircuitState": "string enum for circuit breaker states",
    "HealthStatus": "string enum for component health",
    "FlagAPI": "interface",
    "HealthComponent": "interface with Name, Check, Recover methods",
    "ExperimentData": "synthetic experiment data for testing",
    "CacheOperation": "cache operation for property testing"
  },
  "methods": {
    "EvaluateFlag(flagKey, context) EvaluationResult": "core flag evaluation with dependency checking",
    "StreamUpdates(clientID) chan FlagUpdate": "real-time flag change streaming",
    "RecordExposure(exposure) error": "log flag evaluation for analytics",
    "CalculateSignificance(experimentID) SignificanceResult": "compute experiment statistical results",
    "GetFlag(key) (*FlagDefinition, error)": "retrieve flag definition by key",
    "CreateFlag(flag) error": "store new flag definition",
    "UpdateFlag(flag) error": "modify existing flag definition",
    "ListFlags(enabledOnly) ([]*FlagDefinition, error)": "retrieve multiple flag definitions",
    "evaluateTargetingRules(rules, context) (string, interface{}, string, bool)": "process targeting rules",
    "evaluateRuleConditions(conditions, operator, context) bool": "check rule condition satisfaction",
    "calculateUserBucket(userID, flagKey) int": "consistent hashing for user allocation",
    "ValidateFlag(flag) error": "comprehensive validation of flag definitions",
    "ValidateUserContext(ctx) error": "validates user context",
    "DetectCircularDependencies(flags) error": "validates prerequisite relationships for cycles",
    "NewAttributeValue(value) AttributeValue": "create type-safe attribute wrapper",
    "String() (string, bool)": "convert attribute to string",
    "Int() (int64, bool)": "convert attribute to integer",
    "Float() (float64, bool)": "convert attribute to float",
    "Bool() (bool, bool)": "convert attribute to boolean",
    "StringSlice() ([]string, bool)": "convert attribute to string slice",
    "ServeHTTP(w, r)": "handles SSE connection requests",
    "BroadcastFlagUpdate(flagKey, payload, changeType)": "sends flag change to all connected clients",
    "Connect(ctx) error": "initiates SSE connection with automatic retry",
    "GetFlag(flagKey) (*FlagDefinition, error)": "retrieves flag from cache with fallback hierarchy",
    "InvalidateFlag(flagKey) error": "removes flag from all cache levels",
    "UpdateFlag(flagKey, flag, source) error": "stores new flag version in cache",
    "ApplyFlagUpdate(event) error": "processes incoming flag changes with synchronization",
    "calculateBackoffDelay() time.Duration": "computes exponential backoff with jitter",
    "sendReplayEvents(client)": "replays buffered events to reconnecting clients",
    "sendHeartbeat(client) error": "sends keep-alive ping to client",
    "generateEventID() string": "creates unique sequential event identifier",
    "parseEventID(eventID) int64": "extracts sequence number from event ID",
    "CreateExperiment(experiment) error": "initialize new A/B test with validation",
    "AssignUserToVariant(experimentID, userID, context) (string, error)": "determine user variant assignment",
    "DetectSampleRatioMismatch(experimentID) (bool, float64, error)": "check if assignments match intended ratios",
    "StartProcessing()": "begin background exposure processing pipeline",
    "ProcessEvaluationRequest(ctx, flagKey, userCtx) (*EvaluationResult, error)": "handles complete evaluation flow",
    "PropagateChange(flagKey, changeType, payload) error": "handles flag update distribution with tracking",
    "HandleClientConnection(w, r)": "manages complete connection lifecycle",
    "Error() string": "implements error interface",
    "Unwrap() error": "returns wrapped error for error chaining",
    "Allow() error": "checks if circuit breaker permits request",
    "RecordResult(err error)": "updates circuit breaker state based on operation result",
    "State() CircuitState": "returns current circuit breaker state",
    "Add(field, message string)": "adds validation error",
    "HasErrors() bool": "checks if validation errors exist",
    "GetFlagWithFallback(ctx, flagKey) (*FlagDefinition, string, error)": "retrieves flag with complete fallback hierarchy",
    "StartMonitoring(ctx context.Context)": "begins health monitoring loop",
    "Name() string": "returns component name for health checking",
    "Check(ctx context.Context) error": "performs component health check",
    "Recover(ctx context.Context) error": "attempts component recovery",
    "ValidateFlagDefinition(flag) error": "validates flag structure",
    "TestAssignmentStability(user, flag) bool": "property test for consistent assignment",
    "TestRuleDeterminism(rules, ctx) bool": "property test for rule evaluation",
    "TestCacheConsistency(operations) bool": "property test for cache behavior",
    "TestSignificanceAccuracy(experimentData) bool": "property test for statistical calculations"
  },
  "constants": {
    "AND": "logical AND operator for rule conditions",
    "OR": "logical OR operator for rule conditions",
    "equals": "exact match condition operator",
    "in": "array membership operator",
    "contains": "substring match operator",
    "create": "flag creation operation",
    "update": "flag modification operation",
    "delete": "flag deletion operation",
    "greater_than": "numeric comparison operator",
    "less_than": "numeric comparison operator",
    "StateDisconnected": "connection state: not connected",
    "StateConnecting": "connection state: attempting connection",
    "StateConnected": "connection state: actively connected",
    "StateReconnecting": "connection state: retrying after failure",
    "ErrorTypeValidation": "validation error type",
    "ErrorTypeNetwork": "network error type",
    "ErrorTypeStorage": "storage error type",
    "ErrorTypeEvaluation": "evaluation error type",
    "ErrorTypeCircuit": "circuit breaker error type",
    "ErrorTypeDependency": "dependency error type",
    "ErrorTypeResource": "resource exhaustion error type",
    "StateClosed": "circuit breaker closed state",
    "StateOpen": "circuit breaker open state",
    "StateHalfOpen": "circuit breaker half-open state",
    "HealthStatusHealthy": "healthy component status",
    "HealthStatusDegraded": "degraded component status",
    "HealthStatusUnhealthy": "unhealthy component status"
  },
  "terms": {
    "feature flags": "runtime toggles controlling feature availability",
    "air traffic control": "mental model for coordinating software releases",
    "consistent hashing": "deterministic algorithm ensuring users receive same variants across evaluations",
    "graceful degradation": "maintaining functionality during partial failures",
    "flag debt": "accumulation of obsolete feature flags in codebase",
    "scope creep": "expansion beyond defined system boundaries",
    "evaluation-first design": "architecture prioritizing flag evaluation performance above all other considerations",
    "targeting rules": "conditions determining user variant assignment",
    "percentage rollout": "gradual feature exposure using allocation buckets",
    "cache invalidation": "updating cached flag definitions when configurations change",
    "Server-Sent Events": "unidirectional streaming protocol for real-time updates",
    "bucket ranges": "deterministic allocation intervals for percentage splits",
    "user context": "comprehensive user information for targeting",
    "segment membership": "pre-computed group classifications for efficient targeting",
    "flag analytics": "comprehensive tracking and analysis of feature flag usage and performance",
    "exposure events": "recorded instances of users encountering specific flag variants",
    "A/B testing framework": "systematic approach to controlled feature experimentation",
    "statistical significance": "mathematical confidence that observed differences are not due to chance",
    "sample ratio mismatch": "deviation between intended and actual variant allocation ratios",
    "intent-to-treat analysis": "analyzing all assigned users regardless of actual exposure",
    "sequential testing": "statistical method allowing valid interim analysis of experiments",
    "power analysis": "calculation of sample size needed for reliable effect detection",
    "survivorship bias": "analytical error from excluding users who dropped out during experiment",
    "evaluation flow": "step-by-step process from client request to variant assignment",
    "update propagation flow": "how flag changes flow from management interface to all connected clients",
    "thundering herd": "mass simultaneous connection attempts overwhelming service",
    "exponential backoff": "progressively longer retry delays with randomization",
    "optimistic consistency": "immediate writes with asynchronous distribution",
    "at-least-once delivery": "guaranteed message delivery with possible duplication",
    "sequence numbers": "monotonic identifiers preventing out-of-order processing",
    "fallback hierarchy": "ordered sequence of data sources for resilience",
    "circuit breaker": "pattern preventing cascade failures",
    "split-brain scenario": "network partition causing inconsistent system state",
    "load shedding": "selective request dropping during high traffic",
    "consistency guarantee": "promise about data consistency during degraded operation",
    "resource exhaustion": "system running out of memory or other critical resources",
    "property-based testing": "testing invariants with random inputs",
    "milestone validation": "quality gates between development phases",
    "assignment stability": "property that users get same variant consistently",
    "rule evaluation determinism": "property that targeting rules evaluate consistently",
    "cache consistency": "property that cached data matches authoritative source",
    "significance calculation accuracy": "property that statistical calculations match established formulas",
    "flag evaluation": "process of determining variant assignment from rules and context",
    "rule evaluation": "processing targeting conditions to determine matches",
    "cache synchronization": "ensuring cached data matches authoritative source",
    "connection management": "handling establishment, maintenance, and recovery of streaming connections",
    "event ordering": "ensuring updates are processed in correct sequence",
    "health monitoring": "systematic checking of component operational status",
    "error classification": "categorizing errors by type for appropriate handling",
    "dynamic segmentation": "real-time evaluation of user segment membership during flag evaluation",
    "prerequisite flags": "required flags that must be enabled before dependent flags activate",
    "multi-environment support": "independent flag configurations across development, staging, and production environments",
    "edge evaluation": "flag evaluation at geographically distributed nodes for reduced latency",
    "configuration promotion": "controlled advancement of flag settings between environments",
    "dependency graph": "directed acyclic graph representing flag prerequisite relationships",
    "contextual targeting": "flag targeting based on environmental and situational user information",
    "CRDT": "conflict-free replicated data types ensuring eventual consistency",
    "evaluation result caching": "caching flag evaluation outcomes for identical user contexts"
  }
}