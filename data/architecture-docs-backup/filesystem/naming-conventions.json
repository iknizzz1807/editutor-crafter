{
  "types": {
    "block_device_t": "fields: fd int, total_blocks block_count_t, read_only bool, cache char*",
    "block_num_t": "uint32_t block number",
    "inode_num_t": "uint32_t inode number",
    "file_size_t": "uint64_t file size in bytes",
    "block_count_t": "uint32_t number of blocks",
    "fs_error_t": "enum with filesystem error codes",
    "milestone_test_t": "fields: test_name char*, test_function function pointer, description char*",
    "superblock_t": "complete superblock structure with all metadata fields",
    "inode_t": "fields: magic uint32_t, mode uint16_t, size file_size_t, blocks_count uint32_t, direct_blocks block_num_t[12], single_indirect block_num_t, double_indirect block_num_t",
    "directory_entry_t": "fields: inode_number inode_num_t, record_length uint16_t, name_length uint8_t, file_type uint8_t, name char[]",
    "inode_allocator_t": "fields: device block_device_t*, bitmap_start_block block_num_t, total_inodes uint32_t, free_inodes uint32_t",
    "directory_iterator_t": "fields: device block_device_t*, directory_inode inode_t*, current_block block_num_t, current_offset uint32_t, block_buffer uint8_t*, buffer_dirty bool",
    "path_components_t": "fields: components char**, component_count size_t, is_absolute bool, original_path char*",
    "file_handle_t": "fields: device block_device_t*, inode inode_t*, inode_number inode_num_t, dirty bool",
    "file_op_result_t": "fields: bytes_processed size_t, created_holes bool, extended_file bool, error fs_error_t",
    "block_mapping_t": "fields: block_number block_num_t, block_offset uint32_t, is_hole bool, needs_allocation bool",
    "filesystem_state_t": "fields: device block_device_t*, superblock superblock_t, is_mounted bool, read_only bool, errors_count uint64_t",
    "error_context_t": "fields: error_code fs_error_t, operation_name char*, file_path char*, offset uint64_t, detailed_message char*",
    "circuit_breaker_t": "fields: failure_count uint32_t, last_failure_time time_t, is_open bool, failure_threshold uint32_t",
    "retry_config_t": "fields: max_retries uint32_t, base_delay_ms uint32_t, max_delay_ms uint32_t, timeout_seconds uint32_t",
    "space_utilization_level_t": "enum with disk space usage levels",
    "test_context_t": "fields: temp_dir char[256], temp_files char[32][256], temp_file_count int",
    "debug_logger_t": "fields: log_file FILE*, current_level log_level_t, log_mutex pthread_mutex_t, include_timestamps bool, include_thread_id bool",
    "fs_statistics_t": "fields: total_blocks uint32_t, free_blocks uint32_t, total_inodes uint32_t, free_inodes uint32_t, directory_count uint32_t, file_count uint32_t, total_file_size uint64_t, fragmentation_score uint32_t",
    "block_type_info_t": "fields: display_char char, description const char*, count uint32_t",
    "fuse_trace_entry_t": "fields: operation_name const char*, start_time struct timespec, end_time struct timespec, return_code int, path char[256]",
    "log_level_t": "enum: LOG_LEVEL_ERROR, LOG_LEVEL_WARN, LOG_LEVEL_INFO, LOG_LEVEL_DEBUG, LOG_LEVEL_TRACE",
    "journal_superblock_t": "fields: magic uint32_t, version uint32_t, block_size uint32_t, journal_blocks uint32_t, journal_start block_num_t, head_sequence uint64_t, tail_sequence uint64_t, head_block block_num_t, tail_block block_num_t, transaction_count uint32_t, max_transaction_size uint32_t, total_commits uint64_t, total_aborts uint64_t, checksum uint32_t, reserved uint8_t[64]",
    "journal_record_t": "fields: magic uint32_t, record_type uint32_t, transaction_id uint64_t, record_length uint32_t, data_length uint32_t, checksum uint32_t, data uint8_t[]",
    "block_modification_t": "fields: block_number block_num_t, offset uint32_t, length uint32_t, before_image uint8_t[BLOCK_SIZE], after_image uint8_t[BLOCK_SIZE]",
    "extent_t": "fields: start_block block_num_t, block_count uint32_t, is_allocated bool, allocation_time uint64_t",
    "extent_allocator_t": "fields: extents extent_t*, extent_count uint32_t, max_extents uint32_t, device block_device_t*",
    "async_io_request_t": "fields: operation_type int, block_number block_num_t, buffer uint8_t*, buffer_size size_t, completion_callback function pointer, user_data void*, result fs_error_t",
    "xattr_entry_t": "fields: name char[256], value_length uint32_t, value uint8_t[]",
    "journal_t": "journal management structure"
  },
  "methods": {
    "block_device_open(image_path, read_only, device) returns fs_error_t": "open disk image file as block device",
    "block_device_close(device) returns void": "close block device and free resources",
    "block_read(device, block_num, buffer) returns fs_error_t": "read single block into buffer",
    "block_write(device, block_num, buffer) returns fs_error_t": "write single block from buffer",
    "block_sync(device) returns fs_error_t": "flush all cached writes to disk",
    "block_device_open(image_path, read_only, device)": "open disk image file as block device",
    "block_device_close(device)": "close block device and free resources",
    "block_read(device, block_num, buffer)": "read single block into buffer",
    "block_write(device, block_num, buffer)": "write single block from buffer",
    "block_sync(device)": "flush all cached writes to disk",
    "create_symbolic_link(link_path, target_path)": "create symbolic link (disabled in scope)",
    "allocate_extent(start, length)": "allocate contiguous blocks (scope violation example)",
    "block_alloc(device, allocated_block)": "allocate free block",
    "block_free(device, block_num)": "deallocate block",
    "run_milestone_tests(tests, test_count)": "execute array of milestone tests",
    "print_test_results(milestone_name, passed, total)": "display test summary",
    "superblock_read(device, sb) returns fs_error_t": "read superblock from block device",
    "superblock_write(device, sb) returns fs_error_t": "write superblock to block device",
    "superblock_validate(sb) returns fs_error_t": "validate superblock structure and magic",
    "inode_read(device, inode_num, inode) returns fs_error_t": "read inode from inode table",
    "inode_write(device, inode_num, inode) returns fs_error_t": "write inode to inode table",
    "directory_add_entry(device, dir_inode, name, target_inode) returns fs_error_t": "add entry to directory",
    "directory_lookup(device, dir_inode, name, found_inode) returns fs_error_t": "find inode number by name in directory",
    "block_alloc(device, allocated_block) returns fs_error_t": "allocate free block",
    "block_free(device, block_num) returns fs_error_t": "deallocate block",
    "inode_alloc(allocator, inode_num) returns fs_error_t": "allocate free inode number",
    "inode_free(allocator, inode_num) returns fs_error_t": "deallocate inode number",
    "inode_offset_to_block(inode, file_offset, block_num, block_offset) returns fs_error_t": "convert file offset to block address",
    "inode_extend_file(device, inode, new_size) returns fs_error_t": "allocate blocks to grow file",
    "inode_truncate_file(device, inode, new_size) returns fs_error_t": "free blocks to shrink file",
    "directory_remove_entry(device, dir_inode, name) returns fs_error_t": "remove entry from directory",
    "path_resolve_to_inode(device, path, root_inode, cwd_inode, result_inode) returns fs_error_t": "resolve path to inode number",
    "filesystem_create_file(device, path, mode, root_inode) returns fs_error_t": "create new file",
    "filesystem_create_directory(device, path, mode, root_inode) returns fs_error_t": "create new directory",
    "filesystem_delete_file(device, path, root_inode) returns fs_error_t": "delete file",
    "inode_increment_links(device, inode_number) returns fs_error_t": "increment inode reference count",
    "inode_decrement_links(device, inode_number) returns fs_error_t": "decrement inode reference count",
    "file_read(device, inode, offset, length, buffer, bytes_read) returns fs_error_t": "read data from file at offset",
    "file_write(device, inode, inode_number, offset, length, buffer, bytes_written) returns fs_error_t": "write data to file at offset",
    "filesystem_state_init(image_path, mount_point) returns fs_error_t": "initialize global filesystem state for mounting",
    "filesystem_state_cleanup() returns void": "cleanup filesystem state during unmount",
    "fs_error_to_errno(error) returns int": "convert internal error codes to FUSE errno values",
    "inode_mode_to_posix(inode_mode) returns mode_t": "convert inode mode field to POSIX stat mode",
    "posix_mode_to_inode(posix_mode) returns uint16_t": "convert POSIX mode to inode mode field",
    "fuse_getattr(path, stbuf, fi) returns int": "FUSE callback to get file attributes",
    "fuse_readdir(path, buf, filler, offset, fi, flags) returns int": "FUSE callback to read directory contents",
    "fuse_open(path, fi) returns int": "FUSE callback to open file for reading or writing",
    "fuse_read(path, buf, size, offset, fi) returns int": "FUSE callback to read data from open file",
    "fuse_write(path, buf, size, offset, fi) returns int": "FUSE callback to write data to open file",
    "fuse_release(path, fi) returns int": "FUSE callback to close file handle",
    "fuse_create(path, mode, fi) returns int": "FUSE callback to create new file",
    "fuse_mkdir(path, mode) returns int": "FUSE callback to create new directory",
    "fuse_unlink(path) returns int": "FUSE callback to delete file",
    "filesystem_create_file(path, mode) returns fs_error_t": "create new file with coordination across all layers",
    "file_read_coordinated(path, offset, length, buffer, bytes_read) returns fs_error_t": "read file data with cross-layer coordination",
    "file_write_coordinated(path, offset, length, buffer, bytes_written) returns fs_error_t": "write file data with allocation and consistency handling",
    "directory_list_coordinated(path, entry_callback) returns fs_error_t": "list directory contents with proper iterator management",
    "log_operation_error(context) returns void": "detailed error logging for debugging",
    "classify_io_error(errno_value, operation) returns fs_error_t": "map errno to filesystem error codes",
    "retry_io_operation(operation, context, config, error_ctx) returns fs_error_t": "retry logic with exponential backoff",
    "circuit_breaker_should_allow(breaker) returns bool": "check if operation should be allowed",
    "validate_magic_number(structure, expected_magic, structure_name, block_num) returns fs_error_t": "validate structure magic number",
    "calculate_crc32(data, length, checksum_offset) returns uint32_t": "calculate CRC32 checksum",
    "verify_structure_checksum(structure, structure_size, checksum_offset, structure_name) returns fs_error_t": "verify structure integrity using checksum",
    "validate_inode_structure(inode, inode_number) returns fs_error_t": "check inode structural consistency",
    "check_disk_space_level(device, superblock) returns space_utilization_level_t": "monitor disk space utilization",
    "perform_emergency_cleanup(fs_state, target_bytes) returns fs_error_t": "emergency space cleanup when critically low",
    "check_inode_availability(allocator, remaining_inodes, utilization_percent) returns fs_error_t": "monitor inode allocation status",
    "test_create_temp_disk_image(size_spec, image_path_out)": "create temporary disk image for testing",
    "test_cleanup_resources(context)": "clean up test files and resources",
    "test_measure_operation_time(operation)": "measure execution time of test operation",
    "debug_logger_init(log_path, level) returns fs_error_t": "initialize debugging logger with configuration",
    "debug_log(level, component, format, ...) returns void": "thread-safe logging with automatic formatting",
    "debug_dump_filesystem_state(device, dump_path) returns fs_error_t": "comprehensive filesystem state dumper for debugging",
    "debug_inspect_inode(device, inode_number) returns fs_error_t": "interactive inode inspector for manual debugging",
    "debug_visualize_allocation(device, output_path) returns fs_error_t": "generate ASCII art visualization of filesystem layout",
    "fuse_trace_start(operation, path) returns void": "start timing a FUSE operation",
    "fuse_trace_end(return_code) returns void": "end timing and record result",
    "fuse_getattr_traced(path, stbuf, fi) returns int": "enhanced FUSE callback with tracing",
    "fuse_read_traced(path, buf, size, offset, fi) returns int": "enhanced FUSE read callback with tracing",
    "fuse_dump_trace(dump_path) returns void": "dump recent FUSE trace for debugging",
    "journal_init(device, journal_blocks, journal_out) returns fs_error_t": "initialize journal system with specified block count",
    "journal_begin_transaction(journal, transaction_id) returns fs_error_t": "start new transaction and return unique ID",
    "journal_log_block_write(journal, transaction_id, block_num, before_data, after_data) returns fs_error_t": "log block modification with before/after images",
    "journal_commit_transaction(journal, transaction_id) returns fs_error_t": "commit transaction by writing to journal and applying changes",
    "journal_abort_transaction(journal, transaction_id) returns fs_error_t": "abort transaction and discard all logged changes",
    "journal_recover(device, journal) returns fs_error_t": "recover filesystem state from journal after crash",
    "extent_allocate_range(allocator, block_count, allocated_extent) returns fs_error_t": "allocate contiguous block range using extent system",
    "extent_free_range(allocator, extent) returns fs_error_t": "free extent range and coalesce with adjacent free extents",
    "async_io_submit_read(device, block_num, buffer, callback, user_data) returns fs_error_t": "submit asynchronous read request",
    "async_io_submit_write(device, block_num, buffer, callback, user_data) returns fs_error_t": "submit asynchronous write request",
    "symlink_create(device, link_path, target_path, parent_inode) returns fs_error_t": "create symbolic link pointing to target path",
    "symlink_resolve(device, link_inode, resolved_path, path_buffer_size, max_follow_depth) returns fs_error_t": "resolve symbolic link to target path",
    "xattr_set(device, inode_number, attr_name, attr_value, value_size, flags) returns fs_error_t": "set extended attribute on file",
    "xattr_get(device, inode_number, attr_name, attr_value, value_size) returns fs_error_t": "get extended attribute value",
    "xattr_list(device, inode_number, attr_names, names_size) returns fs_error_t": "list all extended attribute names"
  },
  "constants": {
    "BLOCK_SIZE": "4096 bytes per block",
    "FS_MAGIC": "0x53465348 filesystem magic number",
    "INODE_MAGIC": "0x494E4F44 inode magic number",
    "MAX_FILENAME_LEN": "255 maximum filename length",
    "FS_SUCCESS": "0 success error code",
    "FS_ERROR_IO_ERROR": "5 I/O error code",
    "FS_ERROR_NOT_SUPPORTED": "error code for disabled features",
    "FS_MAX_FILESIZE": "1GB maximum file size",
    "FS_MAX_FILESYSTEM_SIZE": "4GB maximum filesystem size",
    "DIRECT_BLOCK_COUNT": "12 direct block pointers in inode",
    "FS_ERROR_NOT_FOUND": "error code for file not found",
    "FS_ERROR_EXISTS": "error code for file already exists",
    "FS_ERROR_NOT_DIRECTORY": "error code for not a directory",
    "FS_ERROR_INVALID_ARGUMENT": "error code for invalid parameters",
    "FS_ERROR_TOO_MANY_LINKS": "error code for link count overflow",
    "FS_ERROR_INVALID_STATE": "error code for invalid filesystem state",
    "FS_ERROR_IO_TIMEOUT": "error code for I/O timeout",
    "FS_ERROR_IO_MEDIA_ERROR": "error code for media/hardware failure",
    "FS_ERROR_IO_DEVICE_FULL": "error code for disk space exhaustion",
    "FS_ERROR_CORRUPTION_MAGIC": "error code for magic number corruption",
    "FS_ERROR_CORRUPTION_CHECKSUM": "error code for checksum mismatch",
    "FS_ERROR_CORRUPTION_STRUCTURE": "error code for structural inconsistency",
    "FS_ERROR_RESOURCE_EXHAUSTED_SPACE": "error code for disk space exhaustion",
    "FS_ERROR_RESOURCE_EXHAUSTED_INODES": "error code for inode exhaustion",
    "FS_ERROR_RESOURCE_EXHAUSTED_MEMORY": "error code for memory allocation failure",
    "FS_ERROR_NO_SPACE": "error code for disk space exhaustion",
    "MAX_TRACE_ENTRIES": "1000 maximum FUSE trace entries",
    "LOG_LEVEL_ERROR": "0 error log level",
    "LOG_LEVEL_WARN": "1 warning log level",
    "LOG_LEVEL_INFO": "2 info log level",
    "LOG_LEVEL_DEBUG": "3 debug log level",
    "LOG_LEVEL_TRACE": "4 trace log level",
    "JOURNAL_MAGIC": "0x4A524E4C journal identification magic",
    "JOURNAL_VERSION": "1 journal format version",
    "TRANSACTION_MAGIC": "0x54584E52 transaction record magic",
    "JOURNAL_RECORD_BEGIN": "1 begin transaction record type",
    "JOURNAL_RECORD_DATA": "2 data modification record type",
    "JOURNAL_RECORD_COMMIT": "3 commit transaction record type",
    "JOURNAL_RECORD_ABORT": "4 abort transaction record type",
    "MAX_SYMLINK_DEPTH": "32 maximum symbolic link following depth",
    "MAX_XATTR_NAME_LEN": "255 maximum extended attribute name length",
    "MAX_XATTR_VALUE_LEN": "65536 maximum extended attribute value length"
  },
  "terms": {
    "block device": "abstraction providing fixed-size block read/write operations",
    "block cache": "in-memory cache of frequently accessed blocks",
    "write-back caching": "cache policy that delays writes until cache eviction",
    "bitmap": "bit array tracking allocation status of blocks or inodes",
    "superblock": "first block containing filesystem metadata",
    "inode": "data structure storing file metadata and block pointers",
    "FUSE": "Filesystem in Userspace interface",
    "scope creep": "adding features beyond defined project boundaries",
    "milestone validation": "systematic testing of completed project phases",
    "path resolution": "algorithm converting path strings to target inodes",
    "layered architecture": "architectural pattern with strict hierarchical dependencies",
    "API boundary": "interface definition between architectural layers",
    "cross-layer dependency": "violation of layered architecture principles",
    "abstraction leakage": "exposure of implementation details through interfaces",
    "block bitmap": "bit array tracking allocation status of blocks",
    "inode bitmap": "bit array tracking allocation status of inodes",
    "directory entry": "structure mapping filename to inode number",
    "direct block pointers": "immediate references to file data blocks",
    "indirect block pointer": "reference to block containing more block pointers",
    "magic number": "signature value for structure identification",
    "record length": "total size of variable-length directory entry",
    "alignment padding": "bytes added to maintain structure alignment",
    "inode table": "on-disk storage area for inode structures",
    "reference counting": "tracking number of directory entries pointing to inode",
    "phone book pages": "mental model for understanding directory structure",
    "hierarchical namespace": "tree structure of directories and files",
    "atomic rename": "rename operation that appears instantaneous",
    "links count": "number of directory entries referencing an inode",
    "parent reference": "directory's .. entry pointing to parent inode",
    "circular reference": "invalid directory structure creating loops",
    "sparse files": "files with holes that don't consume storage for zero regions",
    "expandable notebooks": "mental model for files that can grow by adding pages",
    "holes": "unallocated regions in sparse files that read as zeros",
    "block mapping": "translation from file offset to physical block number",
    "file growth": "extending file size by allocating additional blocks",
    "file truncation": "reducing file size by freeing blocks beyond new end",
    "indirect block pointers": "references to blocks containing more block pointers",
    "zero-fill": "filling memory or storage regions with zero bytes",
    "partial block writes": "writes that don't cover entire block boundaries",
    "translation service": "mental model for FUSE as bridge between OS and filesystem",
    "callback functions": "user-defined functions called by FUSE for filesystem operations",
    "VFS layer": "Virtual File System layer in operating system kernel",
    "user space": "non-privileged execution environment outside kernel",
    "thread-safe": "code that works correctly when executed concurrently",
    "global mutex": "single lock protecting all shared filesystem resources",
    "stateless design": "callback implementation that looks up all needed data on each call",
    "defensive programming": "validating all inputs to guard against malicious or invalid data",
    "mount point": "directory path where filesystem appears in namespace",
    "errno": "POSIX error code convention for system calls",
    "file handle": "opaque identifier representing open file for subsequent operations",
    "bidirectional translator": "component that converts between two different interfaces or protocols",
    "layered collaboration": "coordination between specialized architectural layers",
    "orchestration patterns": "coordination patterns for complex multi-layer operations",
    "offset-to-block translation": "converting file byte offsets to physical block addresses",
    "read-modify-write cycle": "pattern for handling partial block updates",
    "compensation pattern": "rollback strategy for handling partial operation failures",
    "snapshot consistency": "providing consistent view of data at a point in time",
    "block-level buffering": "caching entire blocks during directory iteration",
    "incremental listing": "transferring directory contents across multiple operations",
    "batch allocation": "allocating multiple resources in single operation",
    "global filesystem state": "shared state structure coordinating all layers",
    "error propagation": "systematic forwarding of error information between layers",
    "resource tracking": "monitoring allocated resources for proper cleanup",
    "concurrency control": "synchronization mechanisms for thread safety",
    "circuit breaker pattern": "isolation mechanism for failing components",
    "write failure compensation": "recovery strategy for partial write failures",
    "corruption detection": "systematic validation of data structure integrity",
    "resource exhaustion": "depletion of critical filesystem resources like space or inodes",
    "graduated response": "increasingly strict measures as resources become scarce",
    "emergency cleanup": "aggressive resource reclamation when critically low",
    "retry-with-backoff pattern": "exponential delay increase between retry attempts",
    "graceful degradation": "maintaining partial functionality when errors occur",
    "unit testing by layer": "testing each architectural layer in isolation",
    "milestone verification checkpoints": "structured validation gates for each project phase",
    "end-to-end integration testing": "complete filesystem testing through FUSE interface",
    "deterministic data patterns": "predictable test data that makes debugging failures easier",
    "stress testing": "validation under resource pressure and high concurrent load",
    "workload simulation": "testing with realistic application usage patterns",
    "resource exhaustion testing": "validation when disk space or inodes are depleted",
    "test framework": "infrastructure providing assertions and resource management",
    "automated test execution": "programmatic validation without manual intervention",
    "manual verification steps": "human validation of expected behaviors and outputs",
    "hex editor": "tool for inspecting binary file contents in hexadecimal format",
    "FUSE callback": "user-defined function called by FUSE for filesystem operations",
    "race condition": "bug caused by unexpected timing of concurrent operations",
    "deadlock": "situation where threads wait indefinitely for each other's locks",
    "consistency check": "validation of filesystem invariants and relationships",
    "trace-driven debugging": "debugging approach using operation history analysis",
    "write-ahead logging": "journaling technique where modifications are logged before being applied",
    "extent-based allocation": "allocating contiguous block ranges instead of individual blocks",
    "copy-on-write": "technique where shared data is copied only when modified",
    "symbolic links": "filesystem shortcuts that store target paths as file content",
    "extended attributes": "key-value metadata system for storing arbitrary file metadata",
    "crash consistency": "property that filesystem remains consistent after unexpected shutdowns",
    "transaction": "atomic group of filesystem operations that succeed or fail together",
    "journal recovery": "process of replaying or rolling back transactions after crash",
    "block reference counting": "tracking how many structures reference each block",
    "read-ahead": "prefetching data before applications request it",
    "write coalescing": "combining multiple write operations for efficiency",
    "lock-free data structures": "concurrent data structures using atomic operations instead of locks",
    "circular buffer": "fixed-size buffer that wraps around when full",
    "checkpoint": "process of applying committed transactions and reclaiming journal space"
  }
}