{
  "title": "Simple Filesystem Implementation: Design Document",
  "overview": "This system implements a complete filesystem with inodes, directories, and journaling that can be mounted via FUSE. The key architectural challenge is organizing data structures on disk for durability while providing the abstractions that applications expect from a standard filesystem.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains what filesystems do, why they're complex, and how existing filesystems solve the core challenges of data organization and consistency.",
      "subsections": [
        {
          "id": "filesystem-analogy",
          "title": "Mental Model: Digital Filing Cabinet",
          "summary": "Introduces filesystems through the analogy of a filing cabinet with drawers, folders, and index cards."
        },
        {
          "id": "core-challenges",
          "title": "Core Filesystem Challenges",
          "summary": "The fundamental problems any filesystem must solve: data organization, metadata management, and crash consistency."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Filesystem Approaches",
          "summary": "Comparison of different filesystem designs like ext4, NTFS, and ZFS with their trade-offs."
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what this filesystem implementation will and will not support, setting clear boundaries for the project scope.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Core features the filesystem must implement including basic file operations and FUSE mounting."
        },
        {
          "id": "non-functional-goals",
          "title": "Non-Functional Goals",
          "summary": "Performance, reliability, and usability characteristics the system should achieve."
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Advanced features deliberately excluded to keep the project manageable and educational."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Overview of the five major components and how they layer on top of each other to provide filesystem functionality.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "The five layers: block layer, inode management, directory operations, file operations, and FUSE interface."
        },
        {
          "id": "layered-design",
          "title": "Layered Design Rationale",
          "summary": "Why a layered architecture makes filesystem implementation more manageable and testable."
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "How to organize the C codebase into modules that mirror the architectural layers."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines all the key data structures stored on disk including superblock, inodes, directory entries, and block allocation metadata.",
      "subsections": [
        {
          "id": "disk-layout",
          "title": "Disk Layout Overview",
          "summary": "How the filesystem organizes the disk into regions for different types of data and metadata."
        },
        {
          "id": "superblock-structure",
          "title": "Superblock Structure",
          "summary": "The master record containing filesystem metadata like size, block count, and magic numbers."
        },
        {
          "id": "inode-structure",
          "title": "Inode Structure",
          "summary": "File metadata including size, permissions, timestamps, and block pointers."
        },
        {
          "id": "directory-entries",
          "title": "Directory Entry Format",
          "summary": "How directories store name-to-inode mappings within directory data blocks."
        }
      ]
    },
    {
      "id": "block-layer",
      "title": "Block Layer Design",
      "summary": "The foundation layer that provides raw block device operations, allocation tracking, and caching on top of a disk image file.",
      "subsections": [
        {
          "id": "block-abstraction",
          "title": "Block Device Abstraction",
          "summary": "Mental model and interface for treating a file as a collection of fixed-size blocks."
        },
        {
          "id": "allocation-bitmap",
          "title": "Block Allocation Strategy",
          "summary": "Using bitmaps to track free and allocated blocks with allocation and deallocation algorithms."
        },
        {
          "id": "block-caching",
          "title": "Block Caching Design",
          "summary": "Write-back caching to reduce disk I/O with cache eviction and synchronization policies."
        },
        {
          "id": "block-layer-implementation",
          "title": "Implementation Guidance",
          "summary": "C structures, starter code for disk I/O, and skeleton functions for allocation."
        }
      ]
    },
    {
      "id": "inode-management",
      "title": "Inode Management Design",
      "summary": "Manages file metadata including allocation, direct and indirect block pointers, and serialization to the inode table on disk.",
      "subsections": [
        {
          "id": "inode-mental-model",
          "title": "Mental Model: File Index Cards",
          "summary": "Understanding inodes as index cards that contain file metadata and pointers to actual data."
        },
        {
          "id": "block-pointer-strategy",
          "title": "Direct and Indirect Block Pointers",
          "summary": "How inodes support files of varying sizes through multiple levels of indirection."
        },
        {
          "id": "inode-allocation",
          "title": "Inode Allocation and Lifecycle",
          "summary": "Allocating inodes from the inode bitmap and managing their lifecycle."
        },
        {
          "id": "inode-implementation",
          "title": "Implementation Guidance",
          "summary": "Inode structure definition, allocation routines, and block pointer traversal skeletons."
        }
      ]
    },
    {
      "id": "directory-operations",
      "title": "Directory Operations Design",
      "summary": "Implements directory entry management, path resolution, and hierarchical namespace operations like create, delete, and rename.",
      "subsections": [
        {
          "id": "directory-mental-model",
          "title": "Mental Model: Phone Book Pages",
          "summary": "Understanding directories as pages that map names to addresses (inode numbers)."
        },
        {
          "id": "path-resolution",
          "title": "Path Resolution Algorithm",
          "summary": "Step-by-step process for traversing path components to find target inodes."
        },
        {
          "id": "directory-consistency",
          "title": "Directory Consistency Challenges",
          "summary": "Handling parent references, link counts, and atomic rename operations."
        },
        {
          "id": "directory-implementation",
          "title": "Implementation Guidance",
          "summary": "Directory entry format, path traversal skeleton, and namespace operation stubs."
        }
      ]
    },
    {
      "id": "file-operations",
      "title": "File Operations Design",
      "summary": "Implements file I/O operations including read, write, truncate, and sparse file support through the inode block pointer system.",
      "subsections": [
        {
          "id": "file-io-mental-model",
          "title": "Mental Model: Expandable Notebooks",
          "summary": "Understanding files as notebooks that can grow by adding pages, with an index showing which pages exist."
        },
        {
          "id": "sparse-files",
          "title": "Sparse File Handling",
          "summary": "Supporting files with holes that read as zeros without allocating storage for unwritten regions."
        },
        {
          "id": "file-growth-truncation",
          "title": "File Growth and Truncation",
          "summary": "Algorithms for extending files by allocating blocks and shrinking files by releasing blocks."
        },
        {
          "id": "file-operations-implementation",
          "title": "Implementation Guidance",
          "summary": "File I/O function skeletons, offset-to-block mapping, and sparse file detection logic."
        }
      ]
    },
    {
      "id": "fuse-interface",
      "title": "FUSE Interface Design",
      "summary": "Bridges the custom filesystem implementation to the operating system's VFS layer through FUSE callback functions.",
      "subsections": [
        {
          "id": "fuse-mental-model",
          "title": "Mental Model: Translation Service",
          "summary": "Understanding FUSE as a translation layer between OS system calls and custom filesystem operations."
        },
        {
          "id": "callback-mapping",
          "title": "FUSE Callback Implementation Strategy",
          "summary": "Mapping FUSE operations like getattr, read, and write to internal filesystem functions."
        },
        {
          "id": "concurrency-considerations",
          "title": "Concurrency and Threading",
          "summary": "Handling multiple simultaneous filesystem operations and protecting shared state."
        },
        {
          "id": "fuse-implementation",
          "title": "Implementation Guidance",
          "summary": "FUSE callback registration, operation handler skeletons, and mount/unmount lifecycle."
        }
      ]
    },
    {
      "id": "data-flow-interactions",
      "title": "Interactions and Data Flow",
      "summary": "Describes how components communicate and the sequence of operations for common filesystem tasks like creating files and reading directories.",
      "subsections": [
        {
          "id": "file-creation-flow",
          "title": "File Creation Data Flow",
          "summary": "Step-by-step sequence from FUSE create callback down to block allocation and inode creation."
        },
        {
          "id": "read-write-flow",
          "title": "File Read/Write Data Flow",
          "summary": "How read and write operations traverse from FUSE through inodes to block layer operations."
        },
        {
          "id": "directory-listing-flow",
          "title": "Directory Listing Data Flow",
          "summary": "The sequence for readdir operations that scan directory entries and return file information."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Comprehensive error handling strategy covering disk failures, corruption detection, and graceful degradation modes.",
      "subsections": [
        {
          "id": "disk-io-failures",
          "title": "Disk I/O Failure Handling",
          "summary": "Strategies for detecting and responding to read/write failures at the block layer."
        },
        {
          "id": "corruption-detection",
          "title": "Data Corruption Detection",
          "summary": "Using magic numbers, checksums, and consistency checks to detect filesystem corruption."
        },
        {
          "id": "resource-exhaustion",
          "title": "Resource Exhaustion Scenarios",
          "summary": "Handling out-of-space conditions, inode exhaustion, and memory allocation failures."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Testing approach for each milestone with specific verification steps and expected behaviors to confirm correct implementation.",
      "subsections": [
        {
          "id": "unit-testing-approach",
          "title": "Unit Testing by Layer",
          "summary": "Testing strategy for each architectural layer in isolation before integration testing."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "Specific tests and expected outputs after completing each milestone to verify progress."
        },
        {
          "id": "integration-testing",
          "title": "End-to-End Integration Testing",
          "summary": "Testing complete filesystem operations through the FUSE interface with real file operations."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common symptoms, likely causes, and debugging techniques specific to filesystem implementation challenges.",
      "subsections": [
        {
          "id": "common-bugs",
          "title": "Common Implementation Bugs",
          "summary": "Symptom-to-cause-to-fix mapping for the most frequent mistakes in filesystem implementation."
        },
        {
          "id": "debugging-techniques",
          "title": "Filesystem-Specific Debugging",
          "summary": "Tools and techniques for inspecting disk layout, tracing block allocation, and verifying metadata consistency."
        },
        {
          "id": "fuse-debugging",
          "title": "FUSE Integration Debugging",
          "summary": "Debugging FUSE callback issues, mount problems, and user-space filesystem crashes."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements like journaling, compression, and advanced features that build on the basic filesystem foundation.",
      "subsections": [
        {
          "id": "journaling-support",
          "title": "Adding Journaling",
          "summary": "How to extend the design to support write-ahead logging for crash consistency."
        },
        {
          "id": "performance-optimizations",
          "title": "Performance Enhancements",
          "summary": "Potential optimizations like extent-based allocation, read-ahead, and better caching strategies."
        },
        {
          "id": "advanced-features",
          "title": "Advanced Filesystem Features",
          "summary": "Symbolic links, extended attributes, compression, and encryption as future additions."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of filesystem terminology, acronyms, and technical concepts used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "Filesystem Component Architecture",
      "description": "Shows the five main components (FUSE Interface, File Operations, Directory Operations, Inode Management, Block Layer) and how they connect to each other and to the disk image backend. Include data flow arrows and key interfaces between layers.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "data-flow-interactions"
      ]
    },
    {
      "id": "disk-layout",
      "title": "Disk Layout and Data Structures",
      "description": "Visual representation of how the disk is organized into regions: superblock, block bitmap, inode bitmap, inode table, and data blocks. Show the relationships between these structures and sample contents.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "block-layer"
      ]
    },
    {
      "id": "inode-structure",
      "title": "Inode Block Pointer Structure",
      "description": "Detailed view of an inode showing direct block pointers, indirect block pointer, and how they chain to reach file data blocks. Include examples for small and large files.",
      "type": "class",
      "relevant_sections": [
        "inode-management",
        "file-operations"
      ]
    },
    {
      "id": "file-creation-sequence",
      "title": "File Creation Operation Sequence",
      "description": "Sequence diagram showing the flow from FUSE create callback through directory entry addition, inode allocation, and block allocation. Include all component interactions and return values.",
      "type": "sequence",
      "relevant_sections": [
        "data-flow-interactions",
        "fuse-interface"
      ]
    },
    {
      "id": "block-allocation-flow",
      "title": "Block Allocation Process",
      "description": "Flowchart showing the decision process for block allocation: checking bitmap, finding free blocks, updating bitmap, and handling out-of-space conditions.",
      "type": "flowchart",
      "relevant_sections": [
        "block-layer",
        "error-handling"
      ]
    },
    {
      "id": "path-resolution-flow",
      "title": "Path Resolution Algorithm",
      "description": "Flowchart depicting the step-by-step path resolution process: parsing path components, traversing directories, handling . and .. entries, and returning target inode.",
      "type": "flowchart",
      "relevant_sections": [
        "directory-operations"
      ]
    },
    {
      "id": "file-io-state-machine",
      "title": "File Handle State Machine",
      "description": "State machine showing file handle states: closed, open for read, open for write, and the transitions between states based on operations and error conditions.",
      "type": "state-machine",
      "relevant_sections": [
        "file-operations",
        "fuse-interface"
      ]
    },
    {
      "id": "error-handling-flow",
      "title": "Error Detection and Recovery Flow",
      "description": "Flowchart showing error detection points, types of errors (I/O, corruption, resource exhaustion), and recovery strategies for each error type.",
      "type": "flowchart",
      "relevant_sections": [
        "error-handling",
        "debugging-guide"
      ]
    }
  ]
}