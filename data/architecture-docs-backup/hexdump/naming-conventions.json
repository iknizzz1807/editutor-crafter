{
  "types": {
    "BinaryChunk": "fields: bytes[16] unsigned char, length size_t, file_offset off_t",
    "FormatConfig": "fields: group_size int, bytes_per_line int, show_ascii int, uppercase_hex int, skip_offset off_t, length_limit size_t, filename[256] char, canonical_mode int",
    "OutputLine": "fields: offset_str[16] char, hex_str[64] char, ascii_str[32] char",
    "FileReader": "fields: file FILE*, current_offset off_t, skip_offset off_t, bytes_remaining size_t, is_stdin int",
    "HexdumpResult": "enum: SUCCESS, ERROR_FILE_NOT_FOUND, ERROR_PERMISSION_DENIED, ERROR_IO_ERROR, ERROR_INVALID_ARGUMENTS, ERROR_OUT_OF_MEMORY",
    "ASCIIResult": "enum: ASCII_SUCCESS, ASCII_ERROR_NULL_POINTER, ASCII_ERROR_INVALID_LENGTH, ASCII_ERROR_BUFFER_TOO_SMALL",
    "ASCIIConfig": "fields: show_separators int, pad_partial_lines int, replacement_char char",
    "ErrorContext": "fields: result HexdumpResult, filename const char*, operation const char*, system_errno int, file_offset off_t",
    "MilestoneTest": "fields: test_name const char*, input_file const char*, expected_output_file const char*, command_args const char*, expected_result HexdumpResult",
    "ExtensionInterface": "fields: name const char*, description const char*, version_major int, version_minor int, initialize function pointer, process_chunk function pointer, cleanup function pointer",
    "ExtensionCapability": "enum: EXTENSION_COLOR, EXTENSION_UNICODE, EXTENSION_TEMPLATES, EXTENSION_PERFORMANCE, EXTENSION_PLUGINS",
    "ColorCapability": "enum: COLOR_NONE, COLOR_BASIC, COLOR_EXTENDED, COLOR_TRUECOLOR"
  },
  "methods": {
    "file_reader_init(reader, filename, skip_offset, length_limit) returns HexdumpResult": "initializes file reader with seeking and limiting",
    "file_reader_read_chunk(reader, chunk) returns HexdumpResult": "reads next 16-byte chunk from file",
    "errno_to_result() returns HexdumpResult": "converts system errno to hexdump error type",
    "print_error(result, context)": "prints user-friendly error message",
    "get_default_config() returns FormatConfig*": "returns default configuration structure",
    "validate_config(config) returns HexdumpResult": "validates configuration values and combinations",
    "init_binary_chunk(chunk, file_offset)": "initializes binary chunk with offset",
    "init_output_line(line)": "initializes output line with empty strings",
    "format_hex_line(chunk, config, output) returns HexdumpResult": "formats binary chunk as hexadecimal line",
    "format_offset(offset, output) returns HexdumpResult": "formats file offset as hexadecimal address",
    "calculate_hex_width(config, byte_count) returns int": "calculates hex column width for alignment",
    "needs_group_separator(byte_position, group_size) returns int": "determines if space separator needed between groups",
    "byte_to_hex(byte, output, uppercase)": "converts single byte to hexadecimal string",
    "render_ascii_column(bytes, length, hex_width, config, output, output_size) returns ASCIIResult": "renders ASCII representation with alignment",
    "calculate_ascii_padding(byte_count, group_size, bytes_per_line, padding) returns ASCIIResult": "calculates spacing needed for ASCII column alignment",
    "is_printable_ascii(byte) returns int": "tests if character is safe to display",
    "get_default_ascii_config(config) returns ASCIIResult": "initialize ASCII rendering configuration",
    "parse_arguments(argc, argv, config) returns HexdumpResult": "parse command-line arguments and return validated configuration",
    "parse_numeric_argument(arg, result) returns HexdumpResult": "parse numeric arguments with multiple format support",
    "print_usage(program_name)": "display usage information and examples",
    "validate_file_access(filename) returns HexdumpResult": "checks file existence and permissions",
    "validate_file_type(filename) returns HexdumpResult": "validates file is not directory",
    "handle_file_boundary_conditions(reader) returns HexdumpResult": "manages skip offset and stdin limitations",
    "process_partial_chunk(chunk, config, output) returns HexdumpResult": "formats partial chunks with proper alignment",
    "calculate_padding_needed(bytes_present, group_size) returns size_t": "computes spacing for column alignment",
    "is_partial_chunk(bytes_read) returns int": "detects chunks smaller than 16 bytes",
    "run_milestone_test(test) returns HexdumpResult": "executes test case and validates output",
    "test_partial_line_formatting() returns HexdumpResult": "verifies handling of files not divisible by 16 bytes",
    "test_memory_usage_stability() returns HexdumpResult": "verifies streaming maintains constant memory usage",
    "generate_sequential_bytes(filename, count)": "creates binary file with predictable byte pattern for testing",
    "generate_ascii_test_file(filename)": "creates file with all 256 possible byte values for character filtering tests",
    "generate_control_char_file(filename)": "creates file with dangerous control characters for safety testing",
    "verify_chunk_integrity(chunk, expected_offset) returns int": "validates chunk structure and offset correctness",
    "dump_chunk_contents(chunk, label)": "debug output showing binary chunk contents in readable format",
    "verify_hex_formatting(input_bytes, length, expected_hex, config) returns int": "validates hex conversion accuracy",
    "verify_ascii_rendering(input_bytes, length, expected_ascii) returns int": "validates ASCII column rendering correctness",
    "memory_tracking_start()": "initializes memory usage monitoring",
    "memory_tracking_current() returns size_t": "reports current memory usage",
    "memory_tracking_report(operation)": "logs memory usage for specific operation",
    "timing_start()": "starts performance timing measurement",
    "timing_end_ms() returns double": "returns elapsed time in milliseconds",
    "detect_terminal_colors() returns ColorCapability": "detects terminal color support capabilities",
    "render_unicode_aware_column(bytes, length, hex_width, config, output, output_size) returns ASCIIResult": "renders ASCII column with UTF-8 Unicode character support",
    "initialize_extensions(config, requested) returns HexdumpResult": "initializes extension framework with requested capabilities",
    "process_chunk_with_extensions(chunk, config, output) returns HexdumpResult": "processes binary chunk through extension pipeline"
  },
  "constants": {
    "CHUNK_SIZE": "16 bytes per processing chunk",
    "MAX_BYTES_PER_LINE": "16 bytes per output line",
    "HEX_DIGITS_PER_BYTE": "2 characters",
    "ASCII_PRINTABLE_MIN": "0x20 minimum safe ASCII character",
    "ASCII_PRINTABLE_MAX": "0x7E maximum safe ASCII character",
    "ASCII_REPLACEMENT_CHAR": "period character for non-printable bytes"
  },
  "terms": {
    "binary translator": "mental model for hexdump as universal data translator",
    "streaming architecture": "processing files in chunks rather than loading entirely",
    "progressive disclosure": "design principle hiding complexity until needed",
    "cognitive interface": "human-readable representation of binary data",
    "chunked reading": "reading files in fixed-size blocks for memory efficiency",
    "scope creep": "uncontrolled expansion of project features beyond defined boundaries",
    "data blueprint": "mental model for data structures as architectural plans",
    "display artist": "mental model for hex formatter as museum exhibit designer",
    "character filter": "security guard mental model for ASCII safety checking",
    "printable character detection": "identifying safe-to-display ASCII characters",
    "column alignment": "maintaining consistent visual spacing in output",
    "configuration receptionist": "mental model for CLI parser as office receptionist collecting and validating user preferences",
    "batch validation model": "processing all arguments upfront before file processing begins",
    "fail-fast approach": "stopping parsing immediately when any argument fails validation",
    "early filesystem validation": "checking file accessibility during argument parsing",
    "graceful degradation": "continuing to work safely when advanced features unavailable",
    "last-specified-wins": "precedence rule for scalar values when conflicts occur",
    "first-error-fails": "precedence rule for incompatible combinations",
    "layered defaults approach": "system defaults, environment overrides, CLI overrides hierarchy",
    "session-level customization": "environment variable support for consistent settings",
    "cross-field validation": "ensuring configuration fields are internally consistent",
    "assembly line": "mental model for component pipeline processing",
    "streaming pipeline": "data processing flow with constant memory usage",
    "message formats": "structured data contracts between components",
    "component coupling": "dependency relationships between processing stages",
    "impedance mismatch": "difference between fixed-size processing and variable-size input",
    "safety inspector": "mental model for comprehensive error checking and prevention",
    "fail-fast detection": "catching problems immediately when they occur",
    "layered validation approach": "multiple stages of error checking from early to runtime",
    "jigsaw puzzle assembler": "mental model for handling boundary conditions and missing pieces",
    "conservative retry strategy": "selective retrying of only transient errors",
    "boundary condition handling": "managing edge cases at file boundaries and chunk boundaries",
    "milestone verification checkpoints": "systematic validation points for each development stage",
    "progressive validation layers": "testing approach where each milestone builds upon previous testing foundation",
    "conveyor belt": "mental model for chunked file reading as factory processing",
    "quality assurance laboratory": "mental model for systematic testing with calibrated references",
    "digital detective": "mental model for systematic debugging investigation",
    "layered debugging approach": "systematic verification starting with data integrity then component isolation",
    "data integrity verification": "confirming binary data moves correctly without corruption",
    "reference file generation": "creating test files with predictable patterns for validation",
    "binary comparison methodology": "systematic approach to comparing outputs against known references",
    "chunk boundary analysis": "testing behavior at file boundaries not divisible by 16 bytes",
    "component isolation testing": "testing individual components with controlled inputs",
    "integration pipeline debugging": "debugging data flow between components",
    "pipeline state inspection": "capturing intermediate processing state for analysis",
    "offset tracking verification": "validating file position calculations throughout processing",
    "memory safety debugging": "detecting buffer overruns and memory corruption",
    "buffer bounds verification": "ensuring fixed-size buffers handle variable-length data safely",
    "streaming memory usage": "constant memory consumption regardless of file size",
    "performance debugging": "identifying architectural problems through performance analysis",
    "streaming efficiency verification": "confirming consistent per-chunk processing time",
    "layered enhancement model": "integrating extensions with existing components rather than replacing",
    "extension boundary principle": "extensions enhance workflow without changing fundamental behavior",
    "configuration extension pattern": "expanding configuration while maintaining backward compatibility",
    "terminal capability detection": "identifying color and feature support in user terminal",
    "Unicode display width": "actual screen width of Unicode characters for alignment",
    "chunk boundary handling": "managing multi-byte sequences split across processing chunks",
    "feature interaction complexity": "exponential complexity from combining multiple extensions",
    "extension integration framework": "system for loading and coordinating multiple extensions",
    "orthogonal capabilities": "extensions designed to work independently without conflicts",
    "backward compatibility": "maintaining identical behavior for existing use cases",
    "compile-time feature selection": "building customized versions with only required extensions"
  }
}