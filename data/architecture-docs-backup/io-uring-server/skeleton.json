{
  "title": "High-Performance Server with io_uring: Design Document",
  "overview": "This document outlines the design for building a high-performance server leveraging Linux's io_uring interface for asynchronous I/O. It solves the architectural challenge of managing thousands of concurrent I/O operations efficiently, moving beyond the limitations of traditional event-loop models like epoll. The key focus is on mastering core concepts such as submission/completion queues, zero-copy operations, and linked requests to achieve superior throughput for I/O-bound workloads.",
  "sections": [
    {
      "id": "context",
      "title": "Context and Problem Statement",
      "summary": "Explains the I/O bottleneck in servers, introduces the evolution from blocking I/O to epoll, and establishes why io_uring is the next paradigm shift for high-performance systems.",
      "subsections": [
        {
          "id": "context-problem",
          "title": "The I/O Bottleneck and The Evolution of Async",
          "summary": "Uses the analogy of a restaurant kitchen to explain blocking vs. non-blocking I/O, culminating in the unique advantages of io_uring's 'ticket system'."
        },
        {
          "id": "context-existing",
          "title": "Existing Approaches: A Comparison",
          "summary": "Presents a comparison table of Synchronous I/O, Select/Poll, Epoll, and io_uring, highlighting syscall overhead and batching capabilities."
        }
      ]
    },
    {
      "id": "goals",
      "title": "Goals and Non-Goals",
      "summary": "Clearly defines the scope of the educational project, separating what must be achieved in each milestone from out-of-scope complexities.",
      "subsections": [
        {
          "id": "goals-must",
          "title": "Goals (What we must do)",
          "summary": "Lists the acceptance criteria for each of the four project milestones as primary goals."
        },
        {
          "id": "goals-wont",
          "title": "Non-Goals (What we won't do)",
          "summary": "Explicitly excludes production-grade features like TLS, HTTP protocol parsing, complex load balancing, or multi-threaded ring sharing to keep focus on core io_uring mechanics."
        }
      ]
    },
    {
      "id": "high-level",
      "title": "High-Level Architecture",
      "summary": "Provides a component overview of the final server, showing how the io_uring engine interacts with network and file subsystems, and recommends a codebase structure.",
      "subsections": [
        {
          "id": "high-level-components",
          "title": "Component Overview",
          "summary": "Describes the three main logical components: the io_uring Engine Core, the Connection & Session Manager, and the Buffer Manager."
        },
        {
          "id": "high-level-filestructure",
          "title": "Recommended File/Module Structure",
          "summary": "Outlines a suggested directory and file layout for the C codebase, separating core, network, file, and benchmark modules."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the core data structures that represent the io_uring instance, in-flight operations, connections, and registered buffers.",
      "subsections": [
        {
          "id": "data-core-types",
          "title": "Core Types and Structures",
          "summary": "Tables describing key types like `struct io_uring`, `struct connection_state`, `struct io_buffer`, and operation-specific context objects."
        },
        {
          "id": "data-relationships",
          "title": "Relationships and Lifecycles",
          "summary": "Explains how structures reference each other (e.g., CQE -> operation context -> connection) and their creation/destruction points."
        }
      ]
    },
    {
      "id": "component-engine",
      "title": "Component Design: The io_uring Engine Core",
      "summary": "Details the design of the central component that manages the io_uring instance, submission queue (SQ), and completion queue (CQ). Covers Milestone 1.",
      "subsections": [
        {
          "id": "component-engine-mental",
          "title": "Mental Model: The Kitchen Ticket System",
          "summary": "Analogy comparing the SQ to a kitchen order ticket rail and the CQ to a finished order pickup counter."
        },
        {
          "id": "component-engine-adr-setup",
          "title": "ADR: Initialization and Ring Sizing",
          "summary": "Decision record on using `io_uring_queue_init` vs manual setup, and choosing SQ/CQ sizes."
        },
        {
          "id": "component-engine-adr-poll",
          "title": "ADR: Submission and Completion Strategies",
          "summary": "Decision record on batching strategies, when to use `IORING_ENTER_GETEVENTS`, and busy-waiting vs. blocking."
        },
        {
          "id": "component-engine-pitfalls",
          "title": "Common Pitfalls: Engine Core",
          "summary": "Covers issues like improper memory barrier usage, mishandling of CQE overflow, and forgetting to advance the CQ tail."
        },
        {
          "id": "component-engine-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for ring setup/teardown helpers and skeleton code for the main event loop with TODOs."
        }
      ]
    },
    {
      "id": "component-fileio",
      "title": "Component Design: Asynchronous File I/O Server",
      "summary": "Focuses on using io_uring for file operations, covering buffer management and fixed buffer registration. Covers Milestone 2.",
      "subsections": [
        {
          "id": "component-fileio-mental",
          "title": "Mental Model: The Library Book Retrieval System",
          "summary": "Analogy comparing async file reads to a library where you submit a book request slip and continue working until you're called to collect it."
        },
        {
          "id": "component-fileio-adr-buffers",
          "title": "ADR: Buffer Management Strategy",
          "summary": "Decision record comparing fixed buffer registration vs. per-request allocation, and pool management strategies."
        },
        {
          "id": "component-fileio-pitfalls",
          "title": "Common Pitfalls: File I/O",
          "summary": "Covers issues like buffer lifecycle errors with fixed buffers, misaligned offsets for direct I/O, and handling `EAGAIN`/short reads."
        },
        {
          "id": "component-fileio-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for a buffer pool manager and skeleton code for submitting and handling async read requests."
        }
      ]
    },
    {
      "id": "component-network",
      "title": "Component Design: Asynchronous Network Server",
      "summary": "Details building a TCP server using io_uring for accept, read, and write operations, including multishot and connection lifecycle. Covers Milestone 3.",
      "subsections": [
        {
          "id": "component-network-mental",
          "title": "Mental Model: The Concierge Desk and Waitstaff",
          "summary": "Analogy comparing multishot accept to a concierge continuously handing out queue tickets, and read/write operations to waitstaff handling table orders."
        },
        {
          "id": "component-network-adr-multishot",
          "title": "ADR: Using Multishot Operations",
          "summary": "Decision record on when and how to use multishot for accept and receive, balancing complexity against reduced submission overhead."
        },
        {
          "id": "component-network-state",
          "title": "Connection State Management",
          "summary": "Describes the state machine for a connection (Accepting -> Reading -> Writing -> Closing) and its representation."
        },
        {
          "id": "component-network-pitfalls",
          "title": "Common Pitfalls: Network Server",
          "summary": "Covers issues like socket leak on connection drop, mishandling multishot re-submission, and head-of-line blocking in linked chains."
        },
        {
          "id": "component-network-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for connection state management and skeleton code for the network event handler with TODOs for accept/read/write chains."
        }
      ]
    },
    {
      "id": "component-advanced",
      "title": "Component Design: Advanced Features & Optimization",
      "summary": "Covers the implementation of zero-copy sends, linked operations, and ordering controls. Covers Milestone 4.",
      "subsections": [
        {
          "id": "component-advanced-mental",
          "title": "Mental Model: The Assembly Line and Conveyor Belts",
          "summary": "Analogy comparing linked SQEs to an assembly line where one station's output is directly fed to the next, and zero-copy to passing a physical item without wrapping it."
        },
        {
          "id": "component-advanced-adr-zc",
          "title": "ADR: Zero-Copy Send Implementation",
          "summary": "Decision record on managing buffer ownership and lifecycle with `IORING_OP_SEND_ZC`, including notification mechanisms."
        },
        {
          "id": "component-advanced-adr-linked",
          "title": "ADR: Chaining Operations with Linked SQEs",
          "summary": "Decision record on using linked SQEs for request processing pipelines vs. manual chaining in completion handlers."
        },
        {
          "id": "component-advanced-pitfalls",
          "title": "Common Pitfalls: Advanced Features",
          "summary": "Covers issues like deadlocks with `IOSQE_IO_DRAIN`, resource leaks on chain failure, and misusing zero-copy buffer flags."
        },
        {
          "id": "component-advanced-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for a zero-copy buffer lifecycle tracker and skeleton code for setting up linked SQE chains."
        }
      ]
    },
    {
      "id": "interactions",
      "title": "Interactions and Data Flow",
      "summary": "Describes the sequence of operations for key use cases: serving a file request and handling a network request/response cycle.",
      "subsections": [
        {
          "id": "interactions-file-flow",
          "title": "Sequence: Serving a File Read",
          "summary": "Step-by-step walkthrough from receiving a request to submitting a read SQE, harvesting the CQE, and sending the data."
        },
        {
          "id": "interactions-network-flow",
          "title": "Sequence: Network Echo Request/Response",
          "summary": "Step-by-step walkthrough from multishot accept, through linked read-process-write chain, to completion."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Systematizes the approach to handling errors from io_uring operations, partial I/O, and resource exhaustion.",
      "subsections": [
        {
          "id": "error-strategies",
          "title": "Error Classification and Recovery Strategies",
          "summary": "Table categorizing errors (Application, Transient, Fatal) and recommended actions (retry, clean up connection, terminate)."
        },
        {
          "id": "error-edge-cases",
          "title": "Specific Edge Cases and Handling",
          "summary": "Covers handling short reads/writes, connection resets during in-flight ops, and `EBUSY` on ring submission."
        }
      ]
    },
    {
      "id": "testing",
      "title": "Testing Strategy and Milestone Checkpoints",
      "summary": "Outlines a verification approach for each milestone, providing concrete commands and expected outputs to confirm progress.",
      "subsections": [
        {
          "id": "testing-strategy",
          "title": "Overall Testing Philosophy",
          "summary": "Advocates for incremental testing, using tools like `strace`, `perf`, and custom benchmarks."
        },
        {
          "id": "testing-milestone1",
          "title": "Milestone 1 Checkpoint: Basic Operations",
          "summary": "Describes how to verify SQ/CQ operations work by writing a simple test that reads/writes to a file descriptor and checks completions."
        },
        {
          "id": "testing-milestone2",
          "title": "Milestone 2 Checkpoint: File Server",
          "summary": "Describes benchmarking the file server against `dd` or a synchronous server, expecting significant throughput improvement under concurrency."
        },
        {
          "id": "testing-milestone3",
          "title": "Milestone 3 Checkpoint: Network Server",
          "summary": "Describes using a load tester (e.g., `wrk`, `ab`) to verify the server can handle thousands of concurrent connections without degradation."
        },
        {
          "id": "testing-milestone4",
          "title": "Milestone 4 Checkpoint: Advanced Features & Benchmarks",
          "summary": "Describes running the provided benchmark suite against an epoll-based server and verifying zero-copy and linked operations function correctly."
        }
      ]
    },
    {
      "id": "debugging",
      "title": "Debugging Guide",
      "summary": "A practical guide for diagnosing common problems during development, organized by symptom.",
      "subsections": [
        {
          "id": "debugging-table",
          "title": "Symptom \u2192 Cause \u2192 Diagnosis \u2192 Fix Table",
          "summary": "Table listing common issues like 'Server hangs', 'High CPU usage', 'Memory corruption', and step-by-step debugging steps."
        },
        {
          "id": "debugging-techniques",
          "title": "io_uring-Specific Debugging Techniques",
          "summary": "Covers using `io_uring_peek_cqe` to inspect completions, adding user_data tags, and interpreting `strace` output for `io_uring_enter` calls."
        }
      ]
    },
    {
      "id": "future",
      "title": "Future Extensions",
      "summary": "Suggests potential enhancements to the project for further learning, building on the established foundation.",
      "subsections": [
        {
          "id": "future-extensions",
          "title": "Possible Enhancements",
          "summary": "Ideas like adding multi-threading with multiple rings, supporting UDP, implementing HTTP/1.1, or adding a simple WAL for durability."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Defines key terms, acronyms, and Linux-specific concepts used throughout the document.",
      "subsections": [
        {
          "id": "glossary-terms",
          "title": "Terms and Definitions",
          "summary": "Table of terms including SQE, CQE, Multishot, Zero-Copy, Fixed Buffers, `io_uring_enter`, and more."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "diagram-component-overview",
      "title": "System Component Overview",
      "description": "Shows the high-level components of the server: the main event loop with the io_uring engine at the center, interacting with the Connection Manager, Buffer Pool, File I/O Handler, and Network I/O Handler. External entities are Clients and the Filesystem.",
      "type": "component",
      "relevant_sections": [
        "high-level"
      ]
    },
    {
      "id": "diagram-data-model",
      "title": "Data Model Relationships",
      "description": "A class diagram showing key structures: `struct io_uring` containing SQ and CQ rings, `struct io_uring_sqe` and `struct io_uring_cqe`. `struct connection_state` linked to multiple `struct io_op_context`, which in turn reference `struct io_buffer`. Show relationships (contains, points-to).",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "diagram-sequence-file-read",
      "title": "Sequence: Async File Read Request",
      "description": "Sequence diagram showing the flow: Client Request -> Server Main Loop -> Submit READ SQE to io_uring (Kernel) -> Kernel performs I/O -> Kernel posts CQE -> Server harvests CQE -> Server processes data -> Server responds to Client.",
      "type": "sequence",
      "relevant_sections": [
        "interactions",
        "component-fileio"
      ]
    },
    {
      "id": "diagram-sequence-network-echo",
      "title": "Sequence: Network Echo with Linked SQEs",
      "description": "Sequence diagram detailing a linked chain: ACCEPT (multishot) -> READ (linked) -> WRITE (linked). Shows SQE submission as a batch, kernel processing, and CQE completions arriving potentially out-of-order but with dependency enforcement.",
      "type": "sequence",
      "relevant_sections": [
        "interactions",
        "component-network",
        "component-advanced"
      ]
    },
    {
      "id": "diagram-state-connection",
      "title": "Connection State Machine",
      "description": "A state machine diagram for a TCP connection. States: ACCEPTING, READING, WRITING, CLOSING, CLOSED. Transitions triggered by events like 'accept_complete', 'data_received', 'write_complete', 'error'.",
      "type": "state-machine",
      "relevant_sections": [
        "component-network"
      ]
    },
    {
      "id": "diagram-flowchart-eventloop",
      "title": "Main Event Loop Flowchart",
      "description": "Flowchart of the core event loop logic: Initialize -> While(running) -> Check for new events (e.g., inbound signals) -> Prepare & Submit SQEs -> Enter kernel (io_uring_enter) -> Harvest CQEs -> For each CQE: find context, handle based on opcode, clean up or resubmit -> Loop.",
      "type": "flowchart",
      "relevant_sections": [
        "component-engine"
      ]
    },
    {
      "id": "diagram-ring-layout",
      "title": "io_uring Ring Memory Layout",
      "description": "Diagram illustrating the shared memory rings: Submission Queue (SQ) ring with head, tail, array, and SQEs. Completion Queue (CQ) ring with head, tail, and CQEs. Show the separation between ring metadata and the actual entry arrays.",
      "type": "component",
      "relevant_sections": [
        "component-engine"
      ]
    }
  ]
}