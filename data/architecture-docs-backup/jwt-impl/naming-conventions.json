{
  "types": {
    "JWTHeader": "alg: str, typ: str",
    "JWTPayload": "iss: str, sub: str, aud: Union[str, List[str]], exp: int, nbf: int, iat: int, jti: str, custom_claims: Dict[str, Any]",
    "ValidationContext": "verify_signature: bool, verify_expiration: bool, verify_not_before: bool, leeway_seconds: int, allowed_issuers: List[str], require_issuer: bool, expected_audience: str, require_audience: bool, required_claims: List[str]",
    "HMACSignerHS256": "HMAC-SHA256 signer class",
    "SecureKeyHandler": "Secure key storage and management",
    "JWTValidationError": "base exception with context",
    "TemporalValidationError": "time-based validation failures",
    "TokenExpiredError": "time-based validation failures",
    "TokenNotYetValidError": "not-before validation failures",
    "IdentityValidationError": "identity claim validation failures",
    "InvalidIssuerError": "issuer validation failures",
    "InvalidAudienceError": "audience validation failures",
    "CustomClaimValidationError": "custom claim validation failures",
    "MissingRequiredClaimError": "missing required claim failures",
    "ClaimsValidator": "Main validation orchestrator",
    "TimeValidator": "Temporal claims validator",
    "IdentityValidator": "Identity claims validator",
    "CustomClaimsValidator": "Custom claims validator",
    "StructuralError": "token format validation failures",
    "MalformedTokenError": "invalid token structure",
    "ErrorSeverity": "CRITICAL, HIGH, MEDIUM, LOW",
    "SecurityContext": "DEVELOPMENT, PRODUCTION, AUDIT",
    "ValidationFailureContext": "component: str, operation: str, failure_type: str, severity: ErrorSeverity, debug_info: Dict[str, Any], safe_message: str",
    "RSASignerRS256": "private_key, padding_config",
    "RSAVerifierRS256": "public_key, padding_config",
    "ECDSASignerES256": "private_key, curve_params",
    "ECDSAVerifierES256": "public_key, curve_params",
    "VerificationCache": "storage: Dict, max_size: int, ttl: int",
    "CachedResult": "payload: JWTPayload, cached_at: float, expires_at: float, context_hash: str",
    "KeyVersion": "kid: str, created_at: datetime, expires_at: datetime, private_key: bytes, public_key: bytes, algorithm: str, status: str",
    "KeyRotationManager": "key_directory: str, rotation_interval: timedelta",
    "JWEEncryptor": "key_encryption_key, content_encryption_algorithm",
    "JWEDecryptor": "key_decryption_key, content_decryption_algorithm",
    "RuleEngine": "rules: List, context: Dict",
    "ClaimEnrichmentPipeline": "enrichers: List, external_services: Dict"
  },
  "methods": {
    "base64url_encode(data: bytes) -> str": "encode bytes to URL-safe Base64 without padding",
    "base64url_decode(data: str) -> bytes": "decode Base64URL back to bytes with padding restoration",
    "encode_token_parts(header: JWTHeader, payload: JWTPayload) -> tuple[str, str]": "encode header and payload sections to Base64URL",
    "utc_now() -> datetime": "Get current UTC time",
    "to_unix_timestamp(dt: datetime) -> int": "Convert datetime to Unix timestamp",
    "is_expired(exp_timestamp: int, leeway: int) -> bool": "Check if timestamp is in the past",
    "is_not_before(nbf_timestamp: int, leeway: int) -> bool": "Check if current time is before nbf",
    "create_token(header: JWTHeader, payload: JWTPayload, secret_key: bytes) -> str": "generate signed JWT token",
    "verify_token(token: str, secret_key: bytes, context: ValidationContext) -> JWTPayload": "verify JWT token and return payload if valid",
    "serialize_header(header: JWTHeader) -> str": "serialize JWT header to JSON",
    "serialize_payload(payload: JWTPayload) -> str": "serialize JWT payload to JSON",
    "create_signing_input(encoded_header: str, encoded_payload: str) -> str": "create signing input string",
    "assemble_token(encoded_header: str, encoded_payload: str, signature: str) -> str": "assemble final JWT token",
    "sign(signing_input: str) -> str": "generate RSA signature for JWT",
    "verify(signing_input: str, provided_signature: str) -> bool": "verify RSA signature against input",
    "validate_key_strength(key: bytes) -> None": "validate key meets security requirements",
    "generate_secure_key() -> bytes": "generate 32-byte random key",
    "constant_time_compare(a: Union[bytes, str], b: Union[bytes, str]) -> bool": "timing-safe comparison",
    "validate_claims(payload_dict: Dict[str, Any]) -> JWTPayload": "Main claims validation entry point",
    "validate_temporal_claims(payload_dict: Dict[str, Any]) -> None": "Validate time-based claims",
    "validate_identity_claims(payload_dict: Dict[str, Any]) -> None": "Validate identity claims",
    "create_strict_context(allowed_issuers: List[str], expected_audience: str) -> ValidationContext": "Create strict validation context",
    "create_permissive_context() -> ValidationContext": "Create permissive validation context",
    "create_custom_context(**kwargs) -> ValidationContext": "Create custom validation context",
    "parse_token_structure(token: str) -> Tuple[str, str, str]": "parse JWT structure into three parts",
    "parse_token_structure(token: str) -> tuple[str, str, str]": "parse JWT structure into three parts",
    "validate_base64url_format(data: str, part_name: str) -> None": "validate Base64URL character set",
    "handle_cryptographic_error(error: Exception, operation: str) -> JWTValidationError": "convert crypto errors to JWT errors",
    "validate_temporal_bounds(timestamp: int, claim_name: str, leeway_seconds: int) -> None": "validate timestamp ranges",
    "constant_time_compare(a: bytes, b: bytes) -> bool": "timing-safe comparison",
    "log_validation_failure(context: ValidationFailureContext)": "security-aware error logging",
    "get_safe_message() -> str": "external-safe error message",
    "get_debug_info() -> Dict[str, Any]": "internal diagnostic information",
    "get_cache_key(token: str, context: ValidationContext) -> str": "generate composite cache key",
    "get(cache_key: str) -> Optional[CachedResult]": "retrieve cached verification result",
    "put(cache_key: str, payload: JWTPayload, context: ValidationContext) -> None": "store verification result in cache",
    "generate_new_key(algorithm: str) -> KeyVersion": "create new key pair with metadata",
    "initiate_rotation() -> KeyVersion": "begin key rotation process",
    "get_signing_key() -> KeyVersion": "retrieve current active signing key",
    "get_verification_keys() -> List[KeyVersion]": "get all valid verification keys"
  },
  "constants": {
    "DEFAULT_LEEWAY_SECONDS": "300 seconds clock skew tolerance",
    "HS256": "HMAC-SHA256 algorithm identifier",
    "JWT": "Standard token type identifier",
    "MIN_KEY_LENGTH": "32 bytes minimum for security",
    "HMAC_SHA256_LENGTH": "32 bytes signature length",
    "DEFAULT_MAX_TOKEN_AGE": "86400 seconds maximum token age",
    "RS256": "RSA-SHA256 algorithm identifier",
    "ES256": "ECDSA-P256-SHA256 algorithm identifier",
    "DEFAULT_CACHE_TTL": "300 seconds default cache time-to-live",
    "MIN_RSA_KEY_SIZE": "2048 bits minimum RSA key size",
    "DEFAULT_ROTATION_INTERVAL": "90 days default key rotation period",
    "CACHE_MAX_SIZE": "1000 entries maximum cache size"
  },
  "terms": {
    "stateless authentication": "authentication without server-side session storage",
    "Base64URL encoding": "URL-safe Base64 variant without padding characters",
    "claims": "statements about an entity contained in JWT payload",
    "signature verification": "cryptographic validation of token authenticity",
    "clock skew": "time difference between servers affecting validation",
    "timing attack": "cryptographic attack exploiting execution time differences",
    "algorithm confusion attack": "attack exploiting JWT algorithm flexibility to use wrong verification method",
    "JSON serialization": "converting structured data to JSON text format",
    "token assembly": "combining encoded parts into final JWT format",
    "signing input": "header.payload string used for signature computation",
    "constant-time comparison": "comparison preventing timing side channels",
    "secret key handling": "secure management of cryptographic keys",
    "HMAC-SHA256": "keyed hash algorithm for authentication",
    "temporal validation": "time-based claims checking",
    "identity validation": "issuer and audience verification",
    "custom claims processing": "application-specific claim validation",
    "fail-fast validation": "immediate rejection on first validation failure",
    "leeway period": "clock skew tolerance window",
    "allowlist validation": "exact string matching against approved values",
    "component coordination": "orchestrating data flow between library components",
    "error propagation": "passing error context through component hierarchy",
    "self-verification": "validating created tokens before returning them",
    "error classification": "organizing failures by type and severity",
    "security context": "deployment environment affecting error detail level",
    "temporal edge cases": "time-related validation complications",
    "malformed token handling": "structural validation and error recovery",
    "cryptographic error handling": "secure handling of signature failures",
    "validation failure context": "structured error information",
    "information disclosure": "unintended revelation of sensitive details through errors",
    "security-aware logging": "logging that adapts detail level to security context",
    "claims validation": "verification of JWT payload statements",
    "test vectors": "known-good inputs and outputs for validation",
    "end-to-end scenarios": "complete workflows from token creation through validation",
    "security test scenarios": "tests for timing attacks and other vulnerabilities",
    "reference test vectors": "official specification test cases",
    "milestone verification points": "concrete checkpoints for each development stage",
    "asymmetric cryptography": "public-private key cryptography enabling distributed verification",
    "key rotation": "periodic replacement of cryptographic keys for security",
    "JWE": "JSON Web Encryption providing confidentiality for JWT content",
    "nested tokens": "JWT tokens encrypted within JWE for both authenticity and confidentiality",
    "cache invalidation": "removal of stale cache entries based on time or security events",
    "key distribution": "secure delivery of cryptographic keys to verification services",
    "graceful transition": "smooth key rotation without service disruption",
    "rule-based validation": "configurable claim validation using custom business logic",
    "claim enrichment": "augmenting token claims with external data during validation",
    "JSON Web Token": "compact URL-safe token format for representing claims",
    "verification cache": "storage mechanism for caching successful token verification results"
  }
}