{
  "types": {
    "NodeID": "uint64",
    "NodeState": "int enum",
    "MessageType": "int enum",
    "Node": "ID NodeID, Address string, State NodeState",
    "Transport": "interface for inter-node communication",
    "Message": "Type MessageType, From NodeID, To NodeID, Payload []byte, Term uint64, Timestamp int64",
    "ElectionCoordinator": "nodeID NodeID, currentState *ElectionState, transport Transport",
    "BullyElection": "nodeID NodeID, transport Transport, membership *ClusterMembership, state *ElectionState, timeout *ElectionTimeoutManager",
    "RingElection": "nodeID NodeID, transport Transport, membership *ClusterMembership, topology *RingTopology, state *ElectionState",
    "RingToken": "ElectionID uint64, InitiatorID NodeID, Participants []NodeID, Complete bool, Term uint64, Timestamp int64",
    "HTTPTransport": "HTTP implementation of Transport",
    "ElectionMessage": "ElectionID uint64, CandidateID NodeID, Term uint64",
    "OKMessage": "ElectionID uint64, ResponderID NodeID",
    "CoordinatorMessage": "LeaderID NodeID, Term uint64, ElectionID uint64",
    "HeartbeatMessage": "LeaderID NodeID, Term uint64, Timestamp int64",
    "ClusterMembership": "nodes map[NodeID]Node, activeMembers []NodeID",
    "MessageBuilder": "helper for constructing messages",
    "FailureDetector": "transport Transport, membership *ClusterMembership, heartbeatInterval time.Duration",
    "ElectionState": "currentState NodeState, currentLeader NodeID, currentTerm uint64, activeElectionID uint64",
    "ElectionTimeoutManager": "timeout time.Duration, timer *time.Timer, cancelFunc context.CancelFunc",
    "RingTopology": "mu sync.RWMutex, nodeID NodeID, successorMap map[NodeID]NodeID, ringSequence []NodeID, membership *ClusterMembership, ringVersion uint64, lastUpdate time.Time",
    "ElectionTrigger": "Type TriggerType, NodeID NodeID, Timestamp int64, Context map[string]interface{}",
    "MessageSequencer": "nodeID NodeID, transport Transport, incomingQueue chan *Message, processingQueue chan *Message, sequenceNumbers map[NodeID]uint64, timeouts map[string]*time.Timer",
    "LeadershipManager": "nodeID NodeID, transport Transport, membership *ClusterMembership, heartbeatTicker *time.Ticker, membershipVersion uint64, isLeader bool, currentTerm uint64",
    "ElectionScenarioTest": "nodes map[NodeID]*ElectionCoordinator, transport *TestTransport, timeline *TestTimeline, partitions map[NodeID][]NodeID",
    "AdaptiveTimeoutManager": "baseTimeout time.Duration, minTimeout time.Duration, maxTimeout time.Duration, currentTimeout time.Duration, recentElections []ElectionRecord, recentRTTs []time.Duration, networkLatency time.Duration, successThreshold float64, adjustmentFactor float64, windowSize int",
    "QuorumChecker": "originalClusterSize int, quorumSize int, membership *ClusterMembership",
    "CascadeDetector": "recentFailures []FailureEvent, windowDuration time.Duration, cascadeThreshold int",
    "NetworkPartitioner": "partitions map[NodeID][]NodeID, isPartitioned bool",
    "ElectionRecord": "StartTime time.Time, CompletionTime time.Time, Success bool, NetworkLatency time.Duration, ParticipantCount int",
    "FailureEvent": "NodeID NodeID, Timestamp time.Time, FailureType string",
    "TestTransport": "nodeID NodeID, messageQueue chan *Message, deliveryRules map[string]DeliveryRule, networkState *NetworkState, faultInjector *FaultInjector",
    "DeliveryRule": "Delay time.Duration, DropRate float64, Duplicate bool, Reorder bool",
    "NetworkState": "partitions map[NodeID][]NodeID, failures map[NodeID]bool",
    "FaultInjector": "dropRate float64, delayRange time.Duration, partitions map[NodeID][]NodeID",
    "TestCluster": "nodes map[NodeID]*ElectionCoordinator, transports map[NodeID]*TestTransport, networkSim *NetworkSimulator, timeline *TestTimeline",
    "TestClusterConfig": "NodeCount int, InitialLeaderID NodeID, HeartbeatInterval time.Duration, ElectionTimeout time.Duration, FailureDetectionTimeout time.Duration",
    "FaultScenario": "Name string, Description string, Setup func(*TestCluster) error, Trigger func(*TestCluster) error, Validation func(*TestCluster) error, Cleanup func(*TestCluster) error",
    "ElectionLogger": "logger *slog.Logger, nodeID NodeID",
    "NodeStateSnapshot": "NodeID NodeID, Timestamp int64, ElectionState *ElectionState",
    "DebugStateCollector": "snapshots map[NodeID]*NodeStateSnapshot, mu sync.RWMutex",
    "MessageTrace": "ElectionID uint64, MessageType MessageType, Source NodeID, Target NodeID",
    "ElectionFlowTracer": "traces map[uint64][]*MessageTrace, mu sync.RWMutex",
    "MessageBatcher": "messages []Message, batchWindow time.Duration, batchSize int",
    "ConcurrentElectionResolver": "activeElections map[uint64]*ElectionState, priorities map[uint64]int",
    "RaftElection": "nodeID NodeID, transport Transport, membership *ClusterMembership, currentTerm uint64, votedFor NodeID, state NodeState, electionTimeout time.Duration, heartbeatTimeout time.Duration, votesReceived map[uint64]map[NodeID]bool",
    "MetricsCollector": "nodeID NodeID, electionDuration prometheus.Histogram, electionSuccess prometheus.Counter, electionFailures prometheus.CounterVec, activeElections map[uint64]*ElectionMetrics",
    "ElectionMetrics": "ElectionID uint64, StartTime time.Time, Algorithm string, TriggerReason string, Participants []NodeID, MessagesSent int, MessagesReceived int, NetworkBytes int64",
    "ConfigurationManager": "config *ElectionConfig, configVersion uint64, lastUpdated time.Time, subscribers []ConfigSubscriber",
    "ElectionConfig": "HeartbeatInterval time.Duration, FailureDetectionTimeout time.Duration, ElectionTimeout time.Duration, PreferredAlgorithm string",
    "RequestVoteMessage": "Term uint64, CandidateID NodeID, LastLogIndex uint64",
    "RequestVoteResponse": "Term uint64, VoteGranted bool",
    "TriggerType": "int enum",
    "TermDefinition": "Term string, Definition string, Context string, Aliases []string, Related []string, Examples []string",
    "GlossaryManager": "definitions map[string]*TermDefinition, categories map[string][]string, mu sync.RWMutex"
  },
  "methods": {
    "StartElection() error": "initiates new leader election",
    "HandleMessage(msg Message) error": "processes incoming election messages",
    "GetCurrentLeader() NodeID": "returns current leader ID",
    "IsLeader() bool": "checks if this node is leader",
    "SendMessage(target NodeID, msg Message) error": "sends message to specific node",
    "BroadcastMessage(msg Message) error": "sends message to all nodes",
    "ReceiveMessages() <-chan Message": "returns incoming message channel",
    "findNextLiveNode(startPos int) (NodeID, error)": "locates next reachable ring node",
    "UpdateMembership(nodes []Node) error": "bulk update cluster members",
    "GetActiveMembers() []Node": "returns currently alive nodes",
    "MarkNodeSeen(nodeID NodeID)": "updates last seen timestamp",
    "IncreaseSuspicion(nodeID NodeID) int": "increments failure suspicion",
    "BuildElectionMessage(to NodeID, electionID uint64, term uint64) (*Message, error)": "creates election message",
    "BuildCoordinatorMessage(leaderID NodeID, term uint64, electionID uint64) (*Message, error)": "creates coordinator announcement",
    "SendMessage(target NodeID, msg *Message) error": "sends message to specific node with controlled delivery",
    "BroadcastMessage(msg *Message) error": "sends message to all nodes with fault injection",
    "ReceiveMessages() <-chan *Message": "returns incoming message channel",
    "HandleMessage(msg *Message) error": "processes incoming election messages",
    "StartHeartbeats()": "begin periodic failure detection",
    "CheckForFailures() []NodeID": "identify failed nodes",
    "TransitionTo(newState NodeState, leaderID NodeID, term uint64)": "safely changes node state",
    "StartTimeout(callback func())": "begins election timeout with callback",
    "CancelTimeout()": "stops current election timeout",
    "findNextLiveNode(startID NodeID, transport Transport) (NodeID, error)": "locates next reachable node starting from given position",
    "RebuildRing() error": "reconstructs ring topology from current membership",
    "GetSuccessor(nodeID NodeID) (NodeID, bool)": "returns immediate successor for given node",
    "selectLeaderFromParticipants(participants []NodeID) NodeID": "determines leader from collected participant IDs",
    "forwardToken(token *RingToken, successorID NodeID) error": "sends ring token to next live node in sequence",
    "generateElectionID() uint64": "creates unique identifier for new election",
    "testNodeConnectivity(nodeID NodeID, transport Transport) bool": "checks if node is reachable",
    "StartElectionCoordinator() error": "initializes and starts the complete election system",
    "ProcessElectionTrigger(trigger ElectionTrigger) error": "handles different trigger scenarios and initiates appropriate elections",
    "SequenceElectionMessages(algorithm string, electionID uint64) error": "coordinates the complete message flow for an election",
    "ProcessIncomingMessage(msg *Message) error": "handles message ordering and delivers to appropriate handlers",
    "AssumeLeadership(term uint64, electionID uint64) error": "transitions this node to leader and begins leader duties",
    "StepDown(reason string) error": "gracefully transitions away from leadership",
    "SendHeartbeat() error": "broadcasts leader aliveness to all cluster members",
    "GetCurrentTimeout() time.Duration": "returns dynamically calculated timeout based on network conditions",
    "RecordFailure()": "tracks failure for timeout adaptation",
    "ValidateLeadershipClaim(candidateID NodeID, supporters []NodeID) bool": "validates leadership against quorum requirements",
    "CanElectLeader() bool": "checks if current partition can safely elect leader",
    "DetectCascade() bool": "identifies cascading failure patterns",
    "CreatePartition(groups [][]NodeID) error": "simulates network partition for testing",
    "IsReachable(source, target NodeID) bool": "checks connectivity during partition simulation",
    "StartCluster() error": "initializes and starts all test nodes",
    "SimulateFailure(nodeID NodeID) error": "stops specific node and triggers failure detection",
    "WaitForElection(timeout time.Duration) (NodeID, error)": "waits for election completion and returns winner",
    "ValidateMilestone1Messaging(*TestCluster) error": "verifies node communication milestone requirements",
    "ValidateMilestone2BullyElection(*TestCluster) error": "verifies bully algorithm milestone requirements",
    "ValidateMilestone3RingElection(*TestCluster) error": "verifies ring election milestone requirements",
    "LogElectionStarted(electionID uint64, term uint64, trigger string)": "records election initiation with structured fields",
    "LogMessageSent(msgType MessageType, target NodeID, electionID uint64)": "records outgoing election message",
    "LogStateTransition(oldState, newState NodeState, term uint64, reason string)": "records node state changes",
    "CaptureSnapshot(coordinator *ElectionCoordinator)": "records current node state",
    "CompareStates() map[string][]string": "identifies inconsistencies between node states",
    "TraceMessageSent(electionID uint64, msgType MessageType, source, target NodeID)": "records outgoing message",
    "AnalyzeElectionFlow(electionID uint64) []string": "identifies problems in message sequences",
    "EnableMessageDrop(rate float64)": "configures message loss simulation",
    "CreateNetworkPartition(groups [][]NodeID)": "simulates cluster split",
    "ShouldDropMessage(source, target NodeID) bool": "determines if message should be lost",
    "RecordElectionResult(record ElectionRecord)": "updates timeout calculations based on election outcome",
    "RecordNetworkRTT(rtt time.Duration)": "updates network latency estimates from ping data",
    "StartRaftElection() error": "initiates Raft election with term increment and vote requests",
    "HandleRequestVote(msg *RequestVoteMessage) (*RequestVoteResponse, error)": "processes vote requests from candidates",
    "CollectVotes(term uint64) (bool, error)": "counts votes and checks for majority",
    "RecordElectionStarted(electionID uint64, algorithm, trigger string)": "begins tracking metrics for new election",
    "RecordElectionCompleted(electionID uint64, success bool, winner NodeID)": "finalizes election metrics",
    "ApplyConfigurationUpdate(newConfig *ElectionConfig) error": "validates and applies configuration changes",
    "ValidateConfiguration(config *ElectionConfig) []string": "checks configuration safety and consistency"
  },
  "constants": {
    "StateFollower": "0 - following current leader",
    "StateCandidate": "1 - participating in election",
    "StateLeader": "2 - serving as cluster leader",
    "MsgElection": "1 - bully algorithm election",
    "MsgOK": "2 - bully acknowledgment",
    "MsgCoordinator": "3 - leader announcement",
    "MsgHeartbeat": "4 - failure detection heartbeat",
    "MsgRingToken": "5 - ring election token",
    "TriggerLeaderFailure": "0 - leader failure detection trigger",
    "TriggerStartup": "1 - cluster bootstrap trigger",
    "TriggerPartitionHealing": "2 - partition recovery trigger",
    "TriggerManualElection": "3 - administrative trigger",
    "TriggerTermConflict": "4 - term conflict trigger",
    "RAFT_ALGORITHM": "raft leader election protocol",
    "SWIM_ALGORITHM": "SWIM failure detection protocol",
    "WEIGHTED_ALGORITHM": "capability-based weighted election"
  },
  "terms": {
    "leader election": "process of selecting coordinator node",
    "split-brain": "scenario with multiple simultaneous leaders",
    "bully algorithm": "election where highest-ID node wins through competitive messaging",
    "ring election": "token-passing election around logical ring",
    "failure detection": "identifying crashed or unreachable nodes",
    "network partition": "cluster split into isolated groups",
    "election term": "monotonically increasing epoch counter",
    "quorum": "minimum nodes needed for valid election",
    "membership": "view of which nodes are alive and participating",
    "heartbeat": "periodic alive signal between nodes",
    "suspicion level": "graduated failure detection counter",
    "broadcast": "message delivery to all active members",
    "point-to-point": "message delivery between specific nodes",
    "cluster membership": "view of alive participating nodes",
    "cascade election": "sequential election attempts when higher-ID nodes fail during election",
    "coordinator announcement": "broadcast declaring new leader",
    "election timeout": "deadline for higher-ID node responses",
    "state transition": "change from follower to candidate to leader",
    "concurrent election": "multiple simultaneous election initiations",
    "logical ring topology": "circular ordering of nodes by ID",
    "election token": "message containing participant list",
    "token circulation": "passing token through ring nodes",
    "ring repair": "mechanism to skip failed nodes",
    "successor mapping": "next node relationships in ring",
    "partition healing": "restoring connectivity between segments",
    "ring completion detection": "identifying when token has traversed full ring",
    "leader selection": "deterministic choice of highest-ID node from participants",
    "token forwarding": "passing election token to next live ring node",
    "election trigger": "event that initiates new leader elections",
    "message sequence pattern": "temporal choreography of election message flows",
    "heartbeat maintenance": "periodic leader aliveness signaling",
    "leadership transition": "change from one leader to another",
    "election storm": "overlapping elections preventing convergence",
    "split-brain prevention": "ensuring single leader during partition healing",
    "bootstrap election": "initial leader selection in empty cluster",
    "concurrent election resolution": "strategies to minimize interference between simultaneous elections",
    "graceful step-down": "voluntary leadership transition with state transfer",
    "cascading failure": "sequential failures triggered by recovery",
    "graduated suspicion": "incremental failure detection",
    "adaptive timeouts": "dynamic timeout adjustment",
    "term-based resolution": "using election terms to resolve leadership conflicts",
    "component-level testing": "testing individual components in isolation",
    "multi-node scenarios": "testing complete election flows",
    "fault injection testing": "introducing controlled failures",
    "milestone validation checkpoints": "concrete behavioral tests that demonstrate milestone completion",
    "test transport": "controllable transport implementation for testing",
    "network partition simulation": "creating controlled network splits that isolate nodes",
    "message loss injection": "controlled dropping of messages during testing",
    "cascading failure testing": "validating system behavior when failures trigger additional failures",
    "election flow validation": "verifying complete election sequences produce correct results",
    "timeout manipulation": "controlled modification of timeout values for testing",
    "chaos testing": "systematic fault injection for resilience",
    "state correlation": "comparing node states across cluster for inconsistencies",
    "message flow analysis": "tracing election messages chronologically through cluster",
    "fault injection": "deliberately introducing failures during testing",
    "structured logging": "consistent log format with correlation IDs",
    "distributed tracing": "tracking elections across nodes",
    "adaptive timeout management": "dynamic adjustment of timeouts based on observed network behavior",
    "message batching": "aggregating multiple messages into single transmissions",
    "Raft leader election": "consensus algorithm election requiring majority votes",
    "SWIM failure detection": "scalable gossip-based membership and failure detection",
    "weighted election algorithms": "elections considering node capabilities and reliability",
    "Byzantine fault tolerance": "handling arbitrary or malicious node behavior",
    "dynamic configuration management": "runtime parameter updates without service restart",
    "chaos engineering": "systematic fault injection to validate system resilience"
  }
}