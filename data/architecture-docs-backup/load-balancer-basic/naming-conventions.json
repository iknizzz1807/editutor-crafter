{
  "types": {
    "Config": "fields: Port int, Backends []BackendConfig, Algorithm string, HealthCheck HealthCheckConfig, Proxy ProxyConfig, Logging LoggingConfig",
    "BackendConfig": "fields: URL string, Weight int, MaxConnections int, ConnectTimeout time.Duration, ResponseTimeout time.Duration, Enabled bool",
    "HealthCheckConfig": "fields: Enabled bool, Interval time.Duration, Timeout time.Duration, HealthyThreshold int, UnhealthyThreshold int, Path string, ExpectedStatus int, UserAgent string",
    "Backend": "fields: ID string, URL *url.URL, Weight int, ActiveConnections *int64, HealthState *HealthState, CreatedAt time.Time, LastUsed *time.Time, Metadata map[string]interface{}",
    "Algorithm": "interface with SelectBackend method",
    "HealthResult": "fields: Backend *Backend, Healthy bool",
    "ReverseProxy": "main HTTP reverse proxy component",
    "BackendManager": "manages pool of backend servers",
    "HealthChecker": "main health checking component",
    "HealthState": "fields: Healthy bool, ConsecutiveSuccesses int, ConsecutiveFailures int, LastCheckTime time.Time, LastSuccessTime time.Time, LastFailureTime time.Time, LastError string",
    "HealthStateChange": "fields: Timestamp time.Time, PreviousState bool, NewState bool, Reason string, CheckCount int",
    "ProxyConfig": "fields: ReadTimeout time.Duration, WriteTimeout time.Duration, IdleTimeout time.Duration, MaxHeaderBytes int",
    "LoggingConfig": "fields: Level string, Format string, Output string",
    "RoundRobin": "fields: counter int64",
    "WeightedRoundRobin": "fields: currentWeights map[string]int, mutex sync.RWMutex",
    "LeastConnections": "fields: connectionCounts map[string]*int64",
    "IPHash": "fields: hashSeed uint64",
    "Random": "fields: rng *rand.Rand, rngMutex sync.Mutex",
    "Manager": "backend pool manager",
    "HTTPProber": "performs HTTP-based health check requests",
    "ProbeResult": "fields: Backend *Backend, Healthy bool, StatusCode int, Duration time.Duration, Error error, Timestamp time.Time",
    "RequestContext": "fields: RequestID string, StartTime time.Time, ClientIP string, OriginalURL string, SelectedBackend *Backend, Stage string, Metrics map[string]interface{}",
    "ErrorResponse": "fields: Status int, Message string, RequestID string, Headers map[string]string",
    "RequestRouter": "fields: proxy *ReverseProxy, backendManager *Manager, healthChecker *HealthChecker, totalRequests int64, successRequests int64, errorRequests int64",
    "PipelineStage": "func(*RequestContext, http.ResponseWriter, *http.Request) error",
    "FileWatcher": "monitors configuration files for changes",
    "HotReloadManager": "coordinates configuration updates across components",
    "ConfigurableComponent": "interface for components that can be reconfigured",
    "ErrorType": "string enum for error classification",
    "ErrorClassifier": "fields: mu sync.RWMutex, classificationRules map[string]ErrorType",
    "CircuitState": "int32 enum for circuit breaker states",
    "CircuitBreaker": "fields: mu sync.RWMutex, state int32, failureCount int64, requestCount int64, lastFailureTime time.Time, lastStateChange time.Time, failureThreshold int64, timeout time.Duration, maxRequests int64",
    "ErrorHandler": "fields: classifier *ErrorClassifier, circuitBreakers map[string]*CircuitBreaker, degradationLevel int32, metrics *MetricsCollector, mu sync.RWMutex",
    "TestBackend": "test server for integration testing",
    "TestServer": "individual test backend server",
    "TestServerPool": "collection of test servers for integration testing",
    "RequestInfo": "tracks request details for test validation",
    "DebugLogger": "fields: logger *slog.Logger, level slog.Level",
    "MetricsCollector": "fields: TotalRequests int64, SuccessfulRequests int64, FailedRequests int64, BackendSelections map[string]int64, ResponseTimes []time.Duration, ConnectionPoolSize int64, ActiveConnections int64",
    "DiagnosticTest": "fields: LoadBalancerURL string, BackendURLs []string, Logger *DebugLogger, Metrics *MetricsCollector",
    "TLSConfig": "fields: Enabled bool, CertificatesPath string, PrivateKeyPath string, CipherSuites []uint16, MinTLSVersion uint16, MaxTLSVersion uint16, ClientAuth tls.ClientAuthType, Certificates []CertificateConfig, ACME ACMEConfig, OCSP OCSPConfig",
    "CertificateConfig": "fields: Domain string, CertificatePath string, PrivateKeyPath string, ExpirationTime time.Time, AutoRenew bool, Backends []string",
    "RoutingConfig": "fields: Rules []RoutingRule, DefaultPool string, FailureHandling string, RuleEvaluation RuleEvalConfig",
    "RoutingRule": "fields: ID string, Priority int, Conditions []RuleCondition, Actions []RuleAction, Enabled bool, Description string, CreatedAt time.Time, Statistics RuleStats",
    "RuleCondition": "fields: Type string, Field string, Operator string, Value string, CaseSensitive bool, Negate bool",
    "MetricsConfig": "fields: Enabled bool, CollectionInterval time.Duration, RetentionPeriod time.Duration, Exporters []ExporterConfig, Histograms HistogramConfig, Alerting AlertingConfig, CustomMetrics []CustomMetricConfig",
    "LoadBalancerMetrics": "fields: TotalRequests int64, SuccessfulRequests int64, FailedRequests int64, RequestRate float64, ErrorRate float64, ResponseTime ResponseTimeMetrics, BackendMetrics map[string]BackendMetrics, AlgorithmMetrics AlgorithmMetrics, HealthCheckMetrics HealthCheckMetrics, ConnectionMetrics ConnectionMetrics",
    "TLSProxy": "SSL-terminating proxy wrapper",
    "RoutingEngine": "evaluates routing rules for backend pool selection",
    "ExtendedConfig": "configuration with extension support",
    "CertificateStore": "manages SSL certificates",
    "RequestMatcher": "evaluates routing rule conditions",
    "BackendPool": "groups backends for routing rules"
  },
  "methods": {
    "LoadConfig(filename string) (*Config, error)": "loads and validates configuration from file",
    "Validate() error": "validates configuration values",
    "SelectBackend(backends []*Backend) *Backend": "chooses backend using algorithm logic",
    "Name() string": "returns algorithm identifier",
    "AddBackend(config BackendConfig) error": "adds backend to pool",
    "GetHealthyBackends() []*Backend": "returns currently healthy backends",
    "UpdateBackendHealth(*Backend, bool) error": "updates backend health status",
    "NewBackend(config BackendConfig) (*Backend, error)": "creates new backend from configuration",
    "IncrementConnections() int64": "atomically increments active connection count",
    "DecrementConnections() int64": "atomically decrements active connection count",
    "GetActiveConnections() int64": "reads current connection count",
    "IsHealthy() bool": "returns current health status",
    "UpdateHealthState(*HealthState)": "atomically updates health state",
    "RecordSuccess(time.Time) bool": "records successful health check",
    "RecordFailure(time.Time, string) bool": "records failed health check",
    "LoadConfig(string) (*Config, error)": "loads configuration from file",
    "NewReverseProxy(backends []string, timeout time.Duration) *ReverseProxy": "creates new reverse proxy instance",
    "ServeHTTP(w http.ResponseWriter, r *http.Request)": "handles incoming HTTP requests through integrated processing pipeline",
    "selectBackend() string": "implements round-robin backend selection",
    "copyHeaders(dst, src http.Header)": "copies HTTP headers between requests",
    "addForwardingHeaders(req *http.Request, originalReq *http.Request)": "adds X-Forwarded-* headers",
    "isConnectionError(err error) bool": "classifies connection-related errors",
    "Reset() error": "clears algorithm state",
    "GetStats() map[string]interface{}": "returns health statistics",
    "SwitchAlgorithm(name string) error": "changes active algorithm",
    "IncrementConnections(backendID string) int64": "atomically increments connection count",
    "DecrementConnections(backendID string) int64": "atomically decrements connection count",
    "NewHealthChecker(config HealthCheckConfig) *HealthChecker": "creates health checker instance",
    "AddBackend(backend *Backend) error": "registers backend for health monitoring",
    "RemoveBackend(backendID string) error": "stops monitoring specified backend",
    "Start(ctx context.Context) error": "begins periodic health checking",
    "Stop()": "gracefully shuts down health checking",
    "ProbeBackend(ctx context.Context, backend *Backend) ProbeResult": "performs single health check probe",
    "RecordSuccess(timestamp time.Time) bool": "processes successful probe result",
    "RecordFailure(timestamp time.Time, errorMsg string) bool": "processes failed probe result",
    "NewRequestRouter(proxy *ReverseProxy, backends *Manager, health *HealthChecker) *RequestRouter": "creates new request router with integrated components",
    "NewRequestContext(r *http.Request) *RequestContext": "creates new request context with correlation ID",
    "WriteErrorResponse(w http.ResponseWriter, err ErrorResponse)": "writes standardized error response to client",
    "processRequest(ctx *RequestContext, w http.ResponseWriter, r *http.Request) error": "executes main request processing pipeline",
    "selectBackend(ctx *RequestContext) (*Backend, error)": "chooses appropriate backend server for request",
    "enhanceRequest(ctx *RequestContext, r *http.Request, backend *Backend) *http.Request": "adds proxy headers and modifies request for backend forwarding",
    "handleRequestError(ctx *RequestContext, w http.ResponseWriter, err error)": "generates appropriate error responses based on failure type",
    "updateMetrics(ctx *RequestContext, success bool, statusCode int)": "records request metrics for monitoring",
    "ApplyDefaults()": "fills in default values for missing configuration",
    "UpdateConfiguration(*Config) error": "updates component with new configuration",
    "RollbackConfiguration(*Config) error": "reverts to previous configuration",
    "ApplyConfiguration(newConfig *Config) error": "attempts to update all components",
    "RegisterComponent(component ConfigurableComponent)": "adds component to receive updates",
    "ClassifyError(error) ErrorType": "determines appropriate error type from error instance",
    "Allow() bool": "checks if circuit breaker allows request through",
    "RecordSuccess()": "records successful request in circuit breaker",
    "RecordFailure()": "records failed request in circuit breaker",
    "HandleError(context.Context, error, *Backend) *ErrorResponse": "processes errors and generates appropriate responses",
    "CheckCircuitBreaker(string) bool": "verifies if requests to backend should be allowed",
    "RecordResult(string, bool, time.Duration)": "updates circuit breaker state based on request outcome",
    "DetermineGracefulDegradation(int, int) int": "calculates appropriate system degradation level",
    "GenerateErrorResponse(ErrorType, string, string) *ErrorResponse": "creates HTTP error response for clients",
    "Start() error": "begins periodic health checking",
    "NewTestServerPool(t *testing.T, count int, startPort int) *TestServerPool": "creates pool of test backend servers",
    "handleRequest(w http.ResponseWriter, r *http.Request)": "processes test requests and tracks statistics",
    "handleHealth(w http.ResponseWriter, r *http.Request)": "provides health check endpoint for testing",
    "NewDebugLogger(level string) *DebugLogger": "creates a configured logger instance",
    "LogRequest(ctx context.Context, event string, attrs map[string]interface{})": "records request processing events with correlation",
    "LogBackendHealth(backend string, healthy bool, reason string)": "records backend health state changes",
    "LogAlgorithmSelection(algorithm string, backend string, counter int64)": "records load balancing algorithm decisions",
    "NewMetricsCollector() *MetricsCollector": "creates new metrics collector instance",
    "RecordRequest(success bool, duration time.Duration)": "increments request counters based on success",
    "RecordBackendSelection(backend string)": "tracks which backends are being selected",
    "GetDistributionStats() map[string]interface{}": "returns request distribution statistics",
    "NewDiagnosticTest(lbURL string, backends []string) *DiagnosticTest": "creates a diagnostic test instance",
    "TestConnectivity(ctx context.Context) error": "verifies basic connectivity to load balancer and backends",
    "TestRequestDistribution(ctx context.Context, requestCount int) error": "validates load balancing algorithm behavior",
    "TestHealthCheckBehavior(ctx context.Context) error": "validates health checking and failover",
    "RunConcurrentLoad(ctx context.Context, goroutines int, duration time.Duration) error": "generates concurrent load to expose race conditions",
    "RecordRequest(success bool, duration time.Duration, backendID string)": "records request metrics with timing and outcome",
    "GetCurrentStats() LoadBalancerMetrics": "returns snapshot of current metrics",
    "NewTLSProxy(proxy *ReverseProxy, config *TLSConfig) (*TLSProxy, error)": "creates SSL-terminating proxy wrapper",
    "ServeHTTPS(addr string) error": "starts HTTPS server with SSL termination",
    "EvaluateRouting(req *http.Request) (string, error)": "determines backend pool based on routing rules",
    "AddRoutingRule(rule RoutingRule) error": "adds new routing rule with validation"
  },
  "constants": {
    "Layer_4": "transport layer load balancing",
    "Layer_7": "application layer load balancing",
    "round_robin": "sequential backend selection algorithm",
    "least_connections": "selects backend with fewest connections",
    "weighted_round_robin": "proportional distribution based on weights",
    "ip_hash": "consistent client-to-backend mapping",
    "random": "random backend selection",
    "DefaultInterval": "30 seconds for health checks",
    "DefaultTimeout": "5 seconds for health check timeout",
    "DefaultHealthyThreshold": "2 consecutive successes",
    "DefaultUnhealthyThreshold": "3 consecutive failures",
    "DefaultPath": "/health endpoint",
    "DefaultExpectedStatus": "200 OK status",
    "ErrorTypeConnection": "connection-related errors",
    "ErrorTypeTimeout": "timeout-related errors",
    "ErrorTypeDNS": "DNS resolution errors",
    "ErrorTypeBackend": "backend server errors",
    "ErrorTypeInternal": "load balancer internal errors",
    "ErrorTypeCapacity": "capacity/resource exhaustion errors",
    "CircuitClosed": "normal operation state",
    "CircuitOpen": "failing fast state",
    "CircuitHalfOpen": "testing recovery state",
    "SSL_TERMINATION": "HTTPS support with certificate management",
    "PATH_BASED_ROUTING": "routing based on URL paths",
    "HEADER_BASED_ROUTING": "routing based on HTTP headers",
    "CONTENT_AWARE_ROUTING": "routing based on request body content",
    "PROMETHEUS_FORMAT": "industry-standard metrics format",
    "ACME_PROTOCOL": "automatic certificate management",
    "SNI_ROUTING": "Server Name Indication based routing"
  },
  "terms": {
    "load balancer": "system distributing requests across backends",
    "reverse proxy": "server forwarding requests to backends",
    "backend server": "application server behind load balancer",
    "health check": "periodic verification of backend availability",
    "session affinity": "routing same client to same backend",
    "graceful degradation": "maintaining service with reduced functionality during failures",
    "connection pooling": "reusing HTTP connections for efficiency",
    "header forwarding": "copying HTTP headers between requests",
    "request forwarding": "sending client requests to backend servers",
    "response streaming": "transferring response data without buffering",
    "load balancing algorithm": "strategy for selecting backend servers",
    "round-robin": "cycling through backends in order",
    "weighted distribution": "proportional traffic based on backend weights",
    "least connections": "selecting backend with fewest active connections",
    "smooth weighted round robin": "avoiding burst selections of high-weight backends",
    "connection tracking": "monitoring active connections per backend",
    "hash consistency": "maintaining same IP-to-backend mapping",
    "atomic operations": "thread-safe counter operations",
    "algorithm switching": "changing selection strategy at runtime",
    "active health checking": "proactive monitoring with scheduled requests",
    "passive health checking": "failure detection from live request errors",
    "consecutive failure counting": "tracking sequential probe failures for state transitions",
    "recovery detection": "monitoring for backend restoration to healthy state",
    "probe": "single health check request to backend server",
    "failure detection": "process of identifying when backends become unhealthy",
    "thundering herd": "simultaneous recovery causing traffic spike",
    "health endpoint": "backend URL path dedicated to health status reporting",
    "state flapping": "rapid alternation between healthy and unhealthy states",
    "request router": "central coordinator integrating HTTP proxy, backend selection, and health checking",
    "request processing pipeline": "multi-stage flow from request reception to response delivery",
    "request context": "correlation data carried through processing pipeline",
    "error response handling": "generating appropriate HTTP error responses for various failure scenarios",
    "backend selection": "choosing appropriate backend server using load balancing algorithm",
    "request enhancement": "adding proxy headers and preparing request for backend forwarding",
    "connection management": "establishing and pooling HTTP connections to backend servers",
    "resource cleanup": "proper test teardown and resource deallocation",
    "error correlation": "tracking requests through logs using correlation IDs",
    "hot reload": "updating configuration without service interruption",
    "configuration validation": "checking configuration correctness before application",
    "atomic updates": "all-or-nothing configuration changes",
    "configuration distribution": "spreading configuration across multiple instances",
    "file watcher": "monitoring configuration files for changes",
    "rollback capability": "reverting to previous configuration on failure",
    "two-phase updates": "validate then apply configuration changes",
    "error classification": "categorizing errors by type and source",
    "circuit breaker": "pattern preventing repeated failed operations",
    "failure mode analysis": "systematic catalog of possible system failures",
    "cascade failure": "initial failures triggering additional failures",
    "admission control": "rejecting requests early when capacity constrained",
    "fail-fast": "immediately returning errors instead of wasting resources",
    "half-open state": "circuit breaker testing phase for recovery",
    "unit testing": "testing individual components in isolation with mocks",
    "integration testing": "end-to-end testing with real HTTP servers",
    "milestone validation": "structured verification of development phase completion",
    "failure injection": "controlled simulation of backend and network failures",
    "concurrent load testing": "testing with multiple simultaneous requests",
    "health check validation": "verifying backend health monitoring accuracy",
    "distribution testing": "validating request distribution across backends",
    "algorithm testing": "verifying load balancing algorithm correctness",
    "race condition detection": "identifying thread safety issues under concurrent load",
    "test server pool": "collection of mock backends for integration testing",
    "request tracking": "monitoring and logging request distribution patterns",
    "configuration hot reload": "updating settings without service interruption",
    "error response validation": "verifying appropriate HTTP error codes and messages",
    "performance testing": "measuring latency and throughput impact",
    "request correlation": "tracking requests through logs using correlation IDs",
    "connection leaks": "HTTP connections opened but never properly closed",
    "false positives": "healthy backends incorrectly marked as unhealthy",
    "false negatives": "unhealthy backends incorrectly marked as healthy",
    "SSL/TLS termination": "handling HTTPS encryption at load balancer",
    "certificate management": "automated SSL certificate lifecycle handling",
    "ACME protocol": "automated certificate management environment standard",
    "path-based routing": "request routing based on URL paths",
    "header-based routing": "request routing based on HTTP headers",
    "content-aware distribution": "routing decisions based on request body content",
    "monitoring and metrics": "comprehensive system observability",
    "Prometheus integration": "standard metrics format support",
    "observability": "system visibility through metrics and monitoring",
    "middleware pattern": "processing layers in request pipeline",
    "extension points": "architectural locations for adding new functionality",
    "backward compatibility": "maintaining existing functionality with new features",
    "configuration versioning": "managing configuration schema evolution",
    "performance impact": "effect of new features on system performance",
    "rule evaluation": "processing routing rules for request decisions",
    "metrics retention": "managing historical metrics data storage",
    "alerting integration": "automated notification based on metric thresholds"
  }
}