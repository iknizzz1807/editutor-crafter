classes: {
  core_class: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  utility_class: {
    style.fill: "#16213e"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  container_style: {
    style.fill: "#0f3460"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  memory_style: {
    style.fill: "#2d1b69"
    style.stroke: "#e17055"
    style.font-color: "#e6edf3"
  }
}

title: Data Structure Relationships {
  style.font-size: 18
  style.font-color: "#e6edf3"
  style.bold: true
}

memory_management: Memory Management {
  class: container_style
  
  node: Node {
    shape: class
    class: core_class
    "- data: T"
    "- next: AtomicPointer<Node>"
    "+ Node(data: T)"
    "+ get_data(): T"
  }
  
  atomic_ptr: AtomicPointer {
    shape: class
    class: utility_class
    "- pointer: atomic<T*>"
    "+ load(): T*"
    "+ store(ptr: T*): void"
    "+ compare_and_swap(expected: T*, desired: T*): bool"
  }
  
  hazard_ptr: HazardPointer {
    shape: class
    class: memory_style
    "- protected_ptr: atomic<void*>"
    "- thread_id: int"
    "- active: bool"
    "+ protect(ptr: void*): void"
    "+ release(): void"
    "+ is_protected(ptr: void*): bool"
  }
}

data_structures: Lock-Free Data Structures {
  class: container_style
  
  stack: Stack {
    shape: class
    class: core_class
    "- head: AtomicPointer<Node>"
    "- hazard_mgr: HazardPointer*"
    "+ push(data: T): void"
    "+ pop(): Option<T>"
    "+ is_empty(): bool"
  }
  
  queue: Queue {
    shape: class
    class: core_class
    "- head: AtomicPointer<Node>"
    "- tail: AtomicPointer<Node>"
    "- hazard_mgr: HazardPointer*"
    "+ enqueue(data: T): void"
    "+ dequeue(): Option<T>"
    "+ is_empty(): bool"
  }
  
  hashmap: HashMap {
    shape: class
    class: core_class
    "- buckets: AtomicPointer<Node>[]"
    "- size: atomic<int>"
    "- hazard_mgr: HazardPointer*"
    "+ put(key: K, value: V): void"
    "+ get(key: K): Option<V>"
    "+ remove(key: K): Option<V>"
    "+ hash(key: K): int"
  }
}

memory_management.node -> memory_management.atomic_ptr: uses {
  style.stroke: "#8b949e"
}

data_structures.stack -> memory_management.node: contains {
  style.stroke: "#3fb950"
}

data_structures.queue -> memory_management.node: contains {
  style.stroke: "#3fb950"
}

data_structures.hashmap -> memory_management.node: contains {
  style.stroke: "#3fb950"
}

data_structures.stack -> memory_management.hazard_ptr: "protects with" {
  style.stroke: "#e17055"
  style.stroke-dash: 3
}

data_structures.queue -> memory_management.hazard_ptr: "protects with" {
  style.stroke: "#e17055"
  style.stroke-dash: 3
}

data_structures.hashmap -> memory_management.hazard_ptr: "protects with" {
  style.stroke: "#e17055"
  style.stroke-dash: 3
}

data_structures.stack -> memory_management.atomic_ptr: "uses CAS" {
  style.stroke: "#8b949e"
}

data_structures.queue -> memory_management.atomic_ptr: "uses CAS" {
  style.stroke: "#8b949e"
}

data_structures.hashmap -> memory_management.atomic_ptr: "uses CAS" {
  style.stroke: "#8b949e"
}