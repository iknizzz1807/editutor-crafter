shape: sequence_diagram

Client: Client {
  style.fill: "#1a1a2e"
  style.font-color: "#e6edf3"
  style.stroke: "#3fb950"
}

Gateway: Query Gateway {
  style.fill: "#1a1a2e"
  style.font-color: "#e6edf3"
  style.stroke: "#3fb950"
}

Parser: LogQL Parser {
  style.fill: "#1a1a2e"
  style.font-color: "#e6edf3"
  style.stroke: "#3fb950"
}

Planner: Query Planner {
  style.fill: "#1a1a2e"
  style.font-color: "#e6edf3"
  style.stroke: "#3fb950"
}

Index: Index Service {
  style.fill: "#1a1a2e"
  style.font-color: "#e6edf3"
  style.stroke: "#3fb950"
}

Storage: Storage Engine {
  style.fill: "#1a1a2e"
  style.font-color: "#e6edf3"
  style.stroke: "#3fb950"
}

Client -> Gateway: POST /query {query: LogQL}
Gateway -> Parser: Parse LogQL
Parser -> Parser: Tokenize & Build AST
Parser -> Gateway: AST {filters, time_range, aggregations}
Gateway -> Planner: Create execution plan
Planner -> Planner: Optimize filter order
Planner -> Planner: Select index strategy
Planner -> Gateway: Execution plan
Gateway -> Index: Label filter lookup
Index -> Index: Query inverted index
Index -> Index: Apply bloom filters
Index -> Gateway: Candidate chunk IDs
Gateway -> Storage: Fetch chunks by IDs
Storage -> Storage: Decompress chunks
Storage -> Storage: Apply text filters
Storage -> Storage: Extract matching lines
Storage -> Gateway: Raw log entries
Gateway -> Gateway: Apply aggregations
Gateway -> Gateway: Format results
Gateway -> Client: Stream results {logs, metrics}