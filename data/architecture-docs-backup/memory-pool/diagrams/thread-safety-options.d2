title: Thread Safety Architecture Options {
  near: top-center
  style.font-size: 18
  style.bold: true
  style.font-color: "#e6edf3"
}

classes: {
  container_style: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  
  data_structure: {
    style.fill: "#16213e"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  
  sync_mechanism: {
    style.fill: "#0f3460"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  
  thread: {
    style.fill: "#2d3748"
    style.stroke: "#4a5568"
    style.font-color: "#e6edf3"
  }
}

approach1: Mutex-Protected Shared Pool {
  class: container_style
  
  shared_pool: Shared Memory Pool {
    class: data_structure
    shape: rectangle
  }
  
  free_list: Global Free List {
    class: data_structure
    shape: cylinder
  }
  
  mutex: Mutex Lock {
    class: sync_mechanism
    shape: diamond
  }
  
  thread1: Thread 1 {
    class: thread
  }
  
  thread2: Thread 2 {
    class: thread
  }
  
  thread3: Thread 3 {
    class: thread
  }
  
  thread1 -> mutex: acquire
  thread2 -> mutex: wait
  thread3 -> mutex: wait
  mutex -> shared_pool: protected access
  shared_pool -> free_list: manages
}

approach2: Per-Thread Pools {
  class: container_style
  
  pool1: Thread 1 Pool {
    class: data_structure
  }
  
  pool2: Thread 2 Pool {
    class: data_structure
  }
  
  pool3: Thread 3 Pool {
    class: data_structure
  }
  
  backup_pool: Backup Shared Pool {
    class: data_structure
    shape: cylinder
  }
  
  fallback_mutex: Fallback Mutex {
    class: sync_mechanism
    shape: diamond
  }
  
  t1: Thread 1 {
    class: thread
  }
  
  t2: Thread 2 {
    class: thread
  }
  
  t3: Thread 3 {
    class: thread
  }
  
  t1 -> pool1: direct access
  t2 -> pool2: direct access
  t3 -> pool3: direct access
  pool1 -> fallback_mutex: when depleted
  pool2 -> fallback_mutex: when depleted
  pool3 -> fallback_mutex: when depleted
  fallback_mutex -> backup_pool: protected access
}

approach3: Lock-Free Approach {
  class: container_style
  
  atomic_stack: Lock-Free Stack {
    class: data_structure
    shape: queue
  }
  
  cas_operations: Compare-And-Swap {
    class: sync_mechanism
    shape: hexagon
  }
  
  memory_ordering: Memory Ordering {
    class: sync_mechanism
    shape: parallelogram
  }
  
  lt1: Thread 1 {
    class: thread
  }
  
  lt2: Thread 2 {
    class: thread
  }
  
  lt3: Thread 3 {
    class: thread
  }
  
  lt1 -> cas_operations: atomic operations
  lt2 -> cas_operations: atomic operations
  lt3 -> cas_operations: atomic operations
  cas_operations -> atomic_stack: lock-free access
  cas_operations -> memory_ordering: ensures consistency
}

comparison: Performance Comparison {
  near: bottom-center
  class: container_style
  
  contention: High Contention {
    class: data_structure
    shape: oval
  }
  
  scalability: Poor Scalability {
    class: data_structure
    shape: oval
  }
  
  isolation: Thread Isolation {
    class: data_structure
    shape: oval
  }
  
  complexity: High Complexity {
    class: data_structure
    shape: oval
  }
}

approach1.mutex -> comparison.contention: causes
approach1.mutex -> comparison.scalability: limits

approach2.pool1 -> comparison.isolation: provides
approach2.pool2 -> comparison.isolation: provides
approach2.pool3 -> comparison.isolation: provides

approach3.cas_operations -> comparison.complexity: introduces

legend: |md
  **Trade-offs:**
  • Mutex: Simple but serialized
  • Per-thread: Fast but memory overhead
  • Lock-free: Scalable but complex
| {
  near: bottom-right
  shape: page
  style.fill: "#16213e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
}