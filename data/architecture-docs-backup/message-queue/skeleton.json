{
  "title": "Message Queue: Design Document",
  "overview": "This document outlines the design of an in-memory message queue supporting publish/subscribe, point-to-point delivery, and consumer groups. The key architectural challenge is building a reliable async communication backbone that handles message ordering, delivery guarantees, and failure recovery while maintaining high throughput.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Establishes the real-world need for message queues and compares different messaging patterns using postal system analogies.",
      "subsections": [
        {
          "id": "postal-analogy",
          "title": "Mental Model: The Digital Postal System",
          "summary": "Explains message queues through postal mail analogies for intuitive understanding"
        },
        {
          "id": "messaging-patterns",
          "title": "Messaging Patterns",
          "summary": "Compares pub/sub vs point-to-point delivery with concrete examples"
        },
        {
          "id": "existing-solutions",
          "title": "Existing Solutions Comparison",
          "summary": "Analyzes RabbitMQ, Apache Kafka, and Redis pub/sub capabilities and limitations"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the scope of functionality this message queue will and will not provide.",
      "subsections": [
        {
          "id": "functional-requirements",
          "title": "Functional Requirements",
          "summary": "Core messaging capabilities and delivery guarantees"
        },
        {
          "id": "non-functional-requirements",
          "title": "Non-Functional Requirements",
          "summary": "Performance, reliability, and operational constraints"
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Features deliberately excluded from this implementation"
        }
      ]
    },
    {
      "id": "architecture",
      "title": "High-Level Architecture",
      "summary": "Presents the overall system design with core components and their relationships.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Identifies the five main components and their responsibilities"
        },
        {
          "id": "module-structure",
          "title": "Recommended Module Structure",
          "summary": "File organization and package layout for clean separation of concerns"
        },
        {
          "id": "deployment-model",
          "title": "Deployment Model",
          "summary": "Single-node in-memory design with future clustering considerations"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines all key data structures for messages, topics, consumers, and persistence.",
      "subsections": [
        {
          "id": "core-types",
          "title": "Core Types",
          "summary": "Message, Topic, Consumer, and ConsumerGroup structure definitions"
        },
        {
          "id": "message-lifecycle",
          "title": "Message Lifecycle States",
          "summary": "State transitions from creation to acknowledgment or dead letter"
        },
        {
          "id": "persistence-format",
          "title": "Persistence Format",
          "summary": "Append-only log structure and indexing strategy"
        }
      ]
    },
    {
      "id": "wire-protocol",
      "title": "Wire Protocol Design",
      "summary": "Defines the binary TCP protocol for client-broker communication (Milestone 1).",
      "subsections": [
        {
          "id": "protocol-mental-model",
          "title": "Mental Model: Request-Response Conversations",
          "summary": "Frames the protocol as structured conversations between client and server"
        },
        {
          "id": "message-framing",
          "title": "Message Framing",
          "summary": "Binary frame format with length prefixes to handle TCP streaming"
        },
        {
          "id": "command-specification",
          "title": "Command Specification",
          "summary": "PUBLISH, SUBSCRIBE, ACK, NACK command formats and response codes"
        },
        {
          "id": "protocol-adrs",
          "title": "Protocol Architecture Decisions",
          "summary": "ADRs for binary vs text, synchronous vs async, and connection management"
        },
        {
          "id": "protocol-pitfalls",
          "title": "Common Protocol Pitfalls",
          "summary": "Partial reads, connection cleanup, and message ordering issues"
        }
      ]
    },
    {
      "id": "topic-manager",
      "title": "Topic Manager Component",
      "summary": "Manages topic creation, message routing, and subscriber fanout (Milestone 1).",
      "subsections": [
        {
          "id": "topic-mental-model",
          "title": "Mental Model: Radio Station Broadcasting",
          "summary": "Explains topic-based routing using radio station and listener analogies"
        },
        {
          "id": "topic-interface",
          "title": "Topic Manager Interface",
          "summary": "CreateTopic, PublishMessage, Subscribe, and Unsubscribe operations"
        },
        {
          "id": "fanout-algorithm",
          "title": "Message Fanout Algorithm",
          "summary": "Step-by-step process for delivering messages to all subscribers"
        },
        {
          "id": "wildcard-matching",
          "title": "Wildcard Subscription Matching",
          "summary": "Pattern matching for hierarchical topic names with * and # wildcards"
        },
        {
          "id": "topic-adrs",
          "title": "Topic Manager Architecture Decisions",
          "summary": "ADRs for in-memory vs disk storage, wildcard syntax, and subscription indexing"
        },
        {
          "id": "topic-pitfalls",
          "title": "Common Topic Management Pitfalls",
          "summary": "Memory leaks from abandoned topics and race conditions in fanout"
        }
      ]
    },
    {
      "id": "consumer-groups",
      "title": "Consumer Groups Component",
      "summary": "Implements consumer groups with round-robin distribution and rebalancing (Milestone 2).",
      "subsections": [
        {
          "id": "consumer-group-mental-model",
          "title": "Mental Model: Work Distribution Teams",
          "summary": "Explains consumer groups as teams dividing work with automatic rebalancing"
        },
        {
          "id": "group-coordinator",
          "title": "Group Coordinator Interface",
          "summary": "JoinGroup, LeaveGroup, and message assignment operations"
        },
        {
          "id": "rebalancing-algorithm",
          "title": "Rebalancing Algorithm",
          "summary": "Step-by-step process for reassigning work when consumers join or leave"
        },
        {
          "id": "assignment-strategies",
          "title": "Assignment Strategies",
          "summary": "Round-robin vs sticky assignment trade-offs and implementation"
        },
        {
          "id": "consumer-group-adrs",
          "title": "Consumer Group Architecture Decisions",
          "summary": "ADRs for assignment strategy, rebalancing triggers, and group membership"
        },
        {
          "id": "consumer-group-pitfalls",
          "title": "Common Consumer Group Pitfalls",
          "summary": "Duplicate delivery during rebalancing and thundering herd on rebalancing"
        }
      ]
    },
    {
      "id": "acknowledgment",
      "title": "Message Acknowledgment Component",
      "summary": "Handles ACK/NACK processing, message tracking, and redelivery (Milestone 2).",
      "subsections": [
        {
          "id": "ack-mental-model",
          "title": "Mental Model: Certified Mail Receipts",
          "summary": "Relates message acknowledgment to postal delivery confirmation systems"
        },
        {
          "id": "ack-tracker-interface",
          "title": "Acknowledgment Tracker Interface",
          "summary": "TrackMessage, ProcessAck, ProcessNack, and CheckTimeouts operations"
        },
        {
          "id": "redelivery-algorithm",
          "title": "Redelivery Algorithm",
          "summary": "Timeout detection and message reassignment to available consumers"
        },
        {
          "id": "poison-message-handling",
          "title": "Poison Message Detection",
          "summary": "Retry count tracking and dead letter queue routing"
        },
        {
          "id": "ack-adrs",
          "title": "Acknowledgment Architecture Decisions",
          "summary": "ADRs for timeout values, retry policies, and delivery semantics"
        },
        {
          "id": "ack-pitfalls",
          "title": "Common Acknowledgment Pitfalls",
          "summary": "Infinite redelivery loops and head-of-line blocking issues"
        }
      ]
    },
    {
      "id": "persistence",
      "title": "Persistence Layer",
      "summary": "Implements append-only logging and crash recovery (Milestone 3).",
      "subsections": [
        {
          "id": "persistence-mental-model",
          "title": "Mental Model: Laboratory Notebook",
          "summary": "Compares append-only logging to scientific laboratory record-keeping"
        },
        {
          "id": "wal-interface",
          "title": "Write-Ahead Log Interface",
          "summary": "AppendRecord, ReadRecord, and CreateCheckpoint operations"
        },
        {
          "id": "recovery-algorithm",
          "title": "Crash Recovery Algorithm",
          "summary": "Step-by-step process for rebuilding state from log on startup"
        },
        {
          "id": "log-compaction",
          "title": "Log Compaction Strategy",
          "summary": "Retention policies and background cleanup procedures"
        },
        {
          "id": "persistence-adrs",
          "title": "Persistence Architecture Decisions",
          "summary": "ADRs for file format, fsync frequency, and indexing strategy"
        },
        {
          "id": "persistence-pitfalls",
          "title": "Common Persistence Pitfalls",
          "summary": "Unbounded log growth and fsync performance trade-offs"
        }
      ]
    },
    {
      "id": "backpressure",
      "title": "Backpressure Management",
      "summary": "Implements flow control to handle slow consumers and prevent system overload (Milestone 3).",
      "subsections": [
        {
          "id": "backpressure-mental-model",
          "title": "Mental Model: Traffic Flow Control",
          "summary": "Explains backpressure using highway traffic management analogies"
        },
        {
          "id": "flow-controller-interface",
          "title": "Flow Controller Interface",
          "summary": "CheckCapacity, ApplyBackpressure, and ReleaseBackpressure operations"
        },
        {
          "id": "lag-monitoring-algorithm",
          "title": "Consumer Lag Monitoring",
          "summary": "Tracking consumer progress and detecting when intervention is needed"
        },
        {
          "id": "throttling-strategies",
          "title": "Producer Throttling Strategies",
          "summary": "Rate limiting and connection pausing approaches"
        },
        {
          "id": "backpressure-adrs",
          "title": "Backpressure Architecture Decisions",
          "summary": "ADRs for lag thresholds, throttling mechanisms, and priority handling"
        },
        {
          "id": "backpressure-pitfalls",
          "title": "Common Backpressure Pitfalls",
          "summary": "Cascading failures and overly aggressive throttling"
        }
      ]
    },
    {
      "id": "dead-letter-queue",
      "title": "Dead Letter Queue Management",
      "summary": "Handles poison messages and provides replay capabilities (Milestone 4).",
      "subsections": [
        {
          "id": "dlq-mental-model",
          "title": "Mental Model: Undeliverable Mail Office",
          "summary": "Relates DLQ to postal service handling of undeliverable mail"
        },
        {
          "id": "dlq-manager-interface",
          "title": "DLQ Manager Interface",
          "summary": "SendToDLQ, InspectMessage, and ReplayMessage operations"
        },
        {
          "id": "message-replay-algorithm",
          "title": "Message Replay Algorithm",
          "summary": "Safe reprocessing of DLQ messages with ordering considerations"
        },
        {
          "id": "dlq-adrs",
          "title": "DLQ Architecture Decisions",
          "summary": "ADRs for DLQ storage, replay ordering, and administrative interfaces"
        },
        {
          "id": "dlq-pitfalls",
          "title": "Common DLQ Pitfalls",
          "summary": "Out-of-order replay and infinite DLQ loops"
        }
      ]
    },
    {
      "id": "monitoring",
      "title": "Monitoring and Observability",
      "summary": "Provides metrics, health checks, and administrative APIs (Milestone 4).",
      "subsections": [
        {
          "id": "monitoring-mental-model",
          "title": "Mental Model: System Dashboard",
          "summary": "Compares monitoring to car dashboard showing engine health"
        },
        {
          "id": "metrics-collection",
          "title": "Metrics Collection",
          "summary": "Queue depth, throughput, error rates, and consumer lag tracking"
        },
        {
          "id": "health-check-algorithm",
          "title": "Health Check Algorithm",
          "summary": "Consumer heartbeat tracking and automatic cleanup"
        },
        {
          "id": "admin-api",
          "title": "Administrative API",
          "summary": "REST endpoints for inspecting and managing broker state"
        },
        {
          "id": "monitoring-adrs",
          "title": "Monitoring Architecture Decisions",
          "summary": "ADRs for metrics format, collection frequency, and alerting thresholds"
        }
      ]
    },
    {
      "id": "interactions",
      "title": "Component Interactions and Data Flow",
      "summary": "Describes how components communicate and the flow of messages through the system.",
      "subsections": [
        {
          "id": "publish-flow",
          "title": "Message Publish Flow",
          "summary": "End-to-end sequence from producer to persistence and fanout"
        },
        {
          "id": "consume-flow",
          "title": "Message Consumption Flow",
          "summary": "Consumer group assignment through acknowledgment or redelivery"
        },
        {
          "id": "rebalancing-flow",
          "title": "Consumer Group Rebalancing Flow",
          "summary": "Coordination sequence when group membership changes"
        },
        {
          "id": "recovery-flow",
          "title": "Crash Recovery Flow",
          "summary": "Startup sequence rebuilding state from persistent logs"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Defines failure modes, detection mechanisms, and recovery strategies.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "Failure Mode Classification",
          "summary": "Network failures, consumer crashes, and broker overload scenarios"
        },
        {
          "id": "error-detection",
          "title": "Error Detection Mechanisms",
          "summary": "Timeouts, heartbeats, and health check strategies"
        },
        {
          "id": "recovery-strategies",
          "title": "Recovery Strategies",
          "summary": "Graceful degradation and automatic healing approaches"
        }
      ]
    },
    {
      "id": "testing",
      "title": "Testing Strategy",
      "summary": "Outlines testing approaches for different system properties and milestone verification.",
      "subsections": [
        {
          "id": "unit-testing",
          "title": "Unit Testing Approach",
          "summary": "Testing individual components with mocked dependencies"
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing Scenarios",
          "summary": "End-to-end workflows and cross-component interactions"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "Expected behavior and verification steps after each milestone"
        },
        {
          "id": "chaos-testing",
          "title": "Chaos Testing Scenarios",
          "summary": "Failure injection and resilience validation"
        }
      ]
    },
    {
      "id": "debugging",
      "title": "Debugging Guide",
      "summary": "Common issues learners encounter with diagnosis and resolution strategies.",
      "subsections": [
        {
          "id": "connection-issues",
          "title": "Connection and Protocol Issues",
          "summary": "TCP connection problems, partial reads, and protocol violations"
        },
        {
          "id": "message-delivery-issues",
          "title": "Message Delivery Issues",
          "summary": "Lost messages, duplicates, and ordering problems"
        },
        {
          "id": "performance-issues",
          "title": "Performance and Memory Issues",
          "summary": "Memory leaks, slow consumers, and throughput bottlenecks"
        },
        {
          "id": "persistence-issues",
          "title": "Persistence and Recovery Issues",
          "summary": "Log corruption, recovery failures, and disk space problems"
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools and Techniques",
          "summary": "Logging strategies, state inspection, and monitoring tools"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements and how the current design accommodates them.",
      "subsections": [
        {
          "id": "clustering",
          "title": "Broker Clustering",
          "summary": "Multi-node deployment with leader election and replication"
        },
        {
          "id": "advanced-routing",
          "title": "Advanced Routing Features",
          "summary": "Content-based routing and exchange types"
        },
        {
          "id": "performance-optimizations",
          "title": "Performance Optimizations",
          "summary": "Batching, compression, and zero-copy techniques"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of technical terms and domain-specific vocabulary used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-overview",
      "title": "System Component Overview",
      "description": "Shows the five main components (Protocol Handler, Topic Manager, Consumer Group Coordinator, Acknowledgment Tracker, Persistence Layer) and their relationships with external clients and storage",
      "type": "component",
      "relevant_sections": [
        "architecture",
        "interactions"
      ]
    },
    {
      "id": "message-lifecycle",
      "title": "Message Lifecycle State Machine",
      "description": "Displays message states from creation through pending, acknowledged, or dead letter states with triggering events and transitions",
      "type": "state-machine",
      "relevant_sections": [
        "data-model",
        "acknowledgment",
        "dead-letter-queue"
      ]
    },
    {
      "id": "publish-sequence",
      "title": "Message Publish Sequence",
      "description": "Sequence diagram showing producer publishing a message through protocol handler, topic manager, persistence, and fanout to subscribers",
      "type": "sequence",
      "relevant_sections": [
        "wire-protocol",
        "topic-manager",
        "persistence",
        "interactions"
      ]
    },
    {
      "id": "consumer-group-sequence",
      "title": "Consumer Group Message Delivery",
      "description": "Sequence diagram showing message delivery to consumer group members with round-robin assignment and acknowledgment tracking",
      "type": "sequence",
      "relevant_sections": [
        "consumer-groups",
        "acknowledgment",
        "interactions"
      ]
    },
    {
      "id": "rebalancing-flowchart",
      "title": "Consumer Group Rebalancing Process",
      "description": "Flowchart showing decision points and steps when consumers join or leave a group, including work reassignment and notification",
      "type": "flowchart",
      "relevant_sections": [
        "consumer-groups",
        "interactions"
      ]
    },
    {
      "id": "data-model-relationships",
      "title": "Data Model Entity Relationships",
      "description": "Shows relationships between Message, Topic, Consumer, ConsumerGroup, and PendingMessage entities with cardinalities",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "recovery-flowchart",
      "title": "Crash Recovery Process",
      "description": "Flowchart showing startup sequence reading WAL, rebuilding topic state, restoring consumer groups, and resuming operations",
      "type": "flowchart",
      "relevant_sections": [
        "persistence",
        "interactions"
      ]
    },
    {
      "id": "backpressure-state-machine",
      "title": "Backpressure Control States",
      "description": "State machine showing normal, warning, and throttled states with transitions based on consumer lag thresholds",
      "type": "state-machine",
      "relevant_sections": [
        "backpressure"
      ]
    }
  ]
}