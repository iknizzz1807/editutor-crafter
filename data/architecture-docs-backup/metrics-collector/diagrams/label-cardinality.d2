# Label Cardinality Impact
title: Label Cardinality Impact

classes: {
  base_metric: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  high_cardinality: {
    style.fill: "#d63031"
    style.stroke: "#e17055"
    style.font-color: "#ffffff"
    style.bold: true
  }
  index_component: {
    style.fill: "#16213e"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  storage_warning: {
    style.fill: "#fdcb6e"
    style.stroke: "#e17055"
    style.font-color: "#2d3436"
    style.bold: true
  }
}

metric_source: Metric Source {
  class: base_metric
  basic_metric: "http_requests_total"
  
  labels: Labels Added {
    method: "method=GET,POST,PUT,DELETE"
    status: "status=200,404,500,503"
    endpoint: "endpoint=/api/users,/api/orders,..."
    region: "region=us-east,us-west,eu-central"
    instance: "instance=server1,server2,server3"
  }
}

cardinality_explosion: Cardinality Explosion {
  class: high_cardinality
  
  calculation: |md
    **Series Count Calculation:**
    4 methods × 4 statuses × 
    10 endpoints × 3 regions × 
    3 instances = **1,440 series**
    
    Adding one more label dimension
    with 5 values = **7,200 series**
  |
  
  memory_impact: Memory Impact {
    class: storage_warning
    series_overhead: "~1KB per series"
    index_size: "7.2MB+ for labels alone"
    query_cost: "Higher scan overhead"
  }
}

storage_engine: Time Series Storage {
  class: index_component
  
  label_index: Label Index {
    inverted_index: "label=value → [series_ids]"
    memory_resident: "Fast query lookups"
    grows_with_cardinality: "O(labels × values)"
  }
  
  series_index: Series Index {
    series_id: "unique ID per series"
    label_hash: "fingerprint → series_id"
    metadata_storage: "series → label pairs"
  }
  
  data_blocks: Data Blocks {
    shape: cylinder
    time_ordered: "samples by timestamp"
    compressed: "delta + compression"
    per_series: "separate blocks per series"
  }
}

query_engine: Query Engine Impact {
  class: index_component
  
  label_matching: Label Matching {
    regex_cost: "method=~'GET|POST'"
    intersection_cost: "multiple label filters"
    series_selection: "filter before data scan"
  }
  
  aggregation: Aggregation Cost {
    group_by: "group by label combinations"
    memory_usage: "intermediate result sets"
    cpu_intensive: "higher series count"
  }
}

# Connections showing data flow and impact
metric_source -> cardinality_explosion: "label combinations multiply"
cardinality_explosion -> storage_engine: "creates index pressure"
storage_engine -> query_engine: "affects query performance"

# Internal storage relationships
storage_engine.label_index -> storage_engine.series_index: "lookup series"
storage_engine.series_index -> storage_engine.data_blocks: "access data"

# Query path
query_engine.label_matching -> storage_engine.label_index: "filter series"
storage_engine.label_index -> query_engine.aggregation: "selected series"

# Warning indicators
cardinality_explosion.memory_impact -> storage_engine.label_index: "index bloat"
cardinality_explosion.memory_impact -> query_engine.aggregation: "query slowdown"

best_practices: Best Practices {
  class: base_metric
  near: bottom-center
  
  avoid_high_cardinality: |md
    • **Avoid unbounded labels** (user_id, request_id)
    • **Limit label values** (<100 per label)
    • **Use recording rules** for pre-aggregation
    • **Monitor cardinality** metrics regularly
  |
}