{
  "types": {
    "shell_state_t": "fields: shell_pgid pid_t, interactive int, shell_tmodes struct termios, job_table struct job*, next_job_id int, sigchld_received volatile sig_atomic_t",
    "job": "fields: job_id int, pgid pid_t, state job_state_t, command_line char*, next struct job*",
    "termios": "terminal interface structure for mode saving",
    "command_t": "fields: tokens char**, token_count int, input_file char*, output_file char*, append_output int, background int",
    "job_state_t": "enum: JOB_RUNNING, JOB_STOPPED, JOB_TERMINATED, JOB_COPROCESS",
    "tokenizer_state_t": "fields: input char*, position size_t, current_state token_state_t, quote_char char",
    "token_array_t": "fields: tokens char**, count size_t, capacity size_t",
    "token_state_t": "enum: TOKEN_NORMAL, TOKEN_SINGLE_QUOTE, TOKEN_DOUBLE_QUOTE, TOKEN_ESCAPE",
    "string_builder_t": "fields: buffer char*, length size_t, capacity size_t",
    "path_result_t": "enum: PATH_FOUND, PATH_NOT_FOUND, PATH_PERMISSION_DENIED, PATH_INVALID_COMMAND",
    "builtin_func_t": "function pointer type for built-in command handlers",
    "builtin_command_t": "fields: name char*, handler builtin_func_t, description char*",
    "pipeline_t": "fields: commands command_t**, command_count size_t, pipes pipe_segment_t*, pipe_count size_t, child_pids pid_t*, pgid pid_t",
    "pipe_segment_t": "fields: read_fd int, write_fd int",
    "fd_tracker_t": "fields: fds int*, count size_t, capacity size_t",
    "sigset_t": "signal set for masking operations",
    "struct sigaction": "signal action structure with handler and flags",
    "error_context_t": "fields: component char*, operation char*, context char*, error_code int, process_id pid_t",
    "resource_manager_t": "fields: resources resource_info_t[], fd_tracker int[], fd_count int, child_pids pid_t*, child_count int, child_capacity int",
    "error_level_t": "enum: ERROR_INFO, ERROR_WARNING, ERROR_ERROR, ERROR_FATAL",
    "resource_type_t": "enum: RESOURCE_FILE_DESCRIPTORS, RESOURCE_PROCESSES, RESOURCE_MEMORY",
    "resource_info_t": "fields: current_usage long, soft_limit long, hard_limit long, system_limit long",
    "test_result_t": "fields: output char[4096], output_size int, exit_status int, error_msg char[256], success int",
    "process_monitor_t": "fields: initial_process_count int, peak_process_count int, initial_fd_count int, peak_fd_count int",
    "debug_level_t": "enum: DEBUG_OFF, DEBUG_ERROR, DEBUG_WARNING, DEBUG_INFO, DEBUG_VERBOSE",
    "hash_table_t": "generic hash table structure",
    "scope_t": "variable scope for function calls",
    "ast_node_t": "base type for abstract syntax tree nodes",
    "ast_if_t": "fields: condition ast_node_t*, then_body ast_node_t*, else_body ast_node_t*",
    "ast_while_t": "fields: condition ast_node_t*, body ast_node_t*, iteration_count int",
    "ast_command_t": "fields: command command_t*, redirections redirection_t*",
    "ast_pipeline_t": "fields: commands ast_node_t**, command_count size_t",
    "ast_sequence_t": "fields: statements ast_node_t**, statement_count size_t",
    "cache_entry_t": "individual cache entry in LRU list",
    "cache_stats_t": "hit/miss ratios and performance metrics",
    "history_entry_t": "individual command history entry",
    "command_resolver_t": "fields: resolve function pointer, next struct command_resolver*",
    "shell_config_t": "shell configuration and feature flags",
    "shell_allocator_t": "memory allocation interface"
  },
  "methods": {
    "shell_init() shell_state_t*": "initialize shell state and signal handling",
    "shell_cleanup(shell_state_t*) void": "clean shutdown and resource cleanup",
    "sigchld_handler(int) static void": "async-signal-safe SIGCHLD handler",
    "terminal_signal_handler(int) static void": "handler for SIGINT and SIGTSTP",
    "handle_sigchld(shell_state_t*) void": "process pending child notifications",
    "setup_process_group(pid_t, pid_t, int) int": "establish process group with race prevention",
    "restore_terminal_control(shell_state_t*) void": "return terminal control to shell",
    "shell_error(const char*, const char*, int) void": "standardized error reporting",
    "handle_eintr(int, const char*) int": "handle interrupted system calls with retry logic",
    "parse_command_line(const char*) command_t*": "parse command line into structured representation",
    "tokenize_command_line(const char*, int*) char**": "break command line into token array",
    "free_command(command_t*) void": "cleanup command structure and associated memory",
    "free_token_array(char**, int) void": "cleanup token array and individual tokens",
    "execute_command(shell_state_t*, command_t*) int": "execute single command with job control",
    "apply_redirections(command_t*, int*) int": "apply I/O redirections including network redirection",
    "restore_redirections(int*) void": "restore original file descriptors",
    "wait_for_job(shell_state_t*, pid_t) int": "wait for foreground job completion",
    "resolve_command_path(const char*, char**) path_result_t": "resolve command name to executable path",
    "is_builtin_command(const char*) int": "check if command is built-in",
    "execute_builtin(shell_state_t*, const char*, char**, int) int": "execute built-in command",
    "builtin_cd(shell_state_t*, char**, int) int": "change directory built-in",
    "builtin_pwd(shell_state_t*, char**, int) int": "print working directory built-in",
    "builtin_exit(shell_state_t*, char**, int) int": "exit shell built-in",
    "pipeline_create(command_t**, size_t) pipeline_t*": "create pipeline structure",
    "pipeline_execute(shell_state_t*, pipeline_t*) int": "execute pipeline with job control",
    "pipeline_destroy(pipeline_t*) void": "cleanup pipeline resources",
    "fd_save_original(int) int": "save file descriptor for restoration",
    "fd_track_pipe(int) void": "track pipe FD for cleanup",
    "fd_close_all_pipes() void": "close all tracked pipe FDs",
    "fd_restore_all() void": "restore all saved FDs",
    "pipeline_setup_child_fds(pipeline_t*, size_t) int": "configure child process file descriptors",
    "create_job(shell_state_t*, pid_t, const char*, int) job*": "create new job entry in job table",
    "find_job_by_id(shell_state_t*, int) job*": "find job by user job ID",
    "update_job_state(shell_state_t*, pid_t, job_state_t) int": "update job state from signal or command",
    "cleanup_terminated_jobs(shell_state_t*) void": "clean up terminated jobs from main loop",
    "builtin_jobs(shell_state_t*, char**, int) int": "list all active jobs",
    "builtin_fg(shell_state_t*, char**, int) int": "bring job to foreground",
    "builtin_bg(shell_state_t*, char**, int) int": "continue job in background",
    "sigchld_handler(int) void": "async-signal-safe SIGCHLD handler",
    "terminal_signal_handler(int) void": "handler for SIGINT and SIGTSTP",
    "give_terminal_to_shell(shell_state_t*) int": "return terminal control to shell",
    "give_terminal_to_job(shell_state_t*, pid_t) int": "transfer terminal control to job",
    "tcsetpgrp(int, pid_t) int": "set terminal foreground process group",
    "setpgid(pid_t, pid_t) int": "set process group membership",
    "waitpid(pid_t, int*, int) pid_t": "wait for child process state change",
    "kill(pid_t, int) int": "send signal to process or process group",
    "sigprocmask(int, const sigset_t*, sigset_t*) int": "block or unblock signals atomically",
    "sigaction(int, const struct sigaction*, struct sigaction*) int": "install signal handler",
    "shell_error(error_level_t, const char*, const char*, const char*) void": "standardized error reporting with severity levels",
    "safe_waitpid(pid_t, int*, int) pid_t": "waitpid wrapper with comprehensive error handling",
    "resource_check_available(resource_manager_t*, resource_type_t, int) int": "verify sufficient resources available",
    "resource_emergency_cleanup(resource_manager_t*) void": "emergency resource cleanup when critically low",
    "assert_test(int, const char*, const char*) void": "test assertion with detailed error reporting",
    "execute_shell_command(const char*, const char*) test_result_t": "execute shell command and capture output",
    "create_process_monitor() process_monitor_t*": "monitor process creation and cleanup",
    "update_process_monitor(process_monitor_t*) void": "update process monitoring statistics",
    "verify_resource_cleanup(process_monitor_t*) int": "verify no resource leaks occurred",
    "print_test_summary() void": "print final test summary",
    "debug_init(debug_level_t, const char*) void": "initialize debug system with level and log file",
    "debug_cleanup() void": "clean shutdown of debug system",
    "debug_print_process_info(pid_t, const char*) void": "print detailed process information",
    "debug_print_fd_info(const char*) void": "print file descriptor information",
    "resource_manager_create() resource_manager_t*": "create resource monitoring system",
    "resource_manager_destroy(resource_manager_t*) void": "cleanup resource monitoring system",
    "signal_debug_record(int) void": "async-signal-safe signal event recording",
    "signal_debug_process_flags() void": "process recorded signal events in main loop",
    "validate_shell_state(shell_state_t*, char*, size_t) int": "comprehensive shell state validation",
    "register_command_resolver(command_resolver_t*) void": "register extension resolver in resolver chain",
    "shell_config_create() shell_config_t*": "initialize configuration with defaults",
    "shell_config_set(shell_config_t*, const char*, const char*) void": "set configuration option",
    "shell_config_get(shell_config_t*, const char*) const char*": "get configuration option value",
    "shell_alloc(size_t) void*": "allocate memory using configured allocator",
    "shell_free(void*) void": "free memory using configured allocator"
  },
  "constants": {
    "DEBUG_SHELL": "compile-time debug flag",
    "WNOHANG": "waitpid flag for non-blocking wait",
    "SA_RESTART": "sigaction flag for automatic system call restart",
    "TOKEN_NORMAL": "normal parsing state outside quotes",
    "TOKEN_SINGLE_QUOTE": "inside single quote parsing",
    "TOKEN_DOUBLE_QUOTE": "inside double quote parsing",
    "TOKEN_ESCAPE": "processing escaped character",
    "DEFAULT_PATH": "/bin:/usr/bin:/usr/local/bin",
    "PATH_SEPARATOR": ":",
    "MAX_PATH_LENGTH": "4096",
    "O_CLOEXEC": "file descriptor flag for close-on-exec",
    "O_RDONLY": "open flag for read-only access",
    "O_WRONLY": "open flag for write-only access",
    "O_CREAT": "open flag to create file if needed",
    "O_TRUNC": "open flag to truncate existing file",
    "O_APPEND": "open flag for append mode",
    "STDIN_FILENO": "file descriptor 0",
    "STDOUT_FILENO": "file descriptor 1",
    "STDERR_FILENO": "file descriptor 2",
    "JOB_RUNNING": "job state for active jobs",
    "JOB_STOPPED": "job state for suspended jobs",
    "JOB_TERMINATED": "job state for completed jobs",
    "SIGCHLD": "signal sent when child process changes state",
    "SIGINT": "signal sent by Ctrl+C",
    "SIGTSTP": "signal sent by Ctrl+Z",
    "SIGCONT": "signal to resume stopped process",
    "SIG_DFL": "default signal handler",
    "SIG_IGN": "ignore signal",
    "WIFEXITED": "macro to check if process exited normally",
    "WIFSIGNALED": "macro to check if process terminated by signal",
    "WIFSTOPPED": "macro to check if process was stopped",
    "WIFCONTINUED": "macro to check if process was continued",
    "EACCES": "permission denied error code",
    "EINTR": "interrupted system call error code",
    "EAGAIN": "resource temporarily unavailable",
    "ESRCH": "no such process error code",
    "ECHILD": "no child processes error code",
    "MAX_OUTPUT_SIZE": "4096",
    "MAX_ERROR_MSG_SIZE": "256",
    "TOKEN_VARIABLE_START": "tokenizer state for beginning variable expansion",
    "TOKEN_VARIABLE_BRACE": "tokenizer state for braced variable names",
    "TOKEN_VARIABLE_NAME": "tokenizer state for simple variable names",
    "TOKEN_VARIABLE_IN_QUOTE": "tokenizer state for variables within quotes",
    "JOB_COPROCESS": "job state for co-processes",
    "MAX_HOSTS": "maximum number of allowed network hosts"
  },
  "terms": {
    "process group": "collection of related processes for job control",
    "foreground job": "job that currently owns terminal control",
    "background job": "job running without terminal control",
    "async-signal-safe": "functions safe to call from signal handlers",
    "race condition hotspot": "timing-sensitive area where race conditions commonly occur",
    "terminal control": "ownership of terminal input/output for signal delivery",
    "job control": "shell feature for managing multiple jobs",
    "signal routing": "directing signals to appropriate process groups",
    "lexical analyzer": "component that breaks input into meaningful tokens",
    "finite state machine": "parsing approach using states and transitions",
    "recursive descent parser": "top-down parsing using recursive function calls",
    "metacharacters": "shell special characters like | > < &",
    "quote removal": "eliminating quote characters during tokenization",
    "memory lifecycle": "allocation, usage, and cleanup phases of dynamic memory",
    "process factory": "mental model for command executor creating processes",
    "fork/exec pattern": "Unix process creation using fork followed by exec",
    "PATH resolution": "algorithm for finding executable files in PATH directories",
    "built-in command": "command executed within shell process",
    "external command": "command executed in separate child process",
    "command classification": "decision logic for built-in vs external execution",
    "resource lifecycle": "allocation, usage, and cleanup phases of resources",
    "file descriptor": "integer handle representing an open file or pipe",
    "pipe object": "pair of connected file descriptors created by pipe() system call",
    "redirection": "changing where a process's stdin/stdout/stderr point",
    "pipeline": "chain of commands connected by pipes",
    "file descriptor duplication": "creating aliases to same resource using dup2",
    "plumbing system": "mental model of file descriptors as reconnectable pipes",
    "job table": "shell data structure tracking all active jobs",
    "process group leader": "first process in a process group",
    "session leader": "process that established the session",
    "controlling terminal": "terminal associated with session",
    "file descriptor lifecycle": "allocation, usage, and cleanup phases of file descriptors",
    "signal mask": "set of blocked signals for a process",
    "critical section": "code region requiring atomic execution",
    "resource exhaustion": "condition where system limits prevent operation",
    "emergency cleanup": "last-resort resource recovery when normal operation impossible",
    "milestone checkpoint": "systematic verification of individual development phase goals",
    "integration testing": "testing complex interactions between multiple shell components",
    "edge case testing": "testing unusual conditions and boundary scenarios",
    "stress testing": "testing under resource pressure and unusual load patterns",
    "process monitor": "utility for tracking process and resource usage during tests",
    "resource leak": "failure to properly clean up allocated resources",
    "symbol table": "data structure mapping variable names to values",
    "lazy expansion": "deferring variable expansion until execution time",
    "abstract syntax tree": "hierarchical representation of program structure",
    "LRU cache": "Least Recently Used caching strategy",
    "command substitution": "capturing command output for use as arguments",
    "here document": "multi-line input embedded in shell scripts",
    "co-process": "bidirectional communication with persistent background process",
    "network redirection": "redirecting I/O to network sockets",
    "string interning": "storing single copies of repeated strings",
    "lazy initialization": "deferring resource allocation until needed",
    "plugin interface": "extension point for adding functionality",
    "feature detection": "runtime determination of available capabilities",
    "memory pool": "pre-allocated memory regions for efficient allocation",
    "extension point": "architectural boundary where new functionality can attach",
    "shell": "Interactive command-line interface that manages processes and I/O",
    "lexical analysis": "component that breaks input into meaningful tokens",
    "builtin command": "command executed within shell process",
    "race condition": "timing-dependent bug where outcome depends on unpredictable ordering",
    "zombie process": "terminated child process whose exit status has not been collected"
  }
}