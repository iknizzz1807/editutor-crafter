title: "Failure Detection and Recovery"

classes: {
  container: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  component: {
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  critical: {
    style.fill: "#16213e"
    style.stroke: "#d63031"
    style.font-color: "#ffffff"
    style.bold: true
  }
  monitor: {
    style.fill: "#0f3460"
    style.stroke: "#fdcb6e"
    style.font-color: "#e6edf3"
  }
  recovery: {
    style.fill: "#2d3436"
    style.stroke: "#00b894"
    style.font-color: "#ffffff"
  }
}

detection_layer: "Detection Layer" {
  class: container
  
  health_monitor: "Health Monitor" {
    class: monitor
  }
  
  circuit_breaker: "Circuit Breaker" {
    class: critical
  }
  
  failure_classifier: "Failure Classifier" {
    class: monitor
  }
}

data_pipeline: "Data Pipeline" {
  class: container
  
  ingestion_cb: "Ingestion CB" {
    class: component
  }
  
  validation_hc: "Data Validation HC" {
    class: component
  }
  
  fallback_cache: "Fallback Cache" {
    shape: cylinder
    class: recovery
  }
}

training_system: "Training System" {
  class: container
  
  compute_monitor: "Compute Monitor" {
    class: monitor
  }
  
  checkpoint_mgr: "Checkpoint Manager" {
    class: recovery
  }
  
  resource_fallback: "Resource Fallback" {
    class: recovery
  }
}

serving_layer: "Serving Layer" {
  class: container
  
  model_hc: "Model Health Check" {
    class: monitor
  }
  
  serving_cb: "Serving CB" {
    class: critical
  }
  
  model_fallback: "Model Fallback" {
    class: recovery
  }
}

recovery_orchestrator: "Recovery Orchestrator" {
  class: container
  
  failure_handler: "Failure Handler" {
    class: recovery
  }
  
  recovery_workflows: "Recovery Workflows" {
    shape: page
    class: recovery
  }
  
  state_manager: "State Manager" {
    shape: cylinder
    class: component
  }
}

# Detection connections
detection_layer.health_monitor -> data_pipeline.validation_hc: "monitor"
detection_layer.health_monitor -> training_system.compute_monitor: "monitor"
detection_layer.health_monitor -> serving_layer.model_hc: "monitor"

detection_layer.circuit_breaker -> data_pipeline.ingestion_cb: "control"
detection_layer.circuit_breaker -> serving_layer.serving_cb: "control"

detection_layer.failure_classifier -> recovery_orchestrator.failure_handler: "classify & route"

# Recovery connections
data_pipeline.ingestion_cb -> data_pipeline.fallback_cache: "fallback data" {
  style.stroke: "#00b894"
  style.stroke-dash: 3
}

training_system.compute_monitor -> training_system.checkpoint_mgr: "save state"
training_system.compute_monitor -> training_system.resource_fallback: "switch resources"

serving_layer.serving_cb -> serving_layer.model_fallback: "fallback model" {
  style.stroke: "#00b894"
  style.stroke-dash: 3
}

recovery_orchestrator.failure_handler -> recovery_orchestrator.recovery_workflows: "execute"
recovery_orchestrator.recovery_workflows -> recovery_orchestrator.state_manager: "update state"

# Cross-system recovery flows
recovery_orchestrator.failure_handler -> data_pipeline.fallback_cache: "data recovery"
recovery_orchestrator.failure_handler -> training_system.checkpoint_mgr: "training recovery"
recovery_orchestrator.failure_handler -> serving_layer.model_fallback: "serving recovery"

# Status reporting
recovery_orchestrator.state_manager -> detection_layer.health_monitor: "status updates" {
  style.stroke: "#fdcb6e"
}