{
  "types": {
    "Order": "fields: order_id str, symbol str, side OrderSide, order_type OrderType, quantity Decimal, price Optional[Decimal], timestamp Timestamp, participant_id str, filled_quantity Decimal, status OrderStatus",
    "Trade": "fields: trade_id str, symbol str, buy_order_id str, sell_order_id str, quantity Decimal, price Decimal, timestamp Timestamp, aggressive_side OrderSide, buy_participant_id str, sell_participant_id str",
    "Timestamp": "fields: nanos int",
    "TradingConfig": "fields: price_precision int, quantity_precision int, max_order_quantity Decimal, min_order_quantity Decimal, max_orders_per_second int, enable_metrics bool, max_price_levels int",
    "LatencyTracker": "fields: _samples list[float]",
    "OrderSide": "enum: BUY, SELL",
    "OrderType": "enum: LIMIT, MARKET",
    "OrderStatus": "values: PENDING, RESTING, PARTIALLY_FILLED, FILLED, CANCELLED",
    "PerformanceMonitor": "histogram-based latency tracking",
    "ThroughputCounter": "counter for orders per second calculation",
    "PriceLevel": "price level management class",
    "OrderBook": "main order book class with price-time priority",
    "RateLimitConfig": "fields: burst_limit int, burst_window int, sustained_limit int, sustained_window int, order_cancel_ratio float",
    "AuthenticationManager": "authentication system with token refresh",
    "TokenBucketRateLimiter": "thread-safe rate limiting implementation",
    "TradingRestAPI": "REST API endpoints for order management",
    "MarketDataPublisher": "WebSocket market data streaming",
    "MessageEnvelope": "fields: message_type MessageType, sequence_number int, timestamp Timestamp, request_id str, payload Dict[str, Any]",
    "AddOrderCommand": "fields: order Order, request_id str",
    "TradeExecutedEvent": "fields: trade Trade, aggressive_order Order, passive_order Order, timestamp Timestamp",
    "SequenceManager": "fields: _counter int, _lock threading.Lock",
    "EventBus": "fields: _subscribers Dict[MessageType, List[Callable]], _message_queue deque, _processing bool, _lock Lock",
    "OrderCoordinator": "fields: symbol str, order_book OrderBook, matching_engine MatchingEngine, market_data_publisher MarketDataPublisher",
    "MessageType": "values: ADD_ORDER_COMMAND, CANCEL_ORDER_COMMAND, MODIFY_ORDER_COMMAND, MATCH_ORDER_COMMAND, SHUTDOWN_COMMAND, ORDER_ADDED_EVENT, ORDER_CANCELLED_EVENT, ORDER_MODIFIED_EVENT, TRADE_EXECUTED_EVENT, PRICE_LEVEL_CHANGED_EVENT",
    "MatchingEngineException": "fields: message str, error_code str, severity ErrorSeverity, recovery_strategy RecoveryStrategy, context Dict, timestamp Timestamp",
    "DataCorruptionException": "fields: corrupted_component str, expected_state str, actual_state str",
    "OrderBookCorruptionException": "fields: order_id str, price_level Decimal, side OrderSide",
    "ResourceExhaustionException": "fields: resource_type str, current_usage float, maximum_capacity float, usage_percentage float",
    "ErrorSeverity": "enum: INFO, WARNING, ERROR, CRITICAL, FATAL",
    "RecoveryStrategy": "enum: NONE, RETRY, FALLBACK, ISOLATE, RESTART, SHUTDOWN",
    "CircuitState": "enum: CLOSED, OPEN, HALF_OPEN",
    "CircuitBreaker": "fields: name str, state CircuitState, failure_count int, success_count int, lock RLock",
    "InvariantValidator": "fields: validation_enabled bool, validation_lock RLock, validations_performed int",
    "RecoveryManager": "fields: recovery_enabled bool, active_recoveries Dict, recovery_history List",
    "RecoveryAction": "enum: VALIDATE_STATE, CLEANUP_RESOURCES, RESTART_COMPONENT, ISOLATE_COMPONENT",
    "LoadTestConfig": "configuration for load testing scenarios",
    "PerformanceTestHarness": "comprehensive performance testing framework",
    "OrderBuilder": "builder for creating test Order objects",
    "TradeBuilder": "builder for creating test Trade objects",
    "PropertyBasedTests": "property-based tests for order book invariants",
    "MilestoneCheckpoints": "automated validation for development milestones",
    "LogLevel": "enum: TRACE, DEBUG, INFO, WARN, ERROR",
    "LogEntry": "fields: timestamp str, sequence int, level str, component str, event str, thread_id str, context Dict[str, Any]",
    "LatencyHistogram": "fields: bucket_boundaries List[float], bucket_counts List[int], total_samples int, sum_latency float",
    "ValidationResult": "fields: is_valid bool, violations List[str], component str, severity str",
    "SymptomAnalyzer": "fields: known_patterns Dict",
    "AsyncStructuredLogger": "async logging with sequence numbers",
    "StopCondition": "enum: STOP_LOSS, STOP_LIMIT",
    "TriggerStatus": "enum: WAITING, TRIGGERED, EXPIRED",
    "ProcessingResult": "fields: should_continue bool, modifications List[str], reason str",
    "OrderTypeHandler": "interface for handling specific order types",
    "BusinessMetric": "fields: name str, value float, timestamp float, symbol Optional[str], participant_id Optional[str], tags Dict[str, str]",
    "ScalingConfig": "fields: enable_partitioning bool, partition_count int, partition_strategy str, enable_read_replicas bool, replica_count int, max_rebalance_frequency int",
    "MonitoringConfig": "fields: enable_metrics bool, metrics_port int, enable_distributed_tracing bool, log_level str, audit_log_retention_days int, alert_thresholds Dict[str, float]",
    "SecurityConfig": "fields: enable_authentication bool, jwt_secret_key str, token_expiry_seconds int, enable_rate_limiting bool, max_orders_per_second_per_participant int, enable_audit_logging bool",
    "ProductionConfig": "fields: trading TradingConfig, scaling ScalingConfig, monitoring MonitoringConfig, security SecurityConfig",
    "ExtensionPoint": "abstract base class for system extensions",
    "ExtensionRegistry": "central registry for managing extensions",
    "BusinessMetricsCollector": "collects and analyzes business metrics",
    "ProductionMonitor": "comprehensive monitoring system"
  },
  "methods": {
    "Timestamp.now() -> Timestamp": "get current nanosecond timestamp",
    "Timestamp.micros_since(earlier) -> float": "calculate microseconds elapsed",
    "Order.remaining_quantity() -> Decimal": "calculate unfilled quantity",
    "Order.is_fully_filled() -> bool": "check if completely filled",
    "Order.can_match_against(other) -> bool": "check matching compatibility",
    "LatencyTracker.record_micros(latency) -> None": "record latency sample",
    "LatencyTracker.get_percentiles() -> dict": "get latency statistics",
    "TradingConfig.from_environment() -> TradingConfig": "load config from env vars",
    "PerformanceMonitor.record_order_processing(start_time) -> None": "record order processing latency",
    "PerformanceMonitor.get_performance_report() -> dict": "get comprehensive performance summary",
    "OrderBook.add_order(order) -> bool": "add order to book with cross-spread detection",
    "OrderBook.cancel_order(order_id) -> Optional[Order]": "cancel order and cleanup empty levels",
    "OrderBook.get_order_by_id(order_id) -> Optional[Order]": "O(1) order lookup",
    "OrderBook.get_best_bid() -> Optional[Decimal]": "O(1) best bid price",
    "OrderBook.get_best_ask() -> Optional[Decimal]": "O(1) best ask price",
    "OrderBook.get_market_depth(side, max_levels) -> List[tuple]": "price levels for market data",
    "PriceLevel.add_order(order) -> None": "add to FIFO queue",
    "PriceLevel.remove_order(order) -> bool": "remove specific order",
    "PriceLevel.get_next_order() -> Order": "peek at front of queue",
    "PriceLevel.pop_front_order() -> Order": "remove from front",
    "PriceLevel.is_empty() -> bool": "check if no orders",
    "PriceLevel.get_total_quantity() -> Decimal": "aggregate quantity",
    "generate_token_pair(participant_id) -> Dict[str, str]": "generate access and refresh tokens",
    "validate_token(token) -> Optional[Dict]": "validate JWT token and return payload",
    "is_allowed(participant_id, request_type) -> tuple[bool, Optional[str]]": "check rate limits",
    "submit_order() -> response": "handle POST /orders endpoint",
    "cancel_order(order_id) -> response": "handle DELETE /orders/{order_id}",
    "modify_order(order_id) -> response": "handle PUT /orders/{order_id}",
    "get_order_status(order_id) -> response": "handle GET /orders/{order_id}",
    "handle_subscription(websocket, path) -> None": "handle WebSocket connections",
    "publish_order_book_update(symbol, side, price, new_qty, old_qty) -> None": "publish market data updates",
    "publish_trade_execution(trade) -> None": "publish trade executions",
    "_should_conflate_update(queue_depth, update_type) -> bool": "determine conflation strategy",
    "SequenceManager.next_sequence() -> int": "get next sequence number atomically",
    "SequenceManager.current_sequence() -> int": "get current sequence number without incrementing",
    "EventBus.subscribe(message_type, handler) -> None": "subscribe to specific message type",
    "EventBus.publish(message) -> None": "publish message to all subscribers",
    "MessageEnvelope.to_dict() -> Dict[str, Any]": "convert message to dictionary format",
    "OrderCoordinator._handle_add_order(message) -> None": "handle incoming add order command",
    "OrderCoordinator._handle_cancel_order(message) -> None": "handle order cancellation request",
    "OrderCoordinator._process_trade_execution(trade, remaining_quantity) -> None": "process completed trade and handle residual",
    "validate_order_book_structure(order_book) -> List[str]": "validate order book invariants and return violations",
    "validate_trade_consistency(trade, buy_order, sell_order) -> List[str]": "validate trade execution consistency",
    "call(func, *args, **kwargs) -> Any": "execute function with circuit breaker protection",
    "get_state_info() -> Dict[str, Any]": "get circuit breaker state and statistics",
    "handle_failure(component_name, failure_type, severity, context) -> bool": "handle component failure with recovery strategy",
    "get_recovery_status(component_name) -> Dict[str, Any]": "get status of recovery operations",
    "OrderBuilder.with_symbol(symbol) -> OrderBuilder": "set order symbol",
    "OrderBuilder.with_price(price) -> OrderBuilder": "set order price",
    "OrderBuilder.build() -> Order": "create configured order",
    "PerformanceTestHarness.run_load_test(config) -> Dict[str, Any]": "execute load test with metrics",
    "validate_milestone_1_order_book(order_book) -> bool": "validate milestone 1 completion",
    "validate_milestone_2_order_operations(coordinator) -> bool": "validate milestone 2 completion",
    "test_order_book_add_remove_invariant(orders) -> None": "property test for add/remove consistency",
    "test_price_time_priority_invariant(orders) -> None": "property test for FIFO ordering",
    "record_latency_micros(latency) -> None": "record latency sample in histogram",
    "get_percentile(percentile) -> Optional[float]": "calculate latency percentile",
    "validate_order_book_structure(order_book) -> ValidationResult": "validate all order book invariants",
    "validate_trade_consistency(trade, buy_order, sell_order) -> ValidationResult": "validate trade execution consistency",
    "analyze_symptoms(error_context) -> List[str]": "pattern match symptoms to likely causes",
    "start_timing(operation_id, operation_type) -> str": "begin timing operation",
    "end_timing(token) -> None": "end timing and record latency",
    "validate_order(order) -> ValidationResult": "checks order-specific validity rules",
    "pre_match_process(order, book) -> ProcessingResult": "handles pre-matching transformations",
    "should_rest_on_book(order, matches) -> bool": "determines if unfilled portion should rest",
    "post_match_cleanup(order, trades) -> None": "performs type-specific cleanup after matching",
    "get_extension_type() -> str": "return extension type identifier",
    "initialize(config) -> None": "initialize extension with configuration",
    "register_extension(extension) -> None": "register new extension with system",
    "get_extensions(extension_type) -> List[ExtensionPoint]": "get all extensions of specific type",
    "load_extensions_from_config(config) -> None": "dynamically load extensions from configuration",
    "load_from_environment() -> ProductionConfig": "load configuration from environment variables and files",
    "validate() -> List[str]": "validate configuration for consistency",
    "record_trade_execution(symbol, price, quantity) -> None": "record trade for market health analysis",
    "record_order_activity(symbol, participant_id, order_type, side) -> None": "record order activity for behavior analysis",
    "check_market_health() -> List[str]": "analyze metrics and return health warnings",
    "start_monitoring() -> None": "start all monitoring subsystems",
    "get_health_status() -> Dict[str, Any]": "get comprehensive system health status"
  },
  "constants": {
    "CONFIG": "global trading configuration instance",
    "SEQUENCE_MANAGER": "global sequence manager instance",
    "EVENT_BUS": "global event bus instance",
    "DEBUG_LOGGER": "global async structured logger",
    "PERFORMANCE_MONITOR": "global performance tracking",
    "EXTENSION_REGISTRY": "global extension registry instance"
  },
  "terms": {
    "price-time priority": "fairness rule where earlier orders at same price get precedence",
    "liquidity provider": "trader who places limit orders that rest on book",
    "liquidity taker": "trader who places market orders that match immediately",
    "order book": "data structure containing all resting buy and sell orders",
    "bid side": "buy orders organized by decreasing price",
    "ask side": "sell orders organized by increasing price",
    "matching engine": "component that executes trades between compatible orders",
    "self-trade prevention": "mechanism preventing orders from same participant matching each other",
    "cache line": "64-byte unit of CPU cache that affects memory access performance",
    "false sharing": "performance penalty when different threads modify data in same cache line",
    "scope creep": "gradual expansion of project requirements beyond original boundaries",
    "latency": "time delay for processing individual operations",
    "throughput": "number of operations processed per unit time",
    "percentile latency": "latency measurement at specific percentile of distribution",
    "cross-spread detection": "checking if limit order would trade immediately",
    "price level": "all orders at same price with FIFO queue",
    "time priority": "first-come first-served ordering within price levels",
    "empty level cleanup": "removing price levels with zero orders",
    "hash map lookup": "O(1) order access by ID",
    "tree rebalancing": "maintaining logarithmic depth for price lookups",
    "lock-free": "concurrent programming without blocking synchronization",
    "atomic operations": "indivisible operations that complete entirely or not at all",
    "compare-and-swap": "atomic operation that updates memory only if current value matches expected",
    "memory ordering": "rules governing when memory operations become visible to other threads",
    "object pooling": "reusing allocated objects to reduce garbage collection overhead",
    "memory barrier": "instruction that prevents CPU from reordering memory operations",
    "sequence number": "monotonically increasing identifier for event ordering",
    "conflation": "combining multiple updates to reduce bandwidth",
    "rate limiting": "controlling request frequency to prevent abuse",
    "token bucket": "algorithm for rate limiting with burst allowance",
    "WebSocket": "bidirectional communication protocol",
    "FIX protocol": "financial information exchange standard",
    "Level 1 data": "best bid and ask prices only",
    "Level 2 data": "full order book depth",
    "market data": "real-time information about trading activity",
    "incremental update": "delta containing only changes since last update",
    "snapshot": "complete current state at point in time",
    "event ordering": "ensuring all system participants observe same sequence of state changes",
    "causality tracking": "linking related events through reference IDs",
    "global sequence": "single source of truth for event ordering across all components",
    "message envelope": "standardized wrapper for all internal messages",
    "event bus": "message routing system for component communication",
    "dependency tracking": "ensuring events are processed respecting causal relationships",
    "invariant validation": "continuous checking that system constraints hold true",
    "circuit breaker": "automatic isolation mechanism for failing components",
    "graceful degradation": "maintaining reduced functionality during failures",
    "cascade failure": "failure in one component triggering failures in others",
    "data corruption": "system state becomes inconsistent with reality",
    "resource exhaustion": "system runs out of critical resources needed for operation",
    "recovery automation": "automatic procedures to restore system health",
    "audit trail": "comprehensive logging for regulatory compliance and forensic analysis",
    "failure mode": "specific way system can malfunction or break",
    "detection strategy": "method for identifying when failures occur",
    "recovery mechanism": "procedure for restoring normal operation after failure",
    "property-based testing": "automated testing approach using generated test cases to validate system properties",
    "load testing": "testing system behavior under realistic concurrent load",
    "stress testing": "testing system behavior beyond normal operating conditions",
    "regression testing": "testing to ensure new changes don't break existing functionality",
    "integration testing": "testing component interactions using real implementations",
    "unit testing": "testing individual components in isolation",
    "test data builders": "pattern for creating test objects with fluent interface",
    "milestone checkpoints": "validation criteria for development phase completion",
    "performance harness": "framework for systematic performance measurement",
    "symptom-cause-fix reference": "diagnostic table mapping observable problems to root causes and solutions",
    "structured logging": "JSON-formatted logs with consistent fields for automated analysis",
    "histogram-based tracking": "latency measurement using predefined bucket boundaries",
    "race condition reproduction": "controlled testing to expose concurrent operation failures",
    "performance degradation scenarios": "test cases for detecting gradual performance loss",
    "happens-before tracking": "causal ordering analysis for concurrent events",
    "lock-free operation tracing": "debugging atomic operations without blocking",
    "horizontal scaling": "scaling by adding more machines rather than upgrading existing ones",
    "symbol-based partitioning": "distributing load by assigning different trading instruments to different engine instances",
    "read replica scaling": "scaling market data consumption through multiple copies of order book state",
    "microservice decomposition": "breaking monolithic matching engine into specialized services",
    "extension point": "architectural pattern allowing new functionality without modifying core code",
    "business metrics": "measurements of market health and trading activity patterns",
    "disaster recovery": "procedures for maintaining operations during infrastructure failures",
    "load forecasting": "predicting future resource requirements based on historical patterns",
    "capacity planning": "ensuring system can handle expected growth and peak loads",
    "penetration testing": "security testing by qualified professionals",
    "tamper-evident logging": "cryptographically secured logs that detect modification attempts"
  }
}