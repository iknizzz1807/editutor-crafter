{
  "types": {
    "capture_engine_t": "opaque struct for capture state",
    "interface_info_t": "fields: name char[64], description char[256], supports_promiscuous bool, is_up bool",
    "raw_packet_t": "fields: timestamp packet_timestamp_t, length uint32_t, captured_length uint32_t, data uint8_t[]",
    "packet_timestamp_t": "seconds time_t, microseconds uint32_t",
    "ethernet_frame_t": "fields: dest_mac uint8_t[6], src_mac uint8_t[6], ethertype uint16_t, has_vlan_tag bool, payload uint8_t*, payload_length uint32_t, timestamp packet_timestamp_t",
    "packet_result_t": "enum: PACKET_SUCCESS, PACKET_ERROR_INVALID, PACKET_ERROR_TRUNCATED, PACKET_ERROR_UNSUPPORTED, PACKET_ERROR_PRIVILEGE, PACKET_ERROR_RESOURCE_EXHAUSTED, PACKET_ERROR_PERFORMANCE",
    "protocol_type_t": "enum: PROTO_ETHERNET, PROTO_IPV4, PROTO_IPV6, PROTO_TCP, PROTO_UDP, PROTO_ICMP, PROTO_UNKNOWN",
    "packet_ring_buffer_t": "fields: packets, capacity, head, tail, count, statistics",
    "error_code_t": "enum for error classification",
    "ip_packet_t": "fields: version ip_address_family_t, src_addr ip_address_t, dst_addr ip_address_t, protocol uint8_t, payload_length uint16_t, payload_data uint8_t*, is_fragmented bool, fragment_offset uint16_t, more_fragments bool, timestamp packet_timestamp_t",
    "ip_address_t": "family ip_address_family_t, addr union of ipv4[4] and ipv6[16]",
    "ip_address_family_t": "ADDR_FAMILY_IPV4, ADDR_FAMILY_IPV6",
    "ipv4_header_t": "version_ihl uint8_t, tos uint8_t, total_length uint16_t, identification uint16_t, flags_fragment uint16_t, ttl uint8_t, protocol uint8_t, checksum uint16_t, src_addr uint32_t, dst_addr uint32_t",
    "ipv6_header_t": "version_tc_fl uint32_t, payload_length uint16_t, next_header uint8_t, hop_limit uint8_t, src_addr[16] uint8_t, dst_addr[16] uint8_t",
    "ipv6_ext_header_t": "next_header uint8_t, length uint8_t",
    "ipv6_fragment_header_t": "next_header uint8_t, reserved uint8_t, offset_flags uint16_t, identification uint32_t",
    "tcp_header_t": "fields: src_port uint16_t, dst_port uint16_t, seq_num uint32_t, ack_num uint32_t, flags uint16_t, window_size uint16_t, payload_data uint8_t*, payload_length uint32_t",
    "udp_header_t": "fields: src_port uint16_t, dst_port uint16_t, length uint16_t, checksum uint16_t, payload_data uint8_t*, payload_length uint32_t",
    "transport_protocol_t": "enum: TRANSPORT_UNKNOWN, TRANSPORT_TCP, TRANSPORT_UDP, TRANSPORT_ICMP",
    "port_service_t": "fields: port uint16_t, service_name const char*, protocol transport_protocol_t, description const char*",
    "bpf_filter_t": "expression char[512], compiled_program void*, program_length size_t, is_valid bool",
    "bpf_compiler_t": "fields: error_buffer char[256], optimization_level int, target_arch enum",
    "bpf_instruction_t": "fields: opcode uint16_t, jt uint8_t, jf uint8_t, operand uint32_t",
    "filter_statistics_t": "fields: packets_examined uint64_t, packets_matched uint64_t, packets_dropped uint64_t",
    "display_filter_t": "expression char[1024], compiled_ast ast_node_t*, field_cache field_cache_t, case_sensitive bool",
    "ast_node_t": "type node_type_t, op operator_t, field field_ref_t, constant value_t, left ast_node_t*, right ast_node_t*",
    "field_ref_t": "fields: protocol char[32], field_name char[64], type field_type_t, offset size_t",
    "value_t": "fields: type value_type_t, data union, length size_t",
    "filter_cache_t": "fields: last_packet packet_id_t, field_values void*[MAX_CACHED_FIELDS], cache_valid bool",
    "output_formatter_t": "type format_type_t, show_timestamp bool, show_hex bool, colors color_scheme_t, output_file FILE*",
    "packet_summary_t": "fields: timestamp packet_timestamp_t, protocols protocol_stack_t, endpoints endpoint_pair_t, length uint32_t, status char[64]",
    "format_options_t": "fields: include_ethernet bool, include_ip_options bool, include_tcp_options bool, max_payload_bytes int",
    "color_scheme_t": "fields: timestamp color_t, protocol color_t, address color_t, flags color_t, error color_t",
    "format_type_t": "FORMAT_SUMMARY, FORMAT_DETAIL, FORMAT_HEX_DUMP, FORMAT_CUSTOM",
    "timestamp_format_t": "enum: TIMESTAMP_ABSOLUTE, TIMESTAMP_RELATIVE, TIMESTAMP_DELTA",
    "packet_error_t": "fields: code error_code_t, message char[256], context char[128], suggested_action char[256], timestamp_us uint64_t",
    "resource_limits_t": "fields: max_memory_bytes uint64_t, max_cpu_percent uint32_t, max_dropped_packets uint64_t, max_file_descriptors uint32_t",
    "resource_usage_t": "fields: memory_bytes uint64_t, cpu_percent uint32_t, packets_dropped uint64_t, file_descriptors_used uint32_t, memory_limit uint64_t",
    "traffic_statistics_t": "fields: packets_per_second double, processed_per_second double, bytes_per_second uint64_t",
    "test_results_t": "total_tests int, passed_tests int, failed_tests int, start_time struct timeval",
    "performance_stats_t": "fields: start_time_us uint64_t, total_packets uint64_t, total_bytes uint64_t, parse_time_us uint64_t, filter_time_us uint64_t, output_time_us uint64_t",
    "log_level_t": "enum: LOG_ERROR, LOG_WARN, LOG_INFO, LOG_DEBUG",
    "icmp_header_t": "fields: type uint8_t, code uint8_t, checksum uint16_t, rest_of_header uint32_t",
    "icmp_message_t": "parsed ICMP message structure",
    "flow_record_t": "fields: src_addr ip_address_t, dst_addr ip_address_t, src_port uint16_t, dst_port uint16_t, protocol transport_protocol_t, bytes_sent uint64_t, bytes_received uint64_t, packets_sent uint64_t, packets_received uint64_t, first_seen packet_timestamp_t, last_seen packet_timestamp_t, tcp_state tcp_connection_state_t, next_seq_sent uint32_t, next_seq_received uint32_t, is_active bool, timeout_seconds uint32_t, hash_next flow_record_t*",
    "flow_tracker_t": "fields: flow_table flow_record_t**, table_size size_t, active_flows size_t, max_flows size_t, bucket_locks pthread_rwlock_t*, cleanup_interval uint32_t, last_cleanup packet_timestamp_t, flows_created uint64_t, flows_expired uint64_t, flows_reset uint64_t",
    "lockfree_queue_t": "fields: packets raw_packet_t**, head volatile size_t, tail volatile size_t, capacity size_t, mask size_t",
    "processing_pipeline_t": "fields: capture_thread pthread_t, parser_threads pthread_t*, analysis_threads pthread_t*, output_thread pthread_t, num_parser_threads size_t, num_analysis_threads size_t, capture_queue lockfree_queue_t, parse_queue lockfree_queue_t, output_queue lockfree_queue_t, shutdown_requested volatile bool, startup_barrier pthread_barrier_t, thread_stats performance_stats_t[]",
    "thread_context_t": "thread-specific context structure",
    "tcp_connection_state_t": "TCP connection state enumeration",
    "benchmark_config_t": "fields: packet_count size_t, packet_size size_t, target_pps double, num_threads size_t, enable_analysis bool, enable_output bool"
  },
  "methods": {
    "capture_engine_create() returns capture_engine_t*": "create new capture engine instance",
    "capture_engine_list_interfaces(engine, interfaces, max_interfaces) returns int": "enumerate network interfaces",
    "capture_engine_start(engine, interface_name, promiscuous) returns packet_result_t": "start packet capture on interface",
    "capture_engine_next_packet(engine, packet, timeout_ms) returns packet_result_t": "capture next packet with timeout",
    "capture_engine_stop(engine) returns void": "stop packet capture",
    "capture_engine_destroy(engine) returns void": "cleanup capture engine",
    "parse_ethernet_frame(raw_packet, frame) returns packet_result_t": "parse Ethernet frame from raw packet",
    "ethernet_get_payload_protocol(frame) returns protocol_type_t": "determine protocol type from EtherType",
    "protocol_name(proto) returns const char*": "get string name for protocol type",
    "format_mac_address(mac, output) returns void": "format MAC address as colon-separated hex",
    "format_ip_address(ip, version, output) returns void": "format IP address as dotted decimal or IPv6",
    "timestamp_to_microseconds(ts) returns uint64_t": "convert timestamp to microseconds since epoch",
    "parse_ip_packet(eth_frame, ip_packet) returns packet_result_t": "parse IP header from Ethernet payload",
    "ip_protocol_name(protocol) returns const char*": "get string name for protocol number",
    "format_ip_address(addr, output, output_len) returns void": "format IP address as string",
    "parse_ipv4_packet(packet_data, data_len, ip_packet) returns packet_result_t": "parse IPv4 header with options",
    "parse_ipv6_packet(packet_data, data_len, ip_packet) returns packet_result_t": "parse IPv6 header chain",
    "format_ipv4_address(addr, output) returns void": "format IPv4 as dotted decimal",
    "format_ipv6_address(addr, output) returns void": "format IPv6 with compression",
    "validate_packet_bounds(packet, packet_len, offset, required_len) returns bool": "check buffer bounds safety",
    "parse_tcp_header(packet_data, data_len, tcp_header) returns packet_result_t": "parse TCP header from IP payload",
    "parse_udp_header(packet_data, data_len, udp_header) returns packet_result_t": "parse UDP header from IP payload",
    "tcp_has_flag(header, flag_mask) returns bool": "test if TCP flag is set",
    "format_tcp_flags(flags, output, output_len) returns void": "format flags as string",
    "lookup_port_service(port, protocol) returns const char*": "get service name for port",
    "bpf_compile_filter(expression, compiler, filter) returns": "compile text expression to bytecode",
    "bpf_validate_expression(expression) returns": "check syntax before compilation",
    "bpf_attach_to_interface(interface, filter) returns": "apply filter to capture interface",
    "bpf_get_statistics(filter, stats) returns": "retrieve filter performance metrics",
    "bpf_optimize_filter(filter, level) returns": "apply optimization passes to bytecode",
    "display_filter_compile(expression, filter) returns": "parse and compile filter expression",
    "display_filter_evaluate(filter, packet) returns": "test if packet matches filter",
    "display_filter_get_fields(filter, fields, max_fields) returns": "list fields referenced by filter",
    "display_filter_validate_syntax(expression) returns": "check expression syntax",
    "display_filter_optimize(filter) returns": "apply optimization passes",
    "format_packet_summary(packet, output, max_length) returns": "generate one-line summary",
    "format_packet_detail(packet, options, output, max_length) returns": "generate detailed breakdown",
    "format_hex_dump(data, length, offset, output, max_length) returns": "generate hex dump with ASCII",
    "export_to_pcap(packets, count, filename) returns": "write PCAP file for Wireshark",
    "format_timestamp(timestamp, format, output) returns": "format timestamp string",
    "ring_buffer_add_packet()": "add packet to ring buffer",
    "ring_buffer_get_packet()": "get packet from ring buffer",
    "parse_packet_stack()": "multi-layer protocol parsing",
    "apply_packet_filters()": "test packet against filters",
    "check_capture_privileges(interface_name, error) returns packet_result_t": "validate packet capture privileges",
    "validate_interface_access(interface_name, info, error) returns packet_result_t": "check interface accessibility",
    "validate_packet_bounds(packet, offset, required_len) returns bool": "check buffer bounds safety",
    "recover_from_parse_error(raw_packet, failed_protocol, partial_result, error) returns packet_result_t": "extract partial data from malformed packets",
    "monitor_system_resources(limits, current_usage, error) returns packet_result_t": "track system resource usage",
    "adaptive_buffer_management(ring_buffer, usage, stats) returns void": "adjust buffer policies based on load",
    "error_init(error) returns void": "initialize error structure",
    "error_set(error, code, message, context) returns void": "set error information",
    "log_message(level, component, format, ...) returns void": "write log message",
    "log_packet_error(error) returns void": "log packet error details",
    "test_framework_init() returns void": "initialize test framework",
    "test_case_run(test_name, test_func) returns void": "execute individual test case",
    "test_assert_equal_int(expected, actual, message) returns void": "validate integer equality",
    "test_assert_packet_result(expected, actual, message) returns void": "validate packet result codes",
    "generate_ethernet_frame(buffer, length, src_mac, dst_mac, ethertype, payload, payload_len) returns void": "create test Ethernet frames",
    "generate_ipv4_packet(buffer, length, src_ip, dst_ip, protocol, payload, payload_len) returns void": "create IPv4 test packets",
    "get_timestamp_microseconds() returns uint64_t": "get current timestamp in microseconds",
    "get_process_memory_usage(rss_bytes, vss_bytes) returns void": "get process memory statistics",
    "get_cpu_usage_percent() returns uint32_t": "get current CPU utilization",
    "validate_ethernet_frame(frame, error) returns packet_result_t": "validate Ethernet frame structure",
    "validate_ip_packet(packet, error) returns packet_result_t": "validate IP packet structure",
    "profiler_start_packet(stats) returns void": "begin packet processing timing",
    "profiler_end_parse(stats) returns void": "end parsing phase timing",
    "profiler_end_filter(stats) returns void": "end filtering phase timing",
    "profiler_end_packet(stats, packet_bytes) returns void": "complete packet processing timing",
    "parse_icmp_message(packet_data, data_len, icmp_msg) returns packet_result_t": "parse ICMP message from IP payload",
    "icmp_message_description(type, code) returns const char*": "get human-readable ICMP message description",
    "flow_tracker_create(max_flows, timeout_seconds) returns flow_tracker_t*": "create and initialize flow tracker",
    "flow_tracker_process_packet(tracker, ip_packet, tcp_header) returns packet_result_t": "add or update flow record from packet",
    "pipeline_create(num_parser_threads, num_analysis_threads, queue_capacity) returns processing_pipeline_t*": "initialize multi-threaded processing pipeline",
    "capture_thread_main(arg) returns void*": "capture thread main function with high priority",
    "parser_thread_main(arg) returns void*": "parser worker thread for protocol header processing",
    "run_performance_benchmark(config) returns test_results_t": "run comprehensive performance benchmark"
  },
  "constants": {
    "MAX_PACKET_SIZE": "65536 bytes maximum frame size",
    "ETHERNET_HEADER_LEN": "14 bytes standard header",
    "IPV4_MIN_HEADER_LEN": "20 bytes minimum header",
    "IPV6_HEADER_LEN": "40 bytes fixed header",
    "TCP_MIN_HEADER_LEN": "20 bytes minimum header",
    "UDP_HEADER_LEN": "8 bytes fixed header",
    "MAC_ADDRESS_LENGTH": "6 bytes MAC size",
    "MAC_STRING_LENGTH": "18 bytes formatted MAC",
    "ETHERTYPE_IPV4": "0x0800 IPv4 protocol",
    "ETHERTYPE_VLAN": "0x8100 VLAN tag",
    "ETHERTYPE_IPV6": "0x86DD IPv6 protocol",
    "MAX_IPV6_EXT_HEADERS": "255 maximum extension headers",
    "IPPROTO_ICMP": "1 ICMP protocol number",
    "IPPROTO_TCP": "6 TCP protocol number",
    "IPPROTO_UDP": "17 UDP protocol number",
    "IPPROTO_IPV6": "41 IPv6-in-IPv4 tunneling",
    "IPPROTO_ICMPV6": "58 ICMPv6 protocol number",
    "IPV6_EXT_HOPBYHOP": "0 hop-by-hop options header",
    "IPV6_EXT_ROUTING": "43 routing header",
    "IPV6_EXT_FRAGMENT": "44 fragment header",
    "IPV6_EXT_DSTOPTS": "60 destination options header",
    "TCP_FLAG_FIN": "0x0001 finish connection",
    "TCP_FLAG_SYN": "0x0002 synchronize sequence",
    "TCP_FLAG_RST": "0x0004 reset connection",
    "TCP_FLAG_PSH": "0x0008 push data immediately",
    "TCP_FLAG_ACK": "0x0010 acknowledgment valid",
    "TCP_FLAG_URG": "0x0020 urgent pointer valid",
    "PACKET_SUCCESS": "successful operation",
    "PACKET_ERROR_PRIVILEGE": "insufficient privileges",
    "PACKET_ERROR_TRUNCATED": "packet data truncated",
    "PACKET_ERROR_INVALID": "invalid packet format",
    "LOG_ERROR": "error log level",
    "LOG_INFO": "info log level",
    "PACKET_ERROR_RESOURCE_EXHAUSTED": "system resources exhausted",
    "PACKET_ERROR_PERFORMANCE": "performance limits exceeded",
    "PACKET_ERROR_UNSUPPORTED": "unsupported operation or protocol",
    "LOG_WARN": "warning log level",
    "LOG_DEBUG": "debug log level",
    "MIN_RING_BUFFER_SIZE": "minimum ring buffer capacity",
    "MAX_WORKER_THREADS": "maximum number of worker threads supported"
  },
  "terms": {
    "promiscuous mode": "network interface mode capturing all traffic",
    "EtherType": "16-bit field indicating payload protocol type",
    "Berkeley Packet Filter": "kernel-level packet filtering system",
    "libpcap": "cross-platform packet capture library providing unified API",
    "raw socket": "low-level socket bypassing normal protocol processing",
    "network byte order": "big-endian byte ordering used in network protocols",
    "VLAN tag": "802.1Q virtual LAN identifier inserted in Ethernet frame",
    "ring buffer": "circular buffer for high-performance packet storage",
    "Internet Header Length": "IPv4 header length field in 32-bit words",
    "extension header chain": "IPv6 linked list of optional headers",
    "fragmentation": "splitting large packets into smaller pieces",
    "Path MTU Discovery": "IPv6 mechanism to find maximum packet size",
    "More Fragments flag": "indicates additional fragments follow",
    "fragment offset": "position of fragment data in original packet",
    "data offset field": "TCP header length in 32-bit words",
    "well-known ports": "port numbers 0-1023 reserved for system services",
    "sequence number": "TCP byte position identifier for reliable delivery",
    "acknowledgment number": "next expected sequence number in TCP",
    "pseudo-header": "IP fields included in UDP checksum calculation",
    "zero-copy techniques": "accessing data through pointers without copying to improve performance",
    "service identification": "mapping port numbers to application protocols",
    "protocol dispatch table": "mapping protocol identifiers to parser functions",
    "fail-fast principle": "detect problems early in pipeline",
    "graceful degradation": "preserve partial results when errors occur",
    "lazy field extraction": "extract packet fields only when needed",
    "privilege escalation": "obtaining elevated system permissions",
    "packet validation hierarchy": "multi-layer validation system",
    "resource pressure": "system load approaching limits",
    "malformed packet recovery": "extracting data from corrupted packets",
    "hardware timestamping": "precise packet arrival timestamps generated by network interface card",
    "memory pressure detection": "monitoring system memory usage",
    "backpressure mechanisms": "signals to upstream components about processing capacity",
    "protocol dispatch registry": "system routing parsed transport payloads to appropriate application parsers",
    "connection tracking": "maintaining state information for network flows and connection lifecycles",
    "receive-side scaling": "hardware feature distributing incoming packets across multiple CPU cores",
    "lock-free queues": "thread-safe queues using atomic operations without mutex locks",
    "flow hash partitioning": "distributing flows across worker threads using consistent hashing",
    "anomaly detection": "identifying unusual network behavior patterns that deviate from baselines",
    "bandwidth monitoring": "tracking network utilization patterns and capacity consumption over time",
    "pipeline parallelism": "dividing processing workload across multiple stages running on separate threads"
  }
}