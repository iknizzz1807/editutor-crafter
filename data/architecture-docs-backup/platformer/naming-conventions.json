{
  "types": {
    "GameLoop": "isRunning: boolean, lastFrameTime: number, targetFPS: number, maxDeltaTime: number",
    "InputManager": "keys: Map, keyBuffer: Map, bufferDuration: number",
    "Entity": "x: number, y: number, width: number, height: number, velocityX: number, velocityY: number, onGround: boolean",
    "Vector2": "x: number, y: number",
    "Rectangle": "x: number, y: number, width: number, height: number",
    "Player": "extends Entity with health: number, coyoteTimer: number, jumpBuffer: number, invulnerabilityTimer: number",
    "Level": "width: number, height: number, tileSize: number, tiles: number[][], entities: Entity[]",
    "Enemy": "extends Entity with patrolStartX: number, patrolEndX: number, patrolSpeed: number, movingRight: boolean, health: number, defeated: boolean",
    "AnimationManager": "animations: Map, currentAnimation: string, frameIndex: number, frameTimer: number, isPlaying: boolean",
    "TextureAtlas": "image: Image, frameWidth: number, frameHeight: number, framesPerRow: number, frameCoords: Map",
    "SpriteRenderer": "context: Context, atlases: Map, spriteQueue: Array",
    "Camera": "worldX: number, worldY: number, targetX: number, targetY: number, screenWidth: number, screenHeight: number, deadzoneWidth: number, deadzoneHeight: number, followSpeed: number, lookAheadDistance: number",
    "ErrorManager": "errorCounts: Map, recentErrors: Array, maxRecentErrors: number, loggingEnabled: boolean",
    "PerformanceMonitor": "frameHistory: Array, maxHistorySize: number, performanceWarningThreshold: number, performanceCriticalThreshold: number, lastFrameTime: number",
    "DebugOverlay": "canvas: Canvas, context: Context, isVisible: boolean, metrics: Map, logs: Array, maxLogs: number",
    "InputDebugger": "inputManager: InputManager, inputHistory: Array, maxHistory: number",
    "GameExtension": "engine: Engine, enabled: boolean",
    "ParticleSystem": "particles: Array, maxParticles: number, effects: Map",
    "AnimationBlender": "currentBlend: BlendState, transitions: Map, blendWeight: number",
    "LevelEditor": "editorMode: boolean, selectedTile: number, clipboard: Array",
    "SpatialGrid": "cellSize: number, cells: Map, entities: Set",
    "PowerUpManager": "activePowerUps: Map, powerUpTypes: Map",
    "BlendState": "animationA: string, animationB: string, weight: number, duration: number"
  },
  "methods": {
    "start(updateCallback, renderCallback)": "begins game loop execution",
    "stop()": "halts game loop execution",
    "gameLoopStep()": "single frame update and render cycle",
    "isKeyPressed(keyCode)": "checks current key state",
    "wasKeyJustPressed(keyCode)": "checks if key pressed within buffer window",
    "consumeKeyPress(keyCode)": "removes buffered key press",
    "update(deltaTime, inputManager)": "updates entity state for one frame",
    "getBoundingBox()": "returns collision rectangle",
    "render(renderer)": "draws entity to screen",
    "getTileAt(x, y)": "returns tile ID at world coordinates",
    "getTileAtGrid(tileX, tileY)": "returns tile ID at grid coordinates",
    "worldToGrid(x, y)": "converts world pixels to grid coordinates",
    "gridToWorld(tileX, tileY)": "converts grid coordinates to world pixels",
    "isTileSolid(tileX, tileY)": "checks if tile blocks movement",
    "getBoundingBox() returns Rectangle": "returns collision rectangle for entity",
    "isTileSolid(tileX, tileY) returns boolean": "checks if tile blocks movement",
    "worldToGrid(x, y) returns object": "converts world pixels to grid coordinates",
    "gridToWorld(tileX, tileY) returns object": "converts grid coordinates to world pixels",
    "getTileAt(x, y) returns number": "returns tile ID at world coordinates",
    "intersectsAABB(rectA, rectB) returns boolean": "tests rectangle intersection",
    "takeDamage()": "applies damage to player with invulnerability check",
    "stomp()": "applies bounce effect after successful enemy stomp",
    "respawn()": "resets player to checkpoint location",
    "defeat()": "marks enemy as defeated",
    "handlePlayerEnemyInteraction(player, enemy)": "processes collision between player and enemy entities",
    "intersects(other) returns boolean": "checks if this entity overlaps with another entity",
    "getTileAtGrid(tileX, tileY) returns number": "returns tile ID at grid coordinates",
    "activateCheckpoint(checkpointId)": "activates specified checkpoint",
    "getActiveCheckpoint()": "returns current respawn point",
    "respawnPlayer(player)": "handles player respawn mechanics",
    "loadAnimations(animationData)": "loads animation definitions from JSON data",
    "setAnimation(name)": "switches to new animation sequence",
    "update(deltaTime)": "processes extension logic each frame",
    "getCurrentFrame()": "returns current frame ID for sprite lookup",
    "calculateFrameCoordinates()": "pre-calculates all frame coordinates in atlas",
    "getFrameCoords(frameId)": "returns source rectangle for frame in atlas",
    "renderSprite(entity, camera)": "renders single entity sprite with animation frame",
    "renderSpriteBatch(sprites, atlas, camera)": "batch renders multiple sprites sharing same texture",
    "renderTileMap(level, camera)": "renders tile map with viewport culling",
    "worldToScreen(worldX, worldY)": "transforms world coordinates to screen coordinates",
    "getVisibleTiles(level)": "calculates visible tile range for viewport culling",
    "logError(category, message, context)": "logs categorized error with recovery",
    "recordFrame(frameTime, deltaTime)": "tracks frame performance metrics",
    "emergencyEntitySeparation(entityA, entityB)": "separates overlapping entities",
    "validateEntityPosition(entity, level)": "checks entity position validity",
    "reconcileInputState(inputManager)": "synchronizes input state",
    "updatePerformance(frameTime)": "updates performance monitoring state",
    "intersectsAABB(rectA, rectB)": "tests rectangle intersection",
    "toggle()": "toggles debug overlay visibility",
    "setMetric(name, value)": "updates debug metric display",
    "log(message)": "adds debug message to overlay",
    "render()": "draws debug overlay to canvas",
    "recordFrame()": "tracks frame timing and detects issues",
    "getAverageFrameTime() returns number": "calculates average frame duration",
    "getFrameRate() returns number": "calculates current frame rate",
    "validateEntityPosition(entity, level) returns boolean": "checks entity position validity",
    "recordInputState()": "captures input system state",
    "reconcileInputState()": "synchronizes input state",
    "initialize()": "sets up extension systems and event listeners",
    "render(renderer, camera)": "draws extension visuals",
    "cleanup()": "releases extension resources",
    "enable()": "activates extension functionality",
    "disable()": "deactivates extension functionality",
    "spawnEffect(effectName, position)": "creates particle effect at location",
    "blendAnimations(animA, animB, weight)": "interpolates between two animations",
    "placeTile(x, y, tileId)": "adds tile at grid coordinates",
    "queryRegion(bounds) returns Array": "returns entities within spatial region",
    "activatePowerUp(type, duration)": "applies power-up effect to player"
  },
  "constants": {
    "targetFPS": "60 target frames per second",
    "maxDeltaTime": "33.33ms minimum framerate cap",
    "bufferDuration": "0.1 seconds input buffer window",
    "GRAVITY": "980 pixels per second squared",
    "TERMINAL_VELOCITY": "600 maximum falling speed",
    "COYOTE_TIME": "0.1 seconds jump grace period",
    "TILE_SIZE": "32 pixels per tile",
    "COLLISION_EPSILON": "0.01 minimum separation distance",
    "frameDuration": "0.083 seconds for 12fps animation",
    "followSpeed": "3.0 camera interpolation rate",
    "deadzoneWidth": "150 pixels horizontal deadzone",
    "deadzoneHeight": "100 pixels vertical deadzone",
    "lookAheadDistance": "80 pixels look-ahead offset",
    "performanceWarningThreshold": "20ms frame time warning",
    "performanceCriticalThreshold": "33.33ms critical frame time",
    "maxHistorySize": "300 frames for 5 seconds at 60fps",
    "maxRecentErrors": "50 maximum stored error records",
    "maxHistory": "300 input state records",
    "maxParticles": "1000 maximum active particles",
    "cellSize": "128 pixels per spatial grid cell",
    "blendDuration": "0.2 seconds for animation transitions",
    "editorGridSize": "32 pixels matching tile size",
    "powerUpDuration": "10 seconds default power-up time"
  },
  "terms": {
    "delta time": "time elapsed since last frame update",
    "frame-rate independence": "consistent behavior across different display refresh rates",
    "input buffering": "remembering button presses for short time window",
    "AABB": "Axis-Aligned Bounding Box for collision detection",
    "penetration resolution": "separating overlapping objects after collision",
    "theatrical physics": "game physics prioritizing feel over realism",
    "coyote time": "allowing jumps briefly after leaving platform",
    "spiral of death": "performance degradation when frame processing exceeds frame time",
    "terminal velocity": "maximum falling speed limit",
    "collision epsilon": "minimum separation distance for floating point precision",
    "jump buffering": "remembering button presses for short time window",
    "stomp detection": "determining when player defeats enemy by landing on top",
    "patrol AI": "simple back-and-forth enemy movement pattern",
    "invulnerability frames": "temporary damage immunity after taking hit",
    "tilemap": "2D grid of tile IDs representing level geometry",
    "checkpoint": "save point for player respawn after death",
    "collision geometry": "physical boundaries derived from tile data",
    "spatial indexing": "organizing game objects by location for efficient queries",
    "coordinate conversion": "transforming between world pixels and tile grid positions",
    "proximity detection": "checking distance for checkpoint activation",
    "unlock conditions": "requirements for checkpoint availability",
    "intent-based actions": "discrete player intentions like jumping that should be buffered",
    "state-based actions": "continuous player control like movement that should be checked directly",
    "flip-book animation": "sequential sprite frames creating motion illusion",
    "deadzone": "screen region where player moves without camera adjustment",
    "look-ahead": "camera offset showing more area in movement direction",
    "viewport culling": "skipping rendering of off-screen elements",
    "exponential decay": "smooth interpolation that slows as target approaches",
    "texture atlas": "single image containing multiple sprite frames",
    "sprite batching": "grouping similar sprites for efficient rendering",
    "pixel-perfect positioning": "rounding coordinates to avoid sub-pixel blurriness",
    "boundary constraints": "preventing camera from showing areas outside level",
    "coordinate transformation": "converting between world space and screen space",
    "graceful degradation": "maintaining core functionality while sacrificing secondary features",
    "delta time clamping": "limiting maximum time step to prevent physics instability",
    "emergency collision recovery": "fallback separation when normal resolution fails",
    "input desynchronization": "input system state diverging from hardware state",
    "cascade effect": "small errors amplifying into game-breaking behavior",
    "tunneling": "entity passing through collision geometry between frames",
    "corner clipping": "entities getting stuck at tile intersections",
    "temporal accuracy": "correct timing behavior in frame-rate independent systems",
    "trajectory analysis": "recording and analyzing entity movement paths over time",
    "boundary condition validation": "testing system behavior at parameter limits",
    "integration bugs": "errors that occur when systems interact",
    "performance degradation": "declining system performance over time",
    "progressive enhancement": "additive features that don't break existing functionality",
    "object pooling": "reusing allocated objects to reduce garbage collection",
    "state-driven animation": "automatic animation selection based on entity state",
    "effect templates": "predefined particle behavior patterns",
    "extension integration pattern": "consistent approach for adding modular functionality",
    "temporal optimization": "spreading expensive calculations across multiple frames",
    "content validation": "automated checking of level design quality"
  }
}