{
  "title": "2D Platformer Game Engine: Design Document",
  "overview": "A 2D platformer game engine that implements real-time physics simulation, collision detection, and game state management. The key architectural challenge is creating a responsive, frame-rate independent physics system that handles complex interactions between player movement, environmental collision, and game entities while maintaining smooth 60fps gameplay.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Establishes the core challenges of real-time game physics, input responsiveness, and collision detection in 2D platformer games.",
      "subsections": [
        {
          "id": "game-physics-mental-model",
          "title": "Game Physics Mental Model",
          "summary": "Introduces the concept of game physics as a simplified simulation of reality with emphasis on feel over realism"
        },
        {
          "id": "existing-approaches",
          "title": "Existing Platformer Approaches",
          "summary": "Compares different architectural patterns used in successful 2D platformers"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what the platformer engine must accomplish and explicitly excludes advanced features to maintain focus.",
      "subsections": []
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Component overview showing the game loop, entity system, physics engine, and rendering pipeline interactions.",
      "subsections": [
        {
          "id": "component-responsibilities",
          "title": "Component Responsibilities",
          "summary": "Defines the role and scope of each major system component"
        },
        {
          "id": "module-structure",
          "title": "Recommended Module Structure",
          "summary": "File and directory organization for maintainable code architecture"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Core data structures for entities, physics properties, level representation, and game state.",
      "subsections": [
        {
          "id": "entity-structure",
          "title": "Entity Data Structure",
          "summary": "Player, enemy, and game object representation with position, velocity, and collision properties"
        },
        {
          "id": "level-data",
          "title": "Level Data Structure",
          "summary": "Tile-based level representation and collision geometry storage"
        }
      ]
    },
    {
      "id": "game-loop",
      "title": "Game Loop and Time Management",
      "summary": "Implements frame-rate independent updates using delta time and manages the main game execution cycle.",
      "subsections": [
        {
          "id": "delta-time-system",
          "title": "Delta Time System",
          "summary": "Frame-rate independent physics calculations using elapsed time between frames"
        },
        {
          "id": "update-order",
          "title": "Update Order and Phases",
          "summary": "Sequence of input processing, physics updates, collision resolution, and rendering"
        }
      ]
    },
    {
      "id": "physics-engine",
      "title": "Physics Engine",
      "summary": "Velocity-based movement system with gravity, acceleration, and terminal velocity constraints.",
      "subsections": [
        {
          "id": "movement-physics",
          "title": "Movement Physics",
          "summary": "Horizontal movement with acceleration, friction, and velocity-based positioning"
        },
        {
          "id": "gravity-system",
          "title": "Gravity and Falling",
          "summary": "Downward acceleration with terminal velocity and ground state detection"
        },
        {
          "id": "jump-mechanics",
          "title": "Jump Mechanics",
          "summary": "Variable height jumping with coyote time and input buffering for responsive controls"
        }
      ]
    },
    {
      "id": "collision-system",
      "title": "Collision Detection and Resolution",
      "summary": "AABB collision detection against tile-based levels with separate axis resolution to prevent corner clipping.",
      "subsections": [
        {
          "id": "aabb-detection",
          "title": "AABB Collision Detection",
          "summary": "Axis-aligned bounding box intersection testing against tile geometry"
        },
        {
          "id": "collision-resolution",
          "title": "Collision Resolution",
          "summary": "Separating X and Y axis collision handling to resolve corner cases and tunneling"
        },
        {
          "id": "tile-collision",
          "title": "Tile-based Collision",
          "summary": "Efficient collision testing against tile grid with one-way platform support"
        }
      ]
    },
    {
      "id": "entity-system",
      "title": "Entity System",
      "summary": "Player character and enemy entities with AI behavior, health systems, and interaction handling.",
      "subsections": [
        {
          "id": "player-entity",
          "title": "Player Entity",
          "summary": "Player character implementation with input handling and state management"
        },
        {
          "id": "enemy-ai",
          "title": "Enemy AI System",
          "summary": "Simple patrol behavior with waypoint-based movement and collision response"
        },
        {
          "id": "entity-interactions",
          "title": "Entity Interactions",
          "summary": "Player-enemy collision detection with different outcomes based on contact direction"
        }
      ]
    },
    {
      "id": "level-system",
      "title": "Level System",
      "summary": "Tile-based level loading, rendering, and checkpoint management for player respawn.",
      "subsections": [
        {
          "id": "tilemap-loading",
          "title": "Tilemap Loading",
          "summary": "Loading level data from files and converting to collision geometry"
        },
        {
          "id": "checkpoint-system",
          "title": "Checkpoint System",
          "summary": "Save points for player respawn after death with activation tracking"
        }
      ]
    },
    {
      "id": "input-system",
      "title": "Input System",
      "summary": "Responsive input handling with buffering and state tracking for smooth controls.",
      "subsections": [
        {
          "id": "input-buffering",
          "title": "Input Buffering",
          "summary": "Capturing and queuing input events to improve responsiveness"
        },
        {
          "id": "control-mapping",
          "title": "Control Mapping",
          "summary": "Mapping keyboard and gamepad inputs to game actions"
        }
      ]
    },
    {
      "id": "rendering-system",
      "title": "Rendering System",
      "summary": "2D graphics rendering with sprite animation, tilemap rendering, and camera management.",
      "subsections": [
        {
          "id": "sprite-rendering",
          "title": "Sprite Rendering",
          "summary": "Entity and tile sprite rendering with animation frame management"
        },
        {
          "id": "camera-system",
          "title": "Camera System",
          "summary": "Camera following player with smooth tracking and boundary constraints"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Handling physics edge cases, collision tunneling, and graceful degradation of game systems.",
      "subsections": []
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Verification approaches for physics behavior, collision accuracy, and gameplay feel with milestone checkpoints.",
      "subsections": []
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common issues learners encounter with physics simulation, collision detection, and input handling.",
      "subsections": []
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements including advanced physics, particle effects, and level editor capabilities.",
      "subsections": []
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of game development and physics simulation terminology used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "System Architecture Overview",
      "description": "Shows the main game systems (Game Loop, Physics Engine, Collision System, Entity System, Rendering System, Input System) and their relationships. Includes data flow between systems and the main update cycle.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "game-loop"
      ]
    },
    {
      "id": "entity-data-model",
      "title": "Entity Data Model",
      "description": "Class diagram showing Entity base class, Player and Enemy subclasses, and their properties (position, velocity, dimensions, state). Shows relationships to physics and collision components.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "entity-system"
      ]
    },
    {
      "id": "physics-update-flow",
      "title": "Physics Update Flow",
      "description": "Flowchart showing the physics update sequence: apply gravity, process input, update velocity, update position, check collisions, resolve collisions. Shows decision points for ground detection and collision response.",
      "type": "flowchart",
      "relevant_sections": [
        "physics-engine",
        "collision-system"
      ]
    },
    {
      "id": "collision-resolution-sequence",
      "title": "Collision Resolution Sequence",
      "description": "Sequence diagram showing the interaction between Entity, Physics Engine, and Collision System during a collision event. Shows X-axis and Y-axis resolution steps and state updates.",
      "type": "sequence",
      "relevant_sections": [
        "collision-system",
        "physics-engine"
      ]
    },
    {
      "id": "player-state-machine",
      "title": "Player State Machine",
      "description": "State machine diagram showing player states (Grounded, Falling, Jumping, Dead) and transitions based on input events and physics conditions. Shows coyote time and jump buffer states.",
      "type": "state-machine",
      "relevant_sections": [
        "entity-system",
        "physics-engine"
      ]
    },
    {
      "id": "game-loop-cycle",
      "title": "Game Loop Execution Cycle",
      "description": "Flowchart showing the main game loop phases: process input, update entities, update physics, resolve collisions, update camera, render frame. Shows timing and delta time calculation.",
      "type": "flowchart",
      "relevant_sections": [
        "game-loop",
        "rendering-system"
      ]
    },
    {
      "id": "tile-collision-grid",
      "title": "Tile-based Collision System",
      "description": "Component diagram showing how entities interact with the tile grid, including tile lookup, AABB testing, and collision geometry. Shows one-way platform handling.",
      "type": "component",
      "relevant_sections": [
        "collision-system",
        "level-system"
      ]
    },
    {
      "id": "enemy-ai-behavior",
      "title": "Enemy AI Behavior Flow",
      "description": "Flowchart showing enemy patrol AI logic: move toward waypoint, check boundaries, reverse direction, handle collision with player. Shows decision points for patrol bounds and player interaction.",
      "type": "flowchart",
      "relevant_sections": [
        "entity-system"
      ]
    }
  ]
}