{
  "types": {
    "process_info_t": "fields: pid_t pid, int stdin_fd, int stdout_fd, char* command, int status",
    "sig_atomic_t": "atomic signal counter type",
    "worker_t": "fields: process_info_t* process, int is_busy, struct worker* next",
    "worker_pool_t": "fields: worker_t* workers, int pool_size, int active_count, sig_atomic_t child_died",
    "pipe_pair_t": "fields: int parent_to_child[2], int child_to_parent[2]",
    "message_header_t": "fields: uint32_t length, uint16_t type, uint16_t sequence",
    "error_context_t": "fields: int error_code, error_severity_t severity, error_category_t category, pid_t process_id, int file_descriptor, char context_info[256], uint64_t timestamp",
    "recovery_state_t": "fields: int retry_count, uint64_t last_attempt, uint64_t backoff_delay, int consecutive_failures",
    "error_severity_t": "enum: ERROR_SEVERITY_INFO, ERROR_SEVERITY_WARNING, ERROR_SEVERITY_ERROR, ERROR_SEVERITY_CRITICAL",
    "error_category_t": "enum: ERROR_CATEGORY_TEMPORARY, ERROR_CATEGORY_PERMANENT, ERROR_CATEGORY_FATAL",
    "resource_baseline_t": "fields: int initial_fd_count, int initial_process_count, size_t initial_memory_usage, struct timespec start_time",
    "stress_config_t": "fields: int num_workers, int tasks_per_second, int test_duration_seconds, double failure_injection_rate",
    "extension_t": "fields: char name[64], int (*initialize)(void* config), int (*cleanup)(void), void* handle, struct extension_t* next",
    "extension_manager_t": "fields: extension_t* extensions, int extension_count, char config_path[256]",
    "metric_t": "fields: char name[128], double value, uint64_t timestamp, char labels[256], struct metric_t* next",
    "metrics_collector_t": "fields: metric_t* metrics, int metric_count, pthread_mutex_t lock, int collection_interval_ms",
    "resource_limits_t": "fields: size_t memory_limit, int cpu_percent, int fd_limit"
  },
  "methods": {
    "spawn_process(command)": "creates new child process with bidirectional pipes",
    "send_to_process(proc, data, len)": "writes data to child stdin",
    "read_from_process(proc, buffer, len)": "reads data from child stdout",
    "fork()": "creates child process copy",
    "exec()": "replaces process image with new program",
    "pipe()": "creates pipe file descriptor pair",
    "dup2()": "redirects file descriptors",
    "waitpid()": "waits for child process termination",
    "cleanup_process(proc)": "waits for termination and cleans resources",
    "create_bidirectional_pipes(p2c, c2p)": "creates pipe pairs for communication",
    "setup_child_redirection(p2c, c2p)": "redirects child stdin/stdout to pipes",
    "setup_parent_pipes(p2c, c2p, write_fd, read_fd)": "configures parent pipe endpoints",
    "initialize_worker_pool(num_workers, command)": "creates worker pool with specified size",
    "distribute_task(pool, task_data, size)": "assigns task to available worker",
    "collect_results(pool, results, max_results)": "gathers output from workers",
    "sigchld_handler(signal)": "handles worker termination signals",
    "handle_worker_failures(pool)": "replaces failed workers",
    "create_process_info(command)": "creates and initializes process_info_t structure",
    "setup_signal_handlers()": "configures SIGCHLD and self-pipe",
    "process_terminated_children(pool)": "collects zombie processes and respawns workers",
    "send_task_to_worker(worker, data, len)": "sends work assignment message to worker",
    "receive_worker_message(worker, header, payload)": "reads and parses message from worker",
    "handle_worker_termination(pool, worker)": "cleans up terminated worker and spawns replacement",
    "read_message_header(fd, header)": "reads fixed-size message header",
    "write_message(fd, type, seq, payload, len)": "writes complete message with header",
    "validate_message_header(header)": "checks header fields for validity",
    "create_error_context(error_code, context)": "creates error context with diagnostics",
    "categorize_error(error_code, operation)": "determines error handling strategy",
    "should_retry_operation(state, category)": "decides if retry should be attempted",
    "update_recovery_state(state, success)": "updates retry state after attempt",
    "cleanup_signal_handlers()": "restores default signal handling",
    "cleanup_leaked_resources()": "closes leaked file descriptors",
    "check_resource_health()": "monitors system resource usage",
    "establish_resource_baseline()": "records current system resource usage",
    "detect_resource_leaks(baseline)": "compares current usage to baseline",
    "generate_test_data(buffer, size, pattern)": "fills buffer with test pattern",
    "verify_test_data(received, size, expected_pattern)": "validates received data matches expected pattern",
    "establish_resource_baseline() returns resource_baseline_t": "records current system resource usage",
    "detect_resource_leaks(baseline) returns int": "compares current usage to baseline",
    "count_open_fds() returns int": "counts file descriptors in /proc/self/fd",
    "get_memory_usage() returns size_t": "reads VmRSS from /proc/self/status",
    "dump_file_descriptors() returns void": "logs all open file descriptors",
    "install_debug_signal_handlers() returns void": "sets up SIGUSR1 for debug dumps",
    "log_process_state(context) returns void": "logs comprehensive process state",
    "debug_spawn_process(command) returns process_info_t*": "debugging wrapper for process creation",
    "debug_initialize_worker_pool(num_workers, command) returns worker_pool_t*": "debugging wrapper for pool creation",
    "debug_sigchld_handler(signal) returns void": "debugging wrapper for signal handler",
    "spawn_process(command) returns process_info_t*": "creates new child process with bidirectional pipes",
    "initialize_worker_pool(num_workers, command) returns worker_pool_t*": "creates worker pool with specified size",
    "sigchld_handler(signal) returns void": "handles worker termination signals",
    "fork() returns pid_t": "creates child process copy",
    "exec() returns int": "replaces process image with new program",
    "waitpid(pid, status, options) returns pid_t": "waits for child process termination",
    "create_extension_manager(config_path) returns extension_manager_t*": "creates extension manager with configuration",
    "load_extension(manager, name, library_path) returns int": "loads extension from shared library",
    "create_metrics_collector(interval_ms) returns metrics_collector_t*": "creates metrics collector",
    "record_metric(collector, name, value, labels) returns void": "records metric value thread-safely",
    "monitor_worker_health(worker, metrics) returns int": "monitors worker process resource usage",
    "check_system_health(pool, metrics) returns int": "comprehensive system health check",
    "apply_resource_limits(worker_pid, limits) returns int": "applies resource limits to worker process",
    "monitor_resource_compliance(worker, limits) returns int": "monitors resource usage against limits"
  },
  "constants": {
    "SIGCHLD": "signal sent when child terminates",
    "WNOHANG": "non-blocking wait option",
    "O_NONBLOCK": "non-blocking file descriptor flag",
    "PIPE_READ_END": "array index 0 for pipe read descriptor",
    "PIPE_WRITE_END": "array index 1 for pipe write descriptor",
    "STDIN_FILENO": "file descriptor 0 for standard input",
    "STDOUT_FILENO": "file descriptor 1 for standard output",
    "MSG_TASK_ASSIGNMENT": "message type value 1",
    "MSG_TASK_RESULT": "message type value 2",
    "MSG_WORKER_READY": "message type value 3",
    "MSG_WORKER_ERROR": "message type value 4",
    "MSG_SHUTDOWN_REQUEST": "message type value 5",
    "MSG_SHUTDOWN_ACK": "message type value 6",
    "MAX_MESSAGE_SIZE": "64KB maximum message size",
    "SA_RESTART": "restart interrupted system calls",
    "FD_CLOEXEC": "close-on-exec file descriptor flag",
    "EAGAIN": "resource temporarily unavailable",
    "ENOMEM": "out of memory",
    "ENOENT": "no such file or directory",
    "EACCES": "permission denied",
    "EPIPE": "broken pipe",
    "EINTR": "interrupted system call",
    "SIGUSR1": "user-defined signal for debugging",
    "STDERR_FILENO": "standard error file descriptor",
    "RLIMIT_AS": "virtual memory limit",
    "RLIMIT_RSS": "resident set size limit",
    "RLIMIT_CPU": "CPU time limit",
    "RLIMIT_NOFILE": "file descriptor limit",
    "CLOCK_MONOTONIC": "monotonic clock for timing"
  },
  "terms": {
    "fork": "system call that creates child process",
    "exec": "system call that replaces process image",
    "pipe": "unidirectional communication channel",
    "zombie process": "terminated child waiting for parent acknowledgment",
    "file descriptor": "integer handle for open files/pipes",
    "signal handler": "function called when signal received",
    "Process Manager": "component handling process lifecycle operations",
    "IPC Handler": "component managing inter-process communication",
    "Worker Pool Management": "component coordinating multiple worker processes",
    "bidirectional communication": "two-way data flow between parent and child",
    "message framing": "determining message boundaries in byte stream",
    "async-signal-safe": "functions safe to call from signal handlers",
    "length-prefixed": "message format with size header",
    "graceful shutdown": "coordinated termination with cleanup",
    "race condition": "timing-dependent bug in concurrent code",
    "deadlock": "mutual blocking where no process can proceed",
    "self-pipe trick": "technique for safe signal handling in event loops",
    "resource leak": "failure to release allocated system resources",
    "cascading failure": "failure that triggers additional failures",
    "circuit breaker": "pattern that stops operations when failure rate is high",
    "backoff": "increasing delay between retry attempts",
    "process spawner": "system that creates and manages child processes",
    "stress testing": "testing system under extreme load conditions",
    "integration testing": "testing multiple components working together",
    "milestone validation": "verifying each development stage meets requirements",
    "failure injection": "deliberately introducing errors to test recovery",
    "strace": "system call tracer for debugging process behavior",
    "debugging": "systematic process of finding and fixing bugs",
    "system call": "interface between user programs and kernel",
    "extension": "pluggable component that adds functionality",
    "metrics collection": "gathering performance and health data",
    "resource limits": "constraints on system resource usage",
    "process monitoring": "tracking process behavior and resource consumption",
    "sandboxing": "security isolation for processes",
    "privilege dropping": "reducing process privileges for security",
    "CPU affinity": "binding processes to specific CPU cores",
    "NUMA awareness": "optimizing for Non-Uniform Memory Access",
    "chaos engineering": "controlled failure injection for testing",
    "distributed tracing": "request tracking across process boundaries",
    "process spawning": "system that creates and manages child processes"
  }
}