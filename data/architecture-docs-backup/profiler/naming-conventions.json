{
  "types": {
    "ProfilerConfig": "sampling: SamplingConfig, symbols: SymbolConfig, visualization: VisualizationConfig, output_directory: str",
    "SamplingConfig": "frequency_hz: int, max_stack_depth: int, include_kernel: bool, target_overhead_percent: float",
    "SymbolConfig": "enable_dwarf: bool, cache_symbols: bool, demangle_cpp: bool, symbol_search_paths: List[str]",
    "VisualizationConfig": "color_scheme: str, min_width_pixels: int, title: str, enable_search: bool, enable_zoom: bool",
    "Profile": "collected profiling data with samples and metadata",
    "Sample": "timestamp: float, thread_id: int, process_id: int, stack_frames: List[StackFrame], cpu_id: int, sample_weight: int, context_switches: int, sample_type: SampleType",
    "StackFrame": "address: int, function_name: str, filename: str, line_number: int, module_name: str, module_offset: int, inlined_frames: List[InlinedFrame], is_kernel: bool",
    "InlinedFrame": "function_name: str, filename: str, line_number: int, call_filename: str, call_line_number: int",
    "SampleBatch": "samples List[Sample], start_time float, end_time float, dropped_samples int, target_process str, sampling_frequency int, total_sample_time float",
    "Symbol": "start_address: int, end_address: int, function_name: str, raw_name: str, source_file: str, line_ranges: List[LineRange], parameter_types: List[str], return_type: str, is_inlined: bool, compilation_unit: str",
    "LineRange": "start_address: int, end_address: int, line_number: int, column_number: int, is_statement: bool, is_prologue_end: bool, is_epilogue_begin: bool",
    "Module": "name: str, path: str, base_address: int, size: int, build_id: str, symbols: Dict[int, Symbol], has_debug_info: bool, architecture: str, load_time: float",
    "SymbolCache": "address_to_symbol: Dict[int, Symbol], module_cache: Dict[str, Module], demangled_names: Dict[str, str], miss_cache: Set[int], cache_size_bytes: int, max_cache_size: int, hit_count: int, miss_count: int",
    "Allocation": "allocation_id: int, size: int, actual_size: int, timestamp: float, thread_id: int, allocation_stack: List[StackFrame], allocation_type: AllocationType, is_freed: bool, free_timestamp: float, free_thread_id: int",
    "MemorySnapshot": "timestamp float, total_allocated int, total_freed int, live_bytes int, live_allocations int, heap_size int, allocation_rate float, free_rate float",
    "MemoryLeak": "allocation: Allocation, leak_confidence: float, leak_category: LeakCategory, allocation_age: float, similar_leaks: int, total_leaked_bytes: int, detection_method: str, suppression_matched: str",
    "AllocationSite": "call_stack_hash: int, representative_stack: List[StackFrame], total_allocations: int, total_bytes: int, peak_live_bytes: int, peak_live_count: int, lifetime_distribution: List[int], first_seen: float, last_seen: float",
    "RegisterContext": "instruction_pointer int, stack_pointer int, frame_pointer int",
    "BufferStats": "total_samples: int, dropped_samples: int, max_buffer_size: int, current_buffer_size: int",
    "TimerConfig": "interval_sec float, initial_sec float",
    "ELFSymbol": "name str, start_address int, size int, symbol_type int, binding int",
    "FlameNode": "function_name: str, sample_count: int, self_count: int, total_count: int, children: Dict[str, FlameNode], parent: Optional[FlameNode], depth: int, module_name: str",
    "Rectangle": "x: float, y: float, width: float, height: float, node: FlameNode, color: str, text_x: float, text_y: float",
    "ColorScheme": "CATEGORY, MODULE, HASH, HEAT",
    "AllocationType": "enum for malloc, calloc, realloc, new types",
    "LeakCategory": "DEFINITE_LEAK, POSSIBLE_LEAK, REACHABLE_LEAK, GROWTH_PATTERN",
    "ProfilerPipeline": "config: ProfilerConfig, stats: PipelineStats, sample_queue: Queue, symbolized_queue: Queue, aggregated_queue: Queue",
    "PipelineStats": "samples_collected: int, samples_symbolized: int, samples_aggregated: int, dropped_samples: int, symbol_cache_hits: int, symbol_cache_misses: int, processing_errors: int, last_error: Optional[str], pipeline_start_time: float",
    "RingBuffer": "capacity: int, buffer: deque, lock: RLock, dropped_count: int, total_added: int",
    "AllocationTracker": "libc: CDLL, original_malloc, original_free, original_realloc, active_allocations: Dict[int, Allocation], allocation_sites: Dict[str, AllocationSite], memory_timeline: List[MemorySnapshot], tracker_lock: RLock, in_tracker: local",
    "InteractiveSVGGenerator": "config: VisualizationConfig, width: int, height: int, colors: dict",
    "ErrorReport": "error_id: str, category: ErrorCategory, severity: ErrorSeverity, message: str, timestamp: float, context: Dict[str, any], stack_trace: Optional[str], recovery_action: Optional[str], similar_error_count: int",
    "ValidationIssue": "result: ValidationResult, message: str, context: Dict[str, Any], fix_suggestion: Optional[str]",
    "TestProgramSpec": "name: str, execution_pattern: str, runtime_seconds: float, expected_hotspots: List[str], allocation_pattern: Dict[str, Any]",
    "PerformanceMetrics": "cpu_time_seconds: float, memory_rss_bytes: int, wall_clock_seconds: float, context_switches: int, page_faults: int",
    "OverheadReport": "baseline_metrics: PerformanceMetrics, profiled_metrics: PerformanceMetrics, cpu_overhead_percent: float, memory_overhead_bytes: int, acceptable_overhead: bool",
    "MilestoneResult": "milestone_name: str, passed: bool, test_results: Dict[str, bool], performance_metrics: Dict[str, float], error_messages: List[str], recommendations: List[str]",
    "HardwareCounters": "cycles: int, instructions: int, cache_references: int, cache_misses: int, branch_instructions: int, branch_misses: int",
    "CustomEvent": "event_id: str, event_name: str, metadata: Dict[str, Any], timestamp: float, thread_id: int",
    "PerformanceBaseline": "function_name: str, average_samples: float, std_deviation: float, confidence_interval: float, observation_count: int",
    "PerformanceAnomaly": "function_name: str, current_samples: int, expected_samples: float, deviation_magnitude: float, anomaly_type: str, confidence: float",
    "ProfilerNode": "node_id: str, address: str, port: int, capabilities: Set[str], last_heartbeat: float",
    "ProfilingSession": "session_id: str, target_processes: Dict[str, int], duration_seconds: float, sampling_config: Dict[str, Any], start_time: float",
    "SampleType": "CPU_TIME, WALL_TIME, MEMORY_ALLOCATION, CUSTOM_EVENT",
    "ELFParser": "binary_path: str, symbols: dict, load_bias: int"
  },
  "methods": {
    "from_json(config_path) returns ProfilerConfig": "load configuration from JSON file",
    "to_json(config_path) returns None": "save configuration to JSON file",
    "profile_process(pid, duration_seconds) returns Profile": "collect profiling samples from target process",
    "symbolize_profile(profile) returns Profile": "resolve addresses to function names",
    "generate_flame_graph(profile, output_path) returns None": "create SVG flame graph visualization",
    "setup_logging(level, log_file) returns None": "configure logging system",
    "timer_context(operation_name) returns Generator": "context manager for timing operations",
    "format_bytes(size_bytes) returns str": "format byte count as human readable",
    "format_percentage(value, total) returns str": "format value as percentage with precision",
    "add_sample(sample: Sample) -> None": "Add sample to batch with timestamp validation and sorting",
    "get_duration() -> float": "Calculate time span of samples in batch",
    "get_sample_rate() -> float": "Calculate actual achieved sampling rate",
    "contains_address(address: int) -> bool": "Check if address falls within symbol range",
    "get_line_number(address: int) -> int": "Find source line number for address within symbol",
    "find_symbol(address: int) -> Optional[Symbol]": "Find symbol containing given address using binary search",
    "add_symbol(symbol: Symbol) -> None": "Add symbol to module with overlap validation",
    "lookup_symbol(address: int) -> Optional[Symbol]": "Look up cached symbol or return None for miss",
    "cache_symbol(address: int, symbol: Optional[Symbol]) -> None": "Cache symbol result or miss for future lookups",
    "get_hit_rate() -> float": "Calculate symbol cache hit rate percentage",
    "get_lifetime() -> float": "calculate allocation lifetime in seconds",
    "is_long_lived(threshold_seconds: float) -> bool": "Check if allocation exceeds lifetime threshold",
    "get_fragmentation_bytes() -> int": "Calculate heap fragmentation in bytes",
    "get_fragmentation_ratio() -> float": "Calculate fragmentation as percentage of heap",
    "get_stack_signature() -> str": "Generate hash signature for leak's call stack",
    "add_allocation(allocation: Allocation) -> None": "Update allocation site statistics with new allocation",
    "get_average_size() -> float": "Calculate average allocation size from site",
    "is_active(current_time: float, inactive_threshold: float) -> bool": "Check if allocation site used recently",
    "start_sampling(target_pid) -> None": "Begin stack sampling of target process",
    "stop_sampling() -> SampleBatch": "Stop sampling and return collected samples",
    "get_current_stats() -> dict": "Get current sampling statistics without stopping",
    "handle_signal(signum, frame) -> None": "Signal handler called on SIGPROF delivery",
    "unwind_stack(context) -> List[StackFrame]": "Unwind call stack from given execution context",
    "add_sample(sample) -> bool": "add sample to buffer with overflow handling",
    "get_samples(max_count) -> List[Sample]": "Extract samples from buffer for processing",
    "get_stats() -> BufferStats": "Get current buffer statistics for monitoring",
    "extract_signal_context(signum, frame) -> RegisterContext": "Extract register context from Python signal frame",
    "add_child(name, module) returns FlameNode": "Add or get child node with given function name",
    "calculate_totals() returns int": "Recursively calculate total sample counts including children",
    "add_sample(sample) -> None": "Process a single sample and add it to the aggregated tree",
    "get_folded_output() returns str": "Export aggregated data in folded stack format",
    "finalize() returns FlameNode": "Complete aggregation and return root node with calculated totals",
    "get_color(node) returns str": "Get color for flame graph node based on current scheme",
    "calculate_coordinates(root) returns List[Rectangle]": "Calculate pixel coordinates for all flame graph rectangles",
    "generate_svg(rectangles, output_path) -> None": "Generate complete SVG flame graph file",
    "record_allocation(ptr, size, stack_frames) -> None": "Record new allocation with metadata",
    "record_deallocation(ptr) -> None": "Record deallocation and update tracking",
    "detect_leaks(live_allocations, allocation_sites) -> List[MemoryLeak]": "Identify potential memory leaks",
    "calculate_leak_confidence(allocation, similar_count) -> float": "Calculate confidence score for leak",
    "start_profiling(target_pid: int, duration_seconds: float) -> None": "Start the complete profiling pipeline for specified target and duration",
    "stop_profiling() -> Profile": "stop profiling and return collected data",
    "add_sample(sample: Sample) -> bool": "Add sample to buffer, dropping oldest if at capacity",
    "get_samples(max_count: int) -> List[Sample]": "Extract up to max_count samples from buffer for processing",
    "intercept_malloc(size: int) -> int": "Intercept malloc calls to track allocations",
    "intercept_free(ptr: int) -> None": "Intercept free calls to track deallocations",
    "detect_leaks() -> List[MemoryLeak]": "Analyze active allocations to detect potential memory leaks",
    "generate_svg(flame_tree: FlameNode, output_path: str) -> None": "Generate complete interactive SVG flame graph file",
    "calculate_coordinates(root: FlameNode) -> List[Rectangle]": "Calculate pixel coordinates for all flame graph rectangles",
    "get_processing_rate() -> float": "Calculate samples processed per second since pipeline start",
    "get_error_rate() -> float": "Calculate error rate as percentage of total samples",
    "handle_signal_delivery_failure(target_pid, expected_samples, actual_samples) returns bool": "Handle failed signal delivery and determine recovery strategy",
    "recover_from_stack_corruption(context, partial_stack) returns Optional[List[StackFrame]]": "Attempt to recover usable stack from corrupted unwind",
    "handle_buffer_overflow(buffer_stats) returns str": "Handle sample buffer overflow with recovery strategy",
    "validate_sample_integrity(sample) returns bool": "Validate captured sample contains reasonable data",
    "handle_missing_debug_symbols(module_path, address) returns Optional[str]": "Generate fallback display when symbols unavailable",
    "detect_aslr_bias_error(module, test_addresses) returns Optional[int]": "Detect and correct ASLR bias calculation errors",
    "recover_from_cache_corruption(corruption_type) returns bool": "Recover symbol cache from detected corruption",
    "validate_dwarf_parsing(dwarf_data, expected_checksum) returns ValidationResult": "Validate DWARF debug information before parsing",
    "detect_recursive_malloc() returns bool": "Detect recursion in allocation tracking",
    "validate_allocation_metadata(allocation) returns List[str]": "Validate allocation metadata for corruption",
    "recover_from_metadata_corruption(corrupted_allocations) returns int": "Recover from corrupted allocation metadata",
    "classify_leak_confidence(allocation, similar_leaks) returns float": "Calculate confidence score for potential leak",
    "report_error(category, severity, message, context, stack_trace) returns ErrorReport": "Report error and trigger recovery actions",
    "validate(data) returns List[ValidationIssue]": "Validate data and return issues found",
    "is_valid(data) returns bool": "Quick check if data passes validation",
    "build_cpu_intensive_program(spec) returns str": "Generate CPU-intensive test program with predictable hotspots",
    "build_memory_allocator_program(spec) returns str": "Generate memory-intensive test program with known allocation patterns",
    "measure_baseline_performance(test_program_path, runtime_seconds) returns PerformanceMetrics": "Run test program without profiling to establish baseline performance",
    "measure_profiled_performance(test_program_path, runtime_seconds, profiler_config) returns PerformanceMetrics": "Run test program under profiler and measure performance impact",
    "generate_overhead_report(baseline, profiled) returns OverheadReport": "Compare baseline vs profiled performance and validate overhead bounds",
    "validate_milestone_1_stack_sampling() returns MilestoneResult": "Validate Milestone 1: Stack sampling implementation",
    "validate_milestone_2_symbol_resolution() returns MilestoneResult": "Validate Milestone 2: Symbol resolution implementation",
    "validate_milestone_3_flame_graphs() returns MilestoneResult": "Validate Milestone 3: Flame graph generation",
    "validate_milestone_4_memory_profiling() returns MilestoneResult": "Validate Milestone 4: Memory profiling implementation",
    "get_ipc() -> float": "calculate instructions per cycle from hardware counters",
    "get_cache_miss_rate() -> float": "calculate cache miss rate percentage",
    "register_event(event_id: str, handler: Callable) -> None": "register custom event handler in registry",
    "trigger_event(event_id: str, metadata: Dict) -> Optional[Sample]": "trigger custom event and capture stack if enabled",
    "can_unwind_frame(frame_address: int) -> bool": "check if unwinder handles given frame address",
    "unwind_stack(context: Any) -> List[StackFrame]": "unwind stack using language-specific method",
    "start_distributed_session(config: Dict) -> str": "start coordinated profiling across cluster nodes",
    "process_sample_stream(stream: AsyncGenerator) -> None": "process continuous stream of profiling samples",
    "detect_anomalies(samples: Dict[str, int]) -> List[PerformanceAnomaly]": "detect performance anomalies against baselines",
    "from_json(config_path) -> ProfilerConfig": "load configuration from JSON file with validation",
    "to_json(config_path) -> None": "save configuration to JSON file with formatting",
    "start_profiling(target_pid, duration_seconds) -> None": "start complete profiling pipeline for target process",
    "lookup_symbol(address) -> Optional[Symbol]": "look up cached symbol or return None for miss",
    "parse_symbol_table() -> Dict[int, Symbol]": "parse ELF symbol table and return mappings",
    "parse_dwarf_debug_info() -> Dict[int, LineRange]": "parse DWARF debug info for line mappings",
    "validate() -> List[str]": "validate configuration and return issues"
  },
  "constants": {
    "SIGPROF": "signal for profiling timer interrupts",
    "DEFAULT_FREQUENCY_HZ": "100 samples per second default",
    "MAX_STACK_DEPTH": "128 maximum call stack frames",
    "TARGET_OVERHEAD_PERCENT": "2.0 percent overhead target",
    "ITIMER_PROF": "interval timer type for CPU profiling",
    "CATEGORY_COLORS": "color mapping for function categories",
    "MODULE_PALETTE": "predefined color palette for modules",
    "DEFAULT_RECTANGLE_HEIGHT": "18 pixels for flame graph rectangles",
    "MIN_WIDTH_THRESHOLD": "0.5 pixels minimum display width",
    "LD_PRELOAD": "environment variable for library preloading",
    "RTLD_NEXT": "dlsym flag for next symbol",
    "PERF_COUNT_HW_CPU_CYCLES": "0 hardware performance counter",
    "PERF_COUNT_HW_INSTRUCTIONS": "1 hardware performance counter",
    "PERF_COUNT_HW_CACHE_REFERENCES": "2",
    "PERF_COUNT_HW_CACHE_MISSES": "3",
    "DEFAULT_WINDOW_SIZE": "60 seconds",
    "ANOMALY_CONFIDENCE_THRESHOLD": "0.95 confidence for anomaly detection"
  },
  "terms": {
    "statistical sampling": "periodic observation of program execution state at regular intervals",
    "instrumentation": "code modification to record execution events as they occur",
    "observer paradox": "measurement overhead changing the behavior being profiled",
    "stack sampling": "capturing call stack at regular intervals using timer signals",
    "symbol resolution": "converting raw memory addresses to function names and source locations",
    "flame graph": "hierarchical visualization showing call stack frequency and relationships",
    "overhead": "performance cost imposed by profiling measurement collection",
    "sampling frequency": "rate of stack captures per second in Hz",
    "debug symbols": "metadata mapping addresses to source code locations and function info",
    "stack unwinding": "walking frame pointers or DWARF info to reconstruct call chain",
    "signal-based interruption": "using timer signals to periodically interrupt execution for sampling",
    "frame pointer": "register pointing to current function's stack frame",
    "async-safe": "functions safe to call from signal handlers without deadlocks",
    "ASLR": "Address Space Layout Randomization for security",
    "DWARF": "Debug information format for source-level debugging",
    "ELF": "Executable and Linkable Format for binaries",
    "demangling": "converting mangled C++ names to readable form",
    "load bias": "offset between runtime and link-time addresses",
    "stack folding": "converting individual stack traces into aggregated signature counts",
    "folded stack format": "semicolon-delimited text format for call stacks with counts",
    "coordinate calculation": "mapping logical tree structure to pixel positions for visualization",
    "interactive SVG": "scalable vector graphics with embedded JavaScript for user interactions",
    "color scheme": "systematic color assignment strategy for visual distinction",
    "stack signature": "unique identifier string created from call stack sequence",
    "hierarchical aggregation": "building tree structure that preserves calling context",
    "weight calculation": "determining visual width based on cumulative sample counts",
    "bottom-up layout": "flame graph orientation with main function at bottom",
    "function interposition": "intercepting calls to library functions like malloc/free",
    "allocation metadata": "tracking information for each memory allocation",
    "leak detection": "identifying allocations without corresponding free operations",
    "allocation site": "unique call stack location where allocation occurs",
    "recursion detection": "preventing infinite loops in allocation tracking",
    "thread-local storage": "per-thread data storage for tracking",
    "suppression rules": "patterns to filter false positive leaks",
    "growth patterns": "allocation sites with unbounded memory growth",
    "backpressure": "downstream overwhelm requiring upstream slowdown or dropping",
    "graceful degradation": "maintaining functionality despite errors or missing data",
    "hardware performance counters": "specialized CPU registers tracking execution events",
    "event-based sampling": "triggering sample collection on hardware events",
    "custom event sampling": "application-specific profiling events",
    "multi-language profiling": "profiling polyglot applications across runtimes",
    "distributed profiling": "coordinated profiling across multiple processes/machines",
    "streaming data processing": "real-time continuous sample analysis",
    "performance baseline": "established normal performance characteristics",
    "anomaly detection": "identifying significant deviations from baseline performance",
    "federated profiling": "hierarchical distributed profiling architecture",
    "clock synchronization": "maintaining consistent timestamps across nodes"
  }
}