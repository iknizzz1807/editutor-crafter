title: Field Encoding Process {
  style.font-size: 20
  style.bold: true
  style.font-color: "#e6edf3"
  near: top-center
}

classes: {
  process: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  decision: {
    style.fill: "#0f3460"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  data: {
    style.fill: "#16213e"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  encoding: {
    style.fill: "#1a1a2e"
    style.stroke: "#d63031"
    style.font-color: "#ffffff"
    style.bold: true
  }
}

start: Start Field Encoding {
  shape: circle
  class: process
}

get_field: Get Field Definition\nfrom Schema {
  class: process
}

gen_key: Generate Field Key\n(field_number << 3) | wire_type {
  class: encoding
}

wire_type_check: Determine\nWire Type {
  shape: diamond
  class: decision
}

varint_encode: VARINT Encoding\nVarint encoding for\nintegers, bools, enums {
  class: encoding
}

length_delim: LENGTH_DELIMITED\nEncode length + data\nfor strings, bytes, messages {
  class: encoding
}

fixed64_encode: FIXED64 Encoding\n8-byte little-endian\nfor double, fixed64 {
  class: encoding
}

fixed32_encode: FIXED32 Encoding\n4-byte little-endian\nfor float, fixed32 {
  class: encoding
}

repeated_check: Is Field\nRepeated? {
  shape: diamond
  class: decision
}

single_value: Encode Single Value\nkey + encoded_value {
  class: process
}

packed_check: Use Packed\nEncoding? {
  shape: diamond
  class: decision
}

packed_encode: Packed Encoding\nkey + length + values {
  class: encoding
}

unpacked_encode: Unpacked Encoding\nMultiple key + value pairs {
  class: encoding
}

append_buffer: Append Encoded Bytes\nto Output Buffer {
  class: process
}

next_field: More Fields\nto Encode? {
  shape: diamond
  class: decision
}

complete: Field Encoding\nComplete {
  shape: circle
  class: process
  style.double-border: true
}

start -> get_field
get_field -> gen_key
gen_key -> wire_type_check

wire_type_check -> varint_encode: VARINT (0)
wire_type_check -> length_delim: LENGTH_DELIMITED (2)
wire_type_check -> fixed64_encode: FIXED64 (1)
wire_type_check -> fixed32_encode: FIXED32 (5)

varint_encode -> repeated_check
length_delim -> repeated_check
fixed64_encode -> repeated_check
fixed32_encode -> repeated_check

repeated_check -> single_value: No
repeated_check -> packed_check: Yes

single_value -> append_buffer

packed_check -> packed_encode: Yes\n(numeric types)
packed_check -> unpacked_encode: No\n(strings, messages)

packed_encode -> append_buffer
unpacked_encode -> append_buffer

append_buffer -> next_field

next_field -> get_field: Yes
next_field -> complete: No

wire_types: Wire Type Reference {
  class: data
  shape: rectangle
  
  type_0: "0: VARINT\nint32, int64, uint32,\nuint64, bool, enum"
  type_1: "1: FIXED64\ndouble, fixed64,\nsfixed64"
  type_2: "2: LENGTH_DELIMITED\nstring, bytes, messages,\npacked repeated"
  type_5: "5: FIXED32\nfloat, fixed32,\nsfixed32"
}

type_0.class: data
type_1.class: data  
type_2.class: data
type_5.class: data