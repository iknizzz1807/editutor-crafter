{
  "types": {
    "ProtocolBuffer": "binary serialization format with schema evolution",
    "Varint": "bytes",
    "WireType": "IntEnum with VARINT, FIXED64, LENGTH_DELIMITED, FIXED32",
    "FieldNumber": "unique numeric identifier for message fields",
    "Schema": "messages: Dict[str, MessageDefinition]",
    "MessageDefinition": "name: str, fields: List[FieldDefinition], nested_messages: Dict[str, MessageDefinition]",
    "FieldDefinition": "name: str, field_type: str, field_number: int, is_repeated: bool",
    "EncodedValue": "bytes",
    "MessageData": "Dict[str, Union[int, str, float, bool, bytes, List, Dict]]",
    "FieldKey": "field_number: int, wire_type: WireType",
    "VarintError": "value: int, byte_position: int",
    "WireTypeError": "wire_type: int, expected_type: str, field_number: int",
    "Token": "type: TokenType, value: str, line: int, column: int",
    "TokenType": "Enum with KEYWORD, PRIMITIVE_TYPE, IDENTIFIER, NUMBER, STRING, LBRACE, RBRACE, SEMICOLON, EQUALS, COMMENT, WHITESPACE, EOF",
    "SchemaParseError": "line: int, column: int, token: str",
    "SchemaLexer": "tokenizes schema text",
    "SchemaParser": "parses token stream into schema",
    "SerializationError": "field_path: List[str], expected_type: str, actual_type: str",
    "DeserializationError": "byte_position: int, field_number: int, wire_type: int",
    "SerializationContext": "schema: Schema, current_message: str, nesting_depth: int, processing_stack: List[str], max_nesting_depth: int",
    "MessageSerializer": "schema: Schema, max_nesting_depth: int",
    "FieldEncoder": "field encoding utilities",
    "MessageDeserializer": "schema: Schema, preserve_unknown_fields: bool",
    "BinaryStream": "data: bytes, offset: int, length: int",
    "ProtocolBufferError": "message: str, error_code: str, context: Dict, timestamp: float",
    "ErrorContext": "field_path: List[str], message_stack: List[str], byte_position: int, current_field: str",
    "ErrorCollector": "errors: List, max_errors: int, error_count: int",
    "ExtendedFieldDefinition": "name: str, field_type: str, field_number: int, modifier: FieldModifier, oneof_group: Optional[str], is_map: bool, key_type: Optional[str], value_type: Optional[str], is_streaming: bool",
    "OneofGroup": "name: str, fields: List[str], field_numbers: List[int]",
    "ExtendedMessageDefinition": "name: str, fields: List[ExtendedFieldDefinition], nested_messages: Dict[str, ExtendedMessageDefinition], oneof_groups: Dict[str, OneofGroup], map_fields: List[str]",
    "ServiceMethod": "name: str, request_type: str, response_type: str, request_streaming: bool, response_streaming: bool",
    "ServiceDefinition": "name: str, methods: List[ServiceMethod]",
    "ExtendedSchema": "messages: Dict[str, ExtendedMessageDefinition], services: Dict[str, ServiceDefinition], imports: List[str]",
    "LazyMessage": "data: bytes, schema: ExtendedMessageDefinition, field_index: Dict[int, FieldLocation], parsed_cache: Dict[str, Any]",
    "BufferView": "_buffer: bytes, _start: int, _end: Optional[int]",
    "FieldLocation": "offset: int, length: int, wire_type: WireType",
    "FieldModifier": "Enum with OPTIONAL, REPEATED, ONEOF, MAP",
    "OneofFieldManager": "schema: ExtendedSchema",
    "ProtocolBufferCodeGenerator": "template_env: Environment, output_dir: str"
  },
  "methods": {
    "encode_varint(value) -> bytes": "convert integer to variable-length byte encoding",
    "decode_varint(data) -> (value, bytes_consumed)": "parse variable-length integer from bytes",
    "zigzag_encode(signed_int) -> unsigned_int": "map signed integer to unsigned for varint encoding",
    "parse_schema(proto_text) -> Schema": "convert schema definition to structured representation",
    "serialize_message(data, schema, message_name)": "encode Python dict to binary",
    "deserialize_message(binary_data, schema, message_name)": "decode binary to Python dict",
    "FieldKey.encode() -> bytes": "encode field key as varint",
    "FieldKey.decode(data) -> (FieldKey, int)": "decode field key from byte stream",
    "zigzag_decode(unsigned_int) -> signed_int": "decode ZigZag-encoded integer back to signed",
    "encode_signed_varint(signed_value) -> bytes": "encode signed integer using ZigZag then varint",
    "decode_signed_varint(data) -> (signed_value, bytes_consumed)": "decode signed varint using varint then ZigZag",
    "validate_wire_type(wire_type) -> WireType": "validate and convert wire type",
    "encode_fixed32(value) -> bytes": "encode 32-bit value little-endian",
    "decode_fixed32(data, offset, signed, is_float) -> tuple": "decode 32-bit value from bytes",
    "encode_fixed64(value) -> bytes": "encode 64-bit value little-endian",
    "decode_fixed64(data, offset, signed, is_double) -> tuple": "decode 64-bit value from bytes",
    "encode_string(value) -> bytes": "encode string as length-prefixed UTF-8",
    "encode_bytes(value) -> bytes": "encode raw bytes with length prefix",
    "decode_length_delimited(data, offset, as_string) -> tuple": "decode length-delimited data",
    "tokenize() -> List[Token]": "convert text to token stream",
    "parse_message_definition() -> MessageDefinition": "parse single message from tokens",
    "parse_field_definition() -> FieldDefinition": "parse single field from tokens",
    "validate_field_number(field_number, message_name)": "check field number validity",
    "resolve_message_references(schema)": "resolve message type references",
    "peek(offset) -> Token": "look at upcoming token",
    "consume() -> Token": "get next token",
    "expect_token(type, message) -> Token": "consume expected token type",
    "serialize_message(data, message_name) -> bytes": "encode Python dict to binary",
    "deserialize_message(binary_data, message_name) -> MessageData": "decode binary to Python dict",
    "_serialize_message_recursive(data, context) -> bytes": "core recursive serialization logic",
    "encode_field(field_def, value, context) -> bytes": "encode single field with key",
    "encode_repeated_field(field_def, values, context) -> bytes": "encode array as multiple field entries",
    "encode_nested_message(field_def, nested_data, context) -> bytes": "encode sub-message as length-delimited",
    "parse_field_from_wire(data, offset) -> tuple": "parse one field from wire format",
    "decode_varint(data) -> tuple": "parse variable-length integer from bytes",
    "_parse_message_fields(stream, field_lookup) -> Dict[str, Any]": "parse all fields from binary stream",
    "create_nested_context(message_name) -> SerializationContext": "create context for nested message",
    "has_remaining() -> bool": "check if stream has remaining bytes",
    "read_byte() -> int": "read and consume one byte",
    "read_bytes(count) -> bytes": "read specified number of bytes",
    "_encode_field_key(field_number, wire_type) -> bytes": "encode field key as varint",
    "_encode_field_value(value, wire_type, field_type) -> bytes": "encode field value according to wire type",
    "validate_varint_bounds(value, signed) -> None": "validate integer fits in varint range",
    "validate_field_value_type(field_def, value, context) -> None": "validate value matches field type",
    "validate_wire_format_integrity(data, offset) -> None": "validate binary data integrity",
    "handle_unknown_field_gracefully(field_number, wire_type, stream, preserve_mode) -> None": "process unknown field without failing",
    "ErrorContext.push_message(message_name) -> None": "add message to processing stack",
    "ErrorContext.pop_message() -> None": "remove message from stack",
    "ErrorContext.push_field(field_name) -> None": "add field to current path",
    "ErrorContext.pop_field() -> None": "remove field from path",
    "ErrorContext.format_location() -> str": "create readable location string",
    "ErrorCollector.add_error(error) -> None": "add error to collection",
    "ErrorCollector.has_errors() -> bool": "check if errors collected",
    "ErrorCollector.format_summary() -> str": "create formatted error summary",
    "validate_oneof_assignment(message_name, field_name, current_data)": "validate oneof field exclusivity",
    "clear_oneof_siblings(message_name, field_name, message_data)": "clear other oneof fields in same group",
    "get_active_oneof_field(message_name, oneof_name, message_data)": "return currently set oneof field name",
    "generate_message_classes(schema, target_lang)": "generate typed message classes",
    "generate_serializers(schema, target_lang)": "generate optimized serialization functions",
    "write_generated_files(generated_code)": "write generated source to files",
    "__getattr__(field_name)": "lazy field access interception",
    "_parse_field_lazy(field_def)": "parse single field on demand",
    "force_parse_all()": "parse all fields immediately",
    "slice(start, end)": "create buffer sub-view",
    "as_bytes()": "convert view to bytes",
    "decode_varint()": "decode varint from buffer view"
  },
  "constants": {
    "WIRE_TYPE_VARINT": "0 - variable-length integers",
    "WIRE_TYPE_FIXED64": "1 - 8-byte fixed values",
    "WIRE_TYPE_LENGTH_DELIMITED": "2 - strings and nested messages",
    "WIRE_TYPE_FIXED32": "5 - 4-byte fixed values",
    "PRIMITIVE_TYPES": "set of built-in Protocol Buffer types",
    "RESERVED_FIELD_RANGES": "field number ranges reserved by Protocol Buffer",
    "TOKEN_PATTERNS": "regex patterns for lexical analysis"
  },
  "terms": {
    "schema evolution": "ability to modify message definitions while maintaining compatibility",
    "forward compatibility": "old software can read new message formats",
    "backward compatibility": "new software can read old message formats",
    "wire format": "binary representation of serialized messages",
    "field presence": "whether optional fields are set in a message",
    "code generation": "compile-time schema processing into optimized language-specific APIs",
    "varint": "variable-length integer encoding using continuation bits",
    "zigzag encoding": "mapping signed integers to unsigned for efficient varint encoding",
    "continuation bit": "MSB indicating more varint bytes follow",
    "little-endian": "least significant bits encoded first",
    "field key": "packed field number and wire type",
    "length-delimited": "variable-length data with size prefix",
    "fixed-width encoding": "constant byte size regardless of value",
    "IEEE 754": "standard floating-point representation",
    "two's complement": "signed integer representation",
    "lexical analysis": "breaking text into meaningful tokens",
    "recursive descent": "parsing technique using recursive function calls",
    "qualified name": "full path to nested message like User.Address",
    "field number": "unique numeric identifier for message field",
    "namespace resolution": "finding message definitions in nested scopes",
    "symbol table": "registry of defined names and types",
    "lookahead": "examining future tokens without consuming them",
    "synchronization tokens": "grammar elements used for error recovery",
    "unknown fields": "field numbers in wire format not defined in current schema",
    "error recovery": "continuing processing after detecting errors",
    "fail fast": "stopping immediately when errors are detected",
    "oneof fields": "exclusive choice modeling with mutual exclusivity",
    "map fields": "key-value pair collections with efficient encoding",
    "service definitions": "RPC interface specifications using Protocol Buffer messages",
    "lazy deserialization": "on-demand field processing to reduce memory usage",
    "zero-copy techniques": "memory-efficient processing avoiding data copying",
    "template-based generation": "using templates to generate optimized code from schemas",
    "arena allocation": "memory pool management for reduced garbage collection",
    "buffer views": "references to data without copying underlying bytes"
  }
}