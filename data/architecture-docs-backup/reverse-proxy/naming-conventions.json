{
  "types": {
    "Buffer": "fields: data char*, capacity size_t, length size_t, position size_t",
    "LogLevel": "enum: DEBUG, INFO, WARN, ERROR",
    "HashTable": "opaque hash table structure",
    "ProxyConfig": "fields: ssl_enabled bool, ssl_cert_path char[512], ssl_key_path char[512], ssl_ca_path char[512], ssl_min_version int",
    "ProxyServer": "main proxy server structure",
    "ConnectionManager": "fields: epoll_fd int, connections HashTable*, backend_pools ConnectionPool**, pool_count size_t, timeout_wheel TimerWheel*, timeout_thread pthread_t, manager_mutex pthread_mutex_t, running bool",
    "LoadBalancer": "fields: backends BackendServer**, backend_count size_t, algorithm LoadBalancingAlgorithm, rr_current_index size_t, connection_counts uint32_t*, weights uint32_t*, current_weights uint32_t*, health_check_thread pthread_t, backend_healthy bool*, last_health_check time_t*, last_failure_time time_t*, failure_count uint32_t*, backends_lock pthread_rwlock_t, state_mutex pthread_mutex_t, health_check_interval int, health_check_timeout int, failure_threshold int, success_threshold int, running bool",
    "CacheEngine": "fields: cache_table HashTable*, lru_head CacheEntry*, lru_tail CacheEntry*, ttl_heap TTLHeap*, cache_rwlock pthread_rwlock_t, lru_mutex pthread_mutex_t, size_current size_t, size_limit size_t, default_ttl time_t, cleanup_thread pthread_t, cleanup_interval int, hit_count uint64_t, miss_count uint64_t, eviction_count uint64_t, running bool",
    "SSLTermination": "fields: contexts HashTable*, default_context SSL_CTX*, cipher_list char[1024], min_tls_version int, max_tls_version int, context_mutex pthread_rwlock_t, cert_reload_thread pthread_t, reload_interval int, running bool",
    "BackendServer": "fields: host char[256], port int, weight int, enabled bool, health_check_path char[512], health_check_port int, active_connections uint32_t, total_requests uint64_t, failed_requests uint64_t, avg_response_time double, last_success_time time_t, last_failure_time time_t",
    "LoadBalancingAlgorithm": "enum: LB_ROUND_ROBIN, LB_LEAST_CONNECTIONS, LB_WEIGHTED_ROUND_ROBIN, LB_IP_HASH",
    "HttpRequest": "fields: method char[16], uri char[2048], version char[16], headers HashTable*, body Buffer*, content_length size_t, chunked bool, keep_alive bool",
    "HttpResponse": "fields: status int, headers HashTable*, body Buffer*, content_length size_t",
    "ProxyMetrics": "performance monitoring structure",
    "Connection": "fields: connection_id int, client_fd int, backend_fd int, state ConnectionState, client_addr struct sockaddr_in, backend_server BackendServer*, request_buffer Buffer*, response_buffer Buffer*, created_time time_t, last_activity time_t, bytes_read size_t, bytes_written size_t, keep_alive bool, pipeline_depth int, timeout_ms int",
    "ConnectionState": "enum: CONNECTION_IDLE, CONNECTION_READING_REQUEST, CONNECTION_FORWARDING, CONNECTION_READING_RESPONSE, CONNECTION_WRITING_RESPONSE, CONNECTION_CLOSING",
    "HashEntry": "hash table entry structure",
    "HttpParserState": "enum: HTTP_PARSING_REQUEST_LINE, HTTP_PARSING_HEADERS, HTTP_DETERMINING_BODY_LENGTH, HTTP_PARSING_BODY, HTTP_PARSING_CHUNKED_SIZE, HTTP_PARSING_CHUNKED_DATA, HTTP_PARSING_COMPLETE, HTTP_PARSING_ERROR",
    "HttpParser": "fields: state HttpParserState, input_buffer Buffer*, current_request HttpRequest*, bytes_remaining size_t, chunk_size size_t, chunk_size_parsed bool",
    "TimerWheel": "fields: slots TimerSlot**, slot_count size_t, current_slot size_t, slot_duration time_t, wheel_mutex pthread_mutex_t",
    "ConnectionPool": "fields: backend BackendServer*, idle_connections Connection**, idle_count size_t, max_connections size_t, active_count size_t, pool_mutex pthread_mutex_t, pool_condition pthread_cond_t, last_health_check time_t",
    "CacheEntry": "fields: cache_key char[512], response_status int, response_headers HashTable*, response_body Buffer*, content_length size_t, created_time time_t, last_access time_t, expires_time time_t, etag char[256], last_modified char[128], vary_headers char[512], cache_control CacheControl*, lru_prev CacheEntry*, lru_next CacheEntry*, ttl_heap_index size_t, entry_size size_t, hit_count uint32_t",
    "CacheControl": "fields: no_store bool, no_cache bool, must_revalidate bool, private bool, public bool, max_age int, s_maxage int, has_etag bool, has_last_modified bool",
    "LRUList": "fields: head CacheEntry*, tail CacheEntry*, count size_t, lru_mutex pthread_mutex_t",
    "TTLHeap": "fields: entries CacheEntry**, size size_t, capacity size_t, heap_mutex pthread_mutex_t",
    "CacheStats": "fields: hit_count uint64_t, miss_count uint64_t, eviction_count uint64_t, current_size size_t",
    "CertificateInfo": "fields: valid bool, error_message char[256], expires_at time_t, subject_name char[256], issuer_name char[256], san_entries char**, san_count size_t",
    "MessageHeader": "inter-component message header",
    "CacheLookupMessage": "cache lookup request message",
    "BackendSelectionMessage": "backend selection request message",
    "ComponentResponse": "generic component response message",
    "EventDispatcher": "event coordination structure",
    "ProxyStats": "component health monitoring statistics",
    "ProxyErrorCode": "enum: PROXY_ERROR_NONE, PROXY_ERROR_PARSE_FAILED, PROXY_ERROR_BACKEND_UNAVAILABLE, PROXY_ERROR_BACKEND_TIMEOUT, PROXY_ERROR_CACHE_FAILURE, PROXY_ERROR_SSL_HANDSHAKE_FAILED, PROXY_ERROR_CLIENT_DISCONNECTED",
    "ErrorContext": "fields: code ProxyErrorCode, message char[512], component char[64], timestamp time_t, request_id uint64_t, failed_connection Connection*, failed_backend BackendServer*",
    "ErrorHandler": "fields: errors ErrorContext*[1024], error_count size_t, error_capacity size_t, error_mutex pthread_mutex_t, recovery_thread pthread_t, running bool",
    "RecoveryManager": "fields: load_balancer LoadBalancer*, conn_manager ConnectionManager*, cache_engine CacheEngine*, ssl_termination SSLTermination*, recovery_mutex pthread_mutex_t",
    "TimeoutEntry": "fields: connection Connection*, timeout_time time_t, timeout_error ProxyErrorCode, timeout_callback void(*)(Connection*, ProxyErrorCode)",
    "TimeoutManager": "fields: timer_wheel TimerWheel*, timeout_thread pthread_t, running bool",
    "MockSocket": "test structure for network simulation",
    "TestServerConfig": "test HTTP server configuration",
    "PoolMetrics": "connection pool performance statistics",
    "CachePerformanceMetrics": "cache hit/miss performance data",
    "SSLTerminationMetrics": "SSL handshake and performance statistics",
    "Extension": "fields: name char[64], init function pointer, destroy function pointer, handlers EventHandler*, handler_count size_t",
    "EventHandler": "fields: event_type EventType, priority int, handler_func function pointer, enabled bool",
    "ExtensionManager": "fields: extensions Extension*[MAX_EXTENSIONS], extension_count size_t, event_handlers HashTable*, extensions_lock pthread_rwlock_t, extensions_enabled bool",
    "RateLimiter": "fields: rules RateLimitRule**, rule_count size_t, client_counters HashTable*, sliding_windows SlidingWindow**, cleanup_thread pthread_t, limiter_mutex pthread_rwlock_t",
    "RateLimitRule": "fields: pattern char[512], requests_per_second uint32_t, burst_size uint32_t, time_window_seconds uint32_t",
    "ClientCounter": "fields: client_id char[64], request_count uint32_t, last_request_time time_t, burst_tokens uint32_t",
    "ExtensionConfigParser": "fields: section_name char[64], parse_section function pointer, validate_config function pointer, free_config function pointer",
    "RateLimitExtension": "fields: limiter RateLimiter*, cleanup_thread pthread_t, thread_running bool"
  },
  "methods": {
    "buffer_create(size_t) Buffer*": "create new buffer with initial capacity",
    "buffer_append(Buffer*, char*, size_t) bool": "append data to buffer",
    "logger_init(LogLevel, FILE*) bool": "initialize logging system",
    "logger_log(LogLevel, char*, char*, ...) void": "log formatted message",
    "hashtable_create(size_t) HashTable*": "create hash table",
    "hashtable_put(HashTable*, char*, void*) bool": "insert key-value pair",
    "config_load(char*) ProxyConfig*": "load configuration from file",
    "logger_log(LogLevel, char*, int, char*, ...) void": "log formatted message",
    "proxy_server_create(ProxyConfig*) ProxyServer*": "initialize proxy server",
    "proxy_server_start(ProxyServer*) bool": "start proxy server",
    "proxy_server_run(ProxyServer*) void": "main event loop",
    "buffer_read(Buffer*, char*, size_t) size_t": "read data from buffer",
    "hashtable_get(HashTable*, char*) void*": "retrieve value by key",
    "config_validate(ProxyConfig*) bool": "validate configuration",
    "proxy_server_stop(ProxyServer*) void": "stop proxy server",
    "http_request_create() HttpRequest*": "create HTTP request structure",
    "http_request_destroy(HttpRequest*) void": "destroy HTTP request",
    "http_request_add_header(HttpRequest*, char*, char*) bool": "add header to request",
    "http_request_get_header(HttpRequest*, char*) char*": "get header value",
    "http_parser_create() HttpParser*": "initialize HTTP parser",
    "http_parser_process(HttpParser*, char*, size_t) int": "process incoming data",
    "connection_manager_create(ProxyConfig*) ConnectionManager*": "initialize connection manager",
    "connection_manager_accept_client(ConnectionManager*, int) Connection*": "accept new client connection and initialize state",
    "connection_manager_acquire_backend(ConnectionManager*, BackendServer*, int) Connection*": "acquire backend connection from pool or create new one",
    "connection_manager_release_backend(ConnectionManager*, Connection*, bool) void": "return backend connection to pool for reuse",
    "connection_manager_handle_event(ConnectionManager*, Connection*, uint32_t) void": "process connection state transitions",
    "connection_manager_close_connection(ConnectionManager*, Connection*) void": "clean up connection and release all resources",
    "timer_wheel_create(size_t, time_t) TimerWheel*": "initialize timer wheel with specified granularity",
    "connection_pool_create(BackendServer*, size_t) ConnectionPool*": "initialize connection pool for specific backend server",
    "pool_health_checker(void*) void*": "background health checking for pooled connections",
    "timeout_processor(void*) void*": "timeout processing using timer wheel",
    "loadbalancer_create(BackendServer**, size_t, LoadBalancingAlgorithm) LoadBalancer*": "initialize load balancer",
    "loadbalancer_select_backend(LoadBalancer*, HttpRequest*) BackendServer*": "select appropriate backend server for request",
    "loadbalancer_update_connection_count(LoadBalancer*, BackendServer*, int) void": "update connection count for backend server",
    "select_backend_round_robin(LoadBalancer*) BackendServer*": "round-robin backend selection algorithm",
    "select_backend_least_connections(LoadBalancer*) BackendServer*": "least-connections backend selection algorithm",
    "select_backend_weighted_round_robin(LoadBalancer*) BackendServer*": "weighted round-robin backend selection algorithm",
    "health_check_backend(LoadBalancer*, BackendServer*) bool": "perform single health check against backend",
    "health_check_loop(void*) void*": "background health checking thread function",
    "update_backend_health(LoadBalancer*, size_t, bool) void": "update backend health status with synchronization",
    "cache_engine_create(size_t, int) CacheEngine*": "initialize cache engine",
    "cache_engine_lookup(CacheEngine*, HttpRequest*) CacheEntry*": "find cached response for request",
    "cache_engine_store(CacheEngine*, char*, HttpResponse*) bool": "store response in cache if cacheable",
    "cache_engine_invalidate(CacheEngine*, char*) bool": "remove specific entry from cache",
    "cache_engine_clear(CacheEngine*) void": "Remove all cached entries",
    "cache_engine_stats(CacheEngine*) CacheStats*": "Retrieve hit/miss/eviction statistics",
    "cache_generate_key(HttpRequest*) char*": "generate cache key for request",
    "cache_is_cacheable(HttpResponse*) bool": "determine if response can be cached",
    "cache_is_fresh(CacheEntry*, time_t) bool": "check if cached entry is still fresh",
    "cache_create_conditional(HttpRequest*, CacheEntry*) HttpRequest*": "create conditional request for validation",
    "cache_update_from_304(CacheEntry*, HttpResponse*) void": "Update entry from 304 Not Modified",
    "cache_control_parse(char*) CacheControl*": "Parse Cache-Control header into structured directives",
    "cache_control_is_cacheable(CacheControl*, bool) bool": "Check if response is cacheable based on cache-control directives",
    "cache_control_calculate_expiry(CacheControl*, char*, time_t) time_t": "Calculate expiration time from cache-control and response headers",
    "cache_control_is_fresh(CacheControl*, time_t, time_t) bool": "Check if cached entry is fresh at given time",
    "lru_list_create() LRUList*": "Initialize LRU list",
    "lru_list_move_to_head(LRUList*, CacheEntry*) void": "Move entry to head of LRU list",
    "lru_list_add_to_head(LRUList*, CacheEntry*) void": "Add new entry to head of LRU list",
    "lru_list_remove_tail(LRUList*) CacheEntry*": "Remove least recently used entry",
    "lru_list_remove_entry(LRUList*, CacheEntry*) void": "Remove specific entry from LRU list",
    "ssl_termination_create(ProxyConfig*) SSLTermination*": "create SSL termination component",
    "ssl_termination_start(SSLTermination*) bool": "start background threads",
    "ssl_termination_accept_connection(SSLTermination*, int) SSL*": "create SSL connection for client",
    "ssl_termination_sni_callback(SSL*, int*, void*) int": "SNI hostname callback",
    "ssl_termination_reload_certificates(SSLTermination*) bool": "reload certificates from disk",
    "ssl_utils_init() bool": "initialize OpenSSL library",
    "ssl_utils_load_certificate(char*, CertificateInfo*) X509*": "load certificate from file",
    "ssl_utils_load_private_key(char*) EVP_PKEY*": "load private key from file",
    "ssl_utils_verify_key_cert_match(EVP_PKEY*, X509*) bool": "verify key matches certificate",
    "ssl_utils_set_secure_ciphers(SSL_CTX*) bool": "configure secure cipher suites",
    "event_dispatcher_create(ConnectionManager*, SSLTermination*) EventDispatcher*": "initialize event dispatcher with component references",
    "event_dispatcher_run(EventDispatcher*) void": "main event processing loop",
    "proxy_process_request(ProxyServer*, Connection*) int": "coordinate complete request processing across all components",
    "proxy_handle_error(ProxyServer*, Connection*, ProxyErrorCode, char*) void": "handle errors that span multiple components",
    "proxy_update_statistics(ProxyServer*, ProxyStats*) void": "collect statistics from all components",
    "error_handler_create() ErrorHandler*": "create central error handling coordinator",
    "error_handler_report(ErrorHandler*, ErrorContext*) void": "report error to central handler for recovery coordination",
    "recovery_manager_create(LoadBalancer*, ConnectionManager*, CacheEngine*, SSLTermination*) RecoveryManager*": "create recovery coordinator for all components",
    "recovery_manager_handle_backend_failure(RecoveryManager*, BackendServer*, ProxyErrorCode) void": "coordinate recovery actions for backend server failures",
    "recovery_manager_handle_ssl_failure(RecoveryManager*, ProxyErrorCode, char*) void": "coordinate recovery actions for SSL/TLS failures",
    "recovery_manager_handle_cache_failure(RecoveryManager*, ProxyErrorCode, char*) void": "coordinate recovery actions for cache system failures",
    "timeout_manager_create(time_t) TimeoutManager*": "create centralized timeout management system",
    "timeout_manager_add_connection(TimeoutManager*, Connection*, int, ProxyErrorCode) void": "add connection timeout monitoring",
    "timeout_processing_thread(void*) void*": "background thread for processing timeouts",
    "generate_client_error_response(Connection*, ProxyErrorCode, char*) void": "generate sanitized error responses for clients",
    "loadbalancer_mark_backend_unhealthy(LoadBalancer*, BackendServer*) void": "mark backend server as failed for load balancing",
    "connection_manager_invalidate_backend_pool(ConnectionManager*, BackendServer*) void": "remove all pooled connections to failed backend",
    "ssl_termination_schedule_reload(SSLTermination*) void": "schedule certificate reload for SSL recovery",
    "mock_socket_create(size_t) int": "create mock socket for testing",
    "mock_socket_inject_data(int, char*, size_t) void": "inject test data into mock socket",
    "mock_socket_set_error(int, int) void": "simulate socket error conditions",
    "extension_manager_register(ExtensionManager*, Extension*) bool": "register extension with proxy system",
    "extension_manager_init_all(ExtensionManager*, ProxyConfig*) bool": "initialize all registered extensions",
    "extension_manager_dispatch_event(ExtensionManager*, EventType, EventData*) bool": "dispatch event to registered handlers",
    "rate_limit_extension_init(ProxyConfig*) bool": "initialize rate limiting extension",
    "rate_limit_handle_request(EventData*) bool": "handle request arrival for rate limiting",
    "config_register_extension_parser(ConfigManager*, ExtensionConfigParser*) bool": "register configuration parser for extension"
  },
  "constants": {
    "SO_REUSEADDR": "socket option for address reuse",
    "O_NONBLOCK": "non-blocking I/O flag",
    "EAGAIN": "would block error code",
    "EWOULDBLOCK": "would block error code",
    "TCP_NODELAY": "disable Nagle's algorithm",
    "MSG_PEEK": "examine data without consuming",
    "EPOLL_CLOEXEC": "close-on-exec flag for epoll",
    "EPOLLIN": "epoll read event",
    "EPOLLOUT": "epoll write event",
    "EPOLLERR": "epoll error event",
    "EPOLLHUP": "epoll hangup event",
    "SO_RCVTIMEO": "socket receive timeout option",
    "SO_SNDTIMEO": "socket send timeout option",
    "UINT32_MAX": "maximum value for 32-bit unsigned integer",
    "__atomic_fetch_add": "atomic increment operation",
    "__atomic_load": "atomic memory load operation",
    "SSL_TLSEXT_ERR_OK": "SNI callback success",
    "SSL_TLSEXT_ERR_ALERT_FATAL": "SNI callback fatal error",
    "TLS_1_2": "TLS version 1.2",
    "TLS_1_3": "TLS version 1.3",
    "GEN_DNS": "DNS subject alternative name type",
    "NID_subject_alt_name": "subject alternative name OID",
    "EINTR": "interrupted system call",
    "ECONNREFUSED": "connection refused error",
    "EMFILE": "too many open files error",
    "EPOLL_CTL_DEL": "epoll delete operation",
    "HTTP_PARSING_ERROR": "parser error state",
    "HTTP_PARSING_COMPLETE": "parsing complete state",
    "LOG_DEBUG": "debug log level",
    "LOG_INFO": "info log level",
    "LOG_WARN": "warning log level",
    "LOG_ERROR": "error log level",
    "MAX_EXTENSIONS": "maximum number of loadable extensions",
    "HTTP_429_TOO_MANY_REQUESTS": "rate limit exceeded response code",
    "RETRY_AFTER_HEADER": "response header indicating retry delay"
  },
  "terms": {
    "reverse proxy": "proxy server that forwards client requests to backend servers",
    "forward proxy": "proxy server that acts on behalf of clients",
    "event-driven architecture": "architecture using asynchronous I/O and event loops",
    "connection pooling": "reusing persistent connections to reduce overhead",
    "SSL termination": "decrypting SSL/TLS connections at the proxy",
    "load balancing": "distributing requests across multiple backend servers",
    "health checking": "monitoring backend server availability",
    "SNI": "Server Name Indication for SSL certificate selection",
    "stream-based parsing": "incremental parsing of data as it arrives",
    "state machine": "parser that maintains state across multiple input operations",
    "chunked transfer encoding": "HTTP body encoding with size-prefixed chunks",
    "request smuggling": "attack exploiting parser differences between systems",
    "sliding window buffer": "buffer management with position tracking and compaction",
    "timer wheel": "efficient timeout management data structure",
    "LIFO strategy": "Last-In First-Out connection reuse for cache locality",
    "connection lifecycle": "states and transitions connections go through from establishment to cleanup",
    "resource leak": "failure to properly release allocated system resources",
    "timeout management": "handling connection timeouts to prevent resource exhaustion",
    "round-robin": "load balancing algorithm that cycles through servers",
    "least-connections": "load balancing algorithm that prefers servers with fewer active connections",
    "weighted distribution": "load balancing that accounts for different server capacities",
    "failure threshold": "number of consecutive failures before marking server unhealthy",
    "success threshold": "number of consecutive successes before marking server healthy",
    "graceful degradation": "continuing operation with reduced functionality during failures",
    "connection count": "number of active connections to a backend server",
    "backend selection": "process of choosing which server should handle a request",
    "TLS context": "cryptographic configuration for SSL connections",
    "cipher suite": "combination of encryption algorithms used in TLS",
    "certificate chain": "sequence of certificates from leaf to root CA",
    "wildcard certificate": "certificate valid for multiple subdomains",
    "session resumption": "reusing TLS session state across connections",
    "AEAD cipher": "authenticated encryption with associated data",
    "perfect forward secrecy": "session keys not derivable from long-term keys",
    "cascade failure": "failure propagation that amplifies problems across system components",
    "circuit breaker": "pattern that stops operations when error rates exceed thresholds",
    "exponential backoff": "increasing delay between retry attempts to reduce load",
    "error sanitization": "removing sensitive information from user-visible error messages",
    "unit testing": "testing individual components in isolation",
    "integration testing": "testing component interactions and data flow",
    "milestone verification": "checkpoints that validate implementation progress",
    "dependency injection": "providing dependencies through constructor parameters",
    "mock implementations": "fake components that simulate real behavior for testing",
    "synthetic events": "artificially generated events for controlled testing",
    "deterministic testing": "tests with predictable, repeatable outcomes",
    "test harness": "framework that controls test execution and validation",
    "cache hit": "request served from cache without backend access",
    "cache miss": "request requiring backend access due to no cached response",
    "TTL expiration": "cached entry becoming stale due to time limit",
    "extension architecture": "framework for adding new functionality without modifying core components",
    "event-driven hooks": "callback system allowing extensions to intercept request processing",
    "plugin system": "modular architecture for runtime feature addition",
    "rate limiting": "controlling request frequency to prevent overload",
    "web application firewall": "security extension examining requests for malicious patterns",
    "multi-tenancy": "serving multiple isolated customers from single proxy instance",
    "service mesh integration": "distributed system coordination and observability features",
    "content transformation": "modifying response format or encoding before client delivery",
    "authentication extension": "verifying client identity and authorization",
    "monitoring extension": "collecting metrics and observability data",
    "performance budget": "time limit allocated for extension processing per request",
    "extension ordering": "controlling execution sequence when multiple extensions process same request"
  }
}