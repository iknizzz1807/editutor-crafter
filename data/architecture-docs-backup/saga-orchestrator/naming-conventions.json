{
  "types": {
    "SagaDefinition": "fields: name String, steps List<StepDefinition>, timeout Duration",
    "StepDefinition": "fields: action String, compensation String, timeout Duration, dependencies List<String>",
    "SagaInstance": "fields: sagaId String, definitionName String, status SagaStatus, currentStepIndex int, stepOutputs Map<String,Object>, compensationIndex int",
    "StepExecution": "fields: stepId String, status StepStatus, output Object, executedAt Instant",
    "SagaStatus": "enum: CREATED, RUNNING, COMPENSATING, COMPLETED, FAILED",
    "StepStatus": "enum: PENDING, RUNNING, COMPLETED, FAILED, COMPENSATING, COMPENSATED",
    "ValidationResult": "fields: isValid boolean, errors List<String>, warnings List<String>",
    "DependencyGraph": "fields: dependencies Map<String,Set<String>>, inDegrees Map<String,Integer>, allSteps Set<String>",
    "ExecutionTask": "fields: sagaId String, taskType TaskType, parameters Map<String,Object>, scheduledTime Instant, retryCount int",
    "CompensationPlan": "fields: completedSteps List<StepExecution>, compensationOrder List<String>, failureReason String, currentCompensationIndex int",
    "IdempotencyRecord": "fields: idempotencyKey String, stepOutput Object, executionStatus StepStatus, executedAt Instant",
    "PersistedSagaInstance": "database entity for saga instances",
    "PersistedStepExecution": "database entity for step tracking",
    "RecoveryAction": "enum for recovery decisions",
    "TimeoutRegistry": "fields: activeTimeouts ConcurrentHashMap<String,TimeoutEntry>, registryLock ReadWriteLock",
    "TimeoutEntry": "fields: sagaId String, stepName String, deadline Instant, timeoutAction TimeoutAction",
    "DeadLetterRecord": "fields: dlqId String, originalSagaId String, admissionTime Instant, admissionReason DLQReason, sagaSnapshot SagaInstance, errorContext List<DLQErrorRecord>, escalationLevel EscalationLevel",
    "AdminCommand": "fields: commandType AdminOperationType, targetSagaId String, parameters Map<String,Object>, operatorId String, justification String",
    "AuditRecord": "fields: auditId String, operationTime Instant, operatorId String, operationType AdminOperationType, sagaId String, beforeState SagaStateSnapshot, afterState SagaStateSnapshot",
    "TimeoutAction": "enum: RETRY, CANCEL_AND_COMPENSATE, EXTEND_TIMEOUT, MANUAL_REVIEW",
    "DLQReason": "enum: RETRY_EXHAUSTION, COMPENSATION_FAILURE, TIMEOUT_ESCALATION, RESOURCE_DEADLOCK, CORRUPTED_STATE, MANUAL_ESCALATION",
    "EscalationLevel": "enum: LOW, MEDIUM, HIGH, CRITICAL",
    "SagaTracer": "fields: tracer Tracer, activeTraceContexts Map<String,TraceContext>, attributeBuilder SpanAttributeBuilder",
    "TraceContext": "fields: traceId String, spanId String, context Context",
    "SagaMetricsCollector": "fields: meterRegistry MeterRegistry, sagaStartedCounter Counter, sagaDurationTimer Timer, activeSagaCount AtomicLong",
    "ChaosTestFramework": "fields: failureInjector FailureInjector, compensationVerifier CompensationVerifier, scenarioRunner TestScenarioRunner",
    "FailureScenario": "fields: injectionPoint String, failureType String, timing ExecutionPhase",
    "CompensationVerificationResult": "fields: isValid boolean, inconsistencies List<String>, businessRulesViolated List<String>",
    "PerformanceImpactReport": "fields: baselineMetrics Map<String,Double>, chaosMetrics Map<String,Double>, degradationPercentage double",
    "MessageEnvelope": "fields: messageId String, correlationId String, sagaId String, messageType String, timestamp Instant, retryCount int, payload Object",
    "FailureClassification": "fields: category FailureCategory, scope FailureScope, recoverability RecoverabilityLevel, consistencyRisk ConsistencyRisk, metadata Map<String,Object>",
    "RecoveryStrategy": "fields: strategyType RecoveryType, parameters Map<String,Object>, successProbability double, resourceCost ResourceCost, fallbackStrategy RecoveryStrategy",
    "PartitionState": "fields: partitionId String, affectedServices Set<String>, detectionTime Instant, resolutionTime Instant, impactedSagas Set<String>",
    "SagaStateAnalysis": "fields: sagaId String, consistencyIssues List<String>, performanceIssues List<String>, recommendations List<String>",
    "DebugEvent": "fields: eventType String, timestamp Instant, details Map<String,Object>",
    "PerformanceAnalysisReport": "fields: analysisWindow Duration, avgExecutionTime Duration, bottleneckSteps List<String>, recommendations List<String>",
    "PerformanceSnapshot": "fields: activeSagaCount long, avgResponseTime Duration, throughputPerSecond double, resourceUtilization Map<String,Double>",
    "StepPerformanceMetrics": "fields: stepName String, avgDuration Duration, successRate double, p95Duration Duration, executionCount long",
    "ParallelStepGroup": "fields: steps List<StepDefinition>, synchronizationPolicy SyncPolicy",
    "ParallelExecutor": "fields: executorService ExecutorService, maxConcurrency int",
    "ParallelCompensator": "fields: compensationExecutor ExecutorService, dependencyResolver DependencyResolver",
    "SynchronizationPoint": "fields: requiredSteps Set<String>, timeoutDuration Duration",
    "ConditionalStep": "fields: condition String, trueBranch List<StepDefinition>, falseBranch List<StepDefinition>",
    "ExecutionBranch": "fields: condition String, steps List<StepDefinition>",
    "ConditionEvaluator": "fields: evaluationEngine ExpressionEngine",
    "BranchMergePoint": "fields: branchOutputs Map<String,Object>",
    "ParentSaga": "fields: childSagas Map<String,SagaInstance>, coordinationPolicy CoordinationPolicy",
    "ChildSaga": "fields: parentSagaId String, inheritedContext SagaContext",
    "SagaCompositionEngine": "fields: compositionRules List<CompositionRule>",
    "CrossSagaCompensation": "fields: compensationOrder List<String>, sharedResources Set<String>",
    "PartitionManager": "fields: partitionRing ConsistentHashRing, instanceMap Map<String,Instance>",
    "ClusterCoordinator": "fields: membershipManager MembershipManager, failureDetector FailureDetector",
    "CrossPartitionRouter": "fields: partitionMap Map<String,String>, routingTable RoutingTable",
    "PartitionRebalancer": "fields: migrationQueue Queue<MigrationTask>",
    "AdmissionController": "fields: maxConcurrentSagas int, priorityQueue PriorityQueue<SagaRequest>",
    "BackpressureMonitor": "fields: resourceMetrics Map<String,Double>, thresholds Map<String,Double>",
    "LoadSheddingPolicy": "fields: priorityLevels Map<Priority,SheddingRate>",
    "CapacityPlanner": "fields: historicalMetrics TimeSeries<MetricSnapshot>",
    "CustomStepExecutor": "fields: stepType String, executionLogic Function<StepContext,StepResult>",
    "CustomCompensator": "fields: compensationLogic Function<CompensationContext,Void>",
    "PluginStateManager": "fields: stateSerializer Serializer, stateStore StateStore",
    "PluginHealthChecker": "fields: healthChecks List<HealthCheck>",
    "SecurityContextPropagation": "fields: contextProvider SecurityContextProvider",
    "StepAuthorizationEngine": "fields: policyEngine PolicyEngine, permissionCache Cache<String,Permission>",
    "DataEncryptionManager": "fields: encryptionProvider EncryptionProvider, keyManager KeyManager",
    "AuditTrailIntegration": "fields: auditLogger AuditLogger, complianceRules List<ComplianceRule>",
    "SagaExtension": "interface for all saga extensions",
    "ParallelExecutionExtension": "interface for parallel execution capabilities",
    "CustomStepPlugin": "interface for custom step implementations",
    "ExtensionStateManager": "interface for extension state persistence",
    "ParallelExecutionResult": "fields: completedSteps Map<String,StepResult>, failedStep String",
    "ExtensionMetadata": "fields: name String, version String, dependencies List<String>",
    "ExtensionConfig": "fields: properties Map<String,Object>",
    "OrchestratorContext": "fields: definitionManager SagaDefinitionManager, executionEngine ExecutionEngine"
  },
  "methods": {
    "startSaga(definitionName, initialContext) returns String": "creates new saga instance and begins execution",
    "executeNextStep(sagaId) returns void": "executes next step in forward path",
    "startCompensation(sagaId, failureReason) returns void": "begins compensation flow in reverse order",
    "recoverIncompleteSagas() returns void": "resumes sagas after restart",
    "startExecution() returns void": "transitions saga from CREATED to RUNNING",
    "completeCurrentStep(stepOutput, totalSteps) returns void": "advances saga to next step",
    "startCompensation() returns void": "begins rollback flow",
    "completeCurrentCompensation() returns void": "advances compensation sequence",
    "storeDefinition(SagaDefinition) returns void": "stores saga definition after validation",
    "validateDefinition(SagaDefinition) returns ValidationResult": "validates definition without storing",
    "resolveExecutionOrder(List<StepDefinition>) returns List<String>": "computes execution order from dependencies",
    "getDefinition(name, version) returns Optional<SagaDefinition>": "retrieves specific definition version",
    "topologicalSort() returns List<String>": "performs dependency ordering",
    "hasCycle() returns boolean": "detects circular dependencies",
    "evaluateStepReadiness(sagaId, stepIndex) returns boolean": "checks if step dependencies are satisfied",
    "invokeStepAction(stepDefinition, context) returns Object": "executes step's forward action with saga context",
    "executeCompensation(stepDefinition, context) returns void": "invokes compensating action for completed step",
    "buildCompensationPlan(completedSteps) returns List<String>": "creates reverse-order execution plan for rollback",
    "storeSagaInstance(sagaInstance)": "persists initial saga instance",
    "updateSagaProgress(sagaId, stepIndex, stepExecution)": "atomic saga and step state update",
    "startCompensation(sagaId, failureReason, compensationIndex)": "begins compensation flow",
    "loadSagaInstance(sagaId)": "retrieves complete saga state",
    "findIncompleteSagas()": "recovery query for non-terminal sagas",
    "checkAndStoreIdempotency(key, output)": "duplicate detection and prevention",
    "recoverIncompleteSagas()": "main recovery entry point",
    "analyzeSagaState(saga)": "determines recovery action",
    "reconstructExecutionContext(saga)": "rebuilds in-memory state",
    "scanForTimeouts() returns void": "main timeout detection algorithm that processes expired timeout entries",
    "detectStuckSagas() returns List<String>": "analyzes saga patterns to identify stuck sagas beyond simple timeouts",
    "admitSagaToDeadLetterQueue(sagaId, reason, context) returns void": "moves saga to DLQ with comprehensive diagnostic information",
    "executeAdminCommand(command, operatorId) returns AdminOperationResult": "executes manual intervention with validation and audit trail",
    "registerStepTimeout(sagaId, stepName, deadline, action) returns void": "adds step to timeout monitoring registry",
    "rebuildTimeoutRegistry() returns void": "reconstructs timeout monitoring from persistent state after restart",
    "findExpiredTimeouts(currentTime) returns List<TimeoutEntry>": "scans registry for timeouts past their deadline",
    "startSagaTrace(sagaId, definitionName, initialContext) returns TraceContext": "creates root span for entire saga execution with proper attributes",
    "startStepTrace(sagaId, stepName, stepIndex, stepContext) returns Span": "creates child span for individual step execution",
    "startCompensationTrace(sagaId, stepName, failureReason, compensationIndex) returns Span": "creates span for compensation action with rollback indicators",
    "recordSagaStarted(sagaId, definitionName) returns void": "increments saga started counter and begins duration timing",
    "recordSagaCompleted(sagaId, definitionName, businessValue) returns void": "records successful completion with duration and business value",
    "executeFullTestSuite(sagaDefinitionName, testContext) returns ChaosTestResults": "runs comprehensive chaos testing scenarios with verification",
    "runFailureScenario(scenario, sagaId) returns TestScenarioResult": "executes specific failure injection with compensation verification",
    "verifyCompensationCorrectness(sagaId, completedSteps, compensationPlan) returns CompensationVerificationResult": "validates rollback operations produce correct final state",
    "classifyFailure(sagaId, stepName, error, context) returns FailureClassification": "analyzes failure characteristics and determines category",
    "initiateRecovery(sagaId, failure, strategies) returns void": "starts automatic recovery process with strategy chain",
    "executeCompensationChain(sagaId, plan) returns void": "executes rollback operations in reverse order",
    "detectPartitionResolution(recoveredServices) returns void": "handles state reconciliation after network partition",
    "evaluateCascadeRisk() returns void": "monitors for cascading failure patterns",
    "executeManualIntervention(command, operatorId) returns AdminOperationResult": "processes administrative intervention with audit trail",
    "completedCurrentStep(stepOutput, totalSteps) returns void": "advances saga to next step",
    "findIncompleteSagas() returns List<String>": "recovery query for non-terminal sagas",
    "checkAndStoreIdempotency(key, output) returns boolean": "duplicate detection and prevention",
    "analyzeSagaState(sagaId) returns SagaStateAnalysis": "comprehensive saga state analysis for debugging",
    "findInconsistentSagas() returns List<String>": "finds sagas with potential state inconsistencies",
    "validateSagaConsistency(sagaId) returns ValidationResult": "validates saga state consistency rules",
    "analyzePerformance(analysisWindow) returns PerformanceAnalysisReport": "analyzes saga execution performance and identifies bottlenecks",
    "getCurrentPerformanceSnapshot() returns PerformanceSnapshot": "monitors real-time performance indicators",
    "detectStuckSagas(stuckThreshold) returns List<String>": "detects sagas that may be stuck or making no progress",
    "analyzeStepPerformance(analysisWindow) returns Map<String,StepPerformanceMetrics>": "analyzes step execution patterns to identify performance bottlenecks",
    "recordSagaStart(sagaId, definitionName) returns void": "records saga execution start for performance tracking",
    "recordSagaCompletion(sagaId, finalStatus) returns void": "records saga completion and calculates performance metrics",
    "recordStepExecution(sagaId, stepName, executionTime, status) returns void": "records step execution for detailed performance analysis",
    "initialize(context, config) returns void": "initialize extension with orchestrator context",
    "getMetadata() returns ExtensionMetadata": "returns extension metadata including dependencies",
    "shutdown() returns void": "perform graceful shutdown of extension resources",
    "checkHealth() returns HealthStatus": "check extension health status",
    "executeParallelGroup(sagaId, stepGroup, context) returns ParallelExecutionResult": "execute multiple steps concurrently",
    "compensateParallelGroup(sagaId, stepGroup, partialResult) returns void": "coordinate compensation for parallel steps",
    "getStepType() returns String": "returns step type identifier for plugin",
    "executeStep(sagaId, stepDefinition, context, parameters) returns StepExecutionResult": "execute custom business logic",
    "compensateStep(sagaId, stepDefinition, context, originalResult) returns void": "perform semantic rollback",
    "validateStepDefinition(stepDefinition, parameters) returns ValidationResult": "validate step definition parameters",
    "serializeState(sagaId, extensionState) returns byte[]": "serialize extension state for storage",
    "deserializeState(sagaId, serializedState, stateVersion) returns Object": "deserialize extension state during recovery",
    "cleanupState(sagaId) returns void": "clean up extension state when saga completes",
    "validateTerminology(sourceFiles) returns ValidationResult": "validates consistent term usage across codebase",
    "validateTypeNames() returns void": "ensures exact naming convention compliance"
  },
  "constants": {
    "SAGA_ID_PREFIX": "saga-",
    "DEFAULT_STEP_TIMEOUT": "30 seconds",
    "MAX_COMPENSATION_RETRIES": "3 attempts",
    "DEFAULT_SAGA_TIMEOUT": "30 minutes",
    "MIN_TIMEOUT": "1 second",
    "MAX_TIMEOUT": "24 hours",
    "WATCHDOG_INTERVAL": "10 seconds",
    "STUCK_HEARTBEAT_TIMEOUT": "5 minutes",
    "DLQ_ADMISSION_RETRY_THRESHOLD": "5 attempts",
    "GRACE_PERIOD_EXTENSION": "5 seconds",
    "PARALLEL_EXECUTION_TIMEOUT": "300 seconds",
    "MAX_PARALLEL_STEPS": "10",
    "PARTITION_REBALANCE_INTERVAL": "60 seconds interval for partition rebalancing",
    "PLUGIN_INITIALIZATION_TIMEOUT": "30 seconds timeout for plugin initialization",
    "EXTENSION_HEALTH_CHECK_INTERVAL": "30 seconds interval for extension health checks"
  },
  "terms": {
    "forward action": "business operation in normal saga execution path",
    "compensating action": "operation that semantically undoes a forward action",
    "saga orchestrator": "central coordinator that manages saga execution and compensation",
    "idempotency": "property that operations can be safely executed multiple times",
    "semantic rollback": "undoing business effects rather than technical database changes",
    "saga definition": "immutable template specifying workflow steps and compensation",
    "saga instance": "runtime execution state of specific saga",
    "step execution": "individual step tracking record with detailed status",
    "dependency resolution": "computing valid execution order from step dependencies",
    "compensation index": "tracks progress during rollback operations",
    "topological sort": "algorithm for ordering nodes in directed acyclic graph",
    "immutable template": "definition that never changes after creation",
    "execution plan": "ordered sequence of steps derived from dependencies",
    "task queue": "queue of execution tasks for worker processing",
    "saga lock": "per-saga synchronization mechanism",
    "compensation plan": "reverse-order execution sequence for rollback",
    "crash recovery": "resuming saga execution after orchestrator restart",
    "execution state storage": "persisting saga progress and step completion status",
    "duplicate detection": "preventing side effects from replayed messages",
    "monotonic progress": "saga never moves backward during recovery",
    "grace period": "additional time allowance before forced step termination",
    "timeout watchdog": "background service monitoring step execution duration",
    "stuck saga detection": "analysis system identifying sagas not making progress",
    "dead letter queue": "quarantine system for unresolvable sagas",
    "admin resolution API": "manual intervention interface for operators",
    "timeout action": "configured response when step exceeds time limit",
    "escalation level": "priority classification for DLQ entries",
    "audit trail": "comprehensive logging of administrative actions",
    "triage level": "classification system for prioritizing dead letter queue entries by urgency and complexity",
    "distributed tracing": "correlation of operations across services with timing",
    "saga visualization": "graphical representation of saga execution progress",
    "chaos testing": "systematic failure injection to verify resilience",
    "trace context propagation": "passing trace identifiers through execution",
    "compensation verification": "validating rollback operations correctness",
    "timeline visualization": "chronological display of saga execution events",
    "failure injection": "controlled introduction of failures",
    "business value metrics": "measurements connecting technical to business outcomes",
    "trace hierarchy": "parent-child relationship structure of spans",
    "request-response correlation": "linking responses to originating requests",
    "message envelope": "standardized wrapper for inter-component messages",
    "conversation state": "tracking request-response pairs",
    "failure taxonomy": "classification system for failure types",
    "cascading failure": "failure propagation affecting multiple components",
    "network partition": "communication loss between components",
    "compensation chain": "sequence of rollback operations in reverse order",
    "state reconciliation": "synchronizing state after partition resolution",
    "manual intervention": "human operator actions for complex failures",
    "backpressure": "flow control preventing system overload",
    "state inconsistencies": "mismatches between saga and step state",
    "performance bottlenecks": "components limiting saga throughput",
    "parallel step groups": "independent steps executing concurrently",
    "synchronization points": "coordination points for parallel completion",
    "conditional branching": "execution paths depending on runtime conditions",
    "nested saga composition": "hierarchical saga structures",
    "horizontal scaling": "distributing execution across instances",
    "saga partitioning": "dividing saga ownership among instances",
    "consistent hashing": "distribution minimizing reassignment",
    "partition failover": "automatic reassignment during failures",
    "batch state persistence": "accumulating changes before storage",
    "asynchronous step execution": "non-blocking step invocation",
    "admission control": "limiting concurrent saga execution",
    "plugin architecture": "extensible system for custom step types",
    "extension interface": "standard contract for functionality integration",
    "security context propagation": "maintaining identity throughout execution",
    "selective encryption": "encrypting sensitive fields while leaving operational data plaintext"
  }
}