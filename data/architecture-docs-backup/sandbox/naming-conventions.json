{
  "types": {
    "sandbox_config_t": "fields: program_path char*, program_args char**, chroot_path char*, memory_limit unsigned long, cpu_percent unsigned int, enable_network int, allowed_syscalls char**",
    "sandbox_state_t": "fields: child_pid pid_t, namespace_fd int[6], cgroup_path char*, cleanup_needed int",
    "namespace_state_t": "fields: pid_ns_fd int, mount_ns_fd int, net_ns_fd int, uts_ns_fd int, user_ns_fd int, initialized int",
    "fs_isolation_state_t": "fields: sandbox_root char*, old_root_path char*, mount_ns_fd int, cleanup_needed int",
    "device_spec": "fields: name char*, mode mode_t, major int, minor int",
    "mount_entry": "fields: path char*, next mount_entry*",
    "syscall_entry_t": "fields: name const char*, number int, arch_specific int",
    "sock_filter": "fields: code unsigned short, jt unsigned char, jf unsigned char, k unsigned int",
    "cgroup_limits_t": "fields: memory_limit_bytes unsigned long, cpu_quota_us unsigned int, cpu_period_us unsigned int, pid_max unsigned int, io_read_bps unsigned long, io_write_bps unsigned long",
    "cgroup_state_t": "fields: cgroup_path char*, instance_id char*, version cgroup_version_t, available_controllers cgroup_controller_t, managed_pids pid_t[256]",
    "cgroup_controller_t": "enum: CGROUP_CONTROLLER_MEMORY, CGROUP_CONTROLLER_CPU, CGROUP_CONTROLLER_PID, CGROUP_CONTROLLER_IO, CGROUP_CONTROLLER_ALL",
    "cgroup_version_t": "enum: CGROUP_VERSION_UNKNOWN, CGROUP_VERSION_V1, CGROUP_VERSION_V2, CGROUP_VERSION_HYBRID",
    "sandbox_lifecycle_state_t": "enum: SANDBOX_STATE_CREATED, SANDBOX_STATE_CONFIGURING, SANDBOX_STATE_RUNNING, SANDBOX_STATE_TERMINATING, SANDBOX_STATE_CLEANED_UP",
    "error_context_t": "fields: error_code int, severity error_severity_t, category error_category_t, component char[64], operation char[128], description char[256]",
    "cleanup_entry_t": "fields: type resource_type_t, resource_data void*, cleanup_func int(*)(void*), description char[128], entries TAILQ_ENTRY",
    "cleanup_manager_t": "fields: cleanup_queue TAILQ_HEAD, queue_mutex pthread_mutex_t, total_resources int, cleanup_failures int, cleanup_in_progress int",
    "health_check_result_t": "fields: check_name char[64], status int, message char[256], response_time_ms double, last_check_time time_t",
    "sandbox_health_t": "fields: sandbox sandbox_state_t*, process_health health_check_result_t, resource_health health_check_result_t, security_health health_check_result_t, network_health health_check_result_t, overall_health_score int, last_health_update time_t, monitor_thread pthread_t, monitoring_active int",
    "error_severity_t": "enum: ERROR_SEVERITY_INFO, ERROR_SEVERITY_WARNING, ERROR_SEVERITY_ERROR, ERROR_SEVERITY_CRITICAL, ERROR_SEVERITY_FATAL",
    "error_category_t": "enum: ERROR_CATEGORY_SYSTEM, ERROR_CATEGORY_RESOURCE, ERROR_CATEGORY_SECURITY, ERROR_CATEGORY_CONFIG, ERROR_CATEGORY_NETWORK",
    "resource_type_t": "enum: RESOURCE_TYPE_NAMESPACE_FD, RESOURCE_TYPE_MOUNT_POINT, RESOURCE_TYPE_CGROUP_DIR, RESOURCE_TYPE_PROCESS_ID, RESOURCE_TYPE_TEMP_FILE, RESOURCE_TYPE_DEVICE_NODE",
    "test_case_t": "fields: name char[128], test_func function pointer, passed int, executed int, error_msg char[256]",
    "child_test_context_t": "fields: child_pid pid_t, timeout_seconds int, expected_exit_code int, expected_signal int, start_time time_t",
    "resource_usage_t": "fields: memory_kb unsigned long, cpu_percent unsigned int, process_count int, io_read_bytes unsigned long, io_write_bytes unsigned long",
    "security_test_t": "fields: attack_name char[64], attack_func function pointer, expected_failure int",
    "debug_level_t": "enum: DEBUG_LEVEL_ERROR, DEBUG_LEVEL_WARN, DEBUG_LEVEL_INFO, DEBUG_LEVEL_DEBUG, DEBUG_LEVEL_TRACE",
    "namespace_info_t": "fields: pid pid_t, pid_ns ino_t, mnt_ns ino_t, net_ns ino_t, uts_ns ino_t, user_ns ino_t, cgroup_ns ino_t, hostname char[256], mount_count int, process_count int",
    "resource_snapshot_t": "fields: memory_usage_bytes unsigned long, memory_limit_bytes unsigned long, cpu_usage_percent double, io_read_bytes unsigned long, io_write_bytes unsigned long, process_count int, process_limit int, timestamp time_t",
    "syscall_trace_entry_t": "fields: syscall_name char[32], pid pid_t, return_value int, errno_value int, duration_ms double, arguments char[512], timestamp time_t",
    "sandbox_template_t": "fields: template_id char[64], base_path char[PATH_MAX], overlay_dir char[PATH_MAX], config sandbox_config_t*, reference_count int, created_time time_t",
    "metric_sample_t": "fields: metric_name char[128], value double, timestamp time_t, labels char[512]",
    "metrics_buffer_t": "fields: samples metric_sample_t*, capacity size_t, count size_t, mutex pthread_mutex_t",
    "process_pool_t": "fields: pool_size int, max_pool_size int, ready_processes sandbox_state_t**, busy_processes sandbox_state_t**, pool_mutex pthread_mutex_t, process_available pthread_cond_t",
    "security_event": "fields: pid pid_t, uid uid_t, comm char[16], event_type int, syscall_event/file_event union",
    "landlock_ruleset_attr": "fields: handled_access_fs __u64",
    "landlock_path_beneath_attr": "fields: allowed_access __u64, parent_fd __s32"
  },
  "methods": {
    "sandbox_config_init() returns sandbox_config_t*": "initialize configuration with defaults",
    "sandbox_config_free(sandbox_config_t*) returns void": "clean up configuration memory",
    "sandbox_state_init() returns sandbox_state_t*": "initialize runtime state",
    "create_sandbox(sandbox_config_t*, sandbox_state_t*) returns int": "main sandbox creation function",
    "cleanup_sandbox(sandbox_state_t*) returns void": "clean up sandbox resources",
    "sandbox_error(const char*, int) returns void": "error reporting utility",
    "check_root_privileges() returns int": "verify root access",
    "create_namespaces(namespace_state_t*) returns int": "initialize namespace isolation",
    "setup_filesystem_isolation(sandbox_config_t*, fs_isolation_state_t*) returns int": "main filesystem isolation setup",
    "cleanup_filesystem_isolation(fs_isolation_state_t*) returns void": "cleanup filesystem resources",
    "create_minimal_rootfs(const char*, const char*) returns int": "build minimal root filesystem",
    "create_tmpfs_mount(const char*, const char*, size_t) returns int": "mount tmpfs with options",
    "create_essential_devices(const char*) returns int": "populate /dev with safe devices",
    "cleanup_all_mounts() returns void": "unmount all tracked mount points",
    "track_mount(const char*) returns void": "add mount to cleanup list",
    "install_seccomp_filter(sandbox_config_t*) returns int": "main function to install BPF filter",
    "build_bpf_program(char**, struct sock_filter**, int*) returns int": "generate BPF instruction array from syscall whitelist",
    "validate_syscall_whitelist(char**) returns int": "verify syscall whitelist is safe and complete",
    "test_seccomp_filter() returns int": "comprehensive test of seccomp filter enforcement",
    "cgroup_state_init(const char*) returns cgroup_state_t*": "initialize cgroup management state",
    "cgroup_state_free(cgroup_state_t*) returns void": "clean up cgroup state",
    "detect_cgroup_capabilities(cgroup_state_t*) returns int": "detect available cgroup version and controllers",
    "create_cgroup_hierarchy(cgroup_state_t*) returns int": "create cgroup directories and hierarchy",
    "configure_resource_limits(cgroup_state_t*, const cgroup_limits_t*) returns int": "set resource limits in cgroup files",
    "add_process_to_cgroup(cgroup_state_t*, pid_t) returns int": "assign process to cgroup",
    "monitor_resource_usage(cgroup_state_t*) returns int": "read current resource usage statistics",
    "cleanup_cgroup_hierarchy(cgroup_state_t*) returns int": "terminate processes and remove cgroup",
    "create_default_limits() returns cgroup_limits_t*": "create default resource limit configuration",
    "validate_resource_limits(const cgroup_limits_t*) returns int": "validate resource limit values",
    "write_file_string(const char*, const char*) returns int": "write string to file utility",
    "read_file_string(const char*, char*, size_t) returns int": "read string from file utility",
    "directory_exists(const char*) returns int": "check if directory exists",
    "create_directory_recursive(const char*, mode_t) returns int": "create directory with parents",
    "drop_capabilities(const char**, size_t) returns int": "drop all capabilities except whitelisted ones",
    "set_no_new_privs() returns int": "Set PR_SET_NO_NEW_PRIVS flag",
    "change_user_group(uid_t, gid_t) returns int": "Change user and group IDs safely",
    "validate_capability_whitelist(const char**, size_t) returns int": "Validate capability whitelist is safe",
    "get_current_capabilities(cap_t*) returns int": "Get current process capabilities",
    "verify_capability_dropped(cap_value_t) returns int": "verify specific capability was dropped from process",
    "monitor_sandbox_lifecycle(sandbox_state_t*) returns int": "monitor child process state changes",
    "terminate_sandbox(sandbox_state_t*, int) returns int": "gracefully terminate sandbox with timeout",
    "sandbox_error_report(error_context_t*) returns void": "centralized error reporting and logging",
    "create_system_error(const char*, const char*, int) returns error_context_t*": "create error context from system call failure",
    "cleanup_manager_init() returns cleanup_manager_t*": "initialize resource cleanup tracking",
    "track_resource_for_cleanup(resource_type_t, void*, int(*)(void*), const char*) returns int": "add resource to cleanup queue",
    "cleanup_all_resources() returns void": "execute all cleanup operations with retry logic",
    "health_monitor_init(sandbox_state_t*) returns sandbox_health_t*": "initialize health monitoring for sandbox",
    "check_process_health(sandbox_state_t*, health_check_result_t*) returns int": "perform comprehensive process health check",
    "monitor_thread_main(void*) returns void*": "main monitoring thread function",
    "register_test(const char*, int (*)(void)) returns void": "register test case in global test registry",
    "run_child_test(child_test_context_t*, int (*)(void)) returns int": "execute test function in child process with timeout",
    "get_cgroup_usage(const char*, resource_usage_t*) returns int": "read resource usage statistics from cgroup",
    "test_namespace_isolation() returns int": "comprehensive test of namespace isolation mechanisms",
    "test_filesystem_isolation() returns int": "comprehensive test of filesystem containment",
    "test_resource_limits() returns int": "comprehensive test of resource limit enforcement",
    "test_capability_management() returns int": "comprehensive test of capability restriction",
    "test_complete_sandbox() returns int": "integration test of complete sandbox system",
    "test_container_escape() returns int": "security test attempting container breakout",
    "test_privilege_escalation() returns int": "security test attempting privilege escalation",
    "test_resource_exhaustion() returns int": "security test attempting resource exhaustion attacks",
    "debug_log(debug_level_t, const char*, const char*, ...) returns void": "log debugging messages with level filtering",
    "inspect_namespace_state(pid_t, namespace_info_t*) returns int": "capture namespace information for process",
    "get_resource_usage(const char*, resource_snapshot_t*) returns int": "read current resource consumption from cgroup",
    "trace_syscalls_to_file(pid_t, const char*, int) returns int": "capture system call trace to file",
    "analyze_trace_file(const char*, syscall_trace_entry_t*, int) returns int": "parse and analyze syscall trace file",
    "compare_namespace_states(const namespace_info_t*, const namespace_info_t*) returns int": "compare expected vs actual namespace configuration",
    "print_debugging_report(pid_t, const char*) returns void": "generate comprehensive debugging report",
    "diagnose_sandbox_failure(pid_t, const char*, const char*) returns int": "main diagnosis function for sandbox failures",
    "analyze_syscall_patterns(const syscall_trace_entry_t*, int, char*, size_t) returns int": "identify patterns in syscall traces",
    "run_interactive_debug_session(pid_t) returns int": "interactive debugging interface",
    "setup_landlock_filesystem_rules(const char**, size_t) returns int": "initialize Landlock ruleset for filesystem restrictions",
    "test_landlock_restrictions() returns int": "test Landlock restrictions by attempting file access",
    "setup_ebpf_security_monitor() returns int": "initialize eBPF security monitoring",
    "security_monitor_thread(void*) returns void*": "process security events from eBPF program",
    "create_sandbox_template(const char*, sandbox_config_t*) returns int": "create reusable sandbox template",
    "instantiate_from_template(const char*, sandbox_state_t*) returns int": "instantiate sandbox from template",
    "cleanup_template_instance(sandbox_state_t*) returns void": "clean up template instance",
    "metrics_init(const char*) returns int": "initialize metrics collection system",
    "record_security_metric(const char*, const char*, const char*) returns void": "record security metric",
    "collect_resource_metrics() returns void": "collect resource usage metrics from cgroups",
    "init_process_pool(int, int) returns process_pool_t*": "initialize process pool for sandbox reuse",
    "get_pooled_process(process_pool_t*, sandbox_config_t*) returns sandbox_state_t*": "get process from pool for task execution",
    "return_pooled_process(process_pool_t*, sandbox_state_t*) returns void": "return process to pool after task completion",
    "setup_namespace_isolation(namespace_state_t*) returns int": "create isolated namespaces for sandbox",
    "build_seccomp_filter(char**, struct sock_filter**, int*) returns int": "generate BPF program from syscall whitelist",
    "clone() returns pid_t": "create child process with namespace isolation",
    "pivot_root(char*, char*) returns int": "atomically change root filesystem",
    "prctl(int, ...) returns int": "set process attributes and security flags",
    "mount(char*, char*, char*, unsigned long, void*) returns int": "mount filesystems and bind mounts"
  },
  "constants": {
    "SANDBOX_SUCCESS": "0",
    "SANDBOX_ERROR_CONFIG": "1",
    "SANDBOX_ERROR_PRIVILEGE": "2",
    "SANDBOX_ERROR_NAMESPACE": "3",
    "SANDBOX_ERROR_FILESYSTEM": "4",
    "SANDBOX_ERROR_SECCOMP": "5",
    "SANDBOX_ERROR_CGROUP": "6",
    "SANDBOX_ERROR_CAPABILITY": "7",
    "SANDBOX_ERROR_EXEC": "8",
    "PATH_MAX": "maximum path length",
    "MS_NOSUID": "no setuid mount flag",
    "MS_NODEV": "mount flag no devices",
    "MS_NOEXEC": "mount flag no execution",
    "MS_RDONLY": "read-only mount flag",
    "MNT_DETACH": "lazy unmount flag",
    "SECCOMP_RET_ALLOW": "BPF allow system call",
    "SECCOMP_RET_ERRNO": "BPF return value returning error code",
    "SECCOMP_RET_KILL": "BPF kill process",
    "PR_SET_NO_NEW_PRIVS": "prevent privilege escalation flag",
    "CGROUP_V1_ROOT": "/sys/fs/cgroup",
    "CGROUP_V2_ROOT": "/sys/fs/cgroup/unified",
    "SANDBOX_CGROUP_PREFIX": "sandbox",
    "CAP_SYS_ADMIN": "dangerous capability with many privileges",
    "CAP_SYS_PTRACE": "dangerous capability allowing process tracing",
    "CLONE_NEWPID": "create new PID namespace",
    "CLONE_NEWMNT": "create new mount namespace",
    "CLONE_NEWNET": "create new network namespace",
    "CLONE_NEWUTS": "create new UTS namespace",
    "CLONE_NEWUSER": "create new user namespace",
    "MS_BIND": "bind mount flag"
  },
  "terms": {
    "process sandbox": "isolated execution environment using OS primitives",
    "defense-in-depth": "multiple independent security layers",
    "namespace": "isolated view of system resources",
    "seccomp": "system call filtering mechanism",
    "cgroups": "resource limiting and accounting subsystem",
    "capabilities": "subdivided root privileges",
    "chroot": "change root directory operation",
    "BPF": "Berkeley Packet Filter for system call filtering",
    "filesystem isolation": "restricting process view to minimal filesystem",
    "pivot_root": "atomic root filesystem swap operation",
    "tmpfs": "memory-backed temporary filesystem",
    "mount namespace": "isolated view of filesystem mounts",
    "device files": "special files providing access to kernel drivers",
    "overlay filesystem": "layered filesystem with read-only base and writable overlay",
    "dependency resolution": "finding all required shared libraries",
    "whitelist": "explicit list of allowed system calls",
    "system call": "interface between user space and kernel",
    "argument-level filtering": "filtering based on system call parameters",
    "resource exhaustion": "attack consuming excessive system resources",
    "hierarchical filesystem": "tree-structured organization of cgroups",
    "controller": "cgroup subsystem managing specific resource type",
    "quota": "allocated amount of resource consumption",
    "bandwidth throttling": "limiting resource consumption rate",
    "OOM killer": "kernel mechanism terminating memory-exhausting processes",
    "proactive enforcement": "preventing resource violations before they occur",
    "effective set": "currently active privileges",
    "permitted set": "maximum possible privileges",
    "inheritable set": "privileges that can transfer to child processes",
    "bounding set": "system-wide privilege ceiling",
    "ambient set": "simplified inheritance for unprivileged processes",
    "no new privileges": "flag preventing privilege escalation through exec",
    "privilege dropping": "systematic removal of unnecessary capabilities",
    "orchestration": "coordination of security components in correct sequence",
    "lifecycle management": "tracking sandbox state from creation to cleanup",
    "coordination channel": "communication mechanism between parent and child processes",
    "resource tracking": "maintaining references to allocated resources for cleanup",
    "cleanup ordering": "sequence of resource cleanup to handle dependencies",
    "health monitoring": "continuous observation of sandbox operational status",
    "misbehavior detection": "identifying processes violating expected behavior patterns",
    "automated recovery": "systematic response to failures without human intervention",
    "escalation": "triggering human attention when automated responses are insufficient",
    "unit testing": "testing individual security components in isolation",
    "integration testing": "testing complete sandbox with realistic workloads",
    "security validation": "systematic testing of attack scenarios and bypass attempts",
    "milestone checkpoint": "verification point ensuring component works before advancing",
    "penetration testing": "comprehensive security testing simulating real attacks",
    "namespace isolation": "separated view of system resources",
    "filesystem containment": "restricting process access to filesystem hierarchy",
    "seccomp filtering": "system call restriction using BPF programs",
    "resource limit enforcement": "cgroup-based resource consumption control",
    "capability management": "fine-grained privilege dropping and restriction",
    "symptom-based diagnosis": "mapping failure symptoms to likely root causes",
    "system call tracing": "monitoring process kernel interactions for debugging",
    "namespace inspection": "examining isolated views of system resources",
    "resource monitoring": "tracking cgroup resource consumption and limits",
    "seccomp violation": "process killed or blocked by system call filter",
    "capability analysis": "examining process privilege restrictions",
    "LSM": "Linux Security Module providing mandatory access control",
    "Landlock": "programmable LSM for application-level sandboxing",
    "seccomp notify": "mechanism allowing user space handling of filtered system calls",
    "eBPF": "extended Berkeley Packet Filter for kernel programming",
    "template-based optimization": "pre-creating sandbox environments for reuse",
    "process pool": "maintaining pre-configured processes for rapid task assignment",
    "memory deduplication": "sharing identical memory pages across processes",
    "metrics collection": "systematic gathering of operational and security data",
    "policy management": "centralized configuration and distribution of security policies",
    "incident response": "automated reaction to security events and operational failures"
  }
}