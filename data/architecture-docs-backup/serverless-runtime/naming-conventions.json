{
  "types": {
    "IsolationBenchmark": "fields: Technology string, Image string, Command []string",
    "ContainerManager": "interface for managing isolated execution environments",
    "Container": "fields: ID string, Image string, Status ContainerStatus, CreatedAt time.Time, Labels map[string]string, Names []string, Ports []Port",
    "ContainerStatus": "string constants: StatusCreated, StatusRunning, StatusPaused, StatusRestarting, StatusExited, StatusDead",
    "CreateContainerRequest": "fields: Image string, Cmd []string, Env []string, Labels map[string]string, CPUQuota int64, MemoryLimit int64, NetworkMode string, Binds []string, WorkingDir string, User string, SecurityOpts []string, ExposedPorts map[string]struct{}, PortBindings map[string][]PortBinding",
    "DockerManager": "fields: client *docker.Client",
    "FunctionDefinition": "fields: Name string, Runtime string, Handler string, CodePath string, Timeout int, MemoryMB int, CPUQuota int64, EnvVars map[string]string, Dependencies []string",
    "InvocationRequest": "fields: ID string, FunctionName string, FunctionVersion string, Payload []byte, Synchronous bool, Deadline time.Time, RequestID string, Source string, CreatedAt time.Time, PreferredInstanceID string, CallbackURL string",
    "Metrics": "fields: ColdStartLatency prometheus.Histogram, InvocationDuration prometheus.Histogram, ActiveInvocations prometheus.Gauge, InvocationErrors *prometheus.CounterVec, FunctionInvocations *prometheus.CounterVec, ContainerOperations *prometheus.CounterVec, MemoryUsageMB *prometheus.GaugeVec, CPUUsagePercent *prometheus.GaugeVec, ContainerCount *prometheus.GaugeVec",
    "FunctionInstance": "fields: ID string, FunctionName string, FunctionVersion string, State FunctionInstanceState, ContainerID string, Host string, Port int, MemoryUsageMB int, CPUUsage float64, CreatedAt time.Time, LastUsedAt time.Time, TerminatedAt *time.Time, InvocationCount int, TotalDurationMS int64",
    "FunctionInstanceState": "string constants: InstanceStateProvisioning, InstanceStateWarm, InstanceStateActive, InstanceStateDraining, InstanceStateTerminated, InstanceStateError",
    "InvocationResponse": "fields: RequestID string, Payload []byte, DurationMS int64, MemoryUsedMB int, BilledDurationMS int64, Error string, ErrorType string, InstanceID string, StartedAt time.Time, FinishedAt time.Time",
    "InvocationStatus": "fields: RequestID string, Status InvocationStatusType, Result *InvocationResponse, LastUpdated time.Time",
    "InvocationStatusType": "string constants: InvocationStatusPending, InvocationStatusRunning, InvocationStatusCompleted, InvocationStatusFailed, InvocationStatusTimeout",
    "ContainerStats": "fields: CPUPercent float64, MemoryUsage int64, MemoryLimit int64, MemoryPercent float64, NetworkRx int64, NetworkTx int64, BlockRead int64, BlockWrite int64, PIDs int, ReadAt time.Time",
    "ListFilter": "fields: Labels map[string]string, Status []ContainerStatus",
    "Port": "fields: IP string, PrivatePort uint16, PublicPort uint16, Type string",
    "PortBinding": "fields: HostIP string, HostPort string",
    "ProcessUploadResult": "fields: FunctionName string, Version string, ArtifactHash string, ArtifactSize int64, Dependencies []string",
    "UploadHandler": "fields: coordinator *packaging.Coordinator, maxUploadMB int64, tempDir string",
    "Coordinator": "fields: registry registry.Registry, storage storage.ArtifactStorage, bundlers map[string]bundler.Bundler, workspaceDir string",
    "GoBundler": "fields: goPath string, buildTarget string",
    "SeccompProfile": "fields: DefaultAction string, Architectures []string, Syscalls []SeccompSyscall",
    "SeccompSyscall": "fields: Name string, Action string, Args []SeccompArg",
    "SeccompArg": "fields: Index uint, Value uint64, ValueTwo uint64, Op string",
    "CGroupHelper": "fields: cgroupPath string, isV2 bool",
    "Executor": "fields: containerManager containermanager.ContainerManager, metrics *types.Metrics, config ExecutorConfig",
    "ExecutorConfig": "fields: DefaultTimeout time.Duration, MaxMemoryMB int64, MaxCPUQuota int64, TempDir string, BaseImages map[string]string",
    "WarmPoolManager": "fields: containerManager container.ContainerManager, config PoolConfig, store PoolStore, metrics *types.Metrics, cleanupTicker *time.Ticker, mu sync.RWMutex, functionDefs map[string]*types.FunctionDefinition",
    "PoolConfig": "fields: MaxWarmInstances int, MinWarmInstances int, InstanceTTL time.Duration, IdleTimeout time.Duration, CleanupInterval time.Duration, PreWarmThreshold float64",
    "PoolStore": "interface for storing warm instances",
    "RuntimeCleaner": "interface with Clean(ctx context.Context, containerID string) error method",
    "Gateway": "fields: router *Router, queueManager *queue.Manager, metrics *gatewayMetrics, config GatewayConfig, server *http.Server",
    "GatewayConfig": "fields: Addr string, MaxRequestBodyBytes int64, DefaultTimeout time.Duration, EnableMetrics bool, MetricsPath string, HealthCheckPath string",
    "gatewayMetrics": "fields: requestsTotal *prometheus.CounterVec, requestDuration *prometheus.HistogramVec, queueDepth *prometheus.GaugeVec, activeInvocations prometheus.Gauge, errorsTotal *prometheus.CounterVec",
    "Router": "fields: mu sync.RWMutex, functions map[string]*functionRoutingTable, instanceManager InstanceManager, config RouterConfig",
    "functionRoutingTable": "fields: functionName string, instances []*routedInstance, concurrencyLimit int32, activeCount int32, circuitBreaker *circuit.Breaker, lastScaleUpTime time.Time",
    "routedInstance": "fields: instance *types.FunctionInstance, activeReqs int32, lastUsed time.Time, failures int32, healthy bool",
    "RouterConfig": "fields: DefaultConcurrencyLimit int, CircuitBreakerThreshold int, CircuitBreakerTimeout time.Duration, StickySessionTTL time.Duration",
    "QueuedRequest": "fields: Request *types.InvocationRequest, EnqueuedAt time.Time, Priority int, index int",
    "RequestQueue": "fields: mu sync.Mutex, heap requestHeap, maxSize int, notEmpty *sync.Cond, notFull *sync.Cond, closed bool",
    "requestHeap": "array of *QueuedRequest",
    "ScaleDecision": "fields: FunctionName string, Direction ScaleDirection, Count int, Reason string",
    "ScaleDirection": "constants: ScaleUp, ScaleDown, ScaleNone",
    "MetricsCollector": "fields: mu sync.RWMutex, invocationBuffers map[string]*ring.Ring, windowSize time.Duration, concurrency map[string]int64",
    "InvocationEvent": "fields: Timestamp time.Time, FunctionName string",
    "Scaler": "fields: mu sync.RWMutex, metricsCollector *MetricsCollector, warmPool pool.WarmPoolManager, router *router.Router, configStore ConfigStore, activeFunctions map[string]bool, lastScaleUpTime map[string]time.Time, lastScaleDownTime map[string]time.Time, ticker *time.Ticker, stopChan chan struct{}, evalInterval time.Duration",
    "ScalingConfig": "fields: FunctionName string, MinInstances int, MaxInstances int, TargetConcurrency int, ScaleUpThreshold float64, ScaleDownThreshold float64, ScaleUpCooldown time.Duration, ScaleDownCooldown time.Duration, IdleTimeout time.Duration, WarmPoolSize int, MetricsWindow time.Duration",
    "FlowCoordinator": "fields: router *gateway.Router, warmPool pool.WarmPoolManager, scaler *scaler.Scaler, metrics *types.Metrics, eventBus chan lifecycle.InstanceEvent, timeoutConfig TimeoutConfig",
    "TimeoutConfig": "fields: GatewayTimeout time.Duration, RoutingTimeout time.Duration, ForwardingTimeout time.Duration, DrainTimeout time.Duration, HealthCheckTimeout time.Duration",
    "InstanceEvent": "fields: Type InstanceEventType, InstanceID string, FunctionName string, Timestamp time.Time, Data map[string]interface{}, Source string",
    "InstanceEventType": "string constants: EventCreateInstance, EventContainerStarted, EventRequestAssigned, EventRequestCompleted, EventRequestFailed, EventTTLExpired, EventIdleTimeout, EventScaleDownSignal, EventDrainCompleted, EventForceTerminate, EventHealthCheckFailed",
    "EventDispatcher": "fields: subscribers map[string]chan InstanceEvent, mu sync.RWMutex",
    "SynchronousInvoker": "fields: router *gateway.Router, eventDispatcher *lifecycle.EventDispatcher, metrics *types.Metrics, config SyncInvokerConfig",
    "SyncInvokerConfig": "fields: MaxQueueTime time.Duration, RetryOnColdStart bool, MaxRetries int, EnableStickyRouting bool",
    "StateMachine": "fields: instance *types.FunctionInstance, mu sync.RWMutex, handlers map[types.FunctionInstanceState]StateHandler, eventCh chan InstanceEvent",
    "StateHandler": "interface with HandleEvent method",
    "ClassifiedError": "fields: Err error, Type ErrorType, Retryable bool, ExitCode int, InstanceID string, Function string, Timestamp time.Time",
    "RecoveryPolicy": "fields: MaxRetries int, BackoffBase time.Duration, BackoffMax time.Duration, RetryOnSameInstance bool",
    "FakeClock": "fields: mu sync.RWMutex, current time.Time, timers []*fakeTimer",
    "fakeTimer": "fields: expiry time.Time, f func(), active bool",
    "RecordingMetrics": "fields: mu sync.RWMutex, ColdStartLatencies []float64, InvocationCounts map[string]int, ErrorCounts map[string]map[string]int",
    "MockContainerManager": "fields: mu sync.RWMutex, containers map[string]*types.Container, createDelay time.Duration, startDelay time.Duration, failCreate bool, failStart bool, opsRecorded []string",
    "WorkflowDefinition": "fields: Name string, Version string, StartAt string, Steps map[string]WorkflowStep, Timeout int",
    "WorkflowStep": "fields: Type string, FunctionName string, Next string, Catch []ErrorHandler, Retry []RetryPolicy",
    "DeviceMapping": "fields: HostPath string, ContainerPath string, Permissions string",
    "WorkflowState": "fields: ExecutionID string, CurrentStep string, Status string, Outputs map[string][]byte",
    "ErrorHandler": "fields: ErrorEquals []string, Next string",
    "RetryPolicy": "fields: ErrorEquals []string, IntervalSeconds int, MaxAttempts int, BackoffRate float64"
  },
  "methods": {
    "CreateContainer(ctx context.Context, req CreateContainerRequest) returns (*Container, error)": "creates a new isolated environment",
    "StartContainer(ctx context.Context, containerID string) returns error": "Simulates container startup",
    "ExecuteInContainer(ctx context.Context, containerID string, cmd []string, input io.Reader, output io.Writer) returns (int, error)": "runs a command inside a running container",
    "StopContainer(ctx context.Context, containerID string, timeout time.Duration) returns error": "gracefully stops a running container",
    "RemoveContainer(ctx context.Context, containerID string) returns error": "cleans up container resources",
    "GetContainerStats(ctx context.Context, containerID string) returns (*ContainerStats, error)": "returns resource usage statistics",
    "ListContainers(ctx context.Context, filter ListFilter) returns ([]Container, error)": "returns all managed containers",
    "NewMetrics() returns *Metrics": "creates and registers all Prometheus metrics for the runtime",
    "RecordColdStart(startTime time.Time) returns": "records the duration of a cold start invocation",
    "RecordInvocation(functionName string, startTime time.Time, err error) returns": "records the completion of a function invocation, including duration and any error",
    "HealthCheck(ctx context.Context) returns error": "verifies the container manager is operational",
    "Validate() returns error": "checks if the FunctionDefinition has required fields",
    "IsActive() returns bool": "returns true if the instance can accept new requests",
    "Age() returns time.Duration": "returns how long the instance has been running",
    "IdleDuration() returns time.Duration": "returns how long the instance has been idle",
    "IsExpired() returns bool": "returns true if the request has passed its deadline",
    "TimeRemaining() returns time.Duration": "returns how much time is left before the deadline",
    "ProcessUpload(ctx context.Context, def *types.FunctionDefinition, sourceDir string) returns (*ProcessUploadResult, error)": "Orchestrates complete packaging workflow",
    "GetBundler(runtime string) returns (bundler.Bundler, error)": "Returns bundler for a runtime",
    "ResolveDependencies(ctx context.Context, workDir string, deps []string) returns ([]string, error)": "Resolves Go dependencies using go mod",
    "BuildArtifact(ctx context.Context, workDir string, def FunctionDefinition) returns (string, error)": "Builds standalone Go binary",
    "ValidateHandler(ctx context.Context, workDir string, def FunctionDefinition) returns error": "Verifies handler exists in Go code",
    "GetBaseImage(runtime string) returns string": "Returns container image for Go runtime",
    "createWorkspace() returns (string, error)": "Creates unique workspace directory",
    "saveUploadedFile(file multipart.File, header *multipart.FileHeader, workspace, destName string) returns (string, error)": "Saves uploaded file to workspace",
    "computeFileHash(path string) returns (string, error)": "Computes SHA-256 hash of file",
    "NewCGroupHelper(path string) returns (*CGroupHelper, error)": "Creates a cgroup at the specified path",
    "SetMemoryLimit(limitBytes int64, swapBytes int64) returns error": "Configures memory limit and swap",
    "AddProcess(pid int) returns error": "Adds a process to the cgroup",
    "Cleanup() returns error": "Removes the cgroup",
    "DefaultSeccompProfile() returns (string, error)": "Returns a restrictive seccomp profile for serverless functions",
    "NewDockerManager() returns (*DockerManager, error)": "Creates a new DockerManager",
    "NewExecutor(cm containermanager.ContainerManager, metrics *types.Metrics, config ExecutorConfig) returns *Executor": "Creates a new function executor",
    "ExecuteFunction(ctx context.Context, def *types.FunctionDefinition, req *types.InvocationRequest) returns (*types.InvocationResponse, error)": "Runs a function in an isolated container",
    "CleanupIdleContainers(ctx context.Context, idleThreshold time.Duration) returns error": "Removes containers that have been idle beyond threshold",
    "AcquireWarmInstance(ctx context.Context, functionName string, version string) returns (*types.FunctionInstance, error)": "Gets a warm instance for the specified function",
    "ReleaseInstance(ctx context.Context, instance *types.FunctionInstance, healthy bool) returns error": "Returns an instance to the pool after execution",
    "PreWarm(ctx context.Context, functionName string, version string, count int) returns error": "Proactively creates warm instances",
    "CleanupInstance(ctx context.Context, cm container.ContainerManager, instance *types.FunctionInstance) returns error": "Resets an instance to a clean state",
    "cleanupExpired(ctx context.Context) returns error": "Removes instances that have exceeded their TTL or idle timeout",
    "NewGateway(router *Router, qm *queue.Manager, config GatewayConfig) returns *Gateway": "creates a new gateway instance",
    "Start() returns error": "begins serving HTTP requests",
    "Shutdown(ctx context.Context) returns error": "gracefully stops the gateway",
    "applyMiddleware(h http.Handler) returns http.Handler": "chains middleware in correct order",
    "invokeHandler(w http.ResponseWriter, r *http.Request) returns": "handles /invoke/{functionName} requests",
    "NewRouter(im InstanceManager, config RouterConfig) returns *Router": "creates a new router",
    "Route(ctx context.Context, req *types.InvocationRequest) returns (*types.InvocationResponse, error)": "routes an invocation request to an appropriate instance",
    "selectInstance(rt *functionRoutingTable, req *types.InvocationRequest) returns (*routedInstance, error)": "chooses an instance using least-connections strategy",
    "forwardRequest(ctx context.Context, instance *routedInstance, req *types.InvocationRequest) returns (*types.InvocationResponse, error)": "sends the request to a specific instance",
    "updateInstanceHealth(instance *routedInstance, success bool) returns": "updates circuit breaker based on success/failure",
    "NewRequestQueue(maxSize int) returns *RequestQueue": "creates a new bounded priority queue",
    "Enqueue(ctx context.Context, req *QueuedRequest) returns error": "adds a request to the queue with timeout",
    "Dequeue(ctx context.Context) returns (*QueuedRequest, error)": "removes and returns the highest priority request",
    "RemoveExpired(deadline time.Time) returns int": "removes and returns count of expired requests",
    "EvaluateScaling(ctx context.Context, functionName string) returns ScaleDecision": "Evaluates current metrics against scaling policies",
    "RecordInvocationMetric(ctx context.Context, functionName string, timestamp time.Time) returns error": "Records invocation for rate calculation",
    "StartScalingLoop(ctx context.Context) returns error": "Begins periodic scaling evaluation",
    "StopScalingLoop(ctx context.Context) returns error": "Stops scaling loop",
    "executeScaling(ctx context.Context, decision ScaleDecision) returns": "Performs actual scaling action",
    "evaluateAllFunctions(ctx context.Context) returns": "Checks all active functions for scaling needs",
    "GetRequestRate(functionName string) returns float64": "Calculates RPS over sliding window",
    "GetConcurrency(functionName string) returns int64": "Returns current concurrent executions",
    "RecordInvocation(functionName string, ts time.Time) returns": "Adds invocation timestamp",
    "IncrementConcurrency(functionName string) returns": "Increases concurrency count",
    "DecrementConcurrency(functionName string) returns": "Decreases concurrency count",
    "StartEventProcessor(ctx context.Context) returns": "processes lifecycle events in background goroutine",
    "handleEvent(ctx context.Context, event lifecycle.InstanceEvent) returns": "processes a single lifecycle event",
    "withTimeout(ctx context.Context, timeout time.Duration, operation string) returns (context.Context, context.CancelFunc)": "creates timeout context and records metrics",
    "Subscribe(id string, bufferSize int) returns <-chan InstanceEvent": "adds subscriber for events",
    "Publish(event InstanceEvent) returns": "sends event to all subscribers",
    "Invoke(ctx context.Context, req *types.InvocationRequest) returns (*types.InvocationResponse, error)": "handles synchronous invocation request",
    "handleColdStartRetry(ctx context.Context, originalErr error, req *types.InvocationRequest, attempt int) returns (bool, error)": "determines if cold start timeout should be retried",
    "Transition(ctx context.Context, newState types.FunctionInstanceState, reason string) returns error": "performs state transition with validation",
    "ProcessEvent(ctx context.Context, event InstanceEvent) returns error": "handles incoming lifecycle events",
    "validateTransition(oldState, newState types.FunctionInstanceState) returns bool": "validates state transition is allowed",
    "executeWithRecovery(ctx context.Context, def *types.FunctionDefinition, req *types.InvocationRequest) returns (*types.InvocationResponse, error)": "wraps function execution with error classification and recovery",
    "classifyExecutionError(rawErr error, def *types.FunctionDefinition, req *types.InvocationRequest) returns *errors.ClassifiedError": "maps raw execution errors to classified types",
    "Now() returns time.Time": "Returns the current fake time",
    "Advance(d time.Duration) returns": "Moves time forward by duration",
    "AfterFunc(d time.Duration, f func()) returns *fakeTimer": "Mimics time.AfterFunc",
    "check(now time.Time) returns": "Checks if timer has expired",
    "RecordColdStart(duration time.Duration) returns": "Captures a cold start duration",
    "RecordInvocation(functionName string, duration time.Duration, err error) returns": "Captures an invocation completion",
    "GetColdStartP95() returns float64": "Returns the 95th percentile cold start latency",
    "CreateContainer(ctx context.Context, req types.CreateContainerRequest) returns (*types.Container, error)": "Simulates container creation",
    "ListContainers(ctx context.Context, filter types.ListFilter) returns ([]types.Container, error)": "Returns mock containers",
    "InitTracer(serviceName, jaegerEndpoint) returns (func(context.Context) error, error)": "Initializes OpenTelemetry tracing with Jaeger exporter",
    "TraceContextFromRequest(r *http.Request) returns map[string]string": "Extracts trace context from HTTP headers",
    "AddTraceContextToInvocationRequest(req *types.InvocationRequest, traceCtx map[string]string) returns": "Adds trace context to an InvocationRequest",
    "Execute(ctx context.Context, input []byte) returns (string, error)": "Starts workflow execution and returns immediately (async execution)",
    "runWorkflow(ctx context.Context, execID string, input []byte) returns": "Internal goroutine that executes workflow steps",
    "GetStatus(ctx context.Context, execID string) returns (*WorkflowStatus, error)": "Returns the current status of a workflow execution",
    "SaveState(ctx context.Context, execID string, state *WorkflowState) returns error": "Saves workflow state to persistence",
    "LoadState(ctx context.Context, execID string) returns (*WorkflowState, error)": "Loads workflow state from persistence"
  },
  "constants": {
    "StatusCreated": "container has been created",
    "StatusRunning": "container is running",
    "StatusExited": "container has stopped",
    "StatusDead": "container is dead and cannot be restarted",
    "InstanceStateProvisioning": "container is being created/started",
    "InstanceStateWarm": "container is running and ready for requests",
    "InstanceStateActive": "container is currently executing a request",
    "InstanceStateDraining": "container is finishing current requests, no new requests",
    "InstanceStateTerminated": "container has been stopped and cleaned up",
    "InstanceStateError": "container is in an error state and needs recovery",
    "InvocationStatusPending": "asynchronous invocation is queued",
    "InvocationStatusRunning": "invocation is executing",
    "InvocationStatusCompleted": "invocation completed successfully",
    "InvocationStatusFailed": "invocation failed with error",
    "InvocationStatusTimeout": "invocation timed out",
    "EventCreateInstance": "instance creation initiated",
    "EventContainerStarted": "container started successfully",
    "EventRequestAssigned": "request assigned to instance",
    "EventRequestCompleted": "request completed successfully",
    "EventRequestFailed": "request failed with error",
    "EventTTLExpired": "instance TTL expired",
    "EventIdleTimeout": "instance idle timeout reached",
    "EventScaleDownSignal": "scale down signal received",
    "EventDrainCompleted": "drain completed successfully",
    "EventForceTerminate": "force termination required",
    "EventHealthCheckFailed": "health check failed",
    "ErrorTypeOOM": "error type for out-of-memory kills",
    "ErrorTypeTimeout": "error type for execution timeouts",
    "ErrorTypeCrash": "error type for application crashes",
    "ErrorTypeSandbox": "error type for sandbox escape attempts",
    "ErrorTypeNetwork": "error type for network failures",
    "ErrorTypeStorage": "error type for storage failures",
    "ErrorTypeStartup": "error type for container startup failures",
    "ErrorTypeHealthCheck": "error type for health check failures"
  },
  "terms": {
    "cold start": "Function invocation requiring creation and initialization of a new execution environment",
    "isolation": "preventing one function from observing, interfering with, or exhausting resources allocated to another function",
    "microVM": "lightweight virtual machine optimized for serverless workloads",
    "cgroups": "Linux control groups used to limit and account for resource usage (CPU, memory, I/O) of a process group",
    "namespaces": "Linux kernel feature that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set, providing isolation for processes",
    "seccomp": "secure computing mode, a Linux kernel feature that restricts the system calls a process can make",
    "AppArmor": "Linux security module that allows the system administrator to restrict programs' capabilities with per-program profiles",
    "control plane": "the system components responsible for orchestration, scaling, and management decisions",
    "data plane": "the system components responsible for actual request processing and function execution",
    "content-addressable storage": "Storage system where content is retrieved by its cryptographic hash rather than location or name",
    "dependency resolution": "Process of determining all required libraries and their compatible versions for a function",
    "immutable versioning": "Versioning scheme where once created, a version cannot be modified",
    "handler": "Entry point function that processes invocation requests",
    "artifact": "Self-contained package containing function code and all dependencies",
    "pop-up shop": "Analogy for temporary, isolated execution environments that are created on-demand and torn down after use",
    "zombie containers": "Containers that weren't properly cleaned up and continue consuming system resources",
    "OOM killer": "Linux out-of-memory killer that terminates processes when system memory is exhausted",
    "security hardening": "The process of securing a system by reducing its attack surface and eliminating vulnerabilities",
    "warm start": "Function invocation using a pre-initialized execution environment from the warm pool",
    "warm pool": "Collection of pre-initialized function instances ready for immediate use",
    "instance reuse": "Returning a container to the warm pool after execution for future invocations",
    "predictive warming": "Proactively creating warm instances based on traffic pattern analysis",
    "instance cleanup": "Process of resetting an execution environment to a fresh state before reuse",
    "least-connections": "load balancing strategy that sends requests to instance with fewest active connections",
    "circuit breaker": "pattern that prevents requests to unhealthy instances",
    "request queue": "bounded buffer for requests when all instances are busy",
    "timeout propagation": "passing deadline from client through all layers to function execution",
    "concurrency limit": "maximum number of simultaneous requests a function can handle",
    "sticky routing": "sending subsequent requests to same instance",
    "auto-scaling": "Dynamic adjustment of function instances based on demand",
    "scale-to-zero": "Removing all instances after idle timeout",
    "provisioned concurrency": "Minimum instances kept always warm",
    "scaling thrashing": "Rapid oscillation between scale-up and scale-down",
    "target concurrency": "Desired concurrent executions per instance",
    "cooldown period": "Minimum time between scaling actions of same direction",
    "idle timeout": "Duration an instance must be idle before termination",
    "hysteresis": "different thresholds for scale-up vs scale-down to prevent oscillation",
    "lifecycle event": "discrete occurrence that triggers state transition",
    "state machine": "component managing state transitions with validation",
    "flow coordinator": "orchestrates cross-component interactions",
    "event dispatcher": "distributes events to subscribers",
    "cold start retry": "retrying invocation after cold start timeout",
    "drain timeout": "maximum time allowed for graceful shutdown",
    "transition validation": "checking if state change is allowed",
    "defense-in-depth": "layered error handling with multiple fallbacks",
    "graceful degradation": "providing reduced functionality when full service isn't possible",
    "error propagation": "how errors flow through system components",
    "recovery state machine": "state machine managing instance recovery lifecycle",
    "load shedding": "Intentionally rejecting requests to prevent system overload",
    "exponential backoff": "retry strategy with increasing delays between attempts",
    "fail-stop": "design where components stop completely on failure rather than continue in undefined state",
    "Arrange-Act-Assert": "Unit test pattern with clear separation of test setup, execution, and verification",
    "property-based tests": "Tests that generate random inputs to discover edge cases",
    "golden files": "Reference test output files for comparison",
    "testcontainers": "Pattern for spinning up container dependencies in tests",
    "deterministic time": "Controllable time source for timing-sensitive tests",
    "custom domains": "Mapping user domain names to specific functions with advanced routing",
    "function composition": "Orchestrating multiple functions into workflows where output of one becomes input to another",
    "distributed tracing": "End-to-end tracking of requests across service boundaries using unique trace IDs",
    "ephemeral storage": "Instance-local persistent storage that lasts for the lifetime of a function instance",
    "GPU support": "Allocating and exposing graphics processing units to functions for accelerated computing",
    "multi-cloud deployment": "Running the runtime across multiple cloud providers and/or on-premises data centers",
    "event sources": "External systems that trigger function invocations, such as message queues or storage events",
    "workflow engine": "Component that interprets workflow definitions and manages stateful execution of steps",
    "trace context": "Set of headers (trace ID, span ID) that propagate across services for distributed tracing",
    "specialized hardware": "Accelerators like GPUs, FPGAs, or TPUs for compute-intensive workloads"
  }
}