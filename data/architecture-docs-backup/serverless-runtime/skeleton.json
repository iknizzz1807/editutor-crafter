{
  "title": "Serverless Function Runtime: Design Document",
  "overview": "This system provides a platform for running ephemeral, event-driven functions without managing servers. The key architectural challenge it solves is balancing strong isolation and fast startup times (cold start optimization) while efficiently scaling from zero to handle unpredictable workloads.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains the need for serverless computing, defines the 'cold start' problem, and compares existing isolation approaches (containers vs. VMs).",
      "subsections": [
        {
          "id": "mental-model-analogy",
          "title": "Mental Model: The Instant Coffee Machine vs. The Barista",
          "summary": "Uses an analogy to explain the trade-off between fast, pre-prepared execution (instant) and fully customizable, isolated execution (barista)."
        },
        {
          "id": "technical-problem",
          "title": "The Core Technical Challenge: Isolation vs. Speed",
          "summary": "Formalizes the problem of providing secure, multi-tenant isolation while minimizing the latency to execute a function for the first time."
        },
        {
          "id": "existing-approaches",
          "title": "Survey of Existing Approaches",
          "summary": "Compares container-based (Docker), microVM-based (Firecracker), and process-based (gVisor) runtimes with a focus on startup time and isolation."
        }
      ]
    },
    {
      "id": "goals-nongoals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the success criteria for the runtime and explicitly scopes out features not included in this initial design.",
      "subsections": []
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Presents the major system components (Controller, Gateway, Worker Pool, Storage) and their interactions, illustrated with a component diagram.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview and Responsibilities",
          "summary": "Describes the role of each core component in the system."
        },
        {
          "id": "file-structure",
          "title": "Recommended File and Module Structure",
          "summary": "Provides a suggested Go project layout to organize the codebase according to architectural components."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the core data structures for Functions, Invocations, and Runtime Environments, including their relationships.",
      "subsections": [
        {
          "id": "core-types",
          "title": "Core Types and Structures",
          "summary": "Tables describing FunctionDefinition, FunctionInstance, InvocationRequest, and other key types."
        },
        {
          "id": "lifecycle-states",
          "title": "Lifecycle State Definitions",
          "summary": "Defines the states for a FunctionInstance (e.g., COLD, WARM, ACTIVE, DRAINING)."
        }
      ]
    },
    {
      "id": "component-packaging",
      "title": "Component Design: Function Packaging",
      "summary": "Covers the design of the subsystem responsible for receiving, building, versioning, and storing function code artifacts. (Milestone 1)",
      "subsections": [
        {
          "id": "packaging-mental-model",
          "title": "Mental Model: The Shipping Dock and Warehouse",
          "summary": "Analogy comparing function packaging to receiving a kit of parts, assembling it, and storing it in a labeled warehouse bin."
        },
        {
          "id": "packaging-interface",
          "title": "Interface and Workflow",
          "summary": "Describes the API for uploading code and the internal steps for dependency resolution and artifact creation."
        },
        {
          "id": "packaging-adr-storage",
          "title": "ADR: Artifact Storage Strategy",
          "summary": "Decision record comparing object storage, content-addressable storage, and registry storage for function packages."
        },
        {
          "id": "packaging-pitfalls",
          "title": "Common Pitfalls in Function Packaging",
          "summary": "Discusses dependency hell, bloated packages, and improper versioning."
        },
        {
          "id": "packaging-implementation",
          "title": "Implementation Guidance for Packaging",
          "summary": "Provides starter code for the upload API and skeleton code for the language-specific bundlers."
        }
      ]
    },
    {
      "id": "component-execution",
      "title": "Component Design: Execution Environment",
      "summary": "Details the isolation mechanism for running function code, focusing on container lifecycle and resource limits. (Milestone 2)",
      "subsections": [
        {
          "id": "execution-mental-model",
          "title": "Mental Model: The Pop-Up Shop",
          "summary": "Analogy of a fully-stocked, temporary retail space that is created on-demand and torn down after use."
        },
        {
          "id": "execution-interface",
          "title": "Container Manager Interface",
          "summary": "Defines the interface for creating, executing within, and destroying isolated environments."
        },
        {
          "id": "execution-adr-isolation",
          "title": "ADR: Container vs. MicroVM Isolation",
          "summary": "Decision record comparing Linux container namespaces/cgroups versus Firecracker microVMs for security and performance."
        },
        {
          "id": "execution-pitfalls",
          "title": "Common Pitfalls in Execution Environment",
          "summary": "Covers resource limit misconfiguration, zombie containers, and sandbox escape vectors."
        },
        {
          "id": "execution-implementation",
          "title": "Implementation Guidance for Execution",
          "summary": "Provides helper code for cgroup setup and skeleton code for the container lifecycle manager."
        }
      ]
    },
    {
      "id": "component-cold-start",
      "title": "Component Design: Cold Start Optimization",
      "summary": "Describes strategies to minimize function startup latency, including warm pools and snapshot/restore. (Milestone 3)",
      "subsections": [
        {
          "id": "coldstart-mental-model",
          "title": "Mental Model: The Taxi Stand",
          "summary": "Analogy comparing a pool of idle, ready-to-go taxis (warm containers) to calling for a new one to be built from scratch (cold start)."
        },
        {
          "id": "coldstart-interface",
          "title": "Warm Pool Manager Interface",
          "summary": "Defines the interface for acquiring, releasing, and managing pre-initialized environments."
        },
        {
          "id": "coldstart-adr-pooling",
          "title": "ADR: Pooling Strategy - Eager vs. Lazy",
          "summary": "Decision record comparing pre-warming a fixed number of instances versus creating them just-in-time."
        },
        {
          "id": "coldstart-pitfalls",
          "title": "Common Pitfalls in Cold Start Optimization",
          "summary": "Discusses memory bloat from large pools, stale environments, and over-complicated snapshotting."
        },
        {
          "id": "coldstart-implementation",
          "title": "Implementation Guidance for Cold Start",
          "summary": "Provides skeleton code for the warm pool manager and lifecycle hooks for environment reuse."
        }
      ]
    },
    {
      "id": "component-routing",
      "title": "Component Design: Request Routing",
      "summary": "Covers the HTTP gateway, load balancing, request queuing, and concurrency limits. (Milestone 4)",
      "subsections": [
        {
          "id": "routing-mental-model",
          "title": "Mental Model: The Restaurant Host and Waitlist",
          "summary": "Analogy comparing the gateway to a host who seats guests (routes requests) and manages a waitlist (queue) when all tables (instances) are full."
        },
        {
          "id": "routing-interface",
          "title": "Gateway API and Internal Routing",
          "summary": "Describes the public HTTP endpoint and the internal mechanism for selecting a function instance."
        },
        {
          "id": "routing-adr-loadbalancing",
          "title": "ADR: Load Balancing Strategy",
          "summary": "Decision record comparing round-robin, least-connections, and consistent hashing (for sticky sessions) routing."
        },
        {
          "id": "routing-pitfalls",
          "title": "Common Pitfalls in Request Routing",
          "summary": "Covers unbounded queue growth, thundering herd on scale-up, and improper timeouts."
        },
        {
          "id": "routing-implementation",
          "title": "Implementation Guidance for Routing",
          "summary": "Provides starter code for the HTTP gateway and skeleton code for the request queue and load balancer."
        }
      ]
    },
    {
      "id": "component-autoscaling",
      "title": "Component Design: Auto-Scaling",
      "summary": "Explains the logic for scaling the number of function instances up and down based on observed load. (Milestone 5)",
      "subsections": [
        {
          "id": "scaling-mental-model",
          "title": "Mental Model: The Elastic Concert Hall",
          "summary": "Analogy of a hall that automatically adds or removes seating sections based on the number of ticket-holders in line."
        },
        {
          "id": "scaling-interface",
          "title": "Scaler Interface and Metrics",
          "summary": "Defines the interface for checking metrics and triggering scale actions, and lists the key metrics (RPS, concurrency)."
        },
        {
          "id": "scaling-adr-algorithm",
          "title": "ADR: Scaling Algorithm - Reactive vs. Predictive",
          "summary": "Decision record comparing simple threshold-based scaling to more complex predictive models."
        },
        {
          "id": "scaling-pitfalls",
          "title": "Common Pitfalls in Auto-Scaling",
          "summary": "Discusses scaling oscillation (thrashing), ignoring cold start latency, and costly minimum instance counts."
        },
        {
          "id": "scaling-implementation",
          "title": "Implementation Guidance for Auto-Scaling",
          "summary": "Provides skeleton code for the scaling decision loop and integration with the warm pool."
        }
      ]
    },
    {
      "id": "interactions-dataflow",
      "title": "Interactions and Data Flow",
      "summary": "Walks through the complete sequence of a function invocation, from HTTP request to response, highlighting interactions between all components.",
      "subsections": [
        {
          "id": "sequence-sync-invoke",
          "title": "Synchronous Invocation Flow",
          "summary": "Step-by-step walkthrough of a synchronous HTTP function call, including cold and warm path variations."
        },
        {
          "id": "lifecycle-events",
          "title": "Function Instance Lifecycle Events",
          "summary": "Describes the events that trigger state transitions (e.g., request arrival, timeout, scale-down signal)."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Catalogues expected failure modes (e.g., OOM, timeout, instance crash) and the system's recovery strategy for each.",
      "subsections": [
        {
          "id": "failure-modes-table",
          "title": "Failure Modes and Mitigations",
          "summary": "A table listing failures, their detection, and the automatic recovery action (e.g., retry on new instance)."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Outlines a testing approach, from unit tests for components to integration tests for the full system, with milestone checkpoints.",
      "subsections": [
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Implementation Checkpoints",
          "summary": "For each milestone, describes the expected behavior and commands to verify correct implementation."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "A practical guide for diagnosing common issues during development, organized as symptom-cause-fix tables.",
      "subsections": [
        {
          "id": "common-bugs-table",
          "title": "Common Bug Symptoms and Fixes",
          "summary": "Table listing symptoms (e.g., 'Function times out immediately'), likely causes, and steps to fix."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Describes potential enhancements like custom domains, function composition, and advanced observability, and how the current design accommodates them.",
      "subsections": []
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key terms used throughout the document, such as Cold Start, MicroVM, CRIU, and Concurrency.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "sys-component-diagram",
      "title": "System Component Overview",
      "description": "Shows the main components (User, HTTP Gateway, Controller, Worker Pool with Warm/Cold instances, Storage) and their network connections. Highlight the data flow for an API request.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture"
      ]
    },
    {
      "id": "data-model-diagram",
      "title": "Core Data Relationships",
      "description": "A class diagram showing the relationships between FunctionDefinition, FunctionInstance, InvocationRequest, and RuntimeSnapshot. Include cardinalities (1-to-many).",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "instance-state-machine",
      "title": "Function Instance Lifecycle",
      "description": "A state machine diagram for a FunctionInstance. States: PROVISIONING, READY (Warm), ACTIVE, DRAINING, TERMINATED. Transitions triggered by events like 'request assigned', 'execution finished', 'scale-down signal'.",
      "type": "state-machine",
      "relevant_sections": [
        "data-model",
        "component-cold-start",
        "component-autoscaling"
      ]
    },
    {
      "id": "sequence-sync-invocation",
      "title": "Sequence: Synchronous Invocation (Cold Start)",
      "description": "Sequence diagram showing the interaction between User, Gateway, Controller, Worker Pool, and Storage for a cold start invocation. Include steps: route request, acquire warm instance (miss), create cold instance, load code, execute, return response.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-dataflow",
        "component-routing",
        "component-cold-start"
      ]
    },
    {
      "id": "flowchart-scaling-logic",
      "title": "Flowchart: Scale-Up Decision Logic",
      "description": "A flowchart for the auto-scaler's decision loop. Start with 'Check metrics'. Decision diamonds for 'Concurrency > Threshold?' and 'Cool-down period elapsed?'. Actions: 'Launch new instance', 'Wait and re-check'.",
      "type": "flowchart",
      "relevant_sections": [
        "component-autoscaling"
      ]
    }
  ]
}