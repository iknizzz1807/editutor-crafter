{
  "title": "Service Discovery: Design Document",
  "overview": "A service registry system that allows microservices to announce their availability and discover other services dynamically. The key architectural challenge is maintaining an accurate, real-time view of service health across a distributed system where services can fail or become unreachable at any time.",
  "sections": [
    {
      "id": "context-and-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains the service discovery problem using real-world analogies and compares existing solutions.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "Mental Model: The Phone Book Analogy",
          "summary": "Understanding service discovery through the lens of a dynamic phone directory."
        },
        {
          "id": "existing-solutions",
          "title": "Existing Solutions Comparison",
          "summary": "Analysis of DNS, load balancers, and service mesh approaches with trade-offs."
        }
      ]
    },
    {
      "id": "goals-and-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what the service registry will and will not provide in terms of functionality and guarantees.",
      "subsections": []
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Component overview showing the registry core, health checker, and HTTP API with their interactions.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "The three main components and their responsibilities."
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "How to organize the codebase across packages and modules."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Core data structures for service instances, health status, and registry state with their relationships.",
      "subsections": []
    },
    {
      "id": "service-registry-core",
      "title": "Service Registry Core",
      "summary": "The central component that manages service registration, deregistration, and lookup operations.",
      "subsections": [
        {
          "id": "registry-mental-model",
          "title": "Mental Model: The Hotel Reception Desk",
          "summary": "Understanding service registration through hotel check-in/check-out processes."
        },
        {
          "id": "registry-interface",
          "title": "Registry Interface",
          "summary": "Public methods for registration, lookup, and management operations."
        },
        {
          "id": "registry-algorithms",
          "title": "Core Algorithms",
          "summary": "Step-by-step procedures for registration, deregistration, and lookup."
        },
        {
          "id": "registry-adrs",
          "title": "Architecture Decision Records",
          "summary": "Key decisions around instance identity, concurrent access, and TTL handling."
        },
        {
          "id": "registry-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Typical mistakes in implementing service registration and how to avoid them."
        },
        {
          "id": "registry-implementation",
          "title": "Implementation Guidance",
          "summary": "Technology choices, starter utilities, and skeleton code for the registry core."
        }
      ]
    },
    {
      "id": "health-checker",
      "title": "Health Checker",
      "summary": "Background component that monitors service health and removes failed instances from the registry.",
      "subsections": [
        {
          "id": "health-mental-model",
          "title": "Mental Model: The Security Guard Rounds",
          "summary": "Understanding health checking through security patrol analogies."
        },
        {
          "id": "health-interface",
          "title": "Health Checker Interface",
          "summary": "Methods for managing health checks and processing results."
        },
        {
          "id": "health-algorithms",
          "title": "Health Check Algorithms",
          "summary": "Procedures for scheduling checks, handling failures, and updating registry state."
        },
        {
          "id": "health-adrs",
          "title": "Architecture Decision Records",
          "summary": "Decisions around check intervals, failure thresholds, and protocol support."
        },
        {
          "id": "health-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Issues with network partitions, check timeouts, and cascading failures."
        },
        {
          "id": "health-implementation",
          "title": "Implementation Guidance",
          "summary": "HTTP client utilities, check scheduling, and core health logic skeleton."
        }
      ]
    },
    {
      "id": "http-api",
      "title": "HTTP API Layer",
      "summary": "REST API that exposes registry operations to services and clients over HTTP.",
      "subsections": [
        {
          "id": "api-mental-model",
          "title": "Mental Model: The Information Desk",
          "summary": "Understanding the API layer as a customer service interface."
        },
        {
          "id": "api-endpoints",
          "title": "API Endpoints",
          "summary": "Complete specification of REST endpoints with request/response formats."
        },
        {
          "id": "api-adrs",
          "title": "Architecture Decision Records",
          "summary": "Decisions around REST design, error codes, and request validation."
        },
        {
          "id": "api-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Issues with input validation, error handling, and concurrent requests."
        },
        {
          "id": "api-implementation",
          "title": "Implementation Guidance",
          "summary": "HTTP server setup, routing utilities, and handler skeleton code."
        }
      ]
    },
    {
      "id": "interactions-and-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "How components communicate and the sequence of operations for key workflows like service registration and health checking.",
      "subsections": [
        {
          "id": "registration-flow",
          "title": "Service Registration Flow",
          "summary": "Step-by-step process when a service joins the registry."
        },
        {
          "id": "lookup-flow",
          "title": "Service Lookup Flow",
          "summary": "How clients discover and retrieve healthy service instances."
        },
        {
          "id": "health-check-flow",
          "title": "Health Check Flow",
          "summary": "Background process for monitoring and updating service health status."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Failure modes, detection strategies, and recovery mechanisms for network issues, service failures, and system overload.",
      "subsections": [
        {
          "id": "network-failures",
          "title": "Network Failure Scenarios",
          "summary": "Handling network partitions, timeouts, and connectivity issues."
        },
        {
          "id": "service-failures",
          "title": "Service Failure Detection",
          "summary": "Distinguishing between temporary and permanent service failures."
        },
        {
          "id": "system-overload",
          "title": "System Overload Protection",
          "summary": "Rate limiting, resource management, and graceful degradation."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Comprehensive testing approach covering unit tests, integration scenarios, and milestone validation checkpoints.",
      "subsections": [
        {
          "id": "unit-testing",
          "title": "Unit Testing Approach",
          "summary": "Testing individual components in isolation with mocks and test data."
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing Scenarios",
          "summary": "End-to-end workflows and component interaction testing."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Validation Checkpoints",
          "summary": "What to verify after completing each milestone and expected behavior."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Systematic approach to diagnosing common issues with symptom-cause-fix mapping and debugging techniques.",
      "subsections": [
        {
          "id": "common-symptoms",
          "title": "Common Symptoms and Diagnosis",
          "summary": "Mapping observable problems to likely root causes and diagnostic steps."
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques",
          "summary": "Tools and approaches for inspecting registry state and tracing issues."
        },
        {
          "id": "logging-strategy",
          "title": "Logging and Observability",
          "summary": "What to log and how to trace operations through the system."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements like clustering, security, and advanced health checks that the current design can accommodate.",
      "subsections": []
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of technical terms, acronyms, and domain-specific vocabulary used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-components",
      "title": "System Component Architecture",
      "description": "Shows the three main components (Registry Core, Health Checker, HTTP API) and their relationships, including data flow between them and external services/clients.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-and-data-flow"
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model Relationships",
      "description": "Illustrates the core data structures (ServiceInstance, HealthStatus, Registry) and their relationships, showing how service metadata and health information are connected.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "registration-sequence",
      "title": "Service Registration Sequence",
      "description": "Step-by-step sequence showing how a service registers itself, from HTTP request through registry storage to health check initiation.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-and-data-flow",
        "http-api"
      ]
    },
    {
      "id": "health-check-flow",
      "title": "Health Check Process Flow",
      "description": "Flowchart showing the health checker's decision process: check scheduling, HTTP requests, failure counting, and registry updates.",
      "type": "flowchart",
      "relevant_sections": [
        "health-checker",
        "interactions-and-data-flow"
      ]
    },
    {
      "id": "service-lifecycle",
      "title": "Service Instance State Machine",
      "description": "State transitions for a service instance from registration through healthy/unhealthy states to deregistration, showing events that trigger each transition.",
      "type": "state-machine",
      "relevant_sections": [
        "service-registry-core",
        "health-checker"
      ]
    },
    {
      "id": "lookup-sequence",
      "title": "Service Discovery Sequence",
      "description": "Shows how a client discovers services: HTTP request to API, registry lookup, health filtering, and response with healthy instances.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-and-data-flow",
        "http-api"
      ]
    },
    {
      "id": "failure-scenarios",
      "title": "Failure Scenario Flowchart",
      "description": "Decision tree for handling different types of failures: network timeouts, service unavailability, and registry errors with recovery actions.",
      "type": "flowchart",
      "relevant_sections": [
        "error-handling",
        "health-checker"
      ]
    },
    {
      "id": "concurrent-access",
      "title": "Concurrent Registry Access",
      "description": "Shows how multiple concurrent operations (registrations, lookups, health updates) interact with shared registry state and synchronization points.",
      "type": "sequence",
      "relevant_sections": [
        "service-registry-core",
        "error-handling"
      ]
    }
  ]
}