{
  "types": {
    "signal_handler_func_t": "function pointer for signal handlers",
    "signal_registration_t": "fields: signal_num int, handler signal_handler_func_t, original_action struct sigaction, is_registered bool",
    "signal_mask_op_t": "enum: SIGNAL_MASK_BLOCK, SIGNAL_MASK_UNBLOCK, SIGNAL_MASK_SETMASK",
    "signal_pipe_t": "fields: write_fd int, read_fd int, is_initialized bool",
    "event_type_t": "enum: EVENT_TYPE_SOCKET, EVENT_TYPE_TIMER, EVENT_TYPE_SIGNAL, EVENT_TYPE_USER",
    "event_descriptor_t": "fields: fd int, type event_type_t, callback function pointer, callback_data void pointer",
    "signal_result_t": "enum: SIGNAL_RESULT_SUCCESS, SIGNAL_RESULT_ERROR, SIGNAL_RESULT_IGNORED, SIGNAL_RESULT_DEFERRED",
    "signal_error_t": "enum: SIGNAL_SUCCESS, SIGNAL_ERROR_INVALID, SIGNAL_ERROR_SYSTEM, SIGNAL_ERROR_EXISTS, SIGNAL_ERROR_NOTFOUND",
    "signal_stats_t": "fields: signals_delivered, signals_processed, pipe_writes, pipe_reads, write_failures, read_failures, mask_operations",
    "sigset_t": "POSIX signal set type",
    "struct sigaction": "POSIX signal action configuration",
    "event_loop_t": "fields: poll_fds, descriptors, max_descriptors, active_descriptors, signal_pipe, shutdown_requested, stats",
    "event_callback_func_t": "function pointer for event callbacks",
    "signal_error_state_t": "fields: handler_errors sig_atomic_t, pipe_write_failures sig_atomic_t, mask_operation_failures sig_atomic_t, pipe_overflow_count sig_atomic_t, recovery_attempts sig_atomic_t, last_error_signal sig_atomic_t, error_flags sig_atomic_t",
    "recovery_context_t": "fields: state recovery_state_t, start_time time_t, attempts int, max_attempts int, last_error signal_error_t",
    "signal_health_metrics_t": "fields: signals_processed uint64_t, pipe_writes_successful uint64_t, pipe_writes_failed uint64_t, mask_operations_successful uint64_t, mask_operations_failed uint64_t, recovery_operations uint64_t, avg_signal_latency double, last_health_check time_t",
    "recovery_state_t": "enum: RECOVERY_IDLE, RECOVERY_ACTIVE, RECOVERY_SUCCESS, RECOVERY_FAILED, RECOVERY_ESCALATE",
    "test_shared_data_t": "fields: signals_received array, handler_executed, test_completed, error_occurred, last_signal_number, handler timing",
    "test_process_t": "fields: child_pid, shared_data pointer, sync_pipe array, result_pipe array",
    "debug_event_type_t": "enum: DEBUG_EVENT_SIGNAL_RECEIVED, DEBUG_EVENT_HANDLER_ENTER, DEBUG_EVENT_HANDLER_EXIT, DEBUG_EVENT_PIPE_WRITE, DEBUG_EVENT_PIPE_READ, DEBUG_EVENT_MASK_CHANGE, DEBUG_EVENT_ERROR_DETECTED",
    "debug_event_t": "fields: type debug_event_type_t, signal_num int, pid pid_t, timestamp struct timespec, error_code int, sequence_number sig_atomic_t",
    "debug_buffer_t": "fields: events debug_event_t array, write_index sig_atomic_t, read_index sig_atomic_t, lost_events sig_atomic_t, log_fd int, enabled sig_atomic_t",
    "race_detector_t": "fields: operation_in_progress sig_atomic_t, signal_during_operation sig_atomic_t, operation_type sig_atomic_t, operation_start struct timespec, signal_arrival struct timespec",
    "sig_atomic_t": "POSIX atomic signal type",
    "struct timespec": "POSIX time structure with nanosecond precision",
    "pid_t": "POSIX process ID type",
    "advanced_signal_registration_t": "fields: signal_num int, handler union, original_action struct sigaction, is_registered bool, use_extended_handler bool, queue_signals bool",
    "rt_signal_queue_entry_t": "fields: signal_num int, sender_pid pid_t, sender_uid int, signal_value union sigval, delivery_time struct timespec, delivery_code int",
    "enhanced_signal_pipe_t": "fields: write_fd int, read_fd int, is_initialized bool, supports_signalfd bool, signal_fd int, signal_mask sigset_t",
    "async_signal_event_t": "fields: type event_type_t, signal_num int, signal_data union sigval, sender_pid pid_t, timestamp struct timespec, completion_callback function pointer, callback_context void pointer",
    "signal_stream_t": "fields: pipe enhanced_signal_pipe_t, event_queue pointer, queue_size int, queue_head int, queue_tail int, event_filter function pointer, event_handler function pointer",
    "shutdown_coordinator_t": "fields: signal_stream pointer, shutdown_requested bool, shutdown_deadline time_t, shutdown_phase int, phase_handlers array, force_shutdown bool",
    "config_reload_manager_t": "fields: config_file_path char pointer, last_reload_time time_t, reload_in_progress bool, validation_callback function pointer, apply_callback function pointer, rollback_callback function pointer"
  },
  "methods": {
    "signal_error_string(error) returns const char*": "Convert error code to human-readable string",
    "signal_get_stats() returns signal_stats_t": "Get current signal handling statistics",
    "signal_reset_stats() returns void": "Reset statistics counters to zero",
    "signal_is_valid(signal_num) returns bool": "Validate signal number against POSIX requirements",
    "signal_create_set(set, signals, count) returns signal_error_t": "Create signal set from array of signal numbers",
    "signal_check_pending(signal_num, is_pending) returns signal_error_t": "Check if signal is pending delivery",
    "signal_to_name(signal_num) returns const char*": "Convert signal number to human-readable name",
    "sigaction(signal, action, old_action) returns int": "POSIX signal handler registration",
    "sigprocmask(how, set, oldset) returns int": "POSIX signal mask manipulation",
    "sigemptyset(set) returns int": "Initialize empty signal set",
    "sigaddset(set, signal) returns int": "Add signal to signal set",
    "signal_register_handler(signal_num, handler) returns signal_error_t": "Register signal handler using sigaction() with proper flags",
    "signal_unregister_handler(signal_num) returns signal_error_t": "Remove signal handler and restore original behavior",
    "signal_is_registered(signal_num) returns bool": "Check if specific signal has registered handler",
    "signal_register_handler(signal_num, handler)": "Register signal handler using sigaction()",
    "signal_unregister_handler(signal_num)": "Remove signal handler and restore original",
    "signal_is_registered(signal_num)": "Check if signal has registered handler",
    "signal_error_string(error)": "Convert error code to string",
    "signal_is_valid(signal_num)": "Validate signal number",
    "signal_to_name(signal_num)": "Convert signal number to name",
    "sigaction(signal, action, old_action)": "POSIX signal handler registration",
    "sigprocmask(how, set, oldset)": "POSIX signal mask manipulation",
    "signal_mask_block(signals_to_block, old_mask) returns signal_error_t": "Block additional signals, saving previous mask",
    "signal_mask_unblock(signals_to_unblock, old_mask) returns signal_error_t": "Unblock specified signals, saving previous mask",
    "signal_mask_set(new_mask, old_mask) returns signal_error_t": "Replace entire signal mask, saving previous mask",
    "signal_mask_get_current(current_mask) returns signal_error_t": "Get currently active signal mask",
    "signal_mask_push(additional_signals) returns signal_error_t": "Push additional signal blocks onto mask stack",
    "signal_mask_pop() returns signal_error_t": "Pop most recent mask level from stack",
    "signal_get_all_pending(pending_signals) returns signal_error_t": "Get all currently pending signals",
    "signal_pipe_create(pipe) returns int": "Create and configure signal notification pipe",
    "signal_pipe_destroy(pipe) returns int": "Clean up and close pipe descriptors",
    "signal_pipe_notify(pipe, signal_num) returns int": "Write signal notification to pipe (async-signal-safe)",
    "signal_pipe_read_notifications(pipe, signals, max_count) returns int": "Read multiple signal notifications from pipe",
    "signal_pipe_add_to_fdset(pipe, read_fds, max_fd) returns int": "Add pipe read descriptor to select() fd_set",
    "signal_pipe_add_to_pollfd(pipe, pfd) returns int": "Configure pipe descriptor for poll() monitoring",
    "signal_stats_reset() returns void": "Reset statistics counters to zero",
    "poll() returns int": "Poll multiple file descriptors for events",
    "select() returns int": "Monitor multiple file descriptors for I/O",
    "record_signal_error(error_type, signal_num) returns void": "Record error in async-signal-safe manner",
    "signal_detect_registration_errors() returns signal_error_t": "Check for signal handler registration failures",
    "signal_monitor_mask_health() returns signal_error_t": "Monitor signal mask operation health",
    "signal_check_pipe_health(pipe) returns signal_error_t": "Check self-pipe mechanism integrity",
    "signal_perform_recovery(error_type, context) returns signal_error_t": "Perform recovery operation based on error type",
    "signal_emergency_recovery() returns signal_error_t": "Emergency recovery when normal recovery fails",
    "create_test_process() returns test_process_t*": "Create isolated test process with shared memory communication",
    "cleanup_test_process(proc) returns void": "Clean up test process and shared resources",
    "send_signal_to_child(proc, signal_num) returns int": "Send signal to child test process",
    "verify_test_results(proc) returns int": "Verify test results from shared memory",
    "kill(pid, signal) returns int": "Send signal to process",
    "fork() returns pid_t": "Create child process",
    "mmap() returns void*": "Create shared memory mapping",
    "clock_gettime() returns int": "Get precise timestamps",
    "debug_signal_init() returns int": "Initialize debugging infrastructure during program startup",
    "debug_record_event(type, signal_num, error_code) returns void": "Record debug event from signal handler - async-signal-safe",
    "debug_process_events() returns int": "Process debug events from main loop - not async-signal-safe",
    "debug_operation_begin(operation_type) returns void": "Mark beginning of race-prone operation",
    "debug_operation_end() returns void": "Mark end of race-prone operation",
    "debug_signal_during_operation(signal_num) returns void": "Call from signal handler to detect races",
    "clock_gettime(clock_id, timespec) returns int": "Get precise timestamps using POSIX realtime clock",
    "write(fd, buffer, count) returns ssize_t": "Write data to file descriptor - async-signal-safe",
    "open(path, flags, mode) returns int": "Open file descriptor with specified flags",
    "getpid() returns pid_t": "Get current process ID - async-signal-safe",
    "snprintf(buffer, size, format, ...) returns int": "Format string safely with size limit",
    "create_signalfd_pipe(pipe, signals) returns int": "Create signalfd() descriptor for enhanced signal handling",
    "process_signalfd_events(pipe, entries, max_entries) returns int": "Process multiple signals from signalfd() in batch"
  },
  "constants": {
    "MAX_SIGNALS": "32",
    "SIGNAL_PIPE_BUF_SIZE": "256",
    "SA_RESTART": "sigaction flag to restart interrupted system calls",
    "SA_NODEFER": "sigaction flag to allow signal reentrancy",
    "SA_SIGINFO": "sigaction flag for extended signal information",
    "SIGINT": "Interrupt signal from keyboard",
    "SIGTERM": "Termination request signal",
    "SIGHUP": "Hangup signal",
    "SIGUSR1": "User-defined signal 1",
    "SIGUSR2": "User-defined signal 2",
    "SIGKILL": "Uncatchable kill signal",
    "SIGSTOP": "Uncatchable stop signal",
    "EINTR": "Interrupted system call",
    "MAX_MASK_STACK_DEPTH": "16",
    "SIG_BLOCK": "Add signals to current mask",
    "SIG_UNBLOCK": "Remove signals from current mask",
    "SIG_SETMASK": "Replace current mask completely",
    "O_NONBLOCK": "Non-blocking file descriptor flag",
    "FD_CLOEXEC": "Close-on-exec flag",
    "EAGAIN": "Resource temporarily unavailable",
    "POLLIN": "data available for reading",
    "PIPE_BUF": "atomic pipe write size limit",
    "ERROR_FLAG_PIPE_BROKEN": "1 << 0",
    "ERROR_FLAG_HANDLER_CRASH": "1 << 1",
    "ERROR_FLAG_MASK_CORRUPT": "1 << 2",
    "ERROR_FLAG_RECOVERY_NEEDED": "1 << 3",
    "EINVAL": "Invalid argument error",
    "EPERM": "Permission denied error",
    "ENOMEM": "Out of memory error",
    "EEXIST": "File exists error",
    "EMFILE": "Too many open files",
    "ENFILE": "File table overflow",
    "EBADF": "Bad file descriptor",
    "EPIPE": "Broken pipe",
    "ENOSYS": "Function not implemented",
    "MAP_SHARED": "mmap flag for shared memory",
    "MAP_ANONYMOUS": "mmap flag for anonymous memory",
    "DEBUG_EVENT_BUFFER_SIZE": "1024",
    "DEBUG_LOG_PATH": "/tmp/signal_debug.log",
    "DEBUG_EVENT_SIGNAL_RECEIVED": "Signal delivery detected",
    "DEBUG_EVENT_HANDLER_ENTER": "Signal handler execution started",
    "DEBUG_EVENT_HANDLER_EXIT": "Signal handler execution completed",
    "DEBUG_EVENT_PIPE_WRITE": "Self-pipe write operation",
    "DEBUG_EVENT_PIPE_READ": "Self-pipe read operation",
    "DEBUG_EVENT_MASK_CHANGE": "Signal mask modification",
    "DEBUG_EVENT_ERROR_DETECTED": "Error condition detected",
    "O_WRONLY": "Open file for write only",
    "O_CREAT": "Create file if it doesn't exist",
    "O_APPEND": "Append to end of file",
    "O_CLOEXEC": "Close-on-exec file descriptor flag",
    "CLOCK_REALTIME": "Wall-clock time for timestamps",
    "errno": "Global error number variable",
    "SIGRTMIN": "First real-time signal number",
    "SIGRTMAX": "Last real-time signal number"
  },
  "terms": {
    "async-signal-safety": "Property of functions safe to call from signal handlers",
    "reentrancy": "Ability to be interrupted and safely called again",
    "signal masking": "Temporarily blocking signal delivery during sensitive operations",
    "self-pipe trick": "Technique to convert async signals to sync events using pipe",
    "signal coalescing": "Multiple identical signals combined into single delivery",
    "critical section": "Code region requiring atomic execution without interruption",
    "graceful shutdown": "Clean process termination with resource cleanup",
    "event loop integration": "Combining signal handling with I/O multiplexing",
    "portable signal handling": "Using POSIX-standard interfaces across Unix systems",
    "pending signals": "Signals delivered but blocked from handler execution",
    "temporal atomicity": "Guarantee that operations complete without interruption",
    "non-blocking I/O": "I/O operations that return immediately if no data available",
    "pipe buffer overflow": "Condition when pipe buffer fills and write operations fail",
    "graceful degradation": "System continues with reduced functionality when components fail",
    "recovery escalation": "Progressive increase in recovery intervention level",
    "health monitoring": "Continuous assessment of system component status",
    "error coalescing": "Combining multiple similar errors into single recovery action",
    "failure isolation": "Preventing component failures from affecting other components",
    "recovery validation": "Verifying that recovery actions successfully restored functionality",
    "emergency shutdown": "Controlled process termination when recovery fails",
    "behavioral validation": "Defining specific, measurable behaviors for testing",
    "controlled signal simulation": "Creating test environments with predictable signal delivery",
    "race condition testing": "Testing timing-dependent signal handling scenarios",
    "race condition": "Timing-dependent bug where program behavior depends on event ordering",
    "strace": "System call tracing utility for debugging",
    "gdb": "GNU debugger with signal handling support",
    "timing window": "Period during which race conditions can occur",
    "event correlation": "Matching related events across different log sources",
    "statistical analysis": "Using repeated testing to identify intermittent problems",
    "buffer overflow": "Condition when circular buffer fills beyond capacity",
    "atomic operation": "Operation that completes without interruption",
    "instrumentation": "Adding monitoring code to track program behavior",
    "real-time signals": "POSIX signals that guarantee queuing and ordered delivery",
    "signalfd()": "Linux system call converting signals to file descriptor events",
    "eventfd()": "Linux file descriptor optimized for event notification",
    "signal queuing": "Mechanism to preserve multiple signal deliveries",
    "framework integration": "Connecting signal handling with higher-level programming abstractions"
  }
}