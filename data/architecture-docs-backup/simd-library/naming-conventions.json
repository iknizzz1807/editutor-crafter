{
  "types": {
    "cpu_features_t": "fields: sse_supported bool, sse2_supported bool, sse3_supported bool, ssse3_supported bool, sse41_supported bool, sse42_supported bool, avx_supported bool, avx2_supported bool, avx512f_supported bool",
    "benchmark_result_t": "fields: mean_ns double, stddev_ns double, iterations size_t, min_ns double, max_ns double",
    "memset_func_t": "function pointer: void (*)(void *dst, int value, size_t size)",
    "memcpy_func_t": "function pointer: void (*)(void *dst, const void *src, size_t size)",
    "strlen_func_t": "function pointer: size_t (*)(const char *str)",
    "__m128i": "SSE 128-bit integer vector register",
    "__m128": "SSE 128-bit single-precision float vector register",
    "milestone_validator_t": "fields: milestone_name const char*, validate_functional_goal bool (*)(), validate_performance_goal bool (*)(), run_milestone_tests void ()()",
    "__m256": "AVX 256-bit single-precision float vector register",
    "benchmark_context_t": "fields: measurements uint64_t*, capacity size_t, count size_t, start_time uint64_t, total_time uint64_t",
    "speedup_analysis_t": "fields: arithmetic_speedup double, throughput_speedup double, efficiency_speedup double, statistical_confidence double, significant_improvement bool",
    "vectorization_analysis_t": "fields: vectorized_successfully bool, vector_width_detected int, limiting_factors const char*[], limiting_factor_count int",
    "safe_processing_plan_t": "fields: ptr const void*, size size_t, safe_simd_bytes size_t, prologue_bytes size_t, epilogue_bytes size_t",
    "error_recovery_strategy_t": "enum: RECOVERY_SCALAR_FALLBACK, RECOVERY_ALIGNMENT_CORRECTION, RECOVERY_UNALIGNED_SIMD, RECOVERY_BOUNDARY_AWARE_SIMD",
    "test_input_t": "fields: buffer void*, size size_t, alignment_offset size_t",
    "extended_cpu_features_t": "fields: sse_supported bool, sse2_supported bool, avx_supported bool, avx2_supported bool, avx512f_supported bool, avx512dq_supported bool, avx512vl_supported bool, avx512bw_supported bool, thermal_monitoring_supported bool, current_frequency_mhz int, thermal_headroom_celsius int",
    "thermal_state_t": "fields: base_frequency_mhz int, current_frequency_mhz int, temperature_celsius int, frequency_scaling_active bool, last_thermal_check_ns uint64_t",
    "simd_vector_128_t": "fields: x86_vector __m128i, arm_vector uint8x16_t, scalar_data uint8_t[16]",
    "gpu_device_info_t": "fields: device_name char[256], global_memory_bytes size_t, local_memory_bytes size_t, compute_units int, max_work_group_size int, supports_double_precision bool, supports_unified_memory bool",
    "gpu_memory_context_t": "fields: gpu_buffer void*, buffer_size_bytes size_t, is_mapped_memory bool, last_access_time_ns uint64_t",
    "image_buffer_t": "fields: pixel_data uint8_t*, width int, height int, channels int, stride_bytes int",
    "complex_t": "fields: real float, imag float",
    "dispatch_target_t": "enum: DISPATCH_CPU_SCALAR, DISPATCH_CPU_SIMD, DISPATCH_GPU_COMPUTE, DISPATCH_HYBRID_CPU_GPU"
  },
  "methods": {
    "detect_cpu_features(void)": "Initialize global CPU feature detection",
    "cpu_has_sse2(void) returns bool": "Check if processor supports SSE2 instructions",
    "cpu_has_avx(void) returns bool": "Check if processor supports AVX instructions",
    "cpu_has_avx2(void) returns bool": "Check if processor supports AVX2 instructions",
    "get_time_ns(void) returns uint64_t": "Get current time in nanoseconds using monotonic clock",
    "benchmark_function(func, arg) returns benchmark_result_t": "Execute function multiple times and return timing statistics",
    "print_benchmark_result(name, result)": "Display formatted benchmark results with statistics",
    "simd_library_init(void)": "Initialize library with optimal function dispatch based on CPU features",
    "simd_memset(dst, value, size)": "Public API for optimized memory set operation",
    "sse_memset(dst, value, size)": "SSE2-optimized memory set implementation",
    "sse_memcpy(dst, src, size)": "SSE2-optimized memory copy implementation",
    "_mm_set1_epi8(value) returns __m128i": "Create vector with byte value replicated to all positions",
    "_mm_load_si128(ptr) returns __m128i": "Load 128-bit vector from 16-byte aligned memory",
    "_mm_loadu_si128(ptr) returns __m128i": "Load 128-bit vector from unaligned memory",
    "_mm_store_si128(ptr, vector)": "Store 128-bit vector to 16-byte aligned memory",
    "_mm_storeu_si128(ptr, vector)": "Store 128-bit vector to unaligned memory",
    "_mm_cmpeq_epi8(a, b) returns __m128i": "Compare bytes for equality across vector lanes",
    "_mm_movemask_epi8(vector) returns int": "Extract sign bits from each byte into bitmask",
    "_mm_mul_ps(a, b) returns __m128": "Parallel single-precision floating-point multiplication",
    "validate_speedup_goal(simd_result, scalar_result, target_speedup) returns bool": "Check if measured speedup meets target",
    "aligned_alloc_16(size) returns void*": "Allocate 16-byte aligned memory",
    "is_aligned_16(ptr) returns bool": "Check if pointer is 16-byte aligned",
    "get_memset_implementation(void) returns memset_func_t": "Return currently selected memset implementation for testing",
    "simd_strlen(str) returns size_t": "SIMD-optimized string length calculation",
    "simd_memchr(buf, c, size) returns void*": "SIMD-optimized byte search in buffer",
    "get_strlen_implementation() returns strlen_func_t": "Return currently selected strlen implementation for testing",
    "cpu_has_sse2() returns bool": "Check if processor supports SSE2 instructions",
    "_mm_add_ps(a, b) returns __m128": "Parallel single-precision floating-point addition",
    "_mm_load_ps(ptr) returns __m128": "Load 4 floats from 16-byte aligned memory",
    "_mm_loadu_ps(ptr) returns __m128": "Load 4 floats from unaligned memory",
    "_mm_shuffle_ps(a, b, mask) returns __m128": "Shuffle and combine elements from two vectors",
    "_mm_extract_ps(vector, index) returns int": "Extract single float from vector register",
    "_mm256_zeroupper()": "Clear upper AVX register state to avoid transition penalties",
    "get_time_ns() returns uint64_t": "Get current time in nanoseconds using monotonic clock",
    "calculate_speedup(baseline, optimized) returns double": "Calculate arithmetic speedup ratio between implementations",
    "is_statistically_converged(ctx) returns bool": "Check if measurement variance has stabilized",
    "analyze_performance_improvement(baseline, optimized, data_size) returns speedup_analysis_t": "Comprehensive speedup analysis with statistical validation",
    "analyze_compiler_vectorization(source_file, function_name, compiler_flags) returns vectorization_analysis_t": "Detect and analyze compiler auto-vectorization results",
    "safe_for_simd_load(ptr, load_size) returns bool": "Check if SIMD load is safe for memory boundaries",
    "bytes_to_page_boundary(ptr) returns size_t": "Calculate bytes until next page boundary",
    "plan_safe_simd_processing(ptr, size, vector_width) returns safe_processing_plan_t": "Generate safe processing plan for SIMD operations",
    "select_recovery_strategy(ptr, size, features) returns error_recovery_strategy_t": "Determine optimal error recovery strategy",
    "safe_simd_operation(dst, src, size, simd_func, scalar_func) returns int": "Execute SIMD operation with comprehensive error handling",
    "benchmark_function_adaptive(func, args, min_iterations, min_duration_ns) returns benchmark_result_t": "Execute function multiple times with adaptive convergence",
    "cpu_has_avx() returns bool": "Check if processor supports AVX instructions",
    "cpu_has_avx2() returns bool": "Check if processor supports AVX2 instructions",
    "benchmark_context_init(ctx, max_measurements)": "Initialize benchmark context for measurement collection",
    "benchmark_add_measurement(ctx, measurement_ns)": "Add measurement to context and update statistics",
    "benchmark_calculate_statistics(ctx) returns benchmark_result_t": "Calculate statistical properties of collected measurements",
    "create_aligned_test_input(size, alignment_offset) returns test_input_t": "Create test input with specified size and alignment",
    "fill_test_pattern(buffer, size, pattern)": "Fill test buffer with specified pattern for deterministic testing",
    "validate_simd_memset_correctness() returns bool": "Comprehensive memset correctness validation",
    "milestone1_functional_validation() returns bool": "SSE2 basics functional validation checkpoint",
    "milestone1_performance_validation() returns bool": "SSE2 basics performance validation checkpoint",
    "milestone1_comprehensive_tests()": "SSE2 basics comprehensive testing suite",
    "detect_extended_cpu_features(features) returns void": "Initialize extended feature detection including AVX-512 subsets",
    "should_use_avx512_implementation(thermal) returns bool": "Monitor thermal state for AVX-512 frequency scaling decisions",
    "update_thermal_state(thermal) returns void": "Update thermal monitoring state",
    "simd_load_128(ptr) returns simd_vector_128_t": "Cross-platform abstracted vector load",
    "simd_store_128(ptr, vector) returns void": "Cross-platform abstracted vector store",
    "simd_add_8x16(a, b) returns simd_vector_128_t": "Cross-platform abstracted vector addition",
    "simd_compare_eq_8x16(a, b) returns simd_vector_128_t": "Cross-platform abstracted vector comparison",
    "simd_movemask_8x16(vector) returns int": "Cross-platform abstracted movemask operation",
    "initialize_gpu_acceleration() returns bool": "Initialize GPU acceleration support",
    "enumerate_gpu_devices(devices, max_devices) returns int": "Detect available GPU devices and capabilities",
    "select_optimal_gpu_device(data_size, operation_type) returns int": "Select optimal device for workload characteristics",
    "determine_optimal_dispatch(data_size, operation_type, cpu_features, gpu_info) returns dispatch_target_t": "Determine optimal processing target based on workload characteristics",
    "simd_rgb_to_grayscale(input, output) returns void": "RGB to grayscale conversion with SIMD optimization",
    "simd_gaussian_blur(input, output, sigma, kernel_radius) returns void": "Gaussian blur implementation with separable kernel optimization",
    "simd_fft_radix2(data, n) returns void": "Fast Fourier Transform with SIMD butterfly operations"
  },
  "constants": {
    "MIN_BENCHMARK_TIME_NS": "100000000 nanoseconds minimum benchmark duration",
    "MAX_BENCHMARK_ITERATIONS": "10000000 maximum benchmark iterations",
    "SIMD_ALIGNMENT_16": "16-byte alignment boundary for SSE operations",
    "SIMD_ALIGNMENT_32": "32-byte alignment boundary for AVX operations",
    "SIMD_LIB_VERSION_MAJOR": "1 library major version",
    "SIMD_LIB_VERSION_MINOR": "0 library minor version",
    "PAGE_SIZE": "4096 bytes memory page size",
    "STATISTICAL_CONFIDENCE_THRESHOLD": "0.05 coefficient of variation threshold for convergence"
  },
  "terms": {
    "vectorization": "process of converting scalar operations to operate on multiple data elements simultaneously",
    "intrinsics": "C function interface to processor SIMD instructions allowing explicit vector programming",
    "auto-vectorization": "compiler optimization that automatically converts scalar loops to SIMD instructions",
    "scalar processing": "traditional computing model processing one data element per instruction",
    "vector processing": "SIMD computing model processing multiple data elements per instruction",
    "alignment": "memory address requirement where data must start at specific byte boundaries",
    "prologue": "initial scalar processing of unaligned data before main SIMD loop",
    "epilogue": "final scalar processing of remaining data after main SIMD loop",
    "horizontal operations": "SIMD operations that combine data across vector lanes within same register",
    "lane independence": "property that SIMD operations occur independently in each vector position",
    "instruction-level parallelism": "CPU ability to execute multiple instructions simultaneously",
    "cache line utilization": "efficiency measure of how much data from loaded cache lines is actually used",
    "runtime dispatch": "technique for selecting optimal function implementation based on detected CPU features",
    "CPUID": "x86 instruction for querying processor capabilities and feature support",
    "performance contract": "explicit agreement defining measurable performance requirements",
    "statistical significance": "confidence level that measured performance differences are not due to random variation",
    "memory bandwidth utilization": "efficiency measure of how much theoretical memory throughput is achieved",
    "function pointer dispatch": "method of selecting implementation variants through function pointer tables",
    "feature detection": "process of querying processor capabilities to enable optimal code paths",
    "domain-driven structure": "organization approach that groups code by functional domain rather than technical layer",
    "bitmask extraction": "process of converting vector comparison results to scalar bit patterns",
    "parallel comparison": "SIMD technique for comparing multiple data elements simultaneously",
    "movemask": "SSE instruction that extracts sign bits from vector lanes into scalar bitmask",
    "page boundary": "4KB memory boundary that may cause access violations if crossed unexpectedly",
    "bit scanning": "technique for finding position of first or last set bit in a word",
    "alignment offset": "number of bytes from current position to next alignment boundary",
    "coefficient of variation": "standard deviation divided by mean, measuring relative variability",
    "throughput measurement": "performance metric based on data processing rate rather than execution time",
    "graceful degradation": "automatic fallback to less optimal but functional implementations when optimal versions are unavailable",
    "boundary violation": "memory access that extends beyond allocated or mapped memory regions",
    "conservative boundary checking": "safety strategy that transitions to scalar processing before reaching danger zones",
    "thermal monitoring": "tracking processor temperature and frequency scaling for optimal instruction set selection",
    "cross-platform abstraction": "unified interface that provides consistent API across different processor architectures",
    "hybrid execution": "coordinated processing approach that dynamically partitions work between CPU and GPU",
    "separable kernel": "convolution optimization that decomposes 2D operations into two 1D operations",
    "butterfly operations": "fundamental FFT computation pattern that combines pairs of complex numbers",
    "memory transfer overhead": "performance cost of moving data between CPU and GPU memory spaces"
  }
}