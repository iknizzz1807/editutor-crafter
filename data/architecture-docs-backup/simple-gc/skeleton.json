{
  "title": "Simple Garbage Collector: Design Document",
  "overview": "A mark-sweep garbage collector that automatically reclaims unused memory by traversing object graphs and freeing unreachable objects. The key architectural challenge is safely identifying live objects while handling reference cycles, stack scanning, and memory layout complexities.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains the fundamental memory management problem that garbage collection solves and why manual memory management is error-prone",
      "subsections": [
        {
          "id": "memory-problem",
          "title": "The Memory Management Problem",
          "summary": "Why manual memory allocation and deallocation leads to bugs like memory leaks and use-after-free"
        },
        {
          "id": "gc-approaches",
          "title": "Garbage Collection Approaches",
          "summary": "Comparison of different GC strategies like reference counting, mark-sweep, and copying collectors"
        }
      ]
    },
    {
      "id": "goals-nongoals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what this garbage collector will and will not do, setting clear scope boundaries",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Core features like automatic memory reclamation and cycle detection"
        },
        {
          "id": "non-functional-goals",
          "title": "Non-Functional Goals",
          "summary": "Performance and scalability targets"
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Advanced GC features we explicitly won't implement"
        }
      ]
    },
    {
      "id": "architecture",
      "title": "High-Level Architecture",
      "summary": "Component overview showing the allocator, object model, root discovery, and mark-sweep phases",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Main components and their responsibilities"
        },
        {
          "id": "gc-lifecycle",
          "title": "GC Lifecycle",
          "summary": "The sequence of operations during a garbage collection cycle"
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "How to organize the codebase into modules"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model and Object Representation",
      "summary": "Defines the object header format, type system, and allocation tracking structures (Milestone 1)",
      "subsections": [
        {
          "id": "object-header",
          "title": "Object Header Design",
          "summary": "Structure containing type information, mark bit, and size"
        },
        {
          "id": "type-system",
          "title": "Type System",
          "summary": "Support for integers, pairs, and strings with runtime type dispatch"
        },
        {
          "id": "allocation-tracking",
          "title": "Allocation Tracking",
          "summary": "Linked list of all allocated objects for sweep phase"
        }
      ]
    },
    {
      "id": "root-discovery",
      "title": "Root Discovery System",
      "summary": "Identifies and enumerates all GC roots from stack, globals, and registers (Milestone 2)",
      "subsections": [
        {
          "id": "root-concept",
          "title": "Root Set Concept",
          "summary": "What constitutes a root and why roots are the starting point for reachability"
        },
        {
          "id": "stack-scanning",
          "title": "Stack Scanning",
          "summary": "Conservative scanning of call stack frames to find pointer values"
        },
        {
          "id": "global-roots",
          "title": "Global and Register Roots",
          "summary": "Tracking references in global variables and CPU registers"
        },
        {
          "id": "precise-conservative",
          "title": "Precise vs Conservative Scanning",
          "summary": "Trade-offs between accuracy and implementation complexity"
        }
      ]
    },
    {
      "id": "mark-phase",
      "title": "Mark Phase Implementation",
      "summary": "Graph traversal algorithm that marks all reachable objects starting from roots (Milestone 3)",
      "subsections": [
        {
          "id": "marking-algorithm",
          "title": "Marking Algorithm",
          "summary": "Depth-first traversal with mark bit checking to handle cycles"
        },
        {
          "id": "worklist-approach",
          "title": "Worklist vs Recursion",
          "summary": "Using explicit stack to avoid stack overflow on deep object graphs"
        },
        {
          "id": "tricolor-marking",
          "title": "Tri-Color Marking Theory",
          "summary": "Conceptual model of white, gray, and black objects during marking"
        }
      ]
    },
    {
      "id": "sweep-phase",
      "title": "Sweep Phase Implementation",
      "summary": "Reclaims unmarked objects and resets the heap for the next cycle (Milestone 4)",
      "subsections": [
        {
          "id": "sweep-algorithm",
          "title": "Sweep Algorithm",
          "summary": "Linear walk through allocation list to identify and free unmarked objects"
        },
        {
          "id": "memory-reclamation",
          "title": "Memory Reclamation",
          "summary": "Returning freed memory to the allocator and updating data structures"
        },
        {
          "id": "mark-reset",
          "title": "Mark Bit Reset",
          "summary": "Clearing mark bits on surviving objects for next collection"
        }
      ]
    },
    {
      "id": "interactions-dataflow",
      "title": "Component Interactions and Data Flow",
      "summary": "How the allocator, roots, marking, and sweeping phases coordinate during GC cycles",
      "subsections": [
        {
          "id": "allocation-flow",
          "title": "Allocation Flow",
          "summary": "How objects get created and added to the allocation list"
        },
        {
          "id": "gc-trigger",
          "title": "GC Trigger Conditions",
          "summary": "When and how garbage collection cycles are initiated"
        },
        {
          "id": "phase-coordination",
          "title": "Phase Coordination",
          "summary": "Sequencing and data passing between mark and sweep phases"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Failure modes, detection strategies, and recovery mechanisms",
      "subsections": [
        {
          "id": "allocation-failures",
          "title": "Allocation Failures",
          "summary": "Handling out-of-memory conditions and allocation errors"
        },
        {
          "id": "corrupted-objects",
          "title": "Corrupted Object Detection",
          "summary": "Detecting and handling invalid object headers or pointers"
        },
        {
          "id": "stack-overflow",
          "title": "Stack Overflow Prevention",
          "summary": "Avoiding recursion-based stack overflow during deep object traversal"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy and Milestone Checkpoints",
      "summary": "Verification approaches for each milestone and integration testing",
      "subsections": [
        {
          "id": "unit-testing",
          "title": "Unit Testing Approach",
          "summary": "Testing individual components like object allocation and marking"
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing",
          "summary": "End-to-end GC scenarios with complex object graphs"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "Expected behavior and verification steps after each milestone"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common implementation bugs, symptoms, causes, and debugging techniques",
      "subsections": [
        {
          "id": "common-bugs",
          "title": "Common Implementation Bugs",
          "summary": "Typical mistakes and their symptoms"
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques",
          "summary": "Tools and methods for diagnosing GC problems"
        },
        {
          "id": "memory-debugging",
          "title": "Memory Debugging Tools",
          "summary": "Using valgrind, AddressSanitizer, and custom logging"
        }
      ]
    },
    {
      "id": "extensions",
      "title": "Future Extensions",
      "summary": "Advanced features that could be added to extend the basic mark-sweep collector",
      "subsections": [
        {
          "id": "performance-optimizations",
          "title": "Performance Optimizations",
          "summary": "Incremental collection, generational GC, and parallel marking"
        },
        {
          "id": "advanced-features",
          "title": "Advanced Features",
          "summary": "Weak references, finalizers, and concurrent collection"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key terms, concepts, and domain-specific vocabulary",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-components",
      "title": "System Component Architecture",
      "description": "Shows the main components: Allocator, Object Model, Root Discovery, Mark Phase, and Sweep Phase, with their interfaces and dependencies",
      "type": "component",
      "relevant_sections": [
        "architecture",
        "interactions-dataflow"
      ]
    },
    {
      "id": "object-model",
      "title": "Object Header and Type System",
      "description": "Illustrates object header layout, type tags, and relationships between different object types (int, pair, string)",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "gc-lifecycle",
      "title": "Garbage Collection Lifecycle",
      "description": "Flowchart showing the complete GC cycle: trigger detection, root discovery, mark phase, sweep phase, and reset",
      "type": "flowchart",
      "relevant_sections": [
        "architecture",
        "interactions-dataflow"
      ]
    },
    {
      "id": "marking-sequence",
      "title": "Mark Phase Sequence",
      "description": "Sequence diagram showing how root discovery passes roots to marking, and how marking traverses object references",
      "type": "sequence",
      "relevant_sections": [
        "root-discovery",
        "mark-phase"
      ]
    },
    {
      "id": "object-states",
      "title": "Object State Machine",
      "description": "State transitions for objects: allocated \u2192 marked \u2192 swept, with conditions for each transition",
      "type": "state-machine",
      "relevant_sections": [
        "mark-phase",
        "sweep-phase"
      ]
    },
    {
      "id": "memory-layout",
      "title": "Heap Memory Layout",
      "description": "Shows how objects are laid out in memory with headers, allocation list linkage, and free space management",
      "type": "component",
      "relevant_sections": [
        "data-model",
        "sweep-phase"
      ]
    },
    {
      "id": "root-discovery-flow",
      "title": "Root Discovery Process",
      "description": "Flowchart of stack scanning, global variable enumeration, and root set construction",
      "type": "flowchart",
      "relevant_sections": [
        "root-discovery"
      ]
    },
    {
      "id": "tricolor-marking",
      "title": "Tri-Color Marking Visualization",
      "description": "Conceptual diagram showing white (unmarked), gray (worklist), and black (marked) objects during graph traversal",
      "type": "component",
      "relevant_sections": [
        "mark-phase"
      ]
    }
  ]
}