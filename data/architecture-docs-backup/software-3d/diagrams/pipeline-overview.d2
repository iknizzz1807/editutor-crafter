direction: right

classes: {
  stage: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  data: {
    style.fill: "#16213e"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  output: {
    style.fill: "#0f3460"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.double-border: true
  }
}

input_data: 3D Vertices\n(x, y, z coordinates) {
  class: data
  shape: oval
}

transformation: Transformation Pipeline {
  class: stage
  
  vertex_transform: Vertex Transform\n(Model → World → View)
  projection: Projection\n(3D → 2D screen coords)
  clipping: Clipping & Culling
  
  vertex_transform -> projection
  projection -> clipping
}

rasterization: Rasterization Engine {
  class: stage
  
  triangle_setup: Triangle Setup
  scan_convert: Scan Conversion\n(Triangle → Pixels)
  depth_test: Depth Testing
  
  triangle_setup -> scan_convert
  scan_convert -> depth_test
}

shading: Shading System {
  class: stage
  
  lighting: Lighting Calculation
  texturing: Texture Mapping
  color_blend: Color Blending
  
  lighting -> texturing
  texturing -> color_blend
}

framebuffer: Frame Buffer\n(2D Pixel Array) {
  class: output
  shape: cylinder
}

input_data -> transformation: Raw 3D data
transformation -> rasterization: Screen coordinates\n& triangles
rasterization -> shading: Pixel fragments\n& depth values
shading -> framebuffer: Final colored pixels

pipeline_note: |md
  **Graphics Pipeline Flow**
  
  Each stage processes data sequentially:
  1. **Transform** - Convert 3D coordinates to screen space
  2. **Rasterize** - Determine which pixels each triangle covers
  3. **Shade** - Calculate final pixel colors with lighting
  4. **Output** - Store pixels in frame buffer for display
| {
  shape: page
  class: data
  near: bottom-center
}