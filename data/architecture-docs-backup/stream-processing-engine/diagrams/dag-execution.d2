title: Job Graph to Execution Graph
shape: rectangle

# Define styling
classes: {
  operator: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  task: {
    style.fill: "#0f3460"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  slot: {
    style.fill: "#16213e"
    style.stroke: "#8b949e"
    style.stroke-width: 2
  }
  container: {
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.font-size: 18
    style.bold: true
  }
  note: {
    style.fill: "#1a1a2e"
    style.stroke: "#8b949e"
    style.stroke-dash: 4
  }
}

# User-Defined Operator Chain (Logical Plan)
user_defined: User-Defined Operator Chain {
  class: container
  source: Source {
    class: operator
  }
  map: Map {
    class: operator
  }
  keyby: KeyBy {
    class: operator
    shape: diamond
  }
  window: Window {
    class: operator
  }
  sink: Sink {
    class: operator
  }
  
  source -> map -> keyby -> window -> sink
}

# Parallelized JobGraph (Parallel Execution Plan)
jobgraph: Parallelized JobGraph {
  class: container
  
  # Source subtasks (parallelism = 2)
  source_subtask1: Source Subtask 1 {
    class: task
  }
  source_subtask2: Source Subtask 2 {
    class: task
  }
  
  # Map subtasks (parallelism = 2)
  map_subtask1: Map Subtask 1 {
    class: task
  }
  map_subtask2: Map Subtask 2 {
    class: task
  }
  
  # KeyBy partitions data by key
  partition: Hash Partition {
    class: note
    shape: page
  }
  
  # Window operator (parallelism = 2, based on key groups)
  window_subtask1: Window Subtask 1 (Key Group 0) {
    class: task
  }
  window_subtask2: Window Subtask 2 (Key Group 1) {
    class: task
  }
  
  # Sink subtasks (parallelism = 2)
  sink_subtask1: Sink Subtask 1 {
    class: task
  }
  sink_subtask2: Sink Subtask 2 {
    class: task
  }
  
  # Connections in JobGraph
  source_subtask1 -> map_subtask1: forward
  source_subtask2 -> map_subtask2: forward
  map_subtask1 -> partition: keyed stream
  map_subtask2 -> partition: keyed stream
  partition -> window_subtask1: hash(key) % 2 = 0
  partition -> window_subtask2: hash(key) % 2 = 1
  window_subtask1 -> sink_subtask1
  window_subtask2 -> sink_subtask2
}

# Physical Execution Graph (Deployed)
execution: Execution Graph (Physical Deployment) {
  class: container
  
  # TaskManager 1 with 2 slots
  tm1: TaskManager 1 {
    class: slot
    
    slot1: Slot 1 {
      deployed1: Source Subtask 1\nMap Subtask 1 {
        class: task
      }
    }
    
    slot2: Slot 2 {
      deployed2: Window Subtask 1\nSink Subtask 1 {
        class: task
      }
    }
  }
  
  # TaskManager 2 with 2 slots
  tm2: TaskManager 2 {
    class: slot
    
    slot3: Slot 3 {
      deployed3: Source Subtask 2\nMap Subtask 2 {
        class: task
      }
    }
    
    slot4: Slot 4 {
      deployed4: Window Subtask 2\nSink Subtask 2 {
        class: task
      }
    }
  }
  
  # Network connections between TaskManagers
  deployed1 -> deployed4: network (hash partition)
  deployed3 -> deployed2: network (hash partition)
}

# Transformation process
user_defined -> jobgraph: Parallelize\n(Set parallelism, operator chaining)
jobgraph -> execution: Schedule & Deploy\n(Assign to TaskManager slots)

# Additional notes
note1: |md
  **Operator Chaining:** Source+Map chained
  to avoid serialization overhead
| {
  class: note
  near: bottom-left
}

note2: |md
  **Key Groups:** Window operator partitioned
  by key groups for state locality
| {
  class: note
  near: bottom-right
}