{
  "types": {
    "Money": "amount_cents int, currency_code str",
    "AuditEventType": "enum for audit event categories",
    "DatabaseManager": "database connection management",
    "BillingSettings": "configuration class for system parameters",
    "Customer": "customer_id UUID, credit_balance_cents int",
    "Plan": "plan_id UUID, base_price_cents int",
    "Subscription": "subscription_id UUID, customer_id UUID, plan_id UUID, status str",
    "Invoice": "invoice_id UUID, customer_id UUID, total_amount Money",
    "Payment": "payment_id UUID, customer_id UUID, invoice_id UUID, amount_cents int, status str",
    "UsageEvent": "event_id UUID, subscription_id Optional[UUID], quantity Decimal, idempotency_key str",
    "PricingTier": "tier_number int, min_quantity int, max_quantity Optional[int], price_per_unit_cents int, flat_fee_cents int",
    "PricingModel": "enum for pricing types",
    "BillingInterval": "enum for billing frequencies",
    "SubscriptionStatus": "enum: incomplete, trialing, active, past_due, unpaid, cancelled, paused",
    "SubscriptionEvent": "event_id UUID, event_type SubscriptionEventType, subscription_id UUID, data Dict, idempotency_key str, created_at datetime",
    "AuditEvent": "event_type AuditEventType, entity_id UUID",
    "DunningAction": "enum: retry_payment, send_email, restrict_access, suspend_subscription",
    "ProrationResult": "credit_amount Money, charge_amount Money, net_amount Money, calculation_details Dict, effective_date datetime",
    "ProrationCalculator": "calculates prorated charges for plan changes",
    "CreditBalanceManager": "manages customer credit balances",
    "PlanChangeHandler": "orchestrates plan changes with proration",
    "UsageAggregation": "aggregation_id UUID, customer_id UUID, subscription_id UUID, event_type str, billing_period_start datetime, billing_period_end datetime, total_quantity Decimal, event_count int",
    "UsageMetricType": "enum with API_CALLS, STORAGE_GB_HOURS, BANDWIDTH_GB, TRANSCODING_MINUTES, ACTIVE_USERS",
    "LineItem": "line_item_id UUID, item_type LineItemType, description str, quantity Decimal, unit_price Money, total_amount Money",
    "PaymentResult": "payment_id str, status PaymentStatus, amount Money, payment_method_id str, gateway_transaction_id Optional[str]",
    "PaymentMethod": "payment_method_id str, customer_id UUID, payment_type str, last_four str, is_default bool",
    "WebhookEvent": "event_id UUID, gateway_event_id str, event_type str, processed_at Optional[datetime], idempotency_key str",
    "InvoiceStatus": "enum: draft, open, paid, past_due, void, uncollectible",
    "PaymentStatus": "enum: pending, processing, succeeded, failed, requires_action",
    "LineItemType": "enum: subscription, usage, proration, credit, tax",
    "WorkflowStatus": "enum: PENDING, RUNNING, COMPLETED, FAILED, COMPENSATING",
    "WorkflowStep": "step_id str, name str, status WorkflowStatus, input_data Dict, output_data Optional[Dict], error_message Optional[str], started_at Optional[datetime], completed_at Optional[datetime], retry_count int",
    "WorkflowExecution": "execution_id str, workflow_type str, status WorkflowStatus, input_data Dict, steps List[WorkflowStep], created_at datetime, updated_at datetime, correlation_id Optional[str]",
    "Event": "event_id UUID, event_type str, data Dict, timestamp datetime, correlation_id Optional[str], idempotency_key Optional[str]",
    "SubscriptionCreationWorkflow": "orchestrates subscription creation workflow",
    "BillingCycleWorkflow": "orchestrates monthly billing cycle workflow",
    "PlanChangeWorkflow": "orchestrates plan change and proration workflow",
    "EventBus": "event publishing and subscription system",
    "WorkflowExecutor": "base class for workflow orchestration",
    "BillingErrorType": "enum for billing error categories",
    "BillingException": "base exception with error_type, entity_id, metadata",
    "PaymentFailedException": "payment-specific exception with decline_code",
    "ConcurrencyConflictException": "version conflict exception",
    "SubscriptionStateException": "invalid state transition exception",
    "RetryConfig": "retry policy configuration",
    "CircuitBreaker": "failure threshold and timeout management",
    "TransactionManager": "database transaction utilities",
    "DunningStage": "enum for payment recovery stages",
    "DunningAttempt": "payment retry tracking record",
    "DunningEngine": "payment failure recovery orchestrator",
    "OptimisticLockManager": "version-based concurrency control",
    "BillingCalendar": "date calculation utilities",
    "TestScenario": "billing test scenario with inputs and expected outputs",
    "BillingTestDataGenerator": "test data creation utilities",
    "ProrationTestGenerator": "proration-specific test scenarios",
    "ProrationPropertyTests": "property-based test validation",
    "BillingWorkflowIntegrationTests": "end-to-end workflow validation",
    "Milestone1ValidationTests": "plan management milestone validation",
    "ValidationError": "enum for validation error categories",
    "ValidationResult": "is_valid bool, error_type Optional[ValidationError], expected_value Any, actual_value Any, details Dict",
    "BillingCalculationValidator": "validates billing calculations for correctness",
    "StateConsistencyChecker": "validates subscription and billing state consistency",
    "WebhookDebugger": "diagnoses webhook processing issues",
    "BillingIssueDiagnostic": "command-line tool for billing system issue diagnosis",
    "AdvancedPricingModel": "enum: seat_based, contract_custom, dynamic_pricing, volume_commitment",
    "SeatConfiguration": "base_seat_count int, base_price_cents int, additional_seat_price_cents int, seat_types Dict",
    "ContractTerms": "contract_id str, customer_id str, base_plan_id str, effective_date date, custom_pricing_rules List",
    "TenantConfiguration": "tenant_id str, schema_name str, database_url str, supported_currencies List",
    "TenantContext": "thread-local tenant context management",
    "TenantDatabaseManager": "multi-tenant database connection and schema management",
    "TenantResourceManager": "cross-tenant resource allocation and quota management",
    "RevenueRecognitionSchedule": "subscription_id str, invoice_id str, total_amount_cents int, recognition_dates",
    "RevenueRecognitionEngine": "ASC 606 compliant revenue recognition processing",
    "CustomerAnalyticsEngine": "customer lifecycle and churn analysis",
    "UsageAnalyticsEngine": "usage pattern analysis and optimization",
    "TerminologyValidator": "validates consistent term usage across codebase"
  },
  "methods": {
    "from_decimal(amount, currency)": "create Money from decimal with rounding",
    "to_decimal()": "convert Money to decimal representation",
    "transaction(isolation_level)": "database transaction context",
    "log_event(event_type, entity_id, entity_type, changes, actor_id, metadata)": "record audit trail event",
    "apply_credit(amount_cents)": "add credit to customer balance",
    "consume_credit(amount_cents)": "apply available credit to reduce invoice amount",
    "calculate_usage_charge(usage_type, quantity)": "calculate charges for usage beyond plan limits",
    "has_feature(feature_name)": "check if plan includes specified feature",
    "from_decimal(amount, currency) returns Money": "create Money from decimal with rounding",
    "to_decimal() returns Decimal": "convert Money to decimal representation",
    "has_feature(feature_name) returns bool": "check if plan includes specified feature",
    "get_feature_limit(feature_name) returns Optional[int]": "get numeric limit for feature",
    "calculate_base_charge() returns Money": "calculate base recurring charge",
    "create_plan_family(plan_data) returns Plan": "create first version of plan family",
    "create_plan_version(plan_family_id, updated_data) returns Plan": "create new version of existing plan",
    "calculate_plan_charge(plan, usage_quantity) returns Money": "calculate total charge for plan",
    "validate_plan_upgrade(from_plan_id, to_plan_id) returns bool": "validate plan change is allowed",
    "transition_state(subscription_id, new_status, reason, actor_id) returns bool": "change subscription state with validation",
    "process_renewal(subscription_id, billing_date, idempotency_key) returns bool": "execute recurring billing cycle",
    "cancel_subscription(subscription_id, cancel_at_period_end, reason, actor_id) returns bool": "terminate subscription with options",
    "handle_payment_failure(subscription_id, invoice_id, failure_reason) returns None": "start dunning process",
    "process_dunning_retry(subscription_id) returns bool": "execute payment retry attempt",
    "log_event(event_type, entity_id, entity_type, changes, actor_id, metadata) returns None": "record audit trail event",
    "publish(event) returns bool": "publish event with idempotency protection",
    "apply_credit(customer_id, amount, source, reference_id, actor_id)": "add credit to customer account balance",
    "consume_credit(customer_id, amount_needed, actor_id)": "apply credit to reduce amount owed",
    "calculate_plan_change_proration(old_plan, new_plan, change_date, cycle_start, cycle_end)": "calculate proration for plan changes",
    "process_plan_upgrade(subscription_id, new_plan_id, effective_date, actor_id)": "handle upgrade with proration",
    "process_plan_downgrade(subscription_id, new_plan_id, effective_date, actor_id)": "handle downgrade with credits",
    "submit_usage_event(event_data) returns UsageEvent": "submit single usage event with idempotency protection",
    "submit_usage_batch(events) returns List[UsageEvent]": "submit multiple usage events in transaction",
    "aggregate_billing_period(start, end) returns List[UsageAggregation]": "aggregate usage events for billing period",
    "calculate_usage_charge(customer_id, event_type, quantity, allowance) returns Dict": "calculate tiered usage charges",
    "record_usage_event(event) returns None": "record event in real-time system",
    "get_current_usage(customer_id, event_type, period_start) returns Dict": "get approximate current usage",
    "check_usage_quotas(customer_id) returns List[Dict]": "check quota status for customer",
    "contains_quantity(quantity) returns bool": "check if quantity falls in pricing tier",
    "calculate_tier_charge(quantity) returns int": "calculate charge for quantity in tier",
    "to_billing_quantity() returns int": "convert decimal to integer for billing",
    "create_charge(amount, payment_method_id, idempotency_key, metadata) returns PaymentResult": "initiate payment charge",
    "process_webhook(payload, signature) returns Optional[Dict]": "process incoming webhook from payment gateway",
    "verify_webhook_signature(payload, signature) returns bool": "verify webhook authenticity using HMAC",
    "handle_payment_succeeded(event_data) returns None": "process successful payment webhook",
    "handle_payment_failed(event_data) returns None": "process failed payment webhook",
    "get_workflow_steps() returns List[str]": "return ordered list of step names for workflow",
    "execute_step(step_name, step_input, execution) returns Dict": "execute single workflow step and return output",
    "compensate_step(step_name, step_output, execution) returns None": "rollback completed step during failure recovery",
    "execute_workflow(input_data, correlation_id) returns WorkflowExecution": "execute complete workflow with error handling",
    "subscribe(event_type, handler) returns None": "subscribe handler to event type",
    "_compensate_workflow(execution) returns None": "execute compensation steps in reverse order",
    "_save_execution(execution) returns None": "persist workflow execution state",
    "_persist_event(event) returns None": "persist event to outbox table",
    "_notify_handlers(event) returns None": "notify all registered handlers for event type",
    "to_dict() returns Dict[str, Any]": "serialize exception to dictionary",
    "is_available() returns bool": "check circuit breaker state",
    "record_success()": "reset circuit breaker failure count",
    "record_failure()": "increment circuit breaker failures",
    "retry_with_backoff(config)": "decorator for automatic retry with exponential backoff",
    "transaction(isolation_level) returns Session": "database transaction context manager",
    "create_savepoint(session, name) returns str": "create nested transaction savepoint",
    "handle_payment_failure(subscription_id, invoice_id, failure_reason, idempotency_key)": "initiate dunning process",
    "escalate_dunning_stage(subscription_id, current_stage) returns DunningStage": "determine next dunning escalation",
    "attempt_payment_recovery(subscription_id, payment_method_id) returns bool": "retry payment with stored method",
    "load_with_lock(entity_class, entity_id) returns Optional[T]": "load entity with version for optimistic locking",
    "save_with_version_check(entity) returns T": "save with version conflict detection",
    "retry_on_conflict(operation_func, max_retries)": "retry operation on version conflicts",
    "calculate_next_billing_date(current_date, interval, anchor, timezone) returns date": "calculate next billing with edge case handling",
    "calculate_proration_factor(change_date, period_start, period_end) returns float": "calculate time-based proration factor",
    "handle_leap_year_anniversary(original_date, target_year) returns date": "adjust anniversary for leap year edge cases",
    "create_test_plan(plan_type, base_price_cents, currency, billing_interval) returns Dict": "generate plan data for testing",
    "create_test_customer(credit_balance_cents, timezone) returns Dict": "generate customer data for testing",
    "create_billing_scenario(scenario_type, plan_data, customer_data) returns TestScenario": "generate complete test scenario",
    "generate_plan_change_scenarios() returns List[TestScenario]": "create plan change test cases",
    "generate_calendar_edge_cases() returns List[TestScenario]": "create calendar edge case scenarios",
    "test_proration_symmetry_property(old_price, new_price, change_date, billing_start)": "verify upgrade/downgrade symmetry",
    "test_proration_monotonicity(base_price, period_days, change_day)": "verify monotonic proration amounts",
    "test_complete_subscription_lifecycle(billing_test_environment)": "end-to-end customer journey test",
    "test_payment_failure_recovery(billing_test_environment)": "dunning process integration test",
    "test_plan_definition_schema(plan_manager)": "validate plan schema requirements",
    "test_pricing_model_calculations(plan_manager)": "validate pricing calculations",
    "test_plan_versioning_protection(plan_manager)": "validate customer protection",
    "validate_currency_precision(money_amount) returns ValidationResult": "validates monetary amounts maintain proper precision",
    "validate_proration_symmetry(old_plan, new_plan, change_date, billing_period_start, billing_period_end) returns ValidationResult": "validates upgrade/downgrade symmetry",
    "check_subscription_state_consistency(subscription_id) returns List[ValidationResult]": "comprehensive subscription state validation",
    "analyze_webhook_processing(gateway_event_id) returns Dict": "comprehensive webhook processing analysis",
    "diagnose_invoice_discrepancy(invoice_id) returns Dict": "comprehensive invoice discrepancy diagnosis",
    "diagnose_subscription_state_issue(subscription_id) returns Dict": "subscription state diagnostic workflow",
    "diagnose_payment_processing_issue(payment_id) returns Dict": "payment processing diagnostic workflow",
    "calculate_plan_change_proration(old_plan, new_plan, change_date, cycle_start, cycle_end) returns ProrationResult": "calculate proration for plan changes",
    "set_current_tenant(tenant_id)": "set thread-local tenant context",
    "get_current_tenant()": "return current tenant ID",
    "tenant_transaction(isolation_level)": "create tenant-aware database transaction",
    "provision_tenant_schema(tenant_config)": "create database schema for new tenant",
    "calculate_subscription_charge(subscription_id, period_start, period_end)": "calculate total charge including advanced pricing",
    "calculate_seat_based_charge(subscription, seat_config, current_seats, billing_days)": "calculate seat-based billing charges",
    "apply_contract_pricing(base_amount, contract)": "apply custom contract pricing rules",
    "check_tenant_quota(tenant_id, resource_type, requested_amount)": "validate tenant resource consumption",
    "create_recognition_schedule(invoice)": "create revenue recognition schedule",
    "process_monthly_recognition(recognition_date)": "process monthly revenue recognition",
    "calculate_customer_lifetime_metrics(customer_id)": "calculate LTV and behavior metrics",
    "generate_cohort_analysis(cohort_period, analysis_date)": "generate cohort retention analysis",
    "analyze_usage_patterns(customer_id, analysis_period_days)": "analyze usage patterns and optimization opportunities",
    "validate_code_comments(file_path) returns List[ValidationResult]": "check code comments for terminology consistency",
    "validate_documentation(doc_path) returns List[ValidationResult]": "check documentation for terminology consistency"
  },
  "constants": {
    "SUPPORTED_CURRENCIES": "currency configuration dict",
    "ISOLATION_LEVEL_SERIALIZABLE": "highest database isolation level",
    "DEFAULT_CURRENCY": "USD",
    "DECIMAL_PRECISION": "Decimal('0.01') for cent precision",
    "SubscriptionEventType": "enum for subscription lifecycle events",
    "AuditEventType": "enum for audit event categories",
    "WorkflowStatus.PENDING": "workflow not started",
    "WorkflowStatus.RUNNING": "workflow executing",
    "WorkflowStatus.COMPLETED": "workflow finished successfully",
    "WorkflowStatus.FAILED": "workflow failed with error",
    "WorkflowStatus.COMPENSATING": "workflow rolling back due to failure",
    "ValidationError.CURRENCY_PRECISION": "currency precision validation error",
    "ValidationError.PRORATION_ASYMMETRY": "proration asymmetry validation error",
    "ValidationError.USAGE_AGGREGATION": "usage aggregation validation error",
    "ValidationError.CREDIT_APPLICATION": "credit application validation error",
    "ValidationError.TIER_CALCULATION": "tier calculation validation error",
    "SubscriptionStatus.active": "active subscription status",
    "SubscriptionStatus.past_due": "past due subscription status",
    "SubscriptionStatus.cancelled": "cancelled subscription status"
  },
  "terms": {
    "subscription billing": "recurring payment system with lifecycle management",
    "proration": "partial charge calculation for mid-cycle changes",
    "billing anchor": "fixed day for recurring subscription charges",
    "dunning management": "systematic payment failure recovery process",
    "usage-based billing": "charges based on metered consumption",
    "financial precision": "accurate monetary calculations using integer cents",
    "grandfathering": "protecting existing customers from plan changes",
    "plan versioning": "creating new plan versions while maintaining old ones",
    "feature entitlements": "capabilities unlocked by subscription plans",
    "pricing tiers": "usage brackets with different rates",
    "grace period": "time window maintaining service access after payment failure",
    "state machine": "defined states and transitions for subscription lifecycle",
    "idempotency": "ensuring operations can be safely retried",
    "audit trail": "complete record of financial operations and state changes",
    "credit balance": "accumulated customer credits for future use",
    "usage factor": "fraction of billing cycle remaining",
    "currency precision": "using smallest currency unit to avoid rounding errors",
    "real-time approximation": "fast estimates for dashboards and quotas",
    "batch aggregation": "scheduled processing for complex analytical computations",
    "overage charges": "fees for usage beyond plan allowances",
    "usage allowances": "included quantities in subscription plans",
    "tiered pricing": "different rates for different usage levels",
    "quota enforcement": "limiting usage based on plan allowances",
    "billing period boundaries": "start and end dates for usage calculations",
    "event deduplication": "preventing duplicate charges for same activity",
    "usage metrics": "measurable activities that can be billed",
    "invoice generation": "creating structured bills from subscription charges and usage",
    "payment gateway integration": "connecting to external payment processors",
    "webhook processing": "handling asynchronous payment status updates",
    "idempotency protection": "preventing duplicate operation processing",
    "line item calculation": "individual charges that make up an invoice",
    "payment method tokenization": "storing secure references to payment instruments",
    "workflow orchestration": "coordinating multi-step business processes across components",
    "transactional outbox": "pattern for reliable event publishing with database transactions",
    "compensation pattern": "rollback strategy for distributed operations",
    "saga pattern": "distributed transaction management with compensation",
    "event-driven architecture": "system design using asynchronous event communication",
    "workflow state machine": "tracking workflow progress through defined states",
    "correlation ID": "identifier linking related operations across components",
    "circuit breaker": "failure prevention pattern for external service calls",
    "eventual consistency": "data consistency model allowing temporary inconsistencies",
    "optimistic concurrency control": "version-based conflict detection for concurrent updates",
    "calendar arithmetic": "date calculations handling month overflow and leap years",
    "timezone handling": "UTC storage with local time display conversion",
    "exponential backoff": "increasing retry delays to reduce system load",
    "property-based testing": "automated test generation verifying mathematical invariants",
    "billing logic unit tests": "mathematical validation of calculation accuracy",
    "integration testing": "validation of component interaction and data flow",
    "milestone validation checkpoints": "verification criteria for development phase completion",
    "proration calculation testing": "validation of partial billing mathematical accuracy",
    "usage aggregation testing": "verification of usage event processing and billing",
    "payment gateway integration testing": "validation of external payment service interaction",
    "subscription lifecycle integration testing": "end-to-end subscription operation validation",
    "webhook reliability testing": "asynchronous payment notification handling validation",
    "database transaction testing": "consistency guarantee validation under failure scenarios",
    "currency precision testing": "monetary calculation accuracy using integer cents",
    "idempotency testing": "duplicate operation protection validation",
    "time zone consistency": "UTC timestamp handling across different time zones",
    "mathematical invariants": "properties that must hold true across all test scenarios",
    "billing cycle integration testing": "monthly billing process end-to-end validation",
    "billing calculation debugging": "systematic approach to identifying and resolving mathematical errors in subscription billing",
    "proration symmetry": "mathematical property that upgrade followed by downgrade should net to zero",
    "state consistency": "alignment between subscription states and related entity states",
    "webhook processing reliability": "ensuring payment gateway events are consistently processed",
    "seat-based billing": "pricing model that scales with number of active users or licenses",
    "multi-tenant architecture": "system design supporting multiple isolated tenant organizations",
    "schema-per-tenant": "database isolation strategy with separate schemas per tenant",
    "revenue recognition": "ASC 606 compliant allocation of revenue over service delivery periods",
    "deferred revenue": "liability for services not yet delivered on prepaid subscriptions",
    "customer lifetime value": "total revenue expected from customer relationship",
    "cohort analysis": "grouping customers by acquisition period for retention analysis",
    "usage pattern analysis": "examination of consumption trends for optimization opportunities",
    "contract-based pricing": "custom pricing terms negotiated for enterprise customers",
    "dynamic pricing": "market-responsive pricing adjustments based on conditions",
    "tenant isolation": "preventing data leakage between tenant organizations",
    "resource allocation": "fair distribution of system resources across tenants",
    "performance obligation": "distinct service commitment requiring revenue recognition",
    "churn prediction": "analytical model identifying customers at risk of cancellation",
    "real-time analytics": "immediate data processing for operational dashboards"
  }
}