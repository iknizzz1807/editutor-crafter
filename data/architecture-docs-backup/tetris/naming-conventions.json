{
  "types": {
    "GameBoard": "grid: Array, width: number, height: number",
    "Tetromino": "type: string, x: number, y: number, rotation: number, shapes: Array",
    "CollisionDetector": "board: GameBoard",
    "GameTimer": "callbacks: Map, intervals: Map, lastTrigger: Map, accumulator: number, fixedTimeStep: number, isRunning: boolean, lastUpdate: number",
    "GAME_CONFIG": "BOARD_WIDTH: number, BOARD_HEIGHT: number, CELL_SIZE: number, INITIAL_FALL_SPEED: number",
    "PIECE_SHAPES": "shape definitions for I,O,T,S,Z,J,L pieces",
    "GameState": "score: number, level: number, linesCleared: number, gameOver: boolean",
    "InputHandler": "gameState: GameState, keyStates: Map, lastKeyTime: Map, keyRepeatDelay: number, keyRepeatRate: number, enabledKeys: Set",
    "COLORS": "piece type to color mapping",
    "POINTS": "scoring values for line clears",
    "MovementValidator": "board: GameBoard",
    "ScoringSystem": "gameState: GameState, gameTimer: GameTimer, eventCallbacks: Map",
    "SpeedCalculator": "speedLookupTable: Map",
    "PROGRESSION_CONFIG": "LINES_PER_LEVEL: number, STARTING_LEVEL: number, MAXIMUM_LEVEL: number",
    "EventSystem": "listeners: Map, eventQueue: Array, isProcessing: boolean, eventHistory: Array",
    "GameLoop": "canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, gameTimer: GameTimer, eventSystem: EventSystem, gameState: GameState, isRunning: boolean",
    "EventCoordinator": "eventSystem: EventSystem, gameState: GameState, sequenceHandlers: Map",
    "ComponentSynchronizer": "eventSystem: EventSystem, componentStates: Map, syncPoints: Set",
    "CollisionValidator": "board: GameBoard, validationHistory: Map, errorCounts: object",
    "GameOverDetector": "gameBoard: GameBoard, eventSystem: EventSystem, gameOverTriggered: boolean, finalState: object, gracePeriodTimer: number",
    "ErrorRecovery": "gameState: GameState, gameBoard: GameBoard, eventSystem: EventSystem, recoveryStrategies: Map, fallbackState: object",
    "TetrisDebugger": "canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, gameState: GameState, gameBoard: GameBoard, debugEnabled: boolean, logHistory: Array, collisionTests: Array",
    "CollisionDetectionTester": "board: GameBoard, testResults: Array",
    "RotationDebugger": "rotationTests: Array, wallKickAttempts: Array",
    "TimingDebugger": "gameTimer: GameTimer, timingLogs: Array, performanceMarkers: Map",
    "AnimationManager": "gameLoop: GameLoop, activeAnimations: Map, animationId: number, interpolationEnabled: boolean, lastFrameTime: number, easingFunctions: Object",
    "ObjectPool": "createObject: Function, resetObject: Function, available: Array, inUse: Set",
    "PluginAPI": "gameState: GameState, eventSystem: EventSystem, loadedPlugins: Map, pluginSandbox: Map",
    "NetworkManager": "gameState: GameState, eventSystem: EventSystem, connections: Map, messageQueue: Array, latencyTracking: Map, connectionState: string",
    "NextPieceQueue": "queue: Array<Tetromino>, queueSize: number",
    "HoldPiece": "heldPiece: Tetromino, holdUsed: boolean",
    "PreviewRenderer": "previewPositions: Array<Position>",
    "HoldRenderer": "holdPosition: Position, holdSize: number",
    "GhostPieceCalculator": "board: GameBoard",
    "GhostPieceRenderer": "transparentColor: string",
    "GhostPieceUpdater": "eventSystem: EventSystem",
    "PuzzleDefinition": "boardState: Array, pieceSequence: Array, objectives: Array",
    "PuzzleValidator": "completionCriteria: Object, currentProgress: Object",
    "PuzzleManager": "puzzleCollection: Array, playerProgress: Object",
    "BattleState": "players: Array, attackQueue: Array",
    "GarbageGenerator": "patternLibrary: Array",
    "AttackRenderer": "effectsQueue: Array",
    "INPUT_CONFIG": "key mappings and timing configuration"
  },
  "methods": {
    "canPlacePiece(piece, x, y, rotation)": "validates piece placement at position",
    "isWithinBounds(piece, x, y, rotation)": "checks boundary constraints only",
    "generateAllRotations(baseShape)": "creates all four rotation states",
    "getTestCopy(newX, newY, newRotation)": "creates piece copy for collision testing",
    "addTimer(name, interval, callback)": "registers recurring timer with callback",
    "update(currentTime)": "processes frame timing and callbacks",
    "moveLeft()": "moves current piece left if valid",
    "handleKeyDown(event)": "processes keyboard input events",
    "updateStats(linesCleared)": "updates score and level after line clear",
    "initializeGrid()": "creates empty 2D array",
    "isWithinBounds(x, y)": "validates coordinates within board",
    "getCellAt(x, y)": "retrieves cell value safely",
    "setCellAt(x, y, value)": "sets cell value with validation",
    "getCurrentShape()": "returns current rotation shape data",
    "updateState(newX, newY, newRotation)": "updates piece position and rotation",
    "spawnNewPiece(pieceType)": "creates new piece at spawn location",
    "updateStats(numberOfLinesCleared)": "updates score and level after line clear",
    "checkGameOver()": "determines if game has ended",
    "resetGame()": "reinitializes game state",
    "initializeGrid() returns Array<Array<number>>": "creates empty 2D array",
    "isWithinBounds(x, y) returns boolean": "validates coordinates within board",
    "getCellAt(x, y) returns number": "retrieves cell value safely",
    "setCellAt(x, y, value) returns boolean": "sets cell value with validation",
    "canPlacePiece(piece, x, y, rotation) returns boolean": "validates piece placement at position",
    "getTestCopy(newX, newY, newRotation) returns Tetromino": "creates piece copy for collision testing",
    "getCurrentShape() returns Array<Array<number>>": "returns current rotation shape data",
    "getAbsoluteBlockPositions()": "calculates world coordinates of all blocks",
    "handleKeyDown(event: KeyboardEvent) returns void": "processes key press events and initiates game actions",
    "handleKeyUp(event: KeyboardEvent) returns void": "processes key release events and updates key state",
    "updateKeyRepeat(currentTime: number) returns void": "checks held keys and triggers repeat actions",
    "validateMovement(direction: string) returns boolean": "tests if movement in direction is legal",
    "executeMovement(direction: string) returns boolean": "performs validated movement and updates state",
    "addTimer(name: string, interval: number, callback: Function) returns void": "registers recurring timer with callback",
    "update(currentTime: number) returns void": "processes frame timing and triggers callbacks",
    "canPlacePiece(piece: Tetromino, x: number, y: number, rotation: number) returns boolean": "validates piece placement at position",
    "isWithinBounds(piece: Tetromino, x: number, y: number, rotation: number) returns boolean": "checks boundary constraints only",
    "getTestCopy(piece: Tetromino, newX: number, newY: number, newRotation: number) returns Tetromino": "creates piece copy for collision testing",
    "getAbsoluteBlockPositions(piece: Tetromino, x: number, y: number, rotation: number) returns Array": "calculates world coordinates of all blocks",
    "rotatePiece(piece)": "attempts clockwise rotation with wall kicks",
    "canRotateInPlace(piece)": "tests basic rotation without wall kicks",
    "attemptWallKicks(piece, targetRotation)": "tries SRS wall kick offsets",
    "rotateOPiece(piece)": "handles O-piece special rotation",
    "rotateIPiece(piece, targetRotation)": "handles I-piece with custom offsets",
    "createTestPiece(originalPiece, newX, newY, newRotation)": "creates piece copy for testing",
    "scanForCompleteLines(board)": "detects all complete rows and returns indices in descending order",
    "removeLines(board, rowIndices)": "removes specified rows and compacts board maintaining dimensions",
    "processCascades(board, lineDetector, lineRemover)": "handles iterative cascade clearing until stability",
    "applyGravityCompaction(board)": "drops floating blocks downward after line removal",
    "isStableState(board, lineDetector)": "checks if board has no more possible cascades",
    "validatePostClearState()": "verifies board integrity after clearing operations",
    "calculateLevelProgression(newLinesCleared)": "determines if level advancement occurs",
    "applyLevelAdvancement(newLevel)": "updates level and adjusts game speed",
    "recordDropPoints(dropType, cellsDropped)": "awards points for soft/hard drops",
    "getProgressToNextLevel()": "returns progress toward next level",
    "getGravitySpeed(level)": "calculates gravity speed for given level",
    "generateSpeedTable()": "pre-calculates speed lookup table",
    "validateLevel(level)": "ensures level within valid bounds",
    "calculateLevelFromTotalLines(totalLines)": "determines level from line count",
    "addTimer(name, interval, callback) returns void": "registers recurring timer with callback",
    "update(currentTime) returns void": "processes frame timing and callbacks",
    "processTimers(currentTime) returns void": "checks and triggers timer callbacks",
    "setTimerInterval(name, newInterval) returns void": "updates timer interval",
    "subscribe(eventType, callback) returns void": "registers event listener",
    "emit(eventType, data) returns void": "triggers event with data",
    "start() returns void": "begins game loop execution",
    "requestNextFrame() returns void": "schedules next animation frame",
    "initializeComponents() returns void": "creates and configures game components",
    "setupTimers() returns void": "configures recurring game timers",
    "bindEvents() returns void": "attaches event listeners",
    "subscribe(eventType, callback, priority)": "registers event listener with priority",
    "emit(eventType, data)": "triggers event with data payload",
    "handlePieceLockingSequence(piece)": "coordinates piece locking event sequence",
    "handleLineClearingSequence(initialLines)": "manages line clearing cascade events",
    "handleLevelProgressionSequence(newLinesCleared)": "coordinates level progression events",
    "coordinateAtomicUpdate(updatePlan)": "ensures atomic multi-component updates",
    "synchronizeTimingUpdate(newTimingConfig)": "coordinates timing changes across components",
    "validatePiecePlacement(piece, x, y, rotation) returns object": "validates complete piece placement with detailed result",
    "isWithinBounds(piece, x, y, rotation) returns boolean": "checks boundary constraints only",
    "isSpaceFree(piece, x, y, rotation) returns boolean": "checks occupancy constraints only",
    "validateSpawnPosition(piece) returns object": "specialized validation for spawn positions",
    "checkGameOverConditions(newPiece, validator) returns object": "primary game over detection method",
    "triggerGameOver(reason, context) returns object": "initiates game over sequence with state capture",
    "captureFinalState(reason, context) returns object": "creates immutable snapshot of final game state",
    "attemptRecovery(error, context) returns object": "implements error recovery strategies",
    "validateGameStateIntegrity() returns object": "validates complete game state consistency",
    "createFallbackState() returns object": "creates safe fallback state",
    "createTestGameState(overrides) returns GameState": "factory for consistent test game state",
    "createTestBoard(preset) returns GameBoard": "factory for test board configurations",
    "createTestPiece(type, x, y, rotation) returns Tetromino": "factory for test tetromino instances",
    "handleKeyDown(event) returns void": "processes keyboard input events",
    "scanForCompleteLines(board) returns Array": "detects all complete rows",
    "removeLines(board, rowIndices) returns void": "removes specified rows and compacts board",
    "processCascades(board, lineDetector, lineRemover) returns void": "handles iterative cascade clearing",
    "verifyMilestone1() returns object": "automated milestone 1 checkpoint verification",
    "verifyMilestone2() returns object": "automated milestone 2 checkpoint verification",
    "measureFrameRate(testDuration) returns Promise": "measures rendering performance",
    "measureInputLatency(inputHandler) returns object": "measures input response timing",
    "getAbsoluteBlockPositions(piece, x, y, rotation)": "calculates world coordinates of all blocks",
    "getWallKickOffsets(pieceType, fromRotation, toRotation)": "gets SRS wall kick offset data",
    "validateMovement(direction)": "tests if movement in direction is legal",
    "executeMovement(direction)": "performs validated movement and updates state",
    "visualizeCollisionTest(piece, x, y, rotation, result)": "real-time collision detection visualization",
    "measureFrameTiming()": "frame timing analysis",
    "exportDebugData()": "export debug logs for analysis",
    "runBoundaryTests()": "test all boundary conditions",
    "runOccupancyTests()": "test occupancy detection with various board states",
    "generateReport()": "generate comprehensive test report",
    "debugRotation(piece, targetRotation)": "test rotation with detailed logging",
    "validateSRSCompliance()": "validate SRS compliance",
    "monitorGravityTiming()": "monitor gravity timing consistency",
    "measureInputLatency()": "measure input responsiveness",
    "validateAnimationTiming()": "animation timing validation",
    "verifyMilestone1()": "automated milestone 1 checkpoint verification",
    "verifyMilestone2()": "automated milestone 2 checkpoint verification",
    "createAnimation(startValue, endValue, duration, easingType) returns number": "creates new animation with automatic ID generation",
    "updateAnimations(deltaTime) returns void": "updates all active animations called from main game loop",
    "animatePosition(startPos, endPos, duration, easingType) returns number": "animates position between two points",
    "animateFade(startOpacity, endOpacity, duration) returns number": "animates opacity changes",
    "animateScale(startScale, endScale, duration) returns number": "animates scale transformations",
    "acquire() returns Object": "retrieves object from pool for use",
    "release(obj) returns void": "returns object to pool after use",
    "getStats() returns Object": "returns pool usage statistics",
    "registerPlugin(pluginName, pluginDefinition) returns void": "registers new plugin with sandboxed capabilities",
    "createPluginProxy(pluginName) returns Object": "creates safe game state access for plugins",
    "loadPlugin(pluginSource, sourceType) returns Promise": "loads plugin from external source",
    "registerCustomPiece(pluginName, pieceDefinition) returns void": "enables plugins to define custom piece types",
    "registerScoringRule(pluginName, ruleName, calculationFunction) returns void": "allows plugins to register custom scoring rules",
    "connectToServer(serverUrl, playerInfo) returns Promise": "establishes connection to multiplayer server",
    "sendGameUpdate(updateType, updateData) returns void": "sends game state updates to other players",
    "handleIncomingMessage(messageData) returns void": "processes incoming messages from other players",
    "sendGarbageAttack(lineCount, attackPattern) returns void": "generates and sends garbage lines to opponent",
    "validateGameState(gameState)": "ensures all game state properties match expected terminology",
    "validateTetrominoType(pieceType)": "ensures piece types match official terminology",
    "validateRotationState(rotation)": "ensures rotation values follow SRS conventions"
  },
  "constants": {
    "BOARD_WIDTH": "10 columns",
    "BOARD_HEIGHT": "20 rows",
    "CELL_SIZE": "30 pixels per cell",
    "INITIAL_FALL_SPEED": "1000ms per cell fall",
    "COLORS": "piece type to color mapping",
    "POINTS": "scoring values for line clears",
    "PIECE_SHAPES": "shape definitions for I,O,T,S,Z,J,L pieces",
    "INPUT_CONFIG": "key mappings and timing configuration",
    "GRAVITY_SPEEDS": "fall intervals for each level",
    "WALL_KICK_TABLES": "SRS offset data for standard and I-piece rotations",
    "PIECE_ROTATIONS": "pre-calculated rotation states for all piece types",
    "PROGRESSION_CONFIG": "level advancement configuration",
    "SCORING_EVENTS": "event type constants for scoring system",
    "LINES_PER_LEVEL": "10 lines required per level",
    "SPEED_MINIMUM": "135ms minimum gravity speed",
    "FIXED_TIME_STEP": "16.67ms for 60fps logical updates",
    "PIECE_LOCKED": "event type for piece placement completion",
    "LINES_CLEARED": "event type for line removal",
    "LEVEL_ADVANCED": "event type for level progression",
    "SPEED_CHANGED": "event type for timing updates",
    "GAME_CONFIG": "board dimensions and game settings",
    "GAME_OVER": "event type for game termination",
    "GRACE_PERIOD_RECOVERY": "event type for successful recovery during grace period",
    "SRS_TEST_POSITIONS": "test cases for Super Rotation System compliance",
    "ANIMATION_TYPES": "easing function definitions",
    "POOL_SIZES": "default object pool configurations",
    "PLUGIN_PERMISSIONS": "allowed API access levels",
    "NETWORK_MESSAGE_TYPES": "multiplayer communication protocols",
    "GARBAGE_PATTERNS": "attack line generation templates",
    "EXTENSION_PRIORITIES": "feature implementation ordering"
  },
  "terms": {
    "tetromino": "seven-piece geometric shapes in Tetris",
    "collision detection": "validation that pieces don't overlap or exceed boundaries",
    "wall kick": "position adjustment when rotation would collide",
    "Super Rotation System": "official standard for piece rotation behavior",
    "gravity timer": "automatic piece falling at regular intervals",
    "line clearing": "removing complete horizontal rows",
    "piece locking": "finalizing piece position when it can't fall further",
    "soft drop": "accelerated falling via down arrow",
    "hard drop": "instant placement via spacebar",
    "component-based architecture": "system design with independent coordinating modules",
    "event-driven input handling": "processing user input through event callbacks",
    "test-and-validate patterns": "creating temporary copies to verify actions before applying",
    "row-major ordering": "2D array access pattern grid[row][column]",
    "anchor point": "reference position for piece rotation and movement",
    "rotation state": "one of four orientations for each piece type",
    "game state": "complete snapshot of current game session",
    "bag randomizer": "7-piece shuffle system ensuring balanced distribution",
    "test-and-validate pattern": "creating temporary copies to verify actions before applying",
    "frame-rate independent timing": "consistent timing regardless of rendering speed",
    "key repeat": "continued action while key is held",
    "DAS": "Delayed Auto Shift - initial key repeat delay",
    "ARR": "Auto Repeat Rate - interval between repeated actions",
    "cascade": "secondary line formation after initial clearing",
    "gravity compaction": "dropping floating blocks after line removal",
    "atomic removal": "processing all complete lines as single operation",
    "stability detection": "determining when no more cascades can occur",
    "removal manifest": "list specifying which rows to eliminate",
    "mass conservation": "preserving all non-removed blocks during clearing",
    "cascade level": "iteration depth in cascade processing sequence",
    "exponential scoring": "point values increase exponentially with simultaneous line clears",
    "level progression": "advancement through difficulty levels based on lines cleared",
    "gravity speed": "time interval between automatic piece drops",
    "logarithmic deceleration": "smooth speed increase following logarithmic curve",
    "multiplicative bonus scaling": "rewards multiply rather than add for multiple lines",
    "adaptive difficulty staircase": "automatic challenge adjustment based on player progress",
    "atomic transition pattern": "speed updates applied as single indivisible operations",
    "decade-based advancement": "10 lines required per level advancement",
    "speed floor": "minimum gravity speed limit for playability",
    "delta time accumulation": "tracking elapsed time across variable frame rates",
    "atomic operations": "state changes that complete entirely or not at all",
    "fixed time step": "consistent logical update intervals",
    "time debt": "accumulated timing error correction",
    "component coordination": "synchronizing independent game systems",
    "event broadcasting": "notifying multiple components of state changes",
    "topological ordering": "dependency-based update sequence",
    "event-driven communication": "decoupled component interaction through events",
    "cascading events": "events that trigger additional events in sequence",
    "component synchronization": "coordinating state updates across multiple systems",
    "event priority": "processing order for simultaneous events",
    "immutable state updates": "creating new state objects instead of modifying existing ones",
    "boundary validation": "checking pieces stay within board edges",
    "occupancy validation": "checking for conflicts with placed blocks",
    "game over detection": "recognizing when game state becomes unwinnable",
    "spawn validation": "testing if new piece can be placed at spawn position",
    "grace period": "temporary delay before game over to allow recovery",
    "atomic validation": "validating complete operations as single units",
    "fail-safe mechanism": "fallback behavior when systems encounter errors",
    "state integrity": "consistency and validity of complete game state",
    "error recovery": "strategies for handling and correcting error conditions",
    "floating blocks": "pieces left unsupported after line clearing",
    "component unit testing": "testing individual components in isolation",
    "integration testing": "testing component interactions and full scenarios",
    "milestone verification checkpoints": "validation criteria for each development stage",
    "event sequence verification": "capturing and validating event flow patterns",
    "synthetic tetromino generation": "creating test pieces with unusual configurations",
    "time simulation": "mocking timing systems for deterministic testing",
    "board state synthesis": "creating specific board configurations for testing",
    "game state orchestration": "setting up controlled test conditions",
    "performance integration tests": "verifying timing-dependent behavior under load",
    "coordinate transformation": "translation between coordinate systems",
    "absolute coordinates": "final world positions on game board",
    "piece-local coordinates": "positions within piece shape definition",
    "SRS specification": "Super Rotation System official standard",
    "wall kick offsets": "position adjustments tested during rotation",
    "animation interpolation": "smooth visual movement between logical states",
    "object pooling": "reusing allocated objects to reduce garbage collection",
    "plugin sandbox": "isolated environment for third-party code execution",
    "garbage lines": "incomplete attack rows sent between players",
    "hot module reloading": "updating code without losing application state",
    "differential state updates": "transmitting only changed portions of game state",
    "microservice architecture": "distributed system with specialized service components",
    "visual regression testing": "automated UI consistency verification",
    "plugin API": "controlled interface for third-party extensions"
  }
}