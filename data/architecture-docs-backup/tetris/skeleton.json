{
  "title": "Tetris Game: Design Document",
  "overview": "A complete implementation of the classic Tetris puzzle game that manages dynamic piece movement, rotation mechanics, and line clearing within a constrained grid system. The key architectural challenge is coordinating real-time game state updates across multiple independent systems while maintaining smooth gameplay and consistent collision detection.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Defines the Tetris game requirements and core technical challenges of building a real-time falling block puzzle game.",
      "subsections": [
        {
          "id": "tetris-fundamentals",
          "title": "Tetris Game Fundamentals",
          "summary": "Core game mechanics and why Tetris presents unique programming challenges"
        },
        {
          "id": "existing-approaches",
          "title": "Existing Implementation Approaches",
          "summary": "Comparison of different architectural patterns used in Tetris implementations"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Explicit scope definition covering what this Tetris implementation will and will not include.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Core gameplay features that must be implemented"
        },
        {
          "id": "non-goals",
          "title": "Non-Goals",
          "summary": "Features explicitly excluded from this implementation"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Component overview showing how game systems interact and the recommended project structure.",
      "subsections": [
        {
          "id": "system-components",
          "title": "System Components",
          "summary": "Main components and their responsibilities in the Tetris architecture"
        },
        {
          "id": "file-organization",
          "title": "File and Module Organization",
          "summary": "Recommended directory structure and module breakdown"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Core data structures representing game board, tetrominoes, and game state with their relationships.",
      "subsections": [
        {
          "id": "board-representation",
          "title": "Board Representation",
          "summary": "How the game board grid and cell states are modeled"
        },
        {
          "id": "tetromino-structures",
          "title": "Tetromino Data Structures",
          "summary": "Shape definitions, rotations, and position tracking for game pieces"
        },
        {
          "id": "game-state-model",
          "title": "Game State Model",
          "summary": "Score, level, timing, and overall game state representation"
        }
      ]
    },
    {
      "id": "board-management",
      "title": "Board Management Component",
      "summary": "Handles the game grid, cell state tracking, and collision detection for all game pieces.",
      "subsections": [
        {
          "id": "board-initialization",
          "title": "Board Initialization and Rendering",
          "summary": "Setting up the 10x20 grid and visual representation"
        },
        {
          "id": "collision-detection",
          "title": "Collision Detection System",
          "summary": "Algorithms for detecting piece conflicts with boundaries and placed blocks"
        },
        {
          "id": "board-state-management",
          "title": "Board State Management",
          "summary": "Updating grid cells when pieces lock into place"
        }
      ]
    },
    {
      "id": "tetromino-system",
      "title": "Tetromino System Component",
      "summary": "Manages piece definitions, spawning, positioning, and the seven standard tetromino shapes.",
      "subsections": [
        {
          "id": "piece-definitions",
          "title": "Piece Shape Definitions",
          "summary": "Data structures for the seven standard Tetris pieces and their orientations"
        },
        {
          "id": "spawn-system",
          "title": "Piece Spawning System",
          "summary": "Logic for creating new pieces at the top of the board"
        },
        {
          "id": "position-tracking",
          "title": "Position and Movement Tracking",
          "summary": "Managing current piece coordinates and movement validation"
        }
      ]
    },
    {
      "id": "movement-controls",
      "title": "Movement and Controls Component",
      "summary": "Handles player input processing, piece movement, and gravity-based automatic falling.",
      "subsections": [
        {
          "id": "input-handling",
          "title": "Input Event Processing",
          "summary": "Keyboard input capture and mapping to game actions"
        },
        {
          "id": "gravity-system",
          "title": "Gravity and Automatic Movement",
          "summary": "Timer-based automatic piece falling and level-based speed control"
        },
        {
          "id": "movement-validation",
          "title": "Movement Validation",
          "summary": "Ensuring piece movements are legal within game constraints"
        }
      ]
    },
    {
      "id": "rotation-system",
      "title": "Rotation System Component",
      "summary": "Implements piece rotation mechanics with wall kick support following the Super Rotation System standard.",
      "subsections": [
        {
          "id": "rotation-mechanics",
          "title": "Core Rotation Mechanics",
          "summary": "How pieces rotate through their four orientations"
        },
        {
          "id": "wall-kick-system",
          "title": "Wall Kick Implementation",
          "summary": "SRS-compliant wall kick tests when rotation collides"
        },
        {
          "id": "special-piece-handling",
          "title": "Special Piece Rotation Handling",
          "summary": "Unique rotation behavior for I-pieces and O-pieces"
        }
      ]
    },
    {
      "id": "line-clearing",
      "title": "Line Clearing Component",
      "summary": "Detects completed rows, removes them from the board, and handles the cascading effect of dropping remaining blocks.",
      "subsections": [
        {
          "id": "line-detection",
          "title": "Complete Line Detection",
          "summary": "Algorithm for identifying rows that are completely filled"
        },
        {
          "id": "removal-mechanics",
          "title": "Line Removal Mechanics",
          "summary": "Process for clearing filled lines and dropping blocks above"
        },
        {
          "id": "cascade-handling",
          "title": "Cascade and Multi-Line Clearing",
          "summary": "Handling simultaneous multi-line clears and chain reactions"
        }
      ]
    },
    {
      "id": "scoring-progression",
      "title": "Scoring and Progression Component",
      "summary": "Manages score calculation, level progression, and difficulty scaling throughout the game.",
      "subsections": [
        {
          "id": "score-calculation",
          "title": "Score Calculation System",
          "summary": "Point awards for different line clear combinations and bonus actions"
        },
        {
          "id": "level-progression",
          "title": "Level Progression Logic",
          "summary": "How levels increase and affect game difficulty"
        },
        {
          "id": "speed-scaling",
          "title": "Speed and Difficulty Scaling",
          "summary": "Adjusting fall speed and timing based on player level"
        }
      ]
    },
    {
      "id": "game-loop",
      "title": "Game Loop and Timing",
      "summary": "Coordinates all game systems through the main update cycle and manages frame-rate independent timing.",
      "subsections": [
        {
          "id": "update-cycle",
          "title": "Main Update Cycle",
          "summary": "Order of operations in each game frame"
        },
        {
          "id": "timing-management",
          "title": "Timing and Delta Management",
          "summary": "Frame-rate independent timing for consistent gameplay"
        },
        {
          "id": "state-coordination",
          "title": "Game State Coordination",
          "summary": "How different components synchronize their updates"
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Details how components communicate and the sequence of operations during key game events.",
      "subsections": [
        {
          "id": "component-communication",
          "title": "Component Communication Patterns",
          "summary": "How game systems pass information and coordinate actions"
        },
        {
          "id": "event-sequences",
          "title": "Key Event Sequences",
          "summary": "Step-by-step flows for piece placement, line clearing, and level progression"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Common failure scenarios and recovery strategies for maintaining stable gameplay.",
      "subsections": [
        {
          "id": "boundary-conditions",
          "title": "Boundary and Collision Edge Cases",
          "summary": "Handling pieces at board edges and complex collision scenarios"
        },
        {
          "id": "game-over-conditions",
          "title": "Game Over Detection",
          "summary": "Recognizing when the game should end and handling the transition"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Testing approach with milestone checkpoints to verify correct implementation at each development stage.",
      "subsections": [
        {
          "id": "unit-testing",
          "title": "Component Unit Testing",
          "summary": "Testing individual components in isolation"
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing",
          "summary": "Testing component interactions and full game scenarios"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "Expected behavior and verification steps after each milestone"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common issues encountered during Tetris development with diagnosis and resolution strategies.",
      "subsections": [
        {
          "id": "collision-debugging",
          "title": "Collision Detection Issues",
          "summary": "Troubleshooting piece movement and boundary problems"
        },
        {
          "id": "rotation-debugging",
          "title": "Rotation and Wall Kick Problems",
          "summary": "Debugging piece rotation issues and wall kick failures"
        },
        {
          "id": "timing-debugging",
          "title": "Timing and Animation Issues",
          "summary": "Resolving problems with game speed and visual updates"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements and how the current architecture supports future feature additions.",
      "subsections": [
        {
          "id": "gameplay-enhancements",
          "title": "Gameplay Feature Extensions",
          "summary": "Additional game modes, special pieces, and advanced mechanics"
        },
        {
          "id": "technical-improvements",
          "title": "Technical Architecture Extensions",
          "summary": "Performance optimizations and architectural improvements"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of Tetris-specific terminology and technical concepts used throughout this document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "System Architecture Overview",
      "description": "Shows the main components (Board, Tetromino System, Controls, Rotation, Line Clearing, Scoring) and their relationships. Includes data flow arrows showing how components communicate during gameplay.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-data-flow"
      ]
    },
    {
      "id": "data-model-relationships",
      "title": "Data Model and Type Relationships",
      "description": "Illustrates the relationships between core data structures: GameBoard, Tetromino, GameState, and their properties. Shows composition and dependency relationships.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "board-management",
        "tetromino-system"
      ]
    },
    {
      "id": "game-state-machine",
      "title": "Game State Machine",
      "description": "State transitions for overall game flow: Menu -> Playing -> Paused -> Game Over, with transitions triggered by user input and game events.",
      "type": "state-machine",
      "relevant_sections": [
        "game-loop",
        "error-handling"
      ]
    },
    {
      "id": "piece-lifecycle",
      "title": "Piece Lifecycle State Machine",
      "description": "State transitions for individual pieces: Spawning -> Falling -> Moving -> Locking -> Locked, showing how pieces progress through their lifecycle.",
      "type": "state-machine",
      "relevant_sections": [
        "tetromino-system",
        "movement-controls"
      ]
    },
    {
      "id": "line-clear-sequence",
      "title": "Line Clearing Sequence",
      "description": "Sequence diagram showing the step-by-step process when lines are cleared: detection -> removal -> cascade -> scoring -> level check -> speed adjustment.",
      "type": "sequence",
      "relevant_sections": [
        "line-clearing",
        "scoring-progression"
      ]
    },
    {
      "id": "rotation-wall-kick-flow",
      "title": "Rotation and Wall Kick Decision Flow",
      "description": "Flowchart showing the decision tree for piece rotation: attempt basic rotation -> check collision -> try wall kick offsets -> succeed or fail.",
      "type": "flowchart",
      "relevant_sections": [
        "rotation-system"
      ]
    },
    {
      "id": "game-loop-cycle",
      "title": "Game Loop Update Cycle",
      "description": "Flowchart of the main game loop showing the order of operations: handle input -> update gravity -> check collisions -> update board -> render -> repeat.",
      "type": "flowchart",
      "relevant_sections": [
        "game-loop",
        "interactions-data-flow"
      ]
    },
    {
      "id": "collision-detection-flow",
      "title": "Collision Detection Algorithm",
      "description": "Flowchart showing how collision detection works: get piece bounds -> check each cell -> test against board boundaries -> test against placed pieces -> return result.",
      "type": "flowchart",
      "relevant_sections": [
        "board-management",
        "movement-controls"
      ]
    }
  ]
}