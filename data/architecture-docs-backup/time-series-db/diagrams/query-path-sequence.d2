shape: sequence_diagram

direction: right

title: "Sequence Diagram: Query Path"
description: "Sequence diagram showing the flow of a query request: Client -> HTTP API -> Query Parser -> Query Planner -> Storage Engine (scan multiple TSM files) -> Aggregate/Process -> Stream results back to Client."

# Participants (Actors)
client: Client {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}
http_api: HTTP API {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}
query_parser: Query Parser {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}
query_planner: Query Planner {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}
storage_engine: Storage Engine {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}
aggregate_process: Aggregate/Process {
  style.fill: "#16213e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}

# Message Flow
client -> http_api: 1. HTTP Query Request (e.g., avg temp NYC July 2023)
http_api -> query_parser: 2. Parse Query & Validate Syntax
query_parser -> query_planner: 3. Abstract Syntax Tree (AST)
query_planner -> storage_engine: 4. Optimized Execution Plan (with indexes)
note: |md
  **Plan includes:**
  - Series Index lookup
  - TSM file selection (block pruning)
  - Columnar projection (timestamp, value)
| {
  style.fill: "#0f3460"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
  style.bold: false
}
storage_engine -> storage_engine: 5. Scan Multiple TSM Files & Blocks
storage_engine -> aggregate_process: 6. Stream Filtered Columnar Data
aggregate_process -> aggregate_process: 7. Apply Aggregation (e.g., GROUP BY, avg)
aggregate_process -> query_planner: 8. Partial/Final Results
query_planner -> http_api: 9. Formatted Result Set
http_api -> client: 10. Stream HTTP Response (e.g., JSON, CSV)