{
  "types": {
    "virtual_addr_t": "32-bit virtual address",
    "physical_addr_t": "32-bit physical address",
    "page_number_t": "virtual page number",
    "frame_number_t": "physical frame number",
    "page_offset_t": "offset within page",
    "permission_flags_t": "read/write/execute permissions",
    "translation_result_t": "enum: TRANSLATION_SUCCESS, TRANSLATION_PAGE_FAULT, TRANSLATION_PROTECTION_VIOLATION, TRANSLATION_TLB_MISS",
    "mmu_t": "Memory Management Unit state",
    "page_table_t": "page table structure",
    "tlb_t": "entries, size, global_timestamp, replacement_policy, random_state, stats",
    "page_table_entry_t": "frame_number:20, dirty:1, referenced:1, execute:1, write:1, read:1, user:1, present:1, valid:1",
    "tlb_entry_t": "vpn, pfn, perms, asid, timestamp, valid",
    "frame_table_entry_t": "frame_num, allocated, owner_page",
    "physical_memory_t": "frames array, total_frames, free_frames",
    "tlb_stats_t": "lookups, hits, misses, invalidations, flushes",
    "multi_level_page_table_t": "page_directory pointer, reference_counts array, physical_memory pointer, stats structure",
    "memory_pressure_monitor_t": "fields: total_faults uint64_t, recent_faults uint64_t, window_start_time uint64_t, window_duration_ms uint32_t, fault_rate_threshold double, thrashing_detected bool, consecutive_high_periods uint32_t",
    "working_set_tracker_t": "accessed_pages uint32_t*, buffer_size uint32_t, current_index uint32_t, unique_pages uint32_t, page_present bool*, access_count uint64_t, window_start_access uint64_t",
    "fifo_replacement_t": "page_queue frame_number_t*, queue_head uint32_t, queue_tail uint32_t, queue_size uint32_t, max_frames uint32_t, frame_positions uint32_t*",
    "lru_replacement_t": "lru_list_head lru_node_t*, lru_list_tail lru_node_t*, frame_to_node lru_node_t**, access_counter uint64_t, total_frames uint32_t",
    "clock_replacement_t": "clock_frames frame_number_t*, reference_bits bool*, clock_hand uint32_t, total_frames uint32_t, scan_count uint64_t",
    "lru_node_t": "fields: frame_number frame_number_t, access_time uint64_t, prev_node lru_node_t*, next_node lru_node_t*, valid bool",
    "interaction_stats_t": "translation_requests uint64_t, tlb_hits uint64_t, page_faults uint64_t, replacement_operations uint64_t, average_translation_time double, fault_resolution_time double",
    "error_context_t": "fields: result translation_result_t, failing_address virtual_addr_t, requested_permissions permission_flags_t, actual_permissions permission_flags_t, error_code uint32_t, error_message char[256], timestamp uint64_t",
    "fault_type_t": "enum values: FAULT_TYPE_MINOR, FAULT_TYPE_MAJOR, FAULT_TYPE_PROTECTION, FAULT_TYPE_SEGMENTATION",
    "test_timer_t": "fields: start_time, end_time, elapsed_seconds",
    "performance_stats_t": "fields: operation_count, total_time, min_time, max_time, sum_of_squares",
    "test_random_t": "fields: seed, state",
    "debug_logger_t": "output_file, current_level, operation_counter, timestamps_enabled, thread_ids_enabled",
    "log_level_t": "enum: ERROR, WARN, INFO, DEBUG, TRACE",
    "allocation_record_t": "ptr, size, file, line, allocation_id, next",
    "async_io_operation_t": "fields: operation_id uint32_t, operation_type io_op_type_t, virtual_address virtual_addr_t, frame_number frame_number_t, swap_slot_id slot_id_t, completion_callback function pointer, start_timestamp uint64_t, latency_ms uint64_t, completed bool",
    "async_io_system_t": "fields: pending_operations array, max_concurrent_ops uint32_t, active_operations uint32_t, next_operation_id uint32_t, queue_lock pthread_mutex_t, completion_condition pthread_cond_t, io_thread pthread_t, shutdown_requested bool",
    "swap_space_t": "fields: size_pages, latency_ms",
    "slot_id_t": "swap slot identifier",
    "swap_stats_t": "I/O statistics structure",
    "page_state_t": "enum: RESIDENT, SWAPPED, LOADING, EVICTING",
    "store_type_t": "backing store type",
    "callback_t": "async completion callback",
    "process_id_t": "process identifier",
    "io_op_type_t": "enum: READ_PAGE, WRITE_PAGE",
    "cow_frame_list_t": "shared frame tracking",
    "frame_id_t": "shared frame identifier",
    "address_space_t": "address space descriptor",
    "numa_node_id_t": "NUMA node identifier",
    "numa_node_t": "fields: node_id, local_frames array, total_local_frames uint32_t, available_local_frames uint32_t, access_latency_to_node array, current_bandwidth_usage double, max_bandwidth_gb_per_sec double",
    "numa_topology_t": "fields: nodes array, total_nodes uint32_t, latency_matrix uint32_t**, migration_counts uint64_t*, total_migration_overhead double",
    "bandwidth_t": "memory bandwidth type",
    "asid_t": "Address Space Identifier",
    "mm_struct_t": "address space structure",
    "bitmap_t": "bit allocation tracking",
    "memory_management_stats_t": "tlb_lookups, tlb_hits, tlb_misses, minor_page_faults, major_page_faults, protection_violations"
  },
  "methods": {
    "get_virtual_page_number(vaddr)": "extract page number from virtual address",
    "get_page_offset(vaddr)": "extract offset from virtual address",
    "make_physical_address(frame, offset)": "combine frame and offset to physical address",
    "mmu_translate(mmu, vaddr, paddr, perms)": "translate virtual to physical address",
    "mmu_create(page_table_size, tlb_size)": "initialize MMU with specified sizes",
    "print_address_breakdown(vaddr)": "display address components for debugging",
    "pte_create(frame, perms)": "create new PTE with specified frame and permissions",
    "pte_get_frame(pte)": "extract physical frame number from PTE",
    "pte_check_permission(pte, required)": "test if PTE grants required permissions",
    "pte_set_referenced(pte)": "mark page as recently accessed",
    "pte_is_valid(pte)": "check if PTE contains valid translation",
    "pte_is_present(pte)": "check if page is currently in memory",
    "tlb_lookup(tlb, vaddr, asid, frame, perms)": "search for cached translation",
    "tlb_insert(tlb, vaddr, frame, perms, asid)": "cache new translation",
    "tlb_invalidate(tlb, vaddr, asid)": "remove specific translation",
    "tlb_flush(tlb)": "clear all TLB entries",
    "tlb_lookup(tlb, vaddr, asid, frame, perms) returns translation_result_t": "search for cached translation",
    "tlb_insert(tlb, vaddr, frame, perms, asid) returns void": "cache new translation",
    "tlb_invalidate(tlb, vaddr, asid) returns void": "remove specific translation",
    "tlb_flush(tlb) returns void": "clear all TLB entries",
    "tlb_create(size, policy) returns tlb_t*": "creates and initializes TLB",
    "tlb_destroy(tlb) returns void": "cleans up TLB resources",
    "get_virtual_page_number(vaddr) returns page_number_t": "extract page number from virtual address",
    "get_page_offset(vaddr) returns page_offset_t": "extract offset from virtual address",
    "make_physical_address(frame, offset) returns physical_addr_t": "combine frame and offset",
    "get_page_dir_index(vaddr) returns uint32_t": "extract page directory index",
    "get_page_table_index(vaddr) returns uint32_t": "extract page table index",
    "multi_level_walk(mlpt, vaddr, paddr, perms) returns translation_result_t": "perform hierarchical page table walk",
    "multi_level_insert(mlpt, vaddr, frame, perms) returns translation_result_t": "insert new mapping with on-demand table allocation",
    "multi_level_remove(mlpt, vaddr) returns translation_result_t": "remove mapping and deallocate empty tables",
    "allocate_page_table() returns page_table_entry_t*": "allocate and initialize new second-level page table",
    "deallocate_page_table(table) returns void": "free second-level page table and update statistics",
    "is_page_table_empty(table) returns bool": "check if all entries in page table are invalid",
    "print_address_breakdown(vaddr) returns void": "display address components",
    "pte_is_present(pte) returns bool": "check if page is currently in memory",
    "pte_is_valid(pte) returns bool": "check if PTE contains valid translation",
    "pte_get_frame(pte) returns frame_number_t": "extract physical frame number from PTE",
    "pte_create(frame, perms) returns page_table_entry_t": "create new PTE with specified frame and permissions",
    "pte_check_permission(pte, required) returns bool": "test if PTE grants required permissions",
    "pte_set_referenced(pte) returns void": "mark page as recently accessed",
    "pressure_monitor_create(window_ms, threshold) returns memory_pressure_monitor_t*": "create memory pressure monitor",
    "pressure_monitor_record_fault(monitor) returns void": "record page fault for pressure monitoring",
    "pressure_monitor_is_thrashing(monitor) returns bool": "check if system is thrashing",
    "pressure_monitor_get_fault_rate(monitor) returns double": "get current fault rate",
    "working_set_create(window_size, max_pages) returns working_set_tracker_t*": "create working set tracker with specified window size",
    "working_set_record_access(tracker, page_num) returns void": "record access to a page for working set tracking",
    "working_set_get_size(tracker) returns uint32_t": "get current working set size",
    "fifo_select_victim(fifo) returns frame_number_t": "select victim page using FIFO algorithm",
    "fifo_add_page(fifo, frame) returns void": "add newly loaded page to FIFO queue",
    "lru_update_access(lru, frame) returns void": "update LRU information when page is accessed",
    "lru_select_victim(lru) returns frame_number_t": "select LRU victim for eviction",
    "clock_set_reference_bit(clock, frame) returns void": "set reference bit when page is accessed",
    "clock_select_victim(clock) returns frame_number_t": "select victim using Clock algorithm",
    "handle_page_replacement(mmu, vaddr, required_perms) returns translation_result_t": "main replacement coordinator",
    "mmu_translate(mmu, vaddr, paddr, perms) returns translation_result_t": "translate virtual to physical address",
    "handle_page_fault(mmu, vaddr, perms) returns translation_result_t": "page fault resolution coordinator",
    "handle_tlb_miss(tlb, vaddr, perms, frame) returns translation_result_t": "TLB miss handler coordination",
    "classify_page_fault(vaddr, perms, pte, fault_type) returns translation_result_t": "classify page fault type based on PTE state and permissions",
    "check_permissions(pte, required) returns translation_result_t": "verify PTE grants required permissions",
    "handle_copy_on_write(vaddr, pte) returns bool": "handle copy-on-write page fault",
    "tlb_invalidate_on_pte_change(tlb, vaddr, asid) returns void": "invalidate TLB entries when PTE changes",
    "create_error_context() returns error_context_t*": "create error context structure",
    "destroy_error_context(ctx) returns void": "free error context structure",
    "log_error(ctx, component, operation) returns void": "log error with context information",
    "test_timer_start(timer) returns void": "start timing measurement",
    "test_timer_stop(timer) returns void": "stop timing and calculate elapsed time",
    "test_malloc(size) returns void*": "tracked memory allocation for leak detection",
    "test_free(ptr) returns void": "tracked memory deallocation",
    "print_test_summary() returns void": "display test results and memory usage",
    "test_random_init(rng, seed) returns void": "initialize deterministic random number generator",
    "test_random_next(rng) returns uint32_t": "generate next pseudo-random number",
    "generate_virtual_address(page_number, offset) returns virtual_addr_t": "create virtual address from components",
    "create_test_page_table(num_pages) returns page_table_t*": "create page table with known mappings for testing",
    "generate_temporal_locality_pattern(addresses, count, working_set_size) returns void": "create access pattern with temporal locality",
    "generate_spatial_locality_pattern(addresses, count, base_address) returns void": "create sequential access pattern",
    "setup_memory_pressure_scenario(mmu, physical_frames, virtual_pages) returns void": "configure system for memory pressure testing",
    "performance_stats_init(stats) returns void": "initialize performance measurement structure",
    "performance_stats_record(stats, elapsed_time) returns void": "record timing measurement",
    "performance_stats_average(stats) returns double": "calculate average operation time",
    "performance_stats_stddev(stats) returns double": "calculate standard deviation",
    "measure_tlb_hit_rate(tlb, addresses, count, hit_rate) returns void": "measure TLB cache effectiveness",
    "measure_page_table_memory_usage(page_table) returns size_t": "calculate memory overhead",
    "measure_working_set_size(addresses, count, window_size) returns uint32_t": "calculate working set size",
    "validate_milestone1() returns int": "comprehensive milestone 1 validation",
    "benchmark_tlb_performance() returns void": "TLB performance measurement suite",
    "benchmark_replacement_algorithms() returns void": "compare replacement algorithm effectiveness",
    "debug_init(log_filename, level) returns debug_logger_t*": "initialize debugging subsystem",
    "debug_log(level, component, operation, format, ...) returns void": "structured logging with context",
    "dump_page_table_entry(pte, vpn) returns void": "display PTE details",
    "dump_page_table(table, name) returns void": "display complete page table",
    "dump_tlb_entry(entry, index) returns void": "display TLB entry details",
    "dump_tlb_state(tlb) returns void": "display complete TLB state",
    "validate_page_table_consistency(table) returns uint32_t": "check page table for corruption",
    "validate_tlb_consistency(tlb, page_table) returns uint32_t": "verify TLB matches page table",
    "validate_multi_level_consistency(mlpt) returns uint32_t": "check multi-level table structure",
    "validate_system_state(mmu) returns bool": "comprehensive consistency check",
    "debug_translate_address(mmu, vaddr, paddr, perms) returns translation_result_t": "detailed address translation with logging",
    "debug_malloc(size, file, line) returns void*": "tracked memory allocation",
    "debug_free(ptr, file, line) returns void": "tracked memory deallocation",
    "debug_report_leaks() returns void": "display memory leak report",
    "swap_space_create(size_pages, latency_ms) returns swap_space_t*": "Initialize simulated swap device",
    "swap_space_write_page(swap, page_data, slot_id) returns translation_result_t": "Store page to swap with latency simulation",
    "swap_space_read_page(swap, slot_id, page_data) returns translation_result_t": "Retrieve page from swap with latency simulation",
    "swap_space_allocate_slot(swap, vpn) returns slot_id_t": "Reserve swap slot for virtual page",
    "swap_space_free_slot(swap, slot_id) returns void": "Release swap slot for reuse",
    "swap_space_get_stats(swap) returns swap_stats_t*": "Return I/O statistics",
    "async_io_create(max_concurrent, base_latency_ms) returns async_io_system_t*": "Initialize async I/O subsystem",
    "io_simulation_thread(arg) returns void*": "Background I/O latency simulation",
    "numa_topology_create(node_count, frames_per_node) returns numa_topology_t*": "Initialize NUMA topology with latency matrix",
    "handle_demand_paging_fault(mmu, vaddr, required_perms) returns translation_result_t": "Extended page fault handler with swap support",
    "handle_cow_write_fault(mmu, vaddr, pte) returns translation_result_t": "Copy-on-write fault handler",
    "migrate_page_to_node(topology, vaddr, target_node, pte) returns translation_result_t": "NUMA page migration with cost analysis",
    "get_timestamp_ms() returns uint64_t": "Get current timestamp in milliseconds",
    "atomic_decrement(ptr) returns uint32_t": "Atomic reference count decrement",
    "numa_allocate_local_frame(node_id) returns frame_number_t": "Allocate frame on specific NUMA node",
    "frame_to_virtual_address(frame) returns void*": "Convert frame to virtual address for copying",
    "debug_print_translation_failure(vaddr, result) returns void": "display debugging information for failed translations"
  },
  "constants": {
    "PAGE_SIZE_BITS": "12 bits for 4KB pages",
    "PAGE_SIZE": "4096",
    "PAGE_OFFSET_MASK": "0xFFF",
    "PERM_READ": "read permission flag",
    "PERM_WRITE": "write permission flag",
    "PERM_EXECUTE": "execute permission flag",
    "TRANSLATION_SUCCESS": "0",
    "TRANSLATION_PAGE_FAULT": "1",
    "TRANSLATION_PROTECTION_VIOLATION": "2",
    "PERM_USER": "user mode permission flag",
    "REPLACEMENT_LRU": "1",
    "REPLACEMENT_RANDOM": "2 - random replacement policy",
    "PAGE_DIR_INDEX_BITS": "10 - number of bits for page directory index",
    "PAGE_TABLE_INDEX_BITS": "10 - number of bits for page table index",
    "PAGE_OFFSET_BITS": "12 - number of bits for page offset",
    "PAGE_DIR_INDEX_MASK": "0x3FF - mask for extracting directory index",
    "PAGE_TABLE_INDEX_MASK": "0x3FF - mask for extracting table index",
    "PAGE_DIR_INDEX_SHIFT": "22 - bit position of directory index",
    "PAGE_TABLE_INDEX_SHIFT": "12 - bit position of table index",
    "INVALID_FRAME": "invalid frame number constant",
    "TRANSLATION_SEGMENTATION_FAULT": "3",
    "FAULT_TYPE_MINOR": "0",
    "FAULT_TYPE_MAJOR": "1",
    "FAULT_TYPE_PROTECTION": "2",
    "FAULT_TYPE_SEGMENTATION": "3",
    "TRANSLATION_TLB_MISS": "translation not in cache",
    "TRANSLATION_OUT_OF_MEMORY": "memory exhaustion",
    "TRANSLATION_THRASHING_DETECTED": "excessive paging detected",
    "LOG_LEVEL_ERROR": "0",
    "LOG_LEVEL_WARN": "1",
    "LOG_LEVEL_INFO": "2",
    "LOG_LEVEL_DEBUG": "3",
    "LOG_LEVEL_TRACE": "4"
  },
  "terms": {
    "virtual memory": "abstraction providing each process private address space",
    "page table": "data structure mapping virtual pages to physical frames",
    "TLB": "Translation Lookaside Buffer - cache for address translations",
    "MMU": "Memory Management Unit - hardware/software performing address translation",
    "page fault": "exception when accessing non-resident virtual page",
    "demand paging": "loading pages from disk only when accessed",
    "address translation": "converting virtual addresses to physical addresses",
    "page replacement": "algorithm for selecting pages to evict when memory is full",
    "sparse address space": "virtual memory with large unmapped regions between used areas",
    "page table entry": "single mapping record containing frame number and metadata",
    "page offset": "low-order bits of virtual address specifying byte within page",
    "frame number": "physical memory page identifier",
    "permission flags": "read/write/execute access control bits",
    "valid bit": "indicates PTE contains correct translation",
    "present bit": "indicates page is currently in physical memory",
    "ASID": "Address Space Identifier for process isolation",
    "temporal locality": "recently accessed items likely to be accessed again",
    "TLB hit": "translation found in TLB cache",
    "TLB miss": "translation not in cache, requires page table walk",
    "replacement policy": "algorithm for selecting victim entries when cache is full",
    "TLB flush": "clearing all TLB entries",
    "stale translation": "outdated cached translation that no longer matches page table",
    "multi-level page table": "hierarchical page table structure with directory and second-level tables",
    "page directory": "top-level table containing pointers to second-level page tables",
    "page directory entry": "PDE - entry in page directory pointing to second-level page table",
    "page table walk": "process of traversing page table hierarchy to translate virtual address",
    "on-demand allocation": "creating second-level page tables only when first accessed",
    "reference counting": "tracking shared page usage",
    "directory index": "high-order bits of virtual address indexing into page directory",
    "table index": "middle bits of virtual address indexing into second-level page table",
    "hierarchical translation": "multi-step address translation through page directory and page tables",
    "memory overhead": "additional memory required for page table data structures",
    "allocation granularity": "size of virtual address region covered by each second-level page table",
    "working set": "number of distinct pages accessed in recent time window",
    "thrashing": "excessive paging overhead",
    "Belady's anomaly": "counterintuitive FIFO property where more memory can increase page faults",
    "dirty page": "page that has been modified since loading from storage",
    "reference bit": "single bit indicating recent page access for Clock algorithm",
    "victim selection": "process of choosing which page to evict during replacement",
    "write-back": "saving modified page contents to storage before eviction",
    "memory pressure": "system state with high page fault rate indicating insufficient memory",
    "minor fault": "TLB miss with valid PTE in page table",
    "major fault": "page fault requiring load from secondary storage",
    "protection violation": "access attempt exceeding page permission flags",
    "segmentation fault": "access to address outside valid address space",
    "copy-on-write": "shared page optimization with copy-on-write semantics",
    "TLB consistency": "maintaining coherence between TLB cache and page table",
    "TLB shootdown": "distributed TLB invalidation in multiprocessor systems",
    "unit testing": "testing individual components in isolation",
    "integration testing": "testing component interactions and system behavior",
    "milestone validation": "structured checkpoints verifying functionality after each development phase",
    "performance testing": "measuring system efficiency, scalability, and resource usage",
    "TLB hit rate": "percentage of translations found in TLB cache",
    "replacement algorithm": "strategy for selecting victim pages when memory is full",
    "spatial locality": "nearby memory locations likely to be accessed together",
    "permission checking": "validating access rights for memory operations",
    "coherency testing": "verifying consistency between cached and authoritative data",
    "stress testing": "evaluating system behavior under extreme conditions",
    "scalability testing": "measuring performance as system load increases",
    "debugging": "systematic process of identifying and fixing software bugs",
    "logging": "recording program execution events for analysis",
    "state inspection": "examining current values of program variables and data structures",
    "consistency checking": "validating data structure invariants and relationships",
    "trace analysis": "examining sequence of operations to understand program behavior",
    "memory corruption": "unintended modification of memory contents",
    "page table corruption": "invalid or inconsistent page table entry data",
    "TLB coherency": "maintaining consistency between TLB cache and page table",
    "use-after-free": "accessing memory after it has been deallocated",
    "memory leak": "allocated memory that is never freed",
    "race condition": "bugs caused by timing-dependent execution order",
    "deterministic testing": "testing with controlled, repeatable conditions",
    "bit manipulation error": "incorrect bitwise operations on addresses or flags",
    "address translation bug": "incorrect virtual to physical address conversion",
    "NUMA": "Non-Uniform Memory Access architecture",
    "swap space": "secondary storage for evicted pages",
    "page migration": "moving pages between NUMA nodes",
    "access pattern tracking": "monitoring page access locality",
    "asynchronous I/O": "non-blocking storage operations",
    "memory ordering": "coordination of memory operations across processors",
    "shootdown protocol": "TLB invalidation coordination mechanism",
    "memory barrier": "synchronization primitive for ordering",
    "pre-fetching": "loading pages before explicit access"
  }
}