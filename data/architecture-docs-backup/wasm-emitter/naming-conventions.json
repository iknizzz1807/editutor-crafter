{
  "types": {
    "BinaryWriter": "fields: buffer Vec<u8>, position usize",
    "StackState": "fields: depth usize",
    "CompilationError": "enum: TypeError, StackError, BinaryFormatError, LabelError, SignatureError",
    "Expression": "AST node representing expressions",
    "BinaryOp": "enum for binary operators",
    "ValueType": "enum: I32, I64, F32, F64",
    "FunctionType": "fields: param_types Vec<ValueType>, result_types Vec<ValueType>",
    "LiteralValue": "enum: I32(i32), I64(i64), F32(f32), F64(f64)",
    "CompilationContext": "fields: function_types Vec<FunctionType>, current_function_type Option<FunctionType>, local_types Vec<ValueType>, label_stack Vec<LabelInfo>",
    "LabelInfo": "fields: label_type LabelType, result_type Option<ValueType>",
    "LabelType": "enum: Block, Loop, If",
    "SectionSizeCalculator": "fields: current_size usize",
    "LocalResolver": "fields: param_count usize, local_names HashMap<String, usize>, local_types Vec<ValueType>",
    "ExpressionCompiler": "fields: writer BinaryWriter, stack StackState, locals LocalResolver",
    "LabelStack": "fields: labels Vec<LabelInfo>, label_names HashMap<String, usize>",
    "BlockTypeInferrer": "fields: path_types Vec<Option<ValueType>>",
    "ControlFlowCompiler": "fields: writer BinaryWriter, context CompilationContext, stack StackState",
    "FunctionTypeRegistry": "fields: types Vec<FunctionType>, type_map HashMap<u64, usize>",
    "CompiledFunction": "fields: type_index usize, local_types Vec<ValueType>, instructions Vec<u8>, binary_size usize",
    "ExportDeclaration": "fields: name String, name_bytes Vec<u8>, function_index u32",
    "SourceLocation": "fields: line usize, column usize, file String",
    "ErrorContext": "fields: phase CompilationPhase, function_name Option<String>, instruction_sequence Vec<String>, stack_state Option<StackState>",
    "CompilationPhase": "enum: Analysis, CodeGeneration, BinaryEmission, ModuleAssembly",
    "RecoveryStrategy": "enum: InsertTypeConversion, UseDefaultLabel, SkipInstruction, InsertPlaceholderValue",
    "CompilationPipeline": "fields: context CompilationContext, compiled_functions Vec<CompiledFunction>, error_recovery_enabled bool",
    "TestBinaryValidator": "test utility for validating binary format",
    "RuntimeValidator": "test utility for runtime execution validation",
    "RuntimeType": "enum: NodeJS, Wasmtime, Browser",
    "StackFrame": "fields: value_type ValueType, source_instruction String, instruction_index usize",
    "StackTracer": "fields: frames Vec<StackFrame>, instruction_history VecDeque<String>, max_history usize, trace_enabled bool",
    "BugPattern": "fields: name String, symptoms Vec<String>, likely_causes Vec<String>, diagnostic_steps Vec<String>, fix_suggestions Vec<String>",
    "ErrorAnalyzer": "fields: patterns HashMap<String, BugPattern>, recent_errors Vec<CompilationError>",
    "OptimizationPass": "fields: name String, pass_type PassType, dependencies Vec<String>, invalidates Vec<String>",
    "PassType": "enum: Analysis, Transform, Verification",
    "OptimizationPipeline": "fields: passes Vec<Box<dyn OptimizationPassTrait>>, pass_manager PassManager, analysis_cache HashMap<String, Box<dyn AnalysisResult>>",
    "ExtendedExpression": "enum with memory operations, structured data, function features",
    "ExtendedTypeSystem": "fields: basic_types HashMap<String, ValueType>, struct_types HashMap<String, StructType>, function_types HashMap<String, FunctionType>, pointer_types HashMap<ValueType, PointerType>",
    "ToolingContext": "fields: compilation_pipeline CompilationPipeline, source_manager SourceManager, semantic_cache SemanticCache, error_reporter ErrorReporter",
    "LanguageServer": "fields: context ToolingContext, client_connection LSPConnection, document_cache HashMap<String, Document>"
  },
  "methods": {
    "emit_module_header(writer) -> Result": "writes WebAssembly magic number and version",
    "emit_section(writer, id, content) -> Result": "writes section with LEB128 size prefix",
    "encode_u32(value) -> Vec<u8>": "LEB128 encoding for unsigned integers",
    "encode_i32(value) -> Vec<u8>": "LEB128 encoding for signed integers",
    "u32_size(value) -> usize": "calculates encoded size without encoding",
    "compile_expression(expr, writer, stack) -> Result": "compiles AST expression to WebAssembly instructions",
    "emit_local_get(writer, index) -> Result": "emits local.get instruction",
    "emit_i32_const(writer, value) -> Result": "emits i32.const instruction",
    "emit_module_header(writer)": "writes WebAssembly magic number and version",
    "encode_u32(value)": "LEB128 encoding for unsigned integers",
    "u32_size(value)": "calculates encoded size without encoding",
    "write_u8(value)": "writes single byte to buffer",
    "write_bytes(bytes)": "writes byte slice to buffer",
    "to_byte(self) -> u8": "convert ValueType to binary encoding",
    "from_byte(byte) -> Result<ValueType, CompilationError>": "parse ValueType from binary",
    "new(param_types, result_types) -> FunctionType": "create function type",
    "binary_size(&self) -> usize": "calculate encoding size",
    "write_binary(&self, writer) -> Result": "write to binary format",
    "to_opcode(self, value_type) -> Result<u8, CompilationError>": "get WebAssembly opcode",
    "is_commutative(self) -> bool": "check if operation is commutative",
    "stack_effect(&self) -> Result<(usize, usize), CompilationError>": "calculate stack consumption and production",
    "result_type(&self) -> Result<Option<ValueType>, CompilationError>": "get expression result type",
    "validate(&self, context) -> Result": "validate expression semantics",
    "i32_size(value) -> usize": "calculates signed encoded size without encoding",
    "new(estimated_size)": "creates writer with initial capacity",
    "position()": "returns current write position",
    "capacity()": "returns current buffer capacity",
    "into_bytes()": "consumes writer and returns buffer",
    "calculate_section_size()": "calculates total size for section including header",
    "add_u32(value)": "adds LEB128 unsigned integer size",
    "add_string(string)": "adds string size with length prefix",
    "emit_binary_operation(op, left_type, right_type) -> Result": "emits binary operation after type verification",
    "validate_stack_balance(expected_depth) -> Result": "validates expected stack depth",
    "emit_type_conversion(source_type, target_type) -> Result": "handles automatic type conversion",
    "resolve_variable(&self, name) -> Result<(usize, ValueType), CompilationError>": "resolve variable name to index and type",
    "add_local(&mut self, name, local_type) -> usize": "add local variable and return index",
    "is_compatible_with(&self, other) -> bool": "check type compatibility",
    "conversion_instruction(&self, target) -> Option<u8>": "get conversion opcode between types",
    "push_label(label_type, result_type, name)": "adds label to stack with optional name",
    "pop_label()": "removes and returns top label",
    "find_label_depth(target_name, label_type_filter)": "calculate relative label depth for branches",
    "add_execution_path(result_type)": "records result type for one execution path",
    "infer_block_type()": "determines block result type from all paths",
    "compile_if_statement(condition, then_body, else_body)": "generates WebAssembly if/else/end structure",
    "compile_while_loop(condition, body)": "generates WebAssembly loop with br_if pattern",
    "compile_break_statement(target_label)": "generates br instruction to target label",
    "compile_continue_statement(target_label)": "generates br instruction to loop beginning",
    "emit_block_with_type(block_type)": "writes block instruction with type annotation",
    "validate_control_structure_stack(expected_result_type, initial_depth)": "checks stack balance at control boundaries",
    "compile_function(name, params, result_type, body) -> Result<u32, CompilationError>": "compiles complete function from AST",
    "add_export(export_name, function_index) -> Result": "processes function export declarations",
    "emit_module(writer) -> Result": "emits complete WebAssembly module",
    "get_or_register_type(func_type) -> usize": "register function type with deduplication",
    "emit_type_section(writer) -> Result": "generates type section binary",
    "emit_local_declarations(writer) -> Result": "writes local variable declarations",
    "calculate_type_hash(func_type) -> u64": "content hash for type deduplication",
    "add_context(context)": "accumulate context information for error reporting",
    "is_recoverable()": "determine if error allows continued compilation",
    "suggest_recovery()": "provide automated repair suggestions",
    "transition_to_phase(phase)": "validate and perform phase transition",
    "get_function_type(index)": "resolve function index to type signature",
    "resolve_local(name)": "map variable name to local index and type",
    "calculate_binary_size()": "compute total size including local declarations",
    "validate_stack_balance()": "verify instruction sequence maintains stack balance",
    "compile_module(ast)": "run complete compilation pipeline",
    "run_analysis_phase(ast)": "extract type information and build context",
    "run_codegen_phase(ast)": "compile functions to instruction sequences",
    "run_binary_emission_phase()": "encode instructions to binary format",
    "run_module_assembly_phase()": "combine sections into complete module",
    "handle_compilation_error(error)": "determine recovery strategy and apply if possible",
    "is_recoverable() -> bool": "determine if error allows continued compilation",
    "suggest_recovery() -> Option<RecoveryStrategy>": "provide automated repair suggestions",
    "attempt_recovery(error, context, binary_state) -> Result": "attempt error recovery with validation",
    "validate_type_consistency(operation, operand_types) -> Result": "checks operation compatibility with operand types",
    "validate_module_header(&self, bytes) -> Result": "validates WebAssembly magic number and version",
    "validate_section_structure(&self, section_id, content, encoded) -> Result": "validates section ID, size prefix, and content",
    "create_test_module(&self) -> Vec<u8>": "generates minimal test module",
    "validate_with_wabt(binary) -> Result": "executes WABT validation tools",
    "execute_and_validate(&self, binary, function_name, args) -> Result": "executes WebAssembly and validates results",
    "test_encode_decode_roundtrip_u32(value)": "helper for LEB128 roundtrip testing",
    "test_encode_decode_roundtrip_i32(value)": "helper for signed LEB128 testing",
    "generate_nodejs_test_script(module_path, function_name, args) -> String": "creates Node.js execution script",
    "validate_module_header(bytes) -> Result": "validates WebAssembly magic number and version",
    "validate_section_structure(section_id, content, encoded) -> Result": "validates section ID, size prefix, and content",
    "create_test_module() -> Vec<u8>": "generates minimal test module",
    "execute_and_validate(binary, function_name, args) -> Result": "executes WebAssembly and validates results",
    "push_value(value_type, instruction)": "records stack push with tracing",
    "pop_value(expected_type) -> Result<ValueType>": "records stack pop with type checking",
    "validate_binary_operation(op) -> Result<ValueType>": "validates binary operation stack effects",
    "trace_expression_compilation(expr_description)": "marks expression compilation boundaries",
    "get_recent_instructions(count) -> Vec<String>": "extracts recent instruction history",
    "analyze_error(error) -> Vec<String>": "provides pattern-based error analysis",
    "suggest_debugging_approach(error) -> Vec<String>": "generates debugging procedure suggestions",
    "add_custom_pattern(pattern)": "adds project-specific bug patterns",
    "detect_available_runtimes()": "auto-detects WebAssembly runtime installations",
    "add_pass(&mut self, pass) -> ()": "validates dependencies and adds optimization pass to pipeline",
    "run_passes(&mut self, ir) -> Result": "executes optimization passes in dependency order with caching",
    "run(&self, ir, analyses) -> Result<bool, OptimizationError>": "executes single optimization pass with analysis dependencies",
    "register_struct_type(&mut self, name, fields) -> Result": "validates and registers new struct type with layout calculation",
    "resolve_field_access(&self, struct_type, field_name) -> Result<(usize, ValueType), TypeError>": "calculates field offset and returns type information",
    "analyze_source(&mut self, source, file_path) -> Result<AnalysisResult, ToolingError>": "performs semantic analysis and caches results for tooling",
    "get_completions(&self, position) -> Vec<CompletionItem>": "generates code completion suggestions at source position",
    "find_definition(&self, position) -> Option<SourceLocation>": "locates symbol definition for tooling navigation",
    "generate_source_map(&self, binary) -> Result<SourceMap, ToolingError>": "creates debugging source map from binary WebAssembly",
    "handle_did_open(&mut self, params) -> Result": "processes LSP document open notification",
    "handle_completion(&self, params) -> Result<CompletionResponse, LSPError>": "processes LSP completion request",
    "push_label(label_type, result_type)": "adds label to stack",
    "pop_label() -> Option<LabelInfo>": "removes and returns top label",
    "is_recoverable(&self) -> bool": "determine if error allows continued compilation",
    "suggest_recovery(&self) -> Option<RecoveryStrategy>": "provide automated repair suggestions",
    "push_value(&mut self, value_type, instruction)": "records stack push with tracing",
    "get_recent_instructions(&self, count) -> Vec<String>": "extracts recent instruction history",
    "analyze_error(&self, error) -> Vec<String>": "provides pattern-based error analysis"
  },
  "constants": {
    "WASM_MAGIC": "0x6d736100 - WebAssembly magic number",
    "WASM_VERSION": "0x00000001 - WebAssembly version",
    "OP_LOCAL_GET": "0x20 - local.get opcode",
    "OP_I32_CONST": "0x41 - i32.const opcode",
    "LEB128_CONTINUATION_BIT": "0x80 - continuation bit for LEB128",
    "LEB128_VALUE_MASK": "0x7F - extracts 7-bit value from LEB128 byte",
    "LEB128_SIGN_BIT": "0x40 - sign bit position for signed LEB128",
    "OP_BLOCK": "0x02 - WebAssembly block opcode",
    "OP_LOOP": "0x03 - WebAssembly loop opcode",
    "OP_IF": "0x04 - WebAssembly if opcode",
    "OP_ELSE": "0x05 - WebAssembly else opcode",
    "OP_END": "0x0B - WebAssembly end opcode",
    "OP_BR": "0x0C - WebAssembly br opcode",
    "OP_BR_IF": "0x0D - WebAssembly br_if opcode",
    "OP_RETURN": "0x0F - return opcode",
    "OP_UNREACHABLE": "0x00 - WebAssembly unreachable opcode",
    "BLOCK_TYPE_EMPTY": "0x40 - empty block type encoding",
    "BLOCK_TYPE_I32": "0x7F - i32 block type encoding",
    "BLOCK_TYPE_F32": "0x7D - f32 block type encoding",
    "OP_LOCAL_SET": "0x21 - local.set opcode",
    "OP_CALL": "0x10 - call opcode"
  },
  "terms": {
    "stack machine": "execution model where operations use implicit operand stack",
    "LEB128": "Little Endian Base 128 variable-length integer encoding",
    "structured control flow": "WebAssembly's nested block-based control structures",
    "section emission": "process of writing WebAssembly binary sections with size prefixes",
    "operand ordering": "correct sequencing of values on the execution stack",
    "label depth": "relative index for branch target resolution in nested blocks",
    "binary format mastery": "comprehensive understanding of WebAssembly specification compliance",
    "correctness over performance": "prioritizing valid output over optimized code generation",
    "intermediate representation": "internal structures bridging AST nodes and binary WebAssembly instructions",
    "type system": "WebAssembly's primitive value types and function signatures",
    "compilation context": "state tracking information needed during compilation phases",
    "two-pass approach": "size calculation followed by binary emission strategy",
    "module container": "WebAssembly module as structured container with typed sections",
    "variable-length encoding": "encoding scheme where data size depends on encoded value",
    "post-order traversal": "algorithm for correct stack instruction generation",
    "stack depth tracking": "maintaining accurate count of execution stack values",
    "type coercion": "automatic conversion between compatible types",
    "local variable index": "WebAssembly index for accessing function parameters and locals",
    "instruction emission": "process of generating WebAssembly binary instructions",
    "stack balance": "ensuring stack depth correctness throughout compilation",
    "block type annotations": "WebAssembly requirement for control structures to declare result types",
    "unreachable code": "code that follows unconditional control transfers",
    "branch target resolution": "algorithm for calculating correct label depths",
    "label stack": "runtime stack tracking nested control structures during compilation",
    "polymorphic typing": "WebAssembly's type system for unreachable code contexts",
    "function ABI": "interface contract specifying parameter and return types",
    "stack-based parameter passing": "WebAssembly convention for function arguments via execution stack",
    "interface contract": "formal agreement between caller and function about data flow",
    "multi-phase transformation pipeline": "sequential stages converting function definitions to binary",
    "assembly line factory": "systematic compilation process with specialized workstations",
    "signature analysis": "extraction and validation of function parameter and return types",
    "local variable allocation": "assignment of WebAssembly local indices to source variables",
    "unified index space": "WebAssembly namespace combining parameters and locals",
    "instruction sequence generation": "transformation of AST to WebAssembly instructions",
    "binary emission": "final encoding phase producing WebAssembly code section",
    "two-pass compilation approach": "size calculation followed by binary generation strategy",
    "contract negotiation mechanism": "WebAssembly module linking between modules and hosts",
    "selective visibility contract": "export system declaring host-accessible functions",
    "dependency declaration": "import system specifying required external functions",
    "function index space management": "coordination of imported and local function indices",
    "type deduplication": "reusing identical function signatures to reduce binary size",
    "content-addressed type registry": "hash-based system for function type management",
    "signature canonicalization": "normalization ensuring consistent type matching",
    "parameter-first indexing": "WebAssembly local indexing with parameters at lowest indices",
    "symbol table with forward reference handling": "compilation strategy supporting flexible function organization",
    "multi-pass compilation strategy": "sequential phases transforming AST through specialized stages",
    "error propagation": "mechanism for preserving context as errors move through pipeline",
    "phase transition": "controlled movement between compilation stages with validation",
    "error recovery": "strategies for continuing compilation after recoverable errors",
    "compilation pipeline": "coordinated sequence of transformation phases",
    "structured error taxonomy": "categorized classification of compilation failure modes",
    "quality control system": "comprehensive error detection and recovery mechanisms",
    "medical triage system": "error categorization by severity and required treatment",
    "damage control system": "error isolation and continued processing capabilities",
    "compliance auditing system": "validation against WebAssembly specification requirements",
    "graduated recovery strategy": "multiple recovery approaches based on error severity",
    "incremental validation": "validation at compilation phase boundaries",
    "cascading error recovery": "recovery attempts that create additional downstream errors",
    "error recovery and partial compilation": "strategies for continuing compilation after errors and producing useful diagnostic information",
    "binary format conformance": "exact compliance with WebAssembly binary specification",
    "progressive complexity approach": "testing strategy starting simple and adding complexity",
    "graduated verification approach": "multi-level testing building confidence incrementally",
    "precision instrument calibration": "validating individual tools produce exact expected output",
    "graduation ceremonies": "milestone checkpoints demonstrating mastery before advancement",
    "final product quality assurance": "end-to-end validation in real deployment environments",
    "binary format debugging": "systematic inspection and validation of WebAssembly binary output",
    "stack machine debugging": "tracing execution stack depth and operand ordering",
    "bug pattern recognition": "systematic matching of symptoms to known failure modes",
    "systematic trace analysis": "methodical reconstruction of instruction sequences leading to errors",
    "operand ordering verification": "ensuring non-commutative operations receive operands in correct sequence",
    "LEB128 variable-length encoding": "WebAssembly integer encoding with continuation bits",
    "peephole optimization": "pattern matching on short instruction sequences for local improvements",
    "register allocation": "assignment of variables to WebAssembly local slots with lifetime analysis",
    "stack depth optimization": "minimizing peak execution stack usage through expression reordering",
    "constant propagation": "tracking and substituting compile-time constant values",
    "dead code elimination": "removing unreachable or unused code sections",
    "function inlining": "replacing function calls with function body when beneficial",
    "multi-level intermediate representation": "progressive lowering through HIR, MIR, and LIR stages",
    "source map generation": "creating debugging metadata mapping binary instructions to source locations",
    "language server protocol": "standardized interface for IDE integration and rich editing features",
    "incremental compilation": "recompiling only changed portions for faster development iteration",
    "metadata preservation": "maintaining source location and semantic information through compilation",
    "tooling integration": "providing APIs and interfaces for external development tools",
    "performance profiling": "instrumentation and analysis for runtime performance optimization",
    "build system integration": "standardized interfaces for modern build toolchain compatibility"
  }
}