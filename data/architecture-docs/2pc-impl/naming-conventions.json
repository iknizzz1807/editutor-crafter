{
  "types": {
    "Transaction": "TxID string, Participants []Participant, State TransactionState, Operations []Operation, Votes map[string]Vote, Decision Decision, AcksReceived map[string]bool, CreatedAt int64",
    "LogRecord": "TxID string, State LogState, Participants []string, Decision Decision, Vote Vote, Timestamp int64, Operations []Operation",
    "Participant": "ID string, URL string, Locks []ResourceLock",
    "Vote": "VoteCommit, VoteAbort",
    "Decision": "DecisionCommit, DecisionAbort",
    "TransactionState": "StateInit, StatePreparing, StateWaitingVotes, StatePrepared, StateCommitting, StateAborting, StateCompleted",
    "LogState": "LogStateInit, LogStatePreparing, LogStatePrepared, LogStateCommitting, LogStateAborting, LogStateCommitted, LogStateAborted, LogStateCompleted",
    "PrepareMessage": "TxID string, Operations []Operation, CoordinatorURL string",
    "VoteMessage": "TxID string, Vote Vote, ParticipantID string",
    "CommitMessage": "TxID string, Decision Decision",
    "AckMessage": "TxID string, ParticipantID string, Success bool",
    "Operation": "ResourceID string, Type OperationType, Value interface{}",
    "OperationType": "Read, Write, Delete",
    "WAL": "file *os.File, mu sync.Mutex, path string",
    "Entry": "Data []byte",
    "AbortMessage": "TxID string, Decision Decision",
    "ResourceLock": "ResourceID string, LockType string",
    "QueryMessage": "TxID string",
    "MessageFilter": "FromNode string, ToNode string, MessageType string, TxID string",
    "DelayRule": "Filter MessageFilter, Delay time.Duration",
    "CrashHookManager": "mu sync.RWMutex, hooks map[string]func() bool, active bool",
    "NetworkFaultInjector": "mu sync.RWMutex, dropRules []MessageFilter, delayRules []DelayRule, realSender func(url string, message interface{}) error",
    "LogInspector": "logPath string",
    "PreCommitMessage": "TxID string, CoordinatorURL string",
    "PreCommitAckMessage": "TxID string, ParticipantID string, Success bool",
    "GroupCommitWAL": "file *os.File, mu sync.Mutex, batchBuffer []Entry, waiters []chan error, flushTicker *time.Ticker, maxBatchSize int, stopCh chan struct{}",
    "PaxosCoordinator": "node raft.Node, storage *raft.MemoryStorage, commitC <-chan *string, proposeC chan<- string, transactions sync.Map",
    "QueryResponseMessage": "State LogState"
  },
  "methods": {
    "MakeDecision(txID string, votes map[string]Vote) Decision": "Evaluates votes and returns global decision",
    "ExecutePreparePhase(txID string) (map[string]Vote, error)": "Sends PREPARE to all participants, collects votes",
    "HandlePrepare(msg PrepareMessage) (Vote, error)": "Participant processes PREPARE and returns vote",
    "Recover() error": "Reads WAL and resumes in-progress transactions",
    "Append(entry Entry) error": "Appends entry to log with fsync",
    "ReadAll() ([]Entry, error)": "Returns all log entries from disk",
    "SendMessage(url string, message interface{}) error": "Sends JSON message via HTTP POST",
    "SendMessageWithRetry(url string, message interface{}, maxRetries int) error": "Sends message with exponential backoff",
    "CollectVotesWithTimeout(txID string, participants []Participant, timeout time.Duration) (map[string]Vote, error)": "Collects votes from all participants with timeout",
    "BeginTransaction(operations []Operation) (txID string, error)": "Creates new transaction with unique ID",
    "RegisterParticipant(txID string, participant Participant) error": "Adds participant to transaction",
    "QueryTransactionStatus(txID string) (TransactionState, error)": "Returns current transaction state",
    "HandleCommit(msg CommitMessage) (AckMessage, error)": "Applies commit decision",
    "HandleAbort(msg AbortMessage) (AckMessage, error)": "Applies abort decision",
    "BroadcastMessage(participants []Participant, message interface{}) map[string]error": "Sends message to all participants concurrently",
    "HandleVoteReceived(msg VoteMessage) error": "Called when VoteMessage arrives from participant",
    "Truncate(beforeIndex int) error": "Removes log entries before specified index",
    "logCommitDecision(txID string, decision Decision) error": "Persists commit decision before sending messages",
    "logVote(txID string, vote Vote) error": "Persists participant vote before responding",
    "NewWAL(path string) (*WAL, error)": "Creates or opens WAL at given path",
    "Close() error": "Closes the log file",
    "BeginTransaction(operations []Operation) returns (string, error)": "Creates new transaction with unique ID",
    "RegisterParticipant(txID string, participant Participant) returns error": "Adds participant to transaction",
    "QueryTransactionStatus(txID string) returns (TransactionState, error)": "Returns current transaction state",
    "ExecutePreparePhase(txID string) returns (map[string]Vote, error)": "Sends PREPARE to all participants, collects votes",
    "MakeDecision(txID string, votes map[string]Vote) returns Decision": "Evaluates votes and returns global decision",
    "ExecuteCommitPhase(txID string, decision Decision) returns error": "Logs decision and broadcasts to participants",
    "HandleVoteReceived(msg VoteMessage) returns error": "Called when VoteMessage arrives from participant",
    "CollectVotesWithTimeout(txID string, participants []Participant, timeout time.Duration) returns (map[string]Vote, error)": "Collects votes from all participants with timeout",
    "logCommitDecision(txID string, decision Decision) returns error": "Persists commit decision before sending messages",
    "Recover() returns error": "Reads WAL and resumes in-progress transactions",
    "SendMessage(url string, message interface{}) returns error": "Sends JSON message via HTTP POST",
    "SendMessageWithRetry(url string, message interface{}, maxRetries int) returns error": "Sends message with exponential backoff",
    "BroadcastMessage(participants []Participant, message interface{}) returns map[string]error": "Sends message to all participants concurrently",
    "NewWAL(path string) returns (*WAL, error)": "Creates or opens WAL at given path",
    "Append(entry Entry) returns error": "Adds entry to batch, blocks until fsync completes",
    "ReadAll() returns ([]Entry, error)": "Returns all log entries from disk",
    "Close() returns error": "Closes the log file",
    "Truncate(beforeIndex int) returns error": "Removes log entries before specified index",
    "AcquireLock(resourceID string, lockType LockType, txID string, timeout time.Duration) error": "Attempts to acquire a lock with timeout",
    "ReleaseLocks(txID string)": "Releases all locks held by a transaction",
    "HandlePrepare(msg PrepareMessage) returns (Vote, error)": "Participant processes PREPARE and returns vote",
    "HandleCommit(msg CommitMessage) returns (AckMessage, error)": "Applies commit decision",
    "HandleAbort(msg AbortMessage) returns (AckMessage, error)": "Applies abort decision",
    "logVote(txID string, vote Vote) returns error": "Persists participant vote before responding",
    "ExecuteCommitPhase(txID string, decision Decision) error": "Logs decision and broadcasts to participants",
    "ComputeChecksum(data []byte) uint32": "Computes CRC32 checksum",
    "ValidateEntry(entryData []byte) bool": "Checks length and checksum",
    "WriteEntryWithChecksum(data []byte) error": "Writes length + checksum + data",
    "ReadValidatedEntries() ([]Entry, error)": "Reads all entries, skipping corrupted ones",
    "QueryCoordinatorForDecision(txID string, coordinatorURL string) (Decision, error)": "Queries coordinator when participant is uncertain",
    "ExecutePreparePhaseWithCrashDetection(txID string) (map[string]Vote, error)": "Sends PREPARE and handles coordinator crash",
    "RecoverFromLogWithCorruption() error": "Reads log and handles corrupted entries",
    "ExecuteHook(hookName string)": "Checks if a crash should occur at this point",
    "RegisterCrashHook(hookName string, condition func() bool)": "Registers a condition function that returns true to trigger crash",
    "EnableCrashHooks()": "Activates the hook manager",
    "DisableCrashHooks()": "Deactivates the hook manager",
    "SetDropRule(filter MessageFilter)": "Configures message drops matching the filter",
    "SetDelayRule(filter MessageFilter, delay time.Duration)": "Configures delays for messages matching the filter",
    "ClearRules()": "Removes all fault injection rules",
    "ReadAllEntries() ([]LogRecord, error)": "Reads all entries from the log, skipping corrupted ones",
    "GetEntriesForTransaction(txID string) ([]LogRecord, error)": "Returns all log entries for a specific transaction",
    "GetLastDecision(txID string) (Decision, error)": "Returns the last decision logged for a transaction",
    "ExecuteThreePhaseCommit(txID string, decision Decision) returns error": "Implements three-phase commit with pre-commit phase",
    "HandlePreCommit(msg PreCommitMessage) returns (PreCommitAckMessage, error)": "Processes PRE-COMMIT message and logs pre-committed state",
    "RecoverWithThreePhase() returns error": "Recovers from crash including pre-committed state handling",
    "ProposeDecision(txID string, decision Decision) returns error": "Proposes decision to Raft group, waits for commit",
    "SendVoteToAllCoordinators(txID string, vote Vote, coordinatorURLs []string) returns error": "Broadcasts vote to all coordinator replicas",
    "NewGroupCommitWAL(path string, flushInterval time.Duration, maxBatchSize int) returns (*GroupCommitWAL, error)": "Creates WAL with group commit enabled",
    "flushLoop()": "Background goroutine performing periodic flushes",
    "flushNow()": "Writes buffered entries and performs single fsync",
    "writeEntry(entry Entry) returns error": "Writes single entry with length and checksum",
    "QueryParticipantState(participantURL string, txID string) returns (LogState, error)": "Queries another participant for transaction state",
    "CollectAcksAsync(txID string, participants []Participant)": "Spawns goroutine to collect acknowledgments in background"
  },
  "constants": {
    "VoteCommit": "Participant agrees to commit",
    "VoteAbort": "Participant refuses to commit",
    "DecisionCommit": "Global decision to commit transaction",
    "DecisionAbort": "Global decision to abort transaction",
    "StateInit": "Transaction initialized",
    "StatePreparing": "Coordinator sending PREPARE",
    "StatePrepared": "Participant has voted",
    "StateWaitingVotes": "Coordinator collecting votes",
    "StateCommitting": "Coordinator decided COMMIT",
    "StateAborting": "Coordinator decided ABORT",
    "StateCompleted": "Transaction finished",
    "StateCommitted": "Participant applied COMMIT",
    "StateAborted": "Participant applied ABORT",
    "Read": "Read operation type",
    "Write": "Write operation type",
    "Delete": "Delete operation type",
    "LogStateInit": "Log state for initialization",
    "LogStatePreparing": "Log state for prepare phase",
    "LogStatePrepared": "Log state for participant vote",
    "LogStateCommitting": "Log state for commit decision",
    "LogStateAborting": "Log state for abort decision",
    "LogStateCommitted": "Log state for participant commit",
    "LogStateAborted": "Log state for participant abort",
    "LogStateCompleted": "Log state for completion",
    "Shared": "Shared lock type",
    "Exclusive": "Exclusive lock type",
    "StatePreCommitting": "Coordinator state during pre-commit phase",
    "StatePreCommitted": "Participant state after receiving and logging pre-commit",
    "LogStatePreCommitting": "Log state for coordinator pre-commit phase",
    "LogStatePreCommitted": "Log state for participant pre-commit"
  },
  "terms": {
    "two-phase commit": "Protocol for atomic commitment across multiple participants",
    "prepare phase": "First phase where coordinator asks participants to vote",
    "commit phase": "Second phase where coordinator broadcasts decision",
    "write-ahead log": "Durable log of state transitions written before taking effect",
    "coordinator": "Central decision-maker driving the protocol",
    "participant": "Resource manager that votes and applies decisions",
    "atomicity": "All-or-nothing guarantee for distributed transaction",
    "blocking": "Property where participants must wait for coordinator decision",
    "uncertainty window": "Period after voting YES where participant doesn't know decision",
    "fsync": "System call to flush data to disk for durability",
    "vote": "Participant's response to PREPARE",
    "decision": "Coordinator's global outcome",
    "presumed abort": "Optimization where missing decision is assumed to be abort",
    "fail-stop model": "Failure assumption where processes crash and stop",
    "Byzantine failures": "Malicious or arbitrarily faulty behavior beyond simple crashes",
    "network partition": "Split in network connectivity preventing communication",
    "group commit": "Optimization batching multiple log writes into single fsync",
    "distributed transaction": "Single logical operation spanning multiple independent systems",
    "crash recovery": "Process of restoring state from logs after failure",
    "at-least-once delivery": "Message delivery guarantee where duplicates are possible",
    "idempotent": "Operation that can be safely applied multiple times",
    "log truncation": "Removing completed transaction entries from log",
    "checksum": "Hash value for detecting data corruption (CRC32 or SHA-256)",
    "lock acquisition": "Process of obtaining exclusive or shared locks on resources",
    "exponential backoff": "Retry strategy with increasing delay between attempts",
    "state machine": "Formal model defining legal state transitions",
    "in-progress transaction": "Transaction that hasn't reached completed state",
    "append-only": "Log structure where entries are only added to the end, never modified",
    "truncation": "Removing completed transaction entries from log",
    "log rotation": "Copying active log to new file to prevent fragmentation",
    "durability": "Guarantee that committed data survives crashes",
    "sequential writes": "Writing data in order to file, optimized on disk hardware",
    "transaction log": "Persistent record of all transaction state transitions",
    "log compaction": "Process of removing old entries to prevent unbounded growth",
    "in-doubt transaction": "Transaction where participant voted YES but has no decision logged",
    "commit point": "The moment when the coordinator logs the decision, determining global outcome",
    "timeout": "Maximum wait duration before assuming failure",
    "message loss": "Network failure where sent message never arrives",
    "message delay": "Network issue causing message to arrive later than expected",
    "message reordering": "Network behavior where messages arrive in different order than sent",
    "duplicate message": "Same message delivered multiple times",
    "crash failure": "Process stops executing due to hardware/software fault",
    "partial failure": "Subset of system components fail while others continue operating",
    "asymmetric partition": "Network split where communication works in one direction but not the other",
    "log corruption": "Data corruption in persistent storage affecting log entries",
    "incomplete write": "Partial log entry written before crash",
    "CAP theorem": "Impossibility result about consistency, availability, partition-tolerance",
    "fault injection": "Programmatically inducing failures to test system behavior",
    "property-based testing": "Verifying invariants that must hold across all executions",
    "scenario-based testing": "Walking through specific execution sequences",
    "crash hook": "Callback registered at critical points that can terminate process",
    "log replay": "Process of reading log entries to reconstruct state",
    "virtual clock": "Test infrastructure allowing deterministic time control",
    "three-phase commit": "Extension of 2PC adding pre-commit phase to reduce blocking",
    "pre-commit phase": "Additional phase between prepare and commit establishing coordinator decision",
    "non-blocking recovery": "Property where participants can complete transaction without coordinator",
    "Paxos Commit": "Fault-tolerant coordination using replicated Paxos group instead of single coordinator",
    "pipelining": "Overlapping multiple transactions' prepare phases to increase parallelism",
    "read-only transaction": "Transaction with only read operations, can skip prepare/commit phases",
    "asynchronous acknowledgment": "Optimization where coordinator doesn't wait for ACKs before completing",
    "distributed tracing": "Observability technique tracking request flow across system boundaries",
    "trace span": "Individual operation recorded in distributed trace",
    "structured logging": "Logging format using key-value pairs for machine parsing",
    "health check": "Endpoint reporting component operational status",
    "metrics collection": "Gathering quantitative measurements of system behavior",
    "alerting": "Automated notifications when system metrics exceed thresholds",
    "snapshot isolation": "Consistency level where reads see consistent point-in-time snapshot",
    "multi-version concurrency control": "Technique maintaining multiple versions of data for concurrent access",
    "Raft": "Consensus protocol providing equivalent guarantees to Paxos with simpler design",
    "consensus": "Agreement protocol ensuring all nodes decide same value",
    "leader election": "Process of selecting single coordinator from replicated group",
    "split-brain": "Scenario where partitioned components make inconsistent decisions"
  }
}