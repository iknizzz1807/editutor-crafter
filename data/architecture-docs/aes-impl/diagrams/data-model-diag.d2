# Data model: State Matrix and Key Schedule
note: |md
  ## Data Model: State Matrix and Key Schedule
  
  Visual representation of the 4x4 State matrix (bytes) and the expanded key 
  schedule (array of words). Shows the relationship between the state and a 
  round key during AddRoundKey.
| {
  style.fill: "#16213e"
  style.font-color: "#e6edf3"
  style.bold: true
}

classes: {
  aes_component: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  array_cell: {
    style.fill: "#0f3460"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  highlight: {
    style.fill: "#2d3a52"
    style.stroke: "#3fb950"
    style.stroke-width: 3
    style.font-color: "#ffffff"
    style.bold: true
  }
}

state_matrix: State Matrix (4×4 bytes) {
  shape: class
  class: aes_component
  label: "State Matrix\n4×4 bytes (16 bytes total)"
  "+ Representation: byte[4][4]"
  "+ Order: Column-major"
  "+ Purpose: Holds block data during transformations"
  "+ Indexing: s[r][c] where r=row, c=column"
}

state_cells: {
  s00: "s₀₀ (byte)" { class: array_cell }
  s01: "s₀₁ (byte)" { class: array_cell }
  s02: "s₀₂ (byte)" { class: array_cell }
  s03: "s₀₃ (byte)" { class: array_cell }
  
  s10: "s₁₀ (byte)" { class: array_cell }
  s11: "s₁₁ (byte)" { class: array_cell }
  s12: "s₁₂ (byte)" { class: array_cell }
  s13: "s₁₃ (byte)" { class: array_cell }
  
  s20: "s₂₀ (byte)" { class: array_cell }
  s21: "s₂₁ (byte)" { class: array_cell }
  s22: "s₂₂ (byte)" { class: array_cell }
  s23: "s₂₃ (byte)" { class: array_cell }
  
  s30: "s₃₀ (byte)" { class: array_cell }
  s31: "s₃₁ (byte)" { class: array_cell }
  s32: "s₃₂ (byte)" { class: array_cell }
  s33: "s₃₃ (byte)" { class: array_cell }
}

state_matrix -> state_cells: contains

col0: {
  s00
  s10
  s20
  s30
  style.opacity: 0
}

col1: {
  s01
  s11
  s21
  s31
  style.opacity: 0
}

col2: {
  s02
  s12
  s22
  s32
  style.opacity: 0
}

col3: {
  s03
  s13
  s23
  s33
  style.opacity: 0
}


key_schedule: Key Schedule {
  shape: class
  class: aes_component
  label: "Expanded Key Schedule\nArray of Words (AES-128: 44 words)"
  "+ Representation: Word[Nb×(Nr+1)]"
  "+ AES-128: 44 words (176 bytes)"
  "+ AES-192: 52 words (208 bytes)"
  "+ AES-256: 60 words (240 bytes)"
  "+ Purpose: Provides round keys for each encryption round"
}

key_words: {
  w0: "w[0]: Word (4 bytes)" { class: array_cell }
  w1: "w[1]: Word (4 bytes)" { class: array_cell }
  w2: "w[2]: Word (4 bytes)" { class: array_cell }
  w3: "w[3]: Word (4 bytes)" { class: array_cell }
  ellipsis1: "..." { style.font-size: 20 }
  w40: "w[40]: Word (4 bytes)" { class: array_cell }
  w41: "w[41]: Word (4 bytes)" { class: array_cell }
  w42: "w[42]: Word (4 bytes)" { class: array_cell }
  w43: "w[43]: Word (4 bytes)" { class: array_cell }
}

key_schedule -> key_words: contains


round_key: Round Key (for Round 1) {
  shape: rectangle
  class: highlight
  label: "Round Key Extraction\n4 consecutive words = 16 bytes"
}

rk_start: "w[4]" { class: highlight }
rk_w1: "w[5]" { class: highlight }
rk_w2: "w[6]" { class: highlight }
rk_w3: "w[7]" { class: highlight }

round_key -> rk_start: starts at
rk_start -> rk_w1 -> rk_w2 -> rk_w3: "form round key"


add_round_key: AddRoundKey Operation {
  shape: rectangle
  class: aes_component
  style.font-color: "#3fb950"
  style.bold: true
  label: "AddRoundKey: State ⊕ RoundKey\n(XOR each byte)"
}

state_matrix -> add_round_key: input
round_key -> add_round_key: input

byte_mapping: Byte-to-Byte XOR {
  shape: text
  label: |md
    **Byte Mapping:**
    - s₀₀ ⊕ k₀₀
    - s₀₁ ⊕ k₀₁
    - ...
    - s₃₃ ⊕ k₃₃
    
    Each state byte XORed with corresponding round key byte
  |
  style.font-color: "#8b949e"
  style.italic: true
}

add_round_key -> byte_mapping: performs

state_matrix.near: top-left
key_schedule.near: top-right
add_round_key.near: center-left
round_key.near: center-right
byte_mapping.near: bottom-center