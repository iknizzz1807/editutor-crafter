{
  "types": {
    "ToolResultStatus": "Enum: SUCCESS, ERROR, TIMEOUT",
    "ToolResult": "fields: content str, status ToolResultStatus, error_message Optional[str], metadata Dict[str, Any]",
    "SubTaskStatus": "Enum: PENDING, EXECUTING, COMPLETED, FAILED, BLOCKED",
    "SubTask": "fields: id str, description str, expected_output Optional[str], tool_name Optional[str], tool_args Optional[Dict[str, Any]], dependencies List[str], status SubTaskStatus, result Optional[ToolResult]",
    "Task": "fields: id str, original_query str, goal str, subtasks List[SubTask], context Dict[str, Any]",
    "AgentState": "Enum: IDLE, PLANNING, EXECUTING, REPLANNING, FINISHED, ERROR",
    "MemoryEntry": "fields: id str, content str, timestamp datetime, metadata Dict[str, Any], embedding Optional[List[float]]",
    "Message": "fields: sender_id str, receiver_id str, message_type str, content Dict[str, Any], timestamp datetime, correlation_id Optional[str]",
    "Tool": "Interface with name, description, parameters_schema properties and execute method",
    "Plan": "fields: task_id str, subtask_dag Dict[str, List[str]], execution_order List[str]",
    "ReActLoopContext": "fields: subtask_description str, expected_output Optional[str], conversation_history List[str], iteration int, max_iterations int, state AgentState, previous_actions List[Tuple[str, Dict[str, Any]]]",
    "ParsingError": "Exception class for parsing failures",
    "Planner": "Interface with create_plan method",
    "DelegatedTask": "fields: task_id str, subtask_description str, assigned_agent str, status str, result Optional[Dict], deadline Optional[float], dependencies List[str]",
    "Subscription": "fields: callback Callable[[Message], None], agent_id str",
    "MessageBus": "fields: _topics Dict[str, asyncio.Queue], _subscriptions Dict[str, Set[Subscription]], _lock asyncio.Lock",
    "OrchestratorAgent": "extends BaseAgent, fields: message_bus MessageBus, available_roles Dict, delegated_tasks Dict[str, DelegatedTask], shared_context Dict[str, Any], orchestration_pattern HierarchicalOrchestrator",
    "WorkerAgent": "extends BaseAgent, fields: role str, message_bus MessageBus, current_tasks Set[str]",
    "ExecutionFlow": "fields: task_id str, current_state AgentState, active_subtask_id Optional[str], completed_subtasks set, shared_context Dict[str, Any], flow_start_time float",
    "FlowController": "fields: agent BaseAgent, planner Planner, memory MemorySystem, tool_registry ToolRegistry, active_flows Dict[str, ExecutionFlow]",
    "ErrorSeverity": "Enum: LOW, MEDIUM, HIGH, CRITICAL",
    "ErrorContext": "fields: component str, error_type str, severity ErrorSeverity, timestamp datetime, details Dict[str, Any], recovery_attempts int, correlation_id Optional[str]",
    "RecoveryOrchestrator": "fields: max_recovery_attempts int, error_history List[ErrorContext], recovery_handlers Dict[str, Callable], _lock asyncio.Lock",
    "ToolExecutionEngine": "fields: tool_registry ToolRegistry, default_timeout float, max_retries int, error_handler ToolErrorHandler, circuit_breakers Dict[str, CircuitBreaker]",
    "MockLLM": "fields: response_sequence List[str], call_count int, history List",
    "InMemoryVectorStore": "fields: embedding_dim int, memories Dict[str, Dict[str, Any]], embeddings Dict[str, np.ndarray]",
    "StructuredLogger": "fields: logger logging.Logger, correlation_id str",
    "JSONFormatter": "fields: (inherits from logging.Formatter)",
    "PromptInspector": "fields: save_dir Path",
    "HumanResponseStatus": "Enum: PENDING, APPROVED, REJECTED, TIMEOUT, CANCELLED",
    "HumanRequest": "fields: request_id str, task_id str, subtask_id Optional[str], question str, context Dict[str, Any], options Optional[Dict[str, Any]], created_at datetime, timeout_seconds float",
    "HumanInteractionTool": "Base class for tools that require human interaction, extends Tool",
    "ToolNode": "fields: node_id str, tool_name str, tool_arguments Dict[str, Any], output_mapping Dict[str, str]",
    "CompositeTool": "fields: name str, description str, graph nx.DiGraph, nodes Dict[str, ToolNode], parameters_schema Dict[str, Any]",
    "InterceptionTrigger": "Enum: BEFORE_TOOL_EXECUTION, AFTER_SUBTASK_COMPLETE, ON_ERROR, ON_SENSITIVE_OPERATION, ON_PLAN_CHANGE",
    "InterceptionRule": "fields: trigger InterceptionTrigger, condition Callable[[Dict[str, Any]], bool], human_tool_name str, tool_arguments Dict[str, Any], priority int"
  },
  "methods": {
    "Agent.run_task(user_query: str) -> str": "Primary public method to execute a user's task",
    "Agent._execute_subtask(subtask: SubTask) -> ToolResult": "Internal method to run the ReAct loop for a single subtask",
    "SubTask.with_status(new_status: SubTaskStatus) -> SubTask": "Functional update returning new SubTask with updated status",
    "SubTask.with_result(result: ToolResult) -> SubTask": "Functional update returning new SubTask with updated result",
    "SubTask.is_ready() -> bool": "Check if subtask can execute (dependencies satisfied)",
    "Task.get_subtask(subtask_id: str) -> Optional[SubTask]": "Retrieve a subtask by ID",
    "Task.update_subtask(updated_subtask: SubTask) -> Task": "Functional update returning new Task with subtask updated",
    "ToolResult.success(content: str, metadata: Optional[Dict[str, Any]]) -> ToolResult": "Factory method for successful tool result",
    "ToolResult.error(error_msg: str, metadata: Optional[Dict[str, Any]]) -> ToolResult": "Factory method for error tool result",
    "ToolResult.timeout(timeout_seconds: float, metadata: Optional[Dict[str, Any]]) -> ToolResult": "Factory method for timeout tool result",
    "ToolRegistry.register_tool(tool: Tool) -> None": "Adds a tool instance to the registry",
    "ToolRegistry.get_tool(name: str) -> Optional[Tool]": "Retrieves a tool by its unique name",
    "ToolRegistry.list_tools() -> List[Tool]": "Returns a list of all registered tools",
    "ToolExecutionEngine.execute_tool_call(tool_name: str, arguments: Dict[str, Any], timeout_seconds: Optional[float]) -> ToolResult": "Main entry point: executes a tool call safely",
    "ReActAgent._execute_subtask(subtask: SubTask) -> ToolResult": "Primary ReAct loop executor for a single subtask",
    "ReActAgent._format_react_prompt(context: ReActLoopContext, available_tools: List[Tool], external_context: str) -> str": "Formats the prompt for the LLM in each cycle",
    "ReActAgent._run_single_cycle(context: ReActLoopContext, available_tools: List[Tool], external_context: str) -> Tuple[AgentState, ReActLoopContext]": "Executes one Think-Act-Observe cycle",
    "parse_llm_action_response(response_text: str) -> Tuple[Optional[str], Optional[Dict[str, Any]]]": "Parses LLM response for Action or Final Answer",
    "extract_json_from_text(text: str) -> Optional[Dict[str, Any]]": "Finds first valid JSON object in text with fallback",
    "Agent._execute_subtask(subtask: SubTask, context: Dict[str, Any]) -> ToolResult": "Internal method to run the ReAct loop for a single subtask",
    "SubTask.is_ready(completed_task_ids: set) -> bool": "Check if subtask can execute (dependencies satisfied)",
    "Planner.create_plan(goal: str, available_tools: List[Tool], initial_context: Optional[Dict]) -> Task": "Decomposes goal into a Task with subtasks",
    "EpisodicMemory.append(role, content, metadata)": "Add message to history",
    "EpisodicMemory.get_messages(limit, since)": "Retrieve messages",
    "EpisodicMemory.get_recent(max_tokens)": "Get recent messages within token limit",
    "EpisodicMemory.clear()": "Clear all history",
    "WorkingMemory.get(key, default)": "Retrieve value",
    "WorkingMemory.set(key, value)": "Store value",
    "WorkingMemory.update(mapping)": "Batch update",
    "WorkingMemory.clear()": "Clear all key-values",
    "WorkingMemory.to_dict()": "Return copy as dict",
    "LongTermMemory.store(content, metadata)": "Store content with embedding",
    "LongTermMemory.query(query_text, limit, threshold)": "Retrieve relevant memories",
    "LongTermMemory.delete(memory_id)": "Delete memory by ID",
    "LongTermMemory.summarize_recent(max_memories)": "Summarize recent entries",
    "MemoryRetriever.retrieve_context(current_query, token_budget)": "Retrieve and format context from all layers",
    "Message.to_dict() -> Dict[str, Any]": "Convert message to dictionary for serialization",
    "Message.from_dict(data: Dict[str, Any]) -> Message": "Create message from dictionary",
    "MessageBus.publish(message: Message) -> None": "Publish a message to the appropriate topic(s)",
    "MessageBus.subscribe(agent_id: str, callback: Callable[[Message], None], topics: Optional[list[str]]) -> None": "Subscribe an agent to message topics",
    "MessageBus.unsubscribe(agent_id: str) -> None": "Remove all subscriptions for an agent",
    "MessageBus.start_message_processor(agent_id: str) -> None": "Start processing messages for an agent (run in background task)",
    "OrchestratorAgent.run_task(user_query: str) -> str": "Primary public method to execute a user's task with multi-agent collaboration",
    "OrchestratorAgent._handle_task_response(message: Message) -> None": "Process a task response from a worker agent",
    "OrchestratorAgent._delegate_subtask(subtask_description: str, required_tools: List[str], context: Dict) -> str": "Delegate a subtask to the most suitable agent",
    "OrchestratorAgent._resolve_conflicts(conflicting_results: List[Dict]) -> Dict": "Resolve contradictory results from multiple agents",
    "WorkerAgent._handle_task_request(message: Message) -> None": "Process incoming task request from orchestrator",
    "WorkerAgent.request_help(task_id: str, issue: str, target_role: str) -> None": "Request assistance from another agent with specific expertise",
    "FlowController.execute_task(user_query: str) -> str": "Main entry point for single-agent task execution",
    "FlowController.execute_multiagent_task(user_query: str, worker_agents: List[BaseAgent]) -> str": "Entry point for multi-agent collaborative execution",
    "ExecutionFlow.mark_subtask_complete(subtask_id: str) -> None": "Update flow state when a subtask completes",
    "ExecutionFlow.get_next_ready_subtask(task) -> Optional[str]": "Find the next subtask that has all dependencies satisfied",
    "RecoveryOrchestrator.register_handler(error_pattern, handler)": "Register a recovery handler for specific error patterns",
    "RecoveryOrchestrator.handle_error(error_context) -> Dict[str, Any]": "Main entry point for error recovery",
    "ToolExecutionEngine._timeout_context(timeout)": "Context manager for timeout control",
    "ToolExecutionEngine._validate_arguments(tool, arguments) -> ValidationResult": "Validate arguments against tool's JSON schema",
    "ToolExecutionEngine._update_circuit_breaker(tool_name, success)": "Update circuit breaker state based on execution outcome",
    "ToolExecutionEngine._is_circuit_open(tool_name) -> bool": "Check if circuit breaker is in OPEN state for given tool",
    "ReActAgent._run_single_cycle(context, available_tools, external_context) -> Tuple[AgentState, ReActLoopContext]": "Executes one Think-Act-Observe cycle with error recovery",
    "MockLLM.generate(prompt: str, **kwargs) -> str": "Mock LLM generation that returns predetermined responses",
    "MockLLM.reset()": "Reset call counter for test reuse",
    "create_mocked_llm_response_chain(*steps: Dict[str, Any]) -> List[str]": "Helper to create a sequence of LLM responses for testing ReAct loops",
    "InMemoryVectorStore.store(id: str, content: str, metadata: Dict[str, Any], embedding: Optional[np.ndarray]) -> None": "Store memory with optional embedding",
    "InMemoryVectorStore.query(query_embedding: np.ndarray, limit: int, threshold: float) -> List[Dict[str, Any]]": "Return memories sorted by cosine similarity to query",
    "StructuredLogger.log_cycle(cycle, state, prompt_preview, llm_response, parsed_action, tool_result, context)": "Log a complete ReAct cycle",
    "StructuredLogger.log_error(error_type, message, component, details)": "Log an error with structured context",
    "PromptInspector.save_prompt(prompt, context, prefix)": "Save a prompt to file with metadata",
    "PromptInspector.analyze_prompt(prompt)": "Analyze prompt structure and composition",
    "log_react_cycle(func)": "Decorator to log each ReAct cycle with full context",
    "HumanInteractionTool.execute(**kwargs) returns ToolResult": "Base implementation for human interaction tools",
    "HumanInteractionTool._await_human_response(request) returns Optional[Dict[str, Any]]": "Send request to human and await response with timeout",
    "HumanInteractionTool.provide_response(request_id, response_data) returns bool": "Called by external system to provide human response",
    "CompositeTool.add_node(node) returns None": "Add a tool node to the composite tool graph",
    "CompositeTool.add_edge(from_node_id, to_node_id) returns None": "Add dependency edge between two tool nodes",
    "CompositeTool.validate(tool_registry) returns List[str]": "Validate the composite tool structure",
    "HumanInTheLoopFlowController.add_interception_rule(rule) returns None": "Add a rule for human interception",
    "HumanInTheLoopFlowController.register_human_tool(tool_name, tool) returns None": "Register a human interaction tool",
    "HumanInTheLoopFlowController._check_and_intercept(trigger, context) returns bool": "Check rules for given trigger and intercept if any match"
  },
  "constants": {
    "AgentState": "Enum: IDLE, THINKING, ACTING, OBSERVING, FINISHED, ERROR",
    "AgentState.IDLE": "Initial state",
    "AgentState.PLANNING": "Creating a plan",
    "AgentState.EXECUTING": "Executing subtasks",
    "AgentState.REPLANNING": "Generating a new plan due to failure",
    "AgentState.FINISHED": "Task completed",
    "AgentState.ERROR": "Task failed irrecoverably",
    "HumanResponseStatus.PENDING": "Request sent but no response yet",
    "HumanResponseStatus.APPROVED": "Human approved the request",
    "HumanResponseStatus.REJECTED": "Human rejected the request",
    "HumanResponseStatus.TIMEOUT": "Request timed out waiting for human response",
    "HumanResponseStatus.CANCELLED": "Request was cancelled before completion",
    "InterceptionTrigger.BEFORE_TOOL_EXECUTION": "Intercept before any tool execution begins",
    "InterceptionTrigger.AFTER_SUBTASK_COMPLETE": "Intercept after a subtask completes",
    "InterceptionTrigger.ON_ERROR": "Intercept when an error occurs",
    "InterceptionTrigger.ON_SENSITIVE_OPERATION": "Intercept when sensitive operation is attempted",
    "InterceptionTrigger.ON_PLAN_CHANGE": "Intercept when the plan changes significantly"
  },
  "terms": {
    "AI Executive": "Mental model for the agent: an entity that plans, delegates, and manages",
    "Semantic Gap": "The disconnect between LLM's natural language reasoning and the structured world of software tools",
    "ReAct Loop": "Reasoning-Acting loop: Think -> Act -> Observe cycle",
    "DAG": "Directed Acyclic Graph, used to model task dependencies",
    "functional update": "Creating new instance with modified fields instead of mutating existing object",
    "whole-part relationship": "Composition pattern where the whole (Task) owns its parts (SubTasks)",
    "bag of properties": "Pattern using dictionary for extensible metadata storage",
    "Service Locator": "A design pattern used to encapsulate the processes involved in obtaining a service",
    "OODA Loop": "Observe-Orient-Decide-Act cycle for adaptive decision-making",
    "JSON-in-Text Parsing": "Extracting JSON objects embedded in free-form text",
    "Iteration Limit": "Maximum number of ReAct cycles before forced termination",
    "Work Breakdown Structure (WBS)": "Hierarchical decomposition of a project into smaller components",
    "topological sort": "Linear ordering of a DAG's vertices such that for every directed edge u -> v, u comes before v",
    "adjacency list": "A representation of a graph as a map from nodes to lists of their neighbors",
    "Episodic Memory": "Linear sequence of dialogue turns, like an open notebook",
    "Working Memory": "Task-scoped key-value state, like a whiteboard",
    "Long-Term Memory": "Semantic memory with vector search, like an indexed filing cabinet",
    "Hybrid Sliding Window with Summarization": "Context management strategy combining recent verbatim turns with summarized older segments",
    "Vector Embedding": "Dense numerical representation of text for semantic similarity",
    "Orchestrator Agent": "Coordinator agent that manages multiple worker agents, decomposes tasks, and synthesizes results",
    "Worker Agent": "Specialized agent with a specific role and toolset that executes delegated subtasks",
    "Message Bus": "Publish-subscribe system for asynchronous communication between agents",
    "Topic-Based Routing": "Message routing where agents subscribe to topics and receive messages published to those topics",
    "Shared Context": "Common workspace where agents can access relevant information and intermediate outputs",
    "Delegation Loop": "Infinite cycle where agents keep delegating the same task back and forth",
    "Conflict Resolution": "Process of reconciling contradictory results from multiple agents using defined merge strategies",
    "Hierarchical Pattern": "Orchestration pattern with a single manager and multiple workers in a tree structure",
    "Broadcast Pattern": "Orchestration pattern where agents communicate directly with all others",
    "Market-Based Pattern": "Orchestration pattern using auction mechanisms for task allocation",
    "blackboard architecture": "Architecture pattern where multiple agents read and write to a common workspace (blackboard)",
    "request-scoped context": "Context that is associated with a specific request/flow and follows through async execution",
    "graded response strategy": "Error recovery approach: first attempt automatic recovery, then escalate to component-level adjustments, then system-level intervention",
    "circuit breaker pattern": "Design pattern that prevents repeated calls to a failing service, allowing it time to recover",
    "exponential backoff with jitter": "Retry strategy where wait time doubles each attempt with random variation to prevent synchronized retries",
    "error propagation chain": "How errors move through components and trigger coordinated recovery actions",
    "validation result": "Outcome of parameter validation including whether valid and any error messages",
    "Testing Pyramid for Agent Systems": "Three-layer testing strategy: unit tests (components), integration tests (interactions), end-to-end tests (full system)",
    "Verification Checkpoints": "Concrete test commands and expected outputs that serve as objective completion criteria for each milestone",
    "Testable Seams": "Interfaces where real components can be substituted with mocks during testing",
    "Deterministic Tests": "Tests that produce identical results on every run, without external dependencies or randomness",
    "Mock LLM": "Simulated LLM that returns predetermined responses for testing agent reasoning loops",
    "E2E Tests": "End-to-end tests that run the complete system with minimal mocks to validate real task completion",
    "Token Budget Management": "Enforcing context length limits through truncation, summarization, or selective retrieval",
    "Role-Based Delegation": "Task assignment strategy where subtasks are routed to agents based on their advertised capabilities",
    "Flaky Tests": "Tests that sometimes pass and sometimes fail due to timing, randomness, or external dependencies",
    "Coverage Reports": "Analysis showing which lines of code are executed during test runs, helping identify untested paths",
    "correlation ID": "Unique identifier passed through execution flow for tracing",
    "prompt inspection": "Analyzing the exact prompt sent to the LLM",
    "structured logging": "Logging in machine-readable format (JSON) with consistent schema",
    "DAG visualization": "Creating visual representation of task dependencies",
    "mock LLM": "Simulated LLM returning predetermined responses for testing",
    "event loop debugging": "Diagnosing issues in async Python code",
    "Flight Control Center": "Mental model for human-in-the-loop: humans as mission control overseeing autonomous agents",
    "Function Composition": "Mental model for tool chaining: mathematical function composition f(g(x))",
    "Professional Apprenticeship": "Mental model for learning from experience: agent learns from successes and mistakes",
    "Air Traffic Control Radar Display": "Mental model for Web UI: real-time visualization of multiple agent activities",
    "Swiss Army Knife with Specialized Attachments": "Mental model for multi-modal tools: base system with interchangeable media handlers",
    "Macro Recorder": "Mental model for scripting: recording successful executions as reusable templates",
    "Conference Room Whiteboard Session": "Mental model for tool sharing: specialists sharing expertise in collaborative setting",
    "Black Box Flight Recorder + Investigative Journalist": "Mental model for explainability: comprehensive data capture plus narrative reconstruction"
  }
}