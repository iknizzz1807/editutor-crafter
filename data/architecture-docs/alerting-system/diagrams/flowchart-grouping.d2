title: Flowchart: Alert Grouping Logic

classes: {
  process: {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: false
  }
  decision: {
    shape: diamond
    style.fill: "#0f3460"
    style.stroke: "#e17055"
    style.font-color: "#e6edf3"
    style.bold: false
  }
  start_end: {
    shape: oval
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  timer: {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
    style.bold: false
    style.stroke-dash: 2
  }
}

start: "New alert received" {
  class: start_end
}

calculate_key: "Calculate group key from alert labels (e.g., {alertname, cluster, severity})" {
  class: process
}

check_existing: "Does group with this key already exist?" {
  class: decision
}

create_group: "Create new alert group with initial alert" {
  class: process
}

add_to_group: "Add alert to existing group" {
  class: process
}

start_group_wait: "Start or restart group_wait timer\n(short delay for initial batching)" {
  class: timer
}

start_group_interval: "Start or restart group_interval timer\n(longer delay for subsequent updates)" {
  class: timer
}

check_send_now: "Should notification be sent now?" {
  class: decision
}

send_notification: "Send notification for entire group" {
  class: process
  style.stroke: "#e17055"
  style.bold: true
}

end: "Alert processed (waiting for timers or next alert)" {
  class: start_end
}

# Flow connections
start -> calculate_key
calculate_key -> check_existing

check_existing -> create_group: No
check_existing -> add_to_group: Yes

create_group -> start_group_wait
add_to_group -> start_group_wait

start_group_wait -> start_group_interval
start_group_interval -> check_send_now

check_send_now -> send_notification: Yes
check_send_now -> end: No

send_notification -> end

# Explanation notes
note_group_key: |md
  **Group Key Calculation:**
  Extracted from alert labels using grouping rules.
  Example: `{alertname="HighCPU", cluster="prod", severity="critical"}`
| {
  shape: page
  style.fill: "#1a1a2e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
  near: top-right
}

note_timers: |md
  **Timers:**
  - **group_wait:** Short delay (e.g., 30s) to batch initial alerts
  - **group_interval:** Longer period (e.g., 5m) between update notifications
  Timers restart on new alerts to prevent notification spam.
| {
  shape: page
  style.fill: "#1a1a2e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
  near: center-right
}

note_send_decision: |md
  **Send Decision Logic:**
  Send if:
  1. First alert in group AND group_wait expired
  2. Group_interval expired since last notification
  3. Critical state change in group
| {
  shape: page
  style.fill: "#1a1a2e"
  style.stroke: "#8b949e"
  style.font-color: "#e6edf3"
  near: bottom-right
}