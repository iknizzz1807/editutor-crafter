{
  "title": "APM Tracing System: Design Document",
  "overview": "We are building an Application Performance Monitoring (APM) system that tracks requests as they flow through a distributed application, creating detailed traces. The key architectural challenge is efficiently collecting, storing, and analyzing massive volumes of trace data while preserving the most valuable insights for debugging and performance optimization.",
  "sections": [
    {
      "id": "context-problem",
      "title": "1. Context and Problem Statement",
      "summary": "Explains the 'why' behind APM and distributed tracing, using an analogy to understand the core problem of observability in microservices.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "Mental Model: The Distributed Detective",
          "summary": "Introduces tracing as following a 'request's journey' through a complex system, akin to a detective following clues."
        },
        {
          "id": "problem-detail",
          "title": "The Observability Challenge in Microservices",
          "summary": "Describes the concrete problems of debugging and performance analysis when a request hops across dozens of services, databases, and queues."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches and Trade-offs",
          "summary": "Compares logging, metrics, and tracing, showing where each falls short and why a dedicated tracing system is needed."
        }
      ]
    },
    {
      "id": "goals-nongoals",
      "title": "2. Goals and Non-Goals",
      "summary": "Defines the explicit scope of what this system will and will not do, setting clear boundaries for the project.",
      "subsections": [
        {
          "id": "goals-list",
          "title": "Goals (What We Must Do)",
          "summary": "Lists functional requirements like trace collection, service map generation, and adaptive sampling."
        },
        {
          "id": "nongoals-list",
          "title": "Non-Goals (What We Explicitly Won't Do)",
          "summary": "Lists out-of-scope items like real-user monitoring (RUM), log aggregation, or infrastructure metrics."
        }
      ]
    },
    {
      "id": "high-level-arch",
      "title": "3. High-Level Architecture",
      "summary": "Presents the bird's-eye view of the system components, their responsibilities, and how data flows between them.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview and Responsibilities",
          "summary": "Describes the Agent, Collector, Storage Backend, Query Service, and Web UI components."
        },
        {
          "id": "file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Provides a suggested Go project layout to organize the codebase logically."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core data structures: Span, Trace, Service, and the relationships between them.",
      "subsections": [
        {
          "id": "core-types",
          "title": "Core Types: Span, Trace, and Service",
          "summary": "Detailed tables describing the fields and semantics of the fundamental data units."
        },
        {
          "id": "relationships-indexes",
          "title": "Relationships and Storage Indexing Strategy",
          "summary": "Explains how spans link to form traces and what secondary indexes are needed for efficient querying."
        }
      ]
    },
    {
      "id": "component-trace-collection",
      "title": "5. Component Design: Trace Collection (Milestone 1)",
      "summary": "Designs the system's front door: the component that receives, validates, buffers, and stores incoming spans.",
      "subsections": [
        {
          "id": "collector-mental-model",
          "title": "Mental Model: The Package Sorting Hub",
          "summary": "Analogy comparing the collector to a logistics hub that receives packages (spans), sorts them by destination (trace ID), and stores them."
        },
        {
          "id": "collector-interface",
          "title": "Collector Interface and API",
          "summary": "Defines the HTTP/gRPC endpoints, their request/response formats, and expected behaviors."
        },
        {
          "id": "collector-behavior",
          "title": "Internal Behavior: Ingestion Pipeline",
          "summary": "Step-by-step algorithm for receiving a span, parsing it, buffering, and finalizing trace assembly."
        },
        {
          "id": "collector-adr-buffering",
          "title": "ADR: Buffering Strategy for Late-Arriving Spans",
          "summary": "Decision record comparing in-memory buffers vs. Write-Ahead Logs for handling out-of-order span arrival."
        },
        {
          "id": "collector-pitfalls",
          "title": "Common Pitfalls in Trace Collection",
          "summary": "Covers unbounded memory growth, clock skew, and incorrect parent-child linking."
        },
        {
          "id": "collector-impl-guide",
          "title": "Implementation Guidance for Trace Collection",
          "summary": "Go-specific tech choices, starter code for HTTP/gRPC servers, and skeleton for the core ingestion logic."
        }
      ]
    },
    {
      "id": "component-service-map",
      "title": "6. Component Design: Service Map (Milestone 2)",
      "summary": "Designs the component that analyzes trace data to build and visualize a dynamic graph of service dependencies.",
      "subsections": [
        {
          "id": "servicemap-mental-model",
          "title": "Mental Model: The Social Network of Services",
          "summary": "Analogy comparing service calls to friendships; the service map builds the 'friend graph' by observing interactions."
        },
        {
          "id": "servicemap-algorithm",
          "title": "Algorithm: Building the Graph from Spans",
          "summary": "Step-by-step process to extract caller-callee edges, aggregate metrics (latency, errors), and detect topology changes."
        },
        {
          "id": "servicemap-adr-graph-db",
          "title": "ADR: Graph Storage - Materialized vs. On-Demand",
          "summary": "Decision record comparing pre-computing and storing the graph vs. computing it live from span data."
        },
        {
          "id": "servicemap-pitfalls",
          "title": "Common Pitfalls in Service Map Construction",
          "summary": "Covers misattributing async calls, high cardinality from operation names, and detecting cyclic dependencies."
        },
        {
          "id": "servicemap-impl-guide",
          "title": "Implementation Guidance for Service Map",
          "summary": "Libraries for graph processing in Go, skeleton for the dependency extraction logic, and hints for real-time updates."
        }
      ]
    },
    {
      "id": "component-trace-sampling",
      "title": "7. Component Design: Trace Sampling (Milestone 3)",
      "summary": "Designs the intelligent filtering mechanism to reduce data volume while keeping critical traces for debugging.",
      "subsections": [
        {
          "id": "sampling-mental-model",
          "title": "Mental Model: The Library Archivist",
          "summary": "Analogy comparing sampling to an archivist who can't keep every book but must preserve rare, important, or representative ones."
        },
        {
          "id": "sampling-strategies",
          "title": "Head-Based vs. Tail-Based Sampling",
          "summary": "Detailed explanation of the two strategies, their trade-offs, and where each is applied in the pipeline."
        },
        {
          "id": "sampling-adr-adaptive",
          "title": "ADR: Adaptive Sampling Algorithm",
          "summary": "Decision record comparing fixed-rate, rate-limiting, and feedback-controlled adaptive sampling."
        },
        {
          "id": "sampling-pitfalls",
          "title": "Common Pitfalls in Sampling",
          "summary": "Covers sampling bias, inconsistent decisions for the same trace, and adaptive algorithm oscillation."
        },
        {
          "id": "sampling-impl-guide",
          "title": "Implementation Guidance for Trace Sampling",
          "summary": "Starter code for a consistent hash-based sampler and skeleton for tail-based sampling evaluation logic."
        }
      ]
    },
    {
      "id": "component-analytics",
      "title": "8. Component Design: Performance Analytics & Anomaly Detection (Milestone 4)",
      "summary": "Designs the analytics engine that computes percentiles, establishes baselines, and flags performance anomalies.",
      "subsections": [
        {
          "id": "analytics-mental-model",
          "title": "Mental Model: The Weather Forecaster for Performance",
          "summary": "Analogy comparing anomaly detection to a weather forecaster who knows normal patterns and spots unusual 'storms'."
        },
        {
          "id": "analytics-algorithms",
          "title": "Algorithms: Percentile Calculation and Anomaly Detection",
          "summary": "Explains the t-digest algorithm for streaming percentiles and statistical methods (z-score, moving average) for anomalies."
        },
        {
          "id": "analytics-adr-storage",
          "title": "ADR: Time-Series Storage for Aggregates",
          "summary": "Decision record comparing rolling in-memory windows vs. external time-series databases for storing historical metrics."
        },
        {
          "id": "analytics-pitfalls",
          "title": "Common Pitfalls in Analytics",
          "summary": "Covers the 'percentile of percentiles' fallacy, false positives during deployments, and baseline drift over time."
        },
        {
          "id": "analytics-impl-guide",
          "title": "Implementation Guidance for Analytics",
          "summary": "Go libraries for t-digest, skeleton for the percentile aggregator and anomaly detector components."
        }
      ]
    },
    {
      "id": "component-sdk",
      "title": "9. Component Design: APM SDK & Auto-Instrumentation (Milestone 5)",
      "summary": "Designs the client-side library that automatically instruments application code to generate and propagate traces.",
      "subsections": [
        {
          "id": "sdk-mental-model",
          "title": "Mental Model: The Invisible Flight Recorder",
          "summary": "Analogy comparing the SDK to a plane's black box, automatically recording critical execution data without pilot intervention."
        },
        {
          "id": "sdk-instrumentation",
          "title": "Instrumentation Techniques: Monkey Patching and Middleware",
          "summary": "Explains how to safely intercept HTTP, database, and framework calls to create spans and propagate context."
        },
        {
          "id": "sdk-adr-context-prop",
          "title": "ADR: Context Propagation Mechanism",
          "summary": "Decision record comparing thread-local storage, explicit parameter passing, and language-specific context objects (Go's `context.Context`)."
        },
        {
          "id": "sdk-pitfalls",
          "title": "Common Pitfalls in SDK Development",
          "summary": "Covers performance overhead, context loss in async/goroutine code, and safe monkey-patching that doesn't break host applications."
        },
        {
          "id": "sdk-impl-guide",
          "title": "Implementation Guidance for the APM SDK",
          "summary": "Go-specific patterns for middleware and `context.Context` propagation, skeleton code for HTTP client and database wrappers."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "10. Interactions and Data Flow",
      "summary": "Traces the journey of a single request through the entire system, from instrumentation to visualization.",
      "subsections": [
        {
          "id": "sequence-trace-lifecycle",
          "title": "Sequence: The Lifecycle of a Trace",
          "summary": "Step-by-step walkthrough of a trace being created, sampled, collected, analyzed, and queried."
        },
        {
          "id": "message-formats",
          "title": "Key Message and Wire Formats",
          "summary": "Tables describing the OpenTelemetry protobuf/JSON format for spans and internal API messages."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "11. Error Handling and Edge Cases",
      "summary": "Describes how the system detects and recovers from failures in its own components and from malformed input.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "Failure Modes and Recovery Strategies",
          "summary": "Covers collector overload, storage unavailability, network partitions, and corrupt span data."
        },
        {
          "id": "backpressure-mechanisms",
          "title": "Backpressure and Degraded Modes",
          "summary": "Explains how the system sheds load (e.g., aggressive sampling) when under extreme pressure to protect itself."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "12. Testing Strategy",
      "summary": "Outlines how to verify the correctness, performance, and resilience of the APM system.",
      "subsections": [
        {
          "id": "testing-approaches",
          "title": "Testing Approaches: Unit, Integration, and Load",
          "summary": "Describes what to test at each level, including property-based tests for trace assembly and chaos testing for resilience."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints and Verification",
          "summary": "For each milestone, provides concrete steps to verify functionality (e.g., 'Send 1000 spans, confirm all are stored and linked')."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "13. Debugging Guide",
      "summary": "A practical manual for diagnosing and fixing common issues encountered while building and running the system.",
      "subsections": [
        {
          "id": "symptom-cause-fix",
          "title": "Common Bugs: Symptom \u2192 Cause \u2192 Fix",
          "summary": "Table listing issues like 'Spans are not linked', 'Service map is empty', or 'High memory usage', with diagnosis steps and solutions."
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques and Tools",
          "summary": "Advice on adding strategic logging, using Go's pprof for profiling, and simulating production traffic for testing."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "14. Future Extensions",
      "summary": "Ideas for how this system could be enhanced, showing the extensibility of the current design.",
      "subsections": [
        {
          "id": "extension-ideas",
          "title": "Potential Enhancements",
          "summary": "Lists ideas like continuous profiling integration, AI-powered root cause analysis, and support for eBPF-based instrumentation."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "15. Glossary",
      "summary": "Definitions of key terms used throughout the document.",
      "subsections": [
        {
          "id": "terms-table",
          "title": "Terminology Reference",
          "summary": "Table of terms like Span, Trace, Sampling, Percentile (p95), and OpenTelemetry."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-comp-diagram",
      "title": "APM System Component Diagram",
      "description": "Shows all major components (Agent, Collector, Storage, Query Service, Web UI) and the data flow between them. Include arrows for span ingestion, trace queries, and service map updates.",
      "type": "component",
      "relevant_sections": [
        "high-level-arch",
        "interactions-data-flow"
      ]
    },
    {
      "id": "data-model-diagram",
      "title": "Data Model: Span and Trace Relationships",
      "description": "A class diagram showing the Span type with its fields (ID, TraceID, ParentID, etc.) and how multiple Spans aggregate into a Trace. Show the Service as another entity linked to Spans.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "ingestion-sequence",
      "title": "Sequence: Trace Ingestion and Processing",
      "description": "A sequence diagram showing: 1. Application (via SDK) sends a span to Collector. 2. Collector validates and buffers. 3. Sampling decision is made. 4. Span is written to storage. 5. Trace assembly service is notified.",
      "type": "sequence",
      "relevant_sections": [
        "component-trace-collection",
        "interactions-data-flow"
      ]
    },
    {
      "id": "servicemap-flowchart",
      "title": "Flowchart: Service Map Construction",
      "description": "A flowchart illustrating the process: Start with raw spans \u2192 Group by trace \u2192 Extract service call edges \u2192 Aggregate metrics (count, error rate, latency) per edge \u2192 Update in-memory graph \u2192 Render visualization.",
      "type": "flowchart",
      "relevant_sections": [
        "component-service-map"
      ]
    },
    {
      "id": "sampling-decision-flow",
      "title": "Flowchart: Head-Based and Tail-Based Sampling Decisions",
      "description": "A flowchart with two main paths. Head-based: Incoming trace ID \u2192 Hash \u2192 Compare to configured rate \u2192 Keep/Drop. Tail-based: Completed trace \u2192 Check for errors/high latency \u2192 Override drop decision if interesting.",
      "type": "flowchart",
      "relevant_sections": [
        "component-trace-sampling"
      ]
    },
    {
      "id": "analytics-sequence",
      "title": "Sequence: Performance Analytics and Alerting",
      "description": "Sequence diagram: 1. Aggregator receives span with latency. 2. Updates t-digest for its service/operation. 3. Calculates current p95. 4. Compares to historical baseline from TSDB. 5. If anomaly detected, triggers alert.",
      "type": "sequence",
      "relevant_sections": [
        "component-analytics"
      ]
    },
    {
      "id": "sdk-instrumentation-comp",
      "title": "Component Diagram: SDK Auto-Instrumentation",
      "description": "Shows the application process with the SDK injected. Illustrate wrappers/middleware around HTTP Client, Database Driver, and Web Framework (Gin/Express), all reporting to a central Tracer which sends spans to the Collector.",
      "type": "component",
      "relevant_sections": [
        "component-sdk"
      ]
    }
  ]
}