{
  "title": "AST Builder (Parser): Design Document",
  "overview": "This system transforms a sequence of tokens into an Abstract Syntax Tree (AST), capturing the grammatical structure of source code while preserving semantic meaning. The key architectural challenge is designing a parser that correctly handles operator precedence, statement nesting, and error recovery, turning flat token streams into hierarchical tree representations that can be evaluated or compiled.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains why parsing is difficult, comparing different parsing approaches, and establishing the mental model of turning a flat sequence into a structured tree.",
      "subsections": [
        {
          "id": "parsing-analogy",
          "title": "Mental Model: From Shopping List to Recipe Book"
        },
        {
          "id": "problem-details",
          "title": "Why Parsing is Challenging"
        },
        {
          "id": "approaches-comparison",
          "title": "Parsing Approaches Comparison"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what the parser must accomplish and what functionality is explicitly out of scope for this educational implementation.",
      "subsections": [
        {
          "id": "goals",
          "title": "Goals"
        },
        {
          "id": "non-goals",
          "title": "Non-Goals"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Overview of system components, their responsibilities, and how they connect, including recommended file structure for organizing the codebase.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview"
        },
        {
          "id": "file-structure",
          "title": "Recommended File/Module Structure"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines AST node types, token representations, and their relationships, providing the foundation for tree construction.",
      "subsections": [
        {
          "id": "node-hierarchy",
          "title": "AST Node Hierarchy"
        },
        {
          "id": "source-location",
          "title": "Source Location Tracking"
        },
        {
          "id": "visitor-pattern",
          "title": "Visitor Pattern Implementation"
        }
      ]
    },
    {
      "id": "token-stream",
      "title": "Component: Token Stream",
      "summary": "Implements the token buffer with lookahead capabilities, acting as the parser's input interface and error boundary.",
      "subsections": [
        {
          "id": "token-stream-mental-model",
          "title": "Mental Model: Bookmark in a Book"
        },
        {
          "id": "token-stream-interface",
          "title": "Interface Design"
        },
        {
          "id": "token-stream-adr",
          "title": "Architecture Decision: Lookahead Strategy"
        }
      ]
    },
    {
      "id": "expression-parser",
      "title": "Component: Expression Parser",
      "summary": "Implements recursive descent with precedence climbing to parse expressions, correctly handling operator precedence and associativity.",
      "subsections": [
        {
          "id": "expression-parser-mental-model",
          "title": "Mental Model: Math Class PEMDAS Rules"
        },
        {
          "id": "precedence-climbing-algorithm",
          "title": "Precedence Climbing Algorithm"
        },
        {
          "id": "expression-parser-adr",
          "title": "Architecture Decision: Recursive Descent vs. Pratt Parser"
        }
      ]
    },
    {
      "id": "statement-parser",
      "title": "Component: Statement Parser",
      "summary": "Parses statements and declarations, handling control flow constructs, variable declarations, and block structures.",
      "subsections": [
        {
          "id": "statement-parser-mental-model",
          "title": "Mental Model: Recipe Instructions"
        },
        {
          "id": "dangling-else-resolution",
          "title": "Dangling Else Problem and Resolution"
        },
        {
          "id": "statement-parser-adr",
          "title": "Architecture Decision: Statement vs. Expression Parsing Order"
        }
      ]
    },
    {
      "id": "error-handler",
      "title": "Component: Error Handler and Recovery",
      "summary": "Implements panic-mode error recovery to report multiple syntax errors and continue parsing after failures.",
      "subsections": [
        {
          "id": "error-handler-mental-model",
          "title": "Mental Model: Spell Checker in Word Processor"
        },
        {
          "id": "panic-mode-recovery",
          "title": "Panic Mode Recovery Algorithm"
        },
        {
          "id": "error-handler-adr",
          "title": "Architecture Decision: Synchronization Points"
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Describes how components communicate during parsing, with sequence diagrams for expression and statement parsing.",
      "subsections": [
        {
          "id": "parsing-sequence",
          "title": "Parsing Sequence: From Tokens to AST"
        },
        {
          "id": "error-recovery-flow",
          "title": "Error Recovery Flow"
        }
      ]
    },
    {
      "id": "error-edge-cases",
      "title": "Error Handling and Edge Cases",
      "summary": "Documents failure modes, detection strategies, and recovery mechanisms for common parsing edge cases.",
      "subsections": [
        {
          "id": "common-error-cases",
          "title": "Common Error Cases"
        },
        {
          "id": "edge-case-resolution",
          "title": "Edge Case Resolution Strategies"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Defines verification approaches, test scenarios, and milestone checkpoints to validate implementation progress.",
      "subsections": [
        {
          "id": "testing-approaches",
          "title": "Testing Approaches"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Provides symptom-cause-fix tables and debugging techniques for common parser implementation issues.",
      "subsections": [
        {
          "id": "common-bugs",
          "title": "Common Bugs and Fixes"
        },
        {
          "id": "debugging-techniques",
          "title": "Parser-Specific Debugging Techniques"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Describes potential enhancements to the parser, showing how the current design accommodates future features.",
      "subsections": [
        {
          "id": "language-extensions",
          "title": "Language Feature Extensions"
        },
        {
          "id": "architectural-extensions",
          "title": "Architectural Extensions"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Defines key technical terms, acronyms, and domain-specific vocabulary used throughout the document.",
      "subsections": [
        {
          "id": "terms-definitions",
          "title": "Terms and Definitions"
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "system-component",
      "title": "System Component Diagram",
      "description": "Shows all major components of the parser system and their relationships: TokenStream, ExpressionParser, StatementParser, ErrorHandler, and AST nodes. Arrows indicate data flow direction.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture"
      ]
    },
    {
      "id": "ast-class-hierarchy",
      "title": "AST Node Class Hierarchy",
      "description": "Shows inheritance relationships between AST node types: Node (base) \u2192 Expression and Statement subclasses, with specific node types like BinaryExpr, IfStmt, etc. Includes fields for each node type.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "parser-state-machine",
      "title": "Parser State Machine",
      "description": "Shows parser state transitions: Normal \u2192 Error \u2192 Recovery \u2192 Normal. Includes events that trigger transitions (unexpected token, synchronization point reached).",
      "type": "state-machine",
      "relevant_sections": [
        "error-handler"
      ]
    },
    {
      "id": "expression-parsing-sequence",
      "title": "Expression Parsing Sequence Diagram",
      "description": "Shows interaction sequence for parsing '1 + 2 * 3': TokenStream \u2192 ExpressionParser method calls \u2192 AST node construction. Demonstrates precedence climbing call stack.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "expression-parser"
      ]
    },
    {
      "id": "if-statement-parsing",
      "title": "If-Statement Parsing Flowchart",
      "description": "Flowchart showing decision process for parsing if-else statements: check 'if' token \u2192 parse condition \u2192 parse then branch \u2192 check for 'else' \u2192 parse else branch. Shows dangling else resolution.",
      "type": "flowchart",
      "relevant_sections": [
        "statement-parser"
      ]
    },
    {
      "id": "error-recovery-flow",
      "title": "Error Recovery Flowchart",
      "description": "Flowchart showing panic mode recovery: detect error \u2192 report \u2192 discard tokens until synchronization point \u2192 resume parsing. Shows different synchronization points for different contexts.",
      "type": "flowchart",
      "relevant_sections": [
        "error-handler",
        "interactions-data-flow"
      ]
    },
    {
      "id": "visitor-pattern",
      "title": "Visitor Pattern Class Diagram",
      "description": "Shows Visitor interface with visit methods for each node type, and concrete visitors like PrettyPrinter, Evaluator. Shows how nodes accept visitors for double dispatch.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    }
  ]
}