title: Flowchart: Expression Evaluation Dispatch

classes: {
  decision: {
    shape: diamond
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  process: {
    shape: rectangle
    style.fill: "#16213e"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  callout: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#3fb950"
    style.bold: true
  }
}

flowchart: {
  start: Evaluate(node, env) {
    class: process
    style.double-border: true
  }

  decision: "What is node type?" {
    class: decision
  }

  start -> decision

  # Literal branch
  literal: Return literal value {
    class: process
  }
  decision -> literal: Literal
  
  # Variable branch
  variable_lookup: Look up in environment {
    class: process
  }
  variable_return: Return value {
    class: process
  }
  decision -> variable_lookup: Variable
  variable_lookup -> variable_return
  
  # Unary branch
  unary_eval: Evaluate operand {
    class: process
  }
  unary_apply: Apply operator {
    class: process
  }
  unary_return: Return result {
    class: process
  }
  decision -> unary_eval: Unary
  unary_eval -> unary_apply
  unary_apply -> unary_return
  
  # Binary branch
  binary_left: Evaluate left operand {
    class: process
  }
  binary_right: Evaluate right operand {
    class: process
  }
  binary_apply: Apply operator {
    class: process
  }
  binary_return: Return result {
    class: process
  }
  decision -> binary_left: Binary
  binary_left -> binary_right
  binary_right -> binary_apply
  binary_apply -> binary_return
  
  # Grouping branch
  grouping_eval: Evaluate expression {
    class: process
  }
  grouping_return: Return value {
    class: process
  }
  decision -> grouping_eval: Grouping
  grouping_eval -> grouping_return
  
  # Call branch
  call_callee: Evaluate callee {
    class: process
  }
  call_args: Evaluate arguments {
    class: process
  }
  call_apply: Call function {
    class: process
  }
  call_return: Return result {
    class: process
  }
  decision -> call_callee: Call
  call_callee -> call_args
  call_args -> call_apply
  call_apply -> call_return
  
  # Recursion indicators
  recursion: |md
    **RECURSION**
    Evaluate() calls itself
    for sub-expressions
  | {
    class: callout
    shape: text
  }
  
  # Connect recursion to recursive steps
  recursion.n -> unary_eval.s: Recursive call
  recursion.n -> binary_left.s: Recursive call
  recursion.n -> grouping_eval.s: Recursive call
  recursion.n -> call_callee.s: Recursive call
  recursion.n -> call_args.s: Recursive call
}