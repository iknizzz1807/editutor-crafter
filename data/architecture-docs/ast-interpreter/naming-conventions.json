{
  "types": {
    "RuntimeError": "fields: message str, token Token",
    "UndefinedVariableError": "fields: message str, token Token",
    "TypeError": "fields: message str, token Token",
    "DivisionByZeroError": "fields: message str, token Token",
    "ArgumentError": "fields: message str, token Token",
    "ControlFlowSignal": "fields: (base class)",
    "BreakSignal": "fields: (none)",
    "ContinueSignal": "fields: (none)",
    "ReturnSignal": "fields: value RuntimeValue",
    "Interpreter": "fields: evaluator Evaluator, global_env Environment",
    "Environment": "fields: store Dict[str, Any], parent Optional[Environment]",
    "FunctionValue": "fields: name Optional[str], parameters List[str], body ASTNode, closure Environment",
    "Evaluator": "fields: (stateless)",
    "ArrayValue": "fields: elements list",
    "HashValue": "fields: items dict",
    "ClassValue": "fields: name str, methods dict, parent ClassValue, class_env Environment",
    "InstanceValue": "fields: klass ClassValue, fields dict",
    "NativeFunctionValue": "fields: name str, func callable, arity int",
    "ExceptionValue": "fields: message str, type str, stack_trace list",
    "BoundMethodValue": "fields: instance InstanceValue, method FunctionValue"
  },
  "methods": {
    "Interpreter.interpret(source_code)": "parse and execute source, return success bool",
    "Interpreter._stringify(value)": "convert runtime value to display string",
    "Interpreter.interpret(source_code) returns bool": "parse and execute source, return success",
    "Interpreter._stringify(value) returns str": "convert runtime value to display string",
    "Environment.define(name, value) returns None": "create new variable binding",
    "Environment.get(name) returns Any": "retrieve variable value walking chain",
    "Environment.assign(name, value) returns None": "update existing variable",
    "Evaluator.evaluate(node, env) returns Any": "main dispatch method for AST evaluation",
    "FunctionValue.call(arguments) returns Any": "execute function with given arguments",
    "Environment.define(name, value)": "create new variable binding",
    "Environment.get(name)": "retrieve variable value walking chain",
    "Environment.assign(name, value)": "update existing variable",
    "Evaluator.evaluate(node, env)": "main dispatch method for AST evaluation",
    "FunctionValue.call(arguments)": "execute function with given arguments",
    "Evaluator._evaluate_variable_expr(node, env) returns Any": "evaluate variable expression",
    "Evaluator._evaluate_assign_expr(node, env) returns Any": "evaluate assignment expression",
    "Evaluator._evaluate_var_stmt(node, env) returns None": "evaluate variable declaration",
    "Evaluator._evaluate_block_stmt(node, env) returns Any": "evaluate block statement",
    "Evaluator._evaluate_if_stmt(node, env) returns Any": "evaluate if/else statement",
    "Evaluator._evaluate_while_stmt(node, env) returns None": "evaluate while loop",
    "Evaluator._evaluate_for_stmt(node, env) returns Any": "evaluate for loop via desugaring",
    "Evaluator._evaluate_break_stmt(node, env)": "evaluate break statement",
    "Evaluator._evaluate_continue_stmt(node, env)": "evaluate continue statement",
    "Evaluator._evaluate_return_stmt(node, env)": "evaluate return statement",
    "Evaluator._is_truthy(value) returns bool": "determine truthiness of a runtime value",
    "Evaluator._evaluate_function_decl(node, env)": "evaluate function declaration statement",
    "Evaluator._evaluate_call_expr(node, env)": "evaluate function call expression",
    "Evaluator._evaluate_binary_expr(node, env)": "evaluate binary expression with type checking",
    "Evaluator._is_truthy(value)": "determine truthiness of a runtime value",
    "Evaluator._is_zero(value)": "check if value is numeric zero",
    "Evaluator._evaluate_variable_expr(node, env)": "evaluate variable expression",
    "Evaluator._evaluate_assign_expr(node, env)": "evaluate assignment expression",
    "Evaluator._evaluate_var_stmt(node, env)": "evaluate variable declaration",
    "Evaluator._evaluate_block_stmt(node, env)": "evaluate block statement",
    "Evaluator._evaluate_if_stmt(node, env)": "evaluate if/else statement",
    "Evaluator._evaluate_while_stmt(node, env)": "evaluate while loop",
    "Evaluator._evaluate_for_stmt(node, env)": "evaluate for loop via desugaring",
    "Builtins.clock(args) returns": "returns current time as NumberValue",
    "Builtins.print(args) returns": "prints arguments and returns NilValue",
    "Builtins.length(args) returns": "returns length of string or array",
    "Builtins.array_push(args) returns": "appends value to array",
    "NativeFunctionValue.call(arguments) returns": "executes native function with arguments",
    "Evaluator._evaluate_class_stmt(node, env) returns": "evaluates class definition",
    "Evaluator._evaluate_new_expr(node, env) returns": "evaluates new instance creation",
    "Evaluator._evaluate_get_expr(node, env) returns": "evaluates object.property expression",
    "Evaluator._evaluate_throw_stmt(node, env) returns": "evaluates throw statement",
    "Evaluator._evaluate_try_stmt(node, env) returns": "evaluates try-catch statement",
    "Builtins.clock(args)": "returns current time as NumberValue",
    "Builtins.print(args)": "prints arguments and returns NilValue",
    "Builtins.length(args)": "returns length of string or array",
    "Builtins.array_push(args)": "appends value to array",
    "NativeFunctionValue.call(arguments)": "executes native function with arguments",
    "Evaluator._evaluate_class_stmt(node, env)": "evaluates class definition",
    "Evaluator._evaluate_new_expr(node, env)": "evaluates new instance creation",
    "Evaluator._evaluate_get_expr(node, env)": "evaluates object.property expression",
    "Evaluator._evaluate_throw_stmt(node, env)": "evaluates throw statement",
    "Evaluator._evaluate_try_stmt(node, env)": "evaluates try-catch statement"
  },
  "constants": {
    "TokenType.SLASH": "division operator token type",
    "TokenType.PERCENT": "modulo operator token type"
  },
  "terms": {
    "lexical scoping": "variable visibility determined by static program structure",
    "closure": "function that captures its defining environment",
    "tree-walking": "evaluating code by recursively traversing the AST",
    "first-class function": "function that can be assigned, passed, and returned like any value",
    "desugaring": "translating syntactic sugar into more primitive constructs",
    "truthiness": "conversion of any value to boolean for conditionals",
    "shadowing": "inner scope redefining variable from outer scope",
    "immutable AST": "AST nodes never modified after creation",
    "environment chain": "linked list of scopes for variable lookup",
    "dispatch": "routing evaluation based on node type",
    "non-local exit": "control flow that jumps out of multiple nested scopes",
    "scope": "region of program where variable binding is visible",
    "binding": "association between variable name and value",
    "global environment": "outermost environment with no parent",
    "lexical closures": "functions that capture their defining environment",
    "arity": "number of parameters a function expects",
    "implicit return": "returning nil when function execution reaches end without return statement",
    "runtime errors": "errors that occur during program execution",
    "fail-fast": "strategy of halting execution at first error",
    "short-circuit evaluation": "logical operators that skip right operand when result determined by left",
    "type checking": "verifying operand types before operation execution",
    "reference semantics": "variables hold references to objects, not copies",
    "value semantics": "variables hold copies of values",
    "tail-call optimization": "reusing stack frame for function call in tail position",
    "bytecode": "compact instruction representation for virtual machine",
    "REPL": "Read-Eval-Print Loop interactive interface",
    "method resolution order": "algorithm for finding methods in inheritance hierarchy",
    "control flow signal": "exception-like mechanism for non-local jumps in evaluator",
    "stack-based VM": "virtual machine using operand stack for computations",
    "register-based VM": "virtual machine using virtual registers for computations"
  }
}