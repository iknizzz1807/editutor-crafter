{
  "title": "AST Tree-Walking Interpreter: Design Document",
  "overview": "This document outlines the design of a tree-walking interpreter that directly executes code by traversing its Abstract Syntax Tree (AST). The key architectural challenge is managing the evaluation environment\u2014a dynamic mapping of names to values\u2014and correctly implementing lexical scoping, function calls, and closures within a simple, recursive evaluator framework.",
  "sections": [
    {
      "id": "context",
      "title": "Context and Problem Statement",
      "summary": "Explains the problem of interpreting code, contrasting the AST-walking approach with bytecode VMs, and introduces the core concepts of evaluation and environments through analogies.",
      "subsections": [
        {
          "id": "context-analogy",
          "title": "Mental Model: The Math Homework Grader",
          "summary": "Explains the interpreter's role using the analogy of a teacher grading a complex math expression step-by-step, following parentheses and operator rules."
        },
        {
          "id": "context-problem",
          "title": "The Interpretation Problem",
          "summary": "Defines the task: transforming static source code into dynamic runtime behavior, and why managing state across nested scopes is complex."
        },
        {
          "id": "context-approaches",
          "title": "Existing Approaches and Trade-offs",
          "summary": "Compares tree-walking interpreters with bytecode virtual machines using a structured table of complexity, performance, and educational value."
        }
      ]
    },
    {
      "id": "goals",
      "title": "Goals and Non-Goals",
      "summary": "Clearly delineates the scope of the interpreter, defining required features and explicit exclusions to maintain project focus.",
      "subsections": [
        {
          "id": "goals-in-scope",
          "title": "Goals (What we must implement)",
          "summary": "Lists core features: expression evaluation, variables, lexical scoping, control flow, and first-class functions with closures."
        },
        {
          "id": "goals-out-of-scope",
          "title": "Non-Goals (What we explicitly omit)",
          "summary": "Lists exclusions: garbage collection, modules/imports, classes/OOP, optimizations (JIT, tail-call), and a standard library."
        }
      ]
    },
    {
      "id": "high-level-arch",
      "title": "High-Level Architecture",
      "summary": "Describes the system's main components\u2014the Evaluator, the Environment chain, and the AST Nodes\u2014and how data flows between them during execution.",
      "subsections": [
        {
          "id": "arch-components",
          "title": "Component Overview",
          "summary": "Introduces the three core pillars: the AST (static program structure), the Evaluator (recursive traversal logic), and the Environment (dynamic runtime state)."
        },
        {
          "id": "arch-data-flow",
          "title": "Execution Flow",
          "summary": "Describes the step-by-step process from a source program string to a final result, highlighting the separation between parsing and evaluation."
        },
        {
          "id": "arch-file-structure",
          "title": "Recommended File Structure",
          "summary": "Provides a suggested modular code layout to separate concerns like syntax, evaluation, and runtime errors."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the core data types and structures: Runtime Values, the Environment class, and key AST Node types relevant to evaluation.",
      "subsections": [
        {
          "id": "data-runtime-values",
          "title": "Runtime Values and Types",
          "summary": "Describes the set of values the interpreter can manipulate (numbers, strings, booleans, nil, functions) and their representation."
        },
        {
          "id": "data-environment",
          "title": "The Environment Model",
          "summary": "Details the structure for storing variable bindings as a chain of dictionaries, enabling lexical scoping."
        },
        {
          "id": "data-ast-nodes",
          "title": "Key AST Node Types for Evaluation",
          "summary": "Lists the AST node classes from the parser that the evaluator must handle, focusing on their runtime semantics."
        }
      ]
    },
    {
      "id": "component-evaluator",
      "title": "Component Design: Core Evaluator",
      "summary": "Details the central recursive `evaluate` function. This component dispatches to specific evaluation logic based on the AST node type. (Milestones 1, 3, 4)",
      "subsections": [
        {
          "id": "evaluator-mental-model",
          "title": "Mental Model: The DOM Tree Walker",
          "summary": "Compares AST evaluation to traversing a DOM tree and applying operations at each node, emphasizing recursive descent."
        },
        {
          "id": "evaluator-interface",
          "title": "Interface and Dispatch",
          "summary": "Describes the `evaluate(node, environment)` function signature and the strategy for routing node types to handler methods."
        },
        {
          "id": "evaluator-behavior",
          "title": "Internal Behavior and Algorithm",
          "summary": "Provides numbered, generic steps for evaluating different node categories: literals, unary/binary expressions, and grouping."
        },
        {
          "id": "evaluator-adr-dispatch",
          "title": "ADR: Expression Dispatch Strategy",
          "summary": "Records the decision to use a single dispatch function over a visitor pattern or double dispatch, favoring simplicity for learners."
        },
        {
          "id": "evaluator-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Highlights mistakes like forgetting to return values, incorrect recursion base cases, and mishandling of literal nodes."
        },
        {
          "id": "evaluator-impl",
          "title": "Implementation Guidance",
          "summary": "Provides Python skeleton code for the Evaluator class, with TODOs for each major node type handler."
        }
      ]
    },
    {
      "id": "component-environment",
      "title": "Component Design: Environment Manager",
      "summary": "Details the design of the scoped variable storage system. This component manages the lifetime and visibility of variable bindings. (Milestone 2)",
      "subsections": [
        {
          "id": "environment-mental-model",
          "title": "Mental Model: Stack of Ledgers",
          "summary": "Compares nested environments to a stack of accounting ledgers, where you look for entries in the current ledger first, then the parent's."
        },
        {
          "id": "environment-interface",
          "title": "Interface: Define, Get, Set",
          "summary": "Defines the three core operations for variable declaration, value retrieval, and assignment, including error conditions."
        },
        {
          "id": "environment-behavior",
          "summary": "Describes the algorithm for variable resolution (walking the parent chain) and the difference between defining a new variable and assigning to an existing one.",
          "title": "Internal Behavior"
        },
        {
          "id": "environment-adr-chain",
          "title": "ADR: Environment Chain vs. Flat Frame",
          "summary": "Records the decision to implement a linked chain of environments over a flat frame-with-display, prioritizing clarity of lexical scope."
        },
        {
          "id": "environment-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Highlights mistakes like incorrect parent chain traversal, confusing assignment with definition, and improper scope creation/teardown."
        },
        {
          "id": "environment-impl",
          "title": "Implementation Guidance",
          "summary": "Provides complete Python starter code for the Environment class and skeleton code for integrating it with variable and block nodes."
        }
      ]
    },
    {
      "id": "component-controlflow",
      "title": "Component Design: Control Flow Executor",
      "summary": "Details the evaluation of statements that alter execution order: conditionals, loops, and jumps (break/continue/return). (Milestone 3)",
      "subsections": [
        {
          "id": "controlflow-mental-model",
          "title": "Mental Model: Railroad Switching Yard",
          "summary": "Compares control flow to train tracks with switches and loops, guided by signal conditions (boolean values)."
        },
        {
          "id": "controlflow-interface",
          "title": "Interface for Statements and Jumps",
          "summary": "Describes how statement evaluation differs from expression evaluation (often returning None) and the mechanism for signaling jumps."
        },
        {
          "id": "controlflow-behavior",
          "title": "Internal Behavior for Loops and Jumps",
          "summary": "Provides algorithm steps for `if`, `while`, and `for` loops, and explains handling `break`/`continue` using exception or sentinel patterns."
        },
        {
          "id": "controlflow-adr-loopjump",
          "title": "ADR: Handling Break/Continue",
          "summary": "Records the decision to use a simple exception mechanism to unwind the loop evaluator, balancing implementation simplicity and control flow clarity."
        },
        {
          "id": "controlflow-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Highlights mistakes like infinite loops from non-updating conditions, incorrect truthiness checks, and mis-scoping of loop variables."
        },
        {
          "id": "controlflow-impl",
          "title": "Implementation Guidance",
          "summary": "Provides skeleton code for `if`, `while`, and `for` evaluation, and a complete helper class for control flow jump signals."
        }
      ]
    },
    {
      "id": "component-functions",
      "title": "Component Design: Function Manager",
      "summary": "Details the implementation of function calls, closures, and the return statement. This component ties together environments and evaluation. (Milestone 4)",
      "subsections": [
        {
          "id": "functions-mental-model",
          "title": "Mental Model: Recipe with Personal Ingredients",
          "summary": "Compares a function to a recipe (body) that, when called, uses a fresh copy of ingredients (parameters) and can also access the chef's own pantry (closure environment)."
        },
        {
          "id": "functions-interface",
          "title": "Interface: Callable Values and Closure",
          "summary": "Defines the runtime representation of a function (parameters, body, closure environment) and the `call(arguments)` operation."
        },
        {
          "id": "functions-behavior",
          "title": "Internal Behavior: Call and Return",
          "summary": "Describes the steps to execute a function call: create a new environment, bind arguments, execute the body, and handle `return`."
        },
        {
          "id": "functions-adr-closure",
          "title": "ADR: Closure Capture Strategy",
          "summary": "Records the decision to store the *defining* environment in the function object, enabling true lexical closures over dynamic scoping."
        },
        {
          "id": "functions-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Highlights mistakes like incorrect environment linking for closures, mishandling of the return value, and argument-parameter count mismatch."
        },
        {
          "id": "functions-impl",
          "title": "Implementation Guidance",
          "summary": "Provides skeleton code for function declaration, callable runtime object, and the `return` statement handling."
        }
      ]
    },
    {
      "id": "interactions",
      "title": "Interactions and Data Flow",
      "summary": "Illustrates how components collaborate in key scenarios: variable lookup across scopes, a function call with closures, and loop execution with break.",
      "subsections": [
        {
          "id": "interactions-sequence",
          "title": "Sequence of Operations",
          "summary": "Walks through concrete examples, tracing the flow of control and data between the Evaluator, Environment chain, and AST nodes."
        },
        {
          "id": "interactions-messages",
          "title": "Message and Value Formats",
          "summary": "Describes the data structures passed between components, such as return value wrappers or control flow signals."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Defines the interpreter's runtime error taxonomy, detection strategies, and recovery (halting) behavior.",
      "subsections": [
        {
          "id": "error-types",
          "title": "Runtime Error Types",
          "summary": "Catalogues expected errors: type errors, undefined variables, division by zero, argument mismatch, and invalid break/continue."
        },
        {
          "id": "error-detection",
          "title": "Detection and Reporting",
          "summary": "Explains where and how each error type is detected, and guidelines for creating user-friendly error messages with line numbers."
        },
        {
          "id": "edge-cases",
          "title": "Special Edge Cases",
          "summary": "Discusses handling of nil, truthiness rules, empty statement blocks, and functions that implicitly return nil."
        }
      ]
    },
    {
      "id": "testing",
      "title": "Testing Strategy",
      "summary": "Provides a approach for verifying the interpreter's correctness, from unit tests of individual components to integration tests of full programs.",
      "subsections": [
        {
          "id": "testing-approach",
          "title": "Testing Approach and Tools",
          "summary": "Recommends a testing framework and suggests organizing tests by language feature (expressions, scoping, control flow, functions)."
        },
        {
          "id": "testing-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "For each of the four project milestones, provides a concrete test program and its expected output to verify core functionality."
        }
      ]
    },
    {
      "id": "debugging",
      "title": "Debugging Guide",
      "summary": "A practical guide for learners to diagnose and fix common implementation bugs, using systematic inspection techniques.",
      "subsections": [
        {
          "id": "debugging-table",
          "title": "Symptom \u2192 Cause \u2192 Fix Table",
          "summary": "Lists common symptoms (e.g., 'variable always returns nil'), their likely causes, and step-by-step diagnosis and fixes."
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques and Tools",
          "summary": "Suggests adding strategic print logging, visualizing the AST and environment chain, and using a debugger to step through evaluation."
        }
      ]
    },
    {
      "id": "extensions",
      "title": "Future Extensions",
      "summary": "Proposes potential enhancements to the interpreter, showing how the current design accommodates or would need modification for them.",
      "subsections": [
        {
          "id": "extensions-features",
          "title": "Language Feature Extensions",
          "summary": "Ideas for adding arrays/hashes, classes, exceptions, standard library functions, and tail-call optimization."
        },
        {
          "id": "extensions-arch",
          "title": "Architectural Evolutions",
          "summary": "Paths to transform the tree-walker into a bytecode compiler/Virtual Machine or add a REPL and debugger."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key technical terms, acronyms, and domain-specific vocabulary used throughout this document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "sys-component",
      "title": "System Component Diagram",
      "description": "Shows the three main components (AST, Evaluator, Environment Chain) and their relationships. The Evaluator reads the AST and reads/writes to the current Environment. Environments link to a parent.",
      "type": "component",
      "relevant_sections": [
        "high-level-arch",
        "interactions"
      ]
    },
    {
      "id": "data-type-relationship",
      "title": "Data Model: Type Relationships",
      "description": "Shows the hierarchy of Runtime Value types (Number, String, Boolean, Nil, Function). The Function value has fields for parameters, body, and closure_environment. The Environment class has a parent pointer and a store dictionary.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "component-functions"
      ]
    },
    {
      "id": "seq-function-call",
      "title": "Sequence Diagram: Function Call with Closure",
      "description": "Traces the steps: 1) Evaluator encounters a Call node, 2) Evaluates the callee (a Function value), 3) Creates a new Environment with the callee's closure_environment as parent, 4) Binds arguments, 5) Evaluates the body in the new environment, 6) Returns the result. Shows the flow between Caller's Evaluator, Callee Function, and Environment objects.",
      "type": "sequence",
      "relevant_sections": [
        "component-functions",
        "interactions"
      ]
    },
    {
      "id": "flowchart-eval-expr",
      "title": "Flowchart: Expression Evaluation Dispatch",
      "description": "A flowchart starting at 'Evaluate(node, env)'. Decision diamonds check node type, routing to processes for Literal, Variable, Binary, Unary, Grouping, and Call. Includes steps for operand evaluation and operator application. Highlights recursion.",
      "type": "flowchart",
      "relevant_sections": [
        "component-evaluator",
        "interactions"
      ]
    },
    {
      "id": "state-machine-loop",
      "title": "State Machine: While Loop Execution",
      "description": "Shows states: 'Evaluate Condition' -> [True] -> 'Execute Body' -> 'Check for Break/Continue' -> 'Handle Jump or Proceed' -> loop back to condition. [False] exits to 'Loop End'. Includes transitions for break (to End) and continue (back to Condition).",
      "type": "state-machine",
      "relevant_sections": [
        "component-controlflow"
      ]
    },
    {
      "id": "env-chain-lookup",
      "title": "Diagram: Environment Chain Lookup",
      "description": "Visualizes a chain of three nested environment boxes (Global, Function, Block). An arrow labeled 'lookup(x)' starts in Block, goes to Function, then to Global where 'x' is found. Illustrates lexical scoping and shadowing.",
      "type": "component",
      "relevant_sections": [
        "component-environment",
        "interactions"
      ]
    }
  ]
}