{
  "types": {
    "BTree": "fields: root_page_id page_id_t, t int, key_count size_t, pager disk_pager_t*",
    "BTreeNode": "fields: keys int*, values void**, children BTreeNode**, num_keys int, is_leaf bool, next BTreeNode*",
    "SearchResult": "fields: found bool, value void*, comparisons int",
    "disk_pager_t": "fields: fd int, num_pages uint64_t, lru_head bp_entry_t*, lru_tail bp_entry_t*, entries bp_entry_t*, num_entries int",
    "bp_entry_t": "fields: page_id page_id_t, page disk_page_t, is_dirty bool, next bp_entry_t*, prev bp_entry_t*",
    "disk_page_t": "fields: bytes uint8_t[PAGE_SIZE]"
  },
  "methods": {
    "btree_create(min_degree int) returns BTree*": "Initialize a new empty B-tree with given minimum degree",
    "btree_destroy(tree BTree*) returns void": "Free all memory used by the B-tree",
    "btree_search(tree BTree*, key int) returns SearchResult": "Public search API",
    "btree_insert(tree BTree*, key int, value void*) returns bool": "Insert a key (and optional value) into the tree",
    "btree_delete(tree BTree*, key int) returns bool": "Delete a key from the tree",
    "btree_size(tree BTree*) returns size_t": "Get the number of keys in the tree",
    "btree_height(tree BTree*) returns int": "Get the height of the tree",
    "btree_validate(tree BTree*) returns bool": "Validate tree invariants",
    "btree_print(tree BTree*) returns void": "Print tree structure",
    "node_create(t int, is_leaf bool) returns BTreeNode*": "Allocates and initializes a new empty node",
    "node_destroy(node BTreeNode*) returns void": "Recursively deallocates a node and all descendants",
    "node_find_key_index(node BTreeNode*, key int, comparisons int*) returns int": "Binary search within node's keys",
    "node_is_full(node BTreeNode*, t int) returns bool": "Checks if node has 2t-1 keys",
    "node_is_underfull(node BTreeNode*, t int) returns bool": "Checks if node has fewer than t-1 keys (root exception handled by caller)",
    "search_recursive(BTreeNode* node, int key) returns SearchResult": "Internal recursive search function",
    "insert_non_full(BTreeNode* node, int key, void* value, int t) returns bool": "Internal recursive insertion helper",
    "delete_from_subtree(BTreeNode* node, int key, int t) returns bool": "Internal recursive deletion helper",
    "node_insert_key(node BTreeNode*, index int, key int, value void*) returns void": "Inserts key at index, shifting existing elements",
    "node_remove_key(node BTreeNode*, index int) returns void": "Removes key at index, shifting elements left",
    "node_split_child(BTreeNode* parent, int i, int t) returns void": "Split child of parent at index i",
    "get_predecessor(BTreeNode* node, int index) returns int": "Helper: Get predecessor key from left subtree",
    "get_successor(BTreeNode* node, int index) returns int": "Helper: Get successor key from right subtree",
    "borrow_from_left(BTreeNode* parent, int child_idx, int t) returns void": "Helper: Borrow key from left sibling",
    "borrow_from_right(BTreeNode* parent, int child_idx, int t) returns void": "Helper: Borrow key from right sibling",
    "merge_with_left_sibling(BTreeNode* parent, int child_idx, int t) returns void": "Helper: Merge child with left sibling",
    "strengthen_child(BTreeNode* parent, int child_idx, int t) returns void": "Helper: Ensure child has at least t keys before descending",
    "btree_create(filename, min_degree) returns": "Create B-tree with disk persistence",
    "node_load(tree, page_id) returns": "Load node from disk into memory",
    "node_save(tree, node, page_id) returns": "Save node to disk",
    "pager_open(filename, cache_pages) returns": "Open/create database file and initialize buffer pool",
    "pager_fetch(pager, page_id) returns": "Get page from cache or disk",
    "btree_range_scan(start_key, end_key) returns": "Return all key-value pairs in range (B+ tree extension)"
  },
  "constants": {
    "DEFAULT_MIN_DEGREE": "3",
    "DEBUG": "Debug logging macro",
    "PAGE_SIZE": "4096",
    "INVALID_PAGE_ID": "UINT64_MAX"
  },
  "terms": {
    "B-tree": "Self-balancing tree data structure optimized for systems that read and write large blocks of data",
    "minimum degree (t)": "Parameter defining capacity bounds: each node (except root) has between t-1 and 2t-1 keys",
    "node splitting": "Operation that splits a full node into two nodes during insertion",
    "node merging": "Operation that combines two underfull nodes during deletion",
    "borrowing": "Operation that transfers a key from a sibling through the parent to fix underflow",
    "disk block/page": "Unit of data transfer between disk and memory (typically 4KB)",
    "fanout": "Number of children per internal node",
    "height": "Number of levels from root to leaves",
    "opaque pointer": "A pointer to an incomplete type that hides implementation details from the user",
    "invariants": "Mathematical rules that must always hold true for the data structure to be valid",
    "proactive splitting": "Splitting full nodes during the downward traversal before insertion",
    "capacity bounds": "Minimum and maximum number of keys allowed in a node based on minimum degree t",
    "binary search": "Algorithm for finding a target value within a sorted array by repeatedly dividing search interval in half",
    "recursive traversal": "Method of traversing tree structures where a function calls itself to process subtrees",
    "node access": "Reading a node from disk or memory, a key performance metric for B-trees",
    "in-order predecessor": "Largest key in the left subtree of a given key",
    "in-order successor": "Smallest key in the right subtree of a given key",
    "underflow": "Condition where a node has fewer than t-1 keys (violating B-tree invariant)",
    "strengthening": "Proactively ensuring a child has at least t keys before descending during deletion",
    "page-oriented storage": "Each node occupies fixed disk block at stable location",
    "buffer pool": "Cache of recently accessed disk pages in memory",
    "B+ tree": "B-tree variant with all values in linked leaves",
    "B* tree": "B-tree variant with redistribution before splitting",
    "lock coupling": "Holding parent lock while acquiring child lock to prevent deadlock",
    "range scan": "Retrieving all keys/values within a specified interval"
  }
}