{
  "types": {
    "block_header_t": "fields: size size_t, allocated int, next struct block_header_t*, prev struct block_header_t*, magic uint32_t",
    "footer_t": "fields: size size_t, allocated int",
    "allocator_state_t": "fields: heap_base void*, heap_size size_t, free_list_head block_header_t*, size_classes block_header_t**, global_mutex pthread_mutex_t",
    "thread_cache_t": "fields: free_lists block_header_t*[NUM_SIZE_CLASSES], allocation_count size_t, hit_count size_t, next struct thread_cache_t*",
    "arena_t": "fields: heap_base void*, heap_size size_t, free_list block_header_t*, lock pthread_mutex_t, cache thread_cache_t*, next struct arena_t*, id int"
  },
  "methods": {
    "os_sbrk(intptr_t increment) returns void*": "wrapper for sbrk system call with error checking",
    "align_to_page(size_t size) returns size_t": "round size up to multiple of page size",
    "get_header_from_ptr(void *ptr) returns block_header_t*": "convert user pointer to its block header",
    "get_total_block_size(size_t user_size) returns size_t": "calculate total size including header, footer, and alignment padding",
    "init_block(void *memory, size_t user_size, int allocated) returns void": "initialize block metadata at given memory location",
    "malloc(size_t size) returns void*": "top-level allocation function",
    "free(void *ptr) returns void": "top-level deallocation function",
    "calloc(size_t nmemb, size_t size) returns void*": "allocate and zero memory",
    "realloc(void *ptr, size_t size) returns void*": "resize existing allocation",
    "split_block(block_header_t *block, size_t needed_size) returns block_header_t*": "divide a free block into allocated portion and free remainder",
    "coalesce_block(block_header_t *block) returns block_header_t*": "merge adjacent free blocks into a single larger block",
    "find_free_block(size_t size) returns block_header_t*": "search free list using configured strategy (first/best/worst-fit)",
    "malloc_segregated(size_t size) returns void*": "allocate using segregated free lists by size class",
    "thread_cache_malloc(size_t size) returns void*": "allocate using thread cache with global fallback",
    "thread_cache_free(void *ptr) returns void": "free to thread-local cache or global arena",
    "heap_visualize(void) returns void": "print heap layout for debugging",
    "free_list_insert(block_header_t* block) returns void": "insert free block at head of free list",
    "free_list_remove(block_header_t* block) returns void": "remove block from free list",
    "os_mmap(size_t size) returns void*": "allocate anonymous private memory via mmap",
    "os_munmap(void* addr, size_t size) returns int": "release memory mapped by os_mmap",
    "get_memory_from_os(size_t total_size, int* is_large) returns void*": "choose between sbrk and mmap based on size threshold",
    "return_memory_to_os(block_header_t* block, size_t block_size, int is_mmap) returns void": "release memory using appropriate system call",
    "find_free_block(size_t size) returns": "search free list using configured strategy (first/best/worst-fit)",
    "malloc_segregated(size_t size) returns": "allocate using segregated free lists by size class",
    "size_to_class_index(size_t size) returns": "map request size to size class index",
    "get_size_class_head(int class_index) returns": "return pointer to free list head for given size class",
    "set_allocation_strategy(allocation_strategy_t strategy) returns": "change allocation strategy at runtime",
    "mutex_lock(pthread_mutex_t* mutex) returns void": "lock mutex with error checking",
    "mutex_unlock(pthread_mutex_t* mutex) returns void": "unlock mutex with error checking",
    "mutex_init(pthread_mutex_t* mutex) returns void": "initialize mutex",
    "mutex_destroy(pthread_mutex_t* mutex) returns void": "destroy mutex",
    "destroy_thread_cache(void* cache_ptr) returns void": "destructor for thread cache when thread exits",
    "init_thread_cache_system() returns void": "initialize thread cache subsystem",
    "get_thread_cache() returns thread_cache_t*": "get or create thread-local cache",
    "thread_cache_free(void* ptr) returns void": "free memory using thread cache",
    "get_arena_for_thread() returns arena_t*": "get or create arena for current thread",
    "arena_malloc(size_t size) returns void*": "allocate from per-thread arena",
    "size_to_class_index(size_t size) returns int": "map request size to size class index",
    "get_size_class_head(int class_index) returns block_header_t*": "return pointer to free list head for given size class",
    "is_valid_pointer(void *ptr) returns int": "validate if pointer came from malloc",
    "is_double_free(block_header_t *header) returns int": "check if block is already free",
    "calculate_total_size(size_t user_size, int *overflow) returns size_t": "compute block size with overflow detection",
    "heap_validate(void) returns int": "check heap integrity",
    "DEBUG_LOG(format, ...) returns void": "conditional debug logging macro",
    "heap_visualize() returns void": "print heap layout for debugging",
    "heap_validate() returns int": "check heap integrity",
    "reset_allocator() returns void": "reinitialize allocator global state for testing",
    "trace_malloc(size_t size, void* ptr, const char* file, int line) returns void": "log allocation operation",
    "trace_free(void* ptr, const char* file, int line) returns void": "log deallocation operation",
    "init_tracing(const char* filename) returns void": "initialize debug tracing system",
    "dump_free_list() returns void": "print free list structure",
    "malloc_buddy(size_t size) returns void*": "allocate using buddy system",
    "free_buddy(void *ptr) returns void": "free memory allocated with buddy system",
    "gc_run(void) returns void": "perform garbage collection cycle",
    "gc_enable(int enable) returns void": "enable/disable garbage collection",
    "gc_register_block(block_header_t* block) returns void": "add block to garbage collector registry",
    "gc_mark_roots(void) returns void": "mark reachable blocks from roots",
    "gc_sweep(void) returns void": "reclaim unmarked blocks",
    "get_allocator_stats(void) returns void": "retrieve allocation statistics",
    "print_allocator_stats(void) returns void": "print statistics to stdout",
    "mremap(void *old_address, size_t old_size, size_t new_size, int flags) returns void*": "Linux system call to resize memory mapping",
    "set_allocation_strategy(allocation_strategy_t strategy) returns void": "change allocation strategy at runtime"
  },
  "constants": {
    "ALIGNMENT": "8",
    "PAGE_SIZE": "4096",
    "SBRK_THRESHOLD": "128 * 1024",
    "MAGIC": "0xDEADBEEF",
    "MAP_FAILED": "(void*)-1",
    "IS_MMAP_FLAG": "0x80000000 (high bit of size field)",
    "MIN_BLOCK_SIZE": "minimum size for a free block",
    "NUM_SIZE_CLASSES": "8",
    "FIRST_FIT": "allocation strategy enum value",
    "BEST_FIT": "allocation strategy enum value",
    "WORST_FIT": "allocation strategy enum value",
    "NEXT_FIT": "allocation strategy enum value",
    "LARGEST_SIZE_CLASS": "2048 (maximum size for segregated lists)",
    "MAX_ARENAS": "maximum number of arenas to create (8)",
    "HEADER_SIZE": "sizeof(block_header_t)",
    "FOOTER_SIZE": "sizeof(footer_t)",
    "DEBUG": "compile-time flag for debugging features",
    "USE_MAGIC": "flag to enable magic number validation",
    "ENOMEM": "errno value for memory exhaustion",
    "CANARY_SIZE": "4 in debug builds, 0 otherwise",
    "CANARY_VALUE": "0xCAFEBABE",
    "MAX_BUDDY_ORDER": "maximum order for buddy allocator",
    "MIN_BUDDY_SIZE": "minimum allocation size for buddy system",
    "MREMAP_MAYMOVE": "flag for mremap allowing relocation",
    "ENABLE_STATS": "compile flag for statistics collection",
    "ENABLE_TRACING": "compile flag for allocation tracing"
  },
  "terms": {
    "heap": "region of virtual address space used for dynamic allocation",
    "fragmentation": "wasted memory space that cannot be used to satisfy allocation requests",
    "coalescing": "process of merging adjacent free memory blocks into a single larger free block",
    "block": "contiguous unit of memory containing metadata and payload",
    "free list": "doubly-linked list tracking free blocks",
    "size class": "category of allocation sizes with power-of-two boundaries",
    "sbrk": "Unix system call to adjust program break for heap expansion/contraction",
    "mmap": "Unix system call to map files or anonymous memory into address space",
    "bump allocator": "An allocator that maintains a single pointer to the next free address, allocating sequentially with no ability to free individual blocks",
    "first-fit": "An allocation strategy that scans the free list and selects the first block large enough to satisfy the request",
    "best-fit": "allocation strategy finding the smallest adequate block",
    "worst-fit": "allocation strategy finding the largest available block",
    "teaching allocator": "educational implementation prioritizing clarity over performance",
    "external fragmentation": "wasted space between allocated blocks",
    "internal fragmentation": "wasted space within allocated blocks due to size rounding to class boundaries",
    "boundary tags": "headers and footers enabling bidirectional coalescing",
    "segregated free lists": "multiple free lists organized by size classes for O(1) allocation",
    "thread-local cache": "per-thread pool of recently freed blocks for fast allocation",
    "lock contention": "performance degradation when multiple threads compete for the same mutex",
    "heap manager": "component responsible for organizing memory into blocks and maintaining free list integrity",
    "OS memory interface": "component that abstracts operating system memory allocation primitives (sbrk, mmap)",
    "allocation strategy engine": "component implementing different algorithms for finding free blocks",
    "thread-local cache manager": "component providing per-thread memory pools to reduce lock contention",
    "header": "metadata structure at start of block",
    "footer": "mirror metadata at end of block",
    "allocator state": "global structure holding heap management information",
    "page alignment": "rounding addresses/sizes to multiples of system page size (typically 4096 bytes)",
    "virtual memory": "OS abstraction providing private address space",
    "anonymous mapping": "mmap allocation not backed by a file (just RAM)",
    "private mapping": "mmap allocation not shared with other processes",
    "program break": "address of first location beyond heap end",
    "splitting": "dividing a large free block into an allocated portion and a smaller free remainder",
    "explicit free list": "free list implementation with explicit next/prev pointers in free blocks",
    "wilderness block": "block at heap end adjacent to program break",
    "allocation strategy": "algorithm for selecting which free block to allocate (first-fit, best-fit, worst-fit)",
    "next-fit": "allocation strategy starting search from last position",
    "per-thread arena": "private heap region assigned to a specific thread",
    "false sharing": "performance issue where unrelated data shares CPU cache line causing invalidations",
    "memory ordering": "constraints on how memory operations become visible across threads",
    "cache line": "unit of data transfer between CPU cache and memory (typically 64 bytes)",
    "fast path": "allocation/deallocation path that avoids locking through thread-local caching",
    "fail-fast": "design principle of immediately reporting errors rather than continuing with corrupted state",
    "integer overflow": "arithmetic operation exceeding type capacity, wrapping to small value",
    "memory exhaustion": "state where OS cannot provide more memory",
    "corruption detection": "techniques to identify damaged heap metadata",
    "edge case": "unusual but valid input that tests boundary conditions",
    "boundary condition": "input values at extremes of valid range",
    "test harness": "framework for organizing and running automated tests",
    "heap integrity": "property that all heap metadata is consistent and valid",
    "thread cache": "per-thread pool of recently freed blocks for fast allocation",
    "magic number": "known constant value in block header to detect corruption",
    "heap visualization": "printing the complete layout of heap blocks",
    "canary": "special value placed at memory boundaries to detect overflows",
    "debug tracing": "logging all allocation/deallocation operations for replay",
    "allocation pattern": "specific sequence of malloc/free operations",
    "buddy allocation": "memory allocation scheme using power-of-two blocks that can be split and merged",
    "garbage collection": "automatic reclamation of memory no longer reachable by program",
    "mark-and-sweep": "garbage collection algorithm that marks reachable blocks then sweeps unmarked ones",
    "conservative scanning": "garbage collection technique that treats any word that looks like a pointer as a pointer",
    "in-place expansion": "resizing a memory block without moving it by using adjacent free space",
    "allocation registry": "global list of all allocated blocks for garbage collection",
    "stop-the-world": "garbage collection pause where all program threads are stopped",
    "payload": "region of a memory block returned to the user program"
  }
}