{
  "types": {
    "MetaInfo": "fields: Announce string, AnnounceList [][]string, CreationDate time.Time, Comment string, CreatedBy string, InfoHash [20]byte, Info Info",
    "Info": "fields: Name string, Length int64, Files []File, PieceLength int64, Pieces []byte",
    "File": "fields: Length int64, Path []string",
    "AnnounceRequest": "fields: InfoHash [20]byte, PeerID [20]byte, Port int, Uploaded int64, Downloaded int64, Left int64, Event string",
    "AnnounceResponse": "fields: Interval int, Complete int, Incomplete int, Peers []byte, FailureReason string",
    "PeerInfo": "fields: IP [4]byte, Port uint16",
    "Decoder": "fields: reader *bufio.Reader, offset int",
    "Client": "fields: metaInfo *torrent.MetaInfo, sharedState *coordination.SharedState, eventBus *EventBus, trackerClient *tracker.Client, peerManager *peer.Manager, pieceManager *piece.PieceManager, ctx context.Context, cancel context.CancelFunc",
    "Connection": "fields: conn net.Conn, framer *MessageFramer, peerID [20]byte, infoHash [20]byte, amChoking bool, amInterested bool, peerChoking bool, peerInterested bool, bitfield *BitfieldOps, pendingRequests map[string]*PendingRequest, maxPipeline int, mutex sync.RWMutex, ctx context.Context, cancel context.CancelFunc",
    "PieceState": "fields: Index int, Length int, Hash [20]byte, Blocks map[int]*Block, State PieceStateEnum, Priority int, Availability int",
    "Block": "fields: PieceIndex int, Offset int, Length int, Data []byte, State BlockStateEnum, RequestedFrom string, RequestTime time.Time",
    "MessageFramer": "fields: conn io.ReadWriter, buffer []byte",
    "BitfieldOps": "fields: bitfield []byte, numPieces int",
    "ParseError": "fields: Offset int, Err error",
    "BencodeType": "enum: TypeString, TypeInteger, TypeList, TypeDictionary",
    "HTTPClient": "fields: client *http.Client",
    "BackoffScheduler": "fields: baseDelay time.Duration, maxDelay time.Duration, multiplier float64, jitterPercent int, currentDelay time.Duration, failures int, mutex sync.RWMutex",
    "Message": "fields: ID int, Payload []byte",
    "Handshake": "fields: InfoHash [20]byte, PeerID [20]byte",
    "PendingRequest": "fields: PieceIndex int, Offset int, Length int, RequestTime time.Time",
    "PieceManager": "fields: metaInfo *torrent.MetaInfo, pieces map[int]*PieceState, selector *PieceSelector, verificationPool *VerificationPool, statistics *Statistics, mutex sync.RWMutex, workRequests chan WorkRequest, blockData chan BlockData, verificationResults chan VerificationResult",
    "VerificationPool": "fields: workers int, requests chan VerificationRequest, wg sync.WaitGroup, shutdown chan struct{}",
    "PieceSelector": "fields: queue PriorityQueue, available map[int]int, needed map[int]bool, mutex sync.RWMutex",
    "EndgameManager": "fields: pieceManager *piece.PieceManager, connections map[string]*peer.Connection, activeRequests map[BlockKey][]string, mutex sync.RWMutex, enabled bool",
    "SharedState": "pieces map[int]*PieceState, connections map[string]*Connection, statistics *Statistics, pieceMutex sync.RWMutex, connectionMutex sync.RWMutex, statsMutex sync.RWMutex",
    "Statistics": "Downloaded int64, Uploaded int64, Left int64, StartTime time.Time, CompletedPieces int, TotalPieces int, ConnectedPeers int",
    "EventBus": "subscribers map[EventType][]chan Event, mutex sync.RWMutex, ctx context.Context, cancel context.CancelFunc",
    "Event": "Type EventType, PeerID string, Timestamp time.Time, Data interface{}",
    "EventType": "enum: EventPeerConnected, EventPeerDisconnected, EventPieceCompleted, EventBlockReceived, EventTrackerResponse, EventDownloadComplete",
    "BitTorrentError": "fields: Type ErrorType, Component string, Operation string, Err error, Context map[string]interface{}, Timestamp time.Time",
    "CircuitBreaker": "fields: name string, failureThreshold int, recoveryTimeout time.Duration, successThreshold int, state CircuitState, failures int, successes int, lastFailureTime time.Time, mutex sync.RWMutex",
    "ErrorHandler": "fields: backoffSchedulers map[string]*BackoffScheduler, circuitBreakers map[string]*CircuitBreaker, qualityScorer *PeerQualityScorer, recoveryStrategies map[ErrorType]RecoveryStrategy, eventBus *EventBus, mutex sync.RWMutex",
    "PeerQualityScorer": "fields: scores map[string]*PeerScore, mutex sync.RWMutex",
    "PeerScore": "fields: ConnectionReliability float64, DataQuality float64, TransferPerformance float64, ProtocolCompliance float64, LastUpdate time.Time",
    "ErrorType": "enum: ErrorTypeNetwork, ErrorTypeProtocol, ErrorTypeData, ErrorTypeTracker, ErrorTypeFileSystem, ErrorTypeConcurrency",
    "CircuitState": "enum: CircuitClosed, CircuitOpen, CircuitHalfOpen",
    "RecoveryAction": "fields: Delay time.Duration, ShouldRetry bool, Strategy string",
    "RecoveryStrategy": "interface for different recovery approaches",
    "TestTorrentConfig": "fields: FileName string, Content []byte, PieceLength int64, AnnounceURL string",
    "MockTracker": "fields: server *httptest.Server, responses map[string]*TrackerResponse, requests []*TrackerRequest",
    "TrackerResponse": "fields: Interval int, Complete int, Incomplete int, Peers []MockPeer, Error string",
    "TrackerRequest": "fields: InfoHash string, PeerID string, Port int, Uploaded int64, Downloaded int64, Left int64, Event string, Timestamp time.Time",
    "MockPeer": "fields: IP net.IP, Port uint16",
    "ComponentLogger": "fields: component string, level LogLevel, output io.Writer, mutex sync.RWMutex",
    "BitTorrentLogger": "fields: loggers map[string]*ComponentLogger, mutex sync.RWMutex",
    "StateInspector": "fields: components map[string]StateProvider, mutex sync.RWMutex, server *http.Server",
    "StateProvider": "interface: GetState() interface{}, GetStatistics() map[string]interface{}",
    "SystemStats": "fields: Goroutines int, MemoryUsage MemoryStats, Uptime time.Duration, Timestamp time.Time",
    "MemoryStats": "fields: Allocated uint64, TotalAlloc uint64, SystemMem uint64, NumGC uint32",
    "DebugDecoder": "fields: *Decoder, logger *debug.ComponentLogger",
    "LogLevel": "enum: DEBUG, INFO, WARN, ERROR",
    "DHTClient": "fields: nodeID [20]byte, conn *net.UDPConn, routingTable *RoutingTable, queries map[string]*PendingQuery, eventBus *EventBus, ctx context.Context, cancel context.CancelFunc",
    "RoutingTable": "fields: nodeID [20]byte, buckets []Bucket, mutex sync.RWMutex",
    "NodeInfo": "fields: ID [20]byte, Addr *net.UDPAddr, LastSeen time.Time",
    "MagnetLink": "fields: InfoHash [20]byte, DisplayName string, Trackers []string, ExactLength int64",
    "MetadataFetcher": "fields: infoHash [20]byte, peerManager *peer.Manager, eventBus *EventBus, ctx context.Context",
    "TorrentStatus": "fields: InfoHash string, Name string, Size int64, Downloaded int64, Uploaded int64, Progress float64, DownloadRate float64, UploadRate float64, Peers int, Status string",
    "BandwidthManager": "fields: globalLimits *RateLimiter, perTorrentLimits map[string]*RateLimiter, tokenBuckets map[string]*TokenBucket"
  },
  "methods": {
    "GetPieceHashes() [][20]byte": "extracts individual 20-byte SHA-1 hashes from concatenated pieces field",
    "CalculateInfoHash(bencoded []byte) [20]byte": "computes SHA-1 hash of bencoded info dictionary",
    "BuildAnnounceURL(announceURL string) string": "constructs complete tracker announce URL with required parameters",
    "ParseCompactPeers(compactPeers []byte) []PeerInfo": "decodes 6-byte compact peer format into PeerInfo structs",
    "NewDecoder(r io.Reader) *Decoder": "creates bencode decoder for given data stream",
    "Decode() (interface{}, error)": "parses next bencode value using recursive descent",
    "decodeString() ([]byte, error)": "parses bencode string format length:content",
    "decodeInteger() (int64, error)": "parses bencode integer format i<number>e",
    "decodeList() ([]interface{}, error)": "parses bencode list format l<items>e",
    "decodeDictionary() (map[string]interface{}, error)": "parses bencode dictionary format d<key><value>e",
    "NewClient(metaInfo *torrent.MetaInfo) *Client": "creates BitTorrent client for given torrent",
    "Download(outputPath string) error": "orchestrates complete download lifecycle from start to completion",
    "ParseFromFile(filepath string) (*MetaInfo, error)": "reads and parses torrent file from disk",
    "UpdateInterest(neededPieces []int)": "updates interested state based on peer's available pieces",
    "CanDownload() bool": "returns true if peer allows downloads",
    "SelectNextPiece(peerBitfield *BitfieldOps) int": "implements rarest-first piece selection",
    "VerifyPiece(pieceIndex int, data []byte) bool": "verifies piece hash and updates state",
    "SetPiece(pieceIndex int)": "sets bit in bitfield for specified piece",
    "HasPiece(pieceIndex int) bool": "checks if piece bit is set in bitfield",
    "CalculateInfoHash([]byte) [20]byte": "computes SHA-1 hash of bencoded info dictionary",
    "NewDecoder(io.Reader) *Decoder": "creates bencode decoder for given data stream",
    "ParseFromFile(string) (*MetaInfo, error)": "reads and parses torrent file from disk",
    "TotalLength() int64": "calculates total size of all files in torrent",
    "ValidatePieceHashes() error": "checks piece hash count matches expected",
    "ExpectedPieceCount() int": "calculates expected number of pieces",
    "BuildAnnounceURL(AnnounceRequest) string": "constructs complete tracker announce URL with required parameters",
    "ParseCompactPeers([]byte) ([]PeerInfo, error)": "decodes 6-byte compact peer format into PeerInfo structs",
    "URLEncodeBinary([]byte) string": "performs percent-encoding for binary data with BitTorrent compatibility",
    "Announce(context.Context, AnnounceRequest) (*AnnounceResponse, error)": "sends announce request and parses response",
    "ScheduleNextAnnounce(int) time.Time": "calculates next announce time with jitter",
    "ShouldAnnounce() bool": "returns true if ready for next announce",
    "OnAnnounceError(error) time.Duration": "handles announce failures with backoff",
    "NewConnection(net.Conn, [20]byte, [20]byte) *Connection": "creates new peer connection with initial state",
    "PerformHandshake() error": "executes BitTorrent handshake protocol",
    "UpdateInterest([]int) error": "updates interested state based on needed pieces",
    "SendRequest(int, int, int) error": "sends block request if conditions allow",
    "ProcessMessage(*Message) error": "dispatches incoming messages to handlers",
    "NewMessageFramer(io.ReadWriter) *MessageFramer": "creates message framer for connection",
    "ReadMessage() (*Message, error)": "reads and parses next protocol message",
    "WriteMessage(*Message) error": "writes message with proper framing",
    "NewBitfieldOps(int) *BitfieldOps": "creates bitfield for specified piece count",
    "SetPiece(int)": "marks piece as available in bitfield",
    "HasPiece(int) bool": "checks if piece is available",
    "CountAvailablePieces() int": "returns total available pieces",
    "MarshalBinary() []byte": "serializes handshake to wire format",
    "UnmarshalBinary([]byte) error": "parses handshake from wire format",
    "NewPieceManager(*torrent.MetaInfo) *PieceManager": "creates piece manager for given torrent",
    "RequestWork(string, *BitfieldOps) ([]BlockRequest, error)": "assigns blocks to peer for downloading",
    "SubmitBlockData(string, int, int, []byte) error": "processes received block data",
    "ServeUploadRequest(int, int, int) ([]byte, error)": "handles upload requests from other peers",
    "VerifyPiece(int, []byte) bool": "verifies piece hash and updates state",
    "SelectNextPiece(*BitfieldOps) int": "implements rarest-first piece selection",
    "ShouldEnterEndgame() bool": "determines if endgame mode should activate",
    "OnBlockReceived(int, int, string)": "handles block completion in endgame mode",
    "NewClient(torrentPath string) (*Client, error)": "creates BitTorrent client for specified torrent file",
    "handlePeerEvent(event Event)": "processes peer connection state changes",
    "handlePieceEvent(event Event)": "processes piece completion and verification events",
    "Shutdown() error": "gracefully terminates all client operations",
    "NewSharedState(totalPieces int, totalLength int64) *SharedState": "creates synchronized state manager",
    "GetPieceState(pieceIndex int) *PieceState": "safely retrieves piece state for reading",
    "UpdatePieceState(pieceIndex int, state *PieceState)": "safely updates piece state",
    "AddConnection(peerID string, conn *Connection)": "registers new peer connection",
    "RemoveConnection(peerID string)": "unregisters peer connection",
    "NewEventBus(ctx context.Context) *EventBus": "creates new event coordination system",
    "Subscribe(eventType EventType, bufferSize int) <-chan Event": "registers channel to receive events",
    "Publish(event Event)": "sends event to all subscribers",
    "HandleError(ctx context.Context, err error) RecoveryAction": "processes errors and determines recovery actions",
    "RecoverFromFailure(ctx context.Context, failureType ErrorType, component string) error": "executes recovery procedures",
    "ValidateMessageIntegrity(msg *Message, expectedType int, maxSize int) error": "validates peer protocol messages",
    "HandlePieceVerificationFailure(pieceIndex int, peerID string, data []byte) error": "manages data integrity failures",
    "HandleConnectionFailure(peerID string, err error) error": "manages peer connection failures",
    "NextDelay() time.Duration": "calculates next backoff delay",
    "Reset()": "resets backoff scheduler",
    "Execute(ctx context.Context, operation func() error) error": "executes operation through circuit breaker",
    "UpdateScore(peerID string, metric string, value float64)": "updates peer quality metrics",
    "NewBackoffScheduler(base, max time.Duration, multiplier float64) *BackoffScheduler": "creates backoff scheduler",
    "NewCircuitBreaker(name string, failureThreshold int, recoveryTimeout time.Duration) *CircuitBreaker": "creates circuit breaker",
    "NewPeerQualityScorer() *PeerQualityScorer": "creates peer quality scorer",
    "GenerateTestTorrent(config TestTorrentConfig) (*MetaInfo, error)": "creates a complete torrent file with known content for testing",
    "WriteTestFile(path string, content []byte) error": "creates the actual file content for a test torrent",
    "LoadTestTorrent(name string) (*MetaInfo, error)": "loads a pre-built test torrent from the fixtures directory",
    "NewMockTracker() *MockTracker": "creates a local HTTP server that implements tracker protocol",
    "SetResponse(infoHash string, response *TrackerResponse)": "configures the tracker response for a specific info hash",
    "GetRequests() []*TrackerRequest": "returns all announce requests received by the tracker",
    "URL() string": "returns the mock tracker's announce URL",
    "Close()": "shuts down the mock tracker server",
    "DefaultPeers() []MockPeer": "returns a standard set of mock peers for testing",
    "NewComponentLogger(component string) *ComponentLogger": "creates logger for specific component",
    "SetLevel(level LogLevel)": "configures minimum log level",
    "Debug(format string, args ...interface{})": "logs debug messages with context",
    "Info(format string, args ...interface{})": "logs informational messages",
    "Warn(format string, args ...interface{})": "logs warning messages",
    "Error(format string, args ...interface{})": "logs error messages",
    "RegisterComponent(name string, provider StateProvider)": "adds component for state inspection",
    "StartDebugServer(port int) error": "launches HTTP server for state inspection",
    "NewDebugDecoder(r io.Reader) *DebugDecoder": "creates decoder with comprehensive debugging",
    "DebugDecode() (interface{}, error)": "parses with extensive logging",
    "ValidateInfoHash(metaInfo *MetaInfo, expectedHex string) error": "compares calculated hash with expected value",
    "SetGlobalLevel(level LogLevel)": "sets log level for all components",
    "ParseMagnetLink(magnetURI string) (*MagnetLink, error)": "extracts components from magnet URI",
    "FetchMetadata() (*MetaInfo, error)": "retrieves complete torrent metadata from peers",
    "Announce(ctx context.Context, req AnnounceRequest) (*AnnounceResponse, error)": "DHT-based peer discovery",
    "HandleTorrents(w http.ResponseWriter, r *http.Request)": "provides GET /torrents endpoint",
    "HandleWebSocket(w http.ResponseWriter, r *http.Request)": "upgrades HTTP to WebSocket for real-time updates",
    "NewDHTClient(port int) (*Client, error)": "creates DHT client implementing tracker interface",
    "NewAPIServer(client *Client, port int) *Server": "creates HTTP server with REST and WebSocket endpoints"
  },
  "constants": {
    "PIECE_HASH_SIZE": "20 bytes for SHA-1 hash",
    "COMPACT_PEER_SIZE": "6 bytes for IP and port",
    "BLOCK_SIZE": "16384 bytes standard block size",
    "MAX_PEERS": "50 reasonable concurrent connection limit",
    "HANDSHAKE_LENGTH": "68 bytes for handshake message",
    "PROTOCOL_STRING": "BitTorrent protocol identifier",
    "TypeString": "bencode string type identifier",
    "TypeInteger": "bencode integer type identifier",
    "TypeList": "bencode list type identifier",
    "TypeDictionary": "bencode dictionary type identifier",
    "MAX_MESSAGE_LENGTH": "maximum allowed message size",
    "MsgChoke": "0",
    "MsgUnchoke": "1",
    "MsgInterested": "2",
    "MsgNotInterested": "3",
    "MsgHave": "4",
    "MsgBitfield": "5",
    "MsgRequest": "6",
    "MsgPiece": "7",
    "MsgCancel": "8",
    "MsgKeepAlive": "-1",
    "MAX_ENDGAME_PIECES": "threshold for endgame mode activation",
    "MAX_PIPELINE_DEPTH": "maximum outstanding requests per peer",
    "EventPeerConnected": "peer connection established event type",
    "EventPeerDisconnected": "peer connection terminated event type",
    "EventPieceCompleted": "piece download and verification completed event type",
    "EventBlockReceived": "block data received from peer event type",
    "EventTrackerResponse": "tracker announce response received event type",
    "EventDownloadComplete": "entire torrent download completed event type",
    "ErrorTypeNetwork": "network-related failures",
    "ErrorTypeProtocol": "protocol violation failures",
    "ErrorTypeData": "data integrity failures",
    "ErrorTypeTracker": "tracker communication failures",
    "ErrorTypeFileSystem": "file I/O failures",
    "ErrorTypeConcurrency": "race condition and synchronization failures",
    "CircuitClosed": "normal operation state",
    "CircuitOpen": "fail-fast state",
    "CircuitHalfOpen": "recovery testing state",
    "DEBUG": "debug log level",
    "INFO": "info log level",
    "WARN": "warning log level",
    "ERROR": "error log level",
    "BEP_3": "Message Stream Encryption specification",
    "BEP_5": "Distributed Hash Table specification",
    "BEP_6": "Fast Extension Protocol specification",
    "BEP_9": "Extension for Peers to Send Metadata Files",
    "KADEMLIA_K": "20 nodes per DHT bucket",
    "DHT_PORT": "6881 default DHT port",
    "METADATA_PIECE_SIZE": "16384 bytes for metadata pieces",
    "API_PORT": "8080 default API server port"
  },
  "terms": {
    "peer": "individual computer participating in BitTorrent swarm",
    "tracker": "central server that coordinates peer discovery for a torrent",
    "torrent file": "metadata file containing file info and tracker URL",
    "info hash": "SHA-1 hash of torrent's info dictionary used as unique identifier",
    "piece": "fixed-size chunk of file that can be independently verified",
    "swarm": "collection of all peers sharing a particular torrent",
    "bencode": "binary encoding format used by BitTorrent for structured data",
    "announce": "HTTP request to tracker reporting peer status and requesting peer list",
    "handshake": "initial 68-byte message establishing BitTorrent connection between peers",
    "choking": "mechanism where peer refuses to upload to another peer",
    "seeding": "uploading complete file pieces to other peers after download completion",
    "block": "16KB unit of network transfer within pieces",
    "bitfield": "bitmap indicating which pieces a peer has available",
    "compact peer format": "6-byte binary encoding of peer IP and port",
    "pipeline": "maintaining multiple outstanding requests for throughput optimization",
    "message framing": "length-prefixed protocol message parsing",
    "state machine": "four-flag system governing peer upload/download permissions",
    "rarest-first": "piece selection strategy prioritizing pieces held by fewest peers",
    "endgame mode": "aggressive final-piece downloading from all available peers",
    "verification": "SHA1 hash checking of downloaded pieces",
    "event bus": "message passing system for inter-component coordination",
    "shared state": "synchronized data structures accessible by multiple components",
    "lifecycle management": "coordinated startup and shutdown of system components",
    "graceful shutdown": "orderly termination allowing in-flight operations to complete",
    "concurrency coordination": "synchronization of multiple concurrent operations",
    "state synchronization": "maintaining consistency across concurrent operations",
    "exponential backoff": "retry delay strategy that increases delay exponentially",
    "circuit breaker": "pattern preventing repeated failures by failing fast",
    "peer quality scoring": "system for rating peer reliability and performance",
    "failure cascade": "when one failure triggers additional failures in other components",
    "graceful degradation": "system continues operating with reduced functionality during failures",
    "recovery strategy": "specific approach for recovering from different types of failures",
    "error wrapping": "technique for preserving error context while adding additional information",
    "jitter": "random variation added to timing to prevent synchronized behavior",
    "thundering herd": "problem where many clients retry simultaneously after failures",
    "graduated response": "escalating response severity based on failure frequency or severity",
    "unit testing": "testing individual components in isolation without external dependencies",
    "integration testing": "testing component interactions using controlled environments",
    "milestone checkpoints": "concrete verification criteria for each implementation phase",
    "mock tracker": "test implementation of tracker protocol for controlled testing",
    "test torrent": "specially crafted torrent with known content for verification",
    "controlled environment": "testing setup with predictable behavior and no external dependencies",
    "verification checkpoint": "specific criteria that must be met before proceeding to next milestone",
    "automated verification": "tests that run without manual intervention",
    "manual verification": "observable behavior inspection and output validation",
    "race condition": "concurrent access bugs in shared data",
    "deadlock": "circular waiting between goroutines",
    "protocol violation": "deviation from BitTorrent wire protocol",
    "memory leak": "accumulated resources not properly released",
    "goroutine leak": "goroutines that never terminate",
    "state machine debugging": "tracing peer protocol state transitions",
    "network traffic analysis": "examining raw protocol bytes",
    "systematic reproduction": "reliable bug reproduction methodology",
    "Distributed Hash Table": "decentralized peer discovery network eliminating tracker dependency",
    "magnet link": "metadata URL enabling instant sharing without torrent files",
    "Message Stream Encryption": "protocol encryption to avoid ISP throttling and deep packet inspection",
    "multi-tracker support": "redundant tracker configuration with tier-based fallback",
    "rarest-first algorithm": "piece selection strategy prioritizing pieces held by fewest peers",
    "bandwidth management": "adaptive allocation and traffic shaping for network optimization",
    "connection pooling": "maintaining reusable connections across multiple torrents",
    "token bucket algorithm": "smooth rate limiting allowing controlled bursts",
    "WebSocket": "persistent bidirectional communication for real-time updates",
    "Single Page Application": "client-side rendering with AJAX communication",
    "DHT bootstrap": "initial connection to well-known DHT nodes",
    "metadata fetching": "retrieving torrent info from peers using Extension Protocol",
    "piece clustering": "grouping adjacent pieces for streaming playback support",
    "congestion control": "adaptive rate adjustment based on network conditions"
  }
}