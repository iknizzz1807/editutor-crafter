{
  "title": "CI/CD Pipeline Orchestrator: Design Document",
  "overview": "This document outlines the design for a custom Continuous Integration (CI) system that automatically runs defined test and build pipelines in response to code changes. The key architectural challenge is orchestrating isolated, parallel job executions reliably while providing real-time feedback to developers, balancing simplicity for educational purposes with the core patterns used in production systems like GitHub Actions.",
  "sections": [
    {
      "id": "1-context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains the core problem of automating software integration tasks, introduces the mental model of an automated factory assembly line, and compares existing CI approaches.",
      "subsections": [
        {
          "id": "1.1-analogy",
          "title": "Mental Model: The Automated Factory Floor",
          "summary": "Frames the CI system as a factory where code changes are work orders that trigger assembly lines (pipelines) with robotic stations (jobs) performing isolated tasks."
        },
        {
          "id": "1.2-problem",
          "title": "The Core Integration Problem",
          "summary": "Describes the manual pain of running tests and builds, the need for isolation, consistency, and immediate feedback."
        },
        {
          "id": "1.3-existing-approaches",
          "title": "Survey of Existing CI Systems",
          "summary": "Compares hosted (GitHub Actions) vs. self-hosted (Jenkins) models, and monolithic vs. distributed architectures in a structured table."
        }
      ]
    },
    {
      "id": "2-goals-nongoals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the scope of the project, listing required features and explicitly out-of-scope items to focus the implementation.",
      "subsections": [
        {
          "id": "2.1-goals",
          "title": "Goals (Must Have)",
          "summary": "List of core capabilities: YAML config parsing, containerized job execution, webhook handling, job queuing, and a basic web dashboard."
        },
        {
          "id": "2.2-nongoals",
          "title": "Non-Goals (Out of Scope)",
          "summary": "Explicitly excludes features like distributed workers across machines, complex secret management, or a full-featured SaaS UI."
        }
      ]
    },
    {
      "id": "3-high-level-arch",
      "title": "High-Level Architecture",
      "summary": "Provides a bird's-eye view of the system's major components, their responsibilities, and how they connect, accompanied by a component diagram.",
      "subsections": [
        {
          "id": "3.1-component-overview",
          "title": "Component Map and Responsibilities",
          "summary": "Describes the four main subsystems: Webhook Listener, Orchestrator, Worker Pool, and Dashboard."
        },
        {
          "id": "3.2-communication-flows",
          "title": "How Components Connect",
          "summary": "Explains the primary data flows: webhook \u2192 queue \u2192 orchestrator \u2192 worker \u2192 dashboard."
        },
        {
          "id": "3.3-file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Suggests a Go module layout to organize the codebase by component, separating interfaces, core logic, and infrastructure."
        }
      ]
    },
    {
      "id": "4-data-model",
      "title": "Data Model",
      "summary": "Defines the core data structures (Pipeline, Job, Step, Run) that flow through the system, their relationships, and persistence strategy.",
      "subsections": [
        {
          "id": "4.1-core-entities",
          "title": "Core Types and Structures",
          "summary": "Tables describing the fields and types for Pipeline Config, Pipeline Run, Job Run, and Step Run."
        },
        {
          "id": "4.2-relationships-lifecycle",
          "title": "Relationships and Lifecycle",
          "summary": "Explains how entities relate (e.g., a PipelineRun contains multiple JobRuns) and their state transitions."
        },
        {
          "id": "4.3-storage-strategy",
          "title": "Storage Strategy ADR",
          "summary": "Architecture Decision Record on using SQLite for simplicity vs. a dedicated database, including trade-offs."
        }
      ]
    },
    {
      "id": "5-component-parser",
      "title": "Component: Pipeline Configuration Parser (Milestone 1)",
      "summary": "Details the component responsible for reading and validating YAML pipeline files, constructing an executable dependency graph.",
      "subsections": [
        {
          "id": "5.1-mental-model",
          "title": "Mental Model: The Blueprint Interpreter",
          "summary": "Analogy to an architect interpreting blueprint drawings (YAML) into a precise list of construction tasks with dependencies."
        },
        {
          "id": "5.2-interface",
          "title": "Interface and API",
          "summary": "Table of methods like ParseConfig, ResolveEnvVars, and ExpandMatrix."
        },
        {
          "id": "5.3-behavior",
          "title": "Internal Behavior and Algorithm",
          "summary": "Numbered steps for parsing YAML, validating structure, resolving variables, expanding matrices, and building the execution DAG."
        },
        {
          "id": "5.4-adr-yaml",
          "title": "ADR: YAML vs. Custom DSL for Configuration",
          "summary": "Decision record comparing YAML, JSON, and a custom DSL for pipeline definition."
        },
        {
          "id": "5.5-pitfalls-parser",
          "title": "Common Pitfalls: Parser",
          "summary": "Discusses issues like circular dependencies, insecure env var substitution, and combinatorial explosion in matrix builds."
        },
        {
          "id": "5.6-impl-guidance",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for YAML unmarshaling helpers and skeleton code with TODOs for DAG construction and matrix expansion."
        }
      ]
    },
    {
      "id": "6-component-execution",
      "title": "Component: Job Execution Engine (Milestone 2)",
      "summary": "Details the component that runs individual job steps in isolated Docker containers, manages resources, and collects artifacts.",
      "subsections": [
        {
          "id": "6.1-mental-model",
          "title": "Mental Model: The Sandboxed Playground",
          "summary": "Analogy to providing each job with a fresh, identical sandbox (container) where it can play (run commands) without affecting others."
        },
        {
          "id": "6.2-interface",
          "title": "Interface and API",
          "summary": "Table of methods like ExecuteJob, StreamLogs, and CollectArtifacts."
        },
        {
          "id": "6.3-behavior",
          "title": "Internal Behavior and Algorithm",
          "summary": "Numbered steps for pulling images, creating containers, executing sequential commands, capturing output, and handling cleanup."
        },
        {
          "id": "6.4-adr-isolation",
          "title": "ADR: Container vs. Process Isolation",
          "summary": "Decision record comparing Docker containers, Linux namespaces/cgroups, and simple subprocess execution for isolation."
        },
        {
          "id": "6.5-pitfalls-execution",
          "title": "Common Pitfalls: Execution Engine",
          "summary": "Discusses zombie containers, log stream blocking, artifact path errors, and timeout management."
        },
        {
          "id": "6.6-impl-guidance",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for a Docker client wrapper and skeleton code with TODOs for step execution and log streaming."
        }
      ]
    },
    {
      "id": "7-component-webhook-queue",
      "title": "Component: Webhook & Queue System (Milestone 3)",
      "summary": "Details the component that accepts Git webhooks, validates them, and manages a queue of pending pipeline runs for workers.",
      "subsections": [
        {
          "id": "7.1-mental-model",
          "title": "Mental Model: The Restaurant Host and Kitchen Ticket Rail",
          "summary": "Analogy to a host (webhook handler) seating customers (events) and placing their orders (jobs) on a ticket rail (queue) for chefs (workers)."
        },
        {
          "id": "7.2-interface",
          "title": "Interface and API",
          "summary": "Table of methods like HandleWebhook, EnqueueRun, and DequeueJob."
        },
        {
          "id": "7.3-behavior",
          "title": "Internal Behavior and Algorithm",
          "summary": "Numbered steps for webhook signature verification, payload parsing, pipeline matching, run creation, and queue dispatch."
        },
        {
          "id": "7.4-adr-queue",
          "title": "ADR: In-Memory vs. Persistent Queue Backend",
          "summary": "Decision record comparing an in-memory channel, Redis, and PostgreSQL for job queuing."
        },
        {
          "id": "7.5-pitfalls-queue",
          "title": "Common Pitfalls: Webhook & Queue",
          "summary": "Discusses webhook replay attacks, queue starvation, lost jobs on crash, and concurrent worker coordination."
        },
        {
          "id": "7.6-impl-guidance",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for HTTP webhook handlers and skeleton code with TODOs for a priority queue and worker pool management."
        }
      ]
    },
    {
      "id": "8-component-dashboard",
      "title": "Component: Web Dashboard (Milestone 4)",
      "summary": "Details the component that provides a web interface for viewing pipeline runs, real-time logs, and visualizations.",
      "subsections": [
        {
          "id": "8.1-mental-model",
          "title": "Mental Model: The Airport Flight Display Board",
          "summary": "Analogy to a display board showing flight status (builds), gates (jobs), and live updates (logs) for passengers (developers)."
        },
        {
          "id": "8.2-interface",
          "title": "Interface and API",
          "summary": "Table of HTTP endpoints like GET /api/runs, GET /api/runs/:id/logs, and GET /badge/:repo.svg."
        },
        {
          "id": "8.3-behavior",
          "title": "Internal Behavior and Algorithm",
          "summary": "Numbered steps for serving static assets, streaming logs via Server-Sent Events (SSE), generating SVG badges, and rendering the DAG visualization."
        },
        {
          "id": "8.4-adr-realtime",
          "title": "ADR: Real-time Log Streaming: WebSockets vs. Server-Sent Events",
          "summary": "Decision record comparing WebSockets and SSE for pushing log output to the browser."
        },
        {
          "id": "8.5-pitfalls-dashboard",
          "title": "Common Pitfalls: Dashboard",
          "summary": "Discusses browser connection limits, log backpressure, SVG caching headers, and cross-origin requests."
        },
        {
          "id": "8.6-impl-guidance",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for a basic HTTP server with SSE helpers and skeleton code with TODOs for the DAG visualization and badge generation."
        }
      ]
    },
    {
      "id": "9-interactions-flow",
      "title": "Interactions and Data Flow",
      "summary": "Traces the journey of a code push through the entire system with sequence diagrams and message format definitions.",
      "subsections": [
        {
          "id": "9.1-happy-path",
          "title": "Happy Path: From Push to Pipeline Completion",
          "summary": "Step-by-step walkthrough of a successful pipeline run triggered by a git push."
        },
        {
          "id": "9.2-message-formats",
          "title": "Message and Event Formats",
          "summary": "Tables defining the structure of webhook payloads, queue messages, and internal events."
        },
        {
          "id": "9.3-concurrency-patterns",
          "title": "Concurrency and Parallelism Patterns",
          "summary": "Explains how parallel stages and matrix jobs are coordinated."
        }
      ]
    },
    {
      "id": "10-error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Catalogues potential failure modes across components and defines recovery and mitigation strategies.",
      "subsections": [
        {
          "id": "10.1-failure-modes",
          "title": "Categorized Failure Modes",
          "summary": "Lists failures in parsing, execution, queue, and network, with detection mechanisms."
        },
        {
          "id": "10.2-recovery-strategy",
          "title": "Recovery and Retry Strategy",
          "summary": "Defines retry policies for transient failures (e.g., network timeouts) and cleanup procedures for stuck resources."
        },
        {
          "id": "10.3-user-notification",
          "title": "User-Facing Error Reporting",
          "summary": "Describes how errors are surfaced in the dashboard and logs for debugging."
        }
      ]
    },
    {
      "id": "11-testing-strategy",
      "title": "Testing Strategy",
      "summary": "Outlines a practical testing approach for the CI system itself, including milestone verification checkpoints.",
      "subsections": [
        {
          "id": "11.1-test-pyramid",
          "title": "Testing Pyramid for a CI System",
          "summary": "Recommends unit tests for parsers, integration tests with a Docker daemon, and end-to-end tests with a mock git server."
        },
        {
          "id": "11.2-milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "For each milestone, describes commands to run and expected outputs to confirm correct implementation."
        }
      ]
    },
    {
      "id": "12-debugging-guide",
      "title": "Debugging Guide",
      "summary": "Provides a symptom-cause-fix table for common bugs learners encounter, along with domain-specific debugging techniques.",
      "subsections": [
        {
          "id": "12.1-symptom-table",
          "title": "Common Bugs: Symptom \u2192 Cause \u2192 Fix",
          "summary": "Table addressing issues like 'Webhooks are ignored', 'Jobs hang forever', 'Logs stop streaming', and 'Artifacts missing'."
        },
        {
          "id": "12.2-techniques-tools",
          "title": "Debugging Techniques and Tools",
          "summary": "Suggests using `docker ps` to check containers, inspecting queue tables, and adding strategic log statements."
        }
      ]
    },
    {
      "id": "13-future-extensions",
      "title": "Future Extensions",
      "summary": "Suggests possible enhancements to the system, evaluating how the current design accommodates or would need to change for each.",
      "subsections": [
        {
          "id": "13.1-easy-additions",
          "title": "Low-Effort Extensions",
          "summary": "Ideas like supporting more Git providers (Bitbucket), adding job timeout configuration, or manual pipeline triggers."
        },
        {
          "id": "13.2-major-enhancements",
          "title": "Major Enhancements",
          "summary": "Ideas like distributed workers across machines, a plugin ecosystem, or persistent workflow caches."
        }
      ]
    },
    {
      "id": "14-glossary",
      "title": "Glossary",
      "summary": "Defines key terms, acronyms, and domain-specific vocabulary used throughout the document.",
      "subsections": [
        {
          "id": "14.1-terms",
          "title": "Terminology Reference",
          "summary": "Table of terms like CI/CD, Pipeline, Stage, Job, Step, Artifact, Webhook, DAG, and Matrix Build."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "diag-system-component",
      "title": "High-Level System Component Diagram",
      "description": "Shows the four main subsystems (Webhook Listener, Orchestrator/Queue, Worker Pool, Dashboard API) and their interactions. Include external systems: Git Host, Docker Daemon, and User's Browser. Arrows should indicate HTTP calls, queue messages, and log streams.",
      "type": "component",
      "relevant_sections": [
        "3-high-level-arch",
        "9-interactions-flow"
      ]
    },
    {
      "id": "diag-data-model",
      "title": "Data Model Relationship Diagram",
      "description": "A class diagram showing core entities: PipelineConfig, PipelineRun, JobRun, StepRun. Show composition relationships (PipelineRun has many JobRuns) and fields like ID, status, timestamps, and references.",
      "type": "class",
      "relevant_sections": [
        "4-data-model"
      ]
    },
    {
      "id": "diag-parser-flowchart",
      "title": "Pipeline Configuration Parsing and DAG Construction",
      "description": "A flowchart detailing the steps from raw YAML to an executable DAG. Steps include: Load File, Parse YAML, Validate Structure, Resolve Environment Variables, Expand Matrix, Build Dependency Graph, Output Execution Plan.",
      "type": "flowchart",
      "relevant_sections": [
        "5-component-parser"
      ]
    },
    {
      "id": "diag-job-state-machine",
      "title": "Job Run State Machine",
      "description": "A state machine diagram for a JobRun. States: Pending, Running, Succeeded, Failed, Cancelled, Skipped. Events: start, finish(success), finish(error), cancel.",
      "type": "state-machine",
      "relevant_sections": [
        "4-data-model",
        "6-component-execution"
      ]
    },
    {
      "id": "diag-webhook-sequence",
      "title": "Sequence: Webhook to Job Execution",
      "description": "Sequence diagram showing actors: Git Host, Webhook Listener, Queue, Orchestrator, Worker, Docker. Messages: HTTP POST webhook, enqueue run, dequeue job, create container, execute commands, update status.",
      "type": "sequence",
      "relevant_sections": [
        "7-component-webhook-queue",
        "9-interactions-flow"
      ]
    },
    {
      "id": "diag-dashboard-component",
      "title": "Web Dashboard Component Breakdown",
      "description": "Component diagram for the dashboard subsystem. Show frontend (HTML/JS), backend API server, WebSocket/SSE connection for logs, and connections to the main system's database for run history.",
      "type": "component",
      "relevant_sections": [
        "8-component-dashboard"
      ]
    }
  ]
}