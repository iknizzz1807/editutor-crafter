shape: sequence_diagram
title: "Read/Write Operation Sequence Diagram: Quorum Consistency with Retries"

# Actors
client: Client
coordinator: Coordinator
primary: Primary Replica
secondary1: Secondary Replica 1
secondary2: Secondary Replica 2

# Styling
client.style.fill: "#0f3460"
coordinator.style.fill: "#16213e"
primary.style.fill: "#16213e"
secondary1.style.fill: "#16213e"
secondary2.style.fill: "#16213e"

all.style.font-color: "#e6edf3"
all.style.stroke: "#8b949e"

# Important message styling
coordinator -> primary: Write Request {
  style.stroke: "#3fb950"
  style.bold: true
}

primary -> coordinator: Write ACK {
  style.stroke: "#3fb950"
  style.bold: true
}

coordinator -> client: Success {
  style.stroke: "#3fb950"
  style.bold: true
}

# WRITE OPERATION SEQUENCE
client -> coordinator: 1. Write(key, value) {
  style.stroke: "#3fb950"
}
note: |md
  **Write Operation Started**
  Client initiates write with
  desired consistency level
| {
  shape: page
  style.fill: "#1a1a2e"
}

coordinator -> primary: 2. Forward Write(key, value) {
  style.stroke: "#3fb950"
  style.bold: true
}

primary -> secondary1: 3. Replicate(key, value)
primary -> secondary2: 3. Replicate(key, value)

secondary1 -> primary: 4. ACK Replication
secondary2 -> primary: 4. ACK Replication

note: |md
  **Quorum Check**
  Primary waits for W-1 ACKs
  (W = write quorum size)
| {
  shape: page
  style.fill: "#1a1a2e"
}

primary -> coordinator: 5. Write ACK {
  style.stroke: "#3fb950"
  style.bold: true
}
coordinator -> client: 6. Success

# READ OPERATION SEQUENCE
client -> coordinator: 7. Read(key) {
  style.stroke: "#3fb950"
}
note: |md
  **Read Operation Started**
  Client requests read with
  desired consistency level
| {
  shape: page
  style.fill: "#1a1a2e"
}

coordinator -> primary: 8. Request Value(key)
coordinator -> secondary1: 8. Request Value(key)
coordinator -> secondary2: 8. Request Value(key)

secondary1 -> coordinator: 9. Response(value, version)
secondary2 -> coordinator: 9. Response(value, version)

note: |md
  **Quorum & Version Resolution**
  Coordinator waits for R responses
  (R = read quorum size),
  picks latest version
| {
  shape: page
  style.fill: "#1a1a2e"
}

primary -> coordinator: 10. Response(value, version) {
  style.stroke: "#3fb950"
  style.bold: true
}

coordinator -> client: 11. Return Value

# TIMEOUT AND RETRY LOGIC
secondary2.style.fill: "#d63031"
secondary2.style.stroke: "#e17055"
coordinator -> secondary2: 12. Retry Request (after timeout) {
  style.stroke: "#e17055"
  style.stroke-dash: 3
}

secondary2 -> coordinator: 13. Response(value, version) {
  style.stroke: "#e17055"
}

note: |md
  **Retry Logic**
  If replica times out or fails,
  coordinator retries with
  another replica or fails
  the operation if quorum
  cannot be achieved
| {
  shape: page
  style.fill: "#1a1a2e"
  style.stroke: "#e17055"
}

# ERROR SCENARIO
secondary1.style.fill: "#d63031"
secondary1.style.stroke: "#e17055"
secondary1 -> coordinator: 14. Error Response {
  style.stroke: "#e17055"
}

note: |md
  **Error Handling**
  Failed responses are logged
  and may trigger replica
  health checks
| {
  shape: page
  style.fill: "#1a1a2e"
  style.stroke: "#e17055"
}

# CONCURRENCY NOTE
note: |md
  **Concurrency Notes:**
  - Write operations lock key at primary
  - Read operations use versioning
  - Quorum: W + R > N ensures consistency
| {
  shape: page
  style.fill: "#1a1a2e"
  style.stroke: "#3fb950"
}