{
  "types": {
    "DNSMessage": "fields: Header Header, Questions []Question, Answers []ResourceRecord, Authority []ResourceRecord, Additional []ResourceRecord",
    "Header": "fields: ID uint16, QueryResponse bool, Opcode uint8, Authoritative bool, Truncated bool, RecursionDesired bool, RecursionAvail bool, ResponseCode uint8, QuestionCount uint16, AnswerCount uint16, AuthorityCount uint16, AdditionalCount uint16",
    "Question": "fields: Name string, Type uint16, Class uint16",
    "ResourceRecord": "fields: Name string, Type uint16, Class uint16, TTL uint32, Data []byte",
    "Server": "addr string, conn net.PacketConn, resolver Resolver, handler MessageHandler",
    "Config": "fields: Server ServerConfig, Cache CacheConfig, Zones []ZoneConfig",
    "ServerConfig": "fields: ListenAddr string, Timeout string",
    "CacheConfig": "fields: MaxSize int, DefaultTTL string",
    "ZoneConfig": "fields: Domain string, File string, Type string",
    "CacheKey": "fields: Name string, Type uint16, Class uint16",
    "CacheEntry": "fields: Records []ResourceRecord, ExpiresAt time.Time, Negative bool, SOARecord *ResourceRecord, HitCount uint64, Size int",
    "MessageHandler": "interface for processing DNS queries",
    "ResolverConfig": "fields: RootHints []string, Timeout time.Duration, MaxDepth int, EnableRecursion bool",
    "CacheStats": "fields: HitRate float64, TotalQueries uint64, CacheHits uint64, CacheMisses uint64, EntryCount int, MemoryUsage int64, EvictionCount uint64",
    "parseState": "fields: data []byte, offset int, visited map[int]bool, jumpCount int",
    "ZoneData": "Origin string, DefaultTTL uint32, SOA *ResourceRecord, Records map[string]map[uint16][]ResourceRecord, NSRecords map[string][]ResourceRecord",
    "AuthoritativeServer": "fields: zones map[string]*ZoneData, config *AuthConfig",
    "AuthConfig": "fields: ZoneFiles map[string]string, DefaultTTL uint32, SOARefresh uint32, SOARetry uint32, SOAExpire uint32, SOAMinimum uint32",
    "ZoneParser": "fields: origin string, defaultTTL uint32, lastDomain string, lineNum int",
    "RecursiveResolver": "fields: config *ResolverConfig, cache *CacheManager, client *NetworkClient, rootHints *RootHints",
    "ResolutionState": "fields: originalQuestion Question, currentQuestion Question, queryCount int, visitedServers map[string]bool, cnameChain []string",
    "RootHints": "fields: servers []string, current int",
    "NetworkClient": "conn net.PacketConn, timeout time.Duration",
    "CacheManager": "fields: mu sync.RWMutex, cache map[CacheKey]*CacheEntry, maxEntries int, maxMemory int64, stats CacheStats, cleanupTicker *time.Ticker, stopCleanup chan struct{}",
    "QueryCoalescer": "mu sync.Mutex, inFlight map[CacheKey]chan *DNSMessage",
    "DNSError": "Code uint8, Message string, Underlying error, Timestamp time.Time, Source string",
    "RetryableError": "Underlying error, RetryAfter time.Duration, Attempts int",
    "NetworkError": "ServerAddr string, Operation string, Underlying error, Timeout bool",
    "ErrorResponseBuilder": "logger *log.Logger",
    "RetryConfig": "MaxAttempts int, InitialDelay time.Duration, MaxDelay time.Duration, BackoffFactor float64, RetryableErrors map[string]bool",
    "NetworkRetryHandler": "config RetryConfig",
    "TestMessageBuilder": "fields: msg *DNSMessage",
    "MockNetworkClient": "fields: responses map[string][]byte, delays map[string]time.Duration, errors map[string]error",
    "MilestoneChecker": "fields: serverAddr string, client *dns.Client",
    "Metrics": "fields: QueriesReceived uint64, ResponsesSent uint64, ParseErrors uint64, ResolutionErrors uint64, CacheHits uint64, CacheMisses uint64, RecursiveQueries uint64, AuthoritativeHits uint64",
    "Logger": "fields: component string, enabled map[string]bool",
    "MetricsCollector": "fields: queriesReceived uint64, cacheHits uint64, resolutionLatency prometheus.Histogram",
    "DebugServer": "fields: metrics *MetricsCollector, logger *Logger",
    "ConfigLoader": "fields: configPath string, current *ServerConfig, watchers []func(*ServerConfig)",
    "DNSSECValidator": "DNSSEC signature validation component",
    "TLSServer": "DNS-over-TLS transport server"
  },
  "methods": {
    "ParseMessage(data []byte) (*DNSMessage, error)": "parses complete DNS message from wire format",
    "parseHeader(data []byte) (Header, error)": "extracts 12-byte header from DNS message",
    "NewServer(addr, resolver, handler) *Server": "creates DNS server instance",
    "Start(ctx) error": "begins listening for DNS queries",
    "handleQuery(queryData, clientAddr)": "processes individual DNS query",
    "LoadConfig(filepath) (*Config, error)": "loads server configuration from YAML file",
    "SerializeMessage(msg *DNSMessage) ([]byte, error)": "convert DNS message to wire format",
    "parseName(data []byte, offset int) (string, int, error)": "parse DNS name with compression support",
    "ValidateMessage(msg *DNSMessage) error": "performs comprehensive DNS message validation",
    "ResolveQuery(ctx context.Context, question Question) (*DNSMessage, error)": "perform complete recursive resolution",
    "LookupAuthoritative(question Question) ([]ResourceRecord, error)": "check local zone data for authoritative answer",
    "LookupCache(name string, recordType uint16) (*CacheEntry, bool)": "retrieve cached record if present and not expired",
    "PerformRecursion(ctx context.Context, question Question) (*DNSMessage, error)": "execute iterative resolution from root servers",
    "FollowCNAME(ctx context.Context, cname string, originalType uint16) ([]ResourceRecord, error)": "resolve CNAME chain to final records",
    "Get(key CacheKey) (*CacheEntry, bool)": "retrieve cache entry if present and not expired",
    "Put(key CacheKey, records []ResourceRecord, ttl uint32) error": "store records with TTL-based expiration",
    "PutNegative(key CacheKey, soaRecord ResourceRecord) error": "cache negative response with SOA-derived TTL",
    "Evict(key CacheKey) bool": "remove specific entry from cache",
    "Cleanup() int": "remove expired entries and return count freed",
    "Stats() CacheStats": "return cache hit rate, size, and memory usage statistics",
    "parseHeader(state *parseState) (Header, error)": "extracts 12-byte header from DNS message",
    "parseName(state *parseState) (string, error)": "parse DNS name with compression support",
    "parseQuestion(state *parseState) (Question, error)": "extracts single question from questions section",
    "parseResourceRecord(state *parseState) (ResourceRecord, error)": "extracts single resource record from sections",
    "newParseState(data []byte) *parseState": "create parser state for message",
    "canRead(bytes int) bool": "check if enough bytes remain",
    "readByte() (byte, error)": "read single byte and advance",
    "readUint16() (uint16, error)": "read 16-bit network byte order value",
    "readUint32() (uint32, error)": "read 32-bit network byte order value",
    "readBytes(count int) ([]byte, error)": "read specified number of bytes",
    "ProcessQuery(ctx context.Context, query *DNSMessage) (*DNSMessage, error)": "Main entry point for query processing",
    "findAuthoritativeZone(domain string) (*ZoneData, bool)": "determine zone authority for domain",
    "matchRecords(zone *ZoneData, domain string, qtype uint16) ([]ResourceRecord, string)": "find matching records in zone data",
    "buildResponse(query *DNSMessage, zone *ZoneData, records []ResourceRecord, matchType string) *DNSMessage": "construct DNS response message",
    "populateAuthoritySections(response *DNSMessage, zone *ZoneData, matchType string, queryName string)": "add authority and additional section records",
    "ParseZoneFile(reader io.Reader, origin string) (*ZoneData, error)": "parse BIND format zone file",
    "parseLine(zone *ZoneData, line string) error": "process single zone file line",
    "parseDirective(line string) error": "handle $ORIGIN and $TTL directives",
    "canonicalizeName(name string) string": "normalize domain names to lowercase with trailing dot",
    "parseTTL(ttlStr string) (uint32, error)": "convert TTL strings with unit suffixes to seconds",
    "PerformIterativeResolution(state *ResolutionState) ([]ResourceRecord, error)": "follow DNS hierarchy from root to authoritative",
    "QueryServer(ctx context.Context, query []byte, serverIP string) ([]byte, error)": "simulates DNS query with configured behavior",
    "NextServer() string": "get next root server IP",
    "validateResponse(query *DNSMessage, response *DNSMessage, serverIP string) error": "check response correctness and security",
    "CoalesceQuery(ctx context.Context, key CacheKey, resolveFunc func() (*DNSMessage, error)) (*DNSMessage, error)": "share resolution work between concurrent identical queries",
    "NewCacheManager(maxEntries int, maxMemory int64, cleanupInterval time.Duration) *CacheManager": "creates cache manager with specified limits",
    "backgroundCleanup()": "periodic goroutine to remove expired cache entries",
    "handleQuery(queryData []byte, clientAddr net.Addr)": "processes individual DNS query",
    "LookupCache(key CacheKey) (*CacheEntry, bool)": "retrieve cached record if present and not expired",
    "FindZone(domain string) (*ZoneData, bool)": "finds authoritative zone for domain",
    "LoadZone(config ZoneConfig) error": "loads zone file into memory",
    "RecoverFromParseError(state *parseState, err error) error": "attempts to recover parsing after encountering an error",
    "BuildErrorResponse(query *DNSMessage, err error) *DNSMessage": "creates DNS response for various error conditions",
    "ExecuteWithRetry(ctx context.Context, operation func() (*DNSMessage, error)) (*DNSMessage, error)": "performs DNS network operation with intelligent retry logic",
    "IsRetryableError(err error) bool": "determines if error should trigger retry logic",
    "NewFormatError(msg string, err error) *DNSError": "constructor for DNS format errors",
    "NewServerFailure(msg string, err error) *DNSError": "constructor for DNS server failure errors",
    "NewNameError(msg string) *DNSError": "constructor for DNS name errors",
    "determineResponseCode(err error) uint8": "maps error types to DNS response codes",
    "logError(query *DNSMessage, err error)": "logs DNS errors for monitoring",
    "NewTestMessage() *TestMessageBuilder": "creates builder for test DNS messages",
    "AddQuestion(name string, qtype uint16) *TestMessageBuilder": "adds question to test message",
    "AddAnswer(name string, rtype uint16, ttl uint32, data []byte) *TestMessageBuilder": "adds resource record to answer section",
    "Build() *DNSMessage": "returns constructed DNS message",
    "ToWireFormat() []byte": "serializes test message to binary format",
    "NewMockNetworkClient() *MockNetworkClient": "creates mock for network testing",
    "AddResponse(pattern string, response []byte)": "configures mock response for query pattern",
    "AddDelay(serverIP string, delay time.Duration)": "simulates network latency",
    "AddError(serverIP string, err error)": "simulates network failures",
    "CheckMilestone1() error": "automated verification for parsing milestone",
    "CheckMilestone2() error": "automated verification for authoritative milestone",
    "CheckMilestone3() error": "automated verification for recursive milestone",
    "CheckMilestone4() error": "automated verification for caching milestone",
    "NewLogger(component string) *Logger": "creates logger with component context",
    "Error(msg string, fields map[string]interface{})": "logs error level message with fields",
    "Warn(msg string, fields map[string]interface{})": "logs warning level message with fields",
    "Info(msg string, fields map[string]interface{})": "logs info level message with fields",
    "Debug(msg string, fields map[string]interface{})": "logs debug level message with fields",
    "IncrementQueriesReceived()": "atomically increments queries received counter",
    "IncrementCacheHits()": "atomically increments cache hit counter",
    "GetMetrics() Metrics": "returns current metrics snapshot",
    "ValidateResponse(response *DNSMessage, question Question) error": "performs DNSSEC validation on DNS response",
    "HandleConnection(conn net.Conn) error": "processes DNS queries over encrypted transport",
    "ExportPrometheusMetrics() string": "formats metrics in Prometheus exposition format",
    "RecordQuery()": "increments queries received counter",
    "Load() error": "reads and parses configuration file",
    "StartWatching() error": "begins monitoring config file for changes"
  },
  "constants": {
    "DNS_HEADER_SIZE": "12 bytes",
    "DNS_UDP_MAX_SIZE": "512 bytes maximum UDP packet size",
    "DEFAULT_PORT": "53 - standard DNS port",
    "TYPE_A": "1 - IPv4 address record",
    "TYPE_AAAA": "28 - IPv6 address record",
    "TYPE_CNAME": "5 - canonical name record",
    "RCODE_NXDOMAIN": "name error response code",
    "RCODE_SERVFAIL": "server failure response code",
    "RCODE_FORMERR": "format error response code",
    "RCODE_REFUSED": "refused response code"
  },
  "terms": {
    "recursive resolver": "DNS server performing complete resolution from root servers",
    "authoritative server": "DNS server with definitive knowledge of specific domains",
    "forwarding server": "DNS server that relays all queries to upstream servers",
    "iterative resolution": "process of following referrals from root to authoritative",
    "zone data": "authoritative DNS records from configuration files",
    "TTL": "time-to-live value controlling cache expiration",
    "root hints": "IP addresses of DNS root servers for bootstrapping resolution",
    "name compression": "DNS message optimization using pointer labels",
    "glue records": "A records for NS names to avoid circular dependencies",
    "wire format": "binary DNS message format for network transmission",
    "negative caching": "caching NXDOMAIN and NODATA responses",
    "bailiwick": "domain hierarchy validation for cache poisoning prevention",
    "resource record": "DNS data entry with name, type, class, TTL and data",
    "compression pointer": "2-byte reference to previously encoded domain name",
    "pointer labels": "DNS labels beginning with 0xC0 that reference other message locations",
    "network byte order": "big-endian byte ordering used in DNS messages",
    "label length encoding": "DNS name format with length-prefixed components",
    "parse state": "tracking structure for current parsing position and context",
    "bounds checking": "validation that operations don't exceed buffer limits",
    "loop detection": "mechanism to prevent infinite loops in recursive operations",
    "CNAME following": "resolving alias chains to final target records",
    "circular dependency": "situation where nameserver resolution requires itself",
    "referral": "NS records pointing to next level of DNS hierarchy",
    "cache poisoning": "injection of false DNS data into cache",
    "LRU eviction": "least recently used cache replacement policy",
    "query coalescing": "sharing resolution work between concurrent identical queries",
    "read-write mutex": "synchronization primitive allowing concurrent reads and exclusive writes",
    "atomic operations": "thread-safe operations for statistics without locks",
    "expiration timestamp": "absolute time when cache entry becomes invalid",
    "SOA minimum": "field in SOA record specifying negative cache TTL",
    "cache manager": "component responsible for TTL-based caching and memory management",
    "message handler": "component coordinating query processing between resolution strategies",
    "zone data manager": "component managing authoritative DNS records from zone files",
    "query processing pipeline": "sequence of operations from packet receipt to response transmission",
    "component interface contracts": "method signatures and data exchange formats between major components",
    "context propagation": "passing timeout and cancellation through component calls",
    "error semantic mapping": "converting internal errors to appropriate DNS response codes",
    "cache integration": "thread-safe access to cached records with TTL management",
    "concurrent query handling": "processing multiple DNS requests simultaneously",
    "resolution priority": "order of authoritative, cache, and recursive lookup attempts",
    "parse errors": "failures during binary-to-structure conversion of DNS messages",
    "network errors": "failures during DNS message transmission and reception",
    "resolution errors": "failures during DNS business logic processing",
    "protocol violations": "deviations from DNS RFC specifications in messages",
    "malformed queries": "DNS queries that violate protocol structure",
    "compression loops": "circular references in DNS name compression pointers",
    "truncation": "DNS mechanism for handling oversized UDP responses",
    "error boundaries": "isolation points that prevent error propagation",
    "retry logic": "automated mechanisms for recovering from transient failures",
    "exponential backoff": "retry delay strategy that increases delay after each failure",
    "circuit breaking": "pattern that prevents cascading failures by stopping requests to failing services",
    "unit testing": "testing individual components in isolation",
    "integration testing": "testing component interactions",
    "milestone checkpoints": "verification steps for each development phase",
    "mock network client": "simulated network infrastructure for testing",
    "TTL expiration": "time-based cache entry invalidation",
    "concurrent testing": "validation of thread-safe behavior",
    "cache hit rate": "percentage of queries served from cache",
    "race conditions": "timing-dependent bugs in concurrent code",
    "compression loop": "circular references in DNS pointer labels create infinite loops",
    "thundering herd": "massive duplicate queries during cache misses",
    "DNSSEC": "DNS Security Extensions providing cryptographic authentication",
    "EDNS": "Extension Mechanisms for DNS allowing larger messages and options",
    "DNS-over-TLS": "DoT - encrypted DNS transport over TLS",
    "DNS-over-HTTPS": "DoH - DNS queries embedded in HTTP/2 requests",
    "trust anchor": "cryptographic root of trust for DNSSEC validation",
    "metrics collection": "gathering performance and operational statistics",
    "configuration management": "dynamic server configuration without restarts",
    "blue-green deployment": "deployment pattern with two identical environments",
    "rolling updates": "gradual replacement of servers in cluster",
    "cache warming": "preloading cache to minimize performance impact",
    "resolution state": "data structure tracking progress through recursive resolution"
  }
}