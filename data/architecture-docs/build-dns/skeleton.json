{
  "title": "DNS Server: Design Document",
  "overview": "A recursive DNS server that resolves domain names by implementing the DNS protocol, following referrals from root servers through the DNS hierarchy, and caching responses for performance. The key architectural challenge is managing stateful recursive resolution while handling concurrent queries and maintaining cache consistency with TTL-based expiration.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Establishes the DNS resolution problem using postal system analogies and compares different resolution approaches.",
      "subsections": [
        {
          "id": "dns-analogy",
          "title": "Mental Model: DNS as a Postal System",
          "summary": "Explains DNS resolution using postal mail routing as an intuitive analogy"
        },
        {
          "id": "resolution-approaches",
          "title": "Resolution Approaches Comparison",
          "summary": "Compares authoritative-only, forwarding, and recursive DNS server architectures"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what the DNS server must accomplish and explicitly excludes advanced features like DNSSEC.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Core DNS server capabilities including protocol support and resolution types"
        },
        {
          "id": "non-goals",
          "title": "Non-Goals",
          "summary": "Advanced DNS features explicitly excluded from this implementation"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "System component overview showing UDP server, message parser, resolver, cache, and zone data manager.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Five major components and their responsibilities in the DNS server"
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "Modular organization of Go packages for DNS server implementation"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Key data structures for DNS messages, resource records, cache entries, and zone data.",
      "subsections": [
        {
          "id": "dns-message-format",
          "title": "DNS Message Format",
          "summary": "Header, question, and resource record structures following RFC 1035"
        },
        {
          "id": "cache-zone-structures",
          "title": "Cache and Zone Data Structures",
          "summary": "Internal representations for cached records and authoritative zone data"
        }
      ]
    },
    {
      "id": "message-parsing",
      "title": "DNS Message Parsing (Milestone 1)",
      "summary": "Binary protocol parsing for DNS messages including name compression and wire format encoding.",
      "subsections": [
        {
          "id": "parsing-mental-model",
          "title": "Mental Model: DNS as Structured Binary Documents",
          "summary": "Understanding DNS messages as fixed and variable-length binary sections"
        },
        {
          "id": "name-compression",
          "title": "Name Compression Algorithm",
          "summary": "Handling DNS pointer labels and compression to reduce message size"
        },
        {
          "id": "parsing-adrs",
          "title": "Architecture Decisions for Parsing",
          "summary": "Decisions on byte order handling, buffer management, and compression validation"
        },
        {
          "id": "parsing-pitfalls",
          "title": "Common Parsing Pitfalls",
          "summary": "Compression loops, endianness errors, and buffer overflow prevention"
        }
      ]
    },
    {
      "id": "authoritative-server",
      "title": "Authoritative Server (Milestone 2)",
      "summary": "Zone file parsing and authoritative query responses with proper authority and additional sections.",
      "subsections": [
        {
          "id": "zone-mental-model",
          "title": "Mental Model: Zones as Local Phone Books",
          "summary": "Understanding DNS zones as authoritative directories of domain information"
        },
        {
          "id": "zone-file-parsing",
          "title": "Zone File Parsing Algorithm",
          "summary": "Reading BIND-format zone files into queryable in-memory structures"
        },
        {
          "id": "query-matching",
          "title": "Query Matching and Response Construction",
          "summary": "Finding matching records and populating answer, authority, and additional sections"
        },
        {
          "id": "authoritative-adrs",
          "title": "Architecture Decisions for Authority",
          "summary": "Decisions on case sensitivity, wildcard matching, and CNAME handling"
        }
      ]
    },
    {
      "id": "recursive-resolver",
      "title": "Recursive Resolver (Milestone 3)",
      "summary": "Iterative resolution following DNS hierarchy from root servers to authoritative nameservers.",
      "subsections": [
        {
          "id": "recursion-mental-model",
          "title": "Mental Model: Recursive Resolution as Detective Work",
          "summary": "Understanding iterative queries as following clues through a hierarchy of authorities"
        },
        {
          "id": "iterative-algorithm",
          "title": "Iterative Resolution Algorithm",
          "summary": "Step-by-step process of following referrals from root to authoritative servers"
        },
        {
          "id": "glue-records",
          "title": "Glue Records and Circular Dependencies",
          "summary": "Handling cases where NS names are within the delegated zone"
        },
        {
          "id": "recursion-adrs",
          "title": "Architecture Decisions for Recursion",
          "summary": "Decisions on loop detection, timeout handling, and CNAME following"
        }
      ]
    },
    {
      "id": "caching-performance",
      "title": "Caching and Performance (Milestone 4)",
      "summary": "TTL-based caching with negative caching and concurrent query handling for performance.",
      "subsections": [
        {
          "id": "cache-mental-model",
          "title": "Mental Model: Cache as Recent Memory",
          "summary": "Understanding DNS cache as short-term memory with automatic forgetting"
        },
        {
          "id": "ttl-management",
          "title": "TTL-Based Cache Management",
          "summary": "Cache storage, lookup, and expiration based on time-to-live values"
        },
        {
          "id": "negative-caching",
          "title": "Negative Caching Strategy",
          "summary": "Caching NXDOMAIN and NODATA responses to avoid repeated failed queries"
        },
        {
          "id": "concurrency-design",
          "title": "Concurrent Query Processing",
          "summary": "Handling multiple simultaneous DNS queries without blocking"
        },
        {
          "id": "caching-adrs",
          "title": "Architecture Decisions for Caching",
          "summary": "Decisions on cache size limits, eviction policies, and security validation"
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Message flow between components and sequence of operations for different query types.",
      "subsections": [
        {
          "id": "query-flow",
          "title": "Query Processing Flow",
          "summary": "End-to-end flow from UDP packet receipt to response transmission"
        },
        {
          "id": "component-interfaces",
          "title": "Component Interface Contracts",
          "summary": "Method signatures and data exchange formats between major components"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Failure modes, malformed message handling, and timeout strategies for robust operation.",
      "subsections": [
        {
          "id": "error-categories",
          "title": "Error Categories and Recovery",
          "summary": "Parse errors, network failures, and resolution timeouts with recovery strategies"
        },
        {
          "id": "edge-cases",
          "title": "DNS Protocol Edge Cases",
          "summary": "Handling malformed queries, oversized responses, and protocol violations"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Unit testing approaches and milestone checkpoints to verify correct DNS server behavior.",
      "subsections": [
        {
          "id": "unit-testing",
          "title": "Unit Testing Approach",
          "summary": "Testing strategies for parsers, resolvers, and cache components"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "Expected behavior and verification steps after completing each milestone"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common DNS server bugs, symptoms, diagnosis techniques, and debugging tools for troubleshooting.",
      "subsections": [
        {
          "id": "common-bugs",
          "title": "Common Bug Patterns",
          "summary": "Typical DNS server implementation bugs with symptom-cause-fix mapping"
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools and Techniques",
          "summary": "Tools like dig, wireshark, and logging strategies for DNS troubleshooting"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements like DNSSEC support, DNS-over-HTTPS, and advanced caching strategies.",
      "subsections": [
        {
          "id": "protocol-extensions",
          "title": "Protocol Extensions",
          "summary": "DNSSEC, EDNS, and modern DNS protocol enhancements"
        },
        {
          "id": "operational-features",
          "title": "Operational Features",
          "summary": "Metrics, monitoring, configuration management, and deployment considerations"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of DNS terminology, protocol concepts, and technical terms used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-components",
      "title": "DNS Server System Components",
      "description": "Shows the five major components (UDP Server, Message Parser, Recursive Resolver, Cache Manager, Zone Data Manager) and their connections. Include data flow arrows showing how UDP packets flow through parsing to resolution and back to response construction.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-data-flow"
      ]
    },
    {
      "id": "dns-message-structure",
      "title": "DNS Message Data Structure",
      "description": "Illustrates the relationship between DNS message components: Header, Question sections, Answer/Authority/Additional RR sections. Shows the internal structure of Resource Records and how name compression creates references between sections.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "message-parsing"
      ]
    },
    {
      "id": "recursive-resolution-flow",
      "title": "Recursive Resolution Sequence",
      "description": "Sequence diagram showing the iterative resolution process: Client query \u2192 Check cache \u2192 Query root server \u2192 Follow NS referral \u2192 Query TLD server \u2192 Follow NS referral \u2192 Query authoritative server \u2192 Return answer \u2192 Cache result \u2192 Respond to client.",
      "type": "sequence",
      "relevant_sections": [
        "recursive-resolver",
        "interactions-data-flow"
      ]
    },
    {
      "id": "cache-state-machine",
      "title": "Cache Entry State Machine",
      "description": "State transitions for cache entries: Empty \u2192 Cached (on cache miss + resolution) \u2192 Expired (on TTL timeout) \u2192 Empty (on eviction). Include negative cache states for NXDOMAIN responses.",
      "type": "state-machine",
      "relevant_sections": [
        "caching-performance"
      ]
    },
    {
      "id": "query-processing-flow",
      "title": "Query Processing Flowchart",
      "description": "Decision flowchart for processing incoming queries: Parse message \u2192 Check if authoritative \u2192 If yes, lookup in zone data \u2192 If no, check cache \u2192 If cache miss, start recursive resolution \u2192 Construct response \u2192 Send response. Include error handling paths.",
      "type": "flowchart",
      "relevant_sections": [
        "interactions-data-flow",
        "error-handling"
      ]
    },
    {
      "id": "name-compression-example",
      "title": "DNS Name Compression Example",
      "description": "Visual representation of how DNS name compression works with pointer labels, showing byte-level layout of compressed names in a DNS message with multiple domain names sharing common suffixes.",
      "type": "flowchart",
      "relevant_sections": [
        "message-parsing"
      ]
    },
    {
      "id": "zone-data-model",
      "title": "Zone Data and Resource Record Model",
      "description": "Class diagram showing the relationship between Zone, ResourceRecord types (A, AAAA, CNAME, MX, NS, SOA, TXT), and how they're organized for efficient querying by domain name and record type.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "authoritative-server"
      ]
    },
    {
      "id": "concurrent-query-handling",
      "title": "Concurrent Query Processing Architecture",
      "description": "Component diagram showing how multiple concurrent queries are handled: UDP listener spawning goroutines, shared cache with locking, resolver pool for parallel recursive resolution, and response correlation.",
      "type": "component",
      "relevant_sections": [
        "caching-performance",
        "interactions-data-flow"
      ]
    }
  ]
}