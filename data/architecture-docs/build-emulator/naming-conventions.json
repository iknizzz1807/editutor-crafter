{
  "types": {
    "EmulatorState": "fields: cpu CPUState, memory MemoryState, ppu PPUState, apu APUState, input InputState, timing TimingState, running bool, paused bool",
    "TimingState": "fields: master_cycles uint64_t, cycles_per_frame uint32_t, frame_cycles uint32_t, cpu_frequency double, target_fps double",
    "RendererState": "fields: window SDL_Window*, renderer SDL_Renderer*, texture SDL_Texture*, framebuffer uint32_t*, screen_width int, screen_height int, scale_factor int",
    "CPUState": "fields: registers uint8_t[8], program_counter uint16_t, stack_pointer uint16_t, status_flags uint8_t, interrupt_enable bool, halted bool, cycle_count uint64_t, last_instruction_cycles uint8_t",
    "MemoryState": "fields: rom_data uint8_t*, rom_size size_t, ram_data uint8_t[0x2000], vram_data uint8_t[0x2000], ppu_registers uint8_t[8], apu_registers uint8_t[32], input_registers uint8_t[2], current_rom_bank uint8_t, current_ram_bank uint8_t, bank_switch_enabled bool",
    "PPUState": "fields: framebuffer uint32_t[160*144], tile_data uint8_t[0x1800], background_map uint8_t[32*32], sprites SpriteAttributes[40], palettes uint32_t[8][4], scroll_x uint8_t, scroll_y uint8_t, current_scanline uint8_t, scanline_cycles uint16_t",
    "APUState": "Audio Processing Unit state",
    "InputState": "fields: joypad_state uint8_t, controller SDL_GameController*, debounce_timers uint32_t[8]",
    "DebugLevel": "enum: DEBUG_NONE, DEBUG_ERROR, DEBUG_WARN, DEBUG_INFO, DEBUG_TRACE",
    "DebugComponent": "enum flags: DEBUG_CPU, DEBUG_MEMORY, DEBUG_GRAPHICS, DEBUG_AUDIO, DEBUG_INPUT, DEBUG_TIMING",
    "SpriteAttributes": "fields: tile_index uint8_t, x_position uint8_t, y_position uint8_t, palette_index uint8_t, priority bool, flip_horizontal bool, flip_vertical bool, visible bool",
    "memory_read_func": "function pointer type for memory read operations",
    "memory_write_func": "function pointer type for memory write operations",
    "instruction_handler": "function pointer type for instruction implementations",
    "ErrorSeverity": "enum: ERROR_SEVERITY_INFO, ERROR_SEVERITY_WARNING, ERROR_SEVERITY_ERROR, ERROR_SEVERITY_CRITICAL",
    "ErrorCategory": "enum flags: ERROR_CATEGORY_CPU, ERROR_CATEGORY_MEMORY, ERROR_CATEGORY_GRAPHICS, ERROR_CATEGORY_AUDIO, ERROR_CATEGORY_INPUT, ERROR_CATEGORY_TIMING, ERROR_CATEGORY_SYSTEM",
    "ErrorInfo": "fields: severity ErrorSeverity, category ErrorCategory, error_code uint32_t, timestamp_cycles uint64_t, program_counter uint16_t, current_instruction uint8_t, description char[256], recovery_action char[128], recovery_attempted bool, recovery_successful bool",
    "InvalidInstructionResponse": "enum: INVALID_INSTRUCTION_HALT, INVALID_INSTRUCTION_NOP, INVALID_INSTRUCTION_CRASH, INVALID_INSTRUCTION_QUIRK",
    "MemoryAccessResult": "enum: MEMORY_ACCESS_VALID, MEMORY_ACCESS_IGNORED, MEMORY_ACCESS_QUIRK, MEMORY_ACCESS_ERROR",
    "ValidationResult": "fields: cpu_state_valid bool, memory_state_valid bool, graphics_state_valid bool, timing_state_valid bool, error_details char[512]",
    "CPUTraceEntry": "fields: cycle_count uint64_t, program_counter uint16_t, opcode uint8_t, operand1 uint8_t, operand2 uint8_t, flags_before uint8_t, flags_after uint8_t",
    "MemoryAccessEntry": "fields: cycle_count uint64_t, address uint16_t, value uint8_t, is_write bool, memory_region uint8_t",
    "DiagnosticLogger": "fields: cpu_trace CPUTraceEntry[], memory_trace MemoryAccessEntry[], error_history ErrorInfo[], cpu_trace_head int, memory_trace_head int, error_history_head int, logging_enabled bool, detail_level int",
    "UndocumentedInstruction": "fields: opcode uint8_t, cycle_count uint8_t, handler function_pointer, description char[64]",
    "TestResults": "fields: tests_run int, tests_passed int, tests_failed int, current_test char[256]",
    "TraceEntry": "fields: cycle uint64_t, pc uint16_t, opcode uint8_t, flags uint8_t",
    "TestFramework": "test execution and validation framework",
    "DebugInterface": "fields: emulator EmulatorState*, logger DiagnosticLogger*, break_requested bool, breakpoints uint16_t[16], breakpoint_count int",
    "InstructionProfile": "fields: address uint16_t, execution_count uint32_t, total_cycles uint64_t, compiled bool, native_code void*",
    "SaveStateHeader": "fields: magic_number uint32_t, version_major uint16_t, version_minor uint16_t, emulator_build uint32_t, timestamp uint64_t, total_size uint32_t, checksum uint32_t",
    "SaveStateChunk": "fields: chunk_type uint32_t, chunk_size uint32_t, chunk_version uint16_t, chunk_checksum uint32_t"
  },
  "methods": {
    "timing_init(timing, cpu_freq, fps)": "initialize timing system with target frequencies",
    "timing_add_cycles(timing, cycles) returns bool": "add cycles and check for frame completion",
    "timing_get_cycles(timing) returns uint64_t": "get current cycle count",
    "emulator_init(emu) returns bool": "initialize all emulator subsystems",
    "emulator_load_rom(emu, rom_path) returns bool": "load ROM file and prepare for execution",
    "emulator_run_frame(emu)": "execute one complete frame of emulation",
    "emulator_shutdown(emu)": "clean shutdown of all subsystems",
    "renderer_init(width, height, scale) returns bool": "initialize SDL2 rendering system",
    "renderer_get_framebuffer() returns uint32_t*": "get pointer to framebuffer for pixel writing",
    "renderer_present_frame()": "display completed frame to screen",
    "debug_init(level, components)": "initialize debugging system",
    "debug_dump_memory(memory, start, end)": "dump memory region for debugging",
    "timing_init(timing, cpu_freq, fps) returns bool": "initialize timing system with target frequencies",
    "platform_init(width, height, scale) returns bool": "initialize SDL2 rendering system",
    "platform_get_framebuffer() returns uint32_t*": "get pointer to framebuffer for pixel writing",
    "platform_present_frame()": "display completed frame to screen",
    "memory_read_byte(memory, address) returns uint8_t": "read byte with address translation",
    "memory_write_byte(memory, address, value)": "write byte with side effect handling",
    "ppu_init(ppu) returns bool": "initialize graphics subsystem",
    "ppu_render_scanline(ppu, scanline)": "render single line of graphics output",
    "ppu_write_tile_data(ppu, tile_address, value)": "update tile pattern data",
    "debug_validate_cpu_state(cpu) returns bool": "validate CPU state consistency",
    "cpu_init(cpu) returns bool": "initialize CPU to power-on state",
    "cpu_step(cpu, read_mem, write_mem, memory_state) returns uint8_t": "execute one instruction and return cycle count",
    "cpu_run_cycles(cpu, target_cycles, read_mem, write_mem, memory_state)": "run CPU for specified number of cycles",
    "set_flag(cpu, flag_mask, value)": "set or clear specific status flag",
    "get_flag(cpu, flag_mask) returns bool": "check if specific status flag is set",
    "update_zero_negative_flags(cpu, result)": "update zero and negative flags based on result",
    "cpu_debug_print_state(cpu)": "print complete CPU state for debugging",
    "memory_init(memory) returns bool": "initialize memory management system",
    "memory_load_rom(memory, rom_path) returns bool": "load ROM file and configure mapping",
    "debug_log_memory_access(address, value, is_write, region)": "log memory access for debugging",
    "debug_validate_address_range(address, min, max, region)": "validate address bounds",
    "input_init(input) returns bool": "initialize input system with SDL2",
    "input_update(input)": "sample current input state from host devices",
    "input_read_joypad(input) returns uint8_t": "read current controller button state",
    "timer_update_divider(timers, cycles)": "update DIV register based on cycles",
    "timer_update_tima(timers, cycles)": "update TIMA timer and handle overflow",
    "interrupt_process_pending(cpu, flags, enable)": "process highest priority pending interrupt",
    "event_queue_add(target_cycle, type, component, data) returns bool": "schedule event for future processing",
    "event_queue_process(current_cycle, handler) returns size_t": "process all events up to current cycle",
    "error_handler_init() returns bool": "initialize error handling system",
    "error_handler_shutdown()": "clean up error handling resources",
    "error_handler_report(error)": "report error for handling and logging",
    "error_handler_should_continue(severity, category) returns bool": "determine if execution should continue after error",
    "error_handler_set_debug_level(level)": "set diagnostic detail level",
    "error_handler_dump_recent_errors(output)": "export recent error history",
    "diagnostic_logger_init() returns bool": "initialize diagnostic capture system",
    "diagnostic_logger_trace_cpu(pc, opcode, op1, op2, flags_before, flags_after, cycles)": "record CPU instruction execution",
    "diagnostic_logger_trace_memory(address, value, is_write, region, cycles)": "record memory access operation",
    "diagnostic_logger_export_trace(output)": "export diagnostic trace data",
    "handle_invalid_instruction(cpu, opcode) returns InvalidInstructionResponse": "process invalid CPU instruction",
    "validate_memory_access(memory, address, value, is_write, cycle) returns MemoryAccessResult": "validate and handle memory access",
    "validate_system_state(emu) returns ValidationResult": "check overall system state consistency",
    "test_framework_init() returns bool": "initialize testing infrastructure",
    "setup_cpu_test() returns CPUState*": "create initialized CPU state for testing",
    "verify_cpu_flags(cpu, expected_flags) returns bool": "compare CPU flags against expected values",
    "compare_execution_traces(reference_file, generated_file) returns bool": "compare execution traces for validation",
    "validate_memory_state(memory) returns bool": "verify memory state consistency",
    "debug_interface_init(debug, emulator, logger) returns bool": "initialize interactive debugging",
    "debug_interface_process_command(debug, command) returns bool": "process user debugging commands",
    "debug_interface_should_break(debug) returns bool": "check breakpoint conditions",
    "test_framework_run_all_tests() returns bool": "execute comprehensive test suite",
    "profiler_init(cpu) returns bool": "initialize profiling system for JIT compilation",
    "profiler_record_execution(address, cycles)": "track instruction execution for compilation decisions",
    "save_state_create(emu, filename) returns bool": "create complete system save state",
    "debug_log_memory_access_detailed(address, value, is_write, region, cycle_count)": "log memory access with timing context"
  },
  "constants": {
    "SDL_INIT_VIDEO": "SDL video subsystem initialization",
    "SDL_INIT_AUDIO": "SDL audio subsystem initialization",
    "SDL_WINDOWPOS_CENTERED": "center window on screen",
    "SDL_RENDERER_ACCELERATED": "use hardware acceleration",
    "SDL_TEXTUREACCESS_STREAMING": "texture for frequent updates",
    "SCREEN_WIDTH": "display width in pixels",
    "SCREEN_HEIGHT": "display height in pixels",
    "TILE_DATA_SIZE": "size of tile pattern memory",
    "MAX_SPRITES": "maximum number of sprites",
    "PALETTE_COUNT": "number of color palettes",
    "COLORS_PER_PALETTE": "colors per palette",
    "RAM_SIZE": "0x2000 - system RAM size",
    "VRAM_SIZE": "0x2000 - video RAM size",
    "PPU_REG_COUNT": "8 - number of PPU registers",
    "APU_REG_COUNT": "32 - number of APU registers",
    "INPUT_REG_COUNT": "2 - number of input registers",
    "FLAG_ZERO": "0x80",
    "FLAG_NEGATIVE": "0x40",
    "FLAG_HALF_CARRY": "0x20",
    "FLAG_CARRY": "0x10",
    "OPCODE_COUNT": "256 - total number of possible opcodes",
    "ROM_BANK_SIZE": "0x4000 - size of ROM bank",
    "CPU_FREQUENCY": "4194304 - 4.194304 MHz",
    "CYCLES_PER_FRAME": "70224 - cycles per complete frame",
    "TARGET_FPS": "59.7 - target frames per second",
    "CYCLES_PER_SCANLINE": "456 - cycles per scanline",
    "SCANLINES_PER_FRAME": "154 - total scanlines including VBlank",
    "SDL_INIT_GAMECONTROLLER": "SDL gamepad subsystem initialization",
    "SDL_RENDERER_PRESENTVSYNC": "synchronize with display refresh",
    "MAX_LOG_ENTRIES": "10000",
    "MAX_CPU_TRACE_ENTRIES": "1000",
    "DEBUG_NONE": "no diagnostic output",
    "DEBUG_ERROR": "error conditions only",
    "DEBUG_WARN": "warnings and errors",
    "DEBUG_INFO": "informational logging",
    "DEBUG_TRACE": "detailed execution tracing"
  },
  "terms": {
    "emulation": "software recreation of hardware system behavior",
    "fetch-decode-execute": "three-phase CPU instruction processing cycle",
    "cycle-accurate": "emulation simulating individual clock cycles",
    "instruction-level emulation": "emulation treating instructions as atomic operations",
    "high-level emulation": "emulation that recreates end results rather than precise mechanisms",
    "framebuffer": "memory buffer containing pixel data for display",
    "scanline": "single horizontal row of pixels in display output",
    "memory mapping": "assignment of address ranges to hardware components",
    "bank switching": "technique for accessing more memory than address space allows",
    "MMIO": "memory-mapped input/output for peripheral control",
    "timing synchronization": "coordination of component execution rates",
    "hardware quirks": "unusual behaviors and bugs in original hardware",
    "state management": "maintaining complete system state for save/restore",
    "tile-based graphics": "graphics system using small reusable pattern blocks",
    "indexed color": "color system using palette lookup tables",
    "sprite attributes": "data describing movable graphics objects",
    "opcode": "operation code identifying instruction type",
    "program counter": "register pointing to next instruction address",
    "status flags": "register containing arithmetic and logic operation results",
    "instruction dispatch": "mechanism routing opcodes to implementation functions",
    "half-carry flag": "flag indicating carry between lower and upper 4-bit nibbles",
    "undocumented opcodes": "instruction codes not officially documented by CPU manufacturer",
    "address translation": "converting virtual addresses to physical storage locations",
    "dispatch table": "function pointer table routing operations based on address",
    "echo RAM": "memory region that mirrors another memory area",
    "mapper": "cartridge hardware controlling memory banking",
    "scanline rendering": "per-line rendering process matching hardware timing constraints",
    "priority system": "layering rules determining pixel visibility",
    "transparency": "sprite pixels that don't affect final output",
    "interrupt vector": "memory address containing interrupt service routine",
    "VBlank interrupt": "interrupt generated during vertical blanking period",
    "timer overflow": "timer register incrementing past maximum value",
    "input debouncing": "filtering rapid input state changes to prevent noise",
    "master cycle counter": "authoritative time reference for all emulator components",
    "component time slicing": "allowing components to advance independently within boundaries",
    "synchronization points": "specific moments when components must coordinate state",
    "event queue": "ordered list of scheduled cross-component communications",
    "cascading state updates": "multi-component state changes triggered by single event",
    "interrupt synchronization": "precise timing coordination for hardware interrupt processing",
    "frame-based timing": "organizing execution around display frame boundaries",
    "execution quantum": "number of cycles processed before synchronization",
    "graceful degradation": "maintaining some functionality when components fail",
    "state consistency": "ensuring system state remains valid and coherent",
    "diagnostic logging": "capture of detailed system activity for debugging",
    "error recovery": "strategies for handling and recovering from failures",
    "invalid operation": "hardware operation that violates normal specifications",
    "memory-mapped I/O": "peripheral control through memory address access",
    "open bus behavior": "reading unmapped memory returns last bus value",
    "unit testing": "testing individual components in isolation",
    "integration testing": "testing component interaction and coordination",
    "compatibility testing": "testing with real games and programs",
    "test ROM": "specialized program for emulator validation",
    "milestone checkpoint": "verification criteria for development phases",
    "instruction set architecture": "specification of CPU instructions and behavior",
    "execution trace": "record of instruction-by-instruction program execution",
    "memory access pattern": "sequence of memory read/write operations",
    "state snapshot": "complete system state capture at specific point",
    "circular buffer": "fixed-size buffer that overwrites oldest entries",
    "component synchronization": "coordination of subsystem execution timing",
    "regression testing": "validation that changes don't break existing functionality",
    "breakpoint": "execution pause point for debugging",
    "single-step mode": "execute one instruction at a time for debugging",
    "memory watch": "monitoring specific memory region for changes",
    "just-in-time compilation": "translating frequently-executed code into native machine code",
    "dynamic recompilation": "cross-instruction optimization during runtime compilation",
    "translation cache": "storage for compiled code blocks mapped by emulated address",
    "cycle-accurate timing": "emulation simulating individual clock cycles",
    "sub-instruction timing": "timing precision at individual instruction cycle boundaries",
    "save states": "complete system state capture for later restoration",
    "progressive disclosure": "presenting basic functionality prominently while making advanced features accessible"
  }
}