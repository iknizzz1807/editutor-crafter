direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ---------------------------------------------------------------------------------------
# L0: USER SPACE
# ---------------------------------------------------------------------------------------
user_space: {
  label: "USER SPACE (Application Process)"
  direction: down
  style: {
    fill: "#f8f9fa"
    stroke: "#343a40"
    stroke-width: 2
  }

  app_logic: {
    shape: class
    label: "Event Loop (main.c)"
    definition: |c
      int epfd = epoll_create1(0);
      struct epoll_event ev;
      ev.events = EPOLLIN | EPOLLET;
      ev.data.fd = sockfd;
      epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &ev);
      
      while(1) {
          int n = epoll_wait(epfd, events, MAX_EVENTS, -1);
          for(int i=0; i<n; i++) handle_event(&events[i]);
      }
    |
  }

  struct_epoll_event: {
    shape: sql_table
    label: "struct epoll_event (sys/epoll.h)"
    row1: "0x00 | uint32_t | events (EPOLLIN | EPOLLET)"
    row2: "0x04 | uint64_t | data (union: ptr, fd, u32, u64)"
    label_bottom: "Total: 12 bytes (packed)"
  }
}

# ---------------------------------------------------------------------------------------
# L1: KERNEL SPACE (The Epoll Subsystem)
# ---------------------------------------------------------------------------------------
kernel_space: {
  label: "KERNEL SPACE (fs/eventpoll.c)"
  direction: down
  style: {
    fill: "#e9ecef"
    stroke: "#495057"
  }

  eventpoll_instance: {
    shape: sql_table
    label: "struct eventpoll (Internal)"
    row1: "0x00 | struct rb_root | rbr (Interest List)"
    row2: "0x08 | struct list_head | rdllist (Ready List)"
    row3: "0x18 | wait_queue_head_t | wq (Process Wait Queue)"
    row4: "0x30 | spinlock_t | lock"
    label_bottom: "Context for epfd"
  }

  interest_list: {
    label: "INTEREST LIST (RB-Tree)"
    epitem_node: {
      shape: sql_table
      label: "struct epitem (fs/eventpoll.c)"
      row1: "0x00 | struct rb_node | rbn (Tree Link)"
      row2: "0x20 | struct list_head | rdllink (Ready Link)"
      row3: "0x30 | struct epoll_filefd | ffd (Target FD)"
      row4: "0x40 | struct epoll_event | event (User Cache)"
      label_bottom: "O(log N) Search Store"
    }
  }

  ready_list: {
    label: "READY LIST (Doubly Linked)"
    style: { stroke: "#28a745"; stroke-width: 3 }
    list_nodes: "epitem[A] <-> epitem[B] <-> epitem[C]"
  }

  wait_queue: {
    label: "WAIT QUEUE (wq_head)"
    blocked_process: "Task: PID 1234 (app_logic)"
    style: { stroke: "#dc3545"; stroke-dash: 3 }
  }
}

# ---------------------------------------------------------------------------------------
# L2: NETWORKING STACK
# ---------------------------------------------------------------------------------------
networking: {
  label: "NETWORKING SUBSYSTEM"
  direction: down
  
  socket_buffer: {
    shape: sql_table
    label: "sk_receive_queue (Socket Buffer)"
    row1: "0x00 | struct sk_buff_head | receive_queue"
    row2: "0x10 | wait_queue_head_t | sk_wq"
    label_bottom: "Contains ep_poll_callback"
  }

  callback_logic: {
    shape: class
    label: "ep_poll_callback (fs/eventpoll.c)"
    definition: |c
      static int ep_poll_callback(wait_queue_entry_t *wait, 
                                 unsigned mode, int sync, void *key) {
          struct epitem *epi = ep_item_from_wait(wait);
          struct eventpoll *ep = epi->ep;
          if (!list_empty(&epi->rdllink)) return 1;
          list_add_tail(&epi->rdllink, &ep->rdllist);
          if (waitqueue_active(&ep->wq)) wake_up_locked(&ep->wq);
          return 1;
      }
    |
  }
}

nic: {
  shape: rectangle
  label: "NIC (Hardware Interface)"
  style: { fill: "#ced4da" }
}

# ---------------------------------------------------------------------------------------
# DATA FLOW & SYSCALL LIFECYCLE
# ---------------------------------------------------------------------------------------

# 1. Registration
user_space.app_logic -> kernel_space.eventpoll_instance: "epoll_ctl(ADD) | 12B | {fd: sockfd, events: EPOLLIN}" {
  style: { stroke: "#007bff"; stroke-width: 2 }
}

# 2. Polling
user_space.app_logic -> kernel_space.wait_queue: "epoll_wait() | Sleep if rdllist.empty"
kernel_space.eventpoll_instance -> kernel_space.wait_queue: "__add_wait_queue(wq, &wait)" {
  style: { stroke-dash: 5 }
}

# 3. Hardware Interrupt -> Wakeup Path
nic -> networking.socket_buffer: "Incoming Frame | 1500B | DMA to SKB"
networking.socket_buffer -> networking.callback_logic: "sk_data_ready() -> Interrupt Context"
networking.callback_logic -> kernel_space.interest_list.epitem_node: "Identify linked epitem"
networking.callback_logic -> kernel_space.ready_list: "list_add_tail(&epi->rdllink, &ep->rdllist)" {
  style: { stroke: "#28a745"; stroke-width: 2; animated: true }
}
kernel_space.ready_list -> kernel_space.wait_queue: "wake_up_locked(&ep->wq)" {
  style: { stroke: "#28a745"; animated: true }
}

# 4. Return to User Space
kernel_space.wait_queue -> user_space.app_logic: "Schedule Task -> epoll_wait returns N"
kernel_space.interest_list.epitem_node -> user_space.struct_epoll_event: "copy_to_user(events, epi->event, n)" {
  style: { stroke: "#007bff"; stroke-width: 2 }
}

# Legend & Annotations
legend: {
  near: bottom-right
  lt_mode: "LT Mode: Item remains on rdllist if data persists" {
    shape: text
    style: { font-color: "#495057"; font-size: 10 }
  }
  et_mode: "ET Mode: Item removed from rdllist immediately" {
    shape: text
    style: { font-color: "#dc3545"; font-size: 10 }
  }
}