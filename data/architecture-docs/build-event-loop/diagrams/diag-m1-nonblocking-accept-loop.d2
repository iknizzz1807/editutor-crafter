direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 1
  }
}

# SATELLITE CONTEXT: Milestone 1 - The Accept Loop
# This diagram focuses on the critical handling of the listening socket in Edge-Triggered (ET) mode.

kernel_network_stack: {
  label: "Linux Kernel Network Stack (net/ipv4/tcp_input.c)"
  direction: down

  listen_backlog: {
    shape: sql_table
    label: "Listen Backlog Queue (somaxconn)"
    
    conn1: "0x01 | ESTABLISHED | Client A (IP: 10.0.0.1)"
    conn2: "0x02 | ESTABLISHED | Client B (IP: 10.0.0.2)"
    conn3: "0x03 | ESTABLISHED | Client C (IP: 10.0.0.3)"
    conn_rst: "0x04 | CLOSED/RST  | Client D (Race Case)"
    
    label_bottom: "3 Pending, 1 Ghost (RST)"
  }

  tcp_state_transition: {
    shape: code
    label: "Handshake Completion"
    language: c
    content: |md
      // 3-way handshake completes
      tcp_v4_syn_recv_sock();
      // Edge Transition: Queue goes 0 -> 1
      // epoll_wait notified ONCE.
    |
  }
}

epoll_interface: {
  label: "Epoll Subsystem"
  direction: down
  
  ready_list: {
    shape: queue
    label: "Ready List (rdllist)"
    item: "fd: 3 (listen_fd) | events: EPOLLIN"
  }
}

app_reactor: {
  label: "Application Reactor (M1 Implementation)"
  direction: down

  accept_logic: {
    direction: right
    
    wrong_way: {
      label: "❌ PITFALL: Single accept()"
      style: {
        stroke: red
        stroke-width: 2
        fill: "#fff0f0"
      }
      logic: |md
        c
        // ONLY 1 CALL
        int fd = accept4(listen_fd, ...);
        // fd=4 (Client A) returned.
        // Loop ends.
        
      |
      note: "Client B & C remain in kernel queue indefinitely!\nET will NOT fire again until Client E arrives." {
        style: { font-color: red; italic: true }
      }
    }

    correct_way: {
      label: "✅ CORRECT: Drain Loop"
      style: {
        stroke: green
        stroke-width: 2
        fill: "#f0fff0"
      }
      logic: |md
        c
        for (;;) {
            int fd = accept4(listen_fd, ..., 
                             SOCK_NONBLOCK);
            if (fd < 0) {
                if (errno == EAGAIN) break; // DONE
                perror("accept4"); break;
            }
            conn_init(fd); // Handle A, B, C
        }
        
      |
    }
  }
  
  blocking_pitfall: {
    label: "⚠️ BLOCKING ACCEPT RACE"
    shape: cloud
    style: { fill: "#fff9c4" }
    content: |md
      **The Scenario:**
      1. Client D sends SYN.
      2. epoll_wait wakes up.
      3. Client D sends RST (Connection Aborted).
      4. `accept()` is called.
      
      **The Result:**
      If socket is **BLOCKING**, `accept()` 
      stalls until the *next* connection 
      arrives, freezing the entire server.
      
      **The Fix:**
      Always use `SOCK_NONBLOCK`.
    |
  }
}

# Data Flows
kernel_network_stack.listen_backlog -> epoll_interface.ready_list: "0 -> 1 Transition | Signal Edge"
epoll_interface.ready_list -> app_reactor: "epoll_wait() | 1 event"

# Logic Mapping
app_reactor.accept_logic.wrong_way -> kernel_network_stack.listen_backlog.conn1: "accept() extracts A"
app_reactor.accept_logic.wrong_way -> kernel_network_stack.listen_backlog.conn2: "STRANDED" {
  style: { stroke: red; stroke-dash: 5 }
}

app_reactor.accept_logic.correct_way -> kernel_network_stack.listen_backlog.conn1: "Iteration 1: A"
app_reactor.accept_logic.correct_way -> kernel_network_stack.listen_backlog.conn2: "Iteration 2: B"
app_reactor.accept_logic.correct_way -> kernel_network_stack.listen_backlog.conn3: "Iteration 3: C"
app_reactor.accept_logic.correct_way -> app_reactor.accept_logic.correct_way: "Iteration 4: EAGAIN"

app_reactor.blocking_pitfall -> kernel_network_stack.listen_backlog.conn_rst: "Blocks here if O_NONBLOCK missing"