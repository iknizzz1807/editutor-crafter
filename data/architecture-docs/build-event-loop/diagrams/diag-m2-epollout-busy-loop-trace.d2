direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 1
  }
}

classes: {
  danger: {
    style: {
      fill: "#ffebee"
      stroke: "#c62828"
      stroke-width: 2
    }
  }
  safe: {
    style: {
      fill: "#e8f5e9"
      stroke: "#2e7d32"
      stroke-width: 2
    }
  }
  kernel: {
    style: {
      fill: "#e3f2fd"
      stroke: "#1565c0"
      stroke-dash: 3
    }
  }
  metrics: {
    shape: sql_table
    style: {
      fill: "#f5f5f5"
      stroke: "#424242"
    }
  }
}

# -----------------------------------------------------------------------------
# SCENARIO A: THE BUSY-LOOP BUG (EPOLLOUT ARMED + EMPTY BUFFER)
# -----------------------------------------------------------------------------
bug_scenario: {
  class: danger
  label: "INCORRECT: EPOLLOUT Busy-Loop (CPU Pinning)"

  direction: down

  trace: {
    direction: right
    
    iter_n: {
      label: "Iteration N"
      wait: "epoll_wait() | timeout=-1"
      wait -> kernel_check: "Check Ready List"
      kernel_check: {
        class: kernel
        label: "Kernel (fs/eventpoll.c)"
        status: "TCP Send Buffer: 87KB Free\nResult: EPOLLOUT READY"
      }
      kernel_check -> callback: "Return fd=5 (Writable)"
      callback: "handle_write(fd=5)"
      callback -> logic: "check c->wbuf.len"
      logic: "len == 0\n(Nothing to send)"
      logic -> loop: "RETURN"
    }

    iter_n1: {
      label: "Iteration N+1"
      wait: "epoll_wait() | timeout=-1"
      wait -> kernel_check: "Check Ready List"
      kernel_check: {
        class: kernel
        label: "Kernel"
        status: "Still Writable\nResult: EPOLLOUT READY"
      }
      kernel_check -> callback: "Return fd=5 (Writable)"
      callback: "handle_write(fd=5)"
      callback -> logic: "len == 0"
      logic -> loop: "RETURN"
    }

    iter_n -> iter_n1: "Next Tick (Instant)"
  }

  stats: {
    class: metrics
    label: "Telemetry: Buggy State"
    row1: "Syscall Rate | ~1,200,000 / sec"
    row2: "CPU Usage    | 100% (Single Core)"
    row3: "Useful Work  | 0 bytes sent"
    row4: "Context      | I/O Priority Inversion"
  }
}

# -----------------------------------------------------------------------------
# SCENARIO B: CORRECT DEREGISTRATION
# -----------------------------------------------------------------------------
fix_scenario: {
  class: safe
  label: "CORRECT: EPOLLOUT Management (Deregister on Empty)"

  direction: down

  trace: {
    direction: right

    step_1: {
      label: "Flush Complete"
      callback: "handle_write(fd=5)"
      logic: "wbuf drained\nlen == 0"
      logic -> syscall: "epoll_ctl(MOD, fd, EPOLLIN)"
      syscall: {
        class: kernel
        label: "Kernel"
        action: "Remove fd from Ready List\nInterest: READ ONLY"
      }
    }

    step_2: {
      label: "Efficient Sleep"
      wait: "epoll_wait() | timeout=500ms"
      wait -> kernel_idle: "Check Ready List"
      kernel_idle: {
        class: kernel
        label: "Kernel"
        status: "No EPOLLIN events\nState: THREAD SLEEPING"
      }
      kernel_idle -> wait: "Blocks until Data Arrives"
    }

    step_1 -> step_2: "Deregistered"
  }

  stats: {
    class: metrics
    label: "Telemetry: Correct State"
    row1: "Syscall Rate | ~2 / sec (Idle)"
    row2: "CPU Usage    | < 0.1%"
    row3: "Useful Work  | High Efficiency"
    row4: "Context      | Battery/Power Optimal"
  }
}

# Comparison Flow
bug_scenario -> fix_scenario: "FIX: Implement MOD_DEL for EPOLLOUT" {
  style: {
    stroke-width: 4
    stroke: "#2e7d32"
  }
}

legend: {
  near: bottom-center
  direction: right
  
  l1: "Red = Busy Loop" { style.fill: "#ffebee" }
  l2: "Blue = Kernel Space" { style.fill: "#e3f2fd" }
  l3: "Green = Application Sleep" { style.fill: "#e8f5e9" }
}