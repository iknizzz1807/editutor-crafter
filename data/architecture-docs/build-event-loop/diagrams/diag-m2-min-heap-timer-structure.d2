direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- DATA STRUCTURE DEFINITIONS (L1 - MEMORY) ---
memory_layout: {
  direction: down
  label: "MEMORY ARCHITECTURE (timer.h)"

  timer_entry_struct: {
    shape: sql_table
    label: "struct timer_entry (timer.h)"
    
    row1: "0x00 | uint64_t | expiry_ms (CLOCK_MONOTONIC)"
    row2: "0x08 | int      | fd        (Target Descriptor)"
    row3: "0x10 | void*    | callback  (timer_callback_fn)"
    row4: "0x18 | bool     | cancelled (Lazy Deletion Flag)"
    row5: "0x19 | uint8_t  | padding   [7 bytes]"
    label_bottom: "Total: 32 bytes (8-byte aligned)"
  }

  heap_array: {
    shape: sql_table
    label: "timer_entry heap[] (timer.c)"
    
    idx0: "0 | {expiry: 1000, fd: 4, cancelled: F}"
    idx1: "1 | {expiry: 1500, fd: 7, cancelled: T}"
    idx2: "2 | {expiry: 2000, fd: 9, cancelled: F}"
    idx3: "3 | {expiry: 3500, fd: 5, cancelled: F}"
    label_bottom: "Contiguous Memory Buffer (Binary Heap)"
  }
  
  perf_note: {
    shape: text
    label: "Performance Note: Min-Heap root at index 0 provides O(1) peek for the next timeout required by epoll_wait()."
    style: { 
      font-color: "#525F7F"
      italic: true 
    }
  }
}

# --- LOGICAL STRUCTURE (L2 - STREET VIEW) ---
heap_tree: {
  label: "LOGICAL MIN-HEAP TREE"
  direction: down

  root: "Entry 0\n1000ms" {
    style: { fill: "#eef9f3"; stroke: green; stroke-width: 2 }
  }
  
  node1: "Entry 1\n1500ms (C)" {
    style: { fill: "#fff9c9"; stroke: orange; stroke-dash: 3 }
    tooltip: "Lazy Cancelled: Marked for skip during extraction"
  }
  
  node2: "Entry 2\n2000ms" {
    style: { fill: "#eef9f3"; stroke: green }
  }
  
  node3: "Entry 3\n3500ms" {
    style: { fill: "#eef9f3"; stroke: green }
  }

  root -> node1: "Left: (2*i + 1)"
  root -> node2: "Right: (2*i + 2)"
  node1 -> node3: "Left: (2*i + 1)"
}

# --- OPERATIONS (IMPLEMENTATION DETAIL) ---
operations: {
  direction: down
  label: "CORE ALGORITHMS (timer.c)"

  op_insert: {
    label: "1. INSERT: O(log n)"
    
    code_impl: |md
      c
      void timer_insert(uint64_t ms, void* cb) {
          heap[size] = (timer_entry){ms, STDIN_FILENO, cb, false};
          sift_up(size++);
      }
      
    |
    
    stage_flow: {
      direction: right
      tail: "Add to tail"
      up: "Sift Up"
      swap: "Swap with Parent"
      
      tail -> up -> swap: "idx = (idx-1)/2"
    }
  }

  op_cancel: {
    label: "2. CANCEL (LAZY): O(1)"
    
    code_impl: |md
      c
      void timer_cancel(int heap_idx) {
          // Keep structure, flag for ignore
          heap[heap_idx].cancelled = true;
      }
      
    |
    
    workflow: {
      direction: right
      set_flag: "O(1) Flag Set"
      integrity: "Structural Integrity"
      deferred: "Clean at Expiry"
      
      set_flag -> integrity -> deferred
    }
  }

  op_expire: {
    label: "3. EXPIRE-ALL: O(k log n)"
    
    code_impl: |md
      c
      void timer_process_expired(uint64_t now) {
          while (size > 0 && heap[0].expiry <= now) {
              timer_entry t = extract_min();
              if (!t.cancelled) t.callback(t.fd);
          }
      }
      
    |
    
    exec_path: {
      direction: right
      peek: "Check Root"
      extract: "Extract Min"
      check: "Validate Flag"
      
      peek -> extract -> check: "if(expiry <= now)"
    }
  }
}

# --- GLOBAL CONNECTIONS & DATA FLOW ---

memory_layout.timer_entry_struct -> memory_layout.heap_array: "Struct Layout -> Array Buffer"
memory_layout.heap_array -> heap_tree: "timer_entry[] | 32B elements | mapped to tree"
heap_tree -> operations: "Manipulation Target"

# --- STYLE OVERRIDES ---
(operations.op_insert.stage_flow.** -> **)[*].style.stroke: green
(operations.op_cancel.workflow.** -> **)[*].style.stroke: blue
(operations.op_expire.exec_path.** -> **)[*].style.stroke: red