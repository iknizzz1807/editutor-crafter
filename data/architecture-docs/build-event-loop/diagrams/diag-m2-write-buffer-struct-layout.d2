direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# L1: COMPONENT DIAGRAM - WRITE BUFFER MEMORY ARCHITECTURE
# Context: Non-blocking socket output management with backpressure handling.

title: "struct write_buffer_t (buffer.h) | Byte-Level Memory Layout" {
  shape: text
  near: top-center
  style: {
    font-size: 24
    bold: true
  }
}

legend: {
  near: bottom-right
  sent: "SENT (Processed)" {
    style: { fill: "#d3d3d3"; stroke-dash: 3 }
  }
  pending: "PENDING (Active)" {
    style: { fill: "#c7f1ff"; bold: true }
  }
  free: "FREE (Capacity)" {
    style: { fill: "#eef9f3" }
  }
}

struct_def: {
  shape: sql_table
  label: "struct write_buffer_t (buffer.h)"
  
  row1: "0x00 | char*    | data     | --> Heap address [0x55...]"
  row2: "0x08 | size_t   | capacity | Total allocated bytes"
  row3: "0x10 | size_t   | length   | Total bytes stored (offset + pending)"
  row4: "0x18 | size_t   | offset   | Index of next byte to send"
  
  label_bottom: "Total Size: 32 Bytes (0x20)"
}

heap_visualization: {
  label: "Memory Region Visualization (Heap)"
  direction: right

  buffer_strip: {
    grid-columns: 3
    grid-gap: 0
    
    sent_region: "data[0 ... offset-1]" {
      label: "SENT DATA\n(Padding)"
      style: {
        fill: "#d3d3d3"
        stroke-dash: 2
        opacity: 0.6
      }
      width: 150
    }

    pending_region: "data[offset ... length-1]" {
      label: "PENDING DATA\n(Active Window)"
      style: {
        fill: "#c7f1ff"
        stroke-width: 3
      }
      width: 250
    }

    free_region: "data[length ... capacity-1]" {
      label: "FREE SPACE\n(Available)"
      style: {
        fill: "#eef9f3"
      }
      width: 150
    }
  }

  # Mathematical Annotations
  pending_region -> math_calc: "Active Data Size"
  math_calc: "size_t n = length - offset;" {
    shape: code
    style: { font-size: 14 }
  }
}

partial_write_logic: {
  label: "Logic Flow: Partial Write Handling"
  
  state_before: |md
    ### STATE: BEFORE write()
    - offset: 0
    - length: 1000
    - capacity: 4096
  |
  
  syscall_action: |md
    c
    // Attempt non-blocking write
    ssize_t w = write(fd, 
                data + offset, 
                length - offset);
    
    if (w > 0) {
        offset += w; // Advance pointer
    }
    
  |
  
  state_after: |md
    ### STATE: AFTER write() returns 500
    - **offset: 500** (Advanced)
    - **length: 1000** (Constant)
    - **next_call**: `data + 500`
  |

  state_before -> syscall_action: "write(fd, ptr, 1000)"
  syscall_action -> state_after: "Returns 500 (EAGAIN path)"
}

# Logical Connections
struct_def.row1 -> heap_visualization.buffer_strip.sent_region: "points to start" {
  style: { stroke-width: 2; animated: true }
}

heap_visualization -> partial_write_logic: "Manages"

notes: {
  near: bottom-left
  shape: text
  label: |md
    **Implementation Invariants:**
    1. `data + offset` is the starting address for `write()` / `send()`.
    2. `length - offset` is the byte count for the syscall.
    3. If `offset == length`, buffer is exhausted; reset `offset = length = 0`.
    4. If `offset > capacity / 2`, perform `memmove()` to compact.
  |
}