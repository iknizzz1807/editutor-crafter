direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- STYLES & CLASSES ---
classes: {
  struct_box: {
    shape: sql_table
    style: {
      stroke-width: 2
    }
  }
  logic_node: {
    shape: rectangle
    style: {
      fill: "#f8f9fa"
      stroke: "#212529"
      border-radius: 4
    }
  }
  warning: {
    style: {
      fill: "#fff3f3"
      stroke: "#dc3545"
      font-color: "#dc3545"
      bold: true
    }
  }
  success: {
    style: {
      fill: "#f3fff3"
      stroke: "#28a745"
      font-color: "#28a745"
      bold: true
    }
  }
}

# --- DATA STRUCTURES ---
data_structures: {
  grid-columns: 2
  
  fd_handler: {
    class: struct_box
    label: "struct fd_handler (reactor.c)"
    
    row1: "0x00 | void*    | callback_fn"
    row2: "0x08 | void*    | user_data"
    row3: "0x10 | uint32_t | events_mask"
    row4: "0x14 | bool     | registered"
    row5: "0x15 | bool     | zombie_flag"
    label_bottom: "Total: 24 bytes"
  }

  deferred_mod: {
    class: struct_box
    label: "struct deferred_mod"
    
    row1: "0x00 | enum     | op (ADD/MOD/DEL)"
    row2: "0x04 | int      | fd"
    row3: "0x08 | uint32_t | events"
    label_bottom: "Total: 12 bytes"
  }
}

# --- SCENARIO A: UNSAFE (IMMEDIATE CTL) ---
unsafe_path: {
  label: "UNSAFE: Immediate epoll_ctl Call"
  direction: down
  class: warning

  epoll_wait: "1. epoll_wait returns [fd:7, fd:9]"
  dispatch: {
    label: "Iteration 0: fd:7"
    callback: "2. Callback(7) calls close(7)"
    sys_ctl: "3. epoll_ctl(DEL, 7) invoked"
    class: warning
  }
  reuse: "4. New connection accepts into fd:7" {
    style: { stroke-dash: 5 }
  }
  corruption: "5. Iteration 1: Dispatch Loop sees fd:7 again" {
    class: warning
    label: "CRASH/CORRUPTION: Dispatches old event to NEW connection state"
  }

  epoll_wait -> dispatch -> reuse -> corruption
}

# --- SCENARIO B: SAFE (DEFERRED MODS) ---
safe_path: {
  label: "SAFE: Reactor Deferred Queue"
  direction: down
  class: success

  wait: "1. epoll_wait(..., events, 1024)"
  
  loop_start: {
    label: "2. Dispatch Loop (r->dispatching = true)"
    direction: right
    
    it_7: {
      label: "Iteration fd:7"
      call_7: "Callback(7) -> reactor_deregister(7)"
      mark: "3. handler[7].zombie = true\n4. enqueue_mod(MOD_DEL, 7)"
      call_7 -> mark
    }
  }

  skip_logic: {
    label: "Iteration N: fd:7 (duplicate in batch)"
    check: "5. if (h->zombie) continue;"
    class: success
  }

  apply_phase: {
    label: "6. Post-Dispatch (r->dispatching = false)"
    drain: "7. foreach(mod in r->mods) {\n   reactor_apply_mod(mod);\n}"
    actual_ctl: "8. epoll_ctl(EPOLL_CTL_DEL, 7, NULL)"
    drain -> actual_ctl
  }

  wait -> loop_start -> skip_logic -> apply_phase
}

# --- COMPARISON CONNECTORS ---
unsafe_path -> safe_path: "Architecture Upgrade" {
  style: {
    stroke-width: 4
    stroke: "#6c757d"
  }
}

# --- IMPLEMENTATION DETAIL ---
implementation_logic: {
  near: bottom-center
  code: |md
    c
    // The Deferred Guard
    void reactor_deregister(reactor *r, int fd) {
        fd_handler *h = &r->handlers[fd];
        if (r->dispatching) {
            h->zombie = true; // Mark for skip
            enqueue_mod(r, MOD_DEL, fd, 0); // Queue for later
        } else {
            h->registered = false;
            epoll_ctl(r->epoll_fd, EPOLL_CTL_DEL, fd, NULL);
        }
    }
    
  |
}

# --- LAYOUT HINTS ---
data_structures.fd_handler -> safe_path.loop_start.it_7.mark: "Sets zombie bit"
data_structures.deferred_mod -> safe_path.loop_start.it_7.mark: "Pushed to queue"