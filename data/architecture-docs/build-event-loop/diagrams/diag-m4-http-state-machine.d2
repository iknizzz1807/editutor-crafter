direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
  # Base style defined in vars to allow spreading into classes
  state_base: {
    style: {
      stroke-width: 2
      border-radius: 8
      font-size: 14
    }
  }
}

# --- STYLE CLASSES ---
classes: {
  input_state: {
    ...${state_base}
    style: {
      fill: "#E1F5FE"
      stroke: "#01579B"
    }
  }
  logic_state: {
    ...${state_base}
    style: {
      fill: "#F3E5F5"
      stroke: "#4A148C"
    }
  }
  output_state: {
    ...${state_base}
    style: {
      fill: "#E8F5E9"
      stroke: "#1B5E20"
    }
  }
  error_state: {
    ...${state_base}
    style: {
      fill: "#FFEBEE"
      stroke: "#B71C1C"
    }
  }
  transition_label: {
    style: {
      font-size: 11
      italic: true
    }
  }
}

# --- STATE DEFINITIONS ---
http_lifecycle: {
  label: "enum conn_http_state (http_server.h)"
  direction: right
  
  READING_HEADERS: "HTTP_READING_HEADERS (0)" {
    class: input_state
    tooltip: "Accumulating bytes until double CRLF (\\r\\n\\r\\n)"
    label_bottom: "Timer: Reset on socket read | Max: 16KB"
  }

  READING_BODY: "HTTP_READING_BODY (1)" {
    class: input_state
    tooltip: "Reading payload of length 'Content-Length'"
    label_bottom: "Timer: Reset on socket read"
  }

  PROCESSING: "HTTP_PROCESSING (2)" {
    class: logic_state
    tooltip: "Headers parsed; routing to handler or static file"
    label_bottom: "Blocking/Async IO handover"
  }

  WRITING_RESPONSE: "HTTP_WRITING_RESPONSE (3)" {
    class: output_state
    tooltip: "Flushing write buffer to kernel"
    label_bottom: "Check for EAGAIN/EWOULDBLOCK"
  }

  CLOSING: "HTTP_CLOSING (4)" {
    class: error_state
    shape: circle
    tooltip: "Close FD and deallocate conn_t"
  }

  # --- TRANSITIONS ---

  READING_HEADERS -> READING_BODY: "Header Complete && CL > 0" {
    class: transition_label
    style.stroke: "#01579B"
  }

  READING_HEADERS -> PROCESSING: "Header Complete && CL == 0" {
    class: transition_label
    style.stroke: "#01579B"
  }

  READING_BODY -> PROCESSING: "body_received == Content-Length" {
    class: transition_label
    style.stroke: "#01579B"
  }

  PROCESSING -> WRITING_RESPONSE: "Handler Success (2xx/3xx)" {
    class: transition_label
    style.stroke: "#4A148C"
  }

  WRITING_RESPONSE -> READING_HEADERS: "wbuf_empty && Connection: Keep-Alive" {
    label: "conn_reset_state()"
    class: transition_label
    style: {
      stroke: "#1B5E20"
      stroke-dash: 3
    }
  }

  # --- EXIT / ERROR PATHS ---

  WRITING_RESPONSE -> CLOSING: "wbuf_empty && Connection: Close" {
    class: transition_label
    style.stroke: "#B71C1C"
  }

  READING_HEADERS -> CLOSING: "431 Request Header Fields Too Large / Timeout" {
    style: {
      stroke: "#B71C1C"
      stroke-dash: 5
    }
  }
  
  READING_BODY -> CLOSING: "ECONNRESET / Timeout" {
    style: {
      stroke: "#B71C1C"
      stroke-dash: 5
    }
  }

  PROCESSING -> CLOSING: "File 404 / 500 / Forbidden" {
    style: {
      stroke: "#B71C1C"
      stroke-dash: 5
    }
  }
}

# --- DOCUMENTATION OVERLAY ---
implementation_notes: |md
  ### Implementation Checklist (http_server.c)
  - **Memory Safety**: `READ_BUF_SIZE` strictly 16KB. All header pointers are offsets into this buffer.
  - **Edge Triggered (EPOLLET)**: States must loop `read()` until `EAGAIN` before sleeping.
  - **Zero-Copy**: Use `sendfile()` in `WRITING_RESPONSE` for static files > 32KB.
  - **Pipelining**: Check if `read_buf` contains the next request start after `PROCESSING`.
| {
  near: bottom-right
}

# Title
main_title: "Reactor Pattern: HTTP/1.1 Connection State machine" {
  shape: text
  near: top-center
  style: {
    font-size: 24
    bold: true
  }
}