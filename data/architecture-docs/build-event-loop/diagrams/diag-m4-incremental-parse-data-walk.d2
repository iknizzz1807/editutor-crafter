direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ---------------------------------------------------------------------------------
# DATA WALK: Incremental HTTP Header Parsing (http_server.c)
# Demonstrates the state machine handling TCP fragmentation across 3 event loop ticks.
# ---------------------------------------------------------------------------------

# LAYER 1: NETWORK INGRESS (TCP Segments)
ingress: {
  label: "TCP INGRESS (Segments)"
  direction: down

  seg1: "Segment 1 | 13B | 'GET /index.ht'" {
    style.stroke: blue
  }
  seg2: "Segment 2 | 20B | 'ml HTTP/1.1\\r\\nHost: ex'" {
    style.stroke: blue
  }
  seg3: "Segment 3 | 13B | 'ample.com\\r\\n\\r\\n'" {
    style.stroke: blue
  }
}

# LAYER 2: BUFFER & PARSER EVOLUTION
parsing_walk: {
  direction: right

  # TICK 1
  tick_1: {
    label: "Tick T1: Partial Header"
    direction: down

    conn_v1: {
      shape: sql_table
      label: "struct http_conn (T1)"
      row1: "0x0000 | char[16384] | read_buf: 'GET /index.ht...'"
      row2: "0x4000 | uint32_t    | read_len: 13"
      row3: "0x4008 | enum        | state: READING_HEADERS"
      label_bottom: "Total: 17,488 bytes"
    }

    logic_v1: {
      shape: code
      label: "find_header_end()"
      language: c
      content: |md
        c
        int hdr_end = find_header_end(buf, 13);
        // Result: -1 (No \r\n\r\n)
        return PARSE_INCOMPLETE;
        
      |
    }
    
    conn_v1 -> logic_v1: "scan 0..13"
  }

  # TICK 2
  tick_2: {
    label: "Tick T2: Pipelined Fragment"
    direction: down

    conn_v2: {
      shape: sql_table
      label: "struct http_conn (T2)"
      row1: "0x0000 | char[16384] | read_buf: 'GET /index.html HTTP/1.1\\r\\nHost: ex...'"
      row2: "0x4000 | uint32_t    | read_len: 33"
      row3: "0x4008 | enum        | state: READING_HEADERS"
    }

    logic_v2: {
      shape: code
      label: "find_header_end()"
      language: c
      content: |md
        c
        int hdr_end = find_header_end(buf, 33);
        // Result: -1 (Still no delimiter)
        return PARSE_INCOMPLETE;
        
      |
    }

    conn_v2 -> logic_v2: "scan 0..33"
  }

  # TICK 3
  tick_3: {
    label: "Tick T3: Completion"
    direction: down

    conn_v3: {
      shape: sql_table
      label: "struct http_conn (T3)"
      row1: "0x0000 | char[16384] | read_buf: '...Host: example.com\\r\\n\\r\\n'"
      row2: "0x4000 | uint32_t    | read_len: 46"
      row3: "0x4008 | enum        | state: PROCESSING"
      style.fill: "#E1F5FE"
    }

    logic_v3: {
      shape: code
      label: "http_parse_headers()"
      language: c
      content: |md
        c
        int hdr_end = find_header_end(buf, 46);
        // Result: 46 (Found \r\n\r\n)
        parse_request_line(buf, ...);
        // Path: "/index.html"
        return PARSE_COMPLETE;
        
      |
    }

    conn_v3 -> logic_v3: "scan 0..46"
    
    action: {
      shape: class
      label: "http_process_request()"
      transition: "state -> PROCESSING"
      method: "build_safe_path()"
    }
    
    logic_v3 -> action: "Parse Success"
  }
}

# CONNECTIONS ACROSS LAYERS
ingress.seg1 -> parsing_walk.tick_1.conn_v1: "read(fd, buf+0, 16384) | 13 bytes"
ingress.seg2 -> parsing_walk.tick_2.conn_v2: "read(fd, buf+13, 16371) | 20 bytes"
ingress.seg3 -> parsing_walk.tick_3.conn_v3: "read(fd, buf+33, 16351) | 13 bytes"

parsing_walk.tick_1 -> parsing_walk.tick_2: "Wait for EPOLLIN"
parsing_walk.tick_2 -> parsing_walk.tick_3: "Wait for EPOLLIN"

# LEGEND / ANNOTATIONS
annotations: {
  near: bottom-right
  header_delimiter: {
    label: "\\r\\n\\r\\n (0x0D 0x0A 0x0D 0x0A)"
    style.font-color: purple
    shape: text
  }
  state_note: {
    label: "Parser is stateless; \nhttp_conn persists buffer."
    style.italic: true
    shape: text
  }
}