direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# LEGEND & SEMANTICS
legend: {
  shape: rectangle
  near: top-left
  label: "Color Semantics\nGreen: Data/Success\nPurple: State Transition\nRed: Closure/Cleanup\nYellow: Idle Timer Reset"
  style: {
    fill: "#fef9c3"
    stroke-dash: 2
  }
}

# DATA STRUCTURE REFERENCE
http_conn_struct: {
  shape: sql_table
  label: "struct http_conn (http_server.c)"
  
  row0: "0x00 | char[16384] | read_buf"
  row1: "0x4000 | write_buf   | wbuf"
  row2: "0x4018 | uint32_t    | read_len"
  row3: "0x401C | int         | fd"
  row4: "0x4020 | int         | timer_id"
  row5: "0x4024 | enum        | state"
  
  label_bottom: "Total: ~17.5 KB per connection"
}

# PERSISTENT CONNECTION FLOW (HTTP/1.1)
http_1_1_persistent: {
  label: "HTTP/1.1 Keep-Alive (Persistent TCP Connection)"
  shape: sequence_diagram
  
  client: Client
  server: Server (http_server.c)
  
  # Request 1
  client -> server: "GET /index.html | ~512B | Req 1 Headers" {
    style.stroke: "#22c55e"
  }
  server -> server: "STATE: HTTP_READING_HEADERS\nTimer Reset: 30s" {
    style.stroke: "#eab308"
  }
  server -> server: "STATE: HTTP_PROCESSING\nhttp_process_request()" {
    style.stroke: "#a855f7"
  }
  server -> client: "HTTP/1.1 200 OK | 1.3KB | Content-Length: 1300" {
    style.stroke: "#3b82f6"
  }
  server -> server: "STATE: HTTP_WRITING_RESPONSE\nconn_flush() -> empty" {
    style.stroke: "#a855f7"
  }
  server -> server: "STATE: HTTP_READING_HEADERS\nhttp_conn_reset_for_keepalive()" {
    style.stroke: "#a855f7"
  }

  # Request 2
  client -> server: "GET /style.css | ~512B | Req 2 Headers" {
    style.stroke: "#22c55e"
  }
  server -> server: "Timer Reset: 30s" {
    style.stroke: "#eab308"
  }
  server -> server: "STATE: PROCESSING -> WRITING"
  server -> client: "HTTP/1.1 200 OK | 4KB"
  server -> server: "STATE: READING_HEADERS (Ready for next)" {
    style.stroke: "#a855f7"
  }

  # Request 3 (Closing)
  client -> server: "GET /logut | Connection: close" {
    style.stroke: "#ef4444"
  }
  server -> server: "Timer Reset: 30s"
  server -> client: "HTTP/1.1 200 OK | Connection: close" {
    style.stroke: "#ef4444"
  }
  server -> server: "STATE: HTTP_CLOSING\nwbuf drained" {
    style.stroke: "#ef4444"
  }
  server -> server: "reactor_defer(http_conn_close_deferred)\nclose(fd)" {
    style.stroke: "#ef4444"
    style.stroke-dash: 5
  }
}

# COMPARISON: EPHEMERAL FLOW (HTTP/1.0)
http_1_0_ephemeral: {
  label: "HTTP/1.0 Ephemeral (Connection per Request)"
  direction: down
  
  conn1: {
    label: "TCP Conn #1"
    h1: "Handshake (SYN/ACK)" {style.stroke: "#94a3b8"}
    req1: "GET /index.html"
    res1: "200 OK"
    fin1: "Close (FIN/ACK)" {style.stroke: "#ef4444"}
    h1 -> req1 -> res1 -> fin1
  }
  
  conn2: {
    label: "TCP Conn #2"
    h2: "Handshake (SYN/ACK)" {style.stroke: "#94a3b8"}
    req2: "GET /style.css"
    res2: "200 OK"
    fin2: "Close (FIN/ACK)" {style.stroke: "#ef4444"}
    h2 -> req2 -> res2 -> fin2
  }
  
  conn3: {
    label: "TCP Conn #3"
    h3: "Handshake (SYN/ACK)" {style.stroke: "#94a3b8"}
    req3: "GET /logout"
    res3: "200 OK"
    fin3: "Close (FIN/ACK)" {style.stroke: "#ef4444"}
    h3 -> req3 -> res3 -> fin3
  }
  
  conn1 -> conn2: "1 RTT Latency Overhead" {style.stroke-width: 2}
  conn2 -> conn3: "1 RTT Latency Overhead" {style.stroke-width: 2}
}

# CONNECTORS
http_conn_struct -> http_1_1_persistent: "Maps state to logic"
http_1_1_persistent -> http_1_0_ephemeral: "Efficiency Comparison:\n1 TCP Stack vs 3" {
  style.stroke-dash: 5
}

# FIXED: Removed object reference for 'near' to comply with ELK engine rules
notes: |md
  ### Key Architectural Gains
  1. **Latency**: HTTP/1.1 saves 2 RTTs of handshake overhead for 3 requests.
  2. **Memory**: Prevents accumulation of connections in `TIME_WAIT` (approx 60s each).
  3. **Framing**: `Content-Length` is mandatory for keep-alive to signal end-of-body.
| {
  near: bottom-center
}