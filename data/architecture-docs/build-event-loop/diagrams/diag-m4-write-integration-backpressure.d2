direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ----------------------------------------------------------------------------------
# CLASSES & STYLING
# ----------------------------------------------------------------------------------
classes: {
  struct: {
    shape: sql_table
    style: {
      fill: "#f4f4f4"
      stroke: "#333333"
    }
  }
  logic_block: {
    shape: code
    style: {
      stroke-width: 2
    }
  }
  kernel_space: {
    style: {
      fill: "#eef9f3"
      stroke: "#3d9069"
      stroke-dash: 3
    }
  }
  hot_path: {
    style: {
      stroke: "#ca052b"
      stroke-width: 4
    }
  }
}

# ----------------------------------------------------------------------------------
# LAYER 1: APPLICATION (HTTP HANDLER)
# ----------------------------------------------------------------------------------
application_layer: {
  label: "APPLICATION LAYER (http_server.c)"
  direction: down

  http_handler: {
    shape: class
    label: "http_process_request()"
    definition: |md
      c
      void http_process_request(http_conn *conn) {
          // 1. Build Headers (MIME, Content-Length: 1048576)
          // 2. Open file: ./public/test.html (1MB)
          // 3. Call conn_write_buffered()
      }
      
    |
  }

  response_data: {
    shape: package
    label: "Prepared Response (1,048,704 Bytes)"
    header: "HTTP/1.1 200 OK\r\nContent-Length: 1048576\r\n..."
    body: "1,048,576 bytes of binary data"
  }

  http_handler -> response_data: "Step 1: Format"
}

# ----------------------------------------------------------------------------------
# LAYER 2: CONNECTION STATE & WRITE BUFFER
# ----------------------------------------------------------------------------------
state_layer: {
  label: "STATE & BUFFERING (Milestone 2/4)"
  direction: down

  conn_struct: {
    class: struct
    label: "struct http_conn (http_server.h)"
    
    row1: "0x00 | int      | fd"
    row2: "0x04 | uint32_t | state = HTTP_WRITING_RESPONSE"
    row3: "0x10 | write_buf| wbuf"
    row4: "0x28 | bool     | epollout_armed"
    label_bottom: "Total size: ~17KB (inc. read_buf)"
  }

  wbuf_struct: {
    class: struct
    label: "struct write_buf (write_buf.h)"
    
    field1: "0x00 | char*    | data (Heap Pointer)"
    field2: "0x08 | uint32_t | len = 896KB (unsent)"
    field3: "0x0C | uint32_t | cap = 1MB"
    field4: "0x10 | uint32_t | offset = 128KB (consumed)"
    label_bottom: "Dynamic Buffer for Backpressure"
  }

  conn_struct.row3 -> wbuf_struct: "contains"
}

# ----------------------------------------------------------------------------------
# LAYER 3: REACTOR & DISPATCH
# ----------------------------------------------------------------------------------
reactor_layer: {
  label: "REACTOR DISPATCH (Milestone 3)"
  direction: down

  dispatch_loop: {
    class: logic_block
    label: "reactor_run() Dispatch"
    content: |md
      c
      if (ev & REACTOR_WRITABLE) {
          h->callback(fd, REACTOR_WRITABLE, h->user_data);
          // Invokes http_on_writable()
      }
      
    |
  }

  flush_logic: {
    class: logic_block
    label: "conn_flush_http()"
    content: |md
      c
      while (!wbuf_is_empty(&c->wbuf)) {
          w = write(c->fd, data + off, len);
          if (w == -1 && EAGAIN) return 0;
          wbuf_consume(&c->wbuf, w);
      }
      // Deregister EPOLLOUT if empty
      
    |
  }
}

# ----------------------------------------------------------------------------------
# LAYER 4: KERNEL & HARDWARE
# ----------------------------------------------------------------------------------
kernel_layer: {
  class: kernel_space
  label: "LINUX KERNEL / TCP STACK"
  direction: down

  tcp_send_buffer: {
    shape: cylinder
    label: "Socket Send Buffer (sk_write_queue)"
    capacity: "128 KB (default auto-tune)"
    status: "FULL (Step 2) -> DRAINING (Step 4-10)"
  }

  nic_dma: {
    shape: diamond
    label: "NIC DMA Engine"
  }

  tcp_send_buffer -> nic_dma: "DMA Transfer to Wire"
}

# ----------------------------------------------------------------------------------
# FLOWS & ANNOTATIONS
# ----------------------------------------------------------------------------------

# Step 2 & 3: Initial write and buffering
application_layer.response_data -> state_layer.conn_struct: "Step 2: conn_write_buffered() | 1,048,704 Bytes" {
  class: hot_path
}

state_layer.conn_struct -> kernel_layer.tcp_send_buffer: "write(fd, buf, 1MB) -> returns 131,072 (128KB)" {
  style: {
    stroke: blue
  }
}

state_layer.conn_struct -> reactor_layer.dispatch_loop: "Step 3: epoll_ctl(MOD, +EPOLLOUT)" {
  label: "Remaining 896KB -> wbuf"
}

# Steps 4-10: The Loop
kernel_layer.tcp_send_buffer -> reactor_layer.dispatch_loop: "Step 4: TCP ACK received -> Buffer space free -> EPOLLOUT" {
  style: {
    stroke: green
    stroke-dash: 5
  }
}

reactor_layer.dispatch_loop -> reactor_layer.flush_logic: "Invokes callback"
reactor_layer.flush_logic -> kernel_layer.tcp_send_buffer: "Step 5-10: write(next 128KB)" {
  class: hot_path
}

# Step 11: Completion
reactor_layer.flush_logic -> state_layer.conn_struct: "Step 11: wbuf->len == 0" {
  label: "Transition: HTTP_READING_HEADERS"
  style: {
    stroke: purple
  }
}

reactor_layer.flush_logic -> kernel_layer: "epoll_ctl(MOD, -EPOLLOUT)" {
  label: "Deregister (Busy-loop defense)"
}

# ----------------------------------------------------------------------------------
# TIMELINE / LEGEND
# ----------------------------------------------------------------------------------
legend: {
  near: bottom-right
  title: "Write Path Timeline"
  t1: "T=0: App attempts 1MB write"
  t2: "T+1: Kernel takes 128KB, 896KB buffered"
  t3: "T+N: NIC clears space, Reactor notifies"
  t4: "T+End: Buffer empty, reset for Keep-Alive"
}