direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 3
  }
}

# ---------------------------------------------------------------------------------------
# LAYER 1: HARDWARE & KERNEL INTERFACE (Milestone 1)
# ---------------------------------------------------------------------------------------
kernel_layer: {
  label: "KERNEL LAYER (epoll_core.c)"
  direction: down

  nic_rx: "Network Interface Card (NIC)\nRX Ring Buffer" {
    shape: cylinder
    style.fill: "#DEE1EB"
  }

  tcp_stack: "Linux TCP/IP Stack\n(net/ipv4/tcp_input.c)" {
    shape: rectangle
    style.fill: "#DEE1EB"
  }

  epoll_subsystem: {
    label: "epoll Instance (M1)"
    
    interest_list: {
      shape: sql_table
      label: "Interest List (RB-Tree)"
      row1: "fd: 3 | events: EPOLLIN"
      row2: "fd: 7 | events: EPOLLIN | EPOLLET"
      row3: "fd: 12| events: EPOLLIN | EPOLLOUT"
    }

    ready_list: {
      shape: sql_table
      label: "Ready List (rdllist)"
      row1: "fd: 7  | status: active"
      row2: "fd: 12 | status: active"
    }
    
    interest_list -> ready_list: "Hardware Interrupt\nvia sock_def_readable"
  }

  nic_rx -> tcp_stack: "DMA Transfer"
  tcp_stack -> epoll_subsystem: "sk_data_ready callback"
}

# ---------------------------------------------------------------------------------------
# LAYER 2: REACTOR ABSTRACTION (Milestone 3)
# ---------------------------------------------------------------------------------------
reactor_layer: {
  label: "REACTOR LAYER (reactor.c)"
  direction: down

  reactor_struct: {
    shape: sql_table
    label: "struct reactor (reactor_internal.h)"
    row1: "0x00 | int        | epoll_fd"
    row2: "0x04 | bool       | dispatching"
    row3: "0x08 | fd_handler | handlers[65536]"
    row4: "0x10 | timer_heap | timers"
    row5: "0x18 | task_q     | deferred_tasks"
    label_bottom: "Total: ~1.5 MB (resident)"
  }

  event_dispatcher: {
    label: "Event Dispatcher (M3)"
    dispatch_loop: |md
      c
      // reactor_run()
      while(r->running) {
        int n = epoll_wait(r->epoll_fd, events, ...);
        reactor_process_timers(r);
        r->dispatching = true;
        for(int i=0; i<n; i++) {
          h->callback(fd, ev, h->user_data);
        }
        r->dispatching = false;
        reactor_apply_deferred_mods(r);
      }
      
    |
  }

  timer_system: {
    label: "Timer Management (M2)"
    shape: class
    fields: |md
      c
      timer_entry timer_heap[65536];
      int timer_heap_size;
      
    |
    methods: |md
      c
      uint64_t now_ms();
      void timer_set(fd, expiry);
      void timer_process_expired();
      
    |
  }

  reactor_struct -> event_dispatcher: "references"
  event_dispatcher -> timer_system: "calls timer_process_expired"
}

# ---------------------------------------------------------------------------------------
# LAYER 3: HTTP APPLICATION (Milestone 2 & 4)
# ---------------------------------------------------------------------------------------
application_layer: {
  label: "APPLICATION LAYER (http_server.c)"
  direction: down

  http_state_machine: {
    label: "HTTP State Machine (M4)"
    shape: class
    fields: |md
      c
      enum {
        HTTP_READING_HEADERS,
        HTTP_READING_BODY,
        HTTP_PROCESSING,
        HTTP_WRITING_RESPONSE
      } state;
      
    |
    methods: |md
      c
      void http_on_readable(fd, ev, ud);
      void http_on_writable(fd, ev, ud);
      
    |
  }

  write_buffering: {
    label: "Write Buffering (M2)"
    shape: sql_table
    label: "struct write_buf"
    row1: "0x00 | char*    | data"
    row2: "0x08 | uint32_t | len"
    row3: "0x0C | uint32_t | offset"
    row4: "0x10 | uint32_t | cap"
    label_bottom: "Max: 256KB per conn"
  }

  http_parser: {
    label: "Incremental Parser (M4)"
    shape: rectangle
    style.fill: "#E4DBFE"
    tooltip: "Scans for \r\n\r\n and parses method/path"
  }

  http_state_machine -> http_parser: "calls"
  http_state_machine -> write_buffering: "manages"
}

# ---------------------------------------------------------------------------------------
# CROSS-LAYER DATA FLOW & ANCHORS
# ---------------------------------------------------------------------------------------

kernel_layer.epoll_subsystem -> reactor_layer.event_dispatcher: "struct epoll_event[] | 12KB | {data.ptr, events}"

reactor_layer.event_dispatcher -> application_layer.http_state_machine: "Callback | REACTOR_READABLE | {fd: 7, ud: http_conn*}"

application_layer.http_state_machine -> kernel_layer.tcp_stack: "Syscall | read/write | 4KB Buffer"

application_layer.write_buffering -> reactor_layer.reactor_struct: "reactor_register | REACTOR_WRITABLE | (Backpressure)"

# Layout rules alignment
kernel_layer -> reactor_layer: "M1 -> M3 Integration"
reactor_layer -> application_layer: "M3 -> M4 Integration"

# Legend/Milestone Indicators
milestones: {
  near: bottom-right
  m1: "M1: epoll Basics" { style.fill: "#C7F1FF" }
  m2: "M2: Write Buffers & Timers" { style.fill: "#ACE1AF" }
  m3: "M3: Reactor API" { style.fill: "#F6C889" }
  m4: "M4: HTTP Implementation" { style.fill: "#E4DBFE" }
}

# Applying milestone colors to key components
kernel_layer.epoll_subsystem.label: "M1: epoll Instance"
kernel_layer.epoll_subsystem.style.fill: "#C7F1FF"

reactor_layer.event_dispatcher.style.fill: "#F6C889"
reactor_layer.timer_system.style.fill: "#ACE1AF"

application_layer.http_state_machine.style.fill: "#E4DBFE"
application_layer.write_buffering.style.fill: "#ACE1AF"