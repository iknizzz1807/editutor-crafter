direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 6
  }
}

# ---------------------------------------------------------------------------------------
# SCENARIO A: THE BUSY-LOOP BUG (MISSING DEREGISTRATION)
# ---------------------------------------------------------------------------------------
Bugged_Trace: {
  label: "SCENARIO A: EPOLLOUT Busy-Loop (Bugged)"
  direction: down
  
  Timeline: {
    shape: sequence_diagram
    User_Space: "Application Reactor"
    Kernel: "Linux epoll subsystem"
    CPU: "CPU Load: 100%" {
      style.fill: "#ffcccc"
      style.stroke: red
    }

    User_Space -> Kernel: "1. epoll_wait(timeout=-1)"
    User_Space <- Kernel: "2. Ready: [fd=5, events=EPOLLOUT]"
    User_Space -> User_Space: "3. handle_writable(fd=5)"
    User_Space -> User_Space: "4. conn_flush(): wbuf.len == 0"
    User_Space -> User_Space: "5. **BUG: No epoll_ctl(MOD) called**"
    User_Space -> Kernel: "6. epoll_wait() (Returns Immediately)"
    
    User_Space <- Kernel: "7. Ready: [fd=5, events=EPOLLOUT]"
    User_Space -> User_Space: "8. handle_writable(fd=5)"
    User_Space -> User_Space: "9. conn_flush(): wbuf.len == 0"
    
    User_Space -> CPU: "Iteration 1,000,000+" {
      style.stroke: red
      style.animated: true
    }
  }

  Legend: |md
    **Root Cause:**
    The kernel send buffer for `fd=5` has space. Since the application has nothing to write but remains registered for `EPOLLOUT`, `epoll_wait` returns immediately.
    
    **Result:**
    Infinite loop of syscalls.
    CPU pins 100% on one core.
  |
}

# ---------------------------------------------------------------------------------------
# SCENARIO B: CORRECT EPOLLOUT LIFECYCLE
# ---------------------------------------------------------------------------------------
Correct_Trace: {
  label: "SCENARIO B: Correct Deregistration Logic"
  direction: down

  Timeline: {
    shape: sequence_diagram
    User_Space: "Application Reactor"
    Kernel: "Linux epoll subsystem"
    CPU: "CPU Load: 0.1%" {
      style.fill: "#ccffcc"
      style.stroke: green
    }

    User_Space -> Kernel: "1. epoll_wait(timeout=-1)"
    User_Space <- Kernel: "2. Ready: [fd=5, events=EPOLLOUT]"
    User_Space -> User_Space: "3. handle_writable(fd=5)"
    User_Space -> User_Space: "4. conn_flush(): wbuf.len == 0"
    User_Space -> Kernel: "5. epoll_ctl(MOD, fd=5, ev=EPOLLIN)" {
      style: {
        stroke: red
        stroke-width: 4
        bold: true
      }
    }
    User_Space -> Kernel: "6. epoll_wait() (Blocks/Sleeps)"
    
    Kernel -> CPU: "CPU Enters HLT State" {
      style.stroke: green
    }
  }

  Legend: |md
    **Mechanism:**
    Once the application-level `write_buf` is empty, the reactor explicitly removes `EPOLLOUT` interest from the kernel.
    
    **Result:**
    `epoll_wait` now blocks until *new* data arrives or a timer expires.
    CPU utilization drops to near zero.
  |
}

Bugged_Trace -> Correct_Trace: "Fix: Implement M2 Deregistration" {
  style.stroke-dash: 5
}

# ---------------------------------------------------------------------------------------
# STATE TRANSITION: EPOLLOUT ARMING (INTEL MANUAL QUALITY)
# ---------------------------------------------------------------------------------------
Write_Interest_States: {
  near: bottom-right
  
  "●": { shape: circle }
  "●" -> Idle: "Init"
  
  Idle: "IDLE (EPOLLIN Only)\nInvar: wbuf.len == 0"
  
  Idle -> Armed: "write() returns EAGAIN\nAction: epoll_ctl(MOD, EPOLLIN|EPOLLOUT)" {
    style.stroke: red
  }
  
  Armed: "BUFFERED (EPOLLIN|EPOLLOUT)\nInvar: wbuf.len > 0" {
    style.fill: "#fff3cc"
  }
  
  Armed -> Armed: "EPOLLOUT fired; wbuf.len still > 0\nAction: conn_flush()"
  
  Armed -> Idle: "EPOLLOUT fired; wbuf.len == 0\nAction: epoll_ctl(MOD, EPOLLIN)" {
    style.stroke: blue
  }
  
  Armed -> Error: "wbuf.len > WRITE_BUF_MAX" {
    style.stroke: red
  }
  
  Error: "FORCE CLOSE" {
    style.fill: "#ff0000"
    style.font-color: white
  }
}