layout-engine: elk
vars: {
  d2-config: {
    theme-id: 4
  }
}

# 1. Memory Layout: timer_entry Struct
timer_entry_layout: {
  shape: sql_table
  label: "timer_entry Struct Layout (sizeof=12)"
  style.stroke: "#333333"

  # Offsets Left, Field/Size Right
  # Purple Header
  "Offset": "Field | Size" { style.fill: "#D1C4E9" }

  # Blue Data
  "0x00": "expiry_ms (uint64_t) | 8B" { style.fill: "#BBDEFB" }
  "0x08": "fd (int32_t) | 4B" { style.fill: "#BBDEFB" }
}

# 2. Heap Array with Cache Boundary
timer_heap_view: {
  label: "timer_heap[] Memory Representation"
  
  timer_heap_array: {
    grid-columns: 1
    h0: "Index 0: fd=12" { style.fill: "#BBDEFB" }
    h1: "Index 1: fd=8" { style.fill: "#BBDEFB" }
    h2: "Index 2: fd=19" { style.fill: "#BBDEFB" }
    h3: "Index 3: fd=42" { 
      style: {
        fill: "#BBDEFB"
        stroke: "#FFA500" # Orange Pointer
        stroke-width: 4
      }
    }
    h4: "Index 4: fd=5" { style.fill: "#BBDEFB" }

    # Cache Line Boundary (64B)
    # entry[0..4] = 12 * 5 = 60B. Entry 5 would cross the 64B boundary.
    padding: "Padding | 4B" { style.fill: "#E0E0E0" }
    boundary: "---------------- 64B Cache Line Boundary ----------------" {
      shape: text
      style: {
        stroke-dash: 5
        font-color: "#757575"
        bold: true
      }
    }
    h5: "Index 5 (Next Cache Line)" { style.fill: "#BBDEFB" }
  }
}

# 3. Connection State Reference
conn_table: {
  label: "Global connections[] (conn_state)"
  shape: sql_table

  "fd (Offset)": "timer_idx | status" { style.fill: "#D1C4E9" }
  "0": "0 | IDLE" { style.fill: "#C8E6C9" } # Green Free
  "1..41": "... | ..." { style.fill: "#EEEEEE" }
  
  "42": "3 | ACTIVE" {
    style: {
      fill: "#BBDEFB"
      stroke: "#FFA500" # Orange pointer field
      stroke-width: 4
    }
  }
  
  "43..MAX": "0 | IDLE" { style.fill: "#C8E6C9" }
}

# Cross-Reference Pointers (Orange)
conn_table."42" -> timer_heap_view.timer_heap_array.h3: "fd 42 is at idx 3" {
  style: {
    stroke: "#FFA500"
    stroke-width: 3
    animated: true
  }
}

timer_heap_view.timer_heap_array.h3 -> conn_table."42": "back-ref" {
  style: {
    stroke: "#FFA500"
    stroke-dash: 3
  }
}

# Documentation
annotation: |md
  ### O(1) Cancellation Logic
  1. Reactor receives `reactor_cancel_timer(fd)`.
  2. Lookup `idx = connections[fd].timer_idx`.
  3. Swap `timer_heap[idx]` with `timer_heap[last]`.
  4. Sift to restore heap property.
  5. Update `connections[new_fd].timer_idx = idx`.
  
  **Complexity: O(log N)** total.
| {
  near: top-right
  style.fill: "#F5F5F5"
}

# Layout constraints for ELK (Replacing forbidden 'near' references with hidden edges)
timer_entry_layout -> timer_heap_view: { style.opacity: 0 }
timer_heap_view -> conn_table: { style.opacity: 0 }