direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

title: |md
  # epoll_wait Timeout Calculation Logic
  *Deriving I/O sleep duration from Timer Min-Heap*
| {near: top-center}

# --- 1. MEMORY LAYOUT ---
# Exact byte offsets left margin, field sizes right margin.
# Purple=Header, Blue=Data, Gray=Padding.
timer_struct: {
  shape: sql_table
  label: "timer_entry_t | sizeof=16 bytes (aligned)"
  
  00: "expiry_ms (uint64_t)" {constraint: "8B"}
  08: "fd (int32_t)" {constraint: "4B"}
  12: "padding" {constraint: "4B"}

  style: {
    stroke: "#000"
    stroke-width: 2
    fill: "#E4DBFE" # Header Purple
  }
  
  00.style.fill: "#cfe2ff" # Blue (Data)
  08.style.fill: "#cfe2ff" # Blue (Data)
  12.style.fill: "#e2e3e5" # Gray (Padding)
}

# --- 2. LOGIC FLOW SECTION ---
logic_flow: {
  label: "Timeout Selection Algorithm"
  style: {
    stroke-width: 2
    fill: "#f8f9fa"
  }

  start: "Start Iteration" {shape: circle}
  get_now: "now = clock_gettime(MONOTONIC)" {style.fill: "#e7f3ff"}
  
  check_size: "timer_heap_size == 0?" {
    shape: diamond
    style.fill: "#fff3cd"
  }

  block_forever: "timeout = -1" {
    style: {
      fill: "#d4edda"
      bold: true
    }
  }

  check_expiry: "heap[0].expiry <= now?" {
    shape: diamond
    style.fill: "#fff3cd"
  }

  immediate: "timeout = 0" {
    style: {
      fill: "#f8d7da"
      bold: true
    }
  }

  calculate: "diff = heap[0].expiry - now" {style.fill: "#e7f3ff"}
  clamp: "timeout = min(diff, INT_MAX)" {style.fill: "#e7f3ff"}

  call_epoll: "epoll_wait(ep_fd, events, MAX, timeout)" {
    shape: rectangle
    style: {
      fill: "#e2e3e5"
      stroke-width: 4
      double-border: true
    }
  }

  start -> get_now
  get_now -> check_size
  check_size -> block_forever: "Yes (No Timers)"
  check_size -> check_expiry: "No"
  check_expiry -> immediate: "Yes (Expired)"
  check_expiry -> calculate: "No (Future)"
  calculate -> clamp
  clamp -> call_epoll
  block_forever -> call_epoll
  immediate -> call_epoll
}

# --- 3. EXECUTION SCENARIOS ---
execution_scenarios: {
  grid-columns: 3
  style.stroke-width: 0

  A: {
    label: "Scenario A: Empty Heap"
    # Fixed 'slot' to 'rectangle' with dashed stroke to represent empty state
    heap: "Heap [ ]" {
      shape: rectangle
      style.stroke-dash: 3
    }
    sys_call: "epoll_wait(..., -1)" {style.fill: "#d4edda"}
    desc: "Server blocks indefinitely until NIC/Socket event occurs."
    heap -> sys_call: "Yields -1"
  }

  B: {
    label: "Scenario B: Scheduled Timer"
    heap: "Heap [ T+5000ms ]" {
      shape: rectangle
      style.fill: "#e7f3ff"
    }
    sys_call: "epoll_wait(..., 5000)" {style.fill: "#e7f3ff"}
    desc: "Server sleeps for 5s. Wakes early if I/O arrives."
    heap -> sys_call: "Yields 5000"
  }

  C: {
    label: "Scenario C: Expired Timer"
    heap: "Heap [ T-10ms ]" {
      shape: rectangle
      style.fill: "#f8d7da"
    }
    sys_call: "epoll_wait(..., 0)" {style.fill: "#f8d7da"}
    desc: "Non-blocking check. Processes stale timers immediately."
    heap -> sys_call: "Yields 0"
  }
}

# --- 4. GLOBAL CONNECTIONS & ANNOTATIONS ---
logic_flow.call_epoll -> execution_scenarios: "Timeout passed to Kernel"
timer_struct.00 -> logic_flow.check_expiry: "Provides heap[0].expiry" {
  style.stroke: "#f39c12" # Orange Pointer
}

legend: |md
  - **-1**: Infinite Block (Wait for I/O)
  - **0**: Instant Return (Process Timers)
  - **N**: Sleep N ms (Bounded Wait)
| {near: bottom-right}