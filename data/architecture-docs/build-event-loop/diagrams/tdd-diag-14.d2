direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 6
  }
}

# LEGEND / INVARIANTS
Legend: {
  shape: rectangle
  label: |md
    ### Lifecycle Invariants
    - **Active Flag**: Must be set `false` first to prevent re-entrant calls.
    - **Timer ID**: Must be cancelled before `close(fd)` to prevent use-after-free on reused FDs.
    - **Write Buffer**: Must be explicitly freed; `close(fd)` does not free heap memory.
    - **Zombie State**: If in Dispatch Loop, defer `close()` to avoid event batch corruption.
  |
  style: {
    stroke: "#ed800c"
    stroke-dash: 2
    fill: "#fcf9e8"
  }
  near: top-right
}

# STATES
"●": {
  shape: circle
  width: 20
  height: 20
}

"●" -> CREATED: "accept4() success"

CREATED: {
  label: "STATE: CREATED"
  description: |md
    **Invariants:**
    - `fd >= 0`
    - `active = true`
    - `timer_idx >= 0`
    - `wbuf.data = NULL`
  |
  style: {
    stroke: "#B5AFF6"
    stroke-width: 2
  }
}

ACTIVE: {
  label: "STATE: ACTIVE"
  description: |md
    **Invariants:**
    - `timer_idx` in Min-Heap
    - `wbuf.data` may be allocated
    - `epollout_armed` tracks kernel state
  |
  style: {
    stroke: "#88DCF7"
    stroke-width: 4
  }
}

TIMING_OUT: {
  label: "STATE: TIMING_OUT"
  description: |md
    **Invariants:**
    - `timer_idx = -1` (Fired)
    - `active = true`
    - `fd` still open
  |
}

CLEANUP: {
  label: "STATE: CLEANUP"
  style: {
    fill: "#fce7c6"
    stroke: "#ed800c"
    stroke-width: 2
  }
  
  # MANDATORY TEARDOWN SEQUENCE
  sequence: {
    shape: sql_table
    style.fill: "#B5AFF6"
    step_1: "1. set active = false" {constraint: "Prevent Re-entry"}
    step_2: "2. timer_cancel()" {constraint: "Stop Heap Refs"}
    step_3: "3. epoll_ctl(DEL)" {constraint: "Kernel Unreg"}
    step_4: "4. wbuf_free()" {constraint: "Heap Free"}
    step_5: "5. close(fd)" {constraint: "FD Release"}
  }
}

ERROR: {
  label: "ERROR / PEER HANGUP"
  style: {
    fill: "#ffcccc"
    stroke: red
  }
}

# TRANSITIONS
CREATED -> ACTIVE: "reactor_register()" {
  label: "Trigger: I/O Registration\nGuard: fd valid\nAction: add to epoll"
}

ACTIVE -> ACTIVE: "read() > 0" {
  label: "Trigger: EPOLLIN\nAction: timer_set(now + 30s)"
}

ACTIVE -> TIMING_OUT: "now_ms() >= expiry" {
  label: "Trigger: epoll_wait timeout\nGuard: r->timer_heap[0] expired"
}

ACTIVE -> ERROR: "read() == 0 || errno != EAGAIN" {
  label: "Trigger: EPOLLIN\nAction: reactor_defer(close)"
}

TIMING_OUT -> CLEANUP: "conn_close()" {
  label: "Action: Execute Mandatory Sequence"
}

ERROR -> CLEANUP: "reactor_run_deferred()"

CLEANUP -> "⊗": "free(conn_struct)"
"⊗": {
  shape: circle
  style.fill: red
}

# ILLEGAL TRANSITIONS
TIMING_OUT -> ACTIVE: "ILLEGAL" {
  style: {
    stroke: red
    stroke-dash: 3
  }
}

# ANNOTATIONS
# FIXED: Changed 'near: CLEANUP' to constant 'near: bottom-center' for ELK compliance.
Annotation: |md
  **CRITICAL FAILURE MODES:**
  1. **Skipping step 2**: Timer fires on a new connection that reused the same FD (Corruption).
  2. **Skipping step 4**: Heap memory leak (~4KB to 256KB per connection).
  3. **Reordering 5 before 3**: Race condition where kernel auto-removes but internal `epoll_armed` flag stays high.
| {
  near: bottom-center
}