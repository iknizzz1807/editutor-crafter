direction: down
layout-engine: elk
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ---------------------------------------------------------------------------------------
# epoll Syscall Sequence: Intel Manual Grade Specification
# ---------------------------------------------------------------------------------------

# Participants
app: Application (User Space) {
  shape: person
}

kernel: Kernel Syscall Interface {
  style.fill: "#DEE1EB"
}

epoll_subsystem: epoll Subsystem (Kernel Space) {
  style.stroke-width: 2
  
  eventpoll: "struct eventpoll" {
    shape: sql_table
    rbtree: "RB-Tree (Interest List)"
    rdllist: "List (Ready List)"
    wq: "wait_queue_head_t"
  }
}

socket_sub: Socket/VFS Subsystem {
  style.fill: "#C7F1FF"
}

# ---------------------------------------------------------------------------------------
# Phase 1: Creation
# ---------------------------------------------------------------------------------------

app -> kernel: "epoll_create1(EPOLL_CLOEXEC)" {
  style.stroke: blue
  style.stroke-width: 2
}

kernel -> epoll_subsystem: "ep_alloc()"
epoll_subsystem.eventpoll.rbtree -> epoll_subsystem.eventpoll.rbtree: "Init Empty"
epoll_subsystem.eventpoll.rdllist -> epoll_subsystem.eventpoll.rdllist: "Init Empty"

kernel <- epoll_subsystem: "eventpoll ptr"
app <- kernel: "return epoll_fd (int > 0)" {
  style.stroke: blue
}

# ---------------------------------------------------------------------------------------
# Phase 2: Interest Registration (ADD)
# ---------------------------------------------------------------------------------------

app -> kernel: "epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &ev)" {
  tooltip: "ev.events = EPOLLIN | EPOLLET; ev.data.fd = sfd;"
}

kernel -> epoll_subsystem: "ep_insert(sfd)"
epoll_subsystem -> epoll_subsystem: "Allocate struct epitem" {
  style.stroke: orange
}

epoll_subsystem.eventpoll.rbtree -> epoll_subsystem.eventpoll.rbtree: "rb_insert(epitem)"
epoll_subsystem -> socket_sub: "poll_wait(socket_callback)"

kernel <- epoll_subsystem: "Success"
app <- kernel: "return 0"

# Error Path: Duplicate ADD
app -> kernel: "epoll_ctl(ADD, existing_fd, ...)" {
  style.stroke: red
  style.stroke-dash: 3
}
kernel -> app: "return -1, errno=EEXIST" {
  style.stroke: red
}

# ---------------------------------------------------------------------------------------
# Phase 3: Wait and Async Trigger
# ---------------------------------------------------------------------------------------

app -> kernel: "epoll_wait(efd, &events, max, -1)" {
  style.stroke: blue
}

kernel -> epoll_subsystem: "ep_poll()"
epoll_subsystem -> kernel: "Block (Wait on eventpoll.wq)"

# ASYNC EVENT FROM HARDWARE
socket_sub -- epoll_subsystem: "ASYNC: sock_def_readable()" {
  style.stroke: orange
  style.animated: true
}

epoll_subsystem -> epoll_subsystem: "epitem -> eventpoll.rdllist" {
  style.stroke: "#F4B76C"
  style.bold: true
}

epoll_subsystem -> kernel: "Wakeup"

kernel -> app: "copy_to_user(events_array, count)" {
  style.stroke: blue
  style.stroke-width: 4
}

# ---------------------------------------------------------------------------------------
# Phase 4: Termination (DEL)
# ---------------------------------------------------------------------------------------

app -> kernel: "epoll_ctl(efd, EPOLL_CTL_DEL, sfd, NULL)"

kernel -> epoll_subsystem: "ep_remove(epitem)"
epoll_subsystem.eventpoll.rbtree -> epoll_subsystem.eventpoll.rbtree: "rb_erase(epitem)"
epoll_subsystem -> epoll_subsystem: "kmem_cache_free(epitem)"

kernel <- epoll_subsystem: "Success"
app <- kernel: "return 0"

# Cleanup Annotation
note: |md
  ### epoll Lifecycle Summary
  - **create1**: Allocates kernel `struct eventpoll`. `O(1)`.
  - **ctl ADD**: Inserts `epitem` into Red-Black Tree. `O(log N)`.
  - **wait**: Returns FDs from `rdllist`. `O(k)` where k=ready count.
  - **DEL**: Removal from RB-Tree. `O(log N)`.
  - **Close**: Kernel auto-removes FDs from epoll if last ref to file is closed.
| {
  near: bottom-right
}