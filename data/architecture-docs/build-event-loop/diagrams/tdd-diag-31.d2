layout-engine: elk
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

title: |md
  # HTTP Keep-Alive vs. Short-Lived Connections
  ### Impact on File Descriptor Budget and Latency (RTT)
| {
  near: top-center
  shape: text
}

# -----------------------------------------------------------------------------
# SCENARIO 1: WITHOUT KEEP-ALIVE (Standard/Legacy)
# -----------------------------------------------------------------------------
standard_flow: "Scenario A: Connection Per Request (Standard)" {
  style: {
    stroke: "#FFB3B3"
    stroke-dash: 3
    fill: "#FFF5F5"
  }
  
  sd: {
    shape: sequence_diagram
    
    client: Client
    server: Server
    
    # Request 1
    client -> server: TCP SYN {tooltip: "RTT Start"}
    client <- server: TCP SYN-ACK {tooltip: "1 RTT Complete"}
    client -> server: GET /img1.png
    client <- server: 200 OK (Data)
    client -> server: TCP FIN
    client <- server: TCP ACK {tooltip: "Socket enters TIME_WAIT (60s)"}
    
    server."FD 101: TIME_WAIT" {
      style.font-color: red
    }

    # Request 2
    client -> server: TCP SYN
    client <- server: TCP SYN-ACK
    client -> server: GET /img2.png
    client <- server: 200 OK (Data)
    client -> server: TCP FIN
    client <- server: TCP ACK
    
    server."FD 102: TIME_WAIT" {
      style.font-color: red
    }
    
    # ... and so on for Req 3, 4, 5
    client."Repeated for all 5 requests"
  }

  impact: |md
    ### Performance Metrics
    - **Handshake Overhead:** 10 RTTs (2 per req)
    - **FD Consumption:** 5 FDs held for 60s
    - **Resource Cost:** High kernel churn (TCP PCB allocation)
  | {
    shape: text
  }
}

# -----------------------------------------------------------------------------
# SCENARIO 2: WITH KEEP-ALIVE (Persistent)
# -----------------------------------------------------------------------------
keep_alive_flow: "Scenario B: Keep-Alive Connection (HTTP/1.1+)" {
  style: {
    stroke: "#B3FFB3"
    stroke-dash: 0
    fill: "#F5FFF5"
  }
  
  sd: {
    shape: sequence_diagram
    
    client: Client
    server: Server
    
    # Single Handshake
    client -> server: TCP SYN
    client <- server: TCP SYN-ACK {tooltip: "Handshake: 1 RTT total"}
    
    # Request Pipeline 1-5
    client -> server: GET /img1.png
    client <- server: 200 OK (Data)
    
    client -> server: GET /img2.png
    client <- server: 200 OK (Data)
    
    client -> server: GET /img3.png
    client <- server: 200 OK (Data)
    
    client -> server: GET /img4.png
    client <- server: 200 OK (Data)
    
    client -> server: GET /img5.png
    client <- server: 200 OK (Data)
    
    # Graceful Close or Idle Timeout
    client -> server: TCP FIN
    client <- server: TCP ACK
    
    server."FD 101: Reused" {
      style.font-color: green
    }
  }

  impact: |md
    ### Performance Metrics
    - **Handshake Overhead:** 2 RTTs (total)
    - **FD Consumption:** 1 FD held for duration
    - **Resource Cost:** Low (stable state)
  | {
    shape: text
  }
}

# -----------------------------------------------------------------------------
# CRITICAL SYSTEM ANALYSIS
# -----------------------------------------------------------------------------
analysis: "C10K Systems Analysis & Constraints" {
  near: bottom-center
  
  math: |md
    ## The Math of Failure (Why Keep-Alive is Mandatory)
    
    Assuming **10,000 requests per second**:
    
    **1. Without Keep-Alive:**
    - New Connections/sec: 10,000
    - `TIME_WAIT` Duration: 60 seconds (Kernel default)
    - Total Concurrent FDs: $10,000 \times 60 = 600,000$
    - **Result:** `ulimit -n` (typically 65,535) is exhausted in **~6.5 seconds**.
    
    **2. With Keep-Alive (30s Idle Timeout):**
    - Steady State Connections: ~10,000
    - Total Concurrent FDs: ~10,000 + burst headroom
    - **Result:** System stable indefinitely within standard FD budgets.
  | {
    shape: text
    style: {
      fill: "#FFFFE0"
      stroke: "#D4AF37"
      font-size: 14
    }
  }
}

# Layout constraints
standard_flow -> keep_alive_flow: "Architecture Comparison" {
  style.stroke-width: 0
}