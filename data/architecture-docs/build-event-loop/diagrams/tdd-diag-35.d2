direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# Classes for Technical Design Artist Spec
classes: {
  logic: {
    style: {
      fill: "#E1D5E7" # Purple (Logic/Header)
      stroke: "#9673A6"
      stroke-width: 2
    }
  }
  data_buffer: {
    style: {
      fill: "#DAE8FC" # Blue (Data)
      stroke: "#6C8EBF"
      stroke-width: 2
    }
  }
  kernel_space: {
    style: {
      fill: "#F5F5F5" # Gray (Padding/System)
      stroke: "#666666"
      stroke-dash: 3
    }
  }
  hardware: {
    style: {
      fill: "#FFE6CC" # Orange (Hardware/Pointers)
      stroke: "#D79B00"
      stroke-width: 3
    }
  }
}

# 1. Application Layer: Generating Response
AppLayer: "Application Layer (User Space)" {
  process_req: "http_process_request()" {
    class: logic
    tooltip: "Builds headers and opens file_fd"
  }

  stack_headers: "Header Buffer\n(Stack: 512 Bytes)" {
    class: data_buffer
    shape: cylinder
  }

  file_cache: "Page Cache / File Read\n(64KB Chunks)" {
    class: data_buffer
    shape: cylinder
  }

  process_req -> stack_headers: "snprintf()"
  stack_headers -> WriteEngine.conn_write: "conn_write(headers)"
  file_cache -> WriteEngine.conn_write: "conn_write(chunk)"
}

# 2. Write Buffering Logic (M2 Engine)
WriteEngine: "Write Strategy & Backpressure" {
  conn_write: "conn_write()" {
    class: logic
    shape: parallelogram
  }

  wbuf: "Write Buffer (wbuf)\n(Heap: 256KB Max)" {
    class: data_buffer
    shape: rectangle
    style: {
      double-border: true
    }
  }

  epoll_mod_plus: "epoll_ctl(MOD, +EPOLLOUT)" {
    class: logic
    style: { font-color: red; bold: true }
  }

  conn_write -> wbuf: "If write() == EAGAIN\n(Buffer remainder)"
  conn_write -> KernelLayer.socket_buffer: "Fast Path\n(wbuf is empty)"
  wbuf -> epoll_mod_plus: "Arm EPOLLOUT"
}

# 3. Reactor & Asynchronous Flush
ReactorDispatch: "Reactor & Event Loop" {
  reactor_run: "Reactor Loop" {
    class: logic
    shape: circle
  }

  on_writable: "http_on_writable()" {
    class: logic
  }

  conn_flush: "conn_flush()" {
    class: logic
    tooltip: "Drains wbuf to socket"
  }

  reactor_run -> on_writable: "EPOLLOUT Event"
  on_writable -> conn_flush
  conn_flush -> KernelLayer.socket_buffer: "write(fd, wbuf.ptr, len)"
}

# 4. Kernel and Hardware Path
KernelLayer: "Kernel & Hardware (Ring 0)" {
  style.stroke: "#666666"
  style.stroke-dash: 5

  socket_buffer: "Socket Send Buffer\n(TCP sk_write_queue)" {
    class: kernel_space
    shape: cylinder
  }

  tcp_stack: "TCP Segmenter / IP Stack" {
    class: kernel_space
  }

  nic_tx_ring: "NIC TX Ring Buffer" {
    class: hardware
  }

  dma_engine: "DMA Engine" {
    class: hardware
    shape: hexagon
  }

  wire: "Network Wire\n(Ethernet/Fiber)" {
    class: hardware
    shape: cloud
  }

  socket_buffer -> tcp_stack
  tcp_stack -> nic_tx_ring
  nic_tx_ring -> dma_engine: "Trigger Descriptor"
  dma_engine -> wire: "PCIe → Wire (Zero Copy)"
}

# 5. Lifecycle Completion
Completion: "Post-Write Lifecycle" {
  check_empty: "wbuf empty?" {
    class: logic
    shape: diamond
  }

  epoll_mod_minus: "epoll_ctl(MOD, -EPOLLOUT)" {
    class: logic
  }

  keep_alive: "http_conn_reset_for_keepalive()" {
    class: logic
    style.fill: "#D5E8D4" # Green (Free/Reset)
  }

  deferred_close: "reactor_defer(http_conn_close)" {
    class: logic
    style.fill: "#F8CECC" # Red (Closing)
  }

  ReactorDispatch.conn_flush -> check_empty
  check_empty -> epoll_mod_minus: "Yes"
  epoll_mod_minus -> keep_alive: "req.keep_alive == true"
  epoll_mod_minus -> deferred_close: "state == CLOSING"
}

# Metadata Annotations
ann: |md
  ### Data Flow Specification
  1. **Fast Path**: Bytes move `Stack -> Socket Buffer` (~5µs).
  2. **Backpressure**: If `EAGAIN`, Reactor manages `EPOLLOUT`.
  3. **Zero-Copy Intent**: DMA handles the move to the wire without CPU.
  4. **State**: Transition to `KEEP_ALIVE` resets headers for next request.
| {
  near: top-right
}