layout-engine: elk
vars: {
  d2-config: {
    theme-id: 4
  }
}

direction: right

# --- 1. ARRIVAL STATE ---
Step_1: {
  label: "STEP 1: 8000 Bytes Arrive"
  style.fill: "#F3E5F5" # Header: Purple
  
  LT_Kernel: {
    label: "LT Kernel Buffer"
    buffer: "8000 / 8000"
    state: "READY (EPOLLIN)"
    style.fill: "#E3F2FD" # Data: Blue
    style.stroke: blue
  }
  
  ET_Kernel: {
    label: "ET Kernel Buffer"
    buffer: "8000 / 8000"
    state: "TRANSITION: EMPTY -> FULL"
    style.fill: "#E3F2FD" # Data: Blue
    style.stroke: blue
  }
}

# --- 2. PARTIAL READ STATE ---
Step_2: {
  label: "STEP 2: read(4096) Invoked"
  style.fill: "#F3E5F5" # Header: Purple
  
  LT_Kernel: {
    label: "LT Kernel Buffer"
    buffer: "**3904 / 8000**"
    state: "STILL READY (Level)"
    style.fill: "#E3F2FD"
    style.stroke: blue
    buffer.style: {
      font-color: red
      bold: true
    }
  }
  
  ET_Kernel: {
    label: "ET Kernel Buffer"
    buffer: "**3904 / 8000**"
    state: "EVENT CONSUMED (Edge)"
    style.fill: "#E3F2FD"
    style.stroke: blue
    buffer.style: {
      font-color: red
      bold: true
    }
  }
}

# --- 3. SUBSEQUENT POLL STATE ---
Step_3: {
  label: "STEP 3: Return to epoll_wait"
  style.fill: "#F3E5F5" # Header: Purple
  
  LT_Kernel: {
    label: "LT Kernel Buffer"
    buffer: "3904 / 8000"
    action: "**WAKES IMMEDIATELY**"
    style.fill: "#E1F5FE"
    action.style: {
      font-color: "#2E7D32" # Green for success
      bold: true
    }
  }
  
  ET_Kernel: {
    label: "ET Kernel Buffer"
    buffer: "3904 / 8000"
    action: "**BLOCKS INDEFINITELY**"
    style.fill: "#FFEBEE"
    action.style: {
      font-color: red # Red for deadlock state
      bold: true
    }
  }
}

# --- CONNECTIONS & FLOW ---
Step_1 -> Step_2: "User calls read(4096)"
Step_2 -> Step_3: "User calls epoll_wait()"

Annotation: |md
  ### The Edge-Triggered Deadlock
  In **Edge-Triggered** mode, the kernel only notifies when the buffer transitions from empty to having data. 
  Because 3904 bytes remain, the state is still "Non-Empty". 
  The kernel will **never** fire `EPOLLIN` again until *new* data arrives from the network.
  If the protocol expects the server to respond before the client sends more data, the system is **Deadlocked**.
| {
  near: bottom-center
  style: {
    stroke: red
    fill: "#FFF9C4"
    stroke-width: 2
  }
}

Step_3.ET_Kernel -> DEADLOCK: {
  style: {
    stroke: red
    stroke-width: 4
    animated: true
  }
}

DEADLOCK: "DEADLOCK" {
  shape: cloud
  style: {
    fill: red
    font-color: white
    bold: true
  }
}