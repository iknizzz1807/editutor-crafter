{
  "types": {
    "Entity": "fields: m_id uint32_t",
    "Component": "pure data structure attached to entities",
    "System": "logic processor for component data",
    "ECSWorld": "coordinates entities, components, and systems",
    "Application": "main application framework class",
    "Window": "fields: m_window SDL_Window*, m_glContext void*, m_width int, m_height int, m_resizeCallback ResizeCallback",
    "Renderer": "graphics rendering interface and pipeline",
    "Timer": "time measurement utility for frame timing",
    "FrameTimer": "frame rate management with fixed timestep",
    "AABB": "axis-aligned bounding box for collision",
    "Circle": "circular collision shape",
    "CollisionPair": "detected collision between two entities",
    "WindowConfig": "fields: title string, width int, height int, fullscreen bool, resizable bool, vsync bool, samples int",
    "Vector2": "fields: x float, y float",
    "Vector3": "fields: x float, y float, z float",
    "TextureHandle": "derived from Handle<T>",
    "MeshHandle": "derived from Handle<T>",
    "AudioHandle": "derived from Handle<T>",
    "SceneHandle": "derived from Handle<T>",
    "Transform": "fields: position Vector3, rotation Vector3, scale Vector3",
    "Sprite": "fields: texture TextureHandle, size Vector2, color Vector4, layer int",
    "RigidBody": "fields: velocity Vector3, acceleration Vector3, mass float, drag float, kinematic bool",
    "ComponentArray<T>": "fields: m_components vector<T>, m_entityToIndex unordered_map, m_indexToEntity vector<Entity>, m_freeIndices vector<size_t>",
    "Handle<T>": "fields: m_handle uint64_t",
    "ShaderProgram": "fields: m_programID uint32_t, m_vertexShaderID uint32_t, m_fragmentShaderID uint32_t, m_uniformLocations unordered_map<string,int>, m_attributeLocations unordered_map<string,int>, m_isLinked bool",
    "SpriteVertex": "fields: position Vector2, texCoord Vector2, color Vector4",
    "SpriteRenderData": "fields: transform Matrix4, color Vector4, textureID uint32_t, depth float",
    "BatchRenderer": "fields: m_VAO uint32_t, m_VBO uint32_t, m_EBO uint32_t, m_spriteShader ShaderProgram, m_viewProjection Matrix4, m_batches vector<BatchData>, m_spriteQueue vector<SpriteRenderData>",
    "Vector4": "fields: x float, y float, z float, w float",
    "Matrix4": "fields: 16 float values in column-major order",
    "TextureResource": "fields: textureID uint32_t, width int, height int, version uint16_t, referenceCount atomic<uint32_t>, filepath string",
    "MeshResource": "fields: VAO uint32_t, VBO uint32_t, EBO uint32_t, vertexCount int, indexCount int, version uint16_t, referenceCount atomic<uint32_t>, filepath string",
    "AudioResource": "fields: bufferID uint32_t, sampleRate int, channels int, duration float, version uint16_t, referenceCount atomic<uint32_t>, filepath string",
    "Scene": "fields: m_metadata SceneMetadata, m_entities vector<Entity>, m_textureReferences unordered_map, m_meshReferences unordered_map, m_audioReferences unordered_map",
    "SceneMetadata": "fields: name string, version string, engineVersion string, requiredResources vector<string>",
    "LoadRequest": "fields: filepath string, type ResourceType, callback function, priority int",
    "TextureData": "fields: pixels vector<uint8_t>, width int, height int, channels int",
    "MeshData": "fields: vertices vector<float>, indices vector<uint32_t>, vertexCount int, indexCount int",
    "AudioData": "fields: samples vector<float>, sampleRate int, channels int, duration float",
    "ThreadSafeQueue<T>": "fields: m_queue queue<T>, m_mutex mutex, m_condition condition_variable",
    "ResourceManager": "fields: m_textures vector<TextureResource>, m_meshes vector<MeshResource>, m_audioClips vector<AudioResource>, m_textureHandles unordered_map, m_meshHandles unordered_map, m_audioHandles unordered_map, m_loadQueue ThreadSafeQueue<LoadRequest>, m_workerThreads vector<thread>, m_shouldStop atomic<bool>",
    "GLErrorChecker": "fields: s_enableChecking bool, s_errorStrings unordered_map<GLenum,string>",
    "ShaderCompiler": "static methods for compilation",
    "PhysicsMonitor": "fields: m_currentMetrics SimulationMetrics, m_baselineMetrics SimulationMetrics, m_energyHistory vector<float>",
    "SimulationMetrics": "fields: totalEnergy float, maxVelocity float, maxPosition float, nanDetectedCount uint32_t",
    "TunnellingPreventer": "static methods for tunnelling detection",
    "ThreadSafeErrorQueue": "fields: m_mutex mutex, m_queue queue, m_condition condition_variable",
    "ResourceLoadError": "fields: resourcePath string, resourceType ResourceType, errorCode uint32_t, errorMessage string",
    "FallbackResourceManager": "fields: m_fallbackHierarchy unordered_map",
    "TestResult": "test execution result with timing",
    "TestRunner": "manages test registration and execution",
    "PerformanceTimer": "high-resolution timing utility",
    "MemoryTracker": "allocation tracking and leak detection",
    "GraphicsDebugger": "graphics state capture and analysis",
    "EngineLogger": "async logging system with thread-safe queue",
    "MemoryAnalyzer": "comprehensive memory tracking and leak detection",
    "SystemProfiler": "ECS system performance monitoring",
    "ThreadSafeQueue": "fields: m_queue queue<T>, m_mutex mutex, m_condition condition_variable",
    "Handle": "fields: m_handle uint64_t",
    "ComponentTypeID": "type identifier for component types",
    "FramebufferManager": "manages OpenGL framebuffers and render targets",
    "RenderPassManager": "coordinates multi-pass rendering pipeline",
    "AudioSource": "ECS component for positioned audio",
    "AudioListener": "ECS component for audio receiver",
    "AudioSystem": "processes spatial audio each frame",
    "Job": "description for parallel work execution",
    "JobSystem": "multi-threaded job execution system",
    "ComponentStorage": "interface for component storage strategies",
    "TerminologyValidator": "validates terminology consistency",
    "DocumentationGenerator": "generates documentation from terminology",
    "TerminologyIntegration": "integrates terminology validation with development tools"
  },
  "methods": {
    "CreateEntity() -> Entity": "creates new entity with unique recycled ID",
    "DestroyEntity(Entity)": "removes entity and all associated components",
    "AddComponent<T>(Entity, Args...) -> T&": "adds component to entity with constructor arguments",
    "RemoveComponent<T>(Entity)": "removes specific component type from entity",
    "GetComponent<T>(Entity) -> T*": "retrieves component pointer or nullptr",
    "RegisterSystem<T>(Args...)": "adds system to execution pipeline",
    "UpdateSystems(float)": "executes all registered systems with delta time",
    "ShouldClose() -> bool": "checks if window close was requested",
    "SwapBuffers()": "presents rendered frame to screen",
    "PollEvents()": "processes OS input and window events",
    "Update()": "updates timer and calculates new delta time",
    "GetDeltaTime() -> float": "returns time elapsed since last frame",
    "Initialize(WindowConfig) -> InitResult": "creates window and initializes all subsystems",
    "Run() -> int": "enters main game loop until exit",
    "Shutdown()": "cleanly destroys subsystems",
    "StepSimulation(float)": "advances physics by fixed timestep",
    "RenderFrame()": "executes rendering pipeline",
    "GetIndex() -> uint32_t": "extracts index from entity ID",
    "GetGeneration() -> uint32_t": "extracts generation from entity ID",
    "GetID() -> uint32_t": "extracts resource ID from handle",
    "IsValid() -> bool": "checks if handle points to valid resource",
    "GetType() -> ResourceType": "extracts resource type from handle",
    "GetVersion() -> uint16_t": "extracts version from resource handle",
    "HasComponent(Entity) -> bool": "checks if entity has specific component",
    "GetEntity(size_t) -> Entity": "gets entity ID for component at index",
    "Initialize(WindowConfig) -> bool": "creates window and initializes graphics context",
    "Shutdown() -> void": "cleanly destroys window and context resources",
    "SwapBuffers() -> void": "presents rendered frame to screen",
    "PollEvents() -> void": "processes OS input and window events",
    "LoadFromFiles(string, string) -> bool": "loads and compiles shaders from vertex and fragment files",
    "Use() -> void": "binds shader program for rendering",
    "SetUniform(string, value) -> void": "sets uniform variable in active shader",
    "BeginBatch(Matrix4) -> void": "starts new batch with view-projection matrix",
    "SubmitSprite(SpriteRenderData) -> void": "adds sprite to current batch queue",
    "EndBatch() -> void": "processes and renders all batched sprites",
    "DetectCollisions() -> vector<CollisionPair>": "runs broad and narrow phase collision detection",
    "ResolveCollisions(vector<CollisionPair>)": "applies impulse response and position correction",
    "IntegrateMotion(float)": "updates velocity and position using semi-implicit Euler",
    "TestAABBvsAABB(AABB, AABB, CollisionPair) -> bool": "narrow phase geometric intersection test",
    "ApplyImpulse(Entity, Entity, CollisionPair)": "calculates and applies collision impulse forces",
    "CorrectPositions(Entity, Entity, CollisionPair)": "separates overlapping objects with position correction",
    "LoadTexture(filepath) -> TextureHandle": "loads texture synchronously, returns handle",
    "LoadTextureAsync(filepath, callback)": "loads texture in background thread",
    "LoadMesh(filepath) -> MeshHandle": "loads 3D mesh synchronously",
    "LoadAudio(filepath) -> AudioHandle": "loads audio clip synchronously",
    "GetTexture(handle) -> TextureResource*": "retrieves texture data from handle",
    "GetMesh(handle) -> MeshResource*": "retrieves mesh data from handle",
    "GetAudio(handle) -> AudioResource*": "retrieves audio data from handle",
    "AddReference(handle)": "increments resource reference count",
    "RemoveReference(handle)": "decrements reference count, cleanup if zero",
    "RunGarbageCollection()": "frees resources with zero reference count",
    "ProcessAsyncUploads()": "uploads completed loads to GPU",
    "SaveToFile(filepath, world) -> bool": "serializes scene to disk file",
    "LoadFromFile(filepath, world, resources) -> bool": "deserializes scene from file",
    "ToJSON(world) -> json": "converts scene to JSON representation",
    "FromJSON(json, world, resources) -> bool": "reconstructs scene from JSON data",
    "Push(item)": "adds item to thread-safe queue",
    "TryPop(item) -> bool": "attempts to remove item from queue",
    "WaitAndPop(item)": "blocks until item available in queue",
    "Empty() -> bool": "checks if queue has no items",
    "Size() -> size_t": "returns number of items in queue",
    "CheckErrors(const char*, const char*, int) -> bool": "validates OpenGL operations",
    "CompileShader(uint32_t, string, GLenum, string&) -> bool": "compiles shader with error handling",
    "ValidateSimulationState(vector<RigidBody>) -> bool": "checks physics stability",
    "CheckForTunnelling(RigidBody, Transform, Transform, float) -> bool": "detects potential tunnelling",
    "Push(T) -> void": "adds item to thread-safe queue",
    "GetFallbackResource(ResourceType, uint32_t) -> Handle": "retrieves fallback resource",
    "RegisterTest(string, function)": "adds test to execution suite",
    "RunAllTests() -> vector<TestResult>": "executes all registered tests",
    "RunTestsByPattern(string)": "runs tests matching pattern",
    "Start()": "begins performance timing",
    "Stop()": "ends performance timing",
    "GetMilliseconds() -> double": "returns elapsed time in milliseconds",
    "RecordAllocation(void*, size_t, const char*, int)": "tracks memory allocation",
    "RecordDeallocation(void*)": "tracks memory deallocation",
    "DumpLeaks()": "prints unfreed allocations",
    "Log(LogLevel, string, string, const char*, int)": "adds entry to async log queue",
    "GenerateReport()": "exports profiling data",
    "RecordSimulationState(vector<RigidBody>)": "captures physics metrics",
    "CalculateMaxSafeVelocity(AABB, float) -> float": "computes tunneling-safe velocity",
    "CreateFramebuffer(name, config) -> bool": "creates framebuffer with specified configuration",
    "BindFramebuffer(name)": "bind framebuffer for rendering",
    "GetColorTexture(name) -> uint32_t": "get color texture handle for use in subsequent passes",
    "AddPass(name, framebuffer, shader, setup)": "add render pass to execution pipeline",
    "ExecutePasses()": "execute all passes in sequence",
    "Initialize() -> bool": "initialize audio context and set up 3D audio parameters",
    "Update(world, deltaTime)": "update all audio sources based on 3D positions relative to listener",
    "PlaySoundAtPosition(audio, position, volume)": "trigger one-shot audio playback at specific world position",
    "SubmitJob(job)": "add job to least loaded worker queue",
    "WaitForCompletion()": "wait for all currently queued jobs to complete",
    "ExecuteSystemsParallel(systems, world, deltaTime)": "execute systems in parallel where component dependencies allow",
    "RegisterTerm(string, string)": "adds term to validation dictionary",
    "ValidateCodebase(string) -> bool": "scans source for terminology consistency",
    "GenerateMarkdownGlossary(string)": "creates glossary documentation",
    "ValidatePullRequest(string) -> bool": "checks code changes for terminology violations"
  },
  "constants": {
    "TARGET_FPS": "60.0f",
    "MAX_ENTITIES": "4194304",
    "NULL_ENTITY": "Entity{0} - invalid entity ID",
    "TARGET_FRAME_TIME": "16.67ms frame budget",
    "INDEX_BITS": "22",
    "GENERATION_BITS": "10",
    "TYPE_BITS": "16 - bits for resource type in handle",
    "VERSION_BITS": "16 - bits for resource version in handle",
    "ID_BITS": "32 - bits for resource ID in handle",
    "MAX_SPRITES_PER_BATCH": "1000 - maximum sprites per batch",
    "VERTICES_PER_SPRITE": "4 - quad vertices per sprite",
    "INDICES_PER_SPRITE": "6 - triangle indices per sprite",
    "PHYSICS_TIMESTEP": "1.0f/60.0f",
    "MAX_ACCUMULATED_TIME": "100ms - prevents spiral of death",
    "POSITION_CORRECTION_PERCENT": "0.8f overlap correction fraction",
    "GRID_CELL_SIZE": "64.0f - spatial partitioning cell size",
    "NULL_HANDLE": "0",
    "TYPE_SHIFT": "48 - bit shift for type field",
    "VERSION_SHIFT": "32 - bit shift for version field",
    "ID_MASK": "0xFFFFFFFF - mask for ID extraction",
    "VERSION_MASK": "0xFFFF - mask for version extraction",
    "TYPE_MASK": "0xFFFF - mask for type extraction",
    "GL_CONTEXT_LOST_KHR": "OpenGL context loss error code",
    "PENETRATION_TOLERANCE": "0.01f units minimum overlap"
  },
  "terms": {
    "archetype": "group of entities with identical component signatures",
    "component signature": "bitset indicating component types",
    "data-oriented design": "organizing data by access patterns",
    "frame time budget": "maximum time per frame for target framerate",
    "cache-friendly": "memory layout optimized for CPU cache",
    "spatial partitioning": "dividing space for collision optimization",
    "broad phase": "fast approximate collision detection using spatial partitioning",
    "narrow phase": "precise geometric intersection testing between collision shapes",
    "fixed timestep": "constant time increment for physics",
    "handle-based access": "indirect resource access through validated handles",
    "struct-of-arrays": "organizing data with separate arrays for each field type",
    "array-of-structs": "organizing data with objects containing all fields together",
    "generation counter": "version number for handle validation",
    "dense storage": "contiguous array storage without gaps",
    "batch rendering": "grouping draw operations to minimize state changes",
    "immediate mode": "direct rendering commands issued from game logic",
    "retained mode": "scene graph approach with cached render commands",
    "vertex buffer": "GPU memory storing vertex attribute data",
    "shader program": "linked vertex and fragment shaders",
    "uniform variable": "shader parameter constant across draw call",
    "framebuffer": "render target for GPU drawing operations",
    "swap chain": "double buffering system for smooth frame presentation",
    "draw call": "GPU command to render geometry",
    "state change": "GPU pipeline reconfiguration between draw operations",
    "impulse response": "instantaneous velocity changes that simulate collision forces",
    "position correction": "separating overlapping objects to prevent visual artifacts",
    "semi-implicit Euler": "integration method that updates velocity first, then position",
    "accumulator pattern": "time debt system that decouples physics from rendering frame rate",
    "deterministic simulation": "identical inputs produce identical outputs",
    "penetration depth": "how far two collision shapes have overlapped",
    "reference counting": "usage tracking for automatic cleanup",
    "asynchronous loading": "background loading without blocking",
    "resource manifest": "list of all assets required by a scene",
    "atomic operations": "thread-safe operations without explicit locking",
    "two-phase commit": "load validation then atomic scene transition",
    "resource lifecycle": "states from load request through active use to cleanup",
    "GPU resource upload": "transferring asset data from CPU to graphics memory",
    "scene serialization": "converting entity-component state to persistent format",
    "circular dependencies": "resource references that form cycles preventing cleanup",
    "thread-safe queue": "queue data structure safe for concurrent access",
    "worker thread pool": "background threads dedicated to asset loading",
    "completion callback": "function invoked when async operation finishes",
    "garbage collection": "automatic cleanup of unused resources",
    "handle validation": "checking if handle points to valid loaded resource",
    "frame processing lifecycle": "sequence of input, update, physics, and rendering phases repeated each frame",
    "system dependency graph": "directed graph determining execution order based on component access",
    "handle-based resource access": "indirect resource access through validated handles for safety",
    "event queue": "deferred message passing system for inter-system communication",
    "tunneling": "fast objects passing through barriers between timesteps",
    "jitter": "rapid oscillation in resting contact",
    "context loss": "graphics driver reset invalidating GPU resources",
    "fallback resource": "substitute content when primary loading fails",
    "numerical stability": "preventing accumulated floating-point errors",
    "penetration tolerance": "allowed overlap to reduce jitter",
    "frame processing pipeline": "sequence of input, update, physics, and rendering phases repeated each frame",
    "integration testing": "end-to-end validation of multiple systems working together",
    "unit testing": "isolated testing of individual components",
    "performance validation": "verification that systems meet timing and throughput requirements",
    "milestone verification": "checkpoint testing after completing development stages",
    "energy conservation": "physics property that total energy remains constant",
    "thread safety": "safe operation under concurrent access",
    "multi-pass rendering": "rendering the scene multiple times from different perspectives",
    "shadow mapping": "depth-based shadow rendering technique",
    "post-processing": "screen-space effects applied after main rendering",
    "physically-based rendering": "lighting model based on real-world material properties",
    "compute shaders": "GPU programs for general computation beyond graphics",
    "job system": "parallel work distribution across CPU cores",
    "client-server": "networking architecture with authoritative server",
    "scripting integration": "embedded interpreted languages for gameplay logic",
    "memory pools": "pre-allocated memory blocks for frequent allocations",
    "component replication": "synchronizing component changes across network",
    "false sharing": "cache line conflicts in multi-threaded access",
    "asynchronous compute": "parallel GPU computation with graphics rendering",
    "entity component system": "architectural pattern separating data from behavior"
  }
}