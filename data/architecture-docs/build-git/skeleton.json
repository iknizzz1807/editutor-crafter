{
  "title": "Build Your Own Git: Design Document",
  "overview": "This system implements a version control system that uses content-addressable storage and a directed acyclic graph to track file changes over time. The key architectural challenge is designing an immutable object store where every piece of content is identified by its cryptographic hash, enabling efficient deduplication and integrity verification.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Establishes the fundamental challenge of version control systems and why content-addressable storage is the elegant solution that Git pioneered.",
      "subsections": [
        {
          "id": "version-control-analogy",
          "title": "Mental Model: The Digital Filing Cabinet",
          "summary": "Introduces version control through the analogy of a magical filing cabinet that never loses documents and can show you any previous version instantly."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Version Control Approaches",
          "summary": "Compares centralized systems (SVN), distributed systems (Git), and simple approaches (file copying) with their trade-offs."
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what our Git implementation will and will not support, focusing on core operations while avoiding advanced features.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Lists the eight core Git operations we will implement, from repository initialization through three-way merging."
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Clearly states advanced Git features we will not implement, such as remote repositories, pack files, and advanced merging strategies."
        }
      ]
    },
    {
      "id": "architecture-overview",
      "title": "High-Level Architecture",
      "summary": "Presents the four-layer architecture of our Git system and how components interact through the content-addressable object store.",
      "subsections": [
        {
          "id": "system-components",
          "title": "System Components",
          "summary": "Describes the Object Store, Index, References, and Working Directory components and their responsibilities."
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "Shows how to organize the codebase into logical modules that mirror the architectural layers."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the three Git object types (blob, tree, commit) and how they form a content-addressable graph structure.",
      "subsections": [
        {
          "id": "git-objects",
          "title": "Git Object Types",
          "summary": "Detailed specifications for blob, tree, and commit objects including their binary formats and hash calculation."
        },
        {
          "id": "object-relationships",
          "title": "Object Relationships",
          "summary": "How commits reference trees, trees reference blobs and other trees, forming the complete project history graph."
        }
      ]
    },
    {
      "id": "object-store",
      "title": "Object Store Design",
      "summary": "The content-addressable storage engine that forms the foundation of Git's architecture, handling immutable object storage and retrieval.",
      "subsections": [
        {
          "id": "content-addressable-concept",
          "title": "Mental Model: The Universal Library",
          "summary": "Explains content-addressable storage through the analogy of a library where books are filed by their content fingerprint rather than arbitrary catalog numbers."
        },
        {
          "id": "object-storage-algorithm",
          "title": "Storage Algorithm",
          "summary": "Step-by-step process for hashing, compressing, and storing objects in the .git/objects directory structure."
        },
        {
          "id": "object-retrieval",
          "title": "Retrieval and Verification",
          "summary": "How to locate, decompress, and verify objects using their SHA-1 hash as the lookup key."
        },
        {
          "id": "storage-adrs",
          "title": "Architecture Decision Records",
          "summary": "Key decisions around SHA-1 vs SHA-256, compression strategies, and file system layout with rationale and trade-offs."
        }
      ]
    },
    {
      "id": "index-staging",
      "title": "Index and Staging Area",
      "summary": "The staging area that sits between the working directory and repository, allowing users to prepare commits incrementally.",
      "subsections": [
        {
          "id": "staging-mental-model",
          "title": "Mental Model: The Photography Dark Room",
          "summary": "Explains the staging area through the analogy of a photographer's darkroom where you prepare and review shots before final development."
        },
        {
          "id": "index-binary-format",
          "title": "Index Binary Format",
          "summary": "Complete specification of the .git/index file format including header, entries, and checksum calculation."
        },
        {
          "id": "add-remove-operations",
          "title": "Add and Remove Operations",
          "summary": "Algorithms for staging and unstaging files, including handling of file modifications and deletions."
        },
        {
          "id": "status-calculation",
          "title": "Status Calculation",
          "summary": "Three-way comparison between working directory, index, and HEAD to determine file states (staged, modified, untracked)."
        }
      ]
    },
    {
      "id": "references-branches",
      "title": "References and Branch Management",
      "summary": "The reference system that provides human-readable names for commits and manages the current branch state.",
      "subsections": [
        {
          "id": "references-mental-model",
          "title": "Mental Model: Bookmarks in History",
          "summary": "Explains Git references as bookmarks that point to specific moments in project history, with HEAD as the 'you are here' marker."
        },
        {
          "id": "symbolic-vs-direct",
          "title": "Symbolic vs Direct References",
          "summary": "The difference between HEAD pointing to a branch name versus pointing directly to a commit hash."
        },
        {
          "id": "branch-operations",
          "title": "Branch Creation and Switching",
          "summary": "Algorithms for creating new branches, switching between branches, and handling detached HEAD states."
        }
      ]
    },
    {
      "id": "diff-algorithm",
      "title": "Diff Algorithm Implementation",
      "summary": "The Myers diff algorithm for computing line-by-line differences between file versions and presenting them in unified diff format.",
      "subsections": [
        {
          "id": "diff-mental-model",
          "title": "Mental Model: Document Comparison",
          "summary": "Explains diff algorithms through the analogy of comparing two drafts of a document to highlight what changed."
        },
        {
          "id": "myers-algorithm",
          "title": "Myers Diff Algorithm",
          "summary": "Step-by-step implementation of the Myers algorithm for finding the shortest edit script between two sequences."
        },
        {
          "id": "unified-diff-format",
          "title": "Unified Diff Output Format",
          "summary": "How to generate standard unified diff output with context lines and hunk headers."
        }
      ]
    },
    {
      "id": "merge-algorithm",
      "title": "Three-Way Merge Implementation",
      "summary": "The merge algorithm that combines changes from two branches, including conflict detection and merge base calculation.",
      "subsections": [
        {
          "id": "merge-mental-model",
          "title": "Mental Model: Collaborative Document Editing",
          "summary": "Explains three-way merging through the analogy of two authors editing the same document independently, then combining their changes."
        },
        {
          "id": "merge-base-calculation",
          "title": "Finding the Merge Base",
          "summary": "Algorithm for finding the lowest common ancestor commit between two branches using graph traversal."
        },
        {
          "id": "three-way-merge-logic",
          "title": "Three-Way Merge Algorithm",
          "summary": "Line-by-line merging logic that automatically combines non-conflicting changes and marks conflicts for manual resolution."
        },
        {
          "id": "conflict-resolution",
          "title": "Conflict Detection and Marking",
          "summary": "How to detect when the same lines were modified in both branches and insert conflict markers for user resolution."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Component Interactions and Data Flow",
      "summary": "How the major Git operations flow through the system components, from simple blob storage through complex merge operations.",
      "subsections": [
        {
          "id": "commit-creation-flow",
          "title": "Commit Creation Data Flow",
          "summary": "Complete sequence from 'git add' through 'git commit', showing how files move from working directory to permanent history."
        },
        {
          "id": "branch-merge-flow",
          "title": "Branch Merge Data Flow",
          "summary": "Complex interaction pattern during merge operations, including conflict resolution and merge commit creation."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Common failure modes in version control systems and strategies for graceful degradation and recovery.",
      "subsections": [
        {
          "id": "repository-corruption",
          "title": "Repository Corruption Handling",
          "summary": "Detection and recovery strategies for corrupted objects, missing references, and invalid repository states."
        },
        {
          "id": "merge-conflicts",
          "title": "Merge Conflict Resolution",
          "summary": "User workflows for resolving conflicts and completing interrupted merge operations."
        },
        {
          "id": "concurrent-access",
          "title": "Concurrent Access Patterns",
          "summary": "How to handle multiple processes accessing the repository simultaneously without corruption."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy and Milestone Checkpoints",
      "summary": "Comprehensive testing approach for each milestone, including integration tests and compatibility verification with real Git.",
      "subsections": [
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Steps",
          "summary": "Specific commands to run and expected outputs after completing each of the eight milestones."
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing Approach",
          "summary": "How to verify that your Git implementation produces the same results as the official Git for core operations."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common problems learners encounter when building Git, organized by symptoms with diagnostic steps and solutions.",
      "subsections": [
        {
          "id": "object-storage-debugging",
          "title": "Object Storage Issues",
          "summary": "Hash mismatches, compression problems, and file system permissions that commonly cause object storage failures."
        },
        {
          "id": "merge-debugging",
          "title": "Merge Algorithm Debugging",
          "summary": "Conflict detection failures, infinite loops in merge base calculation, and corrupted merge states."
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools and Techniques",
          "summary": "How to inspect Git internals, trace object relationships, and validate repository consistency."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Advanced Git features that could be added to this implementation and how the current design accommodates them.",
      "subsections": [
        {
          "id": "remote-repositories",
          "title": "Remote Repository Support",
          "summary": "Adding push, pull, and fetch operations while maintaining the current object store design."
        },
        {
          "id": "pack-files",
          "title": "Pack File Optimization",
          "summary": "Implementing Git's compression and delta encoding for efficient storage of large repositories."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of all technical terms, Git-specific vocabulary, and acronyms used throughout this document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "Git System Architecture",
      "description": "Shows the four main components (Object Store, Index, References, Working Directory) and their relationships. Include data flow arrows showing how objects move between components during common operations.",
      "type": "component",
      "relevant_sections": [
        "architecture-overview",
        "interactions-data-flow"
      ]
    },
    {
      "id": "object-model",
      "title": "Git Object Model",
      "description": "Illustrates the three object types (blob, tree, commit) and how they reference each other. Show a concrete example with a commit pointing to a tree, which points to blobs and sub-trees.",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "object-store"
      ]
    },
    {
      "id": "commit-creation-flow",
      "title": "Commit Creation Sequence",
      "description": "Step-by-step sequence showing file staging (add), tree creation (write-tree), and commit creation (commit-tree). Include interactions between Working Directory, Index, and Object Store.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "index-staging"
      ]
    },
    {
      "id": "merge-base-algorithm",
      "title": "Merge Base Calculation",
      "description": "Flowchart showing the graph traversal algorithm for finding the lowest common ancestor between two commits. Include decision points and termination conditions.",
      "type": "flowchart",
      "relevant_sections": [
        "merge-algorithm"
      ]
    },
    {
      "id": "reference-states",
      "title": "Reference State Machine",
      "description": "State transitions for HEAD and branch references, showing normal branch state, detached HEAD, and transitions between them during checkout operations.",
      "type": "state-machine",
      "relevant_sections": [
        "references-branches"
      ]
    },
    {
      "id": "object-storage-layout",
      "title": "Object Store File Layout",
      "description": "File system structure of .git/objects directory showing how SHA-1 hashes map to directory structure (xx/yy...). Include examples of actual paths.",
      "type": "component",
      "relevant_sections": [
        "object-store"
      ]
    },
    {
      "id": "three-way-merge",
      "title": "Three-Way Merge Process",
      "description": "Flowchart showing merge base calculation, file-by-file comparison, conflict detection, and merge result generation. Include decision points for conflict vs clean merge.",
      "type": "flowchart",
      "relevant_sections": [
        "merge-algorithm"
      ]
    },
    {
      "id": "index-format",
      "title": "Index File Structure",
      "description": "Binary layout of .git/index file showing header, sorted entries, and checksum. Include field sizes and data types for each component.",
      "type": "class",
      "relevant_sections": [
        "index-staging"
      ]
    }
  ]
}