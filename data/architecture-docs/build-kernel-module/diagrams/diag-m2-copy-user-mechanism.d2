direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- KERNEL DATA STRUCTURES ---
extable_entry: {
  shape: sql_table
  label: "struct exception_table_entry (asm/extable.h)"
  f0: "0x00 | int | insn  // Relative offset to faulting instruction"
  f1: "0x04 | int | fixup // Relative offset to fixup code"
  sz: "Total: 8 bytes"
}

elf_section: {
  shape: sql_table
  label: "Section: __ex_table (ELF Binary)"
  row1: "Entry 0 | fault_addr: 0xffffffff8100100a | fixup_addr: 0xffffffff810020f0"
  row2: "Entry 1 | fault_addr: 0xffffffff8100100f | fixup_addr: 0xffffffff810020f5"
  row3: "..."
  note: "Sorted by fault_addr for binary search"
}

# --- EXECUTION FLOW ---
driver_context: {
  label: "Driver Code (mydevice.c)"
  code: |'c
    // mydev_write
    unsigned long n = copy_from_user(kbuf, ubuf, len);
    if (n != 0) {
        return -EFAULT; // Trap recovered!
    }
  '|
}

copy_wrapper: {
  label: "copy_from_user (asm/uaccess_64.h)"
  code: |'c
    static inline unsigned long
    copy_from_user(void *to, const void __user *from, unsigned long n) {
        if (access_ok(from, n))
            n = raw_copy_from_user(to, from, n);
        return n;
    }
  '|
}

hardware_execution: {
  label: "Instruction Execution (CPU Ring 0)"
  asm: |'asm
    .L_copy_loop:
    1:  movb (%rsi), %al  ; <--- FAULT POINT
    2:  movb %al, (%rdi)
        inc %rsi; inc %rdi
        dec %rcx; jnz 1b
  '|
  style: {
    stroke: "#88DCF7"
    fill: "#f0f8ff"
  }
}

page_fault_handler: {
  shape: class
  label: "do_user_addr_fault (arch/x86/mm/fault.c)"
  methods: |'c
    void handle_page_fault(struct pt_regs *regs);
    bool fixup_exception(struct pt_regs *regs);
  '|
  style.fill: "#FFE7CB"
}

lookup_engine: {
  label: "search_exception_tables (kernel/extable.c)"
  code: |'c
    const struct exception_table_entry *e;
    e = search_exception_tables(regs->ip);
    if (e) {
        regs->ip = (unsigned long)&e->fixup;
        return true;
    }
  '|
  style.fill: "#E4DBFE"
}

fixup_stub: {
  label: "Fixup Logic (Generated by Assembler)"
  code: |'asm
    .section .fixup,"ax"
    .L_fixup:
        mov %rcx, %rax   ; Remaining count -> ret
        ret              ; Graceful exit
  '|
  style.fill: "#FFE0F5"
}

# --- CONNECTIONS ---

driver_context -> copy_wrapper: "unsigned long | 8 bytes | ubuf_ptr"
copy_wrapper -> hardware_execution: "Jumps to ASM optimized loop"

hardware_execution -> page_fault_handler: "Hardware Trap | Error: #PF | 0x0E" {
  style: {
    stroke: red
    stroke-width: 2
  }
}

page_fault_handler -> lookup_engine: "Check if IP is registered"
lookup_engine -> elf_section: "Binary Search | key=fault_ip | result=entry"
lookup_engine -> fixup_stub: "Modify regs->ip to fixup_addr" {
  style.stroke-dash: 4
}

fixup_stub -> driver_context: "Return Value | size_t | not_copied > 0" {
  style.stroke: red
}

# --- COMPARISON CONTRAST ---
memcpy_danger: {
  shape: callout
  label: "DIRECT MEMCPY (DANGER)"
  code: |'c
    memcpy(kbuf, ubuf, len); 
    // NO EXCEPTION TABLE ENTRY!
    // Page Fault -> Kernel Panic
    // BUG: unable to handle kernel paging request
  '|
  style: {
    fill: "#FE7070"
    font-color: white
  }
}

hardware_execution -> memcpy_danger: "If no entry exists" {
  style.stroke: grey
}

# Layout constraints
driver_context.near: top-left
elf_section.near: bottom-right