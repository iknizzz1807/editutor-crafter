direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 0
  }
}

# --- LAYER 1: USERSPACE ---
userspace: {
  label: "Userspace Process (proc_read.c)"
  style.fill: "#f9f9f9"

  app: {
    shape: code
    label: "Reader Logic"
    code: |'c
      char buf[4096];
      int fd = open("/proc/mydevice", O_RDONLY);
      while ((n = read(fd, buf, 4096)) > 0) {
          write(STDOUT_FILENO, buf, n);
      }
    '|
    width: 320
  }
}

# --- LAYER 2: KERNEL VFS & SEQ_FILE ---
kernel_vfs: {
  label: "Kernel VFS Layer (fs/seq_file.c)"
  direction: down
  style.fill: "#e1f5fe"

  seq_read_logic: {
    label: "seq_read() Iterator Loop"
    shape: step
    code: |'c
      if (m->count == 0) {
          p = m->op->start(m, &m->index);
          while (p && !m->full) {
              err = m->op->show(m, p);
              p = m->op->next(m, p, &m->index);
          }
          m->op->stop(m, p);
      }
    '|
    width: 380
  }

  seq_struct: {
    shape: sql_table
    label: "struct seq_file (seq_file.h)"
    f0: "0x00 | char*    | buf    // Internal 4KB buffer"
    f1: "0x08 | size_t   | size   // Total buffer size"
    f2: "0x10 | size_t   | from   // Current offset in buf"
    f3: "0x18 | size_t   | count  // Bytes remaining in buf"
    f4: "0x20 | loff_t   | index  // Current object index"
    f5: "0x28 | seq_ops* | op     // Iterator callbacks"
    total: "Total: 48 bytes"
  }
}

# --- LAYER 3: DRIVER CALLBACKS ---
driver_impl: {
  label: "Driver Implementation (mydevice.c)"
  direction: down
  style.fill: "#fff9c4"

  seq_ops: {
    shape: class
    label: "struct seq_operations"
    methods: |'c
      void* start(struct seq_file *m, loff_t *pos);
      void  stop (struct seq_file *m, void *v);
      void* next (struct seq_file *m, void *v, loff_t *pos);
      int   show (struct seq_file *m, void *v);
    '|
  }

  show_impl: {
    shape: code
    label: "mydev_proc_show"
    code: |'c
      seq_printf(m, "buffer_size: %zu\n", b_sz);
      seq_printf(m, "bytes_used:  %zu\n", b_used);
      return 0; // Success
    '|
    width: 320
  }
}

# --- DATA FLOW & INTERACTIONS ---

userspace.app -> kernel_vfs.seq_read_logic: "read(fd, buf, 4096) | syscall | n=4096" {
  style.stroke: "#0d47a1"
  style.stroke-width: 2
}

kernel_vfs.seq_read_logic -> driver_impl.seq_ops: "m->op->start() | func_ptr | pos=0"
driver_impl.seq_ops -> driver_impl.show_impl: "m->op->show() | func_ptr | m=seq_file*"

driver_impl.show_impl -> kernel_vfs.seq_struct: "seq_printf() | data | 'buffer_size: 4096\n...'" {
  style.stroke: "#2e7d32"
  target-arrowhead: * {
    shape: diamond
  }
}

kernel_vfs.seq_struct -> userspace.app: "copy_to_user() | 24 bytes | 'buffer_size: 4096\n...'" {
  style.stroke: "#2e7d32"
  style.animated: true
}

# --- ANNOTATION: PARTIAL READS ---
note_partial: {
  label: "The Stateful Cursor (seq_file logic)"
  shape: callout
  code: |'md
    Unlike raw `read_proc`, `seq_file` uses `m->index`. 
    If userspace reads 10 bytes of a 20-byte line:
    1. Kernel stores 10 bytes in `m->buf`.
    2. `m->from` is updated to 10.
    3. Next `read()` returns from `m->buf + m->from`.
    4. Driver `show()` is NOT called again until `m->count == 0`.
  '|
}

# FIX: elk requires constant value for near at root level
note_partial.near: bottom-right