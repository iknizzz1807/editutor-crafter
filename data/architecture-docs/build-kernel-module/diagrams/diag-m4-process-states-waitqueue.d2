direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 6
  }
}

# --- KERNEL TASK STATES ---

process_states: {
  label: "Linux Process States (sched.h)"
  
  task_running: {
    shape: oval
    label: "TASK_RUNNING (R)"
    style: {
      fill: "#E1F5FE"
      stroke: "#01579B"
      stroke-width: 4
    }
  }

  task_interruptible: {
    shape: oval
    label: "TASK_INTERRUPTIBLE (S)"
    style: {
      fill: "#FFF9C4"
      stroke: "#FBC02D"
      stroke-width: 2
    }
  }

  task_uninterruptible: {
    shape: oval
    label: "TASK_UNINTERRUPTIBLE (D)"
    style: {
      fill: "#FFEBEE"
      stroke: "#C62828"
      stroke-width: 3
    }
  }
}

# --- TRANSITIONS ---

process_states.task_running -> process_states.task_interruptible: "wait_queue_head* | 8B | &wq_event" {
  style: {
    stroke: "#FBC02D"
    animated: true
  }
}

process_states.task_interruptible -> process_states.task_running: "int | 4B | 0 (Success)" {
  style: {
    stroke: "#43A047"
  }
}

process_states.task_interruptible -> process_states.task_running: "long | 8B | -ERESTARTSYS" {
  style: {
    stroke: "#C62828"
    stroke-dash: 5
  }
}

process_states.task_running -> process_states.task_uninterruptible: "mutex* | 8B | &dev->lock" {
  style: {
    stroke: "#C62828"
    animated: true
  }
}

process_states.task_uninterruptible -> process_states.task_running: "void | 0B | lock_available" {
  style: {
    stroke: "#43A047"
  }
}

# --- KERNEL MEMORY STRUCTURES ---

kernel_structures: {
  label: "Memory Layouts"
  
  task_struct: {
    shape: sql_table
    label: "struct task_struct (sched.h)"
    f0: "0x00 | volatile long | state          // State Bitmask"
    f1: "0x08 | void*         | stack          // Thread Info / SP"
    f2: "0x10 | unsigned int  | flags          // PF_KTHREAD, etc."
    f3: "0x14 | int           | exit_state     // Zombie Status"
    f4: "0x18 | mm_struct*    | mm             // Memory Map"
    sz: "Total: ~9KB (Arch Dependent)"
  }
  
  wait_queue: {
    shape: sql_table
    label: "struct wait_queue_head (wait.h)"
    f0: "0x00 | spinlock_t    | lock           // Serialization"
    f1: "0x08 | list_head     | head           // Task List"
    sz: "Total: 24 bytes"
  }
}

# --- IMPLEMENTATION LOGIC ---

logic_context: {
  label: "Scheduling Primitives"
  
  wait_logic: {
    label: "wait_event_interruptible()"
    code: |'c
      for (;;) {
        prepare_to_wait(&wq, &wait, TASK_INTERRUPTIBLE);
        if (condition) break;
        if (signal_pending(current)) return -ERESTARTSYS;
        schedule();
      }
      finish_wait(&wq, &wait);
    '|
  }

  mutex_logic: {
    label: "mutex_lock() slowpath"
    code: |'c
      while (!mutex_trylock(lock)) {
        set_current_state(TASK_UNINTERRUPTIBLE);
        if (mutex_is_locked(lock)) {
          schedule();
        }
      }
    '|
  }
}

# --- SEMANTIC MAPPING ---

behavioral_map: {
  label: "Subsystem Context"
  
  disk_io: {
    label: "Device Driver I/O"
    desc: "Used for DMA/In-flight requests"
  }
  
  network_io: {
    label: "IPC/Network Pipes"
    desc: "Used for sockets/poll/select"
  }
  
  load_calc: {
    label: "Load Average Metrics"
    formula: "Load = R + D Process Counts"
    style: {
      fill: "#FFEBEE"
      stroke: "#C62828"
    }
  }
}

# --- CONNECTIONS TO LOGIC & BEHAVIOR ---

process_states.task_interruptible -> logic_context.wait_logic: "Implemented by"
process_states.task_uninterruptible -> logic_context.mutex_logic: "Implemented by"

process_states.task_interruptible -> behavioral_map.network_io: "Context"
process_states.task_uninterruptible -> behavioral_map.disk_io: "Context"

process_states.task_uninterruptible -> behavioral_map.load_calc: "Contributes to"
process_states.task_running -> behavioral_map.load_calc: "Contributes to"

# --- LEGEND ---

legend: {
  shape: sql_table
  label: "Legend: ps(1) Codes"
  r: "R | Running / Runnable"
  s: "S | Interruptible Sleep (Normal)"
  d: "D | Uninterruptible Sleep (Deep/IO)"
  t: "T | Stopped (Tracing/Signals)"
  z: "Z | Zombie (Dead)"
}

legend.near: bottom-right