layout-engine: elk
vars: {
  d2-config: {
    theme-id: 6
  }
}

# ──────────────────────────────────────────────────────────────────────
# SEQ_FILE ITERATOR PROTOCOL: /proc/mydevice
# ──────────────────────────────────────────────────────────────────────

legend: {
  label: "Protocol: single_open + seq_read\nTarget: /proc/mydevice\nBuffer: 4096B (PAGE_SIZE)"
  near: top-left
  style: {
    fill: "#fff2cc"
    stroke: "#d6b656"
    stroke-dash: 2
  }
}

# ── STEP 1: OPEN & REGISTRATION ──────────────────────────────────────
step_1: "Step 1: open() & Registration" {
  description: |md
    Process calls `open("/proc/mydevice")`.
    Kernel invokes `mydev_proc_open`.
  |
  container: {
    file_struct: "struct file" {
      f_op: "mydev_proc_ops" { style.fill: "#dae8fc" }
      private_data: {
        label: "NULL"
        style: { font-color: red; bold: true; fill: "#e1d5e7" }
      }
    }
  }
  
  action: "single_open(file, show_fn, NULL)"
}

# ── STEP 2: ALLOCATION ──────────────────────────────────────────────
step_2: "Step 2: Allocation State" {
  description: |md
    `single_open` allocates the iterator.
    `m->op` is set to the single-record helper.
  |
  container: {
    file_struct: "struct file" {
      private_data: {
        label: "struct seq_file *m"
        style: { font-color: red; bold: true; fill: "#ffe6cc" }
      }
    }
    seq_file: "struct seq_file" {
      style.fill: "#e1d5e7"
      op: "struct seq_operations" {
        show: "mydev_proc_show"
      }
      buf: "kmalloc(4096)" { style.fill: "#dae8fc" }
      count: "0"
    }
    file_struct.private_data -> seq_file: "points to" { style.stroke: orange }
  }
  
  action: "read(fd, user_buf, 64KB)"
}

# ── STEP 3: ITERATOR START ──────────────────────────────────────────
step_3: "Step 3: seq_read -> start()" {
  description: |md
    `seq_read` invokes `start()`.
    Since it's `single_open`, it returns a dummy pointer.
  |
  container: {
    iterator_state: {
      pos: "0"
      v: {
        label: "0x1 (DUMMY_PTR)"
        style: { font-color: red; bold: true }
      }
    }
  }
  
  action: "seq_read calls show(m, v)"
}

# ── STEP 4: FORMATTING (CRITICAL) ──────────────────────────────────
step_4: "Step 4: show() -> Populate Buffer" {
  description: |md
    `mydev_proc_show` executes.
    `seq_printf` writes human-readable stats.
  |
  container: {
    seq_file_buffer: "m->buf (Kernel Memory)" {
      row_0: {
        label: "=== mydevice statistics ==="
        style: { font-color: red; bold: true }
      }
      row_1: {
        label: "buffer_size: 4096"
        style: { font-color: red; bold: true }
      }
      row_2: {
        label: "bytes_used: 128"
        style: { font-color: red; bold: true }
      }
      row_3: {
        label: "open_count: 1"
        style: { font-color: red; bold: true }
      }
      row_n: "..." 
      style.fill: "#dae8fc"
    }
    stats: "seq_file metadata" {
      style.fill: "#e1d5e7"
      count: {
        label: "128"
        style: { font-color: red; bold: true }
      }
      index: {
        label: "1"
        style: { font-color: red; bold: true }
      }
    }
  }
  
  action: "next() returns NULL -> stop()"
}

# ── STEP 5: MEMORY CROSSING ─────────────────────────────────────────
step_5: "Step 5: copy_to_user" {
  description: |md
    Kernel transfers formatted text to 
    the userspace address provided.
  |
  container: {
    kernel_space: {
      style.stroke-dash: 5
      m_buf: "m->buf" { style.fill: "#dae8fc" }
    }
    user_space: {
      user_buf: "Userspace Buffer" {
        content: {
          label: "=== mydevice statistics ===\nbuffer_size: 4096..."
          style: { font-color: red; bold: true }
        }
      }
    }
    kernel_space.m_buf -> user_space.user_buf: "copy_to_user()" {
      style: { stroke: orange; stroke-width: 4; animated: true }
    }
  }
  
  action: "Return count (128)"
}

# ── STEP 6: FINALIZE ────────────────────────────────────────────────
step_6: "Step 6: Completion" {
  description: |md
    Syscall returns.
    `f_pos` is updated.
  |
  container: {
    final_state: {
      return_val: "128"
      f_pos: {
        label: "128"
        style: { font-color: red; bold: true }
      }
    }
  }
}

# ── CONNECTIONS ─────────────────────────────────────────────────────
step_1.action -> step_2: "Allocates struct"
step_2.action -> step_3: "Syscall Read"
step_3.action -> step_4: "Invoke mydev_proc_show"
step_4.action -> step_5: "Buffer Full/Done"
step_5.action -> step_6: "Exit Handler"

# ── ANNOTATIONS ─────────────────────────────────────────────────────
notes: |md
  ### seq_file Architecture Notes
  - **proc_read**: Implemented by `seq_read`
  - **proc_lseek**: Implemented by `seq_lseek`
  - **proc_release**: Implemented by `single_release` (frees `seq_file` allocation)
  - **Memory Limit**: If output > 4096B, `seq_read` loops back to `start/show` 
    with updated offset to fill multiple read() requests.
| {
  near: bottom-right
}