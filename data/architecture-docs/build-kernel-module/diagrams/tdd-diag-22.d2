direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

classes: {
  critical_section: {
    style: {
      fill: "#E4DBFE"
      stroke: "#B5AFF6"
      stroke-width: 3
      double-border: true
    }
  }
  blocked_state: {
    style: {
      fill: "#fce7c6"
      stroke: "#f9d8a7"
      stroke-dash: 3
    }
  }
  data_movement: {
    style: {
      fill: "#C7F1FF"
      bold: true
    }
  }
  waiting_queue: {
    style: {
      fill: "#DEE1EB"
      italic: true
    }
  }
}

# Master Device Metadata
DeviceData: "struct my_device_data" {
  shape: class
  label: "Device State (sizeof=224 bytes)"
  dev_mutex: "struct mutex"
  read_queue: "wait_queue_head_t"
  write_queue: "wait_queue_head_t"
  buffer: "char *"
  used: "size_t"
}

# Timeline Container
Timeline: {
  direction: right

  # --- WRITE HANDLER SWIMLANE ---
  Write_Thread: "Write Handler (Producer)" {
    start: "Entry: write()"
    lock: "▼ mutex_lock_interruptible(&dev_mutex)"
    
    CS: "CRITICAL SECTION" {
      class: critical_section
      check: "space_available check"
      copy: "copy_from_user(kernel_buf, buf, n)" {
        class: data_movement
        tooltip: "Process context: can sleep while holding mutex"
      }
      inc: "buffer_used += n"
      wake: "wake_up_interruptible(&read_queue)"
    }
    
    unlock: "▲ mutex_unlock(&dev_mutex)"
    end: "Return: count"

    start -> lock -> CS -> unlock -> end
  }

  # --- READ HANDLER SWIMLANE ---
  Read_Thread: "Read Handler (Consumer)" {
    start: "Entry: read()"
    lock: "▼ mutex_lock_interruptible(&dev_mutex)"
    
    CS1: "CRITICAL SECTION (Check)" {
      class: critical_section
      check: "f_pos >= buffer_used?"
      release: "▲ mutex_unlock(&dev_mutex)"
    }
    
    wait: "wait_event_interruptible(&read_queue, ...)" {
      class: waiting_queue
      label: "SLEEPING (TASK_INTERRUPTIBLE)\nMutex is RELEASED here"
    }
    
    re_lock: "▼ mutex_lock_interruptible(&dev_mutex)" {
      class: blocked_state
      label: "Blocked here if Write still holds"
    }

    CS2: "CRITICAL SECTION (Transfer)" {
      class: critical_section
      copy: "copy_to_user(buf, kernel_buf, n)" {
        class: data_movement
      }
      pos: "*f_pos += n"
      wake: "wake_up_interruptible(&write_queue)"
    }

    unlock: "▲ mutex_unlock(&dev_mutex)"
    end: "Return: count"

    start -> lock -> CS1 -> wait -> re_lock -> CS2 -> unlock -> end
  }
}

# Synchronicity Annotations
Timeline.Write_Thread.CS.wake -> Timeline.Read_Thread.wait: "Signal Wakeup" {
  style: {
    stroke: green
    stroke-width: 2
    animated: true
  }
}

Timeline.Read_Thread.CS1.release -> Timeline.Write_Thread.lock: "Mutex Available" {
  style: {
    stroke: orange
    stroke-dash: 5
  }
}

Annotation: |md
  ### Concurrency Rules
  1. **Safe Sleeping**: `copy_to/from_user` can trigger page faults and sleep. This is **legal** inside a mutex critical section because we are in process context.
  2. **Deadlock Avoidance**: The mutex **must** be released before calling `wait_event_interruptible`. If held, producers could never enter `write()` to satisfy the condition.
  3. **Atomic Hand-off**: `wake_up_interruptible` transitions the task to `TASK_RUNNING`, but it only enters the critical section after re-acquiring the mutex.
| {
  near: bottom-center
}