direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

classes: {
  step_box: {
    style: {
      stroke: "#222222"
      stroke-width: 2
      fill: "#f8f9fa"
      border-radius: 4
    }
  }
  state_label: {
    shape: text
    style: {
      font: mono
      font-size: 12
    }
  }
  highlight: {
    style: {
      stroke: red
      stroke-width: 3
      font-color: red
      bold: true
    }
  }
  note_style: {
    style: {
      fill: "#fff3cd"
      stroke: "#856404"
      stroke-dash: 3
    }
  }
}

header: |md
  # wait_event_interruptible()
  ## The Lost-Wakeup Prevention Mechanism
| {near: top-center}

step_0: "Step 0: Mutex Release" {
  class: step_box
  state: |md
    **CPU Context:** Process A (Reader)
    **task_struct->state:** `TASK_RUNNING`
    **dev_mutex:** <span style="color: red;">**FREE**</span> (Unlocked)
  |
}

step_1: "Step 1: prepare_to_wait()" {
  class: step_box
  state: |md
    **task_struct->state:** <span style="color: red;">**TASK_INTERRUPTIBLE**</span>
    **read_queue:** <span style="color: red;">**[ wait_entry_A ]**</span> (Linked)
    **Stack:** `wait_queue_entry_t` allocated on Reader stack
  |
}

step_2: "Step 2: Condition Re-Check (CRITICAL)" {
  class: step_box
  state: |md
    **Logic:** `if (buffer_used > f_pos)`
    **Observation:** Racy read of `buffer_used` WITHOUT mutex.
    **Invariant:** If writer ran between Step 0 and 1, condition is now TRUE.
    **Path:** If TRUE -> Jump to Step 6 (No Sleep).
  |
}

step_3: "Step 3: Signal Check" {
  class: step_box
  state: |md
    **Logic:** `if (signal_pending(current))`
    **Action:** Check `TIF_SIGPENDING` flag in thread info.
    **Path:** If pending -> Jump to Step 7.
  |
}

step_4: "Step 4: schedule()" {
  class: step_box
  state: |md
    **Scheduler:** <span style="color: red;">**deactivate_task(Process A)**</span>
    **Process A:** <span style="color: red;">**REMOVED from RunQueue**</span>
    **CPU:** Context switches to another task.
    **Wait:** Process A sleeps until `wake_up_interruptible()`.
  |
}

step_5: "Step 5: Resume & Re-arm" {
  class: step_box
  state: |md
    **Trigger:** Writer called `wake_up_interruptible(read_queue)`
    **Scheduler:** <span style="color: red;">**activate_task(Process A)**</span>
    **task_struct->state:** <span style="color: red;">**TASK_RUNNING**</span>
    **Loop:** Returns to Step 2 to verify condition under lock.
  |
}

step_6: "Step 6: finish_wait() (Success)" {
  class: step_box
  state: |md
    **read_queue:** <span style="color: red;">**[ ]**</span> (Entry unlinked)
    **Return:** `0` (Success, data available)
  |
}

step_7: "Step 7: Signal Handle (Error)" {
  class: step_box
  state: |md
    **read_queue:** <span style="color: red;">**[ ]**</span> (Cleanup)
    **Return:** <span style="color: red;">**-ERESTARTSYS**</span>
  |
}

# Transitions
step_0 -> step_1: "Enter wait macro"
step_1 -> step_2: "Close TOCTOU window"
step_2 -> step_3: "Condition False"
step_2 -> step_6: "Condition True (Avoided Lost Wakeup)" {
  style.stroke: green
}
step_3 -> step_4: "No pending signals"
step_3 -> step_7: "SIGINT / SIGTERM detected" {
  style.stroke: red
}
step_4 -> step_5: "Woken by wake_up_interruptible()" {
  style.stroke-dash: 5
}
step_5 -> step_2: "Re-evaluate"

# Annotations
note_toctou: |md
  **The Magic Constraint:**
  Step 2 happens **AFTER** the state is set 
  to `TASK_INTERRUPTIBLE` in Step 1.
  If a writer signals between 0 and 1, 
  Step 2 detects it and aborts the sleep.
| {
  class: note_style
}

# Connection to associate note with step since 'near' is unsupported in ELK
note_toctou -- step_2

# Global Highlighting for Step 2 and 4
step_2.class: [step_box; highlight]
step_4.class: [step_box; highlight]