direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ──────────────────────────────────────────────────────────────────────────────
# O_NONBLOCK SEMANTICS: LOGIC FLOW & STATE TRANSITIONS
# ──────────────────────────────────────────────────────────────────────────────

READ_LOGIC: "Read Decision Tree" {
  shape: package
  
  step1: "1. Lock Acquisition" {
    call: "mydev_read(filp, buf, count, f_pos)"
    state: |md
      - Mutex: **LOCKED** (mutex_lock_interruptible)
      - Task: TASK_RUNNING
    |
  }

  step2: "2. Condition Check" {
    check: "if (*f_pos >= dev->used)"
    state: |md
      - Context: Buffer is empty
      - f_pos: 0x0
      - dev->used: 0x0
    |
  }

  step3: "3. O_NONBLOCK Check" {
    check: "if (filp->f_flags & O_NONBLOCK)"
    state: |md
      - Flags: **0x800 (O_NONBLOCK)**
    |
  }

  step1 -> step2: "Acquired"
  step2 -> step3: "Is Empty"
  step2 -> data_copy: "Has Data"
  
  NON_BLOCKING: "Branch: O_NONBLOCK SET" {
    style.stroke: orange
    style.stroke-width: 4
    
    step4a: "4a. Immediate Exit" {
      action: "Release Mutex"
      result: "**RETURN -EAGAIN**"
      note: |md
        - **Correct Error**: -EAGAIN (EWOULDBLOCK)
        - **Reason**: Operation would block
      |
      style.fill: "#fff0f0"
    }
  }

  BLOCKING: "Branch: O_NONBLOCK CLEAR" {
    style.stroke: blue
    style.stroke-width: 4
    
    step4b: "4b. Suspend Process" {
      action: "Release Mutex"
      wait: "wait_event_interruptible(read_queue, ...)"
      style.fill: "#f0f0ff"
    }

    step5: "5. Transition" {
      style.fill: "#fff"
      
      BEFORE: {
        label: "Before schedule()"
        task_state: "TASK_RUNNING"
        read_queue: "[]"
      }
      
      AFTER: {
        label: "After schedule()"
        task_state: "**TASK_INTERRUPTIBLE**"
        read_queue: "**[current_task_ptr]**"
        style.stroke: red
      }
      
      BEFORE -> AFTER: "Context Switch" {
        style.stroke: red
        style.bold: true
      }
    }
    
    step4b -> step5
  }

  step3 -> step4a: "True"
  step3 -> step4b: "False"

  data_copy: "Copy Data Branch" {
    action: "copy_to_user(...)"
    update: "*f_pos += n"
    return: "n bytes"
    style.fill: "#f0fff0"
  }
}

WRITE_LOGIC: "Write Decision Tree" {
  shape: package

  entry: "Entry: mydev_write"
  full_check: "Buffer Full?" {
    shape: diamond
  }
  flag_check: "O_NONBLOCK?" {
    shape: diamond
  }
  
  entry -> full_check: "Lock Mutex"
  full_check -> flag_check: "Yes (used == size)"
  full_check -> do_write: "No (space available)"
  
  flag_check -> ret_eagain: "SET"
  flag_check -> wait_write: "CLEAR"
  
  ret_eagain: "RETURN -EAGAIN" {
    style.font-color: red
    style.bold: true
  }
  
  wait_write: "wait_event_interruptible(write_queue, ...)" {
    style.stroke-dash: 3
  }
  
  do_write: "copy_from_user"
  do_write -> wake_readers: "Update used"
  
  wake_readers: "wake_up_interruptible(read_queue)" {
    style.fill: "#e0ffe0"
  }
}

ANNOTATIONS: |md
  # Critical Constraints
  - **-EAGAIN**: The only valid non-blocking error.
  - **-EINTR**: Reserved for signals, NOT for busy resources.
  - **0 (Zero)**: Strictly means EOF; returning 0 on empty non-blocking read is an **ABI BUG**.
  
  # Dependencies
  - **poll/select**: Depends on -EAGAIN to stop spinning.
  - **epoll (ET)**: Requires -EAGAIN to signal buffer exhaustion.
  - **libuv/Go**: Uses -EAGAIN to re-arm event loop interest.
| {
  near: top-right
  style.font: mono
}

READ_LOGIC.step1.state.style.font-color: blue
READ_LOGIC.NON_BLOCKING.step4a.result.style.font-color: red
READ_LOGIC.NON_BLOCKING.step4a.result.style.bold: true
READ_LOGIC.BLOCKING.step5.AFTER.task_state.style.font-color: red
READ_LOGIC.BLOCKING.step5.AFTER.read_queue.style.font-color: red