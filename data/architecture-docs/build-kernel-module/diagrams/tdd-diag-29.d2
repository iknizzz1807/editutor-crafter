vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
    pad: 20
  }
}

shape: sequence_diagram

title: |md
  ### Wake-Up Protocol: Write Handler Waking Blocked Readers
  **Scenario**: Stream Device (Independent f_pos)
  *R1, R2, R3* initial state: `TASK_INTERRUPTIBLE` inside `wait_event_interruptible`
| {
  near: top-center
  shape: text
}

# Participants (Actors)
W1: "W1\nstruct task_struct"
dev_mutex: "dev_mutex\nstruct mutex"
buffer: "buffer\nkernel_buffer"
read_queue: "read_queue\nwait_queue_head_t"
scheduler: "Scheduler\nkernel/sched/core.c"
R1: "R1\nstruct task_struct"
R2: "R2\nstruct task_struct"
R3: "R3\nstruct task_struct"

# Step 1: Lock Acquisition
W1 -> dev_mutex: "▼ mutex_lock_interruptible(): 0" {
  style: {
    stroke: orange
    bold: true
  }
}

# Step 2: Data Transfer
W1 -> buffer: "copy_from_user(kernel_buf, u_buf, 50): 0" {
  style.stroke: blue
}
W1 -> buffer: "UPDATE buffer_used = 50" {
  style: {
    font-color: red
    bold: true
  }
}

# Step 3: Wake Up Event
W1 -> read_queue: "wake_up_interruptible(&read_queue): void" {
  style.stroke: blue
}

read_queue -> R1: "SET state = TASK_RUNNING" {
  style.stroke-dash: 5
}
read_queue -> R2: "SET state = TASK_RUNNING" {
  style.stroke-dash: 5
}
read_queue -> R3: "SET state = TASK_RUNNING" {
  style.stroke-dash: 5
}

read_queue -> scheduler: "enqueue_task(R1, R2, R3)" {
  style: {
    stroke: green
    bold: true
  }
}

# Step 4: Lock Release
W1 -> dev_mutex: "▲ mutex_unlock(): void" {
  style: {
    stroke: orange
    bold: true
  }
}

# Step 5: Reader 1 Resumes (Independent f_pos logic)
scheduler -> R1: "context_switch_to(R1)" {
  style.stroke: green
}
R1 -> dev_mutex: "▼ mutex_lock_interruptible(): 0" {
  style.stroke: orange
}
R1 -> buffer: "READ condition (buffer_used > *f_pos): true (50 > 0)"
R1 -> buffer: "copy_to_user(u_buf, kernel_buf, 50): 0"
R1 -> R1: "UPDATE *f_pos = 50" {
  style: {
    font-color: red
    bold: true
  }
}
R1 -> dev_mutex: "▲ mutex_unlock(): void" {
  style.stroke: orange
}

# Step 6: Reader 2 Resumes
scheduler -> R2: "context_switch_to(R2)" {
  style.stroke: green
}
R2 -> dev_mutex: "▼ mutex_lock_interruptible(): 0" {
  style.stroke: orange
}
R2 -> buffer: "READ condition (50 > 0): true"
R2 -> R2: "UPDATE *f_pos = 50" {
  style: {
    font-color: red
    bold: true
  }
}
R2 -> dev_mutex: "▲ mutex_unlock(): void" {
  style.stroke: orange
}

# Step 7: Reader 3 Resumes
scheduler -> R3: "context_switch_to(R3)" {
  style.stroke: green
}
R3 -> dev_mutex: "▼ mutex_lock_interruptible(): 0" {
  style.stroke: orange
}
R3 -> buffer: "READ condition (50 > 0): true"
R3 -> R3: "UPDATE *f_pos = 50" {
  style: {
    font-color: red
    bold: true
  }
}
R3 -> dev_mutex: "▲ mutex_unlock(): void" {
  style.stroke: orange
}

annotation: |md
  **Architectural Insight: Independent f_pos**
  Because each reader has a private `loff_t *f_pos` (initialized to 0),
  all three readers find the condition `(50 > 0)` true and consume 
  the same 50 bytes. 
  
  **Contrast (Pipe Behavior)**:
  If `f_pos` were shared (like a pipe), R1's update would move the 
  shared offset to 50. R2 and R3 would then find `(50 > 50)` is false 
  and would immediately re-sleep (Thundering Herd).
| {
  near: bottom-right
  shape: text
}