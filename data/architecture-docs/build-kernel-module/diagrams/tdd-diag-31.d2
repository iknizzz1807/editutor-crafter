vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

description: |md
  ### Kernel Lock Hierarchy (Milestone 4)
  **Constraint:** Non-sleeping context (Spinlocks) must never attempt to acquire a sleeping lock (Mutex).
  **Tooling:** `lockdep` validates these transitions at runtime.
| {
  near: top-center
}

memory_layout: "Memory Layout: Lock Context (36B)" {
  0x00: "dev_mutex (struct mutex)" {
    width: 400
    style.fill: "#9b59b6"
    label: "0x00: [Header] dev_mutex | size: 32B"
  }
  0x20: "read_queue.lock (spinlock_t)" {
    width: 400
    style.fill: "#3498db"
    label: "0x20: [Data] read_queue.lock | size: 4B"
  }
  0x24: "Padding" {
    width: 400
    style.fill: "#95a5a6"
    style.stroke-dash: 5
    label: "0x24: [Padding] Alignment | size: 28B"
  }
  
  64B_MARKER: "----------------- 64B Cache Line Boundary -----------------" {
    shape: text
    style: {
      font-color: gray
      stroke-dash: 5
    }
  }
}

lock_hierarchy: "Lock Ordering & Deadlock Prevention" {
  
  legal_chain: "ALLOWED ACQUISITION ORDER" {
    style.stroke: "#2ecc71"
    style.stroke-width: 4
    
    dev_mutex: "dev_mutex" {
      shape: class
      definition: "struct mutex"
      sizeof: "32 bytes"
      state: "Sleeping Lock"
      
      lock: "void mutex_lock(struct mutex *lock)"
      unlock: "void mutex_unlock(struct mutex *lock)"
      
      style.fill: "#9b59b6"
      style.font-color: white
    }

    wait_queue_internal: "read_queue.lock" {
      shape: class
      definition: "spinlock_t"
      sizeof: "4 bytes"
      state: "Atomic / Non-sleeping"
      
      spin_lock: "void spin_lock(spinlock_t *lock)"
      spin_unlock: "void spin_unlock(spinlock_t *lock)"
      
      style.fill: "#3498db"
      style.font-color: white
    }

    dev_mutex -> wait_queue_internal: "Wakeup Pattern: Held Mutex -> wake_up()" {
      style.stroke: "#3498db"
      tooltip: "Safe transition"
    }
  }

  deadlock_scenarios: "ILLEGAL TRANSITIONS (DEADLOCK)" {
    style.stroke: "#e74c3c"
    style.stroke-width: 4

    self_deadlock: "dev_mutex" {
      shape: class
      label: "**dev_mutex (Re-acquisition)**"
      style.fill: "#e74c3c"
      style.bold: true
    }

    atomic_violation: "read_queue.lock" {
      shape: class
      label: "**read_queue.lock (Held)**"
      style.fill: "#e74c3c"
      style.bold: true
    }

    self_deadlock -> self_deadlock: "ILLEGAL" {
      style.stroke: red
      style.stroke-dash: 5
    }

    atomic_violation -> lock_hierarchy.legal_chain.dev_mutex: "ILLEGAL: Sleep in Atomic" {
      style.stroke: red
      style.stroke-dash: 5
    }
  }

  runtime_flow: "BLOCKING I/O PATTERN" {
    step_1: "1. Acquire dev_mutex"
    step_2: "2. **Release dev_mutex**"
    step_3: "3. wait_event_interruptible()"
    step_4: "4. **Acquire read_queue.lock**"
    step_5: "5. TASK_INTERRUPTIBLE"

    step_1 -> step_2 -> step_3 -> step_4 -> step_5 {
      style.stroke: "#f39c12"
    }
    
    step_2.style.fill: "#f39c12"
    step_4.style.fill: "#f39c12"
    step_2.style.bold: true
    step_4.style.bold: true
  }
}

footer_note: |md
  **Crucial Mechanism:**
  The reader **must** release `dev_mutex` before `wait_event_interruptible`.
  This allows a writer to acquire the mutex, fill the buffer, 
  and call `wake_up()` which signals the `read_queue.lock`.
| {
  near: bottom-center
}

lock_hierarchy.legal_chain -> lock_hierarchy.runtime_flow: "implements" {
  style.stroke-dash: 3
  target-arrowhead: * {
    shape: triangle
    style.filled: false
  }
}