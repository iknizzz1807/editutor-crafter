layout-engine: elk
theme-id: 4

# --- MASTER ALGORITHM STATE: CACHE LINE DYNAMICS (MESI) ---
# Scenario: TDD 5.1/5.2 Concurrent Access & Mutex Serialization

Step_1: "1. Writer (CPU 0) Initialization" {
  CPU_0: "CPU 0 (Write Handler)" {
    L1_Cache: {
      Line_A: "0xc8 [buffer_used]: **M**" {style.fill: "#f8cecc"; style.stroke: red; style.bold: true}
      Line_B: "0x68 [dev_mutex]: **M**" {style.fill: "#f8cecc"; style.stroke: red; style.bold: true}
      Line_C: "0xd4 [stat_ops]: **M**" {style.fill: "#f8cecc"; style.stroke: red; style.bold: true}
    }
    Registers: {
      RAX: "0x20 (32 bytes)"
    }
  }
  CPU_1: "CPU 1 (Read Handler)" {
    L1_Cache: {
      Line_A: "0xc8: I (Invalid)"
      Line_B: "0x68: I (Invalid)"
      Line_C: "0xd4: I (Invalid)"
    }
  }
  L3: "Shared L3 / RAM" {
    Line_A: "Stale: 0x00"
    Line_B: "Stale: Unlocked"
  }
  
  Annotation: |'md
  ### TDD 5.2: Writer holding mutex
  CPU 0 has exclusive ownership of the 
  Critical Section lines.
  '|
}

Step_2: "2. Reader (CPU 1) Snoop & Pull" {
  CPU_0: "CPU 0 (Write Handler)" {
    L1_Cache: {
      Line_A: "0xc8 [buffer_used]: **S**" {style.fill: "#dae8fc"; style.stroke: blue; style.bold: true}
      Line_B: "0x68 [dev_mutex]: M"
    }
  }
  CPU_1: "CPU 1 (Read Handler)" {
    L1_Cache: {
      Line_A: "0xc8 [buffer_used]: **S**" {style.fill: "#dae8fc"; style.stroke: blue; style.bold: true}
      Line_B: "0x68: I"
    }
  }
  L3: "Shared L3 / RAM" {
    Line_A: "**Value: 0x20**" {style.bold: true; style.stroke: red}
  }
  
  CPU_0.L1_Cache.Line_A -> L3: "1. Writeback (M->S)" {style.stroke: red}
  L3 -> CPU_1.L1_Cache.Line_A: "2. Fetch (I->S)" {style.stroke: red}
  
  Annotation: |'md
  ### MESI Transition: ~100ns Latency
  CPU 1 attempts to check `buffer_used` in 
  `while (*f_pos >= dev->used)`.
  '|
}

Step_3: "3. Mutex Bouncing (RFO)" {
  CPU_0: "CPU 0 (Post-Wake)" {
    L1_Cache: {
      Line_B: "0x68 [dev_mutex]: **I**" {style.fill: "#f5f5f5"; style.stroke: gray; style.bold: true}
    }
  }
  CPU_1: "CPU 1 (Acquisition)" {
    L1_Cache: {
      Line_B: "0x68 [dev_mutex]: **M**" {style.fill: "#f8cecc"; style.stroke: red; style.bold: true}
    }
  }
  
  CPU_1.L1_Cache.Line_B -> CPU_0.L1_Cache.Line_B: "Invalidate (Request for Ownership)" {style.stroke: red; style.stroke-dash: 3}
  
  Annotation: |'md
  ### TDD 5.1: Reader acquires mutex
  The `mutex_lock` logic forces the cache line 
  to bounce to CPU 1.
  '|
}

Step_4: "4. Atomic Counter Contention" {
  CPU_0: "CPU 0" {
    L1_Cache: {
      Line_C: "0xd4 [stats]: **I**" {style.fill: "#f5f5f5"; style.stroke: gray; style.bold: true}
    }
  }
  CPU_1: "CPU 1" {
    L1_Cache: {
      Line_C: "0xd4 [stats]: **M**" {style.fill: "#f8cecc"; style.stroke: red; style.bold: true}
    }
  }
  
  CPU_1.L1_Cache.Line_C -> CPU_0.L1_Cache.Line_C: "LOCK INC (Line Bounce)" {style.stroke: red}
  
  Annotation: |'md
  ### False Sharing / Contention
  `read_ops` and `write_ops` sharing Line C 
  causes constant invalidation traffic 
  during high-throughput stress tests.
  '|
}

Step_1 -> Step_2: "CPU 1 enters read()"
Step_2 -> Step_3: "CPU 0 releases lock"
Step_3 -> Step_4: "Atomic statistics update"