direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

shape: sequence_diagram

# Participants: Exact Kernel Types/Subsystems
Module: "mychar_dev.ko\n(Kernel Module)" {
  shape: person
}
Kernel_FS: "fs/char_dev.c\n(chrdev_map)" {
  style.fill: "#DEE1EB"
}
Kernel_Cdev: "fs/cdev.c\n(cdev_hash)" {
  style.fill: "#DEE1EB"
}
Kernel_Sysfs: "drivers/base/class.c\n(sysfs)" {
  style.fill: "#DEE1EB"
}
Kernel_Uevent: "lib/kobject_uevent.c\n(Netlink)" {
  style.fill: "#DEE1EB"
}
Udev_Daemon: "systemd-udevd\n(Userspace)" {
  shape: rectangle
  style.fill: "#C7F1FF"
}
DevFS: "/dev/\n(Virtual FS)" {
  style.fill: "#B5AFF6"
}

# 1. Major/Minor Allocation
Module -> Kernel_FS: "alloc_chrdev_region(&dev_num, 0, 1, 'mydevice')"
Kernel_FS."Reserves entry in chrdev_map hash table\nkeyed by major number."
Kernel_FS -> Module: "ret (dev_t = MKDEV(major, 0))"

# 2. Character Device Registration
Module -> Module: "cdev_init(&my_cdev, &mydev_fops)"
Module."Populates struct cdev:\n- ops = &mydev_fops\n- owner = THIS_MODULE"

Module -> Kernel_Cdev: "cdev_add(&my_cdev, dev_num, 1)" {
  style: {
    stroke: red
    stroke-width: 4
  }
}
Kernel_Cdev."CRITICAL: Device is now LIVE.\nSystem calls can now route to fops."
Kernel_Cdev -> Module: "0 (Success)"

# 3. Class Creation (sysfs)
Module -> Kernel_Sysfs: "class_create(THIS_MODULE, 'mydevice_class')"
Kernel_Sysfs."Registers under /sys/class/mydevice_class/"
Kernel_Sysfs -> Module: "struct class *my_class"

# 4. Device Creation & udev Trigger
Module -> Kernel_Sysfs: "device_create(my_class, NULL, dev_num, NULL, 'mydevice')"
Kernel_Sysfs -> Kernel_Uevent: "kobject_uevent(KOBJ_ADD)"

# Asynchronous Userspace Flow
Kernel_Uevent -> Udev_Daemon: "UEVENT (Netlink Broadcast)" {
  style.stroke-dash: 5
}

Udev_Daemon -> DevFS: "mknod('/dev/mydevice', S_IFCHR, major, minor)" {
  style.animated: true
}

# Annotations for Engineers (Attached as a note to DevFS participant)
DevFS."REGISTRATION INVARIANTS & ERROR UNWIND": |md
  ### REGISTRATION INVARIANTS
  1. **Point of No Return**: Once `cdev_add` returns, the kernel permits `open()` calls. All backend data structures (buffers, mutexes) **must** be initialized *before* this call.
  2. **Waitqueues**: Must be initialized via `init_waitqueue_head()` before `cdev_add`.
  
  ### ERROR UNWIND SEQUENCE (LIFO)
  If step N fails, perform:
  - `device_destroy()`
  - `class_destroy()`
  - `cdev_del()`
  - `unregister_chrdev_region()`
|