vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# 1. Global Definitions & Architecture Metadata
direction: right

# 2. Virtual File System (VFS) Layer
vfs: "VFS Syscall Entry Points" {
  style.fill: "#E4DBFE"
  open_call: "open(2)" {
    shape: rectangle
    style.border-radius: 20
  }
  read_call: "read(2)" {
    shape: rectangle
    style.border-radius: 20
  }
  write_call: "write(2)" {
    shape: rectangle
    style.border-radius: 20
  }
  close_call: "close(2)" {
    shape: rectangle
    style.border-radius: 20
  }
  ioctl_call: "ioctl(2)" {
    shape: rectangle
    style.border-radius: 20
    style.stroke-dash: 3
  }
}

# 3. Kernel File & Device Structures
struct_file: "struct file (In-memory Instance)" {
  style.fill: "#C7F1FF"
  
  f_pos: "0x00 | f_pos: loff_t (8 bytes)" {style.fill: "#88DCF7"}
  f_op: "0x08 | f_op: struct file_operations* (8 bytes)" {style.fill: "#FFA500"}
  
  anno: |md
    **f_op** is initialized during `open()` 
    from the inode's `i_cdev->ops`.
  |
}

cdev_obj: "struct cdev (Driver Registration)" {
  style.fill: "#C7F1FF"
  
  ops: "0x00 | ops: struct file_operations* (8 bytes)" {style.fill: "#FFA500"}
  dev: "0x08 | dev: dev_t (4 bytes)" {style.fill: "#88DCF7"}
  
  anno: |md
    Registered via `cdev_add()`.
    Linked to Major/Minor region.
  |
}

# 4. The Dispatch Table (VTable)
vtable: "struct file_operations mydev_fops (248 bytes)" {
  style.fill: "#E4DBFE"

  # Byte Offsets (x86_64)
  owner: "0x00 | owner (struct module*)" {style.fill: "#FFA500"}
  read: "0x10 | read (ssize_t *)" {style.fill: "#88DCF7"}
  write: "0x18 | write (ssize_t *)" {style.fill: "#88DCF7"}
  ioctl: "0x30 | unlocked_ioctl (8B)" {style.fill: "#808080"} 
  open: "0x58 | open (int *)" {style.fill: "#88DCF7"}
  release: "0x68 | release (int *)" {style.fill: "#88DCF7"}
  poll: "0x78 | poll (8B)" {style.fill: "#808080"}
}

# 5. Driver Implementations
driver: "Driver Code (Kernel Space)" {
  style.fill: "#ACE1AF"
  
  fn_open: "int mydev_open(struct inode *i, struct file *f)" 
  fn_read: "ssize_t mydev_read(struct file *f, char __user *b, size_t c, loff_t *p)" 
  fn_write: "ssize_t mydev_write(struct file *f, const char __user *b, size_t c, loff_t *p)" 
  fn_release: "int mydev_release(struct inode *i, struct file *f)" 
}

# 6. Connections & Dispatch Logic
# Syscall to VTable Slot
vfs.open_call -> vtable.open: "Traverses Inode"
vfs.read_call -> vtable.read
vfs.write_call -> vtable.write
vfs.close_call -> vtable.release

# VTable Slot to Driver Implementation
vtable.open -> driver.fn_open: "Indirect Call" {style.stroke-width: 2}
vtable.read -> driver.fn_read: "Indirect Call" {style.stroke-width: 2}
vtable.write -> driver.fn_write: "Indirect Call" {style.stroke-width: 2}
vtable.release -> driver.fn_release: "Indirect Call" {style.stroke-width: 2}

# Structural References
struct_file.f_op -> vtable: "references" {style.stroke-dash: 5}
cdev_obj.ops -> vtable: "references" {style.stroke-dash: 5}

# Relationship Annotations
driver.fn_read -> vtable.read: "implements" {
  source-arrowhead: * {
    shape: triangle
    style.filled: false
  }
}

# 7. Legend & Global Notes (Root level shapes for 'near' positioning)
note_null: |md
  **NULL Fields**
  Return `-ENOSYS` 
  at the VFS layer.
| {
  near: bottom-right
}

note_owner: |md
  **.owner = THIS_MODULE**
  Pins module in memory; 
  prevents `rmmod` while 
  refcount > 0.
| {
  near: top-left
}