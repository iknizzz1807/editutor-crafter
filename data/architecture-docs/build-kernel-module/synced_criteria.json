[
  {
    "milestone_id": "build-kernel-module-m1",
    "criteria": [
      "Module compiles with `make` using a Kbuild Makefile that references /lib/modules/$(uname -r)/build; build succeeds against the currently running kernel headers with zero errors",
      "Compiled module produces no warnings when built with ccflags-y := -Werror in the Makefile",
      "`modinfo hello.ko` output includes all four fields: `license: GPL`, `author:` (non-empty), `description:` (non-empty), and `version:` (non-empty)",
      "Module declares MODULE_LICENSE(\"GPL\") — loading without this causes kernel taint warning and lsmod shows tainted state; with it, no taint warning appears",
      "`sudo insmod hello.ko` succeeds (exits 0) and `dmesg | tail` shows a KERN_INFO message from module_init containing the module name",
      "`sudo rmmod hello` succeeds (exits 0) and `dmesg | tail` shows a KERN_INFO message from module_exit containing the module name",
      "Module accepts `buffer_size` integer parameter via module_param() with default value 4096; after `insmod hello.ko`, `/sys/module/hello/parameters/buffer_size` exists and reads `4096`",
      "Module parameter permissions are 0644 (not 0666); the sysfs file is owner-writable and world-readable",
      "Loading with custom parameter `sudo insmod hello.ko buffer_size=8192` results in `/sys/module/hello/parameters/buffer_size` reading `8192` and dmesg showing the custom value",
      "Init function validates buffer_size: passing an invalid value (e.g., `buffer_size=-1` or `buffer_size=2000000`) causes insmod to fail with a KERN_ERR message in dmesg and returns -EINVAL",
      "Module_init returns 0 on success; any non-zero negative return code causes insmod to fail without leaving a partial module loaded",
      "After rmmod, the module is absent from `lsmod` output and `/sys/module/hello/` directory no longer exists",
      "Verification script runs all insmod/dmesg/modinfo/rmmod checks and exits 0 only when all assertions pass"
    ]
  },
  {
    "milestone_id": "build-kernel-module-m2",
    "criteria": [
      "Module compiles with ccflags-y := -Werror producing zero warnings against the running kernel headers using Kbuild",
      "alloc_chrdev_region() dynamically allocates a major number; MAJOR(dev_num) and MINOR(dev_num) macros correctly extract components; major number visible in /proc/devices as 'mydevice'",
      "class_create() and device_create() automatically create /dev/mydevice via udev without manual mknod; device node appears with correct major:minor after insmod",
      "file_operations struct defines .owner = THIS_MODULE, .open = mydev_open, .release = mydev_release, .read = mydev_read, .write = mydev_write",
      "kzalloc(BUFFER_SIZE, GFP_KERNEL) allocates kernel buffer in module_init; return value checked for NULL; returns -ENOMEM on allocation failure",
      "write handler uses copy_from_user() with __user-annotated source pointer; returns -EFAULT when copy_from_user returns non-zero; stores up to BUFFER_SIZE bytes in kernel buffer",
      "read handler uses copy_to_user() with __user-annotated destination pointer; returns -EFAULT when copy_to_user returns non-zero",
      "read handler returns 0 (EOF) when *f_pos >= buffer_used, preventing infinite cat loops",
      "read handler advances *f_pos by bytes_to_copy after each successful copy_to_user call; subsequent reads continue from updated position",
      "open handler increments atomic_t open_count via atomic_inc(); release handler decrements it via atomic_dec(); values visible in dmesg printk output",
      "echo 'hello' | tee /dev/mydevice followed by cat /dev/mydevice outputs 'hello' and cat terminates",
      "module_exit performs cleanup in reverse initialization order: device_destroy → class_destroy → cdev_del → unregister_chrdev_region → kfree; /dev/mydevice removed after rmmod",
      "goto-based error unwind in module_init correctly frees all partially-initialized resources if any init step fails",
      "make C=1 (Sparse static analysis) produces no __user annotation violations"
    ]
  },
  {
    "milestone_id": "build-kernel-module-m3",
    "criteria": [
      "mydevice_ioctl.h compiles correctly when included in kernel code (with __KERNEL__ defined by Kbuild) and in userspace code (without __KERNEL__); _IO/_IOW/_IOR macros resolve to correct implementations in each environment",
      "MYDEV_CLEAR, MYDEV_RESIZE, and MYDEV_STATUS are defined using _IO, _IOW, and _IOR macros respectively with magic byte 'M' (or another unique registered value); all three produce distinct non-zero 32-bit values",
      "unlocked_ioctl handler validates _IOC_TYPE(cmd) against MYDEV_MAGIC before processing; any command with a different magic number returns -ENOTTY",
      "unlocked_ioctl handler validates _IOC_NR(cmd) is within the defined command range; any out-of-range command number returns -ENOTTY (not -EINVAL)",
      "MYDEV_CLEAR handler zeroes the kernel buffer contents with memset and resets buffer_used to 0; a read after CLEAR returns 0 bytes (immediate EOF)",
      "MYDEV_RESIZE handler uses allocate-then-swap pattern: allocates new buffer with kzalloc before freeing old; if kzalloc fails, original buffer remains intact and -ENOMEM is returned",
      "MYDEV_RESIZE handler validates new_size is non-zero and within a defined maximum (e.g., 1MB); returns -EINVAL for out-of-range values without touching the buffer",
      "MYDEV_RESIZE handler correctly handles resize-down: if buffer_used exceeds new_size, buffer_used is truncated to new_size before memcpy, preventing buffer overflow",
      "MYDEV_STATUS handler fills all six fields of struct mydev_status (buffer_size, bytes_used, open_count, read_count, write_count, _reserved) and copies to userspace via copy_to_user; returns -EFAULT if copy fails",
      "read_count atomic counter increments on each successful read operation; write_count increments on each successful write; both are visible in MYDEV_STATUS output",
      "/proc/mydevice entry is created with proc_create() using mode 0444 (world-readable, not writable) and proc_ops pointing to seq_file-based handlers",
      "mydev_proc_show uses seq_printf (not sprintf or printk) to output all five statistics: buffer_size, bytes_used, open_count, read_count, write_count",
      "cat /proc/mydevice completes and terminates without hanging; calling cat twice produces consistent output without double-printing or offset errors",
      "proc_entry is removed with proc_remove() in module_exit before device and class are destroyed; /proc/mydevice disappears after rmmod",
      "ioctl(fd, _IO('Z', 99)) returns -1 with errno == ENOTTY; verified in test program",
      "test program test_mydevice.c compiles with gcc -Wall -Werror -I. and exercises MYDEV_CLEAR, MYDEV_RESIZE, MYDEV_STATUS, an unknown command, and /proc read in a single run",
      "struct mydev_status uses __u32 for all integer fields (not unsigned int or uint32_t directly) to guarantee fixed-width layout across architectures",
      "module compiles with ccflags-y := -Werror and produces zero warnings including no __user annotation violations (verified with make C=1 Sparse check)"
    ]
  },
  {
    "milestone_id": "build-kernel-module-m4",
    "criteria": [
      "Module compiles with zero warnings using ccflags-y := -Werror; DEFINE_MUTEX, DECLARE_WAIT_QUEUE_HEAD for read_queue and write_queue declared at module level",
      "Every access to kernel_buffer, buffer_used, and buffer_size_bytes in all file operation handlers (read, write, ioctl) is enclosed in mutex_lock/mutex_unlock; no direct access outside the lock",
      "Write handler uses mutex_lock_interruptible(&dev_mutex) and returns -ERESTARTSYS if interrupted by a signal during mutex acquisition",
      "Read handler uses wait_event_interruptible(read_queue, buffer_used > *f_pos) to block when no unread data is available; returns -ERESTARTSYS when wait is interrupted by a signal",
      "Write handler uses wait_event_interruptible(write_queue, buffer_used < buffer_size_bytes) to block when buffer is full; returns -ERESTARTSYS when interrupted",
      "Write handler calls wake_up_interruptible(&read_queue) after successfully adding data to the buffer, while still holding dev_mutex",
      "Read handler calls wake_up_interruptible(&write_queue) after successfully consuming data from the buffer, while still holding dev_mutex",
      "Both read and write handlers check filp->f_flags & O_NONBLOCK before entering the wait loop; non-blocking read returns -EAGAIN (not 0) when no unread data exists; non-blocking write returns -EAGAIN when buffer is full",
      ".poll file operation registered in file_operations struct; calls poll_wait(filp, &read_queue, wait) and poll_wait(filp, &write_queue, wait) before any condition checks",
      ".poll handler acquires dev_mutex (non-interruptible) to read buffer_used and buffer_size_bytes, returns POLLIN|POLLRDNORM when buffer_used > 0, returns POLLOUT|POLLWRNORM when buffer_used < buffer_size_bytes",
      "poll(2) in a userspace test program correctly identifies initial state (POLLOUT set, POLLIN clear on empty buffer), POLLIN|POLLOUT set after write, transitions verified",
      "Stress test with 4 concurrent writer processes and 4 concurrent reader processes runs to completion with no kernel oops, BUG_ON, WARNING, or panic in dmesg",
      "Stress test verifies data integrity: total bytes written by all 4 writers equals total bytes read by all 4 readers; per-writer byte counts match per-value counts in read data",
      "Ctrl+C (SIGINT) during a blocking read causes read() to return -1 with errno==EINTR in userspace; device mutex is properly released; no kernel deadlock or corruption results",
      "ioctl handlers (MYDEV_CLEAR, MYDEV_RESIZE, MYDEV_STATUS) all acquire dev_mutex before accessing shared state; MYDEV_RESIZE calls kzalloc before acquiring mutex (allocate-then-swap pattern), calls wake_up_interruptible on both queues after resize",
      "make C=1 (Sparse check) produces no __user annotation violations in any handler including the new poll handler"
    ]
  },
  {
    "module_id": "build-kernel-module-m1",
    "criteria": [
      "Module compiles against current running kernel headers using a Kbuild Makefile",
      "insmod loads the module; module_init function runs and printk message appears in dmesg",
      "rmmod cleanly unloads the module; module_exit function runs with cleanup message in dmesg",
      "Module declares MODULE_LICENSE('GPL'), MODULE_AUTHOR, and MODULE_DESCRIPTION; all visible via modinfo",
      "Module accepts buffer_size parameter via module_param(); parameter is visible in /sys/module/hello/parameters/ and validated in range 1-1048576",
      "Module code follows Linux Kernel Style Guide (static functions, __init/__exit annotations)"
    ]
  },
  {
    "module_id": "build-kernel-module-m2",
    "criteria": [
      "alloc_chrdev_region allocates dynamic major number",
      "class_create and device_create trigger /dev node creation via udev",
      "file_operations struct links open, release, read, and write",
      "copy_from_user and copy_to_user used for all userspace data transfers",
      "read handler correctly updates *f_pos and returns 0 at EOF",
      "write handler checks for ENOSPC when buffer is full",
      "module_init uses goto-based error unwinding to prevent leaks",
      "atomic_t used for open_count tracking"
    ]
  },
  {
    "module_id": "build-kernel-module-m3",
    "criteria": [
      "Implement unlocked_ioctl with Magic 'M' and NR 0-2",
      "Implement MYDEV_RESIZE with allocate-then-swap logic",
      "Implement MYDEV_STATUS with copy_to_user of a 24-byte struct",
      "Create /proc/mydevice using the seq_file abstraction",
      "Validate ioctl command numbers and return -ENOTTY for mismatches",
      "Use __KERNEL__ guards in a shared header for ABI stability",
      "Check proc_create return value for NULL to handle registration failure",
      "Maintain read/write counters using atomic_t in data handlers"
    ]
  },
  {
    "module_id": "build-kernel-module-m4",
    "criteria": [
      "Mutex initialization and destruction correctly implemented in init/exit.",
      "Read and write handlers implement blocking logic with wait_event_interruptible.",
      "Handlers correctly check and respect the O_NONBLOCK flag.",
      "The .poll handler registers both read and write wait queues using poll_wait().",
      "Handlers call wake_up_interruptible() to signal state changes.",
      "The -ERESTARTSYS error code is correctly propagated on signal interruption.",
      "The ioctl handler is updated to be thread-safe via the device mutex.",
      "A stress test with 4 writers and 4 readers shows zero data corruption or kernel faults."
    ]
  }
]