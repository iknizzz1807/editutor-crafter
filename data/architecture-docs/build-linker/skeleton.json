{
  "title": "Static Linker: Design Document",
  "overview": "This document designs a static linker that merges multiple compiled object files into a single executable ELF binary. The key architectural challenge is resolving symbolic references across separate compilation units while maintaining proper memory layout, requiring careful section concatenation, global symbol table construction, and address relocation patching.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains the linking problem in software compilation, why it's necessary, and the challenges of merging separate compilation units into a runnable program.",
      "subsections": [
        {
          "id": "analogy",
          "title": "The Assembly Puzzle Analogy",
          "summary": "Compares linking to assembling a puzzle where each object file is a puzzle piece with connectors (symbols) that must match."
        },
        {
          "id": "problem-deep-dive",
          "summary": "Describes the core technical challenges: section merging with alignment, cross-file symbol resolution, and address relocation."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches Comparison",
          "summary": "Compares traditional static linkers (ld, gold) with modern approaches and dynamic linking."
        }
      ]
    },
    {
      "id": "goals-nongoals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what this static linker must achieve and explicit boundaries of its functionality.",
      "subsections": [
        {
          "id": "goals-list",
          "title": "Goals",
          "summary": "Must support: multi-file ELF parsing, section merging, symbol resolution, relocation processing, and executable generation."
        },
        {
          "id": "nongoals-list",
          "title": "Non-Goals",
          "summary": "Will NOT include: dynamic linking, shared libraries, cross-architecture linking, or compiler integration."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Overview of system components, their responsibilities, and how they interact to transform object files into an executable.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Describes the five main components: ELF Reader, Section Merger, Symbol Resolver, Relocation Applier, and Executable Writer."
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "Suggests how to organize the codebase into modules for each component with clear separation of concerns."
        },
        {
          "id": "workflow-overview",
          "title": "Linking Workflow",
          "summary": "Step-by-step flow from input object files to output executable, showing data passing between components."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the core data structures representing ELF sections, symbols, relocations, and their relationships.",
      "subsections": [
        {
          "id": "elf-structures",
          "title": "ELF File Representation",
          "summary": "Structures for parsed ELF headers, section headers, and program headers."
        },
        {
          "id": "internal-structures",
          "title": "Internal Linking Structures",
          "summary": "Tables for tracking merged sections, global symbols, and relocation mappings."
        }
      ]
    },
    {
      "id": "component-elf-reader",
      "title": "Component: ELF Reader",
      "summary": "Responsible for parsing input object files, extracting sections, symbols, and relocation information. (Milestone 1)",
      "subsections": [
        {
          "id": "elf-reader-mental-model",
          "title": "Mental Model: Library Catalog",
          "summary": "ELF reader acts like a library catalog that indexes all parts of a book (object file) without modifying its contents."
        },
        {
          "id": "elf-reader-interface",
          "title": "Interface Specification",
          "summary": "Functions to load ELF files, query sections and symbols, and provide access to raw section data."
        },
        {
          "id": "elf-reader-behavior",
          "title": "Internal Behavior",
          "summary": "Steps to validate ELF format, parse headers, load section data, and extract symbol/relocation tables."
        },
        {
          "id": "elf-reader-adr",
          "title": "Architecture Decision: ELF Parsing Library vs Manual Parsing",
          "summary": "Decision to use manual parsing for educational value over using existing ELF libraries."
        },
        {
          "id": "elf-reader-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Endianness mismatches, alignment issues, and handling of special sections like .symtab and .rela."
        },
        {
          "id": "elf-reader-implementation",
          "title": "Implementation Guidance",
          "summary": "File structure, starter code for ELF header parsing, and skeleton for section loading."
        }
      ]
    },
    {
      "id": "component-section-merger",
      "title": "Component: Section Merger",
      "summary": "Combines same-type sections from multiple object files into contiguous output sections with proper alignment. (Milestone 1)",
      "subsections": [
        {
          "id": "merger-mental-model",
          "title": "Mental Model: Warehouse Consolidation",
          "summary": "Like consolidating inventory from multiple warehouses into a single warehouse, grouping similar items together with aisle spacing."
        },
        {
          "id": "merger-interface",
          "title": "Interface Specification",
          "summary": "Methods to add sections, compute merged layout, and map input sections to output addresses."
        },
        {
          "id": "merger-behavior",
          "title": "Internal Behavior",
          "summary": "Algorithm for grouping sections by type/name, applying alignment padding, and building output section table."
        },
        {
          "id": "merger-adr",
          "title": "Architecture Decision: Lazy vs Eager Section Processing",
          "summary": "Decision to process all sections in two passes (layout then data) versus streaming approach."
        },
        {
          "id": "merger-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Incorrect alignment padding, mishandling of .bss (no file data), and mixing incompatible section flags."
        },
        {
          "id": "merger-implementation",
          "title": "Implementation Guidance",
          "summary": "Data structures for tracking merged sections, alignment helper functions, and layout algorithm skeleton."
        }
      ]
    },
    {
      "id": "component-symbol-resolver",
      "title": "Component: Symbol Resolver",
      "summary": "Builds global symbol table across all object files, resolving references and handling duplicate definitions. (Milestone 2)",
      "subsections": [
        {
          "id": "resolver-mental-model",
          "title": "Mental Model: Conference Name Badges",
          "summary": "Like issuing name badges at a conference where each attendee (symbol) must have a unique badge, and references point to badge holders."
        },
        {
          "id": "resolver-interface",
          "title": "Interface Specification",
          "summary": "Functions to add symbols from objects, resolve references, and query final symbol addresses."
        },
        {
          "id": "resolver-behavior",
          "title": "Internal Behavior",
          "summary": "Steps to collect global symbols, handle strong/weak rules, resolve COMMON symbols, and detect undefined symbols."
        },
        {
          "id": "resolver-adr",
          "title": "Architecture Decision: Two-Pass Symbol Resolution",
          "summary": "Decision to use two passes: first collect all definitions, then resolve references with complete symbol table."
        },
        {
          "id": "resolver-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Incorrect strong/weak resolution, mishandling of COMMON symbols, and confusing local vs global symbol visibility."
        },
        {
          "id": "resolver-implementation",
          "title": "Implementation Guidance",
          "summary": "Symbol table data structure, strong/weak comparison logic, and undefined symbol detection skeleton."
        }
      ]
    },
    {
      "id": "component-relocation-applier",
      "title": "Component: Relocation Applier",
      "summary": "Patches addresses in merged sections using relocation entries and resolved symbol addresses. (Milestone 3)",
      "subsections": [
        {
          "id": "reloc-mental-model",
          "title": "Mental Model: Address Labeling Service",
          "summary": "Like a mail forwarding service that updates old addresses on letters to new addresses after someone moves."
        },
        {
          "id": "reloc-interface",
          "title": "Interface Specification",
          "summary": "Methods to apply relocations to merged section data using symbol addresses and relocation entries."
        },
        {
          "id": "reloc-behavior",
          "title": "Internal Behavior",
          "summary": "Algorithm to iterate relocation entries, calculate final addresses, patch section data, and detect overflow."
        },
        {
          "id": "reloc-adr",
          "title": "Architecture Decision: In-Place vs Copy Relocation",
          "summary": "Decision to modify merged section data in-place versus creating relocated copies."
        },
        {
          "id": "reloc-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Incorrect PC-relative calculation, addend handling errors, and truncation overflow in 32-bit relocation fields."
        },
        {
          "id": "reloc-implementation",
          "title": "Implementation Guidance",
          "summary": "Relocation type handlers, address calculation helpers, and byte-patching functions with skeleton code."
        }
      ]
    },
    {
      "id": "component-executable-writer",
      "title": "Component: Executable Writer",
      "summary": "Generates final ELF executable with program headers, proper segment layout, and entry point. (Milestone 4)",
      "subsections": [
        {
          "id": "writer-mental-model",
          "title": "Mental Model: Building Blueprint",
          "summary": "Like creating architectural blueprints that tell the OS loader how to map the binary into memory with proper room divisions."
        },
        {
          "id": "writer-interface",
          "title": "Interface Specification",
          "summary": "Functions to write ELF headers, program headers, and section data to output file."
        },
        {
          "id": "writer-behavior",
          "title": "Internal Behavior",
          "summary": "Steps to create page-aligned segments, set permissions, write headers, and serialize section data."
        },
        {
          "id": "writer-adr",
          "title": "Architecture Decision: Single vs Multiple PT_LOAD Segments",
          "summary": "Decision to use separate segments for text (RX) and data (RW) versus combined segments."
        },
        {
          "id": "writer-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Incorrect page alignment, wrong entry point address, and mixing segment permissions incorrectly."
        },
        {
          "id": "writer-implementation",
          "title": "Implementation Guidance",
          "summary": "ELF header construction, program header generation, and file writing utilities with skeleton code."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Describes how components communicate, the sequence of operations, and data transformations through the linking pipeline.",
      "subsections": [
        {
          "id": "sequence-overview",
          "title": "Linking Sequence",
          "summary": "Step-by-step flow from reading object files to writing executable, showing data dependencies."
        },
        {
          "id": "data-transformations",
          "title": "Data Transformations",
          "summary": "How raw section data, symbols, and relocations evolve through each processing stage."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Describes failure modes, detection strategies, and recovery approaches for common linking errors.",
      "subsections": [
        {
          "id": "error-categories",
          "title": "Error Categories",
          "summary": "Classification of errors: input validation, symbol resolution, relocation, and layout errors."
        },
        {
          "id": "detection-recovery",
          "title": "Detection and Recovery",
          "summary": "How to detect errors early and provide helpful error messages versus crashing."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Approaches to verify correctness at each milestone, including test programs and expected outputs.",
      "subsections": [
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "For each milestone: what to test, example commands, and expected behavior verification."
        },
        {
          "id": "test-programs",
          "title": "Test Programs",
          "summary": "Simple C programs designed to test specific linker features like external references and relocations."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common bugs learners encounter, symptoms, root causes, and diagnostic techniques.",
      "subsections": [
        {
          "id": "symptom-cause-table",
          "title": "Symptom \u2192 Cause \u2192 Fix Table",
          "summary": "Structured table mapping observable problems to likely causes and fixes."
        },
        {
          "id": "inspection-techniques",
          "title": "Binary Inspection Techniques",
          "summary": "Using readelf, objdump, and hexdump to examine intermediate and final outputs."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements to the linker beyond the core requirements, showing how the design accommodates them.",
      "subsections": [
        {
          "id": "extension-ideas",
          "title": "Extension Ideas",
          "summary": "Support for more relocation types, simple archive libraries, debug sections, and cross-compilation."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key terms, acronyms, and domain-specific vocabulary used throughout the document.",
      "subsections": [
        {
          "id": "terms-table",
          "title": "Terminology Table",
          "summary": "Alphabetical list of terms with definitions and references to where they first appear."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "component-diagram",
      "title": "Static Linker Component Diagram",
      "description": "Shows the five main components (ELF Reader, Section Merger, Symbol Resolver, Relocation Applier, Executable Writer) and their interactions. Include data flow arrows between components and external inputs/outputs.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-data-flow"
      ]
    },
    {
      "id": "data-model-diagram",
      "title": "Data Model Relationships",
      "description": "Shows key data structures: ObjectFile, MergedSection, SymbolTableEntry, RelocationEntry. Include relationships like 'contains', 'maps to', 'references' between these types.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "linking-sequence",
      "title": "Linking Process Sequence Diagram",
      "description": "Shows the sequence of operations from reading multiple object files through section merging, symbol resolution, relocation, to writing executable. Include component interactions and data transformations.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "high-level-architecture"
      ]
    },
    {
      "id": "symbol-resolution-flowchart",
      "title": "Symbol Resolution Flowchart",
      "description": "Flowchart showing the decision process for handling symbols: strong vs weak, defined vs undefined, local vs global, COMMON symbols. Include decision diamonds and resolution outcomes.",
      "type": "flowchart",
      "relevant_sections": [
        "component-symbol-resolver"
      ]
    },
    {
      "id": "section-merging-layout",
      "title": "Section Merging Layout Diagram",
      "description": "Visual representation of how sections from different object files are concatenated with alignment padding. Show .text, .data, .rodata sections from multiple files merging into output sections with padding between.",
      "type": "component",
      "relevant_sections": [
        "component-section-merger"
      ]
    },
    {
      "id": "segment-layout-diagram",
      "title": "Executable Segment Layout",
      "description": "Shows the final executable memory layout with PT_LOAD segments: text segment (RX) containing .text and .rodata, data segment (RW) containing .data and .bss, with page alignment boundaries.",
      "type": "component",
      "relevant_sections": [
        "component-executable-writer"
      ]
    }
  ]
}