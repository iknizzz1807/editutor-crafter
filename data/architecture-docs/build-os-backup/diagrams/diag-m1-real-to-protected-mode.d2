vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Real Mode vs Protected Mode: Address Translation Comparison
  *The far jump is the atomic boundary — before: segment×16+offset; after: GDT\[selector\].base+offset*
| {near: top-center}

real_mode: "Real Mode (8086 Compatible — 1978)" {
  style: {
    fill: "#2d1b1b"
    stroke: "#e05252"
    stroke-width: 3
    border-radius: 8
    font-color: "#ffcccc"
    bold: true
    font-size: 16
  }

  rm_label: "No Protection — Any Code Can Write Any Address" {
    style.fill: "#4a1a1a"
    style.stroke: "#e05252"
    style.font-color: "#ff8888"
    style.border-radius: 4
    style.bold: true
  }

  rm_regs: "Segment Registers (16-bit)" {
    style: {
      fill: "#3d1f1f"
      stroke: "#c44444"
      border-radius: 6
    }
    cs_reg: "CS = 0x07C0\n(Code Segment)" {
      style.fill: "#5a2020"
      style.stroke: "#e05252"
      style.font-color: "#ffaaaa"
      style.font: mono
    }
    ds_reg: "DS = 0x0000\n(Data Segment)" {
      style.fill: "#5a2020"
      style.stroke: "#e05252"
      style.font-color: "#ffaaaa"
      style.font: mono
    }
    ss_reg: "SS = 0x9000\n(Stack Segment)" {
      style.fill: "#5a2020"
      style.stroke: "#e05252"
      style.font-color: "#ffaaaa"
      style.font: mono
    }
  }

  rm_formula: "Address Calculation Formula" {
    style: {
      fill: "#2a1010"
      stroke: "#cc3333"
      border-radius: 6
      font-color: "#ff9999"
    }
    formula_detail: "Physical = (Segment x 16) + Offset\n(Segment << 4) + Offset\n\nExample MBR at boot:\n  CS  = 0x07C0\n  IP  = 0x0000\n  0x07C00 + 0x0000 = 0x07C00" {
      style.fill: "#1e0808"
      style.stroke: "#aa2222"
      style.font-color: "#ff9999"
      style.font: mono
    }
  }

  rm_example: "Translation Example (MBR Boot)" {
    style: {
      fill: "#1e1010"
      stroke: "#aa2222"
      border-radius: 6
    }
    seg_val: "Segment Register\nCS = 0x07C0\n(16-bit value)" {
      style.fill: "#4a1515"
      style.stroke: "#dd4444"
      style.font-color: "#ff9999"
      style.font: mono
    }
    shift_op: "x 16  (left shift 4 bits)\n= 0x07C00\n(20-bit intermediate)" {
      style.fill: "#3a1010"
      style.stroke: "#cc3333"
      style.font-color: "#ffaaaa"
      style.font: mono
      style.bold: true
    }
    offset_val: "+ Offset Register\nIP = 0x0000\n(16-bit)" {
      style.fill: "#4a1515"
      style.stroke: "#dd4444"
      style.font-color: "#ff9999"
      style.font: mono
    }
    phys_addr: "= Physical Address\n0x07C00\n(MBR boot entry point)" {
      style.fill: "#6a1515"
      style.stroke: "#ff4444"
      style.font-color: "#ffcccc"
      style.font: mono
      style.bold: true
    }
    seg_val -> shift_op: "segment x 16 → 20-bit base"
    shift_op -> offset_val: "+ IP offset"
    offset_val -> phys_addr: "= final physical address\n(20-bit, max 0xFFFFF)"
  }

  rm_limits: "Address Space Constraints" {
    style: {
      fill: "#1a0a0a"
      stroke: "#993333"
      border-radius: 6
      font-color: "#ff8888"
    }
    limit1: "Max: 1MB\n(2^20 = 1,048,576 bytes)\n20 address lines A0-A19" {
      style.fill: "#400000"
      style.stroke: "#cc2222"
      style.font-color: "#ffaaaa"
      style.font: mono
    }
    limit2: "Protection: NONE\nAny CS value allowed\nAny segment can overlap" {
      style.fill: "#500000"
      style.stroke: "#ee2222"
      style.font-color: "#ffbbbb"
      style.bold: true
    }
    limit3: "Overlap Risk: TOTAL\nDS=0x0000 and CS=0x0000\ncover same physical bytes\nDOS viruses exploited this" {
      style.fill: "#3a0000"
      style.stroke: "#bb2222"
      style.font-color: "#ff9999"
      style.font: mono
    }
  }

  rm_memory_map: "Physical Memory Layout (Real Mode, 1MB)" {
    style: {
      fill: "#1a0808"
      stroke: "#882222"
      border-radius: 6
    }
    map_ivt: "0x00000-0x003FF\nIVT (256 x 4-byte vectors)\n1024 bytes" {
      style.fill: "#3d1010"
      style.stroke: "#cc3333"
      style.font-color: "#ffaaaa"
      style.font: mono
    }
    map_bda: "0x00400-0x004FF\nBIOS Data Area\n256 bytes of hardware state" {
      style.fill: "#3d1010"
      style.stroke: "#cc3333"
      style.font-color: "#ffaaaa"
      style.font: mono
    }
    map_mbr: "0x07C00-0x07DFF\nMBR / Stage 1 Bootloader\n512 bytes, loaded by BIOS" {
      style.fill: "#5a1a1a"
      style.stroke: "#ee4444"
      style.font-color: "#ffcccc"
      style.font: mono
      style.bold: true
    }
    map_vga: "0xB8000-0xBFFFF\nVGA Text Buffer\n80x25x2 = 4000 bytes active" {
      style.fill: "#3d1010"
      style.stroke: "#cc3333"
      style.font-color: "#ffaaaa"
      style.font: mono
    }
    map_bios: "0xF0000-0xFFFFF\nBIOS ROM\nFirmware, not RAM" {
      style.fill: "#3d1010"
      style.stroke: "#cc3333"
      style.font-color: "#ffaaaa"
      style.font: mono
    }
    map_ivt -> map_bda: "contiguous"
    map_bda -> map_mbr: "no protection between these!" {
      style.stroke: "#ff4444"
      style.font-color: "#ff6666"
      style.bold: true
    }
    map_mbr -> map_vga: "bootloader writes VGA directly"
    map_vga -> map_bios: "above 640KB"
  }

  rm_regs -> rm_formula: "segment value used in\nshift-and-add formula"
  rm_formula -> rm_example: "applied to MBR example"
  rm_example -> rm_limits: "reveals hard constraints"
  rm_limits -> rm_memory_map: "maps to 1MB physical layout"
}

far_jump: "THE FAR JUMP — Atomic Mode Boundary" {
  style: {
    fill: "#1a1a0a"
    stroke: "#ffdd44"
    stroke-width: 4
    border-radius: 10
    font-color: "#ffff88"
    bold: true
    font-size: 18
    shadow: true
  }

  fj_prereqs: "Prerequisites (in order)" {
    style: {
      fill: "#0a1a0a"
      stroke: "#44aa44"
      border-radius: 6
      font-color: "#aaffaa"
    }
    p1: "1. cli\nDisable interrupts\n(IVT still real-mode handlers)" {
      style.fill: "#102010"
      style.stroke: "#33aa33"
      style.font-color: "#aaffaa"
      style.font: mono
    }
    p2: "2. lgdt [gdt_descriptor]\nLoad GDTR register\n(6-byte: 16-bit limit + 32-bit base)" {
      style.fill: "#102010"
      style.stroke: "#33aa33"
      style.font-color: "#aaffaa"
      style.font: mono
    }
    p3: "3. CR0.PE = 1\nEnable protection bit\n(selectors now = GDT indices)" {
      style.fill: "#183018"
      style.stroke: "#44cc44"
      style.font-color: "#ccffcc"
      style.font: mono
      style.bold: true
    }
    p1 -> p2: "step 1 to 2"
    p2 -> p3: "step 2 to 3"
  }

  fj_asm: "The Far Jump Instruction" {
    style: {
      fill: "#2a2a10"
      stroke: "#ddcc33"
      border-radius: 6
      font-color: "#ffffaa"
    }
    asm_detail: "jmp 0x08:protected_mode_label\n     ^^^^  ^^^^^^^^^^^^^^^^^^^^\n  selector   32-bit EIP offset\n  GDT[1]     code destination" {
      style.fill: "#1a1a08"
      style.stroke: "#bbaa22"
      style.font-color: "#ffff88"
      style.font: mono
    }
  }

  fj_effects: "What The Far Jump Does Atomically" {
    style: {
      fill: "#1a1a08"
      stroke: "#ccbb22"
      border-radius: 6
    }
    e1: "1. Loads CS = 0x08\n(selector, not a base address)" {
      style.fill: "#2a2a10"
      style.stroke: "#ddcc44"
      style.font-color: "#ffff99"
      style.font: mono
    }
    e2: "2. CPU looks up GDT[1]\n(bits[15:3] of 0x08 = index 1)" {
      style.fill: "#2a2a10"
      style.stroke: "#ddcc44"
      style.font-color: "#ffff99"
      style.font: mono
    }
    e3: "3. Flushes instruction pipeline\n(discards real-mode prefetched ops)\nMOST CRITICAL STEP" {
      style.fill: "#3a3a10"
      style.stroke: "#eecc33"
      style.font-color: "#ffffaa"
      style.font: mono
      style.bold: true
    }
    e4: "4. All future code fetches\ngo through GDT descriptor\n(base+EIP = physical addr)" {
      style.fill: "#2a2a10"
      style.stroke: "#ddcc44"
      style.font-color: "#ffff99"
      style.font: mono
    }
    e5: "5. CS.CPL = DPL of GDT[1] = 0\nRing 0 kernel code now active" {
      style.fill: "#3a3a10"
      style.stroke: "#eecc33"
      style.font-color: "#ffffaa"
      style.font: mono
      style.bold: true
    }
    e1 -> e2 -> e3 -> e4 -> e5
  }

  fj_danger: "Critical Timing Window" {
    style: {
      fill: "#2a1a00"
      stroke: "#ff9900"
      stroke-width: 2
      border-radius: 6
      font-color: "#ffcc66"
      bold: true
    }
    danger_text: "Between CR0.PE=1 and far jump:\nCPU is in protected mode\nbut CS still holds real-mode value.\nAny interrupt = TRIPLE FAULT.\ncli must be in effect!" {
      style.fill: "#1a0a00"
      style.stroke: "#cc7700"
      style.font-color: "#ffcc44"
      style.bold: true
    }
  }

  fj_prereqs -> fj_asm: "then execute"
  fj_asm -> fj_effects: "triggers these effects"
  fj_effects -> fj_danger: "danger window is\nbetween p3 and here"
}

prot_mode: "Protected Mode (32-bit — 1982)" {
  style: {
    fill: "#0d1f0d"
    stroke: "#44cc44"
    stroke-width: 3
    border-radius: 8
    font-color: "#ccffcc"
    bold: true
    font-size: 16
  }

  pm_label: "Hardware-Enforced — DPL vs CPL Checked on Every Segment Load" {
    style.fill: "#0a2a0a"
    style.stroke: "#44cc44"
    style.font-color: "#88ff88"
    style.border-radius: 4
    style.bold: true
  }

  pm_selector: "Segment Selector (16-bit — New Semantics)" {
    style: {
      fill: "#102010"
      stroke: "#33aa33"
      border-radius: 6
    }
    sel_layout: "Bits [15:3] = GDT Index  (0-8191)\nBit  [2]    = TI: 0=GDT, 1=LDT\nBits [1:0]  = RPL (Requested Privilege)\n              00=ring0  11=ring3\n\nKernel code: 0x08 = (index=1, TI=0, RPL=0)\nUser code:   0x1B = (index=3, TI=0, RPL=3)" {
      style.fill: "#0a2010"
      style.stroke: "#226622"
      style.font-color: "#88ff88"
      style.font: mono
    }
    sel_k: "CS = 0x08 (kernel code)\nIndex=1, GDT, RPL=0 (ring 0)" {
      style.fill: "#1a3a1a"
      style.stroke: "#44cc44"
      style.font-color: "#aaffaa"
      style.font: mono
    }
    sel_kd: "DS = 0x10 (kernel data)\nIndex=2, GDT, RPL=0 (ring 0)" {
      style.fill: "#1a3a1a"
      style.stroke: "#44cc44"
      style.font-color: "#aaffaa"
      style.font: mono
    }
    sel_u: "CS = 0x1B (user code)\nIndex=3, GDT, RPL=3 (ring 3)" {
      style.fill: "#0a2a3a"
      style.stroke: "#3388cc"
      style.font-color: "#aaccff"
      style.font: mono
    }
  }

  pm_gdt: "GDT — Global Descriptor Table" {
    style: {
      fill: "#0a1a0a"
      stroke: "#339933"
      border-radius: 6
    }
    gdt_header: "GDTR Register (6 bytes)\n16-bit limit + 32-bit base address" {
      style.fill: "#102a10"
      style.stroke: "#44bb44"
      style.font-color: "#aaffaa"
      style.font: mono
    }
    gdt_e0: "GDT[0] = NULL Descriptor\n(required — any use = GPF)" {
      style.fill: "#1a1a1a"
      style.stroke: "#555555"
      style.font-color: "#999999"
      style.font: mono
    }
    gdt_e1: "GDT[1] = Kernel Code Seg\nBase=0x00000000 Limit=0xFFFFF\nDPL=0  Access=0x9A (exec+read)" {
      style.fill: "#1a3a1a"
      style.stroke: "#44cc44"
      style.font-color: "#aaffaa"
      style.font: mono
      style.bold: true
    }
    gdt_e2: "GDT[2] = Kernel Data Seg\nBase=0x00000000 Limit=0xFFFFF\nDPL=0  Access=0x92 (read+write)" {
      style.fill: "#1a3a1a"
      style.stroke: "#44cc44"
      style.font-color: "#aaffaa"
      style.font: mono
    }
    gdt_e3: "GDT[3] = User Code Seg\nBase=0x00000000 Limit=0xFFFFF\nDPL=3  Access=0xFA (exec+read)" {
      style.fill: "#1a2a3a"
      style.stroke: "#4488cc"
      style.font-color: "#aaccff"
      style.font: mono
    }
    gdt_e4: "GDT[4] = User Data Seg\nBase=0x00000000 Limit=0xFFFFF\nDPL=3  Access=0xF2 (read+write)" {
      style.fill: "#1a2a3a"
      style.stroke: "#4488cc"
      style.font-color: "#aaccff"
      style.font: mono
    }
    gdt_header -> gdt_e0 -> gdt_e1 -> gdt_e2 -> gdt_e3 -> gdt_e4
  }

  pm_descriptor: "GDT Entry Binary Layout (8 bytes)" {
    style: {
      fill: "#081808"
      stroke: "#226622"
      border-radius: 6
      font-color: "#88ff88"
    }
    desc_bytes: "Byte7      Byte6       Byte5    Byte4    Bytes3-2    Bytes1-0\nBase       Flags+      Access   Base     Base        Limit\n[31:24]    Lim[19:16]  Byte     [23:16]  [23:0]      [15:0]" {
      style.fill: "#051005"
      style.stroke: "#1a4a1a"
      style.font-color: "#77dd77"
      style.font: mono
    }
    desc_access: "Access 0x9A (kernel code):\n  P=1 | DPL=00 (ring 0) | S=1 | Type=1010\n\nAccess 0xFA (user code):\n  P=1 | DPL=11 (ring 3) | S=1 | Type=1010\n\nFlags 0xCF: G=1 (4KB gran) DB=1 (32-bit)\nLimit 0xFFFFF x 4KB = 4GB flat segment" {
      style.fill: "#051005"
      style.stroke: "#1a4a1a"
      style.font-color: "#77dd77"
      style.font: mono
    }
    desc_bytes -> desc_access: "access byte decoding"
  }

  pm_translation: "Address Translation Steps" {
    style: {
      fill: "#0a1a0a"
      stroke: "#33aa33"
      border-radius: 6
    }
    step1: "CS holds selector 0x08\n(a GDT INDEX, not a base address)" {
      style.fill: "#1a3a1a"
      style.stroke: "#44cc44"
      style.font-color: "#aaffaa"
      style.font: mono
    }
    step2: "CPU reads GDT[1] from GDTR.base\nBase=0x00000000 Limit=0xFFFFF\nDPL=0, Present=1" {
      style.fill: "#0a2a0a"
      style.stroke: "#339933"
      style.font-color: "#99ff99"
      style.font: mono
    }
    step3: "Physical = GDT[1].Base + EIP\n= 0x00000000 + 0x00100000\n= 0x00100000 (kernel entry)" {
      style.fill: "#1a4a1a"
      style.stroke: "#55dd55"
      style.font-color: "#ccffcc"
      style.font: mono
      style.bold: true
    }
    step4: "CPU checks: CPL <= DPL?\nCS.CPL=0, GDT[1].DPL=0 -- ALLOWED" {
      style.fill: "#1a3a1a"
      style.stroke: "#44cc44"
      style.font-color: "#aaffaa"
      style.font: mono
    }
    step5: "Ring 3 tries CS=0x08?\nCPL=3 > DPL=0 -- GPF IMMEDIATELY" {
      style.fill: "#3a1a1a"
      style.stroke: "#cc4444"
      style.font-color: "#ffaaaa"
      style.font: mono
      style.bold: true
    }
    step1 -> step2: "index lookup via GDTR.base"
    step2 -> step3: "base + EIP = physical addr\n(flat model: base=0)"
    step3 -> step4: "enforce DPL vs CPL"
    step4 -> step5: "violation path leads to exception"
  }

  pm_protection: "Hardware Protection Rules" {
    style: {
      fill: "#051505"
      stroke: "#227722"
      border-radius: 6
    }
    prot_dpl: "DPL — Descriptor Privilege Level\nin GDT entry: who CAN use segment" {
      style.fill: "#102010"
      style.stroke: "#33aa33"
      style.font-color: "#aaffaa"
    }
    prot_cpl: "CPL — Current Privilege Level\nin CS bits[1:0]: who IS running" {
      style.fill: "#102010"
      style.stroke: "#33aa33"
      style.font-color: "#aaffaa"
    }
    prot_rpl: "RPL — Requested Privilege Level\nin selector bits[1:0]: requested ring" {
      style.fill: "#102010"
      style.stroke: "#33aa33"
      style.font-color: "#aaffaa"
    }
    prot_rule: "RULE: Access granted if\nCPL <= DPL  AND  RPL <= DPL\nChecked by CPU on EVERY segment load" {
      style.fill: "#1a4a1a"
      style.stroke: "#55cc55"
      style.font-color: "#ccffcc"
      style.bold: true
      style.border-radius: 6
    }
    prot_dpl -> prot_rule: "DPL from GDT entry"
    prot_cpl -> prot_rule: "CPL from CS register"
    prot_rpl -> prot_rule: "RPL from selector"
  }

  pm_limits: "Address Space Properties" {
    style: {
      fill: "#051505"
      stroke: "#226622"
      border-radius: 6
      font-color: "#88ff88"
    }
    plimit1: "Max: 4GB\n(32-bit flat model)\n4KB page granularity" {
      style.fill: "#0a2a0a"
      style.stroke: "#33aa33"
      style.font-color: "#aaffaa"
      style.font: mono
    }
    plimit2: "Protection: FULL\nDPL/CPL checked every segment load\nLimit checked every memory access" {
      style.fill: "#1a4a1a"
      style.stroke: "#44cc44"
      style.font-color: "#ccffcc"
      style.bold: true
    }
    plimit3: "Flat Model: All segs Base=0\nbut ring separation enforced\nby DPL in each descriptor" {
      style.fill: "#0a2a0a"
      style.stroke: "#33aa33"
      style.font-color: "#aaffaa"
      style.font: mono
    }
  }

  pm_selector -> pm_gdt: "selector is INDEX\nnot a base address"
  pm_gdt -> pm_descriptor: "each entry: 8 bytes\nspecific binary format"
  pm_descriptor -> pm_translation: "descriptor fields drive\naddress translation"
  pm_translation -> pm_protection: "DPL check integral\nto every translation"
  pm_protection -> pm_limits: "result: 4GB protected\naddress space"
}

real_mode -> far_jump: "cli + lgdt + CR0.PE=1\nthen jmp 0x08:label" {
  style: {
    stroke: "#ffdd44"
    stroke-width: 3
    font-color: "#ffdd44"
    bold: true
    animated: true
  }
  target-arrowhead.shape: arrow
}

far_jump -> prot_mode: "CS now holds GDT selector\nPipeline flushed\nProtected mode fully active" {
  style: {
    stroke: "#44ff44"
    stroke-width: 3
    font-color: "#44ff44"
    bold: true
    animated: true
  }
  target-arrowhead.shape: arrow
}

real_mode.rm_limits.limit2 -> prot_mode.pm_protection: "No protection HERE\nvs Full protection HERE" {
  style: {
    stroke: "#ffaa44"
    stroke-dash: 5
    font-color: "#ffaa44"
  }
}

real_mode.rm_limits.limit1 -> prot_mode.pm_limits.plimit1: "1MB max\nvs 4GB addressable" {
  style: {
    stroke: "#44aaff"
    stroke-dash: 5
    font-color: "#44aaff"
  }
}

legend: "Color Legend" {
  near: bottom-center
  style: {
    fill: "#111111"
    stroke: "#444444"
    border-radius: 6
    font-color: "#cccccc"
  }
  grid-columns: 4
  l_red: "Red = Real Mode / Danger" {
    style.fill: "#4a1515"
    style.stroke: "#e05252"
    style.font-color: "#ffaaaa"
  }
  l_yellow: "Yellow = Transition / Critical" {
    style.fill: "#2a2a10"
    style.stroke: "#ffdd44"
    style.font-color: "#ffff88"
  }
  l_green: "Green = Protected Mode / Safe" {
    style.fill: "#0a2a0a"
    style.stroke: "#44cc44"
    style.font-color: "#aaffaa"
  }
  l_blue: "Blue = User Mode / Ring 3" {
    style.fill: "#0a1a2a"
    style.stroke: "#4488cc"
    style.font-color: "#aaccff"
  }
}