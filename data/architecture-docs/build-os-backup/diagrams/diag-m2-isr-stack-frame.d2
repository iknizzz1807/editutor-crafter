vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |'md
  ## ISR Stack Frame: With and Without Error Code
'| {near: top-center}

left_side: "NO Error Code — Vectors 0,1,2,3,4,5,6,7,9,15-19" {
  style.fill: "#0f1a0f"
  style.stroke: "#2a5a2a"
  style.font-color: "#80ff80"
  style.border-radius: 6

  addr_high_l: "HIGH ADDRESS (before interrupt)" {
    style.fill: "#0a0a0a"
    style.stroke: "#333333"
    style.font-color: "#666666"
    style.font-size: 11
    style.italic: true
  }

  eflags_l: "ESP+16 -> EFLAGS  [CPU auto-push]" {
    style.fill: "#1a3a5c"
    style.stroke: "#4a90d9"
    style.font-color: "#a0d4ff"
    style.bold: true
  }

  eflags_l_note: "IF=1 was enabled; iret restores IF atomically re-enabling IRQs" {
    style.fill: "#0d1f30"
    style.stroke: "#2a5070"
    style.font-color: "#7ab0d9"
    style.font-size: 11
  }

  cs_l: "ESP+12 -> CS = 0x08  [CPU auto-push]" {
    style.fill: "#1a3a5c"
    style.stroke: "#4a90d9"
    style.font-color: "#a0d4ff"
    style.bold: true
  }

  cs_l_note: "kernel code seg ring 0; iret checks CPL change via CS.DPL" {
    style.fill: "#0d1f30"
    style.stroke: "#2a5070"
    style.font-color: "#7ab0d9"
    style.font-size: 11
  }

  eip_l: "ESP+8  -> EIP  [CPU auto-push]" {
    style.fill: "#1a3a5c"
    style.stroke: "#4a90d9"
    style.font-color: "#a0d4ff"
    style.bold: true
  }

  eip_l_note: "fault: faulting instr addr; trap/IRQ: next instr addr" {
    style.fill: "#0d1f30"
    style.stroke: "#2a5070"
    style.font-color: "#7ab0d9"
    style.font-size: 11
  }

  dummy_l: "ESP+4  -> 0x00000000  DUMMY error code  [software]" {
    style.fill: "#3a2a0a"
    style.stroke: "#c87a20"
    style.font-color: "#ffd080"
    style.bold: true
  }

  dummy_l_note: "ISR_NOERR macro: push dword 0; normalises stack to match error-code path" {
    style.fill: "#1e1500"
    style.stroke: "#604010"
    style.font-color: "#c09040"
    style.font-size: 11
  }

  vec_l: "ESP+0  -> vector number  [software push]" {
    style.fill: "#1a3a1a"
    style.stroke: "#4a9d4a"
    style.font-color: "#a0ffa0"
    style.bold: true
  }

  vec_l_note: "push dword N; passed to exception_handler as frame->vector" {
    style.fill: "#0d200d"
    style.stroke: "#2a5a2a"
    style.font-color: "#70c070"
    style.font-size: 11
  }

  div_l: "--- isr_common_stub entry: pusha ---" {
    style.fill: "#151515"
    style.stroke: "#444444"
    style.font-color: "#888888"
    style.font-size: 11
    style.italic: true
  }

  gpregs_l: "ESP-32 -> EAX ECX EDX EBX ESP EBP ESI EDI  [pusha]" {
    style.fill: "#1a3a1a"
    style.stroke: "#4a9d4a"
    style.font-color: "#a0ffa0"
    style.bold: true
  }

  gpregs_l_note: "8 x 4 = 32 bytes; popa on exit restores all 8 registers" {
    style.fill: "#0d200d"
    style.stroke: "#2a5a2a"
    style.font-color: "#70c070"
    style.font-size: 11
  }

  segregs_l: "ESP-48 -> GS FS ES DS  (4 x 4 bytes)  [software push]" {
    style.fill: "#1a3a1a"
    style.stroke: "#4a9d4a"
    style.font-color: "#a0ffa0"
    style.bold: true
  }

  segregs_l_note: "pushed individually after pusha; kernel sets DS/ES/FS/GS = 0x10" {
    style.fill: "#0d200d"
    style.stroke: "#2a5a2a"
    style.font-color: "#70c070"
    style.font-size: 11
  }

  esp_ptr_l: "ESP -> interrupt_frame_t* passed to C handler" {
    style.fill: "#2a1a3a"
    style.stroke: "#9a4ad9"
    style.font-color: "#d0a0ff"
    style.bold: true
  }

  addr_low_l: "LOW ADDRESS (stack grows down)" {
    style.fill: "#0a0a0a"
    style.stroke: "#333333"
    style.font-color: "#666666"
    style.font-size: 11
    style.italic: true
  }

  addr_high_l -> eflags_l: "higher addr"
  eflags_l -> eflags_l_note: "note"
  eflags_l -> cs_l: "-4 bytes (CPU push)"
  cs_l -> cs_l_note: "note"
  cs_l -> eip_l: "-4 bytes (CPU push)"
  eip_l -> eip_l_note: "note"
  eip_l -> dummy_l: "-4 bytes (software ISR_NOERR)"
  dummy_l -> dummy_l_note: "note"
  dummy_l -> vec_l: "-4 bytes (software push)"
  vec_l -> vec_l_note: "note"
  vec_l -> div_l: "enter common stub"
  div_l -> gpregs_l: "pusha: -32 bytes"
  gpregs_l -> gpregs_l_note: "note"
  gpregs_l -> segregs_l: "push gs/fs/es/ds: -16 bytes"
  segregs_l -> segregs_l_note: "note"
  segregs_l -> esp_ptr_l: "push esp (arg to C)"
  esp_ptr_l -> addr_low_l: "lowest addr"
}

right_side: "WITH Error Code — Vectors 8,10,11,12,13,14,17" {
  style.fill: "#1a0f0f"
  style.stroke: "#5a2a2a"
  style.font-color: "#ff8080"
  style.border-radius: 6

  addr_high_r: "HIGH ADDRESS (before interrupt)" {
    style.fill: "#0a0a0a"
    style.stroke: "#333333"
    style.font-color: "#666666"
    style.font-size: 11
    style.italic: true
  }

  eflags_r: "ESP+20 -> EFLAGS  [CPU auto-push]" {
    style.fill: "#1a3a5c"
    style.stroke: "#4a90d9"
    style.font-color: "#a0d4ff"
    style.bold: true
  }

  cs_r: "ESP+16 -> CS = 0x08  [CPU auto-push]" {
    style.fill: "#1a3a5c"
    style.stroke: "#4a90d9"
    style.font-color: "#a0d4ff"
    style.bold: true
  }

  eip_r: "ESP+12 -> EIP  [CPU auto-push]" {
    style.fill: "#1a3a5c"
    style.stroke: "#4a90d9"
    style.font-color: "#a0d4ff"
    style.bold: true
  }

  errcode_r: "ESP+8  -> ERROR CODE  [CPU auto-push!]" {
    style.fill: "#5c1a1a"
    style.stroke: "#d94a4a"
    style.font-color: "#ffa0a0"
    style.bold: true
  }

  errcode_r_note: "DF(8)=always 0; GPF(13)=selector; PF(14)=P/W/U bits; SF(12)=selector" {
    style.fill: "#300d0d"
    style.stroke: "#701a1a"
    style.font-color: "#c06060"
    style.font-size: 11
  }

  vec_r: "ESP+4  -> vector number  [software push]" {
    style.fill: "#1a3a1a"
    style.stroke: "#4a9d4a"
    style.font-color: "#a0ffa0"
    style.bold: true
  }

  vec_r_note: "ISR_ERR macro: push dword N ONLY — NO dummy 0; error code already on stack" {
    style.fill: "#0d200d"
    style.stroke: "#2a5a2a"
    style.font-color: "#70c070"
    style.font-size: 11
  }

  div_r: "--- isr_common_stub entry: pusha ---" {
    style.fill: "#151515"
    style.stroke: "#444444"
    style.font-color: "#888888"
    style.font-size: 11
    style.italic: true
  }

  gpregs_r: "ESP-28 -> EAX ECX EDX EBX ESP EBP ESI EDI  [pusha]" {
    style.fill: "#1a3a1a"
    style.stroke: "#4a9d4a"
    style.font-color: "#a0ffa0"
    style.bold: true
  }

  segregs_r: "ESP-44 -> GS FS ES DS  (4 x 4 bytes)  [software push]" {
    style.fill: "#1a3a1a"
    style.stroke: "#4a9d4a"
    style.font-color: "#a0ffa0"
    style.bold: true
  }

  esp_ptr_r: "ESP -> interrupt_frame_t* passed to C handler" {
    style.fill: "#2a1a3a"
    style.stroke: "#9a4ad9"
    style.font-color: "#d0a0ff"
    style.bold: true
  }

  addr_low_r: "LOW ADDRESS (stack grows down)" {
    style.fill: "#0a0a0a"
    style.stroke: "#333333"
    style.font-color: "#666666"
    style.font-size: 11
    style.italic: true
  }

  addr_high_r -> eflags_r: "higher addr"
  eflags_r -> cs_r: "-4 bytes (CPU push)"
  cs_r -> eip_r: "-4 bytes (CPU push)"
  eip_r -> errcode_r: "-4 bytes (CPU auto-push error code)"
  errcode_r -> errcode_r_note: "note"
  errcode_r -> vec_r: "-4 bytes (software push)"
  vec_r -> vec_r_note: "note"
  vec_r -> div_r: "enter common stub"
  div_r -> gpregs_r: "pusha: -32 bytes"
  gpregs_r -> segregs_r: "push gs/fs/es/ds: -16 bytes"
  segregs_r -> esp_ptr_r: "push esp (arg to C)"
  esp_ptr_r -> addr_low_r: "lowest addr"
}

ring3ext: "RING-3 EXTENSION: Extra CPU Pushes When User-Mode Code Is Interrupted" {
  style.fill: "#0f0f1a"
  style.stroke: "#3a3a6a"
  style.font-color: "#a0a0ff"
  style.border-radius: 6

  r3_note: "CPU switches to kernel stack via TSS.ESP0 THEN pushes two extra fields above EFLAGS" {
    style.fill: "#0a0a14"
    style.stroke: "#2a2a4a"
    style.font-color: "#8080c0"
    style.font-size: 12
  }

  r3_ss: "ESP+28 -> SS = 0x23  user-mode stack segment  [CPU auto-push]" {
    style.fill: "#1a3a5c"
    style.stroke: "#4a90d9"
    style.font-color: "#a0d4ff"
    style.bold: true
  }

  r3_ss_note: "user data selector index=4 RPL=3; iret restores to reload user stack segment" {
    style.fill: "#0d1f30"
    style.stroke: "#2a5070"
    style.font-color: "#7ab0d9"
    style.font-size: 11
  }

  r3_esp: "ESP+24 -> ESP  user-mode stack pointer  [CPU auto-push]" {
    style.fill: "#1a3a5c"
    style.stroke: "#4a90d9"
    style.font-color: "#a0d4ff"
    style.bold: true
  }

  r3_esp_note: "user ESP at interrupt time; absent for ring-0 interrupts; iret pops to switch back to user stack" {
    style.fill: "#0d1f30"
    style.stroke: "#2a5070"
    style.font-color: "#7ab0d9"
    style.font-size: 11
  }

  r3_cont: "... then EFLAGS CS EIP (+ error code if applicable) as normal ..." {
    style.fill: "#111111"
    style.stroke: "#333333"
    style.font-color: "#888888"
    style.font-size: 11
    style.italic: true
  }

  r3_iret: "iret detects ring change via CS.DPL > CPL; pops 5 fields instead of 3" {
    style.fill: "#14140a"
    style.stroke: "#3a3a14"
    style.font-color: "#a0a040"
    style.font-size: 12
    style.bold: true
  }

  r3_note -> r3_ss: "highest extra field"
  r3_ss -> r3_ss_note: "note"
  r3_ss -> r3_esp: "-4 bytes"
  r3_esp -> r3_esp_note: "note"
  r3_esp -> r3_cont: "then normal frame below"
  r3_cont -> r3_iret: "iret behaviour on return"
}

iret_seq: "iret Unwind Sequence" {
  style.fill: "#1a001a"
  style.stroke: "#8020a0"
  style.font-color: "#d060f0"
  style.border-radius: 6

  iret_r0: "Ring-0 interrupted: 3-field iret" {
    style.fill: "#2a1a3a"
    style.stroke: "#7030b0"
    style.font-color: "#c080e0"
    style.bold: true
  }

  iret_r0_1: "1. Pop EIP: resume address" {
    style.fill: "#1a0d25"
    style.stroke: "#501880"
    style.font-color: "#9060c0"
  }

  iret_r0_2: "2. Pop CS: checks DPL for ring change" {
    style.fill: "#1a0d25"
    style.stroke: "#501880"
    style.font-color: "#9060c0"
  }

  iret_r0_3: "3. Pop EFLAGS: atomically restores IF bit" {
    style.fill: "#1a0d25"
    style.stroke: "#501880"
    style.font-color: "#9060c0"
  }

  iret_atomic: "IF restoration atomic with EIP/CS — no IRQ window mid-iret" {
    style.fill: "#0d0a14"
    style.stroke: "#302050"
    style.font-color: "#7060a0"
    style.font-size: 11
    style.italic: true
  }

  iret_r3: "Ring-3 return: 5-field iret (CS.DPL=3 detected)" {
    style.fill: "#3a1a1a"
    style.stroke: "#b03030"
    style.font-color: "#e08080"
    style.bold: true
  }

  iret_r3_1: "1. Pop EIP: user-mode return address" {
    style.fill: "#200d0d"
    style.stroke: "#601818"
    style.font-color: "#c06060"
  }

  iret_r3_2: "2. Pop CS = 0x1B: ring change detected" {
    style.fill: "#200d0d"
    style.stroke: "#601818"
    style.font-color: "#c06060"
  }

  iret_r3_3: "3. Pop EFLAGS: user flags" {
    style.fill: "#200d0d"
    style.stroke: "#601818"
    style.font-color: "#c06060"
  }

  iret_r3_4: "4. Pop ESP: restore user-mode stack pointer" {
    style.fill: "#200d0d"
    style.stroke: "#601818"
    style.font-color: "#c06060"
  }

  iret_r3_5: "5. Pop SS = 0x23: user stack segment; CPU now in ring 3" {
    style.fill: "#200d0d"
    style.stroke: "#601818"
    style.font-color: "#c06060"
  }

  iret_r0 -> iret_r0_1: "step 1"
  iret_r0_1 -> iret_r0_2: "step 2"
  iret_r0_2 -> iret_r0_3: "step 3"
  iret_r0_3 -> iret_atomic: "atomicity"
  iret_r3 -> iret_r3_1: "step 1"
  iret_r3_1 -> iret_r3_2: "step 2"
  iret_r3_2 -> iret_r3_3: "step 3"
  iret_r3_3 -> iret_r3_4: "step 4"
  iret_r3_4 -> iret_r3_5: "step 5"
  iret_r0 -> iret_r3: "ring-3 return path"
}

bug: "THE STACK MISALIGNMENT BUG" {
  style.fill: "#2a0000"
  style.stroke: "#ff2020"
  style.font-color: "#ff6060"
  style.border-radius: 8

  bug_wrong: "BROKEN: single stub, no dummy push for no-error-code exceptions" {
    style.fill: "#1a0000"
    style.stroke: "#801010"
    style.font-color: "#ff4040"
    style.bold: true
  }

  bug_wrong_detail: "isr_bad: push dword 14 (vector only) / jmp common / common reads [esp+4] as error_code BUT that slot contains EIP / iret loads wrong address = TRIPLE FAULT, no message" {
    style.fill: "#150000"
    style.stroke: "#601010"
    style.font-color: "#c04040"
    style.font-size: 11
  }

  bug_fix: "CORRECT: ISR_NOERR macro normalises both paths" {
    style.fill: "#001a00"
    style.stroke: "#108010"
    style.font-color: "#40c040"
    style.bold: true
  }

  bug_fix_detail: "No-err path: cli; push dword 0; push dword N; jmp stub / Err path: cli; push dword N; jmp stub / Exit (same for both): popa; add esp,8 (pops BOTH vector AND error/dummy); iret" {
    style.fill: "#001500"
    style.stroke: "#106010"
    style.font-color: "#30a030"
    style.font-size: 11
  }

  bug_key: "KEY INVARIANT: add esp,8 always pops 8 bytes (vector + error/dummy). Both paths leave identical layout for iret." {
    style.fill: "#0a0a00"
    style.stroke: "#505000"
    style.font-color: "#c0c000"
    style.bold: true
  }

  bug_wrong -> bug_wrong_detail: "broken sequence"
  bug_wrong_detail -> bug_fix: "fix with"
  bug_fix -> bug_fix_detail: "correct sequence"
  bug_fix_detail -> bug_key: "invariant"
}

pf_decode: "Page Fault Error Code Decoder (Vector 14)" {
  style.fill: "#1a1000"
  style.stroke: "#6a4a00"
  style.font-color: "#ffc040"
  style.border-radius: 6

  pf_cr2: "CR2 = faulting virtual address — READ FIRST before any other operation" {
    style.fill: "#002a00"
    style.stroke: "#006000"
    style.font-color: "#40c040"
    style.bold: true
  }

  pf_bit0a: "Bit 0 (P)=0: page NOT present (PTE.P=0)" {
    style.fill: "#2a1a00"
    style.stroke: "#804000"
    style.font-color: "#e09030"
  }

  pf_bit0b: "Bit 0 (P)=1: protection violation (permissions wrong)" {
    style.fill: "#2a1a00"
    style.stroke: "#804000"
    style.font-color: "#e09030"
  }

  pf_bit1a: "Bit 1 (W)=0: fault on READ" {
    style.fill: "#1a1a2a"
    style.stroke: "#404080"
    style.font-color: "#8080d0"
  }

  pf_bit1b: "Bit 1 (W)=1: fault on WRITE" {
    style.fill: "#1a1a2a"
    style.stroke: "#404080"
    style.font-color: "#8080d0"
  }

  pf_bit2a: "Bit 2 (U)=0: fault in SUPERVISOR mode ring 0" {
    style.fill: "#1a001a"
    style.stroke: "#600060"
    style.font-color: "#c060c0"
  }

  pf_bit2b: "Bit 2 (U)=1: fault in USER mode ring 3 — security check!" {
    style.fill: "#1a001a"
    style.stroke: "#600060"
    style.font-color: "#c060c0"
  }

  pf_combos: "P=0,W=0,U=0: kernel read unmapped (null deref?) | P=0,W=1,U=0: kernel write unmapped | P=0,W=0,U=1: user segfault read | P=1,W=0,U=1: user read kernel page SECURITY | P=1,W=1,U=1: user write kernel page SECURITY | P=1,W=1,U=0: kernel write read-only (COW)" {
    style.fill: "#0d0800"
    style.stroke: "#402800"
    style.font-color: "#c09030"
    style.font-size: 11
  }

  pf_cr2 -> pf_bit0a: "P bit"
  pf_bit0a -> pf_bit0b: "or"
  pf_bit0b -> pf_bit1a: "W bit"
  pf_bit1a -> pf_bit1b: "or"
  pf_bit1b -> pf_bit2a: "U bit"
  pf_bit2a -> pf_bit2b: "or"
  pf_bit2b -> pf_combos: "combined meaning"
}

vec_table: "Exception Vector Reference" {
  style.fill: "#0a0f0f"
  style.stroke: "#1a4040"
  style.font-color: "#60d0d0"
  style.border-radius: 6

  no_err: "ISR_NOERR (push dummy 0): 0=Divide | 1=Debug | 2=NMI | 3=Breakpoint | 4=Overflow | 5=Bound | 6=InvalidOp | 7=DeviceNA | 9=CoprocSeg | 15-19=Reserved/FP/SIMD" {
    style.fill: "#051010"
    style.stroke: "#104040"
    style.font-color: "#40a0a0"
    style.font-size: 11
  }

  yes_err: "ISR_ERR (no dummy): 8=DoubleFault(errcode=0) | 10=InvalidTSS | 11=SegNotPresent | 12=StackSegFault | 13=GenProtFault | 14=PageFault(P/W/U) | 17=AlignCheck(errcode=0)" {
    style.fill: "#100505"
    style.stroke: "#401010"
    style.font-color: "#a04040"
    style.font-size: 11
    style.bold: true
  }

  irq_hw: "IRQ_STUB (vectors 32-47): NO error code; must send PIC EOI after handler; interrupt gate clears IF" {
    style.fill: "#050510"
    style.stroke: "#101040"
    style.font-color: "#5050a0"
    style.font-size: 11
  }

  syscall: "Vector 0x80 (INT 0x80): NO error code; DPL=3 trap gate (user-callable); IF remains set during syscall" {
    style.fill: "#051005"
    style.stroke: "#104010"
    style.font-color: "#509050"
    style.font-size: 11
  }

  no_err -> yes_err: "vs with CPU error code"
  yes_err -> irq_hw: "hardware IRQs"
  irq_hw -> syscall: "software interrupt"
}

left_side -> right: "dummy push normalises: both paths identical above add esp,8" {
  style.stroke: "#888800"
  style.stroke-dash: 4
  style.font-color: "#c0c000"
  style.bold: true
}

left_side -> ring3ext: "ring-3 interrupt: SS+ESP pushed above EFLAGS by CPU via TSS.ESP0" {
  style.stroke: "#4060c0"
  style.stroke-dash: 3
  style.font-color: "#8090e0"
}

right_side -> ring3ext: "error-code exceptions also gain SS+ESP when fired from ring 3" {
  style.stroke: "#4060c0"
  style.stroke-dash: 3
  style.font-color: "#8090e0"
}

left_side -> bug: "missing dummy push causes misalignment" {
  style.stroke: "#cc2020"
  style.font-color: "#ff4040"
  style.bold: true
}

right_side -> pf_decode: "vector 14: decode P/W/U bits + read CR2 immediately" {
  style.stroke: "#c06000"
  style.font-color: "#e08000"
}

left_side -> iret_seq: "iret pops CPU-pushed fields to resume" {
  style.stroke: "#8030a0"
  style.stroke-dash: 2
  style.font-color: "#b060d0"
}

right_side -> iret_seq: "add esp,8 removes errcode+vector; then same iret sequence" {
  style.stroke: "#8030a0"
  style.stroke-dash: 2
  style.font-color: "#b060d0"
}

ring3ext -> iret_seq: "5-field iret on ring-3 return" {
  style.stroke: "#b03030"
  style.font-color: "#d06060"
}

left_side -> vec_table: "use ISR_NOERR for these vectors" {
  style.stroke: "#208040"
  style.stroke-dash: 4
  style.font-color: "#50c070"
}

right_side -> vec_table: "use ISR_ERR for these vectors" {
  style.stroke: "#208040"
  style.stroke-dash: 4
  style.font-color: "#50c070"
}