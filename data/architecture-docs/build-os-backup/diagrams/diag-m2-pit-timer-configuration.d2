vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # PIT 8253/8254: Timer Channel 0 Configuration for 100Hz
| {near: top-center}

ioports: "PIT I/O Port Map" {
  style: {
    fill: "#0d1b2a"
    stroke: "#4a90d9"
    stroke-width: 2
    border-radius: 8
    bold: true
  }

  p40: "Port 0x40 — Channel 0 Data" {
    style: {
      fill: "#1a3a5c"
      stroke: "#4a90d9"
      border-radius: 4
      font-color: "#7ec8e3"
      bold: true
    }
  }

  p41: "Port 0x41 — Channel 1 (DRAM Refresh, legacy)" {
    style: {
      fill: "#2a2a2a"
      stroke: "#555"
      border-radius: 4
      font-color: "#888"
    }
  }

  p42: "Port 0x42 — Channel 2 (PC Speaker)" {
    style: {
      fill: "#2a2a2a"
      stroke: "#555"
      border-radius: 4
      font-color: "#888"
    }
  }

  p43: "Port 0x43 — Mode/Command Register (write-only)" {
    style: {
      fill: "#3a1a5c"
      stroke: "#9b59b6"
      border-radius: 4
      font-color: "#c39bd3"
      bold: true
    }
  }
}

cmdbyte: "Command Byte: 0x36 = 0011 0110b" {
  style: {
    fill: "#1a0a2e"
    stroke: "#9b59b6"
    stroke-width: 2
    border-radius: 8
    bold: true
  }

  bits76: "Bits [7:6] = 00 — Channel Select" {
    style: {
      fill: "#3a1a5c"
      stroke: "#9b59b6"
      border-radius: 4
      font-color: "#c39bd3"
    }
    label: "Bits [7:6] = 00 — Channel Select\n00=Ch0 (IRQ0)  01=Ch1  10=Ch2  11=Readback\nWe use 00 → Channel 0 (system timer)"
  }

  bits54: "Bits [5:4] = 11 — Access Mode" {
    style: {
      fill: "#3a1a5c"
      stroke: "#9b59b6"
      border-radius: 4
      font-color: "#c39bd3"
    }
    label: "Bits [5:4] = 11 — Access Mode\n00=Latch  01=Lo only  10=Hi only  11=Lo+Hi\nWe use 11 → write lo byte then hi byte to 0x40"
  }

  bits31: "Bits [3:1] = 010 — Operating Mode" {
    style: {
      fill: "#1a3a1a"
      stroke: "#27ae60"
      border-radius: 4
      font-color: "#82e0aa"
    }
    label: "Bits [3:1] = 010 — Operating Mode 2: Rate Generator\n000=OneShot  001=HWOneShot  010=RateGen  011=SquareWave\nMode 2: counter reloads automatically; IRQ0 fires reliably every N clocks"
  }

  bit0: "Bit [0] = 0 — Binary Counting" {
    style: {
      fill: "#3a1a5c"
      stroke: "#9b59b6"
      border-radius: 4
      font-color: "#c39bd3"
    }
    label: "Bit [0] = 0 — Number Format\n0=Binary (0-65535)  1=BCD (0-9999)\nWe use 0 → standard 16-bit binary divisor"
  }

  summary: "0x36 = Ch0 | Lo+Hi | RateGen | Binary" {
    style: {
      fill: "#4a0080"
      stroke: "#c39bd3"
      stroke-width: 2
      border-radius: 4
      font-color: "#e8daef"
      bold: true
    }
    label: "Bit:  7   6 | 5   4 | 3   2   1 | 0\nVal:  0   0 | 1   1 | 0   1   1 | 0\n      CH=00  ACC=11  MODE=010   BIN=0\nOUT 0x43, 0x36  →  arms Channel 0 for divisor load"
  }
}

freqcalc: "Divisor Calculation: 1193182 Hz / 100 Hz" {
  style: {
    fill: "#1a1500"
    stroke: "#f39c12"
    stroke-width: 2
    border-radius: 8
    bold: true
  }

  basefreq: "PIT Base Clock: 1,193,182 Hz" {
    style: {
      fill: "#3a2800"
      stroke: "#f39c12"
      border-radius: 4
      font-color: "#f8c471"
    }
    label: "PIT Base Clock: 1,193,182 Hz\nOrigin: NTSC color burst 3,579,545 Hz / 3\nAlso: 14.318 MHz / 12\nHardware constant — cannot change in software"
  }

  formula: "divisor = 1193182 / 100 = 11931" {
    style: {
      fill: "#3a2800"
      stroke: "#f39c12"
      border-radius: 4
      font-color: "#f8c471"
    }
    label: "IRQ0_freq = PIT_BASE_HZ / divisor\ndivisor = 1,193,182 / 100 = 11,931.82\nRound to 11,931 = 0x2E9B  (error < 0.01%)\nActual rate: 1,193,182 / 11,931 = 99.99 Hz"
  }

  splitbytes: "0x2E9B → Lo: 0x9B  Hi: 0x2E" {
    style: {
      fill: "#3a2800"
      stroke: "#e67e22"
      border-radius: 4
      font-color: "#fad7a0"
    }
    label: "11,931 = 0x2E9B\n0x2E9B binary: 0010 1110  1001 1011\n               Lo Hi--->  Lo byte--->\nLo byte: 11931 AND 0xFF  = 0x9B = 155\nHi byte: 11931 >> 8      = 0x2E = 46\nWrite lo first, then hi to port 0x40"
  }

  freqtable: "Common Divisor Reference Table" {
    style: {
      fill: "#2a1800"
      stroke: "#d35400"
      border-radius: 4
      font-color: "#fad7a0"
    }
    label: "18 Hz  → divisor 65535  period 54.9ms\n50 Hz  → divisor 23864  period 20.0ms\n100 Hz → divisor 11931  period 10.0ms  ← our choice\n250 Hz → divisor  4773  period  4.0ms\n1000Hz → divisor  1193  period  1.0ms"
  }
}

progseq: "Programming Sequence: 3 outb Calls" {
  style: {
    fill: "#001a00"
    stroke: "#27ae60"
    stroke-width: 2
    border-radius: 8
    bold: true
  }

  step1: "Step 1: outb(0x43, 0x36) — Command Byte" {
    style: {
      fill: "#003300"
      stroke: "#27ae60"
      stroke-width: 2
      border-radius: 4
      font-color: "#82e0aa"
      bold: true
    }
    label: "outb(0x43, 0x36);\nPort 0x43 = Mode/Command Register\nValue 0x36: Ch0, Lo+Hi access, Mode2 RateGen, Binary\nEffect: PIT enters awaiting-divisor state for Ch0\nLatency: 1-4 us (legacy ISA I/O port stall)"
  }

  step2: "Step 2: outb(0x40, 0x9B) — Divisor Low Byte" {
    style: {
      fill: "#003300"
      stroke: "#27ae60"
      stroke-width: 2
      border-radius: 4
      font-color: "#82e0aa"
      bold: true
    }
    label: "outb(0x40, 0x9B);  // 11931 & 0xFF = 0x9B\nPort 0x40 = Channel 0 Data\nValue 0x9B = 155 decimal (low 8 bits of 11931)\nPIT stores low byte in internal latch\nCounter NOT reloaded yet — awaiting hi byte\nLatency: 1-4 us"
  }

  step3: "Step 3: outb(0x40, 0x2E) — Divisor High Byte" {
    style: {
      fill: "#003300"
      stroke: "#2ecc71"
      stroke-width: 3
      border-radius: 4
      font-color: "#a9dfbf"
      bold: true
    }
    label: "outb(0x40, 0x2E);  // (11931 >> 8) & 0xFF = 0x2E\nPort 0x40 = Channel 0 Data\nValue 0x2E = 46 decimal (high 8 bits of 11931)\nPIT NOW LOADS COUNTER = 11931\nCountdown begins: 11931 -> 1 -> IRQ0 fires -> reload\nLatency: 1-4 us  |  Total setup: ~5-15 us"
  }

  cimpl: "C Implementation" {
    style: {
      fill: "#001a00"
      stroke: "#1e8449"
      border-radius: 4
      font-color: "#a9dfbf"
    }
    label: "void pit_set_frequency(uint32_t hz) {\n    uint32_t divisor = 1193182 / hz;\n    if (divisor > 0xFFFF) divisor = 0xFFFF;\n    if (divisor < 1)      divisor = 1;\n    outb(0x43, 0x36);                    // Step 1\n    outb(0x40, divisor & 0xFF);          // Step 2\n    outb(0x40, (divisor >> 8) & 0xFF);   // Step 3\n}"
  }
}

runtime: "PIT Runtime: Counter Cycle and IRQ0 Generation" {
  style: {
    fill: "#1a0000"
    stroke: "#e74c3c"
    stroke-width: 2
    border-radius: 8
    bold: true
  }

  counter_states: "Counter State Machine (Mode 2)" {
    style: {
      fill: "#2a0000"
      stroke: "#e74c3c"
      border-radius: 4
      font-color: "#f1948a"
    }
    label: "After divisor loaded (11931):\nClock:   0      1      2    ...  11929  11930  11931\nCounter: 11931  11930  11929 ...    2      1      0\nOUT pin: HIGH   HIGH   HIGH  ...  HIGH   LOW*  RELOAD\n\n*At count=1: OUT pin goes LOW (IRQ0 asserted to PIC)\n*At count=0: Counter reloads with 11931, OUT goes HIGH\n\nPeriod = 11931 / 1193182 = 0.010001 s = 10.001 ms\nFrequency = 99.99 Hz ≈ 100 Hz"
  }

  irq_chain: "IRQ0 -> PIC -> CPU -> Handler Chain" {
    style: {
      fill: "#2a0000"
      stroke: "#c0392b"
      border-radius: 4
      font-color: "#f1948a"
    }
    label: "Every ~10ms (100 Hz):\n1. PIT OUT0 goes LOW  → asserts IRQ0 on master PIC\n2. Master PIC checks IMR bit 0 (unmasked=0 required)\n   → raises INTR to CPU\n3. CPU finishes current instruction, checks IF=1\n   → accepts interrupt\n4. CPU sends INTA → PIC returns vector 32\n   (after pic_remap(0x20, 0x28))\n5. CPU indexes IDT[32] → jumps to irq0 stub\n6. irq_common_stub: pusha, load DS=0x10, call irq_dispatcher\n7. timer_handler(): pit_tick_count++; sched_tick();\n8. pic_send_eoi(): outb(0x20, 0x20) clears IRQ0 ISR bit\n9. iret: restores EFLAGS/CS/EIP → process resumes"
  }

  tick_counter: "Tick Counter: volatile uint64_t pit_tick_count" {
    style: {
      fill: "#2a0000"
      stroke: "#e74c3c"
      border-radius: 4
      font-color: "#f1948a"
    }
    label: "volatile uint64_t pit_tick_count = 0;\nvoid timer_handler(interrupt_frame_t *frame) {\n    pit_tick_count++;   // increments every 10ms\n    sched_tick();       // drives preemptive scheduler\n}\nvolatile required: modified by IRQ handler,\nread by polling code — compiler must not cache.\nAfter 1s: ~100   After 1min: ~6000   After 1hr: ~360000\n64-bit overflow after ~5.8 billion years"
  }

  timing_signal: "Signal Timing Diagram (Mode 2)" {
    style: {
      fill: "#1a0000"
      stroke: "#c0392b"
      border-radius: 4
      font-color: "#f5b7b1"
    }
    label: "CLK:  _|~|_|~|_|~| ... |~|_|~|_|~|_\nCNT:  N  N-1  N-2  ...  2   1  [N]\nOUT:  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|_|~~~\nIRQ0: ___________________________________|~|___\n\nOUT LOW pulse = 1 PIT clock = 838 nanoseconds\nPIC latches the LOW transition as IRQ0 assertion\nCounter immediately reloads N after reaching zero"
  }
}

overhead: "Timer Overhead Analysis at 100Hz" {
  style: {
    fill: "#001515"
    stroke: "#1abc9c"
    stroke-width: 2
    border-radius: 8
    bold: true
  }

  latency_breakdown: "Interrupt Latency Breakdown" {
    style: {
      fill: "#003333"
      stroke: "#1abc9c"
      border-radius: 4
      font-color: "#76d7c4"
    }
    label: "From IRQ0 assertion to first handler instruction:\nPIC arbitration:            ~5 cycles    ~2.5 ns\nCPU instruction completion:  1-50 cycles  0.5-25 ns\nTSS.ESP0 read (DRAM cold):  ~100 cycles  ~50 ns\nPush 5-value irq frame:      ~15 cycles  ~7.5 ns\nIDT lookup (L2 cache hit):   ~10 cycles  ~5 ns\nPipeline flush + branch:     ~15 cycles  ~7.5 ns\nTotal interrupt latency:    ~150 cycles  ~75 ns\n\nHandler overhead (no context switch):\npusha (8 GPRs):              ~8 cycles\n4 segment saves:             ~12 cycles\nsched_tick() body:           ~20 cycles\npic_send_eoi() outb stall:  ~100 cycles\npopa + iret:                 ~20 cycles\nTotal handler:              ~160 cycles  ~80 ns"
  }

  cpu_budget: "CPU Budget at 100Hz on 2GHz CPU" {
    style: {
      fill: "#003333"
      stroke: "#16a085"
      border-radius: 4
      font-color: "#76d7c4"
    }
    label: "Period between IRQs: 10ms = 20,000,000 cycles at 2GHz\n\nNo context switch:  160 cycles / 20M = 0.0008% overhead\nWith ctx switch:    660 cycles / 20M = 0.0033% overhead\n\nAt  100 Hz: 0.003% overhead  <- our choice (optimal)\nAt 1000 Hz: 0.033% overhead  <- still acceptable\nAt 10000Hz: 0.330% overhead  <- noticeable\n\n100Hz = 10ms granularity: responsive + low overhead"
  }
}

hardware: "PIT 8254 Internal Architecture" {
  style: {
    fill: "#0d0d1a"
    stroke: "#5b2d8e"
    stroke-width: 2
    border-radius: 8
    bold: true
  }

  chip_block: "8254 Chip Block Diagram" {
    style: {
      fill: "#1a0a2e"
      stroke: "#5b2d8e"
      border-radius: 4
      font-color: "#c39bd3"
    }
    label: "CLK 1.193MHz -> [Ch0 Counter 16-bit] -> OUT0 -> IRQ0\n               [Ch1 Counter 16-bit] -> OUT1 -> DRAM\n               [Ch2 Counter 16-bit] -> OUT2 -> Speaker\n\nEach channel: 16-bit Count Register + Output Latch\nD[7:0] <-> Data Bus Buffer\nA[1:0] -> Read/Write Logic  (00=Ch0 01=Ch1 10=Ch2 11=Cmd)\nCS, RD, WR -> Control Logic\n\n8253: 3 channels, no readback command\n8254: 3 channels + readback command (bits 7:6 = 11)"
  }
}

ioports.p43 -> cmdbyte.summary: "outb(0x43, 0x36)\nprograms Channel 0\nfor rate generator mode" {
  style: {
    stroke: "#9b59b6"
    stroke-width: 2
    animated: true
    font-color: "#c39bd3"
  }
}

cmdbyte.bits76 -> cmdbyte.bits54: "bits 7:6 resolved" {
  style: { stroke: "#9b59b6"; stroke-dash: 3 }
}
cmdbyte.bits54 -> cmdbyte.bits31: "bits 5:4 resolved" {
  style: { stroke: "#9b59b6"; stroke-dash: 3 }
}
cmdbyte.bits31 -> cmdbyte.bit0: "bits 3:1 resolved" {
  style: { stroke: "#27ae60"; stroke-dash: 3 }
}
cmdbyte.bit0 -> cmdbyte.summary: "all bits combined" {
  style: { stroke: "#9b59b6"; stroke-dash: 3 }
}

cmdbyte.summary -> progseq.step1: "0x36 encodes\nchannel + mode + format" {
  style: {
    stroke: "#27ae60"
    stroke-width: 2
    font-color: "#82e0aa"
  }
}

freqcalc.basefreq -> freqcalc.formula: "1193182 Hz base\ndivide by target Hz" {
  style: { stroke: "#f39c12"; stroke-width: 2; font-color: "#f8c471" }
}

freqcalc.formula -> freqcalc.splitbytes: "11931 = 0x2E9B\nsplit into lo+hi bytes" {
  style: { stroke: "#e67e22"; stroke-width: 2; font-color: "#fad7a0" }
}

freqcalc.splitbytes -> progseq.step2: "Lo byte 0x9B\noutb(0x40, 0x9B)" {
  style: { stroke: "#f39c12"; stroke-width: 2; font-color: "#f8c471" }
}

freqcalc.splitbytes -> progseq.step3: "Hi byte 0x2E\noutb(0x40, 0x2E)" {
  style: { stroke: "#e67e22"; stroke-width: 2; font-color: "#fad7a0" }
}

ioports.p40 -> progseq.step2: "Write destination:\nChannel 0 data port" {
  style: { stroke: "#4a90d9"; stroke-width: 1; stroke-dash: 4; font-color: "#7ec8e3" }
}

progseq.step1 -> progseq.step2: "Port 0x43 write complete\nPIT awaits lo byte at 0x40" {
  style: { stroke: "#27ae60"; stroke-width: 2; font-color: "#a9dfbf" }
}

progseq.step2 -> progseq.step3: "Lo byte latched internally\nPIT awaits hi byte" {
  style: { stroke: "#27ae60"; stroke-width: 2; font-color: "#a9dfbf" }
}

progseq.step3 -> runtime.counter_states: "Both bytes received\nCounter loads 11931\ncountdown begins" {
  style: { stroke: "#e74c3c"; stroke-width: 2; animated: true; font-color: "#f1948a" }
}

progseq.step3 -> progseq.cimpl: "encapsulated in\npit_set_frequency()" {
  style: { stroke: "#1e8449"; stroke-width: 1; stroke-dash: 3; font-color: "#a9dfbf" }
}

runtime.counter_states -> runtime.irq_chain: "counter reaches 1\nOUT goes LOW\nIRQ0 asserted" {
  style: { stroke: "#e74c3c"; stroke-width: 2; animated: true; font-color: "#f1948a" }
}

runtime.irq_chain -> runtime.tick_counter: "handler called\npит_tick_count++\nsched_tick()" {
  style: { stroke: "#c0392b"; stroke-width: 2; font-color: "#f1948a" }
}

runtime.irq_chain -> overhead.latency_breakdown: "IRQ0 fires every 10ms\nlatency breakdown" {
  style: { stroke: "#1abc9c"; stroke-width: 2; font-color: "#76d7c4" }
}

runtime.tick_counter -> overhead.cpu_budget: "100 increments/second\nCPU budget analysis" {
  style: { stroke: "#1abc9c"; stroke-width: 1; stroke-dash: 3; font-color: "#76d7c4" }
}

hardware.chip_block -> runtime.counter_states: "physical counter\ndecrement mechanism" {
  style: { stroke: "#5b2d8e"; stroke-width: 1; stroke-dash: 3; font-color: "#c39bd3" }
}

runtime.counter_states -> runtime.timing_signal: "Mode 2 waveform\ndetailed view" {
  style: { stroke: "#c0392b"; stroke-width: 1; stroke-dash: 3; font-color: "#f5b7b1" }
}