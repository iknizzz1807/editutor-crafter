vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: down

title: |md
  # Kernel Heap: kmalloc Virtual Address Space Layout
  Virtual Range: 0xD0000000 - 0xDFFFFFFF (256MB heap space)
| {near: top-center}

legend: {
  near: bottom-right
  style.fill: "#1a1a2e"
  style.stroke: "#4a4a6a"
  style.border-radius: 8
  l: |md
    **Color Semantics**

    Green = allocated block

    Blue = free block

    Purple = block header metadata

    Red = fragmentation danger

    Orange = heap expansion
  |
}

vas: "Virtual Address Space" {
  style.fill: "#0d1117"
  style.stroke: "#30363d"
  style.border-radius: 6

  heap_start_label: "0xD0000000 HEAP_START" {
    style.fill: "#1f6feb"
    style.stroke: "#388bfd"
    style.font-color: white
    style.border-radius: 4
    style.bold: true
  }

  page0: "Page 0 [0xD0000000-0xD0000FFF] 4096 bytes -> phys 0x00301000" {
    style.fill: "#0d1117"
    style.stroke: "#388bfd"
    style.border-radius: 4

    b0: "Block A: ALLOCATED kmalloc(64)" {
      style.fill: "#1a4731"
      style.stroke: "#2ea043"
      style.border-radius: 4

      b0_hdr: "Header [20 bytes]" {
        style.fill: "#6e40c9"
        style.stroke: "#8957e5"
        style.font-color: white
        style.border-radius: 3
      }
      b0_data: "User Data [64 bytes] ptr=0xD0000014" {
        style.fill: "#1a4731"
        style.stroke: "#2ea043"
        style.font-color: "#56d364"
      }
      b0_hdr -> b0_data: "offset +20" {
        style.stroke: "#2ea043"
        style.font-size: 11
      }
    }

    b1: "Block B: FREE [128 bytes available]" {
      style.fill: "#0d2235"
      style.stroke: "#1f6feb"
      style.border-radius: 4

      b1_hdr: "Header [20 bytes]" {
        style.fill: "#6e40c9"
        style.stroke: "#8957e5"
        style.font-color: white
        style.border-radius: 3
      }
      b1_free_space: "Free Space [128 bytes] search_hint target" {
        style.fill: "#0d2235"
        style.stroke: "#1f6feb"
        style.font-color: "#79c0ff"
      }
      b1_hdr -> b1_free_space: "offset +20" {
        style.stroke: "#1f6feb"
        style.font-size: 11
      }
    }

    b2: "Block C: ALLOCATED kmalloc(200)" {
      style.fill: "#1a4731"
      style.stroke: "#2ea043"
      style.border-radius: 4

      b2_hdr: "Header [20 bytes]" {
        style.fill: "#6e40c9"
        style.stroke: "#8957e5"
        style.font-color: white
        style.border-radius: 3
      }
      b2_data: "User Data [200 bytes] ptr=0xD00000F8" {
        style.fill: "#1a4731"
        style.stroke: "#2ea043"
        style.font-color: "#56d364"
      }
      b2_hdr -> b2_data: "offset +20" {
        style.stroke: "#2ea043"
        style.font-size: 11
      }
    }

    b3: "Block D: FREE [3636 bytes remainder of page 0]" {
      style.fill: "#0d2235"
      style.stroke: "#1f6feb"
      style.border-radius: 4

      b3_hdr: "Header [20 bytes]" {
        style.fill: "#6e40c9"
        style.stroke: "#8957e5"
        style.font-color: white
        style.border-radius: 3
      }
      b3_large_free: "Large Free [3636 bytes] 0xD00001CC to 0xD0000FFF" {
        style.fill: "#0d2235"
        style.stroke: "#1f6feb"
        style.font-color: "#79c0ff"
      }
      b3_hdr -> b3_large_free: "offset +20" {
        style.stroke: "#1f6feb"
        style.font-size: 11
      }
    }
  }

  unmapped: "Page 1+ [0xD0001000-0xDFFFFFFF] NOT MAPPED: access triggers page fault 14" {
    style.fill: "#1c1c1c"
    style.stroke: "#444"
    style.stroke-dash: 5
    style.font-color: "#6e7681"
    style.border-radius: 4
  }

  heap_end_label: "0xDFFFFFFF HEAP_MAX hard limit" {
    style.fill: "#b91c1c"
    style.stroke: "#ef4444"
    style.font-color: white
    style.border-radius: 4
    style.bold: true
  }
}

header_anatomy: "heap_block_t Header: 20-byte Anatomy" {
  style.fill: "#161b22"
  style.stroke: "#8957e5"
  style.border-radius: 6
  style.bold: true

  field_magic: "offset 0-3: magic uint32_t = 0xDEADBEEF (canary detects corruption)" {
    style.fill: "#3d1a6e"
    style.stroke: "#8957e5"
    style.font-color: "#e2c5ff"
  }

  field_size: "offset 4-7: size uint32_t (usable bytes, excludes header)" {
    style.fill: "#3d1a6e"
    style.stroke: "#8957e5"
    style.font-color: "#e2c5ff"
  }

  field_free: "offset 8: free uint8_t [1=FREE, 0=ALLOC] + 3 bytes padding" {
    style.fill: "#3d1a6e"
    style.stroke: "#8957e5"
    style.font-color: "#e2c5ff"
  }

  field_next: "offset 12-15: next ptr forward link (NULL = end of heap)" {
    style.fill: "#3d1a6e"
    style.stroke: "#8957e5"
    style.font-color: "#e2c5ff"
  }

  field_prev: "offset 16-19: prev ptr backward link (enables O(1) coalescing)" {
    style.fill: "#3d1a6e"
    style.stroke: "#8957e5"
    style.font-color: "#e2c5ff"
  }

  overhead_note: "Overhead Analysis" {
    style.fill: "#4a1942"
    style.stroke: "#f85149"
    style.font-color: "#ffa198"

    overhead_detail: |md
      kmalloc(4) uses 24 bytes -> 500% overhead

      kmalloc(64) uses 84 bytes -> 31% overhead

      kmalloc(4096) uses 4116 bytes -> 0.5% overhead

      Fix: size-class slabs eliminate per-obj headers
    |
  }
}

split_op: "kmalloc SPLIT Operation: Before and After" {
  style.fill: "#0d1117"
  style.stroke: "#e3b341"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true

  split_before: "BEFORE: one free block [148 bytes usable]" {
    style.fill: "#0d1117"
    style.stroke: "#444"
    style.border-radius: 4

    sb_hdr: "Header: magic=OK size=148 free=1" {
      style.fill: "#6e40c9"
      style.stroke: "#8957e5"
      style.font-color: white
    }
    sb_free: "148 bytes free space" {
      style.fill: "#0d2235"
      style.stroke: "#1f6feb"
      style.font-color: "#79c0ff"
    }
    sb_hdr -> sb_free: "+20 bytes" {
      style.stroke: "#1f6feb"
      style.font-size: 11
    }
  }

  split_condition: "kmalloc(32): split because 148 >= 32 + 20 + 8 = 60" {
    style.fill: "#2d2d00"
    style.stroke: "#e3b341"
    style.font-color: "#e3b341"
    style.border-radius: 4
    style.bold: true
  }

  split_after: "AFTER: allocated 32 + free 96" {
    style.fill: "#0d1117"
    style.stroke: "#444"
    style.border-radius: 4

    sa_alloc: "New allocated block [32 bytes]" {
      style.fill: "#1a4731"
      style.stroke: "#2ea043"
      style.border-radius: 4

      sa_alloc_hdr: "Header: size=32 free=0 next->new_free" {
        style.fill: "#6e40c9"
        style.stroke: "#8957e5"
        style.font-color: white
      }
      sa_alloc_data: "32 bytes user data (returned ptr = header+20)" {
        style.fill: "#1a4731"
        style.stroke: "#2ea043"
        style.font-color: "#56d364"
      }
      sa_alloc_hdr -> sa_alloc_data: "+20" {
        style.stroke: "#2ea043"
        style.font-size: 11
      }
    }

    sa_free: "Remainder free block [96 bytes usable]" {
      style.fill: "#0d2235"
      style.stroke: "#1f6feb"
      style.border-radius: 4

      sa_free_hdr: "Header: size=96 free=1 (freshly written)" {
        style.fill: "#6e40c9"
        style.stroke: "#8957e5"
        style.font-color: white
      }
      sa_free_space: "96 bytes free (= 148 - 32 - 20)" {
        style.fill: "#0d2235"
        style.stroke: "#1f6feb"
        style.font-color: "#79c0ff"
      }
      sa_free_hdr -> sa_free_space: "+20" {
        style.stroke: "#1f6feb"
        style.font-size: 11
      }
    }

    int_frag_note: "Internal Fragmentation" {
      style.fill: "#2d1b00"
      style.stroke: "#f0883e"
      style.font-color: "#f0883e"

      int_frag_detail: |md
        kmalloc(33) rounds up to 40, wastes 7 bytes

        Internal frag = allocated_size - requested_size

        Mitigated by 8-byte alignment rounding in kmalloc
      |
    }
  }

  split_before -> split_condition: "kmalloc(32) triggers scan" {
    style.stroke: "#e3b341"
    style.stroke-width: 2
    style.font-color: "#e3b341"
    style.animated: true
  }

  split_condition -> split_after: "split: alloc block + remainder block" {
    style.stroke: "#e3b341"
    style.stroke-width: 2
    style.font-color: "#e3b341"
    style.animated: true
  }
}

coalesce_op: "kfree COALESCE Operation: Before and After" {
  style.fill: "#0d1117"
  style.stroke: "#3fb950"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true

  coalesce_before: "BEFORE kfree(ptr_B): three adjacent blocks" {
    style.fill: "#0d1117"
    style.stroke: "#444"
    style.border-radius: 4

    cb_a: "Block A: FREE [96 bytes] prev=BlockC next=BlockB" {
      style.fill: "#0d2235"
      style.stroke: "#1f6feb"
      style.font-color: "#79c0ff"
    }
    cb_b: "Block B: ALLOCATED [64 bytes] ptr_B points here" {
      style.fill: "#1a4731"
      style.stroke: "#2ea043"
      style.font-color: "#56d364"
    }
    cb_c: "Block C: FREE [200 bytes] prev=BlockB next=NULL" {
      style.fill: "#0d2235"
      style.stroke: "#1f6feb"
      style.font-color: "#79c0ff"
    }
    ext_frag_warn: "External Fragmentation Warning" {
      style.fill: "#3d1a1a"
      style.stroke: "#f85149"
      style.font-color: "#ffa198"

      ext_frag_detail: |md
        96 + 200 = 296 bytes free BUT split across 2 blocks

        kmalloc(250) FAILS even though total free >= 250

        External fragmentation: contiguous space unavailable
      |
    }
  }

  coalesce_steps: "kfree Execution Steps" {
    style.fill: "#0d1117"
    style.stroke: "#444"
    style.border-radius: 4

    step1: "Step 1: Validate header magic and free flag" {
      style.fill: "#2d2500"
      style.stroke: "#e3b341"
      style.font-color: "#e3b341"
    }
    step2: "Step 2: block->free = 1 (mark as free)" {
      style.fill: "#0d2235"
      style.stroke: "#1f6feb"
      style.font-color: "#79c0ff"
    }
    step3: "Step 3: Coalesce NEXT if Block C is free" {
      style.fill: "#143020"
      style.stroke: "#2ea043"

      step3_detail: |md
        block->size += sizeof(header) + next->size

        = 64 + 20 + 200 = 284

        block->next = block->next->next (NULL)
      |
    }
    step4: "Step 4: Coalesce PREV if Block A is free" {
      style.fill: "#143020"
      style.stroke: "#2ea043"

      step4_detail: |md
        prev->size += sizeof(header) + block->size

        = 96 + 20 + 284 = 400

        prev->next = block->next (NULL)
      |
    }
    step5: "Step 5: Update search_hint to freed addr if earlier" {
      style.fill: "#2d2500"
      style.stroke: "#e3b341"
      style.font-color: "#e3b341"
    }

    step1 -> step2: "header valid" { style.stroke: "#e3b341" }
    step2 -> step3: "marked free" { style.stroke: "#2ea043" }
    step3 -> step4: "next coalesced" { style.stroke: "#2ea043" }
    step4 -> step5: "prev coalesced" { style.stroke: "#2ea043" }
  }

  coalesce_after: "AFTER kfree(ptr_B): one large free block" {
    style.fill: "#0d1117"
    style.stroke: "#444"
    style.border-radius: 4

    ca_merged: "Block A+B+C MERGED: FREE [400 bytes usable]" {
      style.fill: "#0d2235"
      style.stroke: "#1f6feb"
      style.border-radius: 4

      ca_merged_hdr: "Header: size=400 free=1 (Block A is merged root)" {
        style.fill: "#6e40c9"
        style.stroke: "#8957e5"
        style.font-color: white
      }
      ca_merged_space: "400 bytes contiguous free: kmalloc(250) now SUCCEEDS" {
        style.fill: "#0d2235"
        style.stroke: "#1f6feb"
        style.font-color: "#79c0ff"
      }
      ca_merged_hdr -> ca_merged_space: "+20" {
        style.stroke: "#1f6feb"
        style.font-size: 11
      }
    }
  }

  coalesce_before -> coalesce_steps: "kfree(ptr_B) called" {
    style.stroke: "#2ea043"
    style.stroke-width: 2
    style.font-color: "#56d364"
    style.animated: true
  }

  coalesce_steps -> coalesce_after: "O(1) merge via prev+next links" {
    style.stroke: "#2ea043"
    style.stroke-width: 2
    style.font-color: "#56d364"
    style.animated: true
  }
}

expand_op: "heap_expand: Map New Physical Frame When Heap Exhausted" {
  style.fill: "#0d1117"
  style.stroke: "#f0883e"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true

  trigger: "Trigger: last block cannot satisfy kmalloc(N)" {
    style.fill: "#2d1200"
    style.stroke: "#f0883e"
    style.font-color: "#f0883e"
    style.border-radius: 4
  }

  e1: "Guard: heap_end >= HEAP_MAX -> FATAL halt" {
    style.fill: "#3d1a1a"
    style.stroke: "#f85149"
    style.font-color: "#ffa198"
  }

  e2: "pmm_alloc_frame() -> returns phys 0x00402000" {
    style.fill: "#143020"
    style.stroke: "#2ea043"
    style.font-color: "#56d364"
  }

  e3: "vmm_map_page(boot_pd, heap_end=0xD0001000, phys, PRESENT|WRITABLE)" {
    style.fill: "#0d2235"
    style.stroke: "#1f6feb"
    style.font-color: "#79c0ff"

    e3_tlb: "tlb_flush_page(0xD0001000): invalidate stale TLB entry" {
      style.fill: "#0d2235"
      style.stroke: "#388bfd"
      style.font-color: "#79c0ff"
    }
  }

  e4: "heap_end += PAGE_SIZE (0xD0001000 -> 0xD0002000)" {
    style.fill: "#2d2500"
    style.stroke: "#e3b341"
    style.font-color: "#e3b341"
  }

  e5: "Extend or create free block covering new page" {
    style.fill: "#0d2235"
    style.stroke: "#1f6feb"
    style.font-color: "#79c0ff"

    e5_detail: |md
      If last block free: last->size += PAGE_SIZE

      Else: new block at heap_end - PAGE_SIZE

      size = PAGE_SIZE - sizeof(header)
    |
  }

  e6: "Retry kmalloc scan: new block satisfies request" {
    style.fill: "#143020"
    style.stroke: "#2ea043"
    style.font-color: "#56d364"
  }

  phys_virt: "Physical-to-Virtual Mapping After Expansion" {
    style.fill: "#161b22"
    style.stroke: "#30363d"
    style.border-radius: 4

    virt_new: "Virtual 0xD0001000-0xD0001FFF: now accessible" {
      style.fill: "#0d2235"
      style.stroke: "#1f6feb"
      style.font-color: "#79c0ff"
    }
    pte_entry: "PTE = 0x00402003 [phys=0x00402000, P=1, W=1, U/S=0]" {
      style.fill: "#3d1a6e"
      style.stroke: "#8957e5"
      style.font-color: "#e2c5ff"
    }
    phys_new: "Physical 0x00402000-0x00402FFF: 4096 bytes RAM from PMM" {
      style.fill: "#143020"
      style.stroke: "#2ea043"
      style.font-color: "#56d364"
    }

    virt_new -> pte_entry: "MMU lookup" {
      style.stroke: "#8957e5"
      style.stroke-dash: 3
    }
    pte_entry -> phys_new: "translates to" {
      style.stroke: "#8957e5"
      style.stroke-dash: 3
    }
  }

  trigger -> e1: "check limit first" { style.stroke: "#f0883e" }
  e1 -> e2: "within limit" { style.stroke: "#2ea043" }
  e2 -> e3: "physical frame allocated" { style.stroke: "#1f6feb" }
  e3 -> e4: "PTE installed + TLB flushed" { style.stroke: "#e3b341" }
  e4 -> e5: "heap_end advanced" { style.stroke: "#1f6feb" }
  e5 -> e6: "free block available" { style.stroke: "#2ea043" }

  e2 -> phys_virt.phys_new: "pmm returns this frame" {
    style.stroke: "#2ea043"
    style.stroke-width: 2
    style.font-color: "#56d364"
    style.font-size: 11
  }

  e3 -> phys_virt.virt_new: "virtual address now mapped" {
    style.stroke: "#1f6feb"
    style.stroke-width: 2
    style.font-color: "#79c0ff"
    style.font-size: 11
  }
}

frag_analysis: "Fragmentation Tradeoff: Internal vs External" {
  style.fill: "#0d1117"
  style.stroke: "#f85149"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true

  internal_frag: "Internal Fragmentation: waste INSIDE a block" {
    style.fill: "#3d1a1a"
    style.stroke: "#f85149"
    style.border-radius: 4

    if_detail: |md
      Cause: size rounded to 8-byte alignment boundary

      kmalloc(33) rounds to 40, wastes 7 bytes per block

      Mitigation: size = (size+7) and NOT 7 alignment

      Production fix: size-class slabs (zero internal frag per class)
    |
  }

  external_frag: "External Fragmentation: waste BETWEEN blocks" {
    style.fill: "#1a2035"
    style.stroke: "#1f6feb"
    style.border-radius: 4

    ef_detail: |md
      Cause: alternating alloc/free leaves non-contiguous holes

      Metric: largest_contiguous_free / total_free

      Mitigation: immediate coalescing in kfree via prev ptr O(1)

      Production fix: buddy allocator (zero ext frag, more int frag)
    |
  }

  policy_table: "Allocation Policy Comparison" {
    style.fill: "#161b22"
    style.stroke: "#30363d"
    style.border-radius: 4

    policy_detail: |md
      First-fit: O(n) search, Medium ext-frag, Low int-frag, Good cache

      Next-fit: O(1) avg, Medium ext-frag, Low int-frag, Best cache

      Best-fit: O(n) search, Low ext-frag, Medium int-frag, Poor cache

      Buddy: O(log n), None ext-frag, High int-frag, OK cache

      Slab/SLUB: O(1), None ext-frag, None int-frag, Best cache

      This kernel uses next-fit via search_hint pointer.

      Linux SLUB used for fixed-size kernel objects.
    |
  }
}

vas.page0.b0 -> vas.page0.b1: "next ptr: Block A -> Block B (forward link)" {
  style.stroke: "#8957e5"
  style.stroke-dash: 3
  style.font-color: "#8957e5"
  style.font-size: 11
}

vas.page0.b1 -> vas.page0.b0: "prev ptr: Block B -> Block A (O(1) coalesce)" {
  style.stroke: "#8957e5"
  style.stroke-dash: 3
  style.font-color: "#8957e5"
  style.font-size: 11
}

vas.page0.b1 -> vas.page0.b2: "next ptr" {
  style.stroke: "#8957e5"
  style.stroke-dash: 3
  style.font-size: 11
}

vas.page0.b2 -> vas.page0.b3: "next ptr" {
  style.stroke: "#8957e5"
  style.stroke-dash: 3
  style.font-size: 11
}

vas.page0.b3 -> vas.unmapped: "heap_expand called when b3 cannot satisfy request" {
  style.stroke: "#f0883e"
  style.stroke-width: 2
  style.font-color: "#f0883e"
  style.animated: true
}

vas.page0.b3 -> expand_op: "last block too small -> triggers heap_expand" {
  style.stroke: "#f0883e"
  style.stroke-width: 2
  style.font-color: "#f0883e"
}

header_anatomy -> split_op: "header layout drives split threshold (20+8=28 min remainder)" {
  style.stroke: "#6e40c9"
  style.stroke-dash: 4
  style.font-color: "#8957e5"
}

header_anatomy -> coalesce_op: "prev+next pointers enable O(1) bidirectional coalesce" {
  style.stroke: "#6e40c9"
  style.stroke-dash: 4
  style.font-color: "#8957e5"
}

frag_analysis.internal_frag -> header_anatomy.overhead_note: "header overhead IS internal fragmentation" {
  style.stroke: "#f85149"
  style.stroke-dash: 3
  style.font-color: "#f85149"
}

frag_analysis.external_frag -> coalesce_op.coalesce_after: "coalescing eliminates external fragmentation" {
  style.stroke: "#1f6feb"
  style.stroke-dash: 3
  style.font-color: "#79c0ff"
}