vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Context Switch: Register Save/Restore Assembly Flow
  ### Why C Cannot Do This â€” Every Byte Accounted For
| {near: top-center}

# â”€â”€ COLOR LEGEND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
legend: {
  near: bottom-right
  style.fill: "#1a1a2e"
  style.stroke: "#444"
  style.border-radius: 8
  label: |md
    **Color Semantics**
    ðŸ”´ Red = hot path / danger
    ðŸŸ¢ Green = success / safe resume
    ðŸŸ¡ Yellow = transition / caution
    ðŸ”µ Blue = data read
    ðŸŸ£ Purple = metadata / PCB fields
    âšª Gray = padding / unused / discarded
  |
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WHY C CANNOT DO THIS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
why_not_c: "Why context_switch() CANNOT Be Written in C" {
  style.fill: "#2d1b1b"
  style.stroke: "#cc4444"
  style.stroke-width: 3
  style.border-radius: 8

  c_compiler_view: |md
    **C Compiler's Register Contract (System V x86 ABI)**

    
    Caller-saved (EAX, ECX, EDX):
      â†’ Caller saves BEFORE call if it needs them
      â†’ C context_switch() is FREE to trash these
      â†’ Interrupted process NEVER saved them before IRQ

    Callee-saved (EBX, ESI, EDI, EBP):
      â†’ Callee MUST restore these on return
      â†’ C compiler auto-generates push/pop for these 4 only

    EFLAGS: â† NEVER saved by any C calling convention
    ESP:    â† C has no syntax to save/restore stack pointer
    EIP:    â† Implicit in call/ret â€” wrong for context switch
    CS/DS:  â† C cannot emit segment register saves
    
  | {style.fill: "#1a0a0a"; style.border-radius: 4}

  gap_analysis: |md
    **The Gap: What C Saves vs What We Need**

    
    Register   C Saves?   We Need?   Gap?
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    EAX        âœ— (caller) âœ“          â† SILENT CORRUPTION
    ECX        âœ— (caller) âœ“          â† SILENT CORRUPTION
    EDX        âœ— (caller) âœ“          â† SILENT CORRUPTION
    EBX        âœ“ (callee) âœ“          OK
    ESI        âœ“ (callee) âœ“          OK
    EDI        âœ“ (callee) âœ“          OK
    EBP        âœ“ (callee) âœ“          OK
    EFLAGS     âœ— NEVER    âœ“          â† INTERRUPT FLAG LOST
    ESP        âœ— implicit âœ“          â† STACK POINTER LOST
    EIP        âœ— via ret  âœ“ (wrong)  â† WRONG RESUME POINT
    

    Bug manifestation: Resumed process uses EAX expecting
    its saved value, gets scheduler's intermediate result.
    Failure is 10,000+ instructions AFTER the switch.
    No crash. Wrong answer. Impossible to debug.
  | {style.fill: "#1a0a0a"; style.border-radius: 4}
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PCB LAYOUT (both current and next)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
pcb_layout: "PCB (Process Control Block) Memory Layout" {
  style.fill: "#1a1a2e"
  style.stroke: "#6666cc"
  style.stroke-width: 2
  style.border-radius: 8

  pcb_table: {
    shape: sql_table
    label: "struct pcb { ... }  â€” offsets for asm addressing"
    style.fill: "#0d0d1a"
    style.stroke: "#6666cc"

    pid: "uint32_t pid" {constraint: "+0x00 (4 bytes)"}
    state: "uint32_t state" {constraint: "+0x04 (4 bytes)"}
    saved_edi: "uint32_t saved_edi" {constraint: "+0x08 â† pushad order[0]"}
    saved_esi: "uint32_t saved_esi" {constraint: "+0x0C â† pushad order[1]"}
    saved_ebp: "uint32_t saved_ebp" {constraint: "+0x10 â† pushad order[2]"}
    saved_esp_pushad: "uint32_t saved_esp_pushad" {constraint: "+0x14  (pushad ESP = pre-push, ignored)"}
    saved_ebx: "uint32_t saved_ebx" {constraint: "+0x18 â† pushad order[4]"}
    saved_edx: "uint32_t saved_edx" {constraint: "+0x1C â† pushad order[5]"}
    saved_ecx: "uint32_t saved_ecx" {constraint: "+0x20 â† pushad order[6]"}
    saved_eax: "uint32_t saved_eax" {constraint: "+0x24 â† pushad order[7]"}
    saved_eflags: "uint32_t saved_eflags" {constraint: "+0x28 â† pushfd"}
    saved_eip: "uint32_t saved_eip" {constraint: "+0x2C â† implicit in call/ret"}
    kernel_esp: "uint32_t kernel_esp" {constraint: "+0x30 â† THE KEY FIELD (saved ESP)"}
    page_dir: "pde_t*   page_dir" {constraint: "+0x34 (CR3 physical address)"}
    kernel_stack: "uint8_t  kstack[4096]" {constraint: "+0x38 (4KB, aligned 16)"}
  }

  offset_note: |md
    **Critical**: `kernel_esp` at offset `+0x30` is the only field
    `context_switch_asm` reads/writes directly via `[reg + 0x30]`.
    All other fields are restored from the STACK the kernel_esp points to.
  | {style.fill: "#0d0d1a"; style.border-radius: 4}
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# KERNEL STACK STATE DIAGRAM â€” step by step
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
stack_states: "Kernel Stack State at Each Assembly Step" {
  style.fill: "#0d1a0d"
  style.stroke: "#44aa44"
  style.stroke-width: 2
  style.border-radius: 8

  # STEP 0: Stack as IRQ fires (CPU auto-push already done)
  step0: "STEP 0: Stack when context_switch() is called\n(IRQ already fired; irq_stub called us)" {
    style.fill: "#111"
    style.stroke: "#888"
    style.border-radius: 4

    s0_mem: {
      shape: sql_table
      label: "Current Process Kernel Stack (ESP growing downward â†“)"
      style.fill: "#0a0a0a"

      irq_eflags: "EFLAGS (CPU auto-pushed)" {constraint: "esp+20 | IF=1, ZF, CF..."}
      irq_cs: "CS = 0x08 (CPU auto-pushed)" {constraint: "esp+16 | kernel code seg"}
      irq_eip: "EIP (CPU auto-pushed)" {constraint: "esp+12 | resume address â† GOLD"}
      irq_errcode: "Error code / dummy 0" {constraint: "esp+8  | from IRQ stub"}
      irq_vector: "IRQ vector = 32" {constraint: "esp+4  | from IRQ stub"}
      ret_addr: "return addr â†’ irq_stub_exit" {constraint: "esp+0  â† ESP NOW HERE"}
    }
    note0: "context_switch() sees this stack.\nEIP at esp+12 is where interrupted process resumes." {
      style.fill: "#1a1a00"
      style.font-color: "#ffee44"
    }
  }

  # STEP 1: After pushfd
  step1: "STEP 1: pushfd â€” Save EFLAGS" {
    style.fill: "#111"
    style.stroke: "#cc4444"
    style.border-radius: 4

    s1_asm: |go
      ; context_switch_asm (called with 'call' from irq_dispatcher)
      ; Arguments: [esp+4]=*current_pcb, [esp+8]=*next_pcb

      context_switch_asm:
          ; STEP 1: Save EFLAGS â€” contains IF (interrupt flag!)
          ; C calling convention NEVER does this.
          ; If IF is lost, resumed process runs with interrupts OFF forever.
          pushfd              ; ESP -= 4; [ESP] = EFLAGS
    | {style.fill: "#0a0a0a"}

    s1_mem: {
      shape: sql_table
      label: "Stack after pushfd"
      style.fill: "#0a0a0a"

      eflags_saved: "EFLAGS = 0x00000202" {constraint: "esp+0  â† NEW (IF=1 preserved!) ðŸ”´"}
      ret_was: "return addr" {constraint: "esp+4"}
      eip_below: "EIP (resume point)" {constraint: "esp+16"}
    }

    s1_why: "WHY: EFLAGS contains the Interrupt Flag (bit 9).\nIf we restore EFLAGS without this, the resumed\nprocess runs with interrupts DISABLED â†’ system hang." {
      style.fill: "#2d0000"
      style.font-color: "#ff6666"
    }
  }

  # STEP 2: After pushad
  step2: "STEP 2: pushad â€” Save All 8 General-Purpose Registers" {
    style.fill: "#111"
    style.stroke: "#cc4444"
    style.border-radius: 4

    s2_asm: |go
          ; STEP 2: Save all 8 general-purpose registers atomically.
          ; pushad pushes: EAX, ECX, EDX, EBX, ESP(pre-push), EBP, ESI, EDI
          ; Encoding: PUSHAD = 0x60 (single opcode, 8 pushes = 32 bytes total)
          pushad              ; ESP -= 32; all 8 GPRs on stack
    | {style.fill: "#0a0a0a"}

    s2_mem: {
      shape: sql_table
      label: "Stack after pushad (32 bytes added)"
      style.fill: "#0a0a0a"

      edi_s: "EDI" {constraint: "esp+0   â† NEWEST"}
      esi_s: "ESI" {constraint: "esp+4"}
      ebp_s: "EBP (frame pointer)" {constraint: "esp+8"}
      esp_s: "ESP (pre-pushad value â€” IGNORED on popad)" {constraint: "esp+12  âš  hardware ignores on popad"}
      ebx_s: "EBX" {constraint: "esp+16"}
      edx_s: "EDX" {constraint: "esp+20"}
      ecx_s: "ECX" {constraint: "esp+24"}
      eax_s: "EAX" {constraint: "esp+28 â† C would trash this! ðŸ”´"}
      eflags_below: "EFLAGS (from pushfd)" {constraint: "esp+32"}
      ret_below: "return addr" {constraint: "esp+36"}
      eip_way_below: "EIP (resume point)" {constraint: "esp+48"}
    }

    s2_why: "WHY pushad instead of individual pushes?\nAtomic: no interrupt can fire between saves.\nCompact: 1 opcode vs 8 push instructions.\nEAX/ECX/EDX included â€” these are the registers\nC's calling convention OMITS (caller-saved)." {
      style.fill: "#2d0000"
      style.font-color: "#ff6666"
    }
  }

  # STEP 3: Save kernel ESP into current PCB
  step3: "STEP 3: Save Current Kernel ESP â†’ PCB.kernel_esp" {
    style.fill: "#111"
    style.stroke: "#cc8844"
    style.border-radius: 4

    s3_asm: |go
          ; STEP 3: Record WHERE on the kernel stack all our saved
          ; state lives. Future resume needs this to find EFLAGS, GPRs, EIP.
          ;
          ; [esp+36+4] because: 32 bytes pushad + 4 bytes pushfd = 36 bytes
          ; above our current ESP; then +4 for the call's return address.
          ; We want to save the ESP *before* the call instruction pushed ret addr.
          ;
          ; Simpler: just save current ESP â€” the resume path restores from here.
          mov eax, [esp + 36 + 4]   ; Load *current_pcb ptr (arg1, past our pushes)
          mov [eax + 0x30], esp     ; current_pcb->kernel_esp = ESP
                                    ; Offset 0x30 = kernel_esp field in PCB struct
    | {style.fill: "#0a0a0a"}

    s3_note: |md
      **Offset math:**
      - `esp+0` .. `esp+28` = pushad (8 regs Ã— 4 bytes)
      - `esp+32` = pushfd (EFLAGS)
      - `esp+36` = return address (pushed by `call context_switch_asm`)
      - `esp+40` = arg1 = `*current_pcb` â† we read this
      - `esp+44` = arg2 = `*next_pcb`

      After `mov [eax+0x30], esp`:
      The current PCB's `kernel_esp` field contains the stack address
      where `EDI` is stored. To resume current: `mov esp, pcb->kernel_esp`
      then `popad` then `popfd` then `ret` â†’ lands at saved EIP.
    | {style.fill: "#1a1400"; style.border-radius: 4}
  }

  # STEP 4: Load next PCB's ESP
  step4: "STEP 4: Load Next Process's Kernel ESP â†’ Pivot the Stack" {
    style.fill: "#111"
    style.stroke: "#ffcc00"
    style.stroke-width: 3
    style.border-radius: 4

    s4_asm: |go
          ; STEP 4: THE CRITICAL INSTRUCTION.
          ; After this line, we are on the NEXT process's kernel stack.
          ; All subsequent memory accesses go to next's saved state.
          ; The current process is now "frozen" â€” unreachable until scheduled.
          ;
          ; Must load arg2 BEFORE changing ESP (arg2 is at [esp+44]).
          mov ecx, [esp + 44]       ; Load *next_pcb ptr (arg2)
          mov esp, [ecx + 0x30]     ; ESP = next_pcb->kernel_esp
                                    ; â† WE ARE NOW ON NEXT'S STACK
    | {style.fill: "#0a0a0a"}

    s4_note: "AFTER this instruction:\nâ€¢ Reading [esp+N] accesses NEXT process's saved registers\nâ€¢ The CPU is executing kernel code belonging to 'current'\n  but with next's stack pointer â€” a deliberate hybrid state\nâ€¢ Duration: exactly 4 more instructions until iret completes the switch" {
      style.fill: "#2d2d00"
      style.font-color: "#ffee00"
    }
  }

  # STEP 4.5: CR3 switch (optional)
  step4b: "STEP 4.5: CR3 Reload â€” Switch Address Space (if different)" {
    style.fill: "#111"
    style.stroke: "#6644cc"
    style.border-radius: 4

    s4b_asm: |go
          ; STEP 4.5: Switch virtual address space.
          ; Only if next process has a different page directory.
          ; Kernel threads share boot_page_directory â†’ skip for them.
          mov eax, cr3
          cmp eax, [ecx + 0x34]     ; Compare current CR3 to next->page_dir
          je  .same_pgdir           ; Skip flush if same (kernel threads)
          mov cr3, [ecx + 0x34]     ; Load next's page directory physical addr
                                    ; This FLUSHES non-global TLB entries!
                                    ; Cost: ~30 cycles + TLB cold-miss penalty
      .same_pgdir:
    | {style.fill: "#0a0a0a"}

    s4b_note: "CR3 flush cost: ~30 cycles reload + subsequent TLB misses\n(each miss = 3 memory reads for 2-level page walk = ~60-180ns).\nKernel threads skip this â†’ use PAGE_GLOBAL flag on kernel PTEs\nso TLB entries survive CR3 reloads when switching between\nkernel-only processes." {
      style.fill: "#1a0d2d"
      style.font-color: "#aa88ff"
    }
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RESTORE SEQUENCE (popad / popfd / ret)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
restore_seq: "RESTORE SEQUENCE â€” Resuming the Next Process" {
  style.fill: "#0d1a2d"
  style.stroke: "#4488cc"
  style.stroke-width: 2
  style.border-radius: 8

  # STEP 5: popad
  step5: "STEP 5: popad â€” Restore Next Process's 8 GPRs" {
    style.fill: "#111"
    style.stroke: "#44aaff"
    style.border-radius: 4

    s5_asm: |go
          ; STEP 5: popad restores 8 GPRs from the NEXT process's stack.
          ; These values were pushed by the PREVIOUS invocation of pushad
          ; when next was last preempted (or were set up as the fake initial frame).
          ;
          ; popad pops: EDI, ESI, EBP, (ESP ignored), EBX, EDX, ECX, EAX
          ; Note: popad does NOT restore ESP from the stack value at esp+12.
          ;       The hardware skips that slot to keep ESP consistent.
          popad               ; ESP += 32; all 8 GPRs â† NEXT PROCESS's values
    | {style.fill: "#0a0a0a"}

    s5_mem: {
      shape: sql_table
      label: "Next Process's Stack â€” values being restored"
      style.fill: "#0a0a0a"

      next_edi: "Next's EDI = (saved value)" {constraint: "esp+0  â†’ EDI register ðŸ”µ"}
      next_esi: "Next's ESI = (saved value)" {constraint: "esp+4  â†’ ESI register ðŸ”µ"}
      next_ebp: "Next's EBP = (saved value)" {constraint: "esp+8  â†’ EBP register ðŸ”µ"}
      next_esp_skip: "Next's ESP_slot (SKIPPED by popad)" {constraint: "esp+12 âšª hardware ignores"}
      next_ebx: "Next's EBX = (saved value)" {constraint: "esp+16 â†’ EBX register ðŸ”µ"}
      next_edx: "Next's EDX = (saved value)" {constraint: "esp+20 â†’ EDX register ðŸ”µ"}
      next_ecx: "Next's ECX = (saved value)" {constraint: "esp+24 â†’ ECX register ðŸ”µ"}
      next_eax: "Next's EAX = (saved value)" {constraint: "esp+28 â†’ EAX register ðŸ”µ"}
      next_eflags: "Next's EFLAGS (after popad esp points here)" {constraint: "esp+0  â† ESP NOW"}
    }
  }

  # STEP 6: popfd
  step6: "STEP 6: popfd â€” Restore EFLAGS (including IF!)" {
    style.fill: "#111"
    style.stroke: "#44cc44"
    style.border-radius: 4

    s6_asm: |go
          ; STEP 6: Restore EFLAGS â€” MUST include IF=1 for preemptible process.
          ; After this: the CPU's condition codes, direction flag, and interrupt
          ; enable bit are all exactly what they were when next was preempted.
          popfd               ; ESP += 4; EFLAGS â† next process's saved EFLAGS
                              ; IF is now restored: interrupts enabled if they were
    | {style.fill: "#0a0a0a"}

    s6_note: "IF (Interrupt Flag) in EFLAGS is bit 9.\nIf next process was running normal code: IF=1 (interrupts on).\nIf next process was in a cli/sti critical section: IF=0.\npopfd atomically restores the EXACT state â€” no gap where\ninterrupts could incorrectly fire between restore steps." {
      style.fill: "#002d00"
      style.font-color: "#66ff66"
    }
  }

  # STEP 7: ret
  step7: "STEP 7: ret â€” Jump to Next Process's Saved EIP" {
    style.fill: "#111"
    style.stroke: "#44ff44"
    style.stroke-width: 3
    style.border-radius: 4

    s7_asm: |go
          ; STEP 7: 'ret' pops EIP from the stack and jumps there.
          ; The value on the stack is the return address that was placed
          ; when context_switch_asm was 'call'ed during next's PREVIOUS preemption.
          ; For a brand-new process: the fake initial frame has the entry point here.
          ;
          ; This is not a 'jmp' â€” it uses the stack. The stack currently contains
          ; exactly the return address back into irq_dispatcher (or trampoline),
          ; which will then 'iret' to restore CS, EIP, EFLAGS (ring transition).
          ret                 ; EIP â† [ESP]; ESP += 4
                              ; CPU jumps to: irq_common_stub exit sequence
                              ; which executes 'iret' â†’ final restore of CS+EIP+EFLAGS
    | {style.fill: "#0a0a0a"}

    s7_note: "After 'ret': execution is in irq_common_stub's exit sequence.\niret then fires, atomically restoring:\n  EIP  â† where next process was interrupted\n  CS   â† 0x08 (kernel) or 0x1B (user ring 3)\n  EFLAGS â† (already restored by popfd, but iret re-restores from frame)\n  [ESP, SS] â† only if crossing ring boundary (ring 3 process)\nThe process resumes at the exact instruction it was at." {
      style.fill: "#002d00"
      style.font-color: "#88ff88"
    }
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BEFORE / AFTER SIDE-BY-SIDE STACK COMPARISON
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
before_after: "BEFORE / AFTER: Stack Transformation Summary" {
  style.fill: "#1a1a1a"
  style.stroke: "#888"
  style.border-radius: 8

  before_col: "BEFORE context_switch()\n(Current Process Running)" {
    style.fill: "#1a0000"
    style.stroke: "#cc2222"
    style.border-radius: 6

    b_cpu: {
      shape: sql_table
      label: "CPU Registers (Current Process)"
      style.fill: "#0d0000"

      b_eax: "EAX = 0xDEADBEEF (mid-computation)" {constraint: "will be SAVED"}
      b_ecx: "ECX = loop counter value" {constraint: "will be SAVED"}
      b_edx: "EDX = intermediate result" {constraint: "will be SAVED"}
      b_ebx: "EBX = base pointer" {constraint: "will be SAVED"}
      b_esp: "ESP = 0xC01FFF00 (kernel stack)" {constraint: "saved to PCB.kernel_esp"}
      b_ebp: "EBP = frame base" {constraint: "will be SAVED"}
      b_esi: "ESI = source index" {constraint: "will be SAVED"}
      b_edi: "EDI = dest index" {constraint: "will be SAVED"}
      b_eip: "EIP = 0x00401234 (mid-loop)" {constraint: "on stack (CPU pushed at IRQ)"}
      b_eflags: "EFLAGS = 0x202 (IF=1, ZF=0)" {constraint: "will be SAVED"}
      b_cr3: "CR3 = 0x00200000 (current PD)" {constraint: "may change"}
    }
  }

  after_col: "AFTER context_switch()\n(Next Process Resumed)" {
    style.fill: "#001a00"
    style.stroke: "#22cc22"
    style.border-radius: 6

    a_cpu: {
      shape: sql_table
      label: "CPU Registers (Next Process â€” completely replaced)"
      style.fill: "#000d00"

      a_eax: "EAX = next's saved EAX" {constraint: "RESTORED by popad ðŸŸ¢"}
      a_ecx: "ECX = next's saved ECX" {constraint: "RESTORED by popad ðŸŸ¢"}
      a_edx: "EDX = next's saved EDX" {constraint: "RESTORED by popad ðŸŸ¢"}
      a_ebx: "EBX = next's saved EBX" {constraint: "RESTORED by popad ðŸŸ¢"}
      a_esp: "ESP = next's user/kernel ESP" {constraint: "RESTORED by iret (ring3) or ret (ring0)"}
      a_ebp: "EBP = next's saved EBP" {constraint: "RESTORED by popad ðŸŸ¢"}
      a_esi: "ESI = next's saved ESI" {constraint: "RESTORED by popad ðŸŸ¢"}
      a_edi: "EDI = next's saved EDI" {constraint: "RESTORED by popad ðŸŸ¢"}
      a_eip: "EIP = next's saved EIP" {constraint: "RESTORED by iret ðŸŸ¢"}
      a_eflags: "EFLAGS = next's (IF=1)" {constraint: "RESTORED by popfd+iret ðŸŸ¢"}
      a_cr3: "CR3 = next's page directory" {constraint: "LOADED by context_switch_asm ðŸŸ¢"}
    }
  }

  before_col -> after_col: "context_switch_asm()\n~10 instructions\n~500â€“1000 CPU cycles\n(mostly cache miss latency)" {
    style.stroke: "#ffcc00"
    style.stroke-width: 4
    style.font-color: "#ffcc00"
    style.bold: true
    style.animated: true
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TIMING / COST ANALYSIS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
timing: "Context Switch Cost Breakdown" {
  style.fill: "#1a1a0a"
  style.stroke: "#aaaa44"
  style.border-radius: 8

  cost_table: {
    shape: sql_table
    label: "Cycle Cost per Operation (2 GHz CPU = 0.5ns per cycle)"
    style.fill: "#0d0d00"

    irq_response: "IRQ recognition + CPU auto-push (EFLAGS/CS/EIP/SS/ESP)" {constraint: "~30 cycles | 15ns"}
    pushfd: "pushfd â€” save EFLAGS" {constraint: "~1 cycle  | 0.5ns"}
    pushad: "pushad â€” save 8 GPRs (32 bytes)" {constraint: "~3 cycles | 1.5ns"}
    save_esp: "mov [pcb+0x30], esp â€” save kernel ESP" {constraint: "~4 cycles | 2ns (L1 hit)"}
    load_next_esp: "mov esp, [pcb+0x30] â€” load next ESP" {constraint: "~100 cycles | 50ns (DRAM if cold PCB)"}
    cr3_reload: "mov cr3, [pcb+0x34] â€” flush TLB" {constraint: "~30 cycles + TLB misses"}
    popad: "popad â€” restore 8 GPRs from next stack" {constraint: "~100 cycles | 50ns (cold stack page)"}
    popfd: "popfd â€” restore EFLAGS" {constraint: "~1 cycle  | 0.5ns"}
    ret_iret: "ret + iret â€” restore EIP/CS/EFLAGS/ESP" {constraint: "~20 cycles | 10ns"}
    tlb_miss_penalty: "TLB cold misses on first access in new address space" {constraint: "~200-500 cycles | 100-250ns (3 mem reads per miss)"}
    total: "TOTAL typical context switch" {constraint: "~500-1000 cycles | 250-500ns"}
  }

  cache_note: |md
    **Why most cycles are memory latency, not computation:**
    - `pushad` / `popad` touch the kernel stack â†’ L1 if hot, DRAM if cold (10ms since last access)
    - Loading `pcb->kernel_esp` â†’ L3 or DRAM (PCB last touched 10ms ago at 100Hz scheduler)
    - First memory access after CR3 reload â†’ guaranteed TLB miss â†’ 3 page-table reads
    - The 10 assembly instructions are ~15 cycles; the 485+ cycles are **waiting for RAM**

    This is why Go goroutines switch in ~100ns: no CR3 reload (shared address space),
    smaller register set, hot stacks from frequent switching.
  | {style.fill: "#0d0d00"; style.border-radius: 4}
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FAKE INITIAL FRAME (for brand-new processes)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fake_frame: "Fake Initial Stack Frame â€” Starting a Brand-New Process" {
  style.fill: "#1a0d1a"
  style.stroke: "#cc66cc"
  style.stroke-width: 2
  style.border-radius: 8

  fake_note: |md
    A new process has never run â€” it has no "saved state from previous preemption."
    We manufacture a fake stack frame that looks exactly like what pushad+pushfd+IRQ would have left.
    When the scheduler first selects it, `popad` restores zeros for GPRs, `popfd` restores IF=1,
    `ret` jumps to the trampoline, and `iret` jumps to the entry function.
  | {style.fill: "#0d000d"; style.border-radius: 4}

  fake_stack: {
    shape: sql_table
    label: "kernel_stack_top âˆ’ N bytes (built by process_create_kernel)"
    style.fill: "#0d000d"

    f_ret: "trampoline addr (â†’ irq_common_stub exit)" {constraint: "esp+0  â† cpu.esp points here ðŸŸ£"}
    f_edi: "EDI initial = 0x00000000" {constraint: "esp+4  (popad slot 0)"}
    f_esi: "ESI initial = 0x00000000" {constraint: "esp+8  (popad slot 1)"}
    f_ebp: "EBP initial = 0x00000000" {constraint: "esp+12 (popad slot 2)"}
    f_esp_skip: "ESP slot = 0x00000000 (SKIPPED by popad)" {constraint: "esp+16 âšª"}
    f_ebx: "EBX initial = 0x00000000" {constraint: "esp+20 (popad slot 4)"}
    f_edx: "EDX initial = 0x00000000" {constraint: "esp+24 (popad slot 5)"}
    f_ecx: "ECX initial = 0x00000000" {constraint: "esp+28 (popad slot 6)"}
    f_eax: "EAX initial = 0x00000000" {constraint: "esp+32 (popad slot 7)"}
    f_eflags: "EFLAGS = 0x00000202 (IF=1, reserved=1)" {constraint: "esp+36 (popfd) â† IF MUST be 1!"}
    f_eip: "[iret slot] EIP = entry_function_addr" {constraint: "esp+40 (CPU-like iret EIP)"}
    f_cs: "[iret slot] CS = 0x08 (kernel) or 0x1B (user)" {constraint: "esp+44"}
    f_cpu_eflags: "[iret slot] EFLAGS = 0x202 (redundant safety)" {constraint: "esp+48"}
    f_user_esp: "[iret slot] user ESP (ring3 only)" {constraint: "esp+52 (only for ring-3 process)"}
    f_user_ss: "[iret slot] user SS = 0x23 (ring3 only)" {constraint: "esp+56 (only for ring-3 process)"}
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONNECTIONS / FLOW
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
why_not_c -> stack_states.step0: "IRQ fires â†’ enters context_switch_asm" {
  style.stroke: "#cc4444"
  style.stroke-width: 2
  style.stroke-dash: 3
}

stack_states.step0 -> stack_states.step1: "pushfd" {
  style.stroke: "#cc4444"
  style.bold: true
  style.font-color: "#ff6666"
}

stack_states.step1 -> stack_states.step2: "pushad (32 bytes)" {
  style.stroke: "#cc4444"
  style.bold: true
  style.font-color: "#ff6666"
}

stack_states.step2 -> stack_states.step3: "mov [current+0x30], esp" {
  style.stroke: "#cc8844"
  style.bold: true
  style.font-color: "#ffaa44"
}

stack_states.step3 -> stack_states.step4: "PIVOT: mov esp, [next+0x30]" {
  style.stroke: "#ffcc00"
  style.stroke-width: 4
  style.bold: true
  style.font-color: "#ffee00"
  style.animated: true
}

stack_states.step4 -> stack_states.step4b: "CR3 switch\n(if different PD)" {
  style.stroke: "#6644cc"
  style.stroke-dash: 3
  style.font-color: "#aa88ff"
}

stack_states.step4b -> restore_seq.step5: "on next's stack â†’ popad" {
  style.stroke: "#44aaff"
  style.stroke-width: 2
  style.font-color: "#88ccff"
}

restore_seq.step5 -> restore_seq.step6: "popfd" {
  style.stroke: "#44cc44"
  style.bold: true
  style.font-color: "#66ff66"
}

restore_seq.step6 -> restore_seq.step7: "ret â†’ iret â†’ resume" {
  style.stroke: "#44ff44"
  style.stroke-width: 3
  style.bold: true
  style.font-color: "#88ff88"
  style.animated: true
}

pcb_layout -> stack_states.step3: "PCB.kernel_esp field\n(offset +0x30)" {
  style.stroke: "#6666cc"
  style.stroke-dash: 5
  style.font-color: "#aaaaff"
}

pcb_layout -> stack_states.step4: "next_pcb->kernel_esp\nloaded into ESP" {
  style.stroke: "#6666cc"
  style.stroke-dash: 5
  style.font-color: "#aaaaff"
}

fake_frame -> restore_seq.step5: "First-ever run: fake frame\nbehaves identically to real saved frame" {
  style.stroke: "#cc66cc"
  style.stroke-dash: 5
  style.font-color: "#ee88ee"
}

before_after -> timing: "cost of the transformation" {
  style.stroke: "#888"
  style.stroke-dash: 3
}