vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Multi-Process VGA Demo: Memory-Mapped I/O Sharing
  3 concurrent kernel processes sharing one identity-mapped VGA buffer at 0xB8000
| {near: top-center}

processes: "Kernel Process Table (ring 0, CS=0x08)" {
  style: {
    fill: "#0d1b2a"
    stroke: "#2a6496"
    stroke-width: 2
    border-radius: 8
    font-color: "#aaddff"
  }

  proc_a: "Process A  PID=1  proc_a_entry()" {
    style: {
      fill: "#003d00"
      stroke: "#00cc00"
      stroke-width: 2
      border-radius: 6
      font-color: "#00ff00"
      bold: true
    }

    pa_state: "PCB fields" {
      style.fill: "#001a00"
      style.font-color: "#88ff88"
      style.border-radius: 4
      pa_s1: "state: PROCESS_RUNNING"
      pa_s2: "ticks_remaining: 0-5 (50ms slice)"
      pa_s3: "page_directory: boot_page_directory (shared)"
      pa_s4: "kernel_stack_top: kernel_stack + 4096"
    }

    pa_cpu: "cpu_state_t (52 bytes saved on preemption)" {
      style.fill: "#002800"
      style.stroke: "#005500"
      style.font-color: "#66dd66"
      style.border-radius: 4
      pa_r1: "EIP    = 0x001003A4  resumes here after switch"
      pa_r2: "EFLAGS = 0x00000202  IF=1 interrupts enabled"
      pa_r3: "CS     = 0x08        ring-0 kernel code selector"
      pa_r4: "EAX/EBX/ECX/EDX/ESI/EDI/EBP  saved by pusha"
      pa_r5: "ESP    = kernel_stack ptr at save time"
    }

    pa_kstack: "kernel_stack[4096]  aligned(16)" {
      style.fill: "#001500"
      style.stroke: "#004400"
      style.font-color: "#55cc55"
      style.border-radius: 4
      pa_k1: "HIGH: kernel_stack_top = kernel_stack + 4096"
      pa_k2: "[EFLAGS][CS][EIP]    CPU pushed on IRQ (3-field ring-0 frame)"
      pa_k3: "[vector][error_code] stub pushed"
      pa_k4: "[DS][ES][FS][GS]     stub saved segment registers"
      pa_k5: "[EDI][ESI][EBP][ESP][EBX][EDX][ECX][EAX] pusha"
      pa_k6: "LOW:  kernel_stack[0]"
    }

    pa_tss_note: "TSS.ESP0 note for kernel process" {
      style.fill: "#002800"
      style.stroke: "#00aa00"
      style.font-color: "#00ff00"
      style.border-radius: 4
      pa_t1: "Updated on EVERY context switch regardless"
      pa_t2: "tss_set_kernel_stack(proc_a.kernel_stack_top)"
      pa_t3: "CPU does NOT read TSS.ESP0 when IRQ fires at ring 0"
      pa_t4: "No stack switch: CS=0x08 means already in ring 0"
      pa_t5: "3-field IRQ frame only: EFLAGS CS EIP"
      pa_t6: "Update mandatory: next IRQ may arrive with ring-3 process"
    }
  }

  proc_b: "Process B  PID=2  proc_b_entry()" {
    style: {
      fill: "#3d0000"
      stroke: "#cc0000"
      stroke-width: 2
      border-radius: 6
      font-color: "#ff6666"
      bold: true
    }

    pb_state: "PCB fields" {
      style.fill: "#1a0000"
      style.font-color: "#ff8888"
      style.border-radius: 4
      pb_s1: "state: PROCESS_READY (waiting for slice)"
      pb_s2: "ticks_remaining: reset to 5 on dispatch"
      pb_s3: "page_directory: boot_page_directory (shared)"
      pb_s4: "kernel_stack_top: kernel_stack + 4096"
    }

    pb_cpu: "cpu_state_t (52 bytes frozen)" {
      style.fill: "#280000"
      style.stroke: "#550000"
      style.font-color: "#dd6666"
      style.border-radius: 4
      pb_r1: "EIP    = 0x001005B8  resumes at busy-loop"
      pb_r2: "EFLAGS = 0x00000202  IF=1"
      pb_r3: "CS     = 0x08        ring-0"
      pb_r4: "All GPRs frozen from last preemption"
    }

    pb_kstack: "kernel_stack[4096]  aligned(16)" {
      style.fill: "#150000"
      style.stroke: "#440000"
      style.font-color: "#cc5555"
      style.border-radius: 4
      pb_k1: "Same 3-field IRQ frame layout as proc_a"
      pb_k2: "Separate physical frame - no overlap with A or C"
      pb_k3: "proc_b.kernel_stack != proc_a.kernel_stack"
    }
  }

  proc_c: "Process C  PID=3  proc_c_entry()" {
    style: {
      fill: "#2d2000"
      stroke: "#cc8800"
      stroke-width: 2
      border-radius: 6
      font-color: "#ffcc44"
      bold: true
    }

    pc_state: "PCB fields" {
      style.fill: "#1a1000"
      style.font-color: "#ffaa33"
      style.border-radius: 4
      pc_s1: "state: PROCESS_READY"
      pc_s2: "page_directory: boot_page_directory (shared)"
      pc_s3: "kernel_stack_top: kernel_stack + 4096"
    }

    pc_cpu: "cpu_state_t (52 bytes)" {
      style.fill: "#201500"
      style.stroke: "#554400"
      style.font-color: "#ddaa44"
      style.border-radius: 4
      pc_r1: "EIP    = 0x001007C0  resumes at busy-loop"
      pc_r2: "EFLAGS = 0x00000202  IF=1"
      pc_r3: "CS     = 0x08        ring-0"
    }

    pc_kstack: "kernel_stack[4096]  aligned(16)" {
      style.fill: "#180f00"
      style.stroke: "#443300"
      style.font-color: "#bb9933"
      style.border-radius: 4
      pc_k1: "Separate physical frame from A and B"
      pc_k2: "Same 3-field IRQ frame layout"
    }
  }
}

page_dir: "boot_page_directory  phys=virt=0x00103000  (shared CR3)" {
  style: {
    fill: "#1a0033"
    stroke: "#7700cc"
    stroke-width: 2
    border-radius: 8
    font-color: "#cc88ff"
  }

  pd_header: "1024 PDEs = 4096 bytes (one physical frame)" {
    style.fill: "#110022"
    style.font-color: "#bb77ee"
    style.border-radius: 4
    pd_h1: "Shared CR3 for ALL kernel processes"
    pd_h2: "No CR3 reload on kernel-to-kernel context switch"
    pd_h3: "context_switch_asm: cmp cr3,next_pd; je .same"
  }

  pd_entry0: "PDE[0]  virt 0x00000000-0x003FFFFF" {
    style.fill: "#220044"
    style.stroke: "#5500aa"
    style.font-color: "#cc66ff"
    style.border-radius: 4
    pd0_f1: "Target: identity_page_table"
    pd0_f2: "Flags: P=1  R/W=1  U/S=0  (supervisor only)"
    pd0_f3: "PTE[0xB8]: phys=0x000B8000  VGA MMIO"
    pd0_f4: "PTE[0x100]: phys=0x00100000  kernel .text"
    pd0_f5: "virtual addr == physical addr (identity map)"
  }

  pd_entry768: "PDE[768]  virt 0xC0000000-0xC03FFFFF" {
    style.fill: "#1a0033"
    style.stroke: "#4400aa"
    style.font-color: "#aa55ee"
    style.border-radius: 4
    pd768_f1: "Target: kernel_page_table (higher-half)"
    pd768_f2: "Flags: P=1  R/W=1  U/S=0  (supervisor only)"
    pd768_f3: "U/S=0: user-mode access triggers PF exception 14"
  }

  cr3_note: "CR3 optimization in context_switch_asm" {
    style.fill: "#110033"
    style.stroke: "#5500bb"
    style.font-color: "#bb88ff"
    style.border-radius: 4
    cr3_f1: "mov eax, cr3"
    cr3_f2: "cmp eax, edx      edx = next->page_directory"
    cr3_f3: "je  .same_cr3     TAKEN for A->B->C->A (all share boot_pd)"
    cr3_f4: "mov cr3, edx      Only executed for kernel->user switch"
    cr3_f5: "TLB NOT flushed on kernel->kernel switch (fast path)"
  }
}

vga_buffer: "VGA Text Buffer  phys=virt=0x000B8000  4000 bytes  MMIO" {
  style: {
    fill: "#111111"
    stroke: "#888888"
    stroke-width: 3
    border-radius: 8
    font-color: "#ffffff"
  }

  vga_layout: "Buffer layout: 80 cols x 25 rows = 2000 cells x 2 bytes" {
    style.fill: "#1a1a1a"
    style.font-color: "#cccccc"
    style.border-radius: 4
    vga_l1: "Each cell: [char byte][attr byte]"
    vga_l2: "attr bits[7:4]=background  bits[3:0]=foreground"
    vga_l3: "Access: volatile uint16_t *vga = (volatile uint16_t*)0xB8000"
    vga_l4: "Cell(row,col): vga[row * 80 + col]"
    vga_l5: "volatile MANDATORY: prevents compiler dead-store elimination"
  }

  vga_region_a: "Process A Region  rows 0-7  offset 0x0000-0x0A00  1280 bytes" {
    style: {
      fill: "#001a00"
      stroke: "#00cc00"
      stroke-width: 2
      border-radius: 6
      font-color: "#00ff00"
    }
    vga_a1: "Process A writes row 2: vga[2*80 + i]"
    vga_a2: "Content: Process A: 42738"
    vga_a3: "Attribute: 0x0A  fg=light-green  bg=black"
    vga_a4: "vga[160+i] = (uint16_t)ch | (0x0A<<8)"
    vga_a5: "Physical MMIO addr: 0xB8140 + i*2"
  }

  vga_region_b: "Process B Region  rows 8-15  offset 0x0A00-0x1400  1280 bytes" {
    style: {
      fill: "#1a0000"
      stroke: "#cc0000"
      stroke-width: 2
      border-radius: 6
      font-color: "#ff6666"
    }
    vga_b1: "Process B writes row 12: vga[12*80 + i]"
    vga_b2: "Content: Process B: 11204"
    vga_b3: "Attribute: 0x0C  fg=light-red  bg=black"
    vga_b4: "vga[960+i] = (uint16_t)ch | (0x0C<<8)"
    vga_b5: "Physical MMIO addr: 0xB8780 + i*2"
  }

  vga_region_c: "Process C Region  rows 16-24  offset 0x1400-0x1F40  1472 bytes" {
    style: {
      fill: "#1a1400"
      stroke: "#cc8800"
      stroke-width: 2
      border-radius: 6
      font-color: "#ffcc44"
    }
    vga_c1: "Process C writes row 22: vga[22*80 + i]"
    vga_c2: "Content: Process C: 3871"
    vga_c3: "Attribute: 0x0E  fg=yellow  bg=black"
    vga_c4: "vga[1760+i] = (uint16_t)ch | (0x0E<<8)"
    vga_c5: "Physical MMIO addr: 0xB8DC0 + i*2"
  }
}

tss: "TSS (Task State Segment)  GDT[5]  selector=0x28" {
  style: {
    fill: "#1a1a00"
    stroke: "#aaaa00"
    stroke-width: 2
    border-radius: 8
    font-color: "#ffff88"
  }

  tss_fields: "tss_t kernel_tss (104 bytes hardware-defined)" {
    style.fill: "#111100"
    style.font-color: "#eeee77"
    style.border-radius: 4
    tss_f1: "esp0:       CURRENT process kernel_stack_top"
    tss_f2: "ss0:        0x10  kernel data selector (fixed)"
    tss_f3: "iomap_base: sizeof(tss_t)  all I/O restricted ring-0"
    tss_f4: "rest:       0  hardware task-switch not used"
  }

  tss_kernel: "Kernel Process (ring 0) - TSS.ESP0 NOT used by CPU on IRQ" {
    style.fill: "#003d00"
    style.stroke: "#00aa00"
    style.font-color: "#00ff00"
    style.border-radius: 6
    tk1: "IRQ fires while CS=0x08 (ring 0):"
    tk2: "  CPU does NOT switch stacks"
    tk3: "  CPU does NOT read TSS.ESP0"
    tk4: "  Pushes 3-field frame: EFLAGS CS EIP only"
    tk5: "  user_esp and user_ss NOT pushed"
    tk6: "TSS.ESP0 still updated before context_switch_asm:"
    tk7: "  Next IRQ might arrive with ring-3 process scheduled"
    tk8: "  tss_set_kernel_stack() called BEFORE context_switch_asm()"
  }

  tss_user: "User Process (ring 3) - TSS.ESP0 is critical path" {
    style.fill: "#3d1a00"
    style.stroke: "#cc6600"
    style.font-color: "#ffaa44"
    style.border-radius: 6
    tu1: "IRQ fires while CS=0x1B (ring 3):"
    tu2: "  CPU reads TSS.ESP0   kernel stack pointer"
    tu3: "  CPU reads TSS.SS0    0x10 kernel data"
    tu4: "  CPU switches to kernel stack"
    tu5: "  Pushes 5-field frame: SS ESP EFLAGS CS EIP"
    tu6: "Wrong TSS.ESP0 = silent stack corruption:"
    tu7: "  Frame written to old process stack"
    tu8: "  Crash surfaces far from context switch site"
  }
}

scheduler: "Preemptive Round-Robin Scheduler" {
  style: {
    fill: "#0a0a1a"
    stroke: "#3355aa"
    stroke-width: 2
    border-radius: 8
    font-color: "#88aaff"
  }

  timer_irq: "PIT IRQ0 -> timer_handler() every 10ms at 100Hz" {
    style.fill: "#050512"
    style.stroke: "#2244aa"
    style.font-color: "#7799ff"
    style.border-radius: 4
    ti1: "pit_tick_count++"
    ti2: "sched_tick():"
    ti3: "  current_process->ticks_remaining--"
    ti4: "  if ticks_remaining == 0: sched_schedule()"
  }

  sched_fn: "sched_schedule() - context switch sequence" {
    style.fill: "#080818"
    style.stroke: "#1133aa"
    style.font-color: "#6688ff"
    style.border-radius: 4
    sf1: "1. scan process_table for next PROCESS_READY"
    sf2: "2. old->state = PROCESS_READY"
    sf3: "3. next->state = PROCESS_RUNNING"
    sf4: "4. next->ticks_remaining = 5"
    sf5: "5. current_process = next"
    sf6: "6. tss_set_kernel_stack(next->kernel_stack_top)"
    sf7: "7. context_switch_asm(and old->cpu.esp, next->cpu.esp, next->page_directory)"
  }
}

before_after: "BEFORE vs AFTER: Switching Process A to Process B" {
  style: {
    fill: "#0a0a0a"
    stroke: "#444444"
    stroke-width: 2
    border-radius: 8
    font-color: "#cccccc"
  }

  before_state: "BEFORE switch (Process A running)" {
    style.fill: "#001a00"
    style.stroke: "#006600"
    style.border-radius: 6
    style.font-color: "#88ff88"
    bs1: "CR3      = boot_page_directory (0x00103000)"
    bs2: "ESP      = proc_a.kernel_stack + 3984"
    bs3: "CS       = 0x08  ring-0"
    bs4: "EIP      = 0x001003A4  inside proc_a busy-loop"
    bs5: "TSS.ESP0 = proc_a.kernel_stack_top"
    bs6: "VGA row 2:  Process A: 42738  (A just wrote)"
    bs7: "VGA row 12: Process B: 11203  (frozen, B paused)"
  }

  after_state: "AFTER switch (Process B running)" {
    style.fill: "#1a0000"
    style.stroke: "#660000"
    style.border-radius: 6
    style.font-color: "#ff8888"
    as1: "CR3      = boot_page_directory (UNCHANGED, no TLB flush)"
    as2: "ESP      = proc_b.kernel_stack + 3984"
    as3: "CS       = 0x08  ring-0"
    as4: "EIP      = 0x001005B8  B resumes exactly here"
    as5: "TSS.ESP0 = proc_b.kernel_stack_top  (updated)"
    as6: "B executes: vga[12*80+i] = ch | (0x0C<<8)"
    as7: "Physical write to 0xB8780 visible immediately"
    as8: "VGA row 12: Process B: 11204  (incremented)"
    as9: "VGA row 2:  Process A: 42738  (frozen, A paused)"
  }
}

processes.proc_a -> page_dir: "page_directory = boot_pd (shared CR3=0x00103000)" {
  style.stroke: "#00cc00"
  style.stroke-width: 2
  style.font-color: "#00cc00"
}

processes.proc_b -> page_dir: "page_directory = boot_pd (shared CR3=0x00103000)" {
  style.stroke: "#cc0000"
  style.stroke-width: 2
  style.font-color: "#cc0000"
}

processes.proc_c -> page_dir: "page_directory = boot_pd (shared CR3=0x00103000)" {
  style.stroke: "#cc8800"
  style.stroke-width: 2
  style.font-color: "#cc8800"
}

page_dir.pd_entry0 -> vga_buffer: "PTE[0xB8]: phys 0x000B8000 VGA MMIO (P=1 R/W=1 U/S=0)" {
  style.stroke: "#9933ff"
  style.stroke-width: 2
  style.animated: true
  style.font-color: "#bb77ff"
}

processes.proc_a -> vga_buffer.vga_region_a: "vga[2*80+i] = ch | 0x0A00 (green, rows 0-7)" {
  style.stroke: "#00cc00"
  style.stroke-width: 3
  style.animated: true
  style.font-color: "#00cc00"
}

processes.proc_b -> vga_buffer.vga_region_b: "vga[12*80+i] = ch | 0x0C00 (red, rows 8-15)" {
  style.stroke: "#cc0000"
  style.stroke-width: 3
  style.animated: true
  style.font-color: "#cc0000"
}

processes.proc_c -> vga_buffer.vga_region_c: "vga[22*80+i] = ch | 0x0E00 (yellow, rows 16-24)" {
  style.stroke: "#cc8800"
  style.stroke-width: 3
  style.animated: true
  style.font-color: "#cc8800"
}

scheduler.timer_irq -> scheduler.sched_fn: "ticks_remaining==0 triggers schedule()" {
  style.stroke: "#5566cc"
  style.font-color: "#8899ff"
}

scheduler.sched_fn -> tss: "tss_set_kernel_stack(next->kernel_stack_top) BEFORE context_switch_asm" {
  style.stroke: "#aaaa00"
  style.stroke-width: 2
  style.font-color: "#ffff55"
}

scheduler -> processes.proc_a: "dispatch A (slice expires, switch away)" {
  style.stroke: "#00aa00"
  style.stroke-dash: 3
  style.font-color: "#00aa00"
}

scheduler -> processes.proc_b: "dispatch B (next READY in table)" {
  style.stroke: "#aa0000"
  style.stroke-dash: 3
  style.font-color: "#aa0000"
}

scheduler -> processes.proc_c: "dispatch C (next READY in table)" {
  style.stroke: "#aa7700"
  style.stroke-dash: 3
  style.font-color: "#aa7700"
}

scheduler.sched_fn -> page_dir.cr3_note: "cmp cr3,next_pd; je .same (taken for kernel->kernel)" {
  style.stroke: "#7700cc"
  style.stroke-dash: 5
  style.font-color: "#9933ff"
}

before_after.before_state -> processes.proc_a: "A was running" {
  style.stroke: "#006600"
  style.stroke-dash: 3
}

before_after.after_state -> processes.proc_b: "B now running" {
  style.stroke: "#660000"
  style.stroke-dash: 3
}

tss.tss_kernel -> processes.proc_a: "ring-0 IRQ: CPU ignores TSS.ESP0 but kernel still updates it" {
  style.stroke: "#007700"
  style.stroke-dash: 5
  style.font-color: "#009900"
}