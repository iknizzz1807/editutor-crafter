vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |'md
  # x86 Privilege Rings: Ring 0 to Ring 3 Full Picture

  **Hardware-enforced privilege hierarchy — CPL bits in CS register [1:0]**
'| {near: top-center}

ring0: "Ring 0 — Kernel (CPL=00)" {
  style: {
    fill: "#3d0000"
    stroke: "#ff4444"
    stroke-width: 4
    font-color: "#ff8888"
    font-size: 18
    bold: true
    border-radius: 8
    shadow: true
  }

  r0_instrs: |'md
    **Legal Instructions (ring 0 only)**

    - HLT — halt CPU until next interrupt
    - LGDT / LIDT — load GDT / IDT register
    - LTR — load Task Register (TSS)
    - MOV CRn — read/write CR0 CR2 CR3 CR4
    - MOV DRn — read/write debug registers
    - RDMSR / WRMSR — model-specific registers
    - CLTS — clear task-switched flag (CR0.TS)
    - INVLPG — invalidate TLB entry
    - INVD / WBINVD — cache invalidation
    - IN / OUT — I/O port access (any port)
    - STI / CLI — set/clear interrupt flag
    - LMSW — load machine status word
'| {
    style: {
      fill: "#5a0000"
      stroke: "#cc3333"
      border-radius: 6
      font-color: "#ffcccc"
      font-size: 13
    }
  }

  r0_cr0: "CR0 — Machine Control" {
    style: {
      fill: "#8b0000"
      stroke: "#cc0000"
      font-color: "#ffbbbb"
      border-radius: 4
    }
    info: |'md
      **CR0** — Machine Control Register

      - Bit 0: PE — Protection Enable
      - Bit 16: WP — Write Protect
      - Bit 31: PG — Paging Enable

      Setting CR0.PG enables MMU
'|
  }

  r0_cr3: "CR3 — Page Directory Base" {
    style: {
      fill: "#8b0000"
      stroke: "#cc0000"
      font-color: "#ffbbbb"
      border-radius: 4
    }
    info: |'md
      **CR3** — Page Directory Base Register

      - Bits 31-12: Physical addr of PD
      - Writing CR3 flushes TLB
      - Per-process: changed on every context switch
'|
  }

  r0_cr4: "CR4 — Feature Control" {
    style: {
      fill: "#8b0000"
      stroke: "#cc0000"
      font-color: "#ffbbbb"
      border-radius: 4
    }
    info: |'md
      **CR4** — Feature Control Register

      - Bit 4: PSE (4MB pages)
      - Bit 5: PAE
      - Bit 7: PGE (global pages)
      - Bit 9: OSFXSR (SSE)
      - Bit 20: SMEP (exec prevention)
      - Bit 21: SMAP (access prevention)
'|
  }

  r0_cr2: "CR2 — Page Fault Address" {
    style: {
      fill: "#8b0000"
      stroke: "#cc0000"
      font-color: "#ffbbbb"
      border-radius: 4
    }
    info: |'md
      **CR2** — Page Fault Linear Address

      - CPU writes faulting vaddr on every page fault (exc 14)
      - Read immediately in PF handler before any nested fault
'|
  }

  r0_kernel_code: |'md
    **Kernel Code Running at Ring 0**

    - Bootloader GDT/IDT setup (Milestone 1)
    - Interrupt handlers / ISRs (Milestone 2)
    - Physical/virtual memory manager (Milestone 3)
    - Scheduler and context switch (Milestone 4)
    - Device drivers: VGA serial PIT PS/2
    - syscall dispatcher (INT 0x80 handler)
'| {
    style: {
      fill: "#5a0000"
      stroke: "#cc3333"
      border-radius: 6
      font-color: "#ffdddd"
      font-size: 13
    }
  }

  r0_io: |'md
    **I/O Port Access — Ring 0 Unrestricted**

    - 0x20 / 0xA0 — 8259 PIC master/slave
    - 0x40-0x43 — PIT 8253/8254 timer
    - 0x60 / 0x64 — PS/2 keyboard controller
    - 0x3F8-0x3FF — COM1 UART (serial debug)
    - 0x3C0-0x3DA — VGA registers
    - 0xCF8 / 0xCFC — PCI config space

    IN AL,DX and OUT DX,AL at ring 0: always legal
'| {
    style: {
      fill: "#6b0000"
      stroke: "#dd2222"
      font-color: "#ffaaaa"
      border-radius: 4
      font-size: 13
    }
  }
}

ring12: "Ring 1 and Ring 2 — Unused in Modern OS Design" {
  style: {
    fill: "#1a1a3d"
    stroke: "#6666cc"
    stroke-width: 3
    stroke-dash: 5
    font-color: "#9999dd"
    font-size: 15
    border-radius: 8
  }

  r12_history: |'md
    **Original Intel Design Intent (386 era, 1985)**

    - Ring 1: OS services and device drivers
    - Ring 2: Trusted system libraries
    - Hierarchical: ring N can access rings above N
    - Never adopted by Unix, Windows NT, or Linux
'| {
    style: {
      fill: "#2a2a5a"
      stroke: "#5555aa"
      font-color: "#aaaaee"
      border-radius: 4
    }
  }

  r12_skipped: |'md
    **Why Skipped by Major OSes?**

    - Portability: ARM MIPS RISC-V have no intermediate rings
    - Unix philosophy: kernel/user binary split is sufficient
    - Complexity: DPL=1/2 GDT entries and call gates needed
    - Modern replacement: VMX root mode below ring 0
    - Today: ring 1/2 GDT entries absent from Linux GDT
    - Windows NT designed for portability: skipped rings 1/2
'| {
    style: {
      fill: "#2a2a5a"
      stroke: "#5555aa"
      font-color: "#ccccff"
      border-radius: 4
      italic: true
    }
  }

  r12_vmx: |'md
    **VMX Root Mode — Ring minus 1 (Intel VT-x)**

    Hypervisors VMware KVM Hyper-V run BELOW ring 0.
    Guest OS ring 0 runs in VMX non-root mode.
    Privileged instructions trigger VM exits to hypervisor.
    QEMU/KVM: guest CR3 writes go through EPT.
    EPT: guest-physical to host-physical addr in HW.
'| {
    style: {
      fill: "#1a2a4a"
      stroke: "#4455aa"
      font-color: "#99aadd"
      border-radius: 4
      italic: true
    }
  }
}

ring3: "Ring 3 — User Mode (CPL=11)" {
  style: {
    fill: "#003d00"
    stroke: "#44cc44"
    stroke-width: 4
    font-color: "#88ff88"
    font-size: 18
    bold: true
    border-radius: 8
    shadow: true
  }

  r3_forbidden: |'md
    **Forbidden Instructions — cause GPF (Exception 13)**

    - HLT — General Protection Fault immediately
    - LGDT / LIDT / LTR — GPF
    - MOV CR0 / MOV CR3 / MOV CR4 — GPF
    - RDMSR / WRMSR — GPF
    - INVLPG — GPF
    - CLI / STI — GPF (unless IOPL=3)
    - IN / OUT if IOPL less than CPL=3 — GPF

    CPU checks CPL vs DPL on every privileged instruction
'| {
    style: {
      fill: "#004400"
      stroke: "#338833"
      border-radius: 6
      font-color: "#aaffaa"
      font-size: 13
    }
  }

  r3_legal: |'md
    **Legal User-Mode Operations**

    - All arithmetic logic and branch instructions
    - Memory read/write within mapped permitted pages
    - INT n — if IDT gate DPL >= CPL (else GPF)
    - INT 0x80 — syscall gate (IDT DPL=3 trap gate)
    - SYSCALL / SYSENTER — fast syscall path
    - FPU / SSE / AVX instructions
    - CPUID — no privilege required
    - RDTSC — unless CR4.TSD=1
'| {
    style: {
      fill: "#004400"
      stroke: "#338833"
      border-radius: 6
      font-color: "#ccffcc"
      font-size: 13
    }
  }

  r3_code: |'md
    **User Processes Running at Ring 3**

    - Application code: C Rust Python interpreter etc.
    - Shell text editors web browsers
    - Docker containers (Linux namespaces: still ring 3)
    - QEMU TCG: guest ring-0 code runs in HOST ring-3
    - Privileged instruction causes SIGSEGV caught by QEMU
    - QEMU emulates the effect and resumes guest at next instr
'| {
    style: {
      fill: "#004400"
      stroke: "#228822"
      border-radius: 6
      font-color: "#ddffdd"
      font-size: 13
    }
  }

  r3_memory: |'md
    **Memory Isolation via Page Table U/S Bit (PTE bit 2)**

    - U/S = 0 (Supervisor): ring 0 only; ring 3 access causes PF
    - U/S = 1 (User): rings 0-3 accessible

    Page fault error code bit 2 = 1 means user-mode violation.
    CR2 holds faulting virtual address.

    SMEP (CR4 bit 20): ring-3 cannot EXECUTE U/S=0 pages.
    Blocks ret2usr: attacker jumps kernel EIP to user shellcode.

    SMAP (CR4 bit 21): ring-0 cannot READ U/S=1 pages without STAC.
    Blocks kernel accidentally dereferencing user pointers.

    KPTI: user page directory has NO kernel mappings.
    Double CR3 swap per syscall — Meltdown mitigation.
'| {
    style: {
      fill: "#003300"
      stroke: "#226622"
      border-radius: 6
      font-color: "#bbffbb"
      font-size: 13
    }
  }
}

gdt_encoding: "GDT Selector and DPL Encoding" {
  style: {
    fill: "#1a1a00"
    stroke: "#cccc00"
    stroke-width: 3
    font-color: "#ffff88"
    font-size: 16
    bold: true
    border-radius: 8
  }

  selector_layout: |'md
    **16-bit Segment Selector Layout**

    Bits 15-3 = Index into GDT (0 = null descriptor)
    Bit  2    = TI: 0=GDT 1=LDT
    Bits 1-0  = RPL: Requested Privilege Level (0-3)

    Kernel CS = 0x08 = index 1 TI=0 RPL=0 — CPL becomes 0
    Kernel DS = 0x10 = index 2 TI=0 RPL=0
    User CS   = 0x1B = index 3 TI=0 RPL=3 — CPL becomes 3
    User DS   = 0x23 = index 4 TI=0 RPL=3
    TSS sel   = 0x28 = index 5 TI=0 RPL=0
'| {
    style: {
      fill: "#2a2a00"
      stroke: "#aaaa00"
      border-radius: 4
      font-color: "#ffffaa"
      font-size: 13
    }
  }

  dpl_rules: |'md
    **DPL Field in GDT Descriptor (Access Byte bits 6:5)**

    Access byte: P | DPL[1:0] | S | Type[3:0]

    DPL = 0: only ring 0 can load this selector.
    DPL = 3: any ring can load this selector.
    GDT enforcement: if CPL > DPL of descriptor — GPF.

    IDT gate DPL enforcement (for INT n):
    If CPL > IDT gate DPL — GPF.
    INT 0x80 gate DPL=3: user mode can invoke it.
    IRQ handler gates DPL=0: only hardware/ring-0 can invoke.
'| {
    style: {
      fill: "#2a2a00"
      stroke: "#aaaa00"
      border-radius: 4
      font-color: "#ffffcc"
      font-size: 13
    }
  }

  cpl_tracking: |'md
    **CPL = Current Privilege Level = CS bits 1:0**

    CPU tracks CPL continuously during execution.
    CPL changes only on: iret far-jump SYSCALL SYSENTER.

    Ring 3 to Ring 0 path:
    INT/exception fires — CPU reads TSS.ESP0.
    Loads kernel SS:ESP from TSS.
    Pushes old SS ESP EFLAGS CS EIP onto kernel stack.
    Loads CS from IDT gate — CPL becomes 0.

    Ring 0 to Ring 3 path:
    IRET pops EIP CS EFLAGS.
    Detects CS.RPL=3 > current CPL=0 — privilege transition.
    Pops user ESP SS — switches back to user stack.
    CPL becomes 3 atomically with EFLAGS restore (IF bit).
'| {
    style: {
      fill: "#2a2a00"
      stroke: "#aaaa00"
      border-radius: 4
      font-color: "#ffffd0"
      font-size: 13
    }
  }
}

transitions: "Ring Transition Mechanics" {
  style: {
    fill: "#001a2a"
    stroke: "#4488cc"
    stroke-width: 3
    font-color: "#88ccff"
    font-size: 16
    bold: true
    border-radius: 8
  }

  r3_to_r0: "Ring 3 to Ring 0: Interrupt / Exception / Syscall" {
    style: {
      fill: "#002233"
      stroke: "#336699"
      font-color: "#aaddff"
      border-radius: 4
    }
    details: |'md
      **Hardware steps (~150 cycles + DRAM for TSS):**

      1. Check IDT gate DPL >= CPL (else GPF immediately)
      2. Read TSS.ESP0 and TSS.SS0 from TSS in physical memory
      3. Switch stack: SS = TSS.SS0 (0x10) ESP = TSS.ESP0
      4. Push onto new kernel stack (top to bottom):
         SS_user ESP_user EFLAGS CS_user EIP error_code
      5. Load CS from IDT gate descriptor — CPL becomes 0
      6. Load EIP from IDT gate offset — jump to handler
'|
  }

  r0_to_r3: "Ring 0 to Ring 3: IRET" {
    style: {
      fill: "#002233"
      stroke: "#336699"
      font-color: "#aaddff"
      border-radius: 4
    }
    details: |'md
      **IRET restores (privilege change when CS.RPL > CPL):**

      1. Pop EIP CS EFLAGS from kernel stack
      2. Detect CS.RPL=3 > current CPL=0 — privilege transition
      3. Pop ESP_user and SS_user from kernel stack
      4. Load SS:ESP with user stack values — stack switches
      5. Load CS with user code selector — CPL becomes 3
      6. Load EFLAGS atomically including IF bit
      7. Jump to EIP in user address space

      CRITICAL: EFLAGS.IF must be 1 in saved frame.
      IF=0 in saved frame means timer never fires and system freezes.
'|
  }

  fast_path: "Fast Syscall: SYSENTER and SYSCALL" {
    style: {
      fill: "#002233"
      stroke: "#336699"
      font-color: "#aaddff"
      border-radius: 4
    }
    details: |'md
      **SYSENTER (32-bit) — bypasses IDT no TSS stack lookup:**

      CS  = IA32_SYSENTER_CS MSR (ring 0 code segment)
      EIP = IA32_SYSENTER_EIP MSR (kernel entry point)
      ESP = IA32_SYSENTER_ESP MSR (kernel stack pointer)
      Cost: ~100 cycles (no TSS lookup no IDT walk)

      **SYSCALL (64-bit) — even faster:**

      RIP = IA32_LSTAR MSR
      RFLAGS masked by IA32_FMASK MSR
      Cost: ~70 cycles

      **vDSO (virtual dynamic shared object): ~20 cycles**

      Kernel maps read-only page into every user address space.
      gettimeofday reads TSC directly in user space.
      Zero ring transitions — no CPL change at all.
'|
  }
}

qemu_tcg: "QEMU TCG: Guest Ring 0 in Host Ring 3" {
  style: {
    fill: "#1a001a"
    stroke: "#cc44cc"
    stroke-width: 3
    font-color: "#dd88ff"
    font-size: 15
    bold: true
    border-radius: 8
    stroke-dash: 4
  }

  tcg_model: |'md
    **QEMU Tiny Code Generator — software emulation mode**

    Host OS: Linux ring 3 (QEMU is a normal user process).
    Guest: your x86 kernel including ring 0 code.

    Translation flow for privileged guest instruction:

    1. Guest ring-0 instruction fetched e.g. MOV CR3,EAX
    2. TCG detects privileged opcode during translation
    3. Generates host code calling QEMU helper function
    4. Helper emulates the effect (updates virtual CR3)
    5. Guest execution continues at next guest instruction

    Guest HLT: QEMU pauses vCPU thread until virtual IRQ.
    Guest LGDT: QEMU updates internal GDT base/limit vars.
    Guest INT 0x80: QEMU dispatches through guest IDT.
'| {
    style: {
      fill: "#2a002a"
      stroke: "#993399"
      border-radius: 4
      font-color: "#eeccff"
      font-size: 13
    }
  }

  kvm_contrast: |'md
    **KVM mode (hardware virtualization VMX/SVM):**

    Guest ring 0 actually runs on physical CPU in VMX non-root.
    Privileged instruction causes VM exit trapped by KVM.
    MOV CR3 in guest: updates VMCS guest CR3 not host CR3.
    EPT: guest-physical to host-physical HW walk.
    Speed: 10-30x faster than TCG for compute-bound workloads.

    Check /dev/kvm on your machine.
    QEMU flag -enable-kvm activates hardware virtualization.
    Without it: falls back to TCG (pure software emulation).
'| {
    style: {
      fill: "#2a002a"
      stroke: "#993399"
      border-radius: 4
      font-color: "#ddbbff"
      font-size: 13
    }
  }
}

mitigations: "SMEP / SMAP / KPTI Hardware Security" {
  style: {
    fill: "#001a00"
    stroke: "#228822"
    stroke-width: 2
    font-color: "#66bb66"
    font-size: 14
    bold: true
    border-radius: 8
  }

  smep_box: "SMEP — Supervisor Mode Execution Prevention" {
    style: {
      fill: "#002200"
      stroke: "#116611"
      font-color: "#aaddaa"
      border-radius: 4
    }
    detail: |'md
      CR4 bit 20. Ring-0 CANNOT execute pages with U/S=1.

      Prevents ret2usr: attacker jumps kernel EIP to user shellcode.
      If ring-0 EIP lands on U/S=1 page: page fault exception 14.
      Set CR4.SMEP=1 during kernel init after page tables configured.
'|
  }

  smap_box: "SMAP — Supervisor Mode Access Prevention" {
    style: {
      fill: "#002200"
      stroke: "#116611"
      font-color: "#aaddaa"
      border-radius: 4
    }
    detail: |'md
      CR4 bit 21. Ring-0 CANNOT read/write U/S=1 pages without STAC.

      Prevents kernel dereferencing unvalidated user pointers.
      copy_from_user() wraps copy with STAC and CLAC instructions.
      Without SMAP: kernel reads user memory enabling Spectre gadgets.
'|
  }

  kpti_box: "KPTI — Kernel Page Table Isolation (Meltdown)" {
    style: {
      fill: "#002200"
      stroke: "#116611"
      font-color: "#cceecc"
      border-radius: 4
    }
    detail: |'md
      User mode runs with shadow page dir: almost no kernel mappings.
      Only syscall entry trampoline mapped in user page directory.
      Ring-3 to ring-0: swap CR3 to full kernel page directory.
      Ring-0 to ring-3: swap CR3 back to user shadow page directory.
      Cost: 2x CR3 reloads per syscall = 5-30% overhead.
      Meltdown used speculative exec to read kernel mem via cache timing.
      KPTI removes kernel mappings so nothing to speculate on.
'|
  }
}

legend: Legend {
  near: bottom-right
  style: {
    fill: "#111111"
    stroke: "#555555"
    stroke-width: 1
    font-color: "#aaaaaa"
    border-radius: 6
    font-size: 12
  }
  content: |'md
    Red border = Ring 0 kernel CPL=00

    Blue dashed = Ring 1/2 unused CPL=01/10

    Green border = Ring 3 user CPL=11

    Yellow = GDT selector encoding

    Blue = Ring transition mechanics

    Purple dashed = Virtualization QEMU/KVM

    Dark green = Hardware security mitigations

    GPF = General Protection Fault exception 13

    CPL = Current Privilege Level = CS bits 1:0

    DPL = Descriptor Privilege Level in GDT/IDT entry

    RPL = Requested Privilege Level in segment selector
'|
}

ring3.r3_forbidden -> ring0: "GPF exception 13\nCPL=3 > DPL=0 detected\nNo ring-3 handler causes triple fault" {
  style: {
    stroke: "#ff4444"
    stroke-width: 3
    animated: true
    font-color: "#ff8888"
    font-size: 12
    stroke-dash: 4
  }
}

ring3.r3_legal -> transitions.r3_to_r0: "INT 0x80 or hardware exception\nCPL=3 gate DPL=3 permitted\nTSS.ESP0 read for kernel stack switch" {
  style: {
    stroke: "#44aaff"
    stroke-width: 2
    animated: true
    font-color: "#88ccff"
    font-size: 12
  }
}

transitions.r3_to_r0 -> ring0: "CPU pushes SS ESP EFLAGS CS EIP\nloads kernel CS=0x08\nCPL becomes 0 jumps to IDT handler" {
  style: {
    stroke: "#4488ff"
    stroke-width: 2
    font-color: "#99bbff"
    font-size: 12
  }
}

ring0 -> transitions.r0_to_r3: "IRET instruction\nrestores EIP CS EFLAGS ESP SS\nCPL becomes 3 when CS.RPL=3" {
  style: {
    stroke: "#44cc44"
    stroke-width: 2
    animated: true
    font-color: "#88ff88"
    font-size: 12
  }
}

transitions.r0_to_r3 -> ring3: "User code resumes at saved EIP\nStack pointer restored from saved ESP\nIF bit restored from saved EFLAGS" {
  style: {
    stroke: "#44cc44"
    stroke-width: 2
    font-color: "#88ff88"
    font-size: 12
  }
}

ring0.r0_cr3 -> ring3.r3_memory: "CR3 loaded on every context switch\nPage directory enforces U/S bits\nRing-3 access to U/S=0 page causes PF" {
  style: {
    stroke: "#cc8800"
    stroke-width: 2
    font-color: "#ffbb44"
    font-size: 11
    stroke-dash: 3
  }
}

gdt_encoding -> ring0: "GDT entry DPL=0\nOnly CPL=0 can load\nkernel CS=0x08 DS=0x10" {
  style: {
    stroke: "#cccc00"
    stroke-width: 2
    font-color: "#eeee44"
    font-size: 11
  }
}

gdt_encoding -> ring3: "GDT entry DPL=3\nAny CPL can load\nuser CS=0x1B DS=0x23" {
  style: {
    stroke: "#cccc00"
    stroke-width: 2
    font-color: "#eeee44"
    font-size: 11
  }
}

qemu_tcg -> ring12: "TCG: guest ring-0 runs in host ring-3\nPrivileged instr intercepted by QEMU helper\nEffect emulated then guest resumes" {
  style: {
    stroke: "#cc44cc"
    stroke-width: 2
    stroke-dash: 5
    font-color: "#ee88ff"
    font-size: 11
    animated: true
  }
}

mitigations -> ring0.r0_cr4: "SMEP SMAP set in CR4 by ring-0\nKPTI: double CR3 swap per syscall\nAll enforced at kernel init time" {
  style: {
    stroke: "#228844"
    stroke-width: 2
    font-color: "#66bb66"
    font-size: 11
  }
}

ring3.r3_memory -> mitigations: "SMEP blocks user-page exec from ring-0\nSMAP blocks kernel deref of user ptr\nKPTI removes kernel from user page dir" {
  style: {
    stroke: "#228844"
    stroke-width: 1
    stroke-dash: 3
    font-color: "#55aa55"
    font-size: 11
  }
}

transitions.fast_path -> ring0: "SYSENTER/SYSCALL MSR-configured entry\nNo IDT walk no TSS lookup\n70-100 cycles vs 500 cycles for INT 0x80" {
  style: {
    stroke: "#4488cc"
    stroke-width: 2
    font-color: "#88bbee"
    font-size: 11
  }
}