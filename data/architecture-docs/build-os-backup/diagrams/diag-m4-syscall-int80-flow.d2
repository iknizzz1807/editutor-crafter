vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |'md
  # System Call: INT 0x80 — User Mode to Kernel Handler (sys\_write)
'| {near: top-center}

userspace: "USER PROCESS (Ring 3 — CPL=3)" {
  style: {
    fill: "#0d2137"
    stroke: "#74c0fc"
    stroke-width: 3
    font-color: "#74c0fc"
    border-radius: 8
    bold: true
  }

  regs_before: "CPU Registers BEFORE int 0x80" {
    style: {
      fill: "#0a2040"
      stroke: "#74c0fc"
      stroke-width: 2
      border-radius: 6
      font-color: "#74c0fc"
    }
    grid-columns: 2
    grid-gap: 4

    eax_lbl: "EAX = 4" {
      style.fill: "#1a3a5c"
      style.stroke: "#74c0fc"
      style.font-color: "#74c0fc"
      style.bold: true
    }
    eax_desc: "syscall number: sys_write" {
      style.fill: "#0d2137"
      style.stroke: "#444"
      style.font-color: "#adb5bd"
    }
    ebx_lbl: "EBX = 1" {
      style.fill: "#1a3a5c"
      style.stroke: "#74c0fc"
      style.font-color: "#74c0fc"
      style.bold: true
    }
    ebx_desc: "arg1: fd = stdout" {
      style.fill: "#0d2137"
      style.stroke: "#444"
      style.font-color: "#adb5bd"
    }
    ecx_lbl: "ECX = 0x00401020" {
      style.fill: "#1a3a5c"
      style.stroke: "#74c0fc"
      style.font-color: "#74c0fc"
      style.bold: true
    }
    ecx_desc: "arg2: buf virtual addr" {
      style.fill: "#0d2137"
      style.stroke: "#444"
      style.font-color: "#adb5bd"
    }
    edx_lbl: "EDX = 6" {
      style.fill: "#1a3a5c"
      style.stroke: "#74c0fc"
      style.font-color: "#74c0fc"
      style.bold: true
    }
    edx_desc: "arg3: byte count" {
      style.fill: "#0d2137"
      style.stroke: "#444"
      style.font-color: "#adb5bd"
    }
    cs_lbl: "CS = 0x1B" {
      style.fill: "#2d1b4e"
      style.stroke: "#cc5de8"
      style.font-color: "#cc5de8"
      style.bold: true
    }
    cs_desc: "ring 3 code selector (RPL=3)" {
      style.fill: "#0d2137"
      style.stroke: "#444"
      style.font-color: "#adb5bd"
    }
    esp_lbl: "ESP = 0x00BFFFF0" {
      style.fill: "#1a3a5c"
      style.stroke: "#74c0fc"
      style.font-color: "#74c0fc"
      style.bold: true
    }
    esp_desc: "user-mode stack pointer" {
      style.fill: "#0d2137"
      style.stroke: "#444"
      style.font-color: "#adb5bd"
    }
    eflags_lbl: "EFLAGS = 0x0202" {
      style.fill: "#1a3a5c"
      style.stroke: "#74c0fc"
      style.font-color: "#74c0fc"
      style.bold: true
    }
    eflags_desc: "IF=1 (interrupts on)" {
      style.fill: "#0d2137"
      style.stroke: "#444"
      style.font-color: "#adb5bd"
    }
  }

  int_instr: "int 0x80 — THE CROSSING POINT" {
    style: {
      fill: "#4a0010"
      stroke: "#ff6b6b"
      stroke-width: 4
      font-color: "#ff6b6b"
      bold: true
      border-radius: 6
      font-size: 16
    }
  }

  regs_after: "CPU Registers AFTER iret (back in ring 3)" {
    style: {
      fill: "#0d2137"
      stroke: "#51cf66"
      stroke-width: 2
      border-radius: 6
      font-color: "#51cf66"
    }
    grid-columns: 2
    grid-gap: 4
    ea: "EAX = 6" {style.fill: "#1a3320"; style.stroke: "#51cf66"; style.font-color: "#51cf66"; style.bold: true}
    ead: "return value: bytes written" {style.fill: "#0d2137"; style.stroke: "#444"; style.font-color: "#51cf66"}
    eip_a: "EIP = 0x00401025" {style.fill: "#1a3320"; style.stroke: "#51cf66"; style.font-color: "#51cf66"; style.bold: true}
    eip_d: "resumes after int 0x80" {style.fill: "#0d2137"; style.stroke: "#444"; style.font-color: "#51cf66"}
    esp_a: "ESP = 0x00BFFFF0" {style.fill: "#1a3320"; style.stroke: "#51cf66"; style.font-color: "#51cf66"; style.bold: true}
    esp_d: "user stack restored by iret" {style.fill: "#0d2137"; style.stroke: "#444"; style.font-color: "#adb5bd"}
    cs_a: "CS = 0x1B" {style.fill: "#2d1b4e"; style.stroke: "#cc5de8"; style.font-color: "#cc5de8"; style.bold: true}
    cs_d: "ring 3 restored by iret" {style.fill: "#0d2137"; style.stroke: "#444"; style.font-color: "#adb5bd"}
  }
}

cpu_hw: "CPU HARDWARE — Ring Transition Logic" {
  style: {
    fill: "#1a0a2e"
    stroke: "#cc5de8"
    stroke-width: 3
    font-color: "#cc5de8"
    border-radius: 8
    bold: true
  }

  step1_dpl: "Step 1: DPL Check — IDT[0x80].DPL=3 >= CPL=3 — PERMITTED" {
    style: {
      fill: "#1a3320"
      stroke: "#51cf66"
      stroke-width: 2
      font-color: "#51cf66"
      border-radius: 4
    }
  }

  step2_tss: "Step 2: Read TSS.SS0 and TSS.ESP0 — Find Kernel Stack" {
    style: {
      fill: "#2d1b4e"
      stroke: "#cc5de8"
      stroke-width: 2
      font-color: "#cc5de8"
      border-radius: 4
    }
  }

  tss_detail: "TSS (Task State Segment) — hardware-defined 104-byte struct" {
    style: {
      fill: "#1e1035"
      stroke: "#cc5de8"
      stroke-width: 2
      font-color: "#cc5de8"
      border-radius: 6
    }
    grid-columns: 2
    grid-gap: 2

    f1: "SS0 = 0x10" {style.fill: "#2d1b4e"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"}
    f1d: "kernel data selector" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    f2: "ESP0 = 0xC001FFFF" {style.fill: "#2d1b4e"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}
    f2d: "CPU loads THIS as new ESP" {style.fill: "#111"; style.font-color: "#ff6b6b"; style.stroke: "#333"; style.bold: true}
    f3: "iomap_base = sizeof(TSS)" {style.fill: "#1a1a2e"; style.font-color: "#666"; style.stroke: "#333"}
    f3d: "all I/O restricted ring 3" {style.fill: "#111"; style.font-color: "#666"; style.stroke: "#333"}
  }

  step3_push: "Step 3: Switch ESP to TSS.ESP0 then push 5-field ring-crossing frame" {
    style: {
      fill: "#3a1000"
      stroke: "#ff6b6b"
      stroke-width: 2
      font-color: "#ff6b6b"
      border-radius: 4
    }
  }

  kernel_stack_frame: "Kernel Stack After CPU Push (grows downward)" {
    style: {
      fill: "#1a0a0e"
      stroke: "#ff6b6b"
      stroke-width: 2
      font-color: "#ff6b6b"
      border-radius: 6
    }
    grid-columns: 3
    grid-gap: 2

    h_addr: "Address" {style.fill: "#2a0a10"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true; style.underline: true}
    h_val: "Value Pushed" {style.fill: "#2a0a10"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true; style.underline: true}
    h_note: "Note" {style.fill: "#2a0a10"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true; style.underline: true}

    a1: "ESP0 - 4" {style.fill: "#111"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
    v1: "SS = 0x23" {style.fill: "#111"; style.font-color: "#74c0fc"; style.stroke: "#333"; style.bold: true}
    n1: "user stack segment" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#222"}

    a2: "ESP0 - 8" {style.fill: "#111"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
    v2: "ESP = 0x00BFFFF0" {style.fill: "#111"; style.font-color: "#74c0fc"; style.stroke: "#333"; style.bold: true}
    n2: "user stack ptr saved" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#222"}

    a3: "ESP0 - 12" {style.fill: "#111"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
    v3: "EFLAGS = 0x0202" {style.fill: "#111"; style.font-color: "#74c0fc"; style.stroke: "#333"; style.bold: true}
    n3: "flags incl. IF=1" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#222"}

    a4: "ESP0 - 16" {style.fill: "#111"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
    v4: "CS = 0x1B" {style.fill: "#111"; style.font-color: "#74c0fc"; style.stroke: "#333"; style.bold: true}
    n4: "ring-3 code selector" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#222"}

    a5: "ESP0-20 (ESP now)" {style.fill: "#2a0a10"; style.font-color: "#ffd43b"; style.stroke: "#ffd43b"; style.bold: true}
    v5: "EIP = 0x00401025" {style.fill: "#111"; style.font-color: "#74c0fc"; style.stroke: "#333"; style.bold: true}
    n5: "return addr after int 0x80" {style.fill: "#111"; style.font-color: "#51cf66"; style.stroke: "#222"; style.bold: true}
  }

  step4_idt: "Step 4: IDT[0x80] lookup — jump to isr128 handler address" {
    style: {
      fill: "#2d1b4e"
      stroke: "#cc5de8"
      font-color: "#cc5de8"
      border-radius: 4
    }
  }

  idt_entry: "IDT Gate Descriptor [vector 0x80 = 128]" {
    style: {
      fill: "#1e1035"
      stroke: "#cc5de8"
      stroke-width: 2
      border-radius: 6
    }
    grid-columns: 2
    grid-gap: 2
    ig1: "offset_low = handler[15:0]" {style.fill: "#1a1a2e"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"}
    id1: "low 16 bits of handler addr" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    ig2: "selector = 0x08" {style.fill: "#1a1a2e"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"}
    id2: "kernel code segment" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    ig3: "type_attr = 0xEF" {style.fill: "#4a1030"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}
    id3: "P=1 DPL=3 trap-gate(0xF)" {style.fill: "#111"; style.font-color: "#ffd43b"; style.stroke: "#333"; style.bold: true}
    ig4: "offset_high = handler[31:16]" {style.fill: "#1a1a2e"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"}
    id4: "high 16 bits full handler addr" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
  }

  gate_note: "Why DPL=3 TRAP gate (not interrupt gate)?" {
    style: {
      fill: "#1a1a0e"
      stroke: "#ffd43b"
      stroke-width: 1
      border-radius: 4
      font-color: "#ffd43b"
    }
    r1: "DPL=3: ring-3 code CAN execute int 0x80 (else GPF)" {style.fill: "#0d0d00"; style.stroke: "#333"; style.font-color: "#ffd43b"}
    r2: "Trap gate: IF NOT cleared on entry — interrupts stay ON" {style.fill: "#0d0d00"; style.stroke: "#333"; style.font-color: "#ffd43b"}
    r3: "Timer can preempt a blocking syscall like read()" {style.fill: "#0d0d00"; style.stroke: "#333"; style.font-color: "#adb5bd"}
    r4: "Interrupt gate would freeze scheduler during every syscall" {style.fill: "#4a1000"; style.stroke: "#ff6b6b"; style.font-color: "#ff6b6b"; style.bold: true}
  }
}

kernel_handler: "KERNEL HANDLER — isr128 stub + isr_common_stub (Ring 0 — CPL=0)" {
  style: {
    fill: "#0d1f0d"
    stroke: "#51cf66"
    stroke-width: 3
    font-color: "#51cf66"
    border-radius: 8
    bold: true
  }

  asm_stub: "isr128 assembly stub" {
    style: {
      fill: "#051005"
      stroke: "#51cf66"
      stroke-width: 2
      border-radius: 6
    }
    code: |'md
      nasm
      global isr128
      isr128:
        ; Trap gate: IF not cleared
        push dword 0     ; dummy error code
        push dword 128   ; vector = 0x80
        jmp isr_common_stub
'|
  }

  common_stub: "isr_common_stub — save ALL registers" {
    style: {
      fill: "#051005"
      stroke: "#51cf66"
      stroke-width: 2
      border-radius: 6
    }
    code: |'md
      nasm
      isr_common_stub:
        pusha          ; EAX ECX EDX EBX ESP EBP ESI EDI
        push ds
        push es ; push fs ; push gs
        mov ax, 0x10   ; kernel data segment
        mov ds, ax ; mov es, ax
        push esp       ; arg: interrupt_frame_t ptr
        call syscall_dispatch
        add esp, 4
        ; pop gs fs es ds
        popa
        add esp, 8     ; discard vector+error_code
        iret
'|
  }

  frame_layout: "interrupt_frame_t on Kernel Stack (after pusha + seg saves)" {
    style: {
      fill: "#0a1a0a"
      stroke: "#51cf66"
      stroke-width: 2
      border-radius: 6
      font-color: "#51cf66"
    }
    grid-columns: 3
    grid-gap: 2

    sh0: "field" {style.fill: "#051005"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true; style.underline: true}
    sv0: "value" {style.fill: "#051005"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true; style.underline: true}
    sn0: "source" {style.fill: "#051005"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true; style.underline: true}

    sh1: "gs fs es ds" {style.fill: "#0a1a0a"; style.font-color: "#cc5de8"; style.stroke: "#333"}
    sv1: "0x10 kernel data" {style.fill: "#0a1a0a"; style.font-color: "#cc5de8"; style.stroke: "#333"}
    sn1: "stub pushed" {style.fill: "#0a1a0a"; style.font-color: "#666"; style.stroke: "#222"}

    sh2: "edi esi ebp esp ebx edx ecx eax" {style.fill: "#0a1a0a"; style.font-color: "#74c0fc"; style.stroke: "#333"}
    sv2: "user register state" {style.fill: "#0a1a0a"; style.font-color: "#74c0fc"; style.stroke: "#333"; style.bold: true}
    sn2: "pusha" {style.fill: "#0a1a0a"; style.font-color: "#74c0fc"; style.stroke: "#222"}

    sh3: "vector" {style.fill: "#0a1a0a"; style.font-color: "#ffd43b"; style.stroke: "#333"}
    sv3: "128 (0x80)" {style.fill: "#0a1a0a"; style.font-color: "#ffd43b"; style.stroke: "#333"}
    sn3: "stub pushed" {style.fill: "#0a1a0a"; style.font-color: "#666"; style.stroke: "#222"}

    sh4: "error_code" {style.fill: "#0a1a0a"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    sv4: "0 dummy" {style.fill: "#0a1a0a"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    sn4: "stub pushed" {style.fill: "#0a1a0a"; style.font-color: "#666"; style.stroke: "#222"}

    sh5: "eip" {style.fill: "#0a1a0a"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true}
    sv5: "0x00401025" {style.fill: "#0a1a0a"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true}
    sn5: "CPU pushed return addr" {style.fill: "#0a1a0a"; style.font-color: "#51cf66"; style.stroke: "#222"; style.bold: true}

    sh6: "cs" {style.fill: "#0a1a0a"; style.font-color: "#51cf66"; style.stroke: "#51cf66"}
    sv6: "0x1B ring-3" {style.fill: "#0a1a0a"; style.font-color: "#51cf66"; style.stroke: "#51cf66"}
    sn6: "CPU pushed" {style.fill: "#0a1a0a"; style.font-color: "#51cf66"; style.stroke: "#222"}

    sh7: "eflags" {style.fill: "#0a1a0a"; style.font-color: "#51cf66"; style.stroke: "#51cf66"}
    sv7: "0x0202 IF=1" {style.fill: "#0a1a0a"; style.font-color: "#51cf66"; style.stroke: "#51cf66"}
    sn7: "CPU pushed" {style.fill: "#0a1a0a"; style.font-color: "#51cf66"; style.stroke: "#222"}

    sh8: "user_esp" {style.fill: "#1a3a10"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true}
    sv8: "0x00BFFFF0" {style.fill: "#1a3a10"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true}
    sn8: "ring-3 only: CPU" {style.fill: "#1a3a10"; style.font-color: "#51cf66"; style.stroke: "#222"; style.bold: true}

    sh9: "user_ss" {style.fill: "#1a3a10"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true}
    sv9: "0x23" {style.fill: "#1a3a10"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true}
    sn9: "ring-3 only: CPU" {style.fill: "#1a3a10"; style.font-color: "#51cf66"; style.stroke: "#222"; style.bold: true}
  }
}

dispatch: "SYSCALL DISPATCH — C Handler and Syscall Table" {
  style: {
    fill: "#1a1000"
    stroke: "#ffd43b"
    stroke-width: 3
    font-color: "#ffd43b"
    border-radius: 8
    bold: true
  }

  c_dispatch: "syscall_dispatch() — reads frame->eax to index table" {
    style: {
      fill: "#0d0d00"
      stroke: "#ffd43b"
      stroke-width: 1
      border-radius: 4
    }
    code: |'md
      c
      void syscall_dispatch(interrupt_frame_t *frame) {
          uint32_t num = frame->eax; // = 4
          if (num >= SYSCALL_MAX) {
              frame->eax = (uint32_t)-ENOSYS;
              return;
          }
          // index into function pointer table
          frame->eax = syscall_table[num](frame);
          // return value -> saved EAX -> user EAX via iret
      }
'|
  }

  syscall_table: "syscall_table[] — Function Pointer Array indexed by EAX" {
    style: {
      fill: "#0d0d00"
      stroke: "#ffd43b"
      stroke-width: 2
      border-radius: 6
      font-color: "#ffd43b"
    }
    grid-columns: 4
    grid-gap: 3

    idx_h: "Index" {style.fill: "#1a1000"; style.font-color: "#ffd43b"; style.stroke: "#ffd43b"; style.bold: true; style.underline: true}
    ptr_h: "Function Ptr" {style.fill: "#1a1000"; style.font-color: "#ffd43b"; style.stroke: "#ffd43b"; style.bold: true; style.underline: true}
    name_h: "Syscall Name" {style.fill: "#1a1000"; style.font-color: "#ffd43b"; style.stroke: "#ffd43b"; style.bold: true; style.underline: true}
    args_h: "Args (frame->reg)" {style.fill: "#1a1000"; style.font-color: "#ffd43b"; style.stroke: "#ffd43b"; style.bold: true; style.underline: true}

    i0: "[0]" {style.fill: "#111"; style.font-color: "#666"; style.stroke: "#333"}
    p0: "NULL" {style.fill: "#111"; style.font-color: "#666"; style.stroke: "#333"}
    n0: "unused" {style.fill: "#111"; style.font-color: "#666"; style.stroke: "#333"}
    a0: "---" {style.fill: "#111"; style.stroke: "#222"; style.font-color: "#666"}

    i1: "[1]" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#51cf66"}
    p1: "sys_exit" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true}
    n1: "SYS_EXIT" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#51cf66"}
    a1: "EBX=exit_code" {style.fill: "#1a3320"; style.font-color: "#adb5bd"; style.stroke: "#333"}

    i2: "[2]" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    p2: "sys_fork" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    n2: "SYS_FORK" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    a2: "none" {style.fill: "#111"; style.font-color: "#666"; style.stroke: "#222"}

    i3: "[3]" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    p3: "sys_read" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    n3: "SYS_READ" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    a3: "EBX ECX EDX" {style.fill: "#111"; style.font-color: "#666"; style.stroke: "#222"}

    i4: "[4] EAX=4 MATCH" {style.fill: "#4a3000"; style.font-color: "#ffd43b"; style.stroke: "#ffd43b"; style.bold: true}
    p4: "sys_write — SELECTED" {style.fill: "#4a3000"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}
    n4: "SYS_WRITE" {style.fill: "#4a3000"; style.font-color: "#ffd43b"; style.stroke: "#ffd43b"; style.bold: true}
    a4: "EBX=fd ECX=buf EDX=len" {style.fill: "#4a3000"; style.font-color: "#ffd43b"; style.stroke: "#333"; style.bold: true}

    i5: "[5]" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    p5: "sys_open" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    n5: "SYS_OPEN" {style.fill: "#111"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    a5: "EBX ECX EDX" {style.fill: "#111"; style.font-color: "#666"; style.stroke: "#222"}

    idots: "[6..N]" {style.fill: "#111"; style.font-color: "#555"; style.stroke: "#333"}
    pdots: "more handlers..." {style.fill: "#111"; style.font-color: "#555"; style.stroke: "#333"; style.italic: true}
    ndots: "..." {style.fill: "#111"; style.font-color: "#555"; style.stroke: "#333"; style.italic: true}
    adots: "..." {style.fill: "#111"; style.stroke: "#222"; style.font-color: "#666"}
  }

  sys_write_impl: "sys_write() — validate user ptr then write to VGA + serial" {
    style: {
      fill: "#0d0d00"
      stroke: "#51cf66"
      stroke-width: 1
      border-radius: 4
    }
    code: |'md
      c
      int32_t sys_write(interrupt_frame_t *frame) {
          uint32_t fd    = frame->ebx; // 1 = stdout
          uint32_t buf   = frame->ecx; // 0x00401020
          uint32_t count = frame->edx; // 6
          // SECURITY: buf must be in user space
          if (buf >= 0xC0000000 ||
              buf + count > 0xC0000000)
              return -EFAULT;
          const char *kbuf = (const char*)buf;
          for (uint32_t i = 0; i < count; i++) {
              if (fd == 1)
                  vga_putchar(kbuf[i], WHITE, BLACK);
              serial_putchar(kbuf[i]);
          }
          return (int32_t)count; // -> frame->eax
      }
'|
  }
}

fast_path: "FAST PATH: SYSENTER vs INT 0x80 — Why 3-5x Faster" {
  style: {
    fill: "#1a0a2e"
    stroke: "#cc5de8"
    stroke-width: 3
    font-color: "#cc5de8"
    border-radius: 8
    bold: true
  }

  comparison: "Cycle Cost Breakdown per Syscall Round-Trip" {
    style: {
      fill: "#110820"
      stroke: "#cc5de8"
      stroke-width: 2
      border-radius: 6
    }
    grid-columns: 3
    grid-gap: 4

    ch1: "Step" {style.fill: "#1e1035"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"; style.bold: true; style.underline: true}
    ch2: "INT 0x80 cycles" {style.fill: "#4a0010"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true; style.underline: true}
    ch3: "SYSENTER cycles" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true; style.underline: true}

    cr1: "DPL permission check" {style.fill: "#110820"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    cd1: "~2" {style.fill: "#4a0010"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
    cse1: "0 (no check)" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#333"}

    cr2: "IDT lookup L2 memory" {style.fill: "#110820"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    cd2: "~10" {style.fill: "#4a0010"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
    cse2: "0 (MSR direct)" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#333"}

    cr3: "TSS.ESP0 read L3/DRAM" {style.fill: "#110820"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}
    cd3: "80-120 BOTTLENECK" {style.fill: "#4a0010"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}
    cse3: "~1 (MSR_SYSENTER_ESP)" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#333"; style.bold: true}

    cr4: "5x push SS ESP EFLAGS CS EIP" {style.fill: "#110820"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    cd4: "~15" {style.fill: "#4a0010"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
    cse4: "~6 (ESP EIP only)" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#333"}

    cr5: "Pipeline flush and branch" {style.fill: "#110820"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    cd5: "~20" {style.fill: "#4a0010"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
    cse5: "~5 (MSR target)" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#333"}

    cr6: "iret (restore 5 values)" {style.fill: "#110820"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    cd6: "~30" {style.fill: "#4a0010"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
    cse6: "~8 (SYSEXIT)" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#333"}

    cr7: "TOTAL entry + exit overhead" {style.fill: "#1e1035"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"; style.bold: true}
    cd7: "~500-600 cycles" {style.fill: "#4a0010"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}
    cse7: "~100-150 cycles" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true}
  }

  msrs: "SYSENTER uses 3 MSRs — CPU registers, no memory read" {
    style: {
      fill: "#110820"
      stroke: "#cc5de8"
      stroke-width: 2
      border-radius: 6
      font-color: "#cc5de8"
    }
    grid-columns: 2
    grid-gap: 4
    m1: "MSR_SYSENTER_CS  0x174" {style.fill: "#1e1035"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"}
    m1d: "kernel code selector = 0x08" {style.fill: "#110820"; style.font-color: "#adb5bd"; style.stroke: "#333"}
    m2: "MSR_SYSENTER_ESP 0x175" {style.fill: "#1e1035"; style.font-color: "#ffd43b"; style.stroke: "#ffd43b"; style.bold: true}
    m2d: "kernel stack top (replaces TSS.ESP0 DRAM read — saves ~100 cycles)" {style.fill: "#110820"; style.font-color: "#ffd43b"; style.stroke: "#333"; style.bold: true}
    m3: "MSR_SYSENTER_EIP 0x176" {style.fill: "#1e1035"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"}
    m3d: "kernel entry addr (replaces IDT lookup)" {style.fill: "#110820"; style.font-color: "#adb5bd"; style.stroke: "#333"}
  }

  vdso: "vDSO: zero-syscall hot paths like clock_gettime" {
    style: {
      fill: "#0d0a1a"
      stroke: "#cc5de8"
      stroke-width: 1
      border-radius: 4
      font-color: "#cc5de8"
    }
    v1: "Kernel maps read-only page into every process virtual address space" {style.fill: "#110820"; style.stroke: "#333"; style.font-color: "#adb5bd"}
    v2: "Contains: clock_gettime() gettimeofday() getcpu()" {style.fill: "#110820"; style.stroke: "#333"; style.font-color: "#adb5bd"}
    v3: "Reads kernel data updated by timer IRQ — NO ring transition at all" {style.fill: "#1a3320"; style.stroke: "#51cf66"; style.font-color: "#51cf66"; style.bold: true}
    v4: "clock_gettime reads TSC directly: ~20 cycles vs ~500 via INT 0x80" {style.fill: "#1a3320"; style.stroke: "#51cf66"; style.font-color: "#51cf66"; style.bold: true}
    v5: "Trade-off: only valid for read-only kernel data safe for user to see" {style.fill: "#110820"; style.stroke: "#333"; style.font-color: "#ffd43b"}
  }
}

timeline: "INT 0x80 sys_write — Cycle Timeline at 2 GHz" {
  style: {
    fill: "#0d0d1a"
    stroke: "#74c0fc"
    stroke-width: 2
    border-radius: 8
    font-color: "#74c0fc"
  }
  grid-columns: 4
  grid-gap: 3

  th1: "Phase" {style.fill: "#0a0a2e"; style.font-color: "#74c0fc"; style.stroke: "#74c0fc"; style.bold: true; style.underline: true}
  th2: "Cycles" {style.fill: "#0a0a2e"; style.font-color: "#74c0fc"; style.stroke: "#74c0fc"; style.bold: true; style.underline: true}
  th3: "Time at 2GHz" {style.fill: "#0a0a2e"; style.font-color: "#74c0fc"; style.stroke: "#74c0fc"; style.bold: true; style.underline: true}
  th4: "Bottleneck" {style.fill: "#0a0a2e"; style.font-color: "#74c0fc"; style.stroke: "#74c0fc"; style.bold: true; style.underline: true}

  tp1: "User reg setup EAX=4 EBX=1 ECX EDX" {style.fill: "#0d2137"; style.font-color: "#adb5bd"; style.stroke: "#333"}
  tc1: "~4" {style.fill: "#0d2137"; style.font-color: "#51cf66"; style.stroke: "#333"}
  tt1: "~2 ns" {style.fill: "#0d2137"; style.font-color: "#51cf66"; style.stroke: "#333"}
  tb1: "none" {style.fill: "#0d2137"; style.font-color: "#666"; style.stroke: "#222"}

  tp2: "int 0x80 DPL check + IDT lookup" {style.fill: "#0d2137"; style.font-color: "#adb5bd"; style.stroke: "#333"}
  tc2: "~12" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tt2: "~6 ns" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tb2: "L2 cache" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#222"}

  tp3: "TSS.ESP0 read — kernel stack ptr" {style.fill: "#4a1000"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}
  tc3: "80-120" {style.fill: "#4a1000"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}
  tt3: "~50 ns" {style.fill: "#4a1000"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}
  tb3: "L3/DRAM BOTTLENECK" {style.fill: "#4a1000"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"; style.bold: true}

  tp4: "5x CPU push SS ESP EFLAGS CS EIP" {style.fill: "#0d2137"; style.font-color: "#adb5bd"; style.stroke: "#333"}
  tc4: "~15" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tt4: "~7 ns" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tb4: "L1 write" {style.fill: "#0d2137"; style.font-color: "#51cf66"; style.stroke: "#222"}

  tp5: "pusha + 4x seg saves (12 pushes)" {style.fill: "#0d2137"; style.font-color: "#adb5bd"; style.stroke: "#333"}
  tc5: "~20" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tt5: "~10 ns" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tb5: "L1 write" {style.fill: "#0d2137"; style.font-color: "#51cf66"; style.stroke: "#222"}

  tp6: "syscall_table[EAX] lookup + call" {style.fill: "#0d2137"; style.font-color: "#adb5bd"; style.stroke: "#333"}
  tc6: "~15" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tt6: "~7 ns" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tb6: "L1 read" {style.fill: "#0d2137"; style.font-color: "#51cf66"; style.stroke: "#222"}

  tp7: "sys_write validate + VGA MMIO writes" {style.fill: "#4a1000"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
  tc7: "500-5000" {style.fill: "#4a1000"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
  tt7: "250 ns to 2.5 us" {style.fill: "#4a1000"; style.font-color: "#ff6b6b"; style.stroke: "#333"}
  tb7: "MMIO uncacheable" {style.fill: "#4a1000"; style.font-color: "#ff6b6b"; style.stroke: "#ff6b6b"}

  tp8: "popa + seg restores + iret" {style.fill: "#0d2137"; style.font-color: "#adb5bd"; style.stroke: "#333"}
  tc8: "~50" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tt8: "~25 ns" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#333"}
  tb8: "L1 reads + pipeline flush" {style.fill: "#0d2137"; style.font-color: "#ffd43b"; style.stroke: "#222"}

  tp9: "TOTAL overhead excl. VGA writes" {style.fill: "#1e1035"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"; style.bold: true}
  tc9: "~250-350" {style.fill: "#1e1035"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"; style.bold: true}
  tt9: "~150 ns" {style.fill: "#1e1035"; style.font-color: "#cc5de8"; style.stroke: "#cc5de8"; style.bold: true}
  tb9: "SYSENTER: ~100 cycles" {style.fill: "#1a3320"; style.font-color: "#51cf66"; style.stroke: "#51cf66"; style.bold: true}
}

userspace.regs_before -> userspace.int_instr: "loads EAX=4 EBX=1 ECX=buf EDX=6 then executes" {
  style.stroke: "#74c0fc"
  style.stroke-width: 2
  style.font-color: "#74c0fc"
}

userspace.int_instr -> cpu_hw.step1_dpl: "int 0x80 fires — CPU intercepts between instructions" {
  style.stroke: "#ff6b6b"
  style.stroke-width: 4
  style.animated: true
  style.font-color: "#ff6b6b"
  style.bold: true
}

cpu_hw.step1_dpl -> cpu_hw.step2_tss: "DPL check passed — permitted" {
  style.stroke: "#51cf66"
  style.stroke-width: 2
  style.font-color: "#51cf66"
}

cpu_hw.step2_tss -> cpu_hw.tss_detail: "reads TSS from memory — L3/DRAM bottleneck" {
  style.stroke: "#cc5de8"
  style.stroke-dash: 3
  style.font-color: "#cc5de8"
}

cpu_hw.tss_detail -> cpu_hw.step3_push: "ESP0 loaded as new kernel ESP" {
  style.stroke: "#ff6b6b"
  style.stroke-width: 2
  style.font-color: "#ff6b6b"
}

cpu_hw.step3_push -> cpu_hw.kernel_stack_frame: "5 values pushed onto kernel stack" {
  style.stroke: "#ff6b6b"
  style.stroke-dash: 3
  style.font-color: "#ff6b6b"
}

cpu_hw.step3_push -> cpu_hw.step4_idt: "push complete — lookup handler address" {
  style.stroke: "#ffd43b"
  style.font-color: "#ffd43b"
}

cpu_hw.step4_idt -> cpu_hw.idt_entry: "reads IDT[128] descriptor" {
  style.stroke: "#cc5de8"
  style.stroke-dash: 3
  style.font-color: "#cc5de8"
}

cpu_hw.step4_idt -> kernel_handler.asm_stub: "JMP to isr128 — now executing ring 0" {
  style.stroke: "#ff6b6b"
  style.stroke-width: 3
  style.animated: true
  style.font-color: "#ff6b6b"
  style.bold: true
}

kernel_handler.asm_stub -> kernel_handler.common_stub: "jmp isr_common_stub" {
  style.stroke: "#51cf66"
  style.font-color: "#51cf66"
}

kernel_handler.common_stub -> kernel_handler.frame_layout: "pusha + push segs builds interrupt_frame_t" {
  style.stroke: "#74c0fc"
  style.stroke-dash: 3
  style.font-color: "#74c0fc"
}

kernel_handler.common_stub -> dispatch.c_dispatch: "call syscall_dispatch(frame)" {
  style.stroke: "#ffd43b"
  style.stroke-width: 3
  style.animated: true
  style.font-color: "#ffd43b"
  style.bold: true
}

dispatch.c_dispatch -> dispatch.syscall_table: "frame->eax = 4 indexes table" {
  style.stroke: "#ffd43b"
  style.stroke-width: 2
  style.font-color: "#ffd43b"
}

dispatch.syscall_table -> dispatch.sys_write_impl: "syscall_table[4]() called — sys_write" {
  style.stroke: "#ff6b6b"
  style.stroke-width: 2
  style.animated: true
  style.font-color: "#ff6b6b"
}

dispatch.sys_write_impl -> kernel_handler.common_stub: "returns count=6 stored in frame->eax" {
  style.stroke: "#51cf66"
  style.stroke-width: 2
  style.font-color: "#51cf66"
}

kernel_handler.common_stub -> userspace.regs_after: "popa + seg restores + iret: CPL back to 3 EAX=6" {
  style.stroke: "#51cf66"
  style.stroke-width: 3
  style.animated: true
  style.font-color: "#51cf66"
  style.bold: true
}

cpu_hw.step2_tss -> fast_path.msrs: "SYSENTER replaces DRAM read with 1-cycle MSR — saves ~100 cycles" {
  style.stroke: "#cc5de8"
  style.stroke-dash: 5
  style.stroke-width: 2
  style.font-color: "#cc5de8"
  style.bold: true
}