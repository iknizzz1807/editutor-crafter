vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # TSS: Hardware Ring 3 to Ring 0 Transition Mechanics
| {near: top-center}

legend: {
  near: bottom-right
  style.fill: "#1a1a2e"
  style.stroke: "#444"
  style.font-color: white
  grid-columns: 2
  grid-gap: 4

  l_red: "Red = Hot path / danger" {
    style.fill: "#3d0000"
    style.font-color: "#ff6b6b"
    style.stroke: "#ff6b6b"
  }
  l_green: "Green = Safe / success" {
    style.fill: "#002200"
    style.font-color: "#66ff66"
    style.stroke: "#66ff66"
  }
  l_yellow: "Yellow = Caution" {
    style.fill: "#2a2000"
    style.font-color: "#ffd700"
    style.stroke: "#ffd700"
  }
  l_purple: "Purple = Hardware structs" {
    style.fill: "#1a0030"
    style.font-color: "#ce93d8"
    style.stroke: "#ce93d8"
  }
}

step1: "Step 1: Ring-3 Process Executing" {
  style.fill: "#001830"
  style.stroke: "#4fc3f7"
  style.stroke-width: 2
  style.border-radius: 6

  cpu_regs: "CPU Register State (Ring 3)" {
    style.fill: "#002244"
    style.stroke: "#4fc3f7"
    style.font-color: "#4fc3f7"

    r1: "CS  = 0x1B  (User code seg, DPL=3)" { style.fill: "#001433"; style.stroke: "#4fc3f7"; style.font-color: "#88ccff" }
    r2: "SS  = 0x23  (User stack seg, DPL=3)" { style.fill: "#001433"; style.stroke: "#4fc3f7"; style.font-color: "#88ccff" }
    r3: "ESP = 0xBFF000  (User stack ptr)" { style.fill: "#001433"; style.stroke: "#4fc3f7"; style.font-color: "#88ccff" }
    r4: "EIP = 0x00401234  (User code)" { style.fill: "#001433"; style.stroke: "#4fc3f7"; style.font-color: "#88ccff" }
    r5: "CPL = 3  (bits[1:0] of CS)" { style.fill: "#001433"; style.stroke: "#4fc3f7"; style.font-color: "#ffd700" }
    r6: "EFLAGS.IF = 1  (interrupts enabled)" { style.fill: "#001433"; style.stroke: "#4fc3f7"; style.font-color: "#88ccff" }
  }

  cr3_info: "CR3 = 0x00205000 (User Page Directory phys addr)" {
    style.fill: "#001433"
    style.stroke: "#4fc3f7"
    style.font-color: "#4fc3f7"
  }

  user_pd_note: "User PD: indices 0-767 user mappings (U/S=1), 768-1023 kernel (U/S=0)" {
    style.fill: "#000d22"
    style.stroke: "#4fc3f7"
    style.font-color: "#88aacc"
  }

  cr3_info -> user_pd_note: "CR3 points here (physical addr)" {
    style.stroke: "#4fc3f7"
    style.font-color: "#4fc3f7"
  }
}

step2: "Step 2: Interrupt Fires" {
  style.fill: "#2a0000"
  style.stroke: "#ff4444"
  style.stroke-width: 3
  style.border-radius: 6

  hw_irq: "Hardware IRQ (Timer IRQ0)" {
    style.fill: "#3d0000"
    style.stroke: "#ff4444"
    style.font-color: "#ff6b6b"
    label: "PIT asserts IRQ0 -> PIC -> CPU INTR pin\nCPU checks: EFLAGS.IF=1? YES -> accept\nInterrupt vector = 32 (remapped IRQ0)"
  }

  sw_int: "Software INT 0x80 (syscall)" {
    style.fill: "#3d0000"
    style.stroke: "#ff8800"
    style.font-color: "#ffaa44"
    label: "User executes: int 0x80\nCPU checks IDT[128].DPL >= CPL(3)? YES\nTrap gate: IF not cleared on entry"
  }

  cpu_check: "CPU: CPL=3, gate DPL >= CPL -> ALLOWED" {
    style.fill: "#1a1a00"
    style.stroke: "#ffd700"
    style.font-color: "#ffd700"
  }

  hw_irq -> cpu_check: "triggers" {
    style.stroke: "#ff4444"
    style.font-color: "#ff4444"
  }
  sw_int -> cpu_check: "triggers" {
    style.stroke: "#ff8800"
    style.font-color: "#ff8800"
  }
}

step3: "Step 3: CPU Reads TR Register -> Locates TSS" {
  style.fill: "#1a0030"
  style.stroke: "#ce93d8"
  style.stroke-width: 2
  style.border-radius: 6

  tr_reg: "TR (Task Register) = 0x28" {
    style.fill: "#2d0050"
    style.stroke: "#ce93d8"
    style.font-color: "#ce93d8"
    label: "TR = 0x28 (selector loaded by ltr at boot)\nTR caches GDT[5] TSS descriptor\nGDT[5] base = 0x00108000 (TSS phys addr)\nGDT[5] type = 0x9 (available 32-bit TSS)"
  }

  gdt5: "GDT Entry 5: TSS Descriptor (8 bytes)" {
    style.fill: "#200040"
    style.stroke: "#ce93d8"

    g1: "Bytes[1:0] limit_low  = 0x0067  (104-1)" { style.fill: "#180030"; style.stroke: "#9c27b0"; style.font-color: "#cc88ff" }
    g2: "Bytes[3:2] base_low   = 0x8000" { style.fill: "#180030"; style.stroke: "#9c27b0"; style.font-color: "#cc88ff" }
    g3: "Byte [4]   base_mid   = 0x10" { style.fill: "#180030"; style.stroke: "#9c27b0"; style.font-color: "#cc88ff" }
    g4: "Byte [5]   access     = 0x89  (P=1,DPL=0,S=0,type=9)" { style.fill: "#180030"; style.stroke: "#9c27b0"; style.font-color: "#cc88ff" }
    g5: "TSS physical base => 0x00108000" { style.fill: "#2d0050"; style.stroke: "#ce93d8"; style.font-color: "#ff88ff"; style.bold: true }
  }

  tr_reg -> gdt5: "CPU walks GDT using TR.selector\nto get TSS base address" {
    style.stroke: "#ce93d8"
    style.font-color: "#ce93d8"
  }
}

step4: "Step 4: CPU Reads SS0 + ESP0 From TSS Memory" {
  style.fill: "#1a0030"
  style.stroke: "#ce93d8"
  style.stroke-width: 2
  style.border-radius: 6

  tss_layout: "TSS at Physical 0x00108000 (104 bytes, Intel-defined layout)" {
    style.fill: "#200040"
    style.stroke: "#9c27b0"

    t0: "Offset +0x00: prev_task = 0x0000  (unused)" { style.fill: "#180030"; style.stroke: "#6a0080"; style.font-color: "#cc88ff" }
    t1: "Offset +0x04: ESP0 = 0x00110FFF  <- KERNEL STACK TOP" { style.fill: "#3d0050"; style.stroke: "#ff00ff"; style.font-color: "#ff88ff"; style.bold: true }
    t2: "Offset +0x08: SS0  = 0x0010      <- KERNEL DATA SEG" { style.fill: "#2d0050"; style.stroke: "#ce93d8"; style.font-color: "#ee88ff"; style.bold: true }
    t3: "Offset +0x0C: ESP1 = 0  (ring 1 unused)" { style.fill: "#180030"; style.stroke: "#6a0080"; style.font-color: "#886699" }
    t4: "Offset +0x10: ESP2 = 0  (ring 2 unused)" { style.fill: "#180030"; style.stroke: "#6a0080"; style.font-color: "#886699" }
    t5: "Offset +0x64: IOMAP base = 0x0068  (all I/O restricted)" { style.fill: "#180030"; style.stroke: "#6a0080"; style.font-color: "#886699" }
  }

  esp0_box: "TSS.ESP0 = kernel stack top for CURRENT process\nMUST BE UPDATED ON EVERY CONTEXT SWITCH" {
    style.fill: "#3d0050"
    style.stroke: "#ff00ff"
    style.font-color: "#ff88ff"
    style.stroke-width: 3
    style.bold: true
  }

  ss0_box: "TSS.SS0 = 0x10 = Kernel Data Segment\nConstant: same for all processes" {
    style.fill: "#200040"
    style.stroke: "#ce93d8"
    style.font-color: "#ce93d8"
  }

  tss_layout -> esp0_box: "CPU reads ESP0 at offset +4\n(~100 cycles DRAM if cold)" {
    style.stroke: "#ff00ff"
    style.font-color: "#ff00ff"
  }
  tss_layout -> ss0_box: "CPU reads SS0 at offset +8" {
    style.stroke: "#ce93d8"
    style.font-color: "#ce93d8"
  }
}

step5: "Step 5: CPU Pushes Ring-3 State Onto Kernel Stack" {
  style.fill: "#002200"
  style.stroke: "#66ff66"
  style.stroke-width: 2
  style.border-radius: 6

  stack_switch: "CPU Switches to Kernel Stack" {
    style.fill: "#002200"
    style.stroke: "#66ff66"
    style.font-color: "#66ff66"
    label: "Old SS:ESP (ring-3) saved internally\nNew SS  <- TSS.SS0  = 0x10\nNew ESP <- TSS.ESP0 = 0x00110FFF\nCPU now uses the KERNEL stack"
  }

  kstack: "Kernel Stack for This Process (0x00110000 - 0x00110FFF = 4KB)" {
    style.fill: "#001500"
    style.stroke: "#66ff66"

    sp0: "ESP = 0x00110FFF  (top before pushes)" {
      style.fill: "#001500"
      style.stroke: "#4caf50"
      style.font-color: "#88ff88"
    }
    p1: "push SS   = 0x23        (old user stack seg)" {
      style.fill: "#003300"
      style.stroke: "#66ff66"
      style.font-color: "#66ff66"
    }
    p2: "push ESP  = 0xBFF000    (old user stack ptr)" {
      style.fill: "#003300"
      style.stroke: "#66ff66"
      style.font-color: "#66ff66"
    }
    p3: "push EFLAGS = 0x00000202  (IF=1)" {
      style.fill: "#003300"
      style.stroke: "#66ff66"
      style.font-color: "#66ff66"
    }
    p4: "push CS   = 0x1B        (old user code seg)" {
      style.fill: "#003300"
      style.stroke: "#66ff66"
      style.font-color: "#66ff66"
    }
    p5: "push EIP  = 0x00401234  (return address)" {
      style.fill: "#003300"
      style.stroke: "#66ff66"
      style.font-color: "#66ff66"
    }
    p6: "push ERROR_CODE  (0 or CPU-provided)" {
      style.fill: "#002200"
      style.stroke: "#4caf50"
      style.font-color: "#88ff88"
    }
    spf: "ESP = 0x00110FE8  (new ESP after 6 pushes of 4 bytes each)" {
      style.fill: "#001500"
      style.stroke: "#66ff66"
      style.font-color: "#66ff66"
      style.bold: true
    }

    sp0 -> p1: "push 1: SS (ring-3->ring-0 crossing only)" { style.stroke: "#66ff66" }
    p1 -> p2: "push 2: ESP" { style.stroke: "#66ff66" }
    p2 -> p3: "push 3: EFLAGS" { style.stroke: "#66ff66" }
    p3 -> p4: "push 4: CS" { style.stroke: "#66ff66" }
    p4 -> p5: "push 5: EIP  (return address)" { style.stroke: "#66ff66" }
    p5 -> p6: "push 6: error code" { style.stroke: "#4caf50" }
    p6 -> spf: "ESP now points here" { style.stroke: "#66ff66"; style.font-color: "#66ff66" }
  }

  iret_note: "iret reversal on return: pops EIP->CS->EFLAGS->ESP->SS\nDetects CS.CPL=3 -> switches back to user stack atomically" {
    style.fill: "#001a00"
    style.stroke: "#4caf50"
    style.font-color: "#88ff88"
  }

  stack_switch -> kstack: "CPU atomically switches SS:ESP\nthen begins frame pushes" {
    style.stroke: "#66ff66"
    style.font-color: "#66ff66"
  }
}

step6: "Step 6: IDT Handler Address Loaded Into EIP" {
  style.fill: "#1a1000"
  style.stroke: "#ffd700"
  style.stroke-width: 2
  style.border-radius: 6

  idt_lookup: "IDT[vector] Gate Descriptor Lookup" {
    style.fill: "#2a2000"
    style.stroke: "#ffd700"
    style.font-color: "#ffd700"
    label: "IDTR -> IDT base = 0x00102000\nIDT[32] for IRQ0 | IDT[128] for INT 0x80\nInterrupt gate 0x8E: IF cleared on entry\nTrap gate 0xEF DPL=3: IF stays 1 (INT 0x80)\nHandler offset = irq_common_stub or syscall_stub"
  }

  after_regs: "CPU State After Transition to Ring 0" {
    style.fill: "#1a1500"
    style.stroke: "#ffd700"

    ar1: "CS  = 0x08  (Kernel code seg, DPL=0)" { style.fill: "#111000"; style.stroke: "#ffd700"; style.font-color: "#ffe082" }
    ar2: "CPL = 0  (extracted from CS bits[1:0])" { style.fill: "#111000"; style.stroke: "#ffd700"; style.font-color: "#ffd700"; style.bold: true }
    ar3: "EIP = irq_common_stub addr  (from IDT gate)" { style.fill: "#111000"; style.stroke: "#ffd700"; style.font-color: "#ffe082" }
    ar4: "SS  = 0x10  (Kernel data seg, from TSS.SS0)" { style.fill: "#111000"; style.stroke: "#ffd700"; style.font-color: "#ffe082" }
    ar5: "ESP = 0x00110FE8  (kernel stack, from TSS.ESP0)" { style.fill: "#111000"; style.stroke: "#ffd700"; style.font-color: "#ffe082" }
    ar6: "IF  = 0 (interrupt gate) | 1 (trap gate)" { style.fill: "#111000"; style.stroke: "#ffd700"; style.font-color: "#88ccff" }
  }

  dpl_check: "DPL gate check: user code CANNOT invoke DPL=0 gates\nprevents arbitrary ring-0 entry from user mode" {
    style.fill: "#2a2000"
    style.stroke: "#ff8800"
    style.font-color: "#ffaa44"
  }

  idt_lookup -> after_regs: "loads new CS and EIP\nfrom gate descriptor" {
    style.stroke: "#ffd700"
    style.font-color: "#ffd700"
  }
  idt_lookup -> dpl_check: "DPL check enforced\nbefore handler invocation" {
    style.stroke: "#ff8800"
    style.font-color: "#ff8800"
  }
}

triple_fault: "TRIPLE FAULT: TSS.ESP0 INVALID OR STALE" {
  style.fill: "#3d0000"
  style.stroke: "#ff0000"
  style.stroke-width: 4
  style.border-radius: 6
  style.bold: true

  tf_cause: "Root Causes" {
    style.fill: "#2a0000"
    style.stroke: "#ff4444"
    style.font-color: "#ff4444"
    label: "TSS.ESP0 points to wrong process kernel stack (stale after context switch)\nOR TSS.ESP0 = 0 (never initialized)\nOR TSS.ESP0 points to unmapped virtual address"
  }

  f1: "IRQ fires while Process B runs" { style.fill: "#1a0000"; style.stroke: "#ff4444"; style.font-color: "#ff6b6b" }
  f2: "CPU reads TSS.ESP0 -> still points to Process A stack" { style.fill: "#1a0000"; style.stroke: "#ff4444"; style.font-color: "#ff6b6b" }
  f3: "CPU pushes frame onto Process A stack (CORRUPTION)" { style.fill: "#1a0000"; style.stroke: "#ff4444"; style.font-color: "#ff6b6b" }
  f4: "OR: ESP0 invalid -> Stack Fault (exception 12)" { style.fill: "#1a0000"; style.stroke: "#ff4444"; style.font-color: "#ff6b6b" }
  f5: "Stack fault handler needs TSS.ESP0 -> another fault" { style.fill: "#1a0000"; style.stroke: "#ff4444"; style.font-color: "#ff6b6b" }
  f6: "Double Fault -> handler can't push frame -> TRIPLE FAULT" { style.fill: "#3d0000"; style.stroke: "#ff0000"; style.font-color: "#ff0000"; style.bold: true }
  f7: "CPU HARD RESET — no error message — QEMU reboots" { style.fill: "#200000"; style.stroke: "#cc0000"; style.font-color: "#ff4444"; style.bold: true }

  tf_cause -> f1: "triggers" { style.stroke: "#ff4444" }
  f1 -> f2 { style.stroke: "#ff4444" }
  f2 -> f3 { style.stroke: "#ff4444" }
  f3 -> f4: "if ESP0 invalid" { style.stroke: "#ff8800" }
  f4 -> f5 { style.stroke: "#ff4444" }
  f5 -> f6 { style.stroke: "#ff0000"; style.stroke-width: 2 }
  f6 -> f7 { style.stroke: "#ff0000"; style.stroke-width: 3; style.animated: true }
}

esp0_update: "MANDATORY: Update TSS.ESP0 on Every Context Switch" {
  style.fill: "#002200"
  style.stroke: "#00ff00"
  style.stroke-width: 4
  style.border-radius: 6
  style.bold: true

  the_rule: "The Rule: call tss_set_kernel_stack(next->kernel_stack_top)\nBEFORE context_switch_asm() — single 32-bit write ~1 cycle" {
    style.fill: "#001500"
    style.stroke: "#00cc00"
    style.font-color: "#88ff88"
  }

  ordering: "Critical Ordering in sched_schedule()" {
    style.fill: "#001500"
    style.stroke: "#4caf50"

    o1: "1. old->state = PROCESS_READY" { style.fill: "#001000"; style.stroke: "#4caf50"; style.font-color: "#88ff88" }
    o2: "2. next->state = PROCESS_RUNNING" { style.fill: "#001000"; style.stroke: "#4caf50"; style.font-color: "#88ff88" }
    o3: "3. current_process = next" { style.fill: "#001000"; style.stroke: "#4caf50"; style.font-color: "#88ff88" }
    o4: "4. tss_set_kernel_stack(next->kernel_stack_top)  <- BEFORE switch" { style.fill: "#003300"; style.stroke: "#00ff00"; style.font-color: "#00ff00"; style.bold: true }
    o5: "5. context_switch_asm(old_esp, next_esp, next_cr3)  <- iret fires here" { style.fill: "#001000"; style.stroke: "#4caf50"; style.font-color: "#88ff88" }
    o6: "6. [new process executing — TSS.ESP0 already correct]" { style.fill: "#002200"; style.stroke: "#4caf50"; style.font-color: "#66ff66" }

    o1 -> o2 { style.stroke: "#4caf50" }
    o2 -> o3 { style.stroke: "#4caf50" }
    o3 -> o4 { style.stroke: "#00ff00"; style.stroke-width: 2 }
    o4 -> o5 { style.stroke: "#4caf50" }
    o5 -> o6 { style.stroke: "#4caf50" }
  }

  the_rule -> ordering: "implementation" { style.stroke: "#00cc00"; style.font-color: "#00cc00" }
}

perf_note: "Hardware Cost Summary" {
  near: bottom-left
  style.fill: "#111111"
  style.stroke: "#555"
  style.border-radius: 4

  c1: "TSS.ESP0 read (L1 cached): ~4 cycles" { style.fill: "#0d0d0d"; style.stroke: "#444"; style.font-color: "#aaa" }
  c2: "TSS.ESP0 read (DRAM cold): ~100 cycles" { style.fill: "#0d0d0d"; style.stroke: "#444"; style.font-color: "#aaa" }
  c3: "Push 5 values to kernel stack: ~10 cycles" { style.fill: "#0d0d0d"; style.stroke: "#444"; style.font-color: "#aaa" }
  c4: "IDT gate read (L2 hot): ~10 cycles" { style.fill: "#0d0d0d"; style.stroke: "#444"; style.font-color: "#aaa" }
  c5: "tss_set_kernel_stack() write: ~1 cycle (L1 hit)" { style.fill: "#0d0d0d"; style.stroke: "#444"; style.font-color: "#aaa" }
  c6: "Total ring-3->ring-0 transition: ~150-200 cycles" { style.fill: "#1a1a00"; style.stroke: "#ffd700"; style.font-color: "#ffd700"; style.bold: true }
  c7: "Context switch end-to-end: ~700-1000 cycles" { style.fill: "#1a0000"; style.stroke: "#ff6b6b"; style.font-color: "#ff6b6b"; style.bold: true }
}

step1 -> step2: "Ring-3 code running; interrupt arrives between instructions" {
  style.stroke: "#ff6b6b"
  style.stroke-width: 2
  style.font-color: "#ff6b6b"
}

step2 -> step3: "CPU accepts interrupt; must find kernel stack via TSS" {
  style.stroke: "#ce93d8"
  style.stroke-width: 2
  style.font-color: "#ce93d8"
}

step3 -> step4: "TR -> GDT[5] -> TSS base address resolved" {
  style.stroke: "#ce93d8"
  style.stroke-width: 2
  style.font-color: "#ce93d8"
}

step4 -> step5: "ESP0 + SS0 loaded from TSS memory" {
  style.stroke: "#66ff66"
  style.stroke-width: 2
  style.font-color: "#66ff66"
}

step5 -> step6: "Kernel stack ready; ring-3 state saved; jump to handler" {
  style.stroke: "#ffd700"
  style.stroke-width: 2
  style.font-color: "#ffd700"
}

step4 -> triple_fault: "If TSS.ESP0 is stale or invalid -> fault chain" {
  style.stroke: "#ff0000"
  style.stroke-width: 3
  style.font-color: "#ff0000"
  style.stroke-dash: 5
}

triple_fault -> esp0_update: "Prevented by always updating TSS.ESP0 before switch" {
  style.stroke: "#00ff00"
  style.stroke-width: 2
  style.font-color: "#00ff00"
  style.animated: true
}

esp0_update -> step4: "ensures TSS.ESP0 always points to current process kernel stack top" {
  style.stroke: "#00cc00"
  style.font-color: "#00cc00"
  style.stroke-dash: 3
}