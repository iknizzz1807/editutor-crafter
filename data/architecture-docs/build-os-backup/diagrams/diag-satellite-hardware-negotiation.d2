vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

style: {
  fill: "#0D1117"
  stroke: "#30363D"
}

# ─── COLOR SEMANTICS ───
# Red    = hot path / hardware danger zone
# Green  = safe resolved state / software solution
# Yellow = transition / negotiation point
# Blue   = data flow / read path
# Purple = metadata / hardware registers
# Gray   = padding / legacy / unused

# ═══════════════════════════════════════════
# CENTRAL NODE
# ═══════════════════════════════════════════

cpu: |'md
# x86 CPU
**The Physical Negotiator**
Every design decision traces back here.
Executes at 2–3GHz, enforces privilege
rings in hardware, walks page tables via
MMU, caches translations in TLB, reads
TSS on every ring crossing.
'| {
  style: {
    fill: "#1A0A2E"
    stroke: "#CC00FF"
    stroke-width: 4
    font-color: "#E0AAFF"
    border-radius: 12
    shadow: true
    bold: true
  }
}

# ═══════════════════════════════════════════
# BRANCH 1 — 4KB Pages → Allocator → Tables → Heap
# ═══════════════════════════════════════════

branch1: "BRANCH 1: Fixed 4KB Page Granularity" {
  style: {
    fill: "#0D1F0D"
    stroke: "#2EA043"
    stroke-width: 2
    border-radius: 8
    font-color: "#2EA043"
    bold: true
  }

  hw_pages: |'md
  **HARDWARE CONSTRAINT**
  MMU translates in 4KB units only.
  CR3 holds physical addr of Page Dir.
  PDE[31:12] → Page Table (4KB aligned).
  PTE[31:12] → Physical Frame (4KB).
  Page size = 2^PAGE_SHIFT = 2^12 = 4096B.
  Enforced by: **MMU silicon** — not software.
  '| {
    style: {
      fill: "#0A1A0A"
      stroke: "#3FB950"
      font-color: "#3FB950"
      border-radius: 6
    }
  }

  frame_alloc: |'md
  **Physical Frame Allocator (PMM)**
  bitmap[FRAME_COUNT/32] — 1 bit per 4KB frame
  4GB RAM → 1M frames → 128KB bitmap
  pmm_alloc_frame() → 4KB-aligned phys addr
  pmm_free_frame()  → bitmap_clear + hint update
  Double-free detected: bitmap_test before clear
  Cache win: 64B cache line = 512 frames = 2MB
  '| {
    style: {
      fill: "#0D1F0D"
      stroke: "#56D364"
      font-color: "#56D364"
      border-radius: 6
    }
  }

  page_tables: |'md
  **Two-Level Page Tables (VMM)**
  Virtual addr [31:22] → PD index (0–1023)
  Virtual addr [21:12] → PT index (0–1023)
  Virtual addr [11:0]  → byte offset (0–4095)
  PDE flags: P R/W U/S PWT PCD A PS G
  PTE flags: P R/W U/S PWT PCD A D G
  vmm_map_page(): alloc PT frame if PDE absent
  vmm_unmap_page(): PTE=0 + MANDATORY invlpg
  '| {
    style: {
      fill: "#0D1F0D"
      stroke: "#56D364"
      font-color: "#56D364"
      border-radius: 6
    }
  }

  kmalloc_heap: |'md
  **Kernel Heap (kmalloc / kfree)**
  Virtual range: 0xD0000000–0xDFFFFFFF (256MB)
  heap_expand(): pmm_alloc_frame() + vmm_map_page()
  Block header: magic|size|free|next|prev (20B)
  First-fit scan; split if block.size ≥ req+hdr+8
  Coalesce on kfree: merge next+prev free blocks
  Magic=0xDEADBEEF: detects header corruption O(1)
  '| {
    style: {
      fill: "#0D1F0D"
      stroke: "#56D364"
      font-color: "#56D364"
      border-radius: 6
    }
  }

  hw_pages -> frame_alloc: "4KB frame unit\nforces page-granular\nallocation"  {
    style: { stroke: "#3FB950"; font-color: "#3FB950"; stroke-width: 2 }
  }
  frame_alloc -> page_tables: "pmm_alloc_frame()\nreturns 4KB-aligned\nphys addr for PTEs" {
    style: { stroke: "#3FB950"; font-color: "#3FB950"; stroke-width: 2 }
  }
  page_tables -> kmalloc_heap: "heap pages mapped\nvirtual→physical\nvia vmm_map_page()" {
    style: { stroke: "#3FB950"; font-color: "#3FB950"; stroke-width: 2 }
  }
}

cpu -> branch1.hw_pages: "CR3 reg holds PD phys addr\nMMU walks PDE→PTE on every\nmemory access (TLB miss path)" {
  style: { stroke: "#2EA043"; font-color: "#2EA043"; stroke-width: 3; bold: true }
}

# ═══════════════════════════════════════════
# BRANCH 2 — Privilege Rings → GDT → TSS → Syscalls
# ═══════════════════════════════════════════

branch2: "BRANCH 2: Hardware Privilege Ring Model" {
  style: {
    fill: "#1A0D2E"
    stroke: "#8B5CF6"
    stroke-width: 2
    border-radius: 8
    font-color: "#8B5CF6"
    bold: true
  }

  hw_rings: |'md
  **HARDWARE CONSTRAINT**
  CPL (Current Privilege Level) in CS[1:0]
  Ring 0 = kernel (unrestricted hardware access)
  Ring 3 = user  (restricted: no privileged instrs)
  Page U/S=0: only ring 0 can access
  Page U/S=1: rings 0–3 can access
  Enforced by: **CPU microcode on every fetch+access**
  '| {
    style: {
      fill: "#0F0820"
      stroke: "#A78BFA"
      font-color: "#A78BFA"
      border-radius: 6
    }
  }

  gdt: |'md
  **GDT (Global Descriptor Table)**
  GDTR register: 6B = limit(16b) + base(32b)
  Loaded with: lgdt [gdt_descriptor]
  Entry 0 (0x00): Null descriptor (required)
  Entry 1 (0x08): Kernel code  DPL=0 Access=0x9A
  Entry 2 (0x10): Kernel data  DPL=0 Access=0x92
  Entry 3 (0x18): User code    DPL=3 Access=0xFA
  Entry 4 (0x20): User data    DPL=3 Access=0xF2
  Entry 5 (0x28): TSS          S=0   Access=0x89
  Selector = (index<<3)|TI|RPL
  Kernel code: (1<<3)|0|0 = 0x08
  User code:   (3<<3)|0|3 = 0x1B
  '| {
    style: {
      fill: "#1A0D2E"
      stroke: "#C4B5FD"
      font-color: "#C4B5FD"
      border-radius: 6
    }
  }

  tss: |'md
  **TSS (Task State Segment) — Hardware Read**
  CPU reads TSS on EVERY ring-3 → ring-0 crossing
  TSS.SS0  = 0x10  (kernel data segment)
  TSS.ESP0 = per-process kernel stack top
  Loaded via: ltr 0x28 (Task Register)
  tss_set_kernel_stack(next->kernel_stack_top)
  called BEFORE context_switch_asm()
  Stale TSS.ESP0 → wrong stack → silent corruption
  TR caches TSS descriptor; ESP0 read live from RAM
  '| {
    style: {
      fill: "#1A0D2E"
      stroke: "#C4B5FD"
      font-color: "#C4B5FD"
      border-radius: 6
    }
  }

  syscall_gate: |'md
  **System Call Gate (INT 0x80)**
  IDT[0x80] = Trap Gate, DPL=3 (0xEF)
  DPL=3: ring-3 code may invoke via 'int 0x80'
  Trap (not interrupt) gate: IF not cleared
  → timer IRQs fire during blocking syscalls
  Ring-3 → Ring-0: CPU uses TSS.ESP0 for kstack
  Pushes: SS ESP EFLAGS CS EIP (5 words)
  EAX=syscall#, EBX=arg1, ECX=arg2, EDX=arg3
  Return value in EAX
  Pointer validation: buf_vaddr < 0xC0000000
  '| {
    style: {
      fill: "#1A0D2E"
      stroke: "#C4B5FD"
      font-color: "#C4B5FD"
      border-radius: 6
    }
  }

  hw_rings -> gdt: "Segment selector DPL\nmust match CPL/RPL\nGPF if violated" {
    style: { stroke: "#A78BFA"; font-color: "#A78BFA"; stroke-width: 2 }
  }
  gdt -> tss: "GDT entry 5 describes TSS\nbase+limit+type=0x89\nCPU caches via ltr" {
    style: { stroke: "#A78BFA"; font-color: "#A78BFA"; stroke-width: 2 }
  }
  tss -> syscall_gate: "TSS.ESP0 provides\nkernel stack for\nevery ring crossing" {
    style: { stroke: "#A78BFA"; font-color: "#A78BFA"; stroke-width: 2 }
  }
}

cpu -> branch2.hw_rings: "CPL bits in CS[1:0]\nMMU checks U/S on\nevery memory access" {
  style: { stroke: "#8B5CF6"; font-color: "#8B5CF6"; stroke-width: 3; bold: true }
}

# ═══════════════════════════════════════════
# BRANCH 3 — Interrupt Hardware → PIC → IDT → ISR
# ═══════════════════════════════════════════

branch3: "BRANCH 3: Interrupt Hardware Architecture" {
  style: {
    fill: "#1A0A0A"
    stroke: "#CF222E"
    stroke-width: 2
    border-radius: 8
    font-color: "#CF222E"
    bold: true
  }

  hw_irq: |'md
  **HARDWARE CONSTRAINT**
  8259 PIC (1976) wired BEFORE x86 exceptions defined
  Default: IRQ0→vec8 (Double Fault!), IRQ1→vec9 …
  CPU vectors 0–31: reserved for CPU exceptions
  Timer tick (IRQ0) at default → INSTANT triple fault
  CPU checks INTR line between instructions (IF=1)
  INTR asserted → CPU reads INTA → PIC sends vector
  '| {
    style: {
      fill: "#1A0000"
      stroke: "#FF7B72"
      font-color: "#FF7B72"
      border-radius: 6
    }
  }

  pic_remap: |'md
  **PIC Remapping (MANDATORY before sti)**
  Master PIC: ports 0x20/0x21 (IRQ0–7)
  Slave PIC:  ports 0xA0/0xA1 (IRQ8–15)
  ICW1→ICW2→ICW3→ICW4 initialization sequence
  pic_remap(0x20, 0x28):
    IRQ0–7  → vectors 32–39  (above exceptions)
    IRQ8–15 → vectors 40–47
  EOI (0x20) MUST be sent after every IRQ handler
  Forgot EOI → PIC masks IRQ line PERMANENTLY (silent!)
  Spurious IRQ7/15: check ISR reg before EOI
  '| {
    style: {
      fill: "#1A0A0A"
      stroke: "#FF7B72"
      font-color: "#FF7B72"
      border-radius: 6
    }
  }

  idt: |'md
  **IDT (Interrupt Descriptor Table)**
  IDTR: 6B = limit(16b) + base(32b) → lidt
  256 gate descriptors × 8B each = 2KB
  Interrupt Gate (0x8E): IF cleared on entry
    → hardware IRQ handlers (no reentrancy)
  Trap Gate (0x8F, DPL=0): IF preserved
    → CPU exception handlers
  Trap Gate (0xEF, DPL=3): IF preserved, user-callable
    → INT 0x80 system call gate
  Vectors 0–31: CPU exceptions (fault/trap/abort)
  Vectors 32–47: Hardware IRQs (after PIC remap)
  Vector 0x80: System call trap gate
  '| {
    style: {
      fill: "#1A0A0A"
      stroke: "#FF7B72"
      font-color: "#FF7B72"
      border-radius: 6
    }
  }

  isr_discipline: |'md
  **ISR Discipline (Stack Frame Discipline)**
  CPU auto-pushes: EFLAGS CS EIP [SS ESP if ring-3]
  Exceptions WITH error code: 8,10,11,12,13,14,17
  Exceptions WITHOUT: push dummy 0 (uniform frame)
  ISR stub: cli → push_err → push_vec → isr_common
  isr_common: pusha → push DS/ES/FS/GS → call handler
  Return:     pop GS/FS/ES/DS → popa → add esp,8 → iret
  iret: atomically restores EIP+CS+EFLAGS [+ESP+SS]
  Missing pusha/popa → register clobber on resume
  Wrong add esp,N → corrupted stack → triple fault
  '| {
    style: {
      fill: "#1A0A0A"
      stroke: "#FF7B72"
      font-color: "#FF7B72"
      border-radius: 6
    }
  }

  hw_irq -> pic_remap: "Default IRQ→vector mapping\ncollides with CPU exceptions\nMUST remap before sti" {
    style: { stroke: "#CF222E"; font-color: "#CF222E"; stroke-width: 2 }
  }
  pic_remap -> idt: "Remapped vectors 32–47\nsafe to install in IDT\nno collision with exceptions" {
    style: { stroke: "#CF222E"; font-color: "#CF222E"; stroke-width: 2 }
  }
  idt -> isr_discipline: "IDT gate type determines\nIF behavior on entry\nStack frame layout is fixed" {
    style: { stroke: "#CF222E"; font-color: "#CF222E"; stroke-width: 2 }
  }
}

cpu -> branch3.hw_irq: "INTR pin sampled\nbetween instructions\nIF=1 required to accept" {
  style: { stroke: "#CF222E"; font-color: "#CF222E"; stroke-width: 3; bold: true }
}

# ═══════════════════════════════════════════
# BRANCH 4 — Pipeline Reset → Far Jump after CR0.PE
# ═══════════════════════════════════════════

branch4: "BRANCH 4: Pipeline Reset Requirement" {
  style: {
    fill: "#1A1200"
    stroke: "#D29922"
    stroke-width: 2
    border-radius: 8
    font-color: "#D29922"
    bold: true
  }

  hw_pipeline: |'md
  **HARDWARE CONSTRAINT**
  Modern CPUs prefetch + decode ahead of IP
  Instructions decoded under REAL MODE assumptions
  sit in pipeline at moment CR0.PE is set
  Setting CR0.PE is instantaneous and irrevocable
  Next fetch goes through GDT — but prefetch buffer
  may contain real-mode-decoded instructions
  Executing them in protected mode = UNDEFINED
  '| {
    style: {
      fill: "#1A1000"
      stroke: "#E3B341"
      font-color: "#E3B341"
      border-radius: 6
    }
  }

  pm_transition: |'md
  **Protected Mode Transition Sequence**
  Step 1: cli       — disable interrupts (IVT invalid)
  Step 2: lgdt [gdt_descriptor] — load GDTR
  Step 3: mov eax,cr0; or eax,1; mov cr0,eax
           CR0 bit0 (PE) = 1 → protected mode ON
  Step 4: jmp 0x08:protected_mode_entry  ← MANDATORY
           Far jump: loads CS=0x08 from GDT entry 1
           Flushes prefetch buffer (pipeline reset)
           CPU re-fetches from new address under PM rules
  Step 5: mov ax,0x10; mov ds,ax; mov ss,ax …
           All segment regs must be reloaded explicitly
  '| {
    style: {
      fill: "#1A1A00"
      stroke: "#E3B341"
      font-color: "#E3B341"
      border-radius: 6
    }
  }

  far_jump: |'md
  **Far Jump: The Only Valid Pipeline Flush**
  'jmp 0x08:label' is a FAR jump instruction
  It simultaneously:
   • Loads CS with segment selector 0x08
   • Flushes the instruction pipeline completely
   • Forces re-fetch from new IP under PM decode rules
  Regular 'jmp label' (near): does NOT flush pipeline
  Indirect call through C: compiler may insert near jumps
  Cost: ~20–30 cycles (pipeline restart + BP miss)
  Happens ONCE at boot → negligible
  Registers: DS ES FS GS SS must be loaded AFTER far jump
  '| {
    style: {
      fill: "#1A1A00"
      stroke: "#E3B341"
      font-color: "#E3B341"
      border-radius: 6
    }
  }

  hw_pipeline -> pm_transition: "Real-mode decoded instrs\nin pipeline at CR0.PE set\nMust be flushed immediately" {
    style: { stroke: "#D29922"; font-color: "#D29922"; stroke-width: 2 }
  }
  pm_transition -> far_jump: "CR0.PE=1 only enables PM\nCS still holds real-mode value\nFar jump loads GDT entry into CS" {
    style: { stroke: "#D29922"; font-color: "#D29922"; stroke-width: 2 }
  }
}

cpu -> branch4.hw_pipeline: "Superscalar pipeline\nprefetches N instrs ahead\nMode change must flush all" {
  style: { stroke: "#D29922"; font-color: "#D29922"; stroke-width: 3; bold: true }
}

# ═══════════════════════════════════════════
# BRANCH 5 — TLB Caching → invlpg Requirement
# ═══════════════════════════════════════════

branch5: "BRANCH 5: TLB Address Translation Cache" {
  style: {
    fill: "#001A2E"
    stroke: "#1F6FEB"
    stroke-width: 2
    border-radius: 8
    font-color: "#1F6FEB"
    bold: true
  }

  hw_tlb: |'md
  **HARDWARE CONSTRAINT**
  TLB = Translation Lookaside Buffer (per-core cache)
  L1 dTLB: 32–64 entries (virtual page → phys frame)
  L2 sTLB: 512–4096 entries
  TLB hit:  1 cycle (no page table walk)
  TLB miss: 20–50 cycles (MMU walks PD→PT→frame)
  TLB is NOT coherent with page table modifications
  CPU serves stale translations until explicitly flushed
  Per-core: each CPU core has its own private TLB
  '| {
    style: {
      fill: "#001020"
      stroke: "#58A6FF"
      font-color: "#58A6FF"
      border-radius: 6
    }
  }

  tlb_stale: |'md
  **Stale Translation Hazard**
  PTE modified (new phys frame, new flags) →
  TLB still caches OLD translation →
  Next access served from stale TLB →
  Write goes to WRONG physical frame →
  Silent memory corruption (no exception!)
  Failure manifests far from modification site
  On SMP: remote core TLBs also stale →
  Requires IPI (TLB shootdown) to remote cores
  '| {
    style: {
      fill: "#001A2E"
      stroke: "#58A6FF"
      font-color: "#58A6FF"
      border-radius: 6
    }
  }

  invlpg: |'md
  **invlpg: Targeted TLB Invalidation**
  invlpg [virt_addr]: invalidates ONE TLB entry
  Cost: ~20 cycles on modern CPUs
  Use after: vmm_map_page(), vmm_unmap_page()
  CR3 reload: flushes ALL non-global TLB entries
  Cost: ~30 cycles + cold-miss penalty on subsequent accesses
  Use after: bulk PTE changes, process context switch
  PAGE_GLOBAL flag (bit 8): TLB entry survives CR3 reload
  Kernel pages should be GLOBAL → no re-walk on switch
  MANDATORY rule: modify PTE → invlpg(virt_addr)
  '| {
    style: {
      fill: "#001A2E"
      stroke: "#58A6FF"
      font-color: "#58A6FF"
      border-radius: 6
    }
  }

  hw_tlb -> tlb_stale: "TLB not updated on PTE write\nSilent stale translation\nNo hardware exception fired" {
    style: { stroke: "#1F6FEB"; font-color: "#1F6FEB"; stroke-width: 2 }
  }
  tlb_stale -> invlpg: "invlpg shoots down\none specific TLB entry\nCR3 reload flushes all" {
    style: { stroke: "#1F6FEB"; font-color: "#1F6FEB"; stroke-width: 2 }
  }
}

cpu -> branch5.hw_tlb: "TLB sits between\ninstruction pipeline\nand MMU page walker" {
  style: { stroke: "#1F6FEB"; font-color: "#1F6FEB"; stroke-width: 3; bold: true }
}

# ═══════════════════════════════════════════
# BRANCH 6 — 8259 Legacy Mapping → PIC Remap Requirement
# ═══════════════════════════════════════════

branch6: "BRANCH 6: 8259 PIC Legacy Vector Collision" {
  style: {
    fill: "#1A0D0D"
    stroke: "#BC4C00"
    stroke-width: 2
    border-radius: 8
    font-color: "#BC4C00"
    bold: true
  }

  hw_8259: |'md
  **HARDWARE CONSTRAINT: 8259 PIC (1976)**
  Designed for 8080 CPU before x86 exceptions existed
  Factory default IRQ→vector mapping:
    IRQ0  (Timer)    → vector 8  = Double Fault !!
    IRQ1  (Keyboard) → vector 9  = Invalid TSS !!
    IRQ2  (Cascade)  → vector 10 = Seg Not Present !!
    IRQ3  (COM2)     → vector 11 = Stack Fault !!
    IRQ4  (COM1)     → vector 12 = Stack Fault !!
    IRQ5  (LPT2)     → vector 13 = GPF !!
    IRQ6  (Floppy)   → vector 14 = Page Fault !!
    IRQ7  (LPT1)     → vector 15 = FPU Error !!
  First timer tick after sti → IRQ0 → vec8 → Double Fault
  → double fault handler faults → TRIPLE FAULT → REBOOT
  '| {
    style: {
      fill: "#1A0000"
      stroke: "#FF9950"
      font-color: "#FF9950"
      border-radius: 6
    }
  }

  collision_map: |'md
  **Collision Visualization**
  CPU exception vectors (Intel reserved):
    0=Div  1=Dbg  2=NMI  3=BP   4=OVF  5=BRD
    6=UD   7=NM   8=DF   9=CSO  10=TS  11=NP
    12=SS  13=GPF  14=PF  15=Rsv  16=MF  17=AC
  Default PIC mapping DIRECTLY collides with 8–15
  Result: hardware IRQ fires → CPU exception handler runs
  → handler sees impossible error code from real IRQ
  → handler panics or ignores → silent failure or reboot
  '| {
    style: {
      fill: "#1A0D0D"
      stroke: "#FF9950"
      font-color: "#FF9950"
      border-radius: 6
    }
  }

  remap_protocol: |'md
  **ICW Initialization Protocol**
  ICW1 (cmd port): 0x11 = init + ICW4 required
  ICW2 (data port): new base vector offset
    Master: 0x20 → IRQ0–7  map to vectors 32–39
    Slave:  0x28 → IRQ8–15 map to vectors 40–47
  ICW3: cascade wiring (master bit2=slave, slave id=2)
  ICW4: 0x01 = 8086 mode
  io_wait() between writes (hardware setup time ~1μs)
  Must complete BEFORE any sti instruction
  Must complete BEFORE installing IRQ handlers in IDT
  Failure mode: no error, no diagnostic, instant reboot
  '| {
    style: {
      fill: "#1A0D0D"
      stroke: "#FF9950"
      font-color: "#FF9950"
      border-radius: 6
    }
  }

  hw_8259 -> collision_map: "1976 chip + 1982 exceptions\nnever coordinated\nVectors 8–15 doubly claimed" {
    style: { stroke: "#BC4C00"; font-color: "#BC4C00"; stroke-width: 2 }
  }
  collision_map -> remap_protocol: "ICW sequence reprograms\nvector base offset\nto safe range ≥ 32" {
    style: { stroke: "#BC4C00"; font-color: "#BC4C00"; stroke-width: 2 }
  }
}

cpu -> branch6.hw_8259: "INTR pin driven by PIC\nPIC translates IRQ→vector\nDefault mapping is wrong" {
  style: { stroke: "#BC4C00"; font-color: "#BC4C00"; stroke-width: 3; bold: true }
}

# ═══════════════════════════════════════════
# CROSS-BRANCH INTERDEPENDENCIES
# ═══════════════════════════════════════════

branch3.pic_remap -> branch6.remap_protocol: "pic_remap() IS the\nremapping protocol\n(same operation)" {
  style: { stroke: "#6B7280"; stroke-dash: 5; font-color: "#6B7280" }
}

branch2.tss -> branch4.far_jump: "After PM transition\nTSS installed in GDT entry 5\nThen ltr 0x28 loads TR" {
  style: { stroke: "#6B7280"; stroke-dash: 5; font-color: "#6B7280" }
}

branch1.page_tables -> branch5.invlpg: "vmm_map_page() calls\ntlb_flush_page(virt)\nafter every PTE write" {
  style: { stroke: "#6B7280"; stroke-dash: 5; font-color: "#6B7280" }
}

branch2.syscall_gate -> branch3.idt: "INT 0x80 registered\nin IDT[0x80] with\nDPL=3 trap gate" {
  style: { stroke: "#6B7280"; stroke-dash: 5; font-color: "#6B7280" }
}

# ═══════════════════════════════════════════
# LEGEND
# ═══════════════════════════════════════════

legend: |'md
## Legend & Color Semantics
**Purple border** = Privilege/metadata enforcement
**Green  border** = Memory management / safe allocation
**Red    border** = Interrupt danger / hot path
**Yellow border** = Transition / negotiation required
**Blue   border** = Data flow / translation cache
**Orange border** = Legacy hardware collision hazard
**Gray dashed**   = Cross-branch dependency

**Solid thick arrows** → CPU register enforces constraint
**Solid thin arrows**  → Software solution chain
**Dashed arrows**      → Cross-branch relationship
'| {
  near: bottom-center
  style: {
    fill: "#161B22"
    stroke: "#30363D"
    font-color: "#8B949E"
    border-radius: 8
    font-size: 12
  }
}