vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: right

title: |md
  # Interrupt Infrastructure as Scheduler Foundation
  *M2 (interrupts) must be complete before M4 (scheduling) can function*
| {near: top-center}

legend: {
  near: bottom-left
  style: {
    fill: "#1a1a2e"
    stroke: "#444466"
    border-radius: 8
    font-color: "#ccccdd"
    font-size: 12
  }
  l_red: "Red = Danger / Hot path" {
    style.fill: "#3d0000"
    style.stroke: "#cc2222"
    style.font-color: "#ff6666"
    style.border-radius: 4
  }
  l_green: "Green = Success / Correct path" {
    style.fill: "#003d00"
    style.stroke: "#22aa22"
    style.font-color: "#66ff66"
    style.border-radius: 4
  }
  l_yellow: "Yellow = Waiting / Caution" {
    style.fill: "#2e2a00"
    style.stroke: "#aaaa00"
    style.font-color: "#ffee44"
    style.border-radius: 4
  }
  l_blue: "Blue = Data flow / Read" {
    style.fill: "#001830"
    style.stroke: "#2266cc"
    style.font-color: "#66aaff"
    style.border-radius: 4
  }
  l_gray: "Gray = Unused / Dead path" {
    style.fill: "#1a1a1a"
    style.stroke: "#555555"
    style.font-color: "#888888"
    style.border-radius: 4
  }
}

hw: "HARDWARE LAYER" {
  style: {
    fill: "#1a0a00"
    stroke: "#cc6600"
    stroke-width: 3
    border-radius: 10
    font-color: "#ff9933"
    bold: true
    font-size: 14
  }

  pit: "PIT Chip (Intel 8253/8254)" {
    style: {
      fill: "#2e1500"
      stroke: "#cc6600"
      font-color: "#ffaa44"
      border-radius: 6
      bold: true
    }
    pit_freq: |md
      Clock: **1,193,182 Hz**
      Divisor: 11,932
      IRQ rate: **100 Hz = 10ms**
    | {
      style.fill: "#1a0d00"
      style.stroke: "#885500"
      style.font-color: "#cc8833"
      style.font-size: 11
    }
  }

  pic_master: "Master 8259 PIC (0x20/0x21)" {
    style: {
      fill: "#2e0000"
      stroke: "#cc2200"
      font-color: "#ff6644"
      border-radius: 6
      bold: true
    }
    irq_lines: |md
      IRQ0 -> Timer
      IRQ1 -> Keyboard
      IRQ2 -> Cascade slave
      IRQ7 -> Spurious
    | {
      style.fill: "#1a0000"
      style.stroke: "#881100"
      style.font-color: "#cc4433"
      style.font-size: 11
    }
  }

  pic_slave: "Slave 8259 PIC (0xA0/0xA1)" {
    style: {
      fill: "#1a0a20"
      stroke: "#663399"
      font-color: "#aa77cc"
      border-radius: 6
    }
    slave_irqs: |md
      IRQ8  -> RTC
      IRQ12 -> PS/2 Mouse
      IRQ14 -> ATA primary
      IRQ15 -> Spurious
    | {
      style.fill: "#110718"
      style.stroke: "#442266"
      style.font-color: "#8855aa"
      style.font-size: 11
    }
  }

  cpu_intr: "CPU INTR Pin" {
    style: {
      fill: "#0d0d0d"
      stroke: "#888888"
      font-color: "#cccccc"
      border-radius: 4
      bold: true
    }
  }
}

m2: "MILESTONE 2: Interrupt Infrastructure" {
  style: {
    fill: "#001830"
    stroke: "#2266cc"
    stroke-width: 3
    border-radius: 10
    font-color: "#66aaff"
    bold: true
    font-size: 14
  }

  pic_remap: "pic_remap(0x20, 0x28)" {
    style: {
      fill: "#003060"
      stroke: "#3388ff"
      font-color: "#88ccff"
      border-radius: 6
      bold: true
    }
    remap_detail: |md
      ICW1 -> init both PICs
      ICW2 -> master offset=0x20
      ICW2 -> slave  offset=0x28
      ICW3 -> cascade IRQ2
      ICW4 -> 8086 mode
      Result: IRQ0->vec32, IRQ1->vec33
    | {
      style.fill: "#001830"
      style.stroke: "#224488"
      style.font-color: "#6699cc"
      style.font-size: 11
    }
  }

  idt: "IDT: 256 entries x 8 bytes" {
    style: {
      fill: "#003060"
      stroke: "#3388ff"
      font-color: "#88ccff"
      border-radius: 6
      bold: true
    }
    idt_gates: |md
      vec 0-31:  CPU exceptions (trap gates)
      vec 32:    IRQ0 Timer (interrupt gate)
      vec 33:    IRQ1 Keyboard (interrupt gate)
      vec 0x80:  syscall (trap gate DPL=3)
    | {
      style.fill: "#001830"
      style.stroke: "#224488"
      style.font-color: "#6699cc"
      style.font-size: 11
    }
    lidt: "lidt loads IDTR register" {
      style.fill: "#002244"
      style.stroke: "#224488"
      style.font-color: "#55aacc"
      style.font-size: 11
    }
  }

  irq_stub: "irq_common_stub (assembly ISR)" {
    style: {
      fill: "#002244"
      stroke: "#2266cc"
      font-color: "#6699ff"
      border-radius: 6
      bold: true
    }
    stub_body: |md
      irq0: cli; push 0; push 32
      jmp irq_common_stub
      irq_common_stub:
        pusha
        push ds/es/fs/gs
        mov ax, 0x10; mov ds, ax
        push esp
        call irq_dispatcher
        add esp, 4
        pop gs/fs/es/ds
        popa; add esp,8; iret
    | {
      style.fill: "#001830"
      style.stroke: "#224488"
      style.font-color: "#6699cc"
      style.font-size: 10
    }
  }

  eoi: "pic_send_eoi(irq)" {
    style: {
      fill: "#003060"
      stroke: "#33aaff"
      font-color: "#66ccff"
      border-radius: 6
      bold: true
    }
    eoi_detail: |md
      if irq >= 8:
        outb(0xA0, 0x20)  slave EOI
      outb(0x20, 0x20)  master EOI

      Without EOI: PIC ISR bit stays set
      IRQ line permanently masked
      Scheduler freezes after 1 switch
    | {
      style.fill: "#001830"
      style.stroke: "#224488"
      style.font-color: "#6699cc"
      style.font-size: 11
    }
  }

  tick_counter: "pit_tick_count++ (volatile uint64_t)" {
    style: {
      fill: "#003060"
      stroke: "#2266cc"
      font-color: "#88ccff"
      border-radius: 6
    }
    tick_note: |md
      volatile = forces memory read
      Not atomic: single-core only
      Incremented 100x per second
    | {
      style.fill: "#001830"
      style.stroke: "#224488"
      style.font-color: "#6699cc"
      style.font-size: 11
    }
  }
}

m4: "MILESTONE 4: Preemptive Scheduler" {
  style: {
    fill: "#001a00"
    stroke: "#22aa22"
    stroke-width: 3
    border-radius: 10
    font-color: "#66ff66"
    bold: true
    font-size: 14
  }

  sched_tick: "sched_tick() called from timer ISR" {
    style: {
      fill: "#003300"
      stroke: "#33cc33"
      font-color: "#88ff88"
      border-radius: 6
      bold: true
    }
    tick_logic: |md
      current_process->ticks_remaining--
      if ticks_remaining > 0: return
      else: sched_schedule()
    | {
      style.fill: "#001a00"
      style.stroke: "#226622"
      style.font-color: "#66aa66"
      style.font-size: 11
    }
  }

  sched_schedule: "sched_schedule() round-robin" {
    style: {
      fill: "#003300"
      stroke: "#33cc33"
      font-color: "#88ff88"
      border-radius: 6
      bold: true
    }
    rr_logic: |md
      Walk process_table[0..MAX]
      Find next PROCESS_READY entry
      old->state = PROCESS_READY
      next->state = PROCESS_RUNNING
      next->ticks = SLICE (5 ticks=50ms)
    | {
      style.fill: "#001a00"
      style.stroke: "#226622"
      style.font-color: "#66aa66"
      style.font-size: 11
    }
  }

  tss_update: "tss_set_kernel_stack() BEFORE context_switch" {
    style: {
      fill: "#1a1a00"
      stroke: "#aaaa00"
      font-color: "#eeee44"
      border-radius: 6
      bold: true
    }
    tss_detail: |md
      kernel_tss.esp0 = next->kernel_stack_top
      kernel_tss.ss0  = 0x10 (kernel data)
      Must precede context switch:
      next IRQ uses new TSS.ESP0
      pushes frame on NEXT process stack
      NOT old stack (avoids corruption)
    | {
      style.fill: "#111100"
      style.stroke: "#777700"
      style.font-color: "#aaaa33"
      style.font-size: 11
    }
  }

  ctx_switch: "context_switch_asm() assembly only" {
    style: {
      fill: "#003300"
      stroke: "#33cc33"
      font-color: "#88ff88"
      border-radius: 6
      bold: true
    }
    ctx_body: |md
      mov eax, [esp+4]   &old->cpu.esp
      mov ecx, [esp+8]   next->cpu.esp
      mov edx, [esp+12]  next->page_dir
      mov [eax], esp     save old ESP
      mov esp, ecx       THE SWITCH
      cmp cr3, edx
      je same_cr3
      mov cr3, edx       flush TLB
      same_cr3: ret
    | {
      style.fill: "#001a00"
      style.stroke: "#226622"
      style.font-color: "#66aa66"
      style.font-size: 10
    }
  }

  pcb: "PCB (process_t) per-process state" {
    style: {
      fill: "#001a00"
      stroke: "#228833"
      font-color: "#66cc88"
      border-radius: 6
    }
    pcb_fields: |md
      pid, name, state
      ticks_remaining
      cpu_state: edi,esi,ebp,esp
                 ebx,edx,ecx,eax
                 eip, cs, eflags
                 [user_esp, user_ss]
      page_directory (CR3 phys addr)
      kernel_stack[4096] aligned(16)
      kernel_stack_top -> TSS.ESP0
    | {
      style.fill: "#001100"
      style.stroke: "#115522"
      style.font-color: "#449966"
      style.font-size: 11
    }
  }

  iret_resume: "iret -> resume next process" {
    style: {
      fill: "#003300"
      stroke: "#44ff44"
      font-color: "#aaffaa"
      border-radius: 6
      bold: true
    }
    iret_detail: |md
      Pops from NEXT process kernel stack:
      EIP -> where process was interrupted
      CS  -> ring0 (0x08) or ring3 (0x1B)
      EFLAGS (IF=1 re-enables interrupts)
      [ESP, SS] only for ring-3 processes
    | {
      style.fill: "#001a00"
      style.stroke: "#226622"
      style.font-color: "#66aa66"
      style.font-size: 11
    }
  }
}

failures: "FAILURE MODES: what breaks without correct M2" {
  style: {
    fill: "#1a0000"
    stroke: "#cc0000"
    stroke-width: 3
    border-radius: 10
    font-color: "#ff4444"
    bold: true
    font-size: 14
  }

  fail_no_remap: "NO PIC REMAP: IRQ0 fires vector 8" {
    style: {
      fill: "#3d0000"
      stroke: "#ff2200"
      font-color: "#ff6666"
      border-radius: 6
      bold: true
    }
    fail_remap_detail: |md
      Default: IRQ0 -> vector 8 = double fault
      First timer tick ~55ms after sti:
      CPU invokes double fault handler
      Double fault handler itself faults
      TRIPLE FAULT -> REBOOT
      No error message. No stack trace.
      QEMU restarts ~55ms after boot.
    | {
      style.fill: "#220000"
      style.stroke: "#881100"
      style.font-color: "#cc3333"
      style.font-size: 11
    }
  }

  fail_no_eoi: "NO EOI SENT: IRQ0 line stays masked" {
    style: {
      fill: "#3d0000"
      stroke: "#ff4400"
      font-color: "#ff8866"
      border-radius: 6
      bold: true
    }
    fail_eoi_detail: |md
      After first timer IRQ is handled:
      PIC ISR bit for IRQ0 stays set
      PIC will not deliver another IRQ0
      Scheduler gets exactly 1 tick
      May switch once then FREEZES
      No crash. No exception. Silent hang.
      Most insidious scheduling bug.
    | {
      style.fill: "#220000"
      style.stroke: "#882200"
      style.font-color: "#cc4422"
      style.font-size: 11
    }
  }

  fail_no_idt: "NO IDT: interrupts reach nowhere" {
    style: {
      fill: "#3d0000"
      stroke: "#ff6600"
      font-color: "#ffaa44"
      border-radius: 6
      bold: true
    }
    fail_idt_detail: |md
      sti -> first IRQ -> CPU indexes IDTR
      IDTR.base = 0 or garbage
      Reads garbage gate descriptor
      Jumps to random address
      IMMEDIATE TRIPLE FAULT
      Even if PIC is correctly remapped.
      Symptom: triple fault on sti.
    | {
      style.fill: "#220000"
      style.stroke: "#883300"
      style.font-color: "#cc5522"
      style.font-size: 11
    }
  }

  fail_no_tss: "TSS.ESP0 NOT UPDATED: wrong kernel stack" {
    style: {
      fill: "#2e2000"
      stroke: "#aaaa00"
      font-color: "#eeee44"
      border-radius: 6
      bold: true
    }
    fail_tss_detail: |md
      Process A runs, gets interrupted
      Timer fires during Process B
      TSS.ESP0 still points to A stack
      CPU pushes IRQ frame onto A stack
      Handler modifies A kernel stack
      A resumes from corrupted state
      Crash appears random / unrelated
    | {
      style.fill: "#1a1400"
      style.stroke: "#666600"
      style.font-color: "#aaaa22"
      style.font-size: 11
    }
  }
}

init_order: "MANDATORY INITIALIZATION ORDER" {
  style: {
    fill: "#0a0a1a"
    stroke: "#555577"
    border-radius: 10
    font-color: "#aaaacc"
    bold: true
    font-size: 13
  }

  step1: "1. idt_setup_all(): Load 256 IDT gates" {
    style.fill: "#001830"
    style.stroke: "#2255aa"
    style.font-color: "#6699dd"
    style.border-radius: 4
  }
  step2: "2. pic_remap(0x20, 0x28): BEFORE sti" {
    style.fill: "#001830"
    style.stroke: "#3388ff"
    style.font-color: "#88aaff"
    style.border-radius: 4
    style.bold: true
  }
  step3: "3. pit_init(100): IRQ0 handler registered" {
    style.fill: "#001830"
    style.stroke: "#2266cc"
    style.font-color: "#6699ff"
    style.border-radius: 4
  }
  step4: "4. sched_init(): Process table zeroed" {
    style.fill: "#001a00"
    style.stroke: "#22aa22"
    style.font-color: "#66cc66"
    style.border-radius: 4
  }
  step5: "5. tss_init() + ltr 0x28: TSS in GDT" {
    style.fill: "#1a1a00"
    style.stroke: "#aaaa00"
    style.font-color: "#cccc44"
    style.border-radius: 4
  }
  step6: "6. process_create_kernel(): Fake stack frame" {
    style.fill: "#001a00"
    style.stroke: "#228833"
    style.font-color: "#66cc88"
    style.border-radius: 4
  }
  step7: "7. sti: Interrupts enabled -- scheduler live" {
    style.fill: "#003300"
    style.stroke: "#44ff44"
    style.font-color: "#aaffaa"
    style.border-radius: 4
    style.bold: true
  }

  step1 -> step2: "IDT before remap\nIRQ before IDT = triple fault" {
    style.stroke: "#3366cc"
    style.font-color: "#6699cc"
    style.font-size: 10
  }
  step2 -> step3: "remap before any\nhardware IRQ fires" {
    style.stroke: "#3366cc"
    style.font-color: "#6699cc"
    style.font-size: 10
  }
  step3 -> step4: "timer must exist\nbefore scheduler ticks" {
    style.stroke: "#336633"
    style.font-color: "#669966"
    style.font-size: 10
  }
  step4 -> step5: "TSS needed before\nring-3 processes" {
    style.stroke: "#777700"
    style.font-color: "#aaaa33"
    style.font-size: 10
  }
  step5 -> step6: "process table ready\nbefore creation" {
    style.stroke: "#336633"
    style.font-color: "#669966"
    style.font-size: 10
  }
  step6 -> step7: "all processes exist\nbefore first tick" {
    style.stroke: "#33aa33"
    style.font-color: "#66cc66"
    style.font-size: 10
    style.bold: true
  }
}

irq_stub_exit: "irq_common_stub exit\npopa, pop segs, add esp 8" {
  style: {
    fill: "#002244"
    stroke: "#2266cc"
    font-color: "#6699ff"
    border-radius: 6
  }
}

dead_path: "WITHOUT REMAP: IRQ0 -> vec 8 double fault handler" {
  style: {
    fill: "#1a1a1a"
    stroke: "#555555"
    stroke-dash: 6
    font-color: "#888888"
    border-radius: 6
    italic: true
  }
}

hw.pit -> hw.pic_master: "IRQ0 pulse every 10ms at 100Hz" {
  style.stroke: "#ff6600"
  style.font-color: "#ff9933"
  style.stroke-width: 3
  style.animated: true
}

hw.pic_slave -> hw.pic_master: "cascade via IRQ2\nslave delivers IRQ8-15" {
  style.stroke: "#8833cc"
  style.font-color: "#aa66dd"
  style.font-size: 10
}

hw.pic_master -> hw.cpu_intr: "INTR signal raised\nif IMR allows" {
  style.stroke: "#cc4400"
  style.font-color: "#ff7733"
  style.stroke-width: 3
  style.animated: true
}

m2.pic_remap -> m2.idt: "after remap:\nIRQ0 -> gate[32]" {
  style.stroke: "#3388ff"
  style.font-color: "#66aaff"
}

hw.cpu_intr -> m2.idt: "CPU reads IDTR\nlooks up gate[32]" {
  style.stroke: "#2255cc"
  style.font-color: "#5588ff"
  style.stroke-width: 3
  style.animated: true
}

m2.idt -> m2.irq_stub: "interrupt gate: clears IF\njumps to irq0 stub" {
  style.stroke: "#3388ff"
  style.font-color: "#66aaff"
  style.stroke-width: 2
}

m2.irq_stub -> m2.tick_counter: "irq_dispatcher calls\ntimer_handler()" {
  style.stroke: "#2266cc"
  style.font-color: "#5599ff"
}

m2.irq_stub -> m2.eoi: "pic_send_eoi(0)\nAFTER handler returns" {
  style.stroke: "#33aaff"
  style.font-color: "#66ccff"
  style.bold: true
}

m2.eoi -> hw.pic_master: "outb(0x20, 0x20)\nunblocks next IRQ0" {
  style.stroke: "#33aaff"
  style.font-color: "#66bbee"
  style.animated: true
  style.stroke-dash: 4
}

m2.tick_counter -> m4.sched_tick: "sched_tick() called\nfrom timer_handler()\n100x per second" {
  style.stroke: "#22cc22"
  style.font-color: "#55ee55"
  style.stroke-width: 4
  style.bold: true
  style.animated: true
}

m4.sched_tick -> m4.sched_schedule: "ticks_remaining == 0\ntime slice expired" {
  style.stroke: "#33aa33"
  style.font-color: "#66cc66"
  style.stroke-width: 2
}

m4.sched_schedule -> m4.tss_update: "MUST update TSS\nbefore switching stacks" {
  style.stroke: "#aaaa00"
  style.font-color: "#dddd33"
  style.stroke-width: 3
  style.bold: true
}

m4.sched_schedule -> m4.pcb: "selects next PCB\nreads next->cpu.esp\nreads next->page_directory" {
  style.stroke: "#228833"
  style.font-color: "#66cc88"
}

m4.tss_update -> m4.ctx_switch: "TSS.ESP0 correct\nsafe to switch" {
  style.stroke: "#33cc33"
  style.font-color: "#77ee77"
  style.stroke-width: 2
}

m4.pcb -> m4.ctx_switch: "old->cpu.esp saved\nnext->cpu.esp loaded" {
  style.stroke: "#228833"
  style.font-color: "#55aa77"
}

m4.ctx_switch -> irq_stub_exit: "ret: now executing on\nnext process stack" {
  style.stroke: "#33aa33"
  style.font-color: "#66cc66"
  style.stroke-width: 3
}

irq_stub_exit -> m4.iret_resume: "iret pops from\nnext process frame" {
  style.stroke: "#33cc33"
  style.font-color: "#66ff66"
  style.stroke-width: 3
  style.bold: true
  style.animated: true
}

m4.iret_resume -> hw.cpu_intr: "CPU resumes next process\nIF restored from EFLAGS\nready for next IRQ" {
  style.stroke: "#22aa22"
  style.font-color: "#55cc55"
  style.stroke-dash: 5
}

m2.pic_remap -> failures.fail_no_remap: "if SKIPPED" {
  style.stroke: "#cc2200"
  style.font-color: "#ff5533"
  style.stroke-dash: 6
  style.stroke-width: 2
}

m2.eoi -> failures.fail_no_eoi: "if SKIPPED" {
  style.stroke: "#cc4400"
  style.font-color: "#ff7744"
  style.stroke-dash: 6
  style.stroke-width: 2
}

m2.idt -> failures.fail_no_idt: "if NOT LOADED" {
  style.stroke: "#cc6600"
  style.font-color: "#ff9944"
  style.stroke-dash: 6
  style.stroke-width: 2
}

m4.tss_update -> failures.fail_no_tss: "if AFTER switch or SKIPPED" {
  style.stroke: "#aaaa00"
  style.font-color: "#dddd44"
  style.stroke-dash: 6
  style.stroke-width: 2
}

hw.pic_master -> dead_path: "default factory mapping\nvec 8 = double fault WRONG" {
  style.stroke: "#555555"
  style.font-color: "#777777"
  style.stroke-dash: 6
  style.opacity: 0.6
}

dead_path -> failures.fail_no_remap: "double fault while\nhandling double fault\ntriple fault" {
  style.stroke: "#cc1100"
  style.font-color: "#ff3322"
  style.stroke-dash: 4
  style.stroke-width: 2
}