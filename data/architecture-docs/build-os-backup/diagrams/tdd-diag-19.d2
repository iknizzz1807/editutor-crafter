vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: right

title: |md
  # Bitmap Physical Frame Allocator: Data Structure Layout and Bit Operations
| {near: top-center}

bitmap_container: "frame_bitmap[32768] — 128KB in .bss" {
  style.fill: "#E8D5FF"
  style.stroke: "#7C3AED"
  style.bold: true
  style.font-size: 14

  word0: "frame_bitmap[0]  0x00000000" {
    style.fill: "#DBEAFE"
    style.stroke: "#2563EB"
    style.font-size: 12
  }
  word1: "frame_bitmap[1]  0x00000000" {
    style.fill: "#DBEAFE"
    style.stroke: "#2563EB"
    style.font-size: 12
  }
  word2: "frame_bitmap[2]  0xFFFFFFFF" {
    style.fill: "#FEE2E2"
    style.stroke: "#DC2626"
    style.font-size: 12
  }
  word3: "frame_bitmap[3]  0xFFFFFFFF" {
    style.fill: "#FEE2E2"
    style.stroke: "#DC2626"
    style.font-size: 12
  }
  ellipsis1: "..." {
    style.fill: "#F3F4F6"
    style.stroke: "#9CA3AF"
    style.font-size: 12
  }
  word_k: "frame_bitmap[k]  0xFFFFF800" {
    style.fill: "#FEF3C7"
    style.stroke: "#D97706"
    style.font-size: 12
  }
  ellipsis2: "..." {
    style.fill: "#F3F4F6"
    style.stroke: "#9CA3AF"
    style.font-size: 12
  }
  word_last: "frame_bitmap[32767]  0xFFFFFFFF" {
    style.fill: "#FEE2E2"
    style.stroke: "#DC2626"
    style.font-size: 12
  }
}

bit_detail: "Word Bit Layout — frame_bitmap[w]  (uint32_t)" {
  style.fill: "#F0FDF4"
  style.stroke: "#16A34A"
  style.bold: true
  style.font-size: 13

  bit_desc: |md
    bit 0  → frame w×32 + 0  (physical 0x000...000)
    bit 1  → frame w×32 + 1
    bit 2  → frame w×32 + 2
    ...
    bit 31 → frame w×32 + 31

    **0 = FREE  (available for allocation)**
    **1 = USED  (reserved or allocated)**

    One 64-byte cache line = 16 words = 512 frames = 2MB
  | {
    style.fill: "#F0FDF4"
    style.stroke: "#16A34A"
    style.font-size: 12
  }
}

addr_macros: "Address ↔ Frame Conversion Macros" {
  style.fill: "#FFF7ED"
  style.stroke: "#EA580C"
  style.bold: true
  style.font-size: 13

  macros: |md
    PAGE_SIZE  = 4096  (4KB)
    PAGE_SHIFT = 12

    ADDR_TO_FRAME(addr)  = addr >> 12
    FRAME_TO_ADDR(frame) = frame << 12

    FRAME_COUNT  = 4GB / 4KB = 1,048,576
    BITMAP_WORDS = 1,048,576 / 32 = 32,768
    Bitmap size  = 32,768 × 4 = **128KB**
  | {
    style.fill: "#FFF7ED"
    style.stroke: "#EA580C"
    style.font-size: 12
  }
}

state_vars: "Allocator State Variables" {
  style.fill: "#F5F3FF"
  style.stroke: "#7C3AED"
  style.bold: true
  style.font-size: 13

  vars_table: {
    shape: sql_table
    pmm_total_frames: "uint32_t — usable frames from E820"
    pmm_used_frames: "uint32_t — currently allocated frames"
    pmm_search_hint: "uint32_t — next-fit scan start (frame #)"
  }
}

alloc_algo: "pmm_alloc_frame() — Next-Fit Algorithm" {
  style.fill: "#EFF6FF"
  style.stroke: "#2563EB"
  style.bold: true
  style.font-size: 13
  style.shadow: true

  step1: "1. Check: pmm_frames_free() == 0 → return NULL" {
    style.fill: "#FEE2E2"
    style.stroke: "#DC2626"
    style.font-size: 12
  }
  step2: "2. start_word = pmm_search_hint / 32" {
    style.fill: "#DBEAFE"
    style.stroke: "#2563EB"
    style.font-size: 12
  }
  step3: "3. LOOP: if bitmap[word] == 0xFFFFFFFF → skip entire word\n   (512 frames checked in 1 comparison — cache-line efficient)" {
    style.fill: "#D1FAE5"
    style.stroke: "#16A34A"
    style.font-size: 12
  }
  step4: "4. Find free bit: iterate bits 0–31 within word" {
    style.fill: "#DBEAFE"
    style.stroke: "#2563EB"
    style.font-size: 12
  }
  step5: "5. Skip frame 0 (NULL pointer semantics preserved)" {
    style.fill: "#FEF3C7"
    style.stroke: "#D97706"
    style.font-size: 12
  }
  step6: "6. bitmap_set(frame); pmm_used_frames++\n   pmm_search_hint = frame\n   return FRAME_TO_ADDR(frame)" {
    style.fill: "#D1FAE5"
    style.stroke: "#16A34A"
    style.font-size: 12
  }

  step1 -> step2
  step2 -> step3
  step3 -> step3: "word all-used\n++(word mod 32768)"
  step3 -> step4: "free bit exists\nin this word"
  step4 -> step5
  step5 -> step6
}

free_algo: "pmm_free_frame(addr) — Free with Validation" {
  style.fill: "#FFF0F0"
  style.stroke: "#DC2626"
  style.bold: true
  style.font-size: 13

  fstep1: "1. frame = addr >> PAGE_SHIFT" {
    style.fill: "#DBEAFE"
    style.stroke: "#2563EB"
    style.font-size: 12
  }
  fstep2: "2. Validate: frame == 0 OR frame >= FRAME_COUNT\n   → kprintf WARNING; return" {
    style.fill: "#FEE2E2"
    style.stroke: "#DC2626"
    style.font-size: 12
  }
  fstep3: "3. Double-free check:\n   if !bitmap_test(frame) → kprintf BUG; return" {
    style.fill: "#FEE2E2"
    style.stroke: "#DC2626"
    style.font-size: 12
  }
  fstep4: "4. bitmap_clear(frame); pmm_used_frames--" {
    style.fill: "#D1FAE5"
    style.stroke: "#16A34A"
    style.font-size: 12
  }
  fstep5: "5. if frame < pmm_search_hint:\n      pmm_search_hint = frame  (update hint)" {
    style.fill: "#FEF3C7"
    style.stroke: "#D97706"
    style.font-size: 12
  }

  fstep1 -> fstep2
  fstep2 -> fstep3: "valid range"
  fstep3 -> fstep4: "bit was set"
  fstep4 -> fstep5
}

cache_perf: "Cache Line Performance Analysis" {
  style.fill: "#ECFDF5"
  style.stroke: "#059669"
  style.bold: true
  style.font-size: 13

  perf_note: |md
    **1 cache line (64 bytes) = 16 uint32_t words = 512 frames = 2MB**

    Full bitmap = 128KB = 2048 cache lines
    Fits in L2 cache (256KB–1MB) after first scan warm-up

    Sequential scan: hardware prefetcher loads ahead
    → subsequent allocs: L2 hit (~5ns per cache line)

    Word-skip optimization: O(1) per 32 frames
    vs pointer-chasing free-list: O(1) per frame but cache-miss per hop
  | {
    style.fill: "#ECFDF5"
    style.stroke: "#059669"
    style.font-size: 12
  }
}

phys_regions: "Physical Address Space Classification (post pmm_init)" {
  style.fill: "#F9FAFB"
  style.stroke: "#374151"
  style.bold: true
  style.font-size: 13

  region_table: {
    shape: sql_table
    "0x00000000–0x000FFFFF (1MB)": "USED — real-mode IVT, BIOS, VGA, ROM"
    "0x00100000–kernel_end": "USED — kernel code, data, BSS, bitmap"
    "0x00pgtbl_start–end (12KB)": "USED — boot_page_directory + 2 page tables"
    "kernel_end–E820_end": "FREE — allocatable RAM (usable by heap+processes)"
    "0xA0000–0xBFFFF (VGA MMIO)": "USED/RESERVED — BIOS video memory"
    "0xFECxxxxx–0xFFFFFFFF": "USED — APIC MMIO, BIOS ROM mirror"
  }
}

bitmap_container -> bit_detail: "1 bit per 4KB frame\nbit=0→FREE, bit=1→USED"
addr_macros -> bitmap_container: "index arithmetic\nframe = addr >> 12"
state_vars -> alloc_algo: "search_hint\nguides start"
alloc_algo -> bitmap_container: "bitmap_set()\nmark allocated"
free_algo -> bitmap_container: "bitmap_clear()\nmark free"
bitmap_container -> cache_perf: "128KB array\ncache behavior"
bitmap_container -> phys_regions: "reflects\nphysical layout"