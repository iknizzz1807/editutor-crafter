vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Kernel Heap: kmalloc Block Layout and Coalescing Algorithm
| {near: top-center}

# ── HEAP_BLOCK_T STRUCTURE ──────────────────────────────────────────────────

block_layout: "heap_block_t Header (20 bytes)" {
  style.fill: "#2D1B69"
  style.font-color: white
  style.stroke: "#7C3AED"
  style.border-radius: 4

  grid-rows: 1
  grid-gap: 0

  f0: "Offset 0\nmagic\nuint32_t\n0xDEADBEEF" {
    width: 130
    style.fill: "#7C3AED"
    style.font-color: white
    style.stroke: "#4C1D95"
    style.font-size: 12
  }
  f4: "Offset 4\nsize\nuint32_t\n(usable bytes)" {
    width: 130
    style.fill: "#7C3AED"
    style.font-color: white
    style.stroke: "#4C1D95"
    style.font-size: 12
  }
  f8: "Offset 8\nfree\nuint8_t\n1=free 0=used" {
    width: 130
    style.fill: "#7C3AED"
    style.font-color: white
    style.stroke: "#4C1D95"
    style.font-size: 12
  }
  f9: "Offset 9\n_pad[3]\n(alignment)" {
    width: 100
    style.fill: "#4C1D95"
    style.font-color: "#C4B5FD"
    style.stroke: "#4C1D95"
    style.font-size: 11
  }
  f12: "Offset 12\nnext*\nheap_block_t*\n(NULL if last)" {
    width: 130
    style.fill: "#EA580C"
    style.font-color: white
    style.stroke: "#9A3412"
    style.font-size: 12
  }
  f16: "Offset 16\nprev*\nheap_block_t*\n(NULL if first)" {
    width: 130
    style.fill: "#EA580C"
    style.font-color: white
    style.stroke: "#9A3412"
    style.font-size: 12
  }
  f20: "Offset 20\n[user data]\nsize bytes\n(8-byte aligned)" {
    width: 160
    style.fill: "#1D4ED8"
    style.font-color: white
    style.stroke: "#1E3A8A"
    style.font-size: 12
  }
}

legend_colors: "Color Key" {
  style.fill: "#1E1E2E"
  style.font-color: white
  style.stroke: "#374151"
  style.font-size: 12

  grid-columns: 2
  grid-gap: 4

  l_magic: "■ Purple = magic/size/free" { style.fill: "#7C3AED"; style.font-color: white; style.font-size: 11 }
  l_pad: "■ Dark Purple = padding" { style.fill: "#4C1D95"; style.font-color: "#C4B5FD"; style.font-size: 11 }
  l_ptr: "■ Orange = pointer fields" { style.fill: "#EA580C"; style.font-color: white; style.font-size: 11 }
  l_data: "■ Blue = user data region" { style.fill: "#1D4ED8"; style.font-color: white; style.font-size: 11 }
  l_free: "■ Green = free block" { style.fill: "#16A34A"; style.font-color: white; style.font-size: 11 }
  l_used: "■ Red = used/corrupt" { style.fill: "#DC2626"; style.font-color: white; style.font-size: 11 }
}

# ── HEAP VIRTUAL ADDRESS LAYOUT ──────────────────────────────────────────────

heap_vas: "Kernel Heap Virtual Address Space" {
  style.fill: "#0F172A"
  style.stroke: "#334155"
  style.font-color: "#94A3B8"
  style.border-radius: 4

  direction: down

  addr_start: "0xD0000000\nHEAP_START" {
    style.fill: "#1E293B"
    style.font-color: "#38BDF8"
    style.stroke: "#0284C7"
    style.font-size: 12
  }

  page0: "Page 0 (4KB) — heap_init() maps first" {
    style.fill: "#16A34A"
    style.font-color: white
    style.stroke: "#15803D"
    style.font-size: 12

    grid-rows: 1
    grid-gap: 0

    hdr0: "heap_block_t\nhdr (20B)\nfree=1" {
      width: 120
      style.fill: "#7C3AED"
      style.font-color: white
      style.font-size: 11
      style.stroke: "#4C1D95"
    }
    free0: "free space\n4096 - 20 = 4076 B\nusable" {
      width: 280
      style.fill: "#16A34A"
      style.font-color: white
      style.font-size: 11
      style.stroke: "#15803D"
    }
  }

  page1: "Page 1 (4KB) — mapped by heap_expand() on demand" {
    style.fill: "#1E3A8A"
    style.font-color: "#93C5FD"
    style.stroke: "#1D4ED8"
    style.font-size: 12
    style.stroke-dash: 5
  }

  page_n: "Pages 2…N — expand on demand" {
    style.fill: "#1E1E2E"
    style.font-color: "#6B7280"
    style.stroke: "#374151"
    style.font-size: 12
    style.stroke-dash: 5
  }

  addr_end: "0xDFFFFFFF\nHEAP_MAX" {
    style.fill: "#1E293B"
    style.font-color: "#F87171"
    style.stroke: "#DC2626"
    style.font-size: 12
  }

  addr_start -> page0: "heap_end\nadvances +4096"
  page0 -> page1: "heap_expand()\ncalled from kmalloc"
  page1 -> page_n: "…"
  page_n -> addr_end: "fatal halt\nat HEAP_MAX"
}

# ── LINKED LIST STATE DIAGRAMS ────────────────────────────────────────────────

# State 1: Initial (one free block)
state_init: "State 1: After heap_init()" {
  style.fill: "#0F172A"
  style.stroke: "#16A34A"
  style.font-color: "#4ADE80"
  style.border-radius: 4

  b0: "Block 0\n0xD0000000\nmagic=0xDEADBEEF\nsize=4076\nfree=1\nnext=NULL\nprev=NULL" {
    style.fill: "#16A34A"
    style.font-color: white
    style.stroke: "#15803D"
  }
  head_ptr: "heap_head" {
    style.fill: "#1E293B"
    style.font-color: "#4ADE80"
    style.stroke: "#16A34A"
    style.font-size: 12
  }
  head_ptr -> b0: "points to"
}

# State 2: After kmalloc(64) + kmalloc(128)
state_two: "State 2: After kmalloc(64), kmalloc(128)" {
  style.fill: "#0F172A"
  style.stroke: "#1D4ED8"
  style.font-color: "#93C5FD"
  style.border-radius: 4

  a_used: "Block A\n0xD0000000\nmagic=0xDEADBEEF\nsize=64\nfree=0\nnext→B\nprev=NULL" {
    style.fill: "#DC2626"
    style.font-color: white
    style.stroke: "#991B1B"
  }
  b_used: "Block B\n+84 (20+64)\nmagic=0xDEADBEEF\nsize=128\nfree=0\nnext→C\nprev→A" {
    style.fill: "#DC2626"
    style.font-color: white
    style.stroke: "#991B1B"
  }
  c_free: "Block C\n+232 (20+128)\nmagic=0xDEADBEEF\nsize=3864\nfree=1\nnext=NULL\nprev→B" {
    style.fill: "#16A34A"
    style.font-color: white
    style.stroke: "#15803D"
  }

  a_used -> b_used: "next" { style.stroke: "#EA580C" }
  b_used -> c_free: "next" { style.stroke: "#EA580C" }
  c_free -> b_used: "prev" { style.stroke: "#EA580C"; style.stroke-dash: 4 }
  b_used -> a_used: "prev" { style.stroke: "#EA580C"; style.stroke-dash: 4 }
}

# State 3: After kfree(B) — coalesce
state_coalesce: "State 3: After kfree(B) — coalesce with C" {
  style.fill: "#0F172A"
  style.stroke: "#D97706"
  style.font-color: "#FCD34D"
  style.border-radius: 4

  a2: "Block A\n0xD0000000\nsize=64\nfree=0\nnext→merged\nprev=NULL" {
    style.fill: "#DC2626"
    style.font-color: white
    style.stroke: "#991B1B"
  }
  merged: "Merged Block B+C\n+84\nsize = 128 + 20 + 3864 = 4012\nfree=1\nnext=NULL\nprev→A" {
    style.fill: "#16A34A"
    style.font-color: white
    style.stroke: "#15803D"
  }
  coalesce_note: |md
    **Coalesce forward (kfree Step 6):**
    B.size += sizeof(header) + C.size
    B.size = 128 + 20 + 3864 = **4012**
    B.next = C.next = NULL
  | {
    style.fill: "#1E293B"
    style.font-color: "#FCD34D"
    style.stroke: "#D97706"
    style.font-size: 12
  }

  a2 -> merged: "next" { style.stroke: "#EA580C" }
  merged -> a2: "prev" { style.stroke: "#EA580C"; style.stroke-dash: 4 }
}

# ── ALGORITHM STEPS ──────────────────────────────────────────────────────────

kmalloc_algo: "kmalloc(size) Algorithm" {
  style.fill: "#1A1A2E"
  style.stroke: "#1D4ED8"
  style.font-color: "#93C5FD"
  style.border-radius: 4

  s0: "1. size == 0 ?\nreturn NULL" {
    style.fill: "#374151"
    style.font-color: white
    style.font-size: 12
  }
  s1: "2. Align up to 8 bytes\nsize = (size+7) & ~7" {
    style.fill: "#1E3A8A"
    style.font-color: "#93C5FD"
    style.font-size: 12
  }
  s2: "3. Walk block list\nfrom heap_head" {
    style.fill: "#1E3A8A"
    style.font-color: "#93C5FD"
    style.font-size: 12
  }
  s3: "4. Check magic\n!= 0xDEADBEEF?\nHALT (corruption)" {
    style.fill: "#DC2626"
    style.font-color: white
    style.font-size: 12
  }
  s4: "5. block.free && block.size >= size ?" {
    style.fill: "#1E3A8A"
    style.font-color: "#93C5FD"
    style.font-size: 12
  }
  s5: "6. Can split?\nsize >= size + 20 + 8 ?" {
    style.fill: "#1E3A8A"
    style.font-color: "#93C5FD"
    style.font-size: 12
  }
  s6: "7. Split: create\nnew_block after data\nmark new_block free" {
    style.fill: "#16A34A"
    style.font-color: white
    style.font-size: 12
  }
  s7: "8. block.free = 0\nreturn ptr = block + 20" {
    style.fill: "#1D4ED8"
    style.font-color: white
    style.font-size: 12
  }
  s8: "9. No fit found:\nheap_expand()\nor extend last free block\nretry" {
    style.fill: "#92400E"
    style.font-color: "#FCD34D"
    style.font-size: 12
  }
  s9: "10. heap_end >= HEAP_MAX ?\nreturn NULL (OOM)" {
    style.fill: "#DC2626"
    style.font-color: white
    style.font-size: 12
  }

  s0 -> s1: "size > 0"
  s1 -> s2
  s2 -> s3: "each block"
  s3 -> s4: "magic OK"
  s4 -> s5: "fits"
  s4 -> s2: "skip\n(not free or too small)" { style.stroke-dash: 3 }
  s4 -> s8: "end of list\n(no fit found)"
  s5 -> s6: "yes"
  s5 -> s7: "no (no split)"
  s6 -> s7
  s8 -> s9: "check bounds"
  s9 -> s2: "expanded;\nretry list" { style.stroke-dash: 3 }
}

kfree_algo: "kfree(ptr) Algorithm" {
  style.fill: "#1A1A2E"
  style.stroke: "#16A34A"
  style.font-color: "#4ADE80"
  style.border-radius: 4

  f0: "1. ptr == NULL ?\nreturn (no-op)" {
    style.fill: "#374151"
    style.font-color: white
    style.font-size: 12
  }
  f1: "2. block = ptr - 20\n(recover header)" {
    style.fill: "#1E3A8A"
    style.font-color: "#93C5FD"
    style.font-size: 12
  }
  f2: "3. block.magic\n!= 0xDEADBEEF ?\nkprintf BUG; return" {
    style.fill: "#DC2626"
    style.font-color: white
    style.font-size: 12
  }
  f3: "4. block.free == 1 ?\nkprintf BUG double-free\nreturn" {
    style.fill: "#DC2626"
    style.font-color: white
    style.font-size: 12
  }
  f4: "5. block.free = 1" {
    style.fill: "#16A34A"
    style.font-color: white
    style.font-size: 12
  }
  f5: "6. next exists && next.free ?\nCoalesce forward:\nblock.size += 20 + next.size\nblock.next = next.next" {
    style.fill: "#16A34A"
    style.font-color: white
    style.font-size: 12
  }
  f6: "7. prev exists && prev.free ?\nCoalesce backward:\nprev.size += 20 + block.size\nprev.next = block.next" {
    style.fill: "#16A34A"
    style.font-color: white
    style.font-size: 12
  }

  f0 -> f1: "ptr != NULL"
  f1 -> f2
  f2 -> f3: "magic OK"
  f3 -> f4: "not double-free"
  f4 -> f5
  f5 -> f6: "(whether or not coalesced)"
}

# ── HEAP_EXPAND ───────────────────────────────────────────────────────────────

expand_box: "heap_expand() — On-Demand Physical Frame Mapping" {
  style.fill: "#1A1A2E"
  style.stroke: "#D97706"
  style.font-color: "#FCD34D"
  style.border-radius: 4

  grid-columns: 1

  e1: "1. heap_end > HEAP_MAX - PAGE_SIZE ?\nFATAL HALT (virtual space exhausted)" {
    style.fill: "#DC2626"
    style.font-color: white
    style.font-size: 12
  }
  e2: "2. phys = pmm_alloc_frame()\nNULL → FATAL HALT (OOM)" {
    style.fill: "#7C3AED"
    style.font-color: white
    style.font-size: 12
  }
  e3: "3. vmm_map_page(boot_pd, heap_end, phys,\nPAGE_PRESENT | PAGE_WRITABLE)\n→ tlb_flush_page(heap_end)" {
    style.fill: "#1D4ED8"
    style.font-color: white
    style.font-size: 12
  }
  e4: "4. heap_end += PAGE_SIZE\n(4KB advance)" {
    style.fill: "#16A34A"
    style.font-color: white
    style.font-size: 12
  }

  e1 -> e2: "space OK"
  e2 -> e3: "frame allocated"
  e3 -> e4
}

# ── CONNECTIONS ──────────────────────────────────────────────────────────────

block_layout -> state_init: "single block\nfills first page"
heap_vas -> state_init: "initial layout"
state_init -> state_two: "kmalloc(64)\nkmalloc(128)"
state_two -> state_coalesce: "kfree(B)"
state_coalesce -> state_two: "kmalloc(128)\nreuses merged block"
kmalloc_algo -> expand_box: "calls when\nno free block"
kfree_algo -> state_coalesce: "produces\ncoalesced state"