vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  ## Real Mode vs Protected Mode: Address Translation Comparison
| {near: top-center}

real_mode: Real Mode (16-bit) {
  style.fill: "#F0E6FF"
  style.stroke: "#7B2FBE"
  style.border-radius: 8

  rm_regs: Segment Registers {
    style.fill: "#E9D5FF"
    style.stroke: "#7B2FBE"
    style.border-radius: 4
    label: |md
      **CS** = 0x07C0 (Code Segment)\
      **DS** = 0x0000 (Data Segment)\
      **SS** = 0x0000 (Stack Segment)\
      **ES** = 0x0000 (Extra Segment)
    |
  }

  rm_ip: Instruction Pointer {
    style.fill: "#E9D5FF"
    style.stroke: "#7B2FBE"
    style.border-radius: 4
    label: |md
      **IP** = 0x0000\
      (16-bit offset)
    |
  }

  rm_formula: Address Calculation {
    style.fill: "#D8B4FE"
    style.stroke: "#6D28D9"
    style.border-radius: 4
    style.font: mono
    label: |md
      Physical Addr = Segment × 16 + Offset\
      \
      CS:IP = 0x07C0 × 16 + 0x0000\
            = 0x07C00 + 0x0000\
            = **0x07C00** (MBR load addr)
    |
  }

  rm_phys: Physical Address {
    style.fill: "#7C3AED"
    style.stroke: "#5B21B6"
    style.font-color: white
    style.border-radius: 4
    label: |md
      **0x07C00**\
      20-bit physical address\
      (no TLB, no protection)
    |
  }

  rm_limit: Addressable Range {
    style.fill: "#F3E8FF"
    style.stroke: "#7B2FBE"
    style.border-radius: 4
    label: |md
      Max = 0xFFFF:0xFFFF\
      = 0xFFFF0 + 0xFFFF\
      = **0x10FFEF** (~1 MB + 64 KB)\
      A20 line gates > 1 MB access
    |
  }

  rm_note: |md
    ⚠️ **No hardware protection**\
    Any code can access any memory.\
    Segment registers hold raw\
    base addresses (÷16).
  | {
    style.fill: "#FEF3C7"
    style.stroke: "#D97706"
    style.border-radius: 4
  }

  rm_regs -> rm_formula: "Segment × 16"
  rm_ip -> rm_formula: "+ Offset"
  rm_formula -> rm_phys: "20-bit result"
  rm_phys -> rm_limit
}

prot_mode: Protected Mode (32-bit) {
  style.fill: "#E0F2FE"
  style.stroke: "#0369A1"
  style.border-radius: 8

  pm_regs: Segment Selectors {
    style.fill: "#BAE6FD"
    style.stroke: "#0369A1"
    style.border-radius: 4
    label: |md
      **CS** = 0x0008 (GDT index 1, RPL 0)\
      **DS** = 0x0010 (GDT index 2, RPL 0)\
      Bits [15:3] = GDT index\
      Bit  [2]   = TI (0=GDT, 1=LDT)\
      Bits [1:0] = RPL (privilege)
    |
  }

  pm_eip: Extended Instruction Pointer {
    style.fill: "#BAE6FD"
    style.stroke: "#0369A1"
    style.border-radius: 4
    label: |md
      **EIP** = 0x00100000\
      (32-bit offset)
    |
  }

  gdt: Global Descriptor Table {
    style.fill: "#7B2FBE"
    style.font-color: white
    style.stroke: "#5B21B6"
    style.border-radius: 4
    label: |md
      **GDTR** register → GDT base address\
      \
      GDT[0]: Null (required)\
      GDT[1]: Kernel Code  Base=0, Limit=4GB\
      GDT[2]: Kernel Data  Base=0, Limit=4GB\
      GDT[3]: User Code    Base=0, Limit=4GB\
      GDT[4]: User Data    Base=0, Limit=4GB\
      \
      Each entry = 8 bytes\
      DPL field enforces ring 0/3 access
    |
  }

  pm_desc: Descriptor Fields {
    style.fill: "#0EA5E9"
    style.font-color: white
    style.stroke: "#0369A1"
    style.border-radius: 4
    label: |md
      **Base** [31:0]  = 0x00000000\
      **Limit** [19:0] = 0xFFFFF (×4KB = 4GB)\
      **DPL**  [1:0]   = 00 (ring 0)\
      **P** = 1 (present)\
      **G** = 1 (4KB granularity)\
      **D/B** = 1 (32-bit)
    |
  }

  pm_formula: Address Calculation {
    style.fill: "#BAE6FD"
    style.stroke: "#0369A1"
    style.border-radius: 4
    style.font: mono
    label: |md
      Physical Addr = Descriptor.Base + EIP\
      \
      = 0x00000000 + 0x00100000\
      = **0x00100000**\
      (flat model: base always 0)
    |
  }

  pm_phys: Physical Address {
    style.fill: "#0369A1"
    style.font-color: white
    style.stroke: "#075985"
    style.border-radius: 4
    label: |md
      **0x00100000**\
      32-bit physical address\
      (or virtual if paging on)
    |
  }

  pm_checks: Hardware Enforcement {
    style.fill: "#F0F9FF"
    style.stroke: "#0369A1"
    style.border-radius: 4
    label: |md
      ✓ Limit check: offset ≤ descriptor limit\
      ✓ DPL check: CPL ≤ descriptor DPL\
      ✓ Type check: code/data match access\
      ✗ Violation → **#GP (exception 13)**
    |
  }

  pm_note: |md
    ✅ **Hardware protection active**\
    Segment registers = GDT indices.\
    CPU validates every access against\
    base, limit, and privilege level.
  | {
    style.fill: "#DCFCE7"
    style.stroke: "#16A34A"
    style.border-radius: 4
  }

  pm_regs -> gdt: "CS selector\nlookup"
  pm_eip -> pm_formula: "+ EIP offset"
  gdt -> pm_desc: "8-byte descriptor"
  pm_desc -> pm_formula: "Base address"
  pm_formula -> pm_phys: "32-bit result"
  pm_phys -> pm_checks: "validated by"
  pm_checks -> pm_note
}

comparison: Key Differences {
  style.fill: "#FFF7ED"
  style.stroke: "#EA580C"
  style.border-radius: 8

  grid-columns: 2

  col_rm: Real Mode {
    style.fill: "#FED7AA"
    style.stroke: "#EA580C"
    style.border-radius: 4
    label: |md
      **Segment Reg** = Raw base (÷16)\
      **Address** = Seg×16 + Offset\
      **Range** = 1 MB (20-bit)\
      **Protection** = None\
      **Ring model** = None\
      **TLB** = N/A\
      **Exception** = IVT (real-mode)
    |
  }

  col_pm: Protected Mode {
    style.fill: "#BAE6FD"
    style.stroke: "#0369A1"
    style.border-radius: 4
    label: |md
      **Segment Reg** = GDT selector index\
      **Address** = Desc.Base + Offset\
      **Range** = 4 GB (32-bit)\
      **Protection** = DPL + limit check\
      **Ring model** = CPL 0–3\
      **TLB** = Active (if paging on)\
      **Exception** = IDT (32-bit gates)
    |
  }
}

transition: Protected Mode Transition Sequence {
  style.fill: "#F0FDF4"
  style.stroke: "#16A34A"
  style.border-radius: 8

  t1: "① cli — disable interrupts" {
    style.fill: "#DCFCE7"
    style.stroke: "#16A34A"
    style.border-radius: 4
  }
  t2: "② lgdt [gdt_descriptor] — load GDTR" {
    style.fill: "#DCFCE7"
    style.stroke: "#16A34A"
    style.border-radius: 4
  }
  t3: "③ mov cr0, eax (OR 1) — set PE bit" {
    style.fill: "#BBF7D0"
    style.stroke: "#15803D"
    style.border-radius: 4
  }
  t4: "④ jmp 0x08:pm_entry — far jump flushes pipeline" {
    style.fill: "#86EFAC"
    style.stroke: "#15803D"
    style.border-radius: 4
    style.bold: true
  }
  t5: "⑤ Load DS/ES/FS/GS/SS = 0x10 — all data segs" {
    style.fill: "#DCFCE7"
    style.stroke: "#16A34A"
    style.border-radius: 4
  }

  t1 -> t2: "mandatory order"
  t2 -> t3
  t3 -> t4: "pipeline flush\nrequired"
  t4 -> t5: "32-bit code\nexecuting"
}

real_mode -> comparison: "before switch"
prot_mode -> comparison: "after switch"
real_mode -> transition: "exit path"
transition -> prot_mode: "enter protected mode"