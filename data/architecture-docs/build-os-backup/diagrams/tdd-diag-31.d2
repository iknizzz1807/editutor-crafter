vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Round-Robin Preemptive Scheduler: sched_tick() and sched_schedule() Flow" {
  shape: text
  near: top-center
  style: {
    font-size: 22
    bold: true
  }
}

classes: {
  irq: {
    style: {
      fill: "#1a1a2e"
      font-color: white
      stroke: "#4a4e69"
      border-radius: 4
    }
  }
  decision: {
    shape: diamond
    style: {
      fill: "#16213e"
      font-color: "#e0e0e0"
      stroke: "#4a4e69"
    }
  }
  action: {
    style: {
      fill: "#0f3460"
      font-color: "#e0e0e0"
      stroke: "#4a4e69"
      border-radius: 4
    }
  }
  asm_block: {
    style: {
      fill: "#533483"
      font-color: white
      stroke: "#7b52ab"
      border-radius: 4
    }
  }
  kernel_state: {
    style: {
      fill: "#2c003e"
      font-color: "#e0e0e0"
      stroke: "#7b52ab"
      border-radius: 4
      bold: true
    }
  }
  process_box: {
    style: {
      fill: "#1b4332"
      font-color: "#d8f3dc"
      stroke: "#52b788"
      border-radius: 4
    }
  }
  zombie: {
    style: {
      fill: "#6b1a1a"
      font-color: "#ffb3b3"
      stroke: "#c9184a"
      border-radius: 4
    }
  }
  note: {
    shape: text
    style: {
      font-color: "#adb5bd"
      italic: true
    }
  }
}

# ─── COLUMN 1: IRQ Entry Path ───────────────────────────────────────────────

irq_fires: "IRQ0 Asserted\n(PIT 100 Hz)" {
  class: irq
}

irq_stub: "irq0 stub\n(irq_stubs.asm)\n\npush 0  ; dummy err\npush 32 ; vector\njmp irq_common_stub" {
  class: asm_block
}

common_stub_entry: "irq_common_stub entry\n(irq_stubs.asm)\n\npusha\npush gs/fs/es/ds\nmov ds/es/fs/gs, 0x10\npush esp  ; frame ptr\ncall irq_dispatcher" {
  class: asm_block
}

irq_dispatcher: "irq_dispatcher(frame)\n(interrupt.c)\n\nirq = frame->vector - 32\nif irq_handlers[irq]:\n    call it\npic_send_eoi(irq)" {
  class: action
}

sched_timer_irq: "sched_timer_irq(frame)\n(sched.c)\n\npit_tick_count++\nif !sched_initialized: return\nif !current_process: return\ncurrent_process->ticks_remaining--" {
  class: action
}

check_slice: "ticks_remaining > 0?" {
  class: decision
}

return_no_switch: "Return to irq_dispatcher\n→ pic_send_eoi(0)\n→ irq_common_stub exit\n→ popa; add esp,8; iret\n→ RESUME SAME PROCESS" {
  class: action
}

call_schedule: "sched_schedule()" {
  class: kernel_state
}

irq_fires -> irq_stub: "CPU: saves SS,ESP,EFLAGS,CS,EIP\nTSS.esp0 → kernel stack\n(ring-3) or stays (ring-0)" {
  style.stroke: "#4a4e69"
  style.font-size: 11
}

irq_stub -> common_stub_entry
common_stub_entry -> irq_dispatcher
irq_dispatcher -> sched_timer_irq: "irq == 0"
sched_timer_irq -> check_slice

check_slice -> return_no_switch: "Yes\n(common fast path)" {
  style.stroke: "#52b788"
}
check_slice -> call_schedule: "No\n(slice expired)" {
  style.stroke: "#e63946"
}

# ─── COLUMN 2: sched_schedule() Round-Robin Selection ───────────────────────

save_old: "old = current_process\ncurrent_idx = old - process_table\nif old->state == RUNNING:\n    old->state = READY" {
  class: action
}

rr_search: "Round-Robin Search\n\nfor i = 1 to MAX_PROCESSES:\n    idx = (current_idx + i) % MAX\n    if table[idx].state == READY:\n        next = &table[idx]; break" {
  class: action
}

found_next: "next != NULL?" {
  class: decision
}

no_ready: "No ready process\nold->state == READY?" {
  class: decision
}

keep_running: "old->state = RUNNING\nold->ticks_remaining =\n    SCHEDULER_TICKS_PER_SLICE\nreturn (no switch)" {
  class: action
}

fatal_halt: "kprintf(\"FATAL: No runnable process\")\nfor(;;) cli; hlt" {
  style: {
    fill: "#6b1a1a"
    font-color: "#ffb3b3"
    stroke: "#c9184a"
    border-radius: 4
  }
}

prepare_switch: "next->state = RUNNING\nnext->ticks_remaining =\n    SCHEDULER_TICKS_PER_SLICE\n\ncurrent_process = next  ← BEFORE switch\ntss_set_kernel_stack(\n    next->kernel_stack_top)" {
  class: action
}

call_schedule -> save_old
save_old -> rr_search
rr_search -> found_next

found_next -> no_ready: "No" {
  style.stroke: "#e63946"
}
found_next -> prepare_switch: "Yes" {
  style.stroke: "#52b788"
}

no_ready -> keep_running: "Yes" {
  style.stroke: "#52b788"
}
no_ready -> fatal_halt: "No" {
  style.stroke: "#e63946"
}

keep_running -> return_no_switch

# ─── COLUMN 3: context_switch_asm and Resume ────────────────────────────────

ctx_asm: "context_switch_asm(\n    &old->saved_esp,  ← arg1\n    next->saved_esp,  ← arg2\n    next->page_directory ← arg3\n)\n(context_switch.asm)" {
  class: asm_block
}

ctx_body: "context_switch_asm body:\n\n; Load ALL args BEFORE touching ESP\nmov eax, [esp+4]  ; old_esp_ptr\nmov ecx, [esp+8]  ; new_esp\nmov edx, [esp+12] ; new_cr3\n\n; Save current kernel ESP\nmov [eax], esp    ; *old_esp_ptr = esp\n\n; PIVOT to next process stack ←\nmov esp, ecx\n\n; Conditional CR3 reload\nmov eax, cr3\ncmp eax, edx\nje  .same_cr3\nmov cr3, edx  ; flush TLB\n.same_cr3:\n\nret  ; pop → irq_return_trampoline\n     ; or sched_schedule return addr" {
  class: asm_block
}

trampoline: "irq_return_trampoline:\n(first activation only)\n\npop eax; mov ds,ax\npop eax; mov es,ax\npop eax; mov fs,ax\npop eax; mov gs,ax\npopa\nadd esp, 8\niret  → PROCESS ENTRY POINT" {
  class: asm_block
}

resume_sched: "Return to sched_schedule()\n(preempted processes only)\n\n; Resumes at line AFTER\n; call context_switch_asm\ncurrent_process = old\nold->state = RUNNING" {
  class: action
}

stub_exit: "irq_common_stub exit:\nadd esp,4  ; pop frame ptr\npop gs/fs/es/ds\npopa\nadd esp,8  ; vector+errcode\niret  → RESUME NEXT PROCESS" {
  class: asm_block
}

prepare_switch -> ctx_asm
ctx_asm -> ctx_body

new_or_old: "First activation\nof next process?" {
  class: decision
}

ctx_body -> new_or_old: "ret executed\n(on next's stack)" {
  style.stroke-dash: 3
}

new_or_old -> trampoline: "Yes\n(trampoline addr\non fake stack)" {
  style.stroke: "#52b788"
}
new_or_old -> resume_sched: "No\n(real return addr\nfrom prior call)" {
  style.stroke: "#e0e0e0"
}

trampoline -> stub_exit: "iret fires"
resume_sched -> stub_exit: "Eventually returns\nthrough call stack\nback to irq_common_stub"

# ─── COLUMN 4: Process States and Stack Structures ──────────────────────────

state_diagram: "Process States" {
  unused: "UNUSED\n(pid=0, slot free)" {
    class: note
  }
  ready: "READY\n(can be scheduled)" {
    class: process_box
  }
  running: "RUNNING\n(current_process == this)\n(on CPU)" {
    class: kernel_state
  }
  blocked: "BLOCKED\n(waiting for event)" {
    style: {
      fill: "#3d405b"
      font-color: "#e0e0e0"
      stroke: "#888"
      border-radius: 4
    }
  }
  zombie_s: "ZOMBIE\n(exited; not freed)" {
    class: zombie
  }

  unused -> ready: "process_create_*()"
  ready -> running: "sched_schedule()\nselects this"
  running -> ready: "timer preempts\n(slice expired)"
  running -> zombie_s: "sys_exit()\ncurrent->state=ZOMBIE\nsched_schedule()"
  running -> blocked: "blocking I/O\n(future)"
  blocked -> ready: "event fires\n(future)"
}

stack_layout: "Kernel Stack at Context Switch\n(grows ↓, low addr at top)" {
  shape: rectangle
  style: {
    fill: "#1a1a2e"
    font-color: "#adb5bd"
    stroke: "#4a4e69"
    border-radius: 4
  }
  label: |md
    
    HIGH  kernel_stack_top
    ────────────────────────
    [+68] user_ss   ← ring-3 only
    [+64] user_esp  ← ring-3 only
    [+60] eflags = 0x202 (IF=1)
    [+56] cs     = 0x1B / 0x08
    [+52] eip    = entry / resume
    [+48] error_code = 0
    [+44] vector = 0
    [+40] eax = 0
    [+36] ecx = 0
    [+32] edx = 0
    [+28] ebx = 0
    [+24] esp_pusha (ignored)
    [+20] ebp = 0
    [+16] esi = 0
    [+12] edi = 0
    [ +8] ds  = 0x10
    [ +4] es  = 0x10
    [ +0] fs  = 0x10
    [-4 ] gs  = 0x10    ← saved_esp
    [-8 ] irq_return_trampoline addr
    LOW
    
  |
}

tss_box: "kernel_tss (104 bytes)\n\nesp0 = current process's\n       kernel_stack_top\nss0  = 0x10 (kernel data)\niomap_base = 104\n\nUpdated by tss_set_kernel_stack()\nBEFORE each context_switch_asm()" {
  style: {
    fill: "#16213e"
    font-color: "#90e0ef"
    stroke: "#0077b6"
    border-radius: 4
  }
}

hw_note: "Hardware on ring-3 interrupt:\n① Read tss.esp0 → kernel ESP\n② Read tss.ss0  → kernel SS\n③ Push user SS,ESP,EFLAGS,CS,EIP\n   onto kernel stack\n④ Jump to IDT handler" {
  class: note
}

# ─── ANNOTATIONS ─────────────────────────────────────────────────────────────

timing_note: |md
  **Scheduler Timing**

  - PIT: 100 Hz = 10ms tick
  - SCHEDULER_TICKS_PER_SLICE = 5
  - Time slice = 50ms per process
  - Context switch overhead: ~700–1000 cycles
  - sched_tick fast path (no switch): < 20 cycles
  - sched_schedule full path: < 200 cycles
  - tss_set_kernel_stack: < 5 cycles (L1 hit)
| {
  near: bottom-right
  style: {
    fill: "#1e1e2e"
    font-color: "#adb5bd"
    stroke: "#4a4e69"
    border-radius: 6
  }
}

ordering_note: |md
  **Critical Ordering in sched_schedule():**

  1. old->state = READY
  2. find next (round-robin)
  3. next->state = RUNNING
  4. **current_process = next** ← before switch
  5. **tss_set_kernel_stack(next->ktop)** ← before switch
  6. context_switch_asm(...)
  7. **current_process = old** ← after resume
  8. old->state = RUNNING
| {
  near: bottom-center
  style: {
    fill: "#1e1e2e"
    font-color: "#e9c46a"
    stroke: "#f4a261"
    border-radius: 6
  }
}

stub_exit -> irq_fires: "next process runs\nuntil next IRQ0" {
  style.stroke-dash: 3
  style.stroke: "#52b788"
  style.animated: true
}