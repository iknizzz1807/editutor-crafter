vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  ## IDT Gate Descriptor: Interrupt Gate vs Trap Gate (8 bytes)
| {near: top-center}

interrupt_gate: "Interrupt Gate (type_attr = 0x8E)" {
  style.fill: "#E8F4FD"
  style.stroke: "#1565C0"
  style.stroke-width: 2
  style.border-radius: 6

  fields: {
    style.fill: transparent
    style.stroke: transparent

    row1: {
      style.fill: transparent
      style.stroke: transparent
      label: |md
        **Byte Layout (0–7, low→high address)**
      |
    }

    byte_table: {
      style.fill: "#FAFAFA"
      style.stroke: "#1565C0"
      style.font: mono
      label: |md
        
        Byte 0–1  │ Offset [15:0]      │ Handler address low 16 bits
        Byte 2–3  │ Selector           │ 0x0008 (kernel code segment)
        Byte 4    │ Zero               │ 0x00 (reserved)
        Byte 5    │ type_attr          │ 0x8E = 1 00 0 1110
        Byte 6–7  │ Offset [31:16]     │ Handler address high 16 bits
        
      |
    }

    type_breakdown: "type_attr = 0x8E decomposition" {
      style.fill: "#E3F2FD"
      style.stroke: "#1565C0"
      style.border-radius: 4

      bits: {
        style.fill: transparent
        style.stroke: transparent
        label: |md
          
          Bit 7   P   = 1       Present (gate valid)
          Bit 6–5 DPL = 00      Ring 0 only (kernel-invokable)
          Bit 4   0   = 0       Must be zero
          Bit 3–0 Type= 1110    32-bit Interrupt Gate
          
        |
      }
    }

    effect_box: "Hardware Effect on Entry" {
      style.fill: "#FFECB3"
      style.stroke: "#F57F17"
      style.border-radius: 4
      label: |md
        **IF (Interrupt Flag) CLEARED on entry**
        → Hardware interrupts MASKED during handler
        → No nested hardware IRQs
        → Use for: hardware IRQ handlers (timer, keyboard)
      |
    }
  }
}

trap_gate: "Trap Gate (type_attr = 0x8F)" {
  style.fill: "#F3E5F5"
  style.stroke: "#6A1B9A"
  style.stroke-width: 2
  style.border-radius: 6

  fields: {
    style.fill: transparent
    style.stroke: transparent

    row1: {
      style.fill: transparent
      style.stroke: transparent
      label: |md
        **Byte Layout (0–7, low→high address)**
      |
    }

    byte_table: {
      style.fill: "#FAFAFA"
      style.stroke: "#6A1B9A"
      style.font: mono
      label: |md
        
        Byte 0–1  │ Offset [15:0]      │ Handler address low 16 bits
        Byte 2–3  │ Selector           │ 0x0008 (kernel code segment)
        Byte 4    │ Zero               │ 0x00 (reserved)
        Byte 5    │ type_attr          │ 0x8F = 1 00 0 1111
        Byte 6–7  │ Offset [31:16]     │ Handler address high 16 bits
        
      |
    }

    type_breakdown: "type_attr = 0x8F decomposition" {
      style.fill: "#EDE7F6"
      style.stroke: "#6A1B9A"
      style.border-radius: 4

      bits: {
        style.fill: transparent
        style.stroke: transparent
        label: |md
          
          Bit 7   P   = 1       Present (gate valid)
          Bit 6–5 DPL = 00      Ring 0 only (kernel-invokable)
          Bit 4   0   = 0       Must be zero
          Bit 3–0 Type= 1111    32-bit Trap Gate
          
        |
      }
    }

    effect_box: "Hardware Effect on Entry" {
      style.fill: "#E8F5E9"
      style.stroke: "#2E7D32"
      style.border-radius: 4
      label: |md
        **IF (Interrupt Flag) PRESERVED on entry**
        → Hardware interrupts remain ENABLED during handler
        → Handlers can be preempted by IRQs
        → Use for: CPU exceptions, system calls
      |
    }
  }
}

syscall_gate: "Syscall Gate (type_attr = 0xEF)" {
  style.fill: "#FFF3E0"
  style.stroke: "#E65100"
  style.stroke-width: 2
  style.border-radius: 6

  fields: {
    style.fill: transparent
    style.stroke: transparent

    byte_table: {
      style.fill: "#FAFAFA"
      style.stroke: "#E65100"
      style.font: mono
      label: |md
        
        Byte 5    │ type_attr          │ 0xEF = 1 11 0 1111
        
      |
    }

    type_breakdown: "type_attr = 0xEF decomposition" {
      style.fill: "#FFF8E1"
      style.stroke: "#E65100"
      style.border-radius: 4

      bits: {
        style.fill: transparent
        style.stroke: transparent
        label: |md
          
          Bit 7   P   = 1       Present
          Bit 6–5 DPL = 11      Ring 3 (user-mode callable via int N)
          Bit 4   0   = 0       Must be zero
          Bit 3–0 Type= 1111    32-bit Trap Gate (IF preserved)
          
        |
      }
    }

    effect_box: "Hardware Effect on Entry" {
      style.fill: "#E8F5E9"
      style.stroke: "#2E7D32"
      style.border-radius: 4
      label: |md
        **DPL=3: ring-3 code can invoke via `int 0x80`**
        → No GPF when user executes `int 0x80`
        → IF preserved (blocking syscalls don't mask timer)
        → Use for: INT 0x80 system call gate
      |
    }
  }
}

comparison: "Gate Type Comparison Matrix" {
  style.fill: "#ECEFF1"
  style.stroke: "#455A64"
  style.stroke-width: 2
  style.border-radius: 6

  table: {
    style.fill: "#FAFAFA"
    style.stroke: "#455A64"
    style.font: mono
    label: |md
      
      Property          │ Interrupt Gate │ Trap Gate  │ Syscall Gate
      ──────────────────┼────────────────┼────────────┼─────────────
      type_attr         │ 0x8E           │ 0x8F       │ 0xEF
      Type nibble       │ 0xE (1110)     │ 0xF (1111) │ 0xF (1111)
      P bit             │ 1              │ 1          │ 1
      DPL               │ 0 (ring 0)     │ 0 (ring 0) │ 3 (ring 3)
      IF on entry       │ Cleared (0)    │ Preserved  │ Preserved
      User-callable     │ No (GPF)       │ No (GPF)   │ Yes
      Use case          │ IRQ0–IRQ15     │ Exceptions │ INT 0x80
      
    |
  }
}

idtr_note: "IDTR Format (6 bytes, loaded by lidt)" {
  style.fill: "#E8EAF6"
  style.stroke: "#283593"
  style.border-radius: 4
  style.font: mono
  label: |md
    
    Bytes 0–1 │ Limit = 2047 (256 entries × 8 bytes − 1)
    Bytes 2–5 │ Base  = physical address of idt[256]
    
  |
}

interrupt_gate -> comparison: "0x8E"
trap_gate -> comparison: "0x8F"
syscall_gate -> comparison: "0xEF"
comparison -> idtr_note: "all 256 entries"