[
  {
    "milestone_id": "build-os-m1",
    "criteria": [
      "Bootloader Stage 1 fits in exactly 512 bytes with 0x55 0xAA boot signature at bytes 510-511, or uses a two-stage approach where Stage 1 (512 bytes) loads Stage 2 from disk before entering protected mode",
      "Bootloader reads the kernel binary from disk using BIOS INT 13h (function 0x02 or LBA extension 0x42) and loads it to a known physical address (0x100000 or equivalent)",
      "GDT contains at least 5 entries: null descriptor at index 0, kernel code at index 1 (ring 0, base=0, limit=4GB, access=0x9A), kernel data at index 2 (ring 0, base=0, limit=4GB, access=0x92), user code at index 3 (ring 3, access=0xFA), user data at index 4 (ring 3, access=0xF2), with 4KB granularity and 32-bit flags on all non-null entries",
      "Protected mode is entered by: (1) executing cli to disable interrupts, (2) loading GDTR with lgdt, (3) setting CR0 bit 0 (PE), (4) executing a far jump with selector 0x08 to flush the instruction pipeline",
      "All data segment registers (DS, ES, FS, GS, SS) are explicitly loaded with the kernel data selector (0x10) immediately after the far jump; ESP is set to a valid kernel stack address",
      "Kernel C entry point (in assembly) zeroes BSS by iterating from __bss_start to __bss_end (symbols defined in linker script) using rep stosd or rep stosb before calling the C kmain function",
      "VGA text mode driver writes 16-bit cells to 0xB8000 via volatile uint16_t pointer; each cell encodes ASCII character in low byte and foreground/background color attribute in high byte; driver correctly handles newline characters and column wrapping",
      "Serial port COM1 (base address 0x3F8) is initialized with correct DLAB sequence for baud rate configuration, 8N1 framing, and FIFO enable; serial_putchar polls the THRE bit before transmitting; output is visible in QEMU with -serial stdio",
      "A kprintf-style function sends formatted output to both VGA and serial simultaneously; kernel boots in QEMU and displays a welcome message on both the VGA screen and the serial console"
    ]
  },
  {
    "milestone_id": "build-os-m2",
    "criteria": [
      "Can explain the PIC vector collision problem: why IRQ0 maps to vector 8 by default and why this causes a triple fault if interrupts are enabled before remapping",
      "Has implemented pic_remap() sending the correct ICW1-ICW4 initialization sequence to both master (0x20/0x21) and slave (0xA0/0xA1) PICs, mapping IRQ0-7 to vectors 32-39 and IRQ8-15 to vectors 40-47",
      "Has constructed a 256-entry IDT with correctly packed 8-byte gate descriptors, using interrupt gates (0x8E) for hardware IRQs and trap gates (0x8F) for CPU exceptions",
      "Can explain the difference between interrupt gates and trap gates, specifically that interrupt gates clear IF on entry while trap gates do not, and why system calls require trap gates",
      "Has implemented ISR stubs for all 32 CPU exception vectors (0-31), correctly pushing a dummy zero error code for exceptions without error codes (0-7, 9, 15-16, 18-31) and letting the CPU-pushed error code stand for exceptions with error codes (8, 10-14, 17)",
      "Has implemented a common ISR stub that saves all general-purpose registers with pusha, saves segment registers, calls the C exception handler, restores all registers, pops the vector number and error code, and returns via iret",
      "Exception handler prints the exception name, vector number, error code, EIP, CS, EFLAGS, and general-purpose registers; page fault handler (vector 14) additionally reads and prints CR2",
      "Double fault handler (vector 8) prints a diagnostic message and halts with cli+hlt rather than attempting recovery",
      "Has implemented IRQ stubs for vectors 32-47 with a common irq_common_stub that saves/restores registers identically to the exception path",
      "Has implemented pic_send_eoi() that sends EOI to the slave PIC first (for IRQ8-15) then always sends EOI to the master PIC, and this is called unconditionally at the end of every IRQ handler",
      "Has configured PIT channel 0 at 100Hz using mode 2 (rate generator) by writing command byte 0x36 and divisor 11932 (low byte then high byte) to ports 0x43 and 0x40",
      "Timer handler increments a volatile uint64_t tick counter on every IRQ0; counter is observable from non-interrupt code",
      "Has implemented PS/2 keyboard handler that reads scancode from port 0x60, identifies break codes via bit 7, tracks shift state, translates make codes through a scancode-to-ASCII table, and places printable characters in a circular buffer",
      "keyboard_getchar() returns characters from the circular buffer without busy-waiting, returning 0 when the buffer is empty",
      "Interrupts are enabled with sti only after IDT is loaded, PIC is remapped, PIT is configured, and keyboard handler is registered",
      "Kernel boots in QEMU and demonstrates: (a) typed characters appearing on screen, (b) timer tick counter advancing when printed, (c) unhandled exceptions displaying a register dump rather than triple-faulting silently"
    ]
  },
  {
    "milestone_id": "build-os-m3",
    "criteria": [
      "Parse the multiboot/E820 memory map and classify all physical regions as usable RAM, reserved, ACPI, or bad; print the map at boot",
      "Initialize a bitmap physical frame allocator covering all usable RAM at 4KB granularity; frames occupied by the kernel binary, page tables, and multiboot data are pre-marked as used",
      "Detect and reject double-free in pmm_free_frame(); never allocate from reserved or bad regions",
      "Construct a page directory and page tables providing identity mapping for the first 4MB (covering kernel at 0x100000, VGA at 0xB8000, and MMIO) and a simultaneous higher-half mapping of the kernel at 0xC0000000",
      "Enable paging by loading CR3 with the page directory's physical address and setting CR0.PG; the system must not triple-fault â€” identity map must be active before CR0.PG is set",
      "Flush the TLB with invlpg after every individual PTE modification and with a CR3 reload after bulk page table changes; demonstrate at least one explicit flush in the codebase",
      "Implement a page fault handler (exception 14) that reads CR2 for the faulting virtual address, decodes the error code into present/write/user flags, and prints a diagnostic message before halting",
      "Implement vmm_map_page() that allocates a new page table frame from the PMM when the directory entry is not present, installs the PTE with correct flags, and flushes the TLB for the mapped address",
      "Implement a kernel heap allocator (kmalloc/kfree) operating from a dedicated virtual address range (e.g., 0xD0000000), backed by frames from pmm_alloc_frame() mapped via vmm_map_page(), supporting variable-size allocation and coalescing of adjacent free blocks on kfree",
      "Demonstrate the heap by calling kmalloc() for multiple sizes, verifying returned pointers are distinct and correctly aligned, then calling kfree() and re-allocating to verify block reuse"
    ]
  },
  {
    "milestone_id": "build-os-m4",
    "criteria": [
      "Implement a process_t PCB struct containing: PID, process_state_t enum (UNUSED/READY/RUNNING/BLOCKED/ZOMBIE), cpu_state_t with all general-purpose registers and EFLAGS, page_directory pointer (physical address), per-process kernel stack (4KB minimum), and kernel_stack_top field",
      "Implement context_switch_asm in assembly that: (1) saves current esp to old_process->cpu.esp before modifying esp, (2) loads all three arguments into registers before modifying esp, (3) switches to next process kernel stack via mov esp, new_esp, (4) conditionally reloads CR3 only when page directories differ, and (5) returns via ret into the IRQ stub exit path so popa+iret restores the next process",
      "Configure a TSS with ss0=0x10 and esp0 pointing to the initial process kernel stack; install the TSS descriptor in GDT index 5 with type=0x9 (system, available TSS); load the Task Register via ltr with the correct selector (0x28)",
      "Call tss_set_kernel_stack(next->kernel_stack_top) before context_switch_asm on every context switch so that TSS.ESP0 always points to the currently running process's kernel stack top",
      "Build fake initial kernel stack frames for new processes that exactly mirror the IRQ stub's stack layout: irq_return_trampoline address, then popa-order registers, then segment registers, then dummy vector+error, then EFLAGS=0x202 (IF=1), CS=0x08, and EIP=entry for kernel processes",
      "Wire the timer handler (IRQ0) to call sched_tick(), which decrements a per-process tick counter and calls sched_schedule() when the slice expires; sched_schedule() finds the next PROCESS_READY process in round-robin order and performs the context switch",
      "Demonstrate at least 3 kernel-mode processes running concurrently and preemptively, each writing counters to a distinct VGA screen region (different rows), with visible independent progress proving they are interleaved by the timer",
      "Create at least one user-mode process with: its own page directory (separate from boot_page_directory), user code mapped at a user-space virtual address with PAGE_USER set, a user stack mapped with PAGE_USER|PAGE_WRITABLE, and an initial stack frame using CS=0x1B and SS=0x23 (ring 3 selectors) so iret transitions to ring 3",
      "Verify ring 3 memory isolation: a user-mode process that reads or writes a kernel-space virtual address (above 0xC0000000) triggers a page fault with error code U=1 (user-mode violation), which the page fault handler catches and reports",
      "Register INT 0x80 in the IDT as a trap gate with DPL=3 (type_attr=0xEF) so user-mode code can invoke it; implement syscall_dispatch() that reads syscall number from frame->eax and arguments from frame->ebx/ecx/edx, and implement at minimum sys_write (writes bytes to VGA/serial) and sys_exit (marks process as PROCESS_ZOMBIE and calls sched_schedule)",
      "Validate that sys_write rejects buf_vaddr values >= 0xC0000000 with a -1 return code, demonstrating basic user-pointer validation before kernel dereference"
    ]
  },
  {
    "module_id": "mod-1",
    "criteria": [
      {
        "id": "c1-boot-signature",
        "description": "stage1.bin is exactly 512 bytes with bytes 510-511 equal to 0x55 0xAA",
        "test": "wc -c stage1.bin | grep 512 && xxd stage1.bin | tail -1 | grep '55 aa'",
        "phase": 1
      },
      {
        "id": "c1-a20-enabled",
        "description": "A20 line is enabled; physical address 0x100000 and 0x000000 are distinct",
        "test": "Stage2 A20 verify code completes without halt; 'A20 OK' appears on QEMU display",
        "phase": 2
      },
      {
        "id": "c1-kernel-loaded",
        "description": "Kernel binary loaded to physical 0x100000; first instruction at 0x100000 is valid 32-bit code",
        "test": "objdump -d kernel.elf | head -5 shows entry at 0x100000; QEMU does not triple-fault on JMP 0x100000",
        "phase": 2
      },
      {
        "id": "c1-gdt-five-entries",
        "description": "GDT contains exactly 5 entries: null, kernel code (0x08), kernel data (0x10), user code (0x18), user data (0x20) with correct access bytes 0x00/0x9A/0x92/0xFA/0xF2 and flags byte 0xCF for non-null entries",
        "test": "kmain reads GDTR via sgdt, dumps GDT bytes via serial, verify against expected byte sequence",
        "phase": 3
      },
      {
        "id": "c1-protected-mode",
        "description": "CR0.PE=1; far jump executed after CR0.PE set; no triple fault",
        "test": "QEMU -d int log shows no exception vectors 0-20 after disk reads; CS=0x0008 printed by kmain",
        "phase": 3
      },
      {
        "id": "c1-segment-registers",
        "description": "DS=ES=FS=GS=SS=0x10 after protected mode entry",
        "test": "kmain reads and prints all segment registers via inline asm; all equal 0x0010",
        "phase": 3
      },
      {
        "id": "c1-bss-zeroed",
        "description": "All bytes in .bss section are zero at kmain entry",
        "test": "Uninitialized static uint32_t bss_canary in kmain.c; kprintf prints its value; must be 0",
        "phase": 4
      },
      {
        "id": "c1-stack-valid",
        "description": "ESP points within the declared kernel_stack array; C function calls work correctly",
        "test": "Call a recursive function 3 levels deep from kmain; returns correctly; verify ESP is between __bss_start and __bss_end bounds",
        "phase": 4
      },
      {
        "id": "c1-linker-address",
        "description": "Kernel .text section linked at VMA 0x00100000; kmain symbol address >= 0x100000",
        "test": "nm kernel.elf | grep 'T kmain' shows address >= 0x100000; objdump -h kernel.elf shows .text VMA=0x00100000",
        "phase": 4
      },
      {
        "id": "c1-vga-output",
        "description": "VGA text mode driver writes colored characters to 0xB8000; visible on QEMU screen",
        "test": "vga_init() + vga_write_string produces visible text on QEMU display; cell at [0][0] contains correct attribute byte",
        "phase": 5
      },
      {
        "id": "c1-vga-scroll",
        "description": "Writing 26 newlines causes rows 1-24 to shift to rows 0-23 and row 24 to be cleared",
        "test": "Write 26 lines with distinct content; verify via reading VGA buffer that row N now contains what was on row N+1",
        "phase": 5
      },
      {
        "id": "c1-vga-volatile",
        "description": "VGA writes are not elided by compiler optimization at -O2",
        "test": "objdump -d vga.o compiled at -O2 contains mov instructions targeting address 0xB8000",
        "phase": 5
      },
      {
        "id": "c1-serial-output",
        "description": "COM1 serial port transmits bytes at 38400/8N1; kprintf output visible on QEMU -serial stdio terminal",
        "test": "qemu-system-i386 -serial stdio; terminal shows same text as VGA; serial_putchar('A') produces 'A' on terminal",
        "phase": 6
      },
      {
        "id": "c1-kprintf-formats",
        "description": "kprintf correctly formats %d, %u, %x, %X, %08x, %s, %c, %%",
        "test": "kprintf('0x%08x %d %s', 0xDEADBEEF, -42, 'hi') == '0xdeadbeef -42 hi' on both VGA and serial",
        "phase": 6
      },
      {
        "id": "c1-dual-output",
        "description": "Every kprintf call writes identical content to both VGA and COM1 serial",
        "test": "Capture serial output to file; compare against expected VGA content; byte-for-byte match (modulo CRLF)",
        "phase": 6
      },
      {
        "id": "c1-welcome-message",
        "description": "Kernel boots in QEMU and displays a welcome message on both VGA screen and serial console",
        "test": "qemu-system-i386 -drive format=raw,file=os.img -serial stdio; terminal and screen both show multi-line welcome message including GDT confirmation, mode, and segment register values",
        "phase": 7
      }
    ]
  },
  {
    "module_id": "mod-2",
    "criteria": [
      {
        "id": "m2-c1",
        "description": "IDT contains exactly 256 valid gate descriptors with present bit set; IDTR loaded via lidt with limit=2047 and base pointing to the idt[] array",
        "type": "functional",
        "verification": "sidt instruction reads back correct limit and base; all 256 entries have type_attr & 0x80 != 0"
      },
      {
        "id": "m2-c2",
        "description": "PIC remapped before sti: master PIC delivers IRQ0-7 at vectors 32-39, slave delivers IRQ8-15 at vectors 40-47; verified by -d int log showing v=20 (not v=08) on first timer tick",
        "type": "functional",
        "verification": "qemu -d int shows v=20 for timer IRQ; system does not triple-fault (reboot) after sti"
      },
      {
        "id": "m2-c3",
        "description": "CPU exception handlers (vectors 0-31) save all general-purpose and segment registers via pusha and segment pushes, print diagnostic including vector name, error code, EIP, CS, EFLAGS, and all GP registers, then halt with cli;hlt",
        "type": "functional",
        "verification": "trigger divide-by-zero; screen shows 'Divide Error', register dump, and 'System halted'; QEMU does not reboot"
      },
      {
        "id": "m2-c4",
        "description": "Page fault handler (vector 14) additionally reads and prints CR2 (faulting virtual address)",
        "type": "functional",
        "verification": "trigger access to unmapped address; CR2 value printed matches the faulting address"
      },
      {
        "id": "m2-c5",
        "description": "Double fault handler (vector 8) catches cascaded faults and halts with diagnostic message instead of causing a triple fault",
        "type": "functional",
        "verification": "double fault handler IDT entry verified present; handler body halts with cli;hlt and does not call complex functions that could re-fault"
      },
      {
        "id": "m2-c6",
        "description": "EOI sent to correct PIC(s) on every hardware IRQ: slave first (outb 0xA0, 0x20) then master (outb 0x20, 0x20) for IRQ8-15; master only for IRQ0-7",
        "type": "functional",
        "verification": "timer fires >10 times in 200ms (EOI working); keyboard fires on multiple keypresses (EOI working)"
      },
      {
        "id": "m2-c7",
        "description": "Spurious IRQ7 and IRQ15 detected via PIC ISR register read; EOI suppressed for genuine spurious (ISR bit clear); no crash on spurious interrupt",
        "type": "functional",
        "verification": "spurious7_handler and spurious15_handler registered; code review verifies pic_get_isr() called and EOI conditionally suppressed"
      },
      {
        "id": "m2-c8",
        "description": "PIT channel 0 configured at 100Hz (divisor 11932, command 0x36); pit_tick_count increments approximately 10 times per 100ms wall-clock period",
        "type": "performance",
        "verification": "record pit_tick_count before and after 100ms busy-wait; delta in range [9, 11]"
      },
      {
        "id": "m2-c9",
        "description": "pit_tick_count declared volatile; compiler does not cache it in a register across interrupt boundaries",
        "type": "implementation",
        "verification": "objdump of pit.o shows memory reference (not register) for pit_tick_count access at -O2"
      },
      {
        "id": "m2-c10",
        "description": "PS/2 keyboard IRQ1 handler reads scancode from port 0x60, filters break codes (bit7 set), handles extended prefix 0xE0 by discarding the next byte, translates make codes via scancode_ascii_lower and scancode_ascii_upper tables based on kb_shift_held state",
        "type": "functional",
        "verification": "typing 'a' returns 0x61; Shift+'a' returns 0x41; key release generates no character; arrow key generates no character"
      },
      {
        "id": "m2-c11",
        "description": "Circular keyboard buffer (256 bytes, power-of-2 for automatic uint8_t wrap) never crashes on overflow; oldest characters preserved when full; keyboard_getchar() returns 0 when empty",
        "type": "functional",
        "verification": "inject 260 characters programmatically; first 255 keyboard_getchar() calls return correct characters; 256th returns 0"
      },
      {
        "id": "m2-c12",
        "description": "All ISR/IRQ stubs save complete CPU state (all 8 GP registers via pusha, 4 segment registers explicitly) and restore it symmetrically (popa, segment pops, add esp 8, iret); interrupt_frame_t struct offsets verified via _Static_assert",
        "type": "implementation",
        "verification": "_Static_assert checks for gs=0, ds=12, edi=16, eax=44, vector=48, error_code=52, eip=56, cs=60, eflags=64 all pass at compile time"
      },
      {
        "id": "m2-c13",
        "description": "Exceptions that push error codes (8,10,11,12,13,14,17) use ISR_ERR macro; all others use ISR_NOERR macro; the dummy zero push in ISR_NOERR ensures uniform stack frame",
        "type": "implementation",
        "verification": "isr_stubs.asm reviewed; ISR_ERR used for vectors 8,10,11,12,13,14,17 and ISR_NOERR for all others"
      },
      {
        "id": "m2-c14",
        "description": "Interrupts enabled via sti only AFTER: idt_setup_all() loaded IDT, pic_remap() remapped PIC, pit_init() registered timer handler, keyboard_init() registered keyboard handler",
        "type": "functional",
        "verification": "kmain ordering verified by code review; sti appears after all four initialization calls"
      },
      {
        "id": "m2-c15",
        "description": "Keyboard echo demo: typing characters in QEMU echoes them to VGA and serial; ESC terminates the echo loop; system continues to run in idle hlt loop",
        "type": "functional",
        "verification": "manual test: type 'Hello' -> screen shows 'Hello'; press ESC -> 'Idle.' message appears; system does not crash"
      }
    ]
  },
  {
    "module_id": "mod-3",
    "criteria": [
      {
        "id": "mod-3-c1",
        "description": "pmm_parse_memory_map() iterates all E820 entries without skipping or duplicating any, using the correct advancement formula (entry->size + 4), and prints each region's type, base, and end address.",
        "verifiable_behavior": "Boot output shows all memory regions reported by QEMU GRUB, including the usable RAM region above 1MB and the reserved region covering 0xA0000-0xFFFFF, with no duplicate or garbled entries."
      },
      {
        "id": "mod-3-c2",
        "description": "pmm_init() marks all frames used by default, then frees usable E820 regions, then re-marks first 1MB, kernel binary, bitmap array, and static page table frames as used. Frame 0 is never allocatable.",
        "verifiable_behavior": "pmm_alloc_frame() called 1000 times returns no address below 0x100000 and no address within the kernel binary range [__kernel_start_phys, __kernel_end_phys). pmm_frames_used() + pmm_frames_free() == pmm_frames_total() after init."
      },
      {
        "id": "mod-3-c3",
        "description": "pmm_alloc_frame() returns distinct 4KB-aligned nonzero physical addresses. Double-free via pmm_free_frame() is detected by pre-free bitmap_test() and reported via kprintf without crashing or inflating the free count.",
        "verifiable_behavior": "Allocate 10 frames: all distinct, all 4KB-aligned, all nonzero. Free frame 2, reallocate: same address returned. Double-free on frame 2: BUG message printed; pmm_frames_free() unchanged from after first free."
      },
      {
        "id": "mod-3-c4",
        "description": "boot_page_directory[0] is present and points to identity_page_table; boot_page_directory[768] is present and points to kernel_page_table; all other PD entries are 0 (not present). All three arrays are 4KB-aligned.",
        "verifiable_behavior": "Runtime print of PD[0], PD[768], PD[1] shows expected values. nm kernel.elf shows all three symbols have addresses ending in 000 (hex). Static assert sizeof(pde_t) == 4 and static assert sizeof(pte_t) == 4 pass at compile time."
      },
      {
        "id": "mod-3-c5",
        "description": "vmm_enable_paging() loads CR3 with the physical address of boot_page_directory and sets CR0.PG=1. Execution continues without page fault because identity_page_table maps the currently executing code. VGA at 0xB8000 remains accessible via identity map.",
        "verifiable_behavior": "kprintf output continues after vmm_enable_paging() returns. Green 'P' character appears at VGA position [0][0]. CR0 read via inline asm has bit 31 set. CR3 read via inline asm equals (uint32_t)boot_page_directory. QEMU does not reboot."
      },
      {
        "id": "mod-3-c6",
        "description": "tlb_flush_page() emits an invlpg instruction targeting the specified virtual address. Every PTE modification in vmm_map_page() and vmm_unmap_page() is followed by tlb_flush_page() before the function returns.",
        "verifiable_behavior": "objdump -d vmm.o shows invlpg instruction in vmm_map_page and vmm_unmap_page. TLB correctness test: map frame A to virtual V, write 0xAAAAAAAA, unmap, map frame B to V, read V -- produces 0xBBBBBBBB (frame B's content), not 0xAAAAAAAA."
      },
      {
        "id": "mod-3-c7",
        "description": "Page fault handler (vector 14) saves CR2 as its first operation, decodes the error code P/W/U bits, prints the faulting address and bit interpretation, and halts without causing a triple fault.",
        "verifiable_behavior": "Deliberate null pointer dereference: output shows 'CR2: 0x00000000', 'P=0', 'W=0', 'U=0', 'null pointer dereference', 'halted'. QEMU does not reboot (-d int shows v=0e, not v=08 after it). Deliberate write to read-only page: output shows 'W=1'."
      },
      {
        "id": "mod-3-c8",
        "description": "kmalloc(n) returns a non-NULL 8-byte-aligned pointer to at least n usable bytes for all n > 0. kmalloc(0) returns NULL. Returned memory is writable and retains written values until kfree().",
        "verifiable_behavior": "kmalloc(1), kmalloc(64), kmalloc(4095), kmalloc(PAGE_SIZE*2) all return non-NULL, 8-byte-aligned pointers. Write 0xCAFEBABE to each; read back; values match. kmalloc(0) returns NULL without crash."
      },
      {
        "id": "mod-3-c9",
        "description": "kfree() returns memory to the free list and coalesces adjacent free blocks. Double-free is detected via the free flag check and reported via kprintf without crashing. Heap corruption via bad magic is detected in kmalloc and kfree.",
        "verifiable_behavior": "Alloc p1(64) + p2(128) + p3(64). Free p2. Alloc p4(64): address equals p2. Free p1, p3, p4: three adjacent frees coalesce. kheap_used()==0. Double-free p2: 'BUG: Double-free' printed, no crash. Corrupt next block magic, call kmalloc: 'CORRUPTION' printed."
      },
      {
        "id": "mod-3-c10",
        "description": "kmain() calls pmm_parse_memory_map(), pmm_init(), vmm_init(), vmm_enable_paging(), heap_init() in that exact order, with all prerequisites satisfied at each step. The memory subsystem is fully operational before the idle loop.",
        "verifiable_behavior": "Full boot produces: memory map output, PMM frame counts, VMM paging-enabled confirmation, heap initialization confirmation, followed by the milestone 3 test results (pmm, vmm, pf, heap all PASS), then idle loop. No exceptions, no reboots."
      }
    ]
  },
  {
    "module_id": "mod-4",
    "criteria": [
      {
        "id": "mod-4-c1",
        "description": "process_t PCB struct has cpu_state_t with all field offsets matching interrupt_frame_t layout: gs=0, fs=4, es=8, ds=12, edi=16, esi=20, ebp=24, esp_pusha=28, ebx=32, edx=36, ecx=40, eax=44, vector=48, error_code=52, eip=56, cs=60, eflags=64, user_esp=68, user_ss=72; static assertions verify all offsets at compile time",
        "verifiable": true
      },
      {
        "id": "mod-4-c2",
        "description": "TSS is 104 bytes (static assertion), ss0=0x10 after tss_init(), iomap_base=104, TR register contains 0x28 after ltr instruction, GDT entry 5 has access byte 0x89; read via str instruction and sidt confirm correct setup",
        "verifiable": true
      },
      {
        "id": "mod-4-c3",
        "description": "context_switch_asm() loads all three arguments (old_esp_ptr, new_esp, new_cr3) into registers BEFORE modifying ESP; verified by inspecting disassembly showing eax=[esp+4], ecx=[esp+8], edx=[esp+12] precede mov esp,ecx",
        "verifiable": true
      },
      {
        "id": "mod-4-c4",
        "description": "Fake initial kernel stack frame places irq_return_trampoline address at lowest address, then gs/fs/es/ds=0x10, then 8 zero GPR fields (pusha order), then vector=0 and error_code=0, then eip=entry, cs=0x08, eflags=0x202; saved_esp points to irq_return_trampoline word; verified by x/20x proc->saved_esp in GDB",
        "verifiable": true
      },
      {
        "id": "mod-4-c5",
        "description": "process_create_kernel() returns a PCB with state=PROCESS_READY, distinct pid, kernel_stack_top = kernel_stack + 4096 (16-byte aligned), page_directory = boot_page_directory, saved_esp within [kernel_stack, kernel_stack_top) range; two processes have non-overlapping kernel_stack arrays",
        "verifiable": true
      },
      {
        "id": "mod-4-c6",
        "description": "Round-robin scheduler calls tss_set_kernel_stack(next->kernel_stack_top) BEFORE context_switch_asm(); current_process = next set BEFORE context_switch_asm(); current_process = old restored AFTER context_switch_asm() returns; old->state = PROCESS_RUNNING set after return",
        "verifiable": true
      },
      {
        "id": "mod-4-c7",
        "description": "Three kernel processes (proc_a/b/c) concurrently print incrementing counters to distinct VGA rows 2, 12, 22 in different colors; counters increment independently at approximately equal rates; system runs stably for 5 minutes without crash",
        "verifiable": true
      },
      {
        "id": "mod-4-c8",
        "description": "process_create_user() allocates separate page directory, copies boot_page_directory PDEs 768-1023 with U/S=0, maps user code at virtual 0x00400000 (PAGE_PRESENT|PAGE_USER, read-only), maps user stack at 0x00BFF000 (PAGE_PRESENT|PAGE_WRITABLE|PAGE_USER), builds ring-3 initial frame with cs=0x1B, user_esp=0x00C00000, user_ss=0x23, eflags=0x202",
        "verifiable": true
      },
      {
        "id": "mod-4-c9",
        "description": "User process executes at CPL=3: CS register read from user code equals 0x001B; user access to virtual address >= 0xC0000000 triggers page fault with error code bits P=1, W=0, U=1 (= 0x05); system halts with correct diagnostic",
        "verifiable": true
      },
      {
        "id": "mod-4-c10",
        "description": "INT 0x80 gate registered at vector 0x80 with IDT_SYSCALL_GATE (type_attr=0xEF: P=1, DPL=3, trap gate); isr128 stub pushes dummy error_code=0 and vector=128, jumps to isr_common_stub; exception_handler dispatches to syscall_dispatch() when frame->vector==128",
        "verifiable": true
      },
      {
        "id": "mod-4-c11",
        "description": "sys_write(fd=1, buf, count): validates buf < 0xC0000000 before dereference; writes count bytes to VGA and serial; returns count on success; returns -1 if fd invalid or buf in kernel space; buffer spanning boundary is clamped to 0xC0000000",
        "verifiable": true
      },
      {
        "id": "mod-4-c12",
        "description": "sys_exit(code): prints exit message with PID and code; sets current_process->state = PROCESS_ZOMBIE; calls sched_schedule() which switches to another process; sys_exit_impl never returns; zombie process is never scheduled again",
        "verifiable": true
      },
      {
        "id": "mod-4-c13",
        "description": "user_hello process prints 'Hello from ring 3!' five times via sys_write, then calls sys_exit(0); serial output contains exactly five occurrences of the message followed by the exit confirmation; three kernel counters continue running after user process exits",
        "verifiable": true
      },
      {
        "id": "mod-4-c14",
        "description": "No CPU exception vectors 0-31 appear in QEMU -d int log during 60 seconds of steady-state operation after initialization; only v=20 (IRQ0 timer) and optionally v=21 (IRQ1 keyboard) appear; no triple faults",
        "verifiable": true
      },
      {
        "id": "mod-4-c15",
        "description": "EBX, ESI, EDI register values set in a kernel process before a context switch are identical after multiple context switches (verified by inline asm set before busy-loop and read after; proves all registers preserved by pusha/popa in irq_common_stub)",
        "verifiable": true
      }
    ]
  }
]