vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # x86 Boot Sequence: BIOS → Kernel Main
  ## The Handoff Chain from Power-On to C Entry
| {near: top-center}
direction: down
classes: {
  hardware: {
    shape: rectangle
    style: {
      fill: "#2D3436"
      font-color: white
      stroke: "#636E72"
      bold: true
    }
  }
  firmware: {
    shape: rectangle
    style: {
      fill: "#6C5CE7"
      font-color: white
      stroke: "#5B4BDB"
      bold: true
    }
  }
  bootloader: {
    shape: rectangle
    style: {
      fill: "#00B894"
      font-color: white
      stroke: "#00A381"
      bold: true
    }
  }
  kernel: {
    shape: rectangle
    style: {
      fill: "#E17055"
      font-color: white
      stroke: "#D35942"
      bold: true
    }
  }
  memory: {
    shape: cylinder
    style: {
      fill: "#0984E3"
      font-color: white
      stroke: "#0773C7"
    }
  }
  transition: {
    shape: diamond
    style: {
      fill: "#FDCB6E"
      stroke: "#F0B93E"
      font-color: "#2D3436"
    }
  }
}
section_hardware: Hardware Layer {
  style.fill: "#F8F9FA"
  style.stroke: "#DEE2E6"
  style.stroke-dash: 3
  power_on: "Power-On" {
    class: hardware
    tooltip: Reset vector at 0xFFFFFFF0
  }
  cpu_reset: CPU Reset {
    class: hardware
    label: ||md
      **CPU State:**
      - CS:IP = 0xF000:0xFFF0
      - EIP = 0xFFFFFFF0 (16-bit)
      - CR0.PE = 0 (Real Mode)
      - EFLAGS = 0x0002
    ||
  }
}
section_bios: BIOS/Firmware {
  style.fill: "#F0EBF8"
  style.stroke: "#6C5CE7"
  bios_post: POST {
    class: firmware
    label: ||md
      **Power-On Self-Test**
      - Memory detection (E820)
      - Hardware init
      - Boot device search
      - ~2-10 seconds
    ||
  }
  bios_mbr_load: Load MBR {
    class: firmware
    label: ||md
      **Read Sector 0**
      - LBA 0 → 0x7C00
      - Check boot signature
      - 0x55AA at offset 510-511
    ||
  }
  mbr_memory: MBR in Memory {
    class: memory
    label: ||md
      **0x7C00 - 0x7DFF (512 bytes)**
      +---------------------+
      | Code (~446 bytes)   |
      +---------------------+
      | Partition Table (64)|
      +---------------------+
      | 0x55 0xAA (sig)     |
      +---------------------+
    ||
  }
}
section_stage1: Stage 1 Bootloader {
  style.fill: "#E8F8F0"
  style.stroke: "#00B894"
  stage1_setup: Setup Environment {
    class: bootloader
    label: ||md
      **16-bit Real Mode**
      asm
      cli
      xor ax, ax
      mov ds, ax
      mov es, ax
      mov ss, ax
      mov sp, 0x7C00
      sti
    ||
  }
  stage1_a20: Enable A20 {
    class: bootloader
    label: ||md
      **A20 Gate Enable**
      1. BIOS INT 15h/2401
      2. Fast A20 (port 0x92)
      3. KBC (port 0x64/0x60)
      *Required for >1MB access*
    ||
  }
  stage1_gdt: Load GDT {
    class: bootloader
    label: ||md
      **Global Descriptor Table**
      asm
      lgdt [gdt_descriptor]
      5 entries: Null, KCode, KData, UCode, UData
    ||
  }
}
section_pm: Protected Mode Transition {
  style.fill: "#FFF9E6"
  style.stroke: "#FDCB6E"
  pm_enable: Enable PM {
    class: transition
    label: ||md
      **Set CR0.PE = 1**
      asm
      mov eax, cr0
      or eax, 1
      mov cr0, eax
      Warning: CPU now in "weird" state
    ||
  }
  pm_far_jump: Far Jump {
    class: transition
    label: ||md
      **Flush Pipeline**
      asm
      jmp 0x08:protected_mode
      - Loads CS = 0x08
      - Flushes 16-bit prefetch
      - Now truly 32-bit!
    ||
  }
  pm_reload: Reload Segments {
    class: bootloader
    label: ||md
      **Reload All Segments**
      asm
      mov ax, 0x10  ; KData
      mov ds, ax
      mov es, ax
      mov fs, ax
      mov gs, ax
      mov ss, ax
      mov esp, 0x90000
    ||
  }
}
section_stage2: Stage 2 / Kernel Load {
  style.fill: "#E8F8F0"
  style.stroke: "#00B894"
  stage2_load: Load Kernel {
    class: bootloader
    label: ||md
      **Read Kernel from Disk**
      - Target: 0x100000 (1MB)
      - Using INT 13h or LBA
      - May use "unreal mode"
      - ~32KB to 1MB+ size
    ||
  }
  kernel_image: Kernel Image {
    class: memory
    label: ||md
      **Memory Layout @ 0x100000**
      +---------------------+
      | .multiboot header   |
      +---------------------+
      | .text (code)        |
      +---------------------+
      | .rodata (const)     |
      +---------------------+
      | .data (init vars)   |
      +---------------------+
      | .bss (uninit)       |
      +---------------------+
    ||
  }
}
section_kernel: Kernel Entry {
  style.fill: "#FDECE8"
  style.stroke: "#E17055"
  kernel_entry: kernel_entry.asm {
    class: kernel
    label: ||md
      **Assembly Entry Point**
      asm
      kernel_entry:
        mov esp, 0x200000  ; Stack
        cld                ; Clear DF
        ; Zero BSS section
        mov edi, __bss_start
        mov ecx, __bss_end
        sub ecx, edi
        xor eax, eax
        rep stosb
        call kernel_main
    ||
  }
  kernel_main: kernel_main() {
    class: kernel
    label: ||md
      **C Entry Point**
      c
      void kernel_main(void) {
        vga_init();
        serial_init();
        kprintf("Hello!\n");
        // ... forever
      }
      **Freestanding C:**
      - No standard library
      - No malloc/free
      - No main() caller
    ||
  }
}
section_running: Running Kernel {
  style.fill: "#E8F4FD"
  style.stroke: "#0984E3"
  running_state: CPU State {
    class: hardware
    label: ||md
      **Final State:**
      - CR0.PE = 1 (Protected)
      - CR0.PG = 0 or 1 (Paging)
      - CS = 0x08 (Kernel Code)
      - DS/ES/SS = 0x10 (Kernel Data)
      - ESP = 0x200000 (Stack)
      - IDT loaded (interrupts)
    ||
  }
}
power_on -> cpu_reset: "Reset signal\n(RST# pin high)" {
  style.stroke-width: 3
}
cpu_reset -> bios_post: "Jump to\n0xFFFFFFF0" {
  style.stroke: "#6C5CE7"
  style.stroke-width: 2
}
bios_post -> bios_mbr_load: "POST OK\nBoot device found" {
  style.stroke: "#6C5CE7"
}
bios_mbr_load -> mbr_memory: "INT 13h, AH=02\nRead 1 sector" {
  style.stroke: "#0984E3"
  style.stroke-dash: 3
}
mbr_memory -> stage1_setup: "jmp 0x7C00\n(0x55AA valid)" {
  style.stroke: "#00B894"
  style.stroke-width: 2
}
stage1_setup -> stage1_a20: "Stack ready\nat 0x7C00 down" {
  style.stroke: "#00B894"
}
stage1_a20 -> stage1_gdt: "A20 enabled\n(addr >1MB OK)" {
  style.stroke: "#00B894"
}
stage1_gdt -> pm_enable: "GDTR loaded\n(gdt ptr)" {
  style.stroke: "#FDCB6E"
  style.stroke-width: 2
}
pm_enable -> pm_far_jump: "CR0.PE=1\n(protected mode)" {
  style.stroke: "#FDCB6E"
  style.stroke-width: 3
  style.animated: true
}
pm_far_jump -> pm_reload: "CS=0x08\n32-bit mode!" {
  style.stroke: "#FDCB6E"
  style.stroke-width: 3
  style.animated: true
}
pm_reload -> stage2_load: "Segments reload\nESP=0x90000" {
  style.stroke: "#00B894"
}
stage2_load -> kernel_image: "Read kernel\nsectors 2+" {
  style.stroke: "#0984E3"
  style.stroke-dash: 3
}
kernel_image -> kernel_entry: "jmp 0x100000\n(kernel entry)" {
  style.stroke: "#E17055"
  style.stroke-width: 3
}
kernel_entry -> kernel_main: "BSS zeroed\nStack ready" {
  style.stroke: "#E17055"
  style.stroke-width: 2
}
kernel_main -> running_state: "Kernel\nrunning!" {
  style.stroke: "#0984E3"
  style.stroke-width: 3
  style.animated: true
}
legend: {
  near: bottom-right
  label: ||md
    **Legend**
    - BIOS/Firmware
    - Bootloader (ASM)
    - Kernel (C/ASM)
    - Memory Region
    - Mode Transition
    - Hardware State
  ||
  style: {
    fill: "#F8F9FA"
    stroke: "#DEE2E6"
    stroke-dash: 2
  }
}
timing: {
  near: bottom-left
  label: ||md
    **Typical Timing (QEMU)**
    | Phase | Time |
    |-------|------|
    | BIOS POST | ~50-500ms |
    | MBR Load | ~1ms |
    | Stage 1 | ~1ms |
    | PM Switch | ~1us |
    | Kernel Load | ~10ms |
    | Kernel Entry | ~1us |
    | **Total** | **~100-600ms** |
  ||
  style: {
    fill: "#F8F9FA"
    stroke: "#DEE2E6"
  }
}
addresses: {
  near: bottom-center
  label: ||md
    **Critical Memory Addresses**
    | Address | Purpose |
    |---------|---------|
    | 0x7C00 | MBR load point |
    | 0x7E00 | Stage 2 (optional) |
    | 0x90000 | Kernel stack (temp) |
    | 0x100000 | Kernel load (1MB) |
    | 0x200000 | Kernel stack (2MB) |
    | 0xB8000 | VGA text buffer |
    | 0xFFFFFFF0 | BIOS reset vector |
  ||
  style: {
    fill: "#F8F9FA"
    stroke: "#DEE2E6"
  }
}
responsibilities: {
  near: top-right
  label: ||md
    **Component Responsibilities**
    **BIOS:**
    - Hardware init
    - Memory detection
    - Load first sector
    **Stage 1 (MBR):**
    - Enable A20
    - Load GDT
    - Enter protected mode
    - Load stage 2/kernel
    **Stage 2 (optional):**
    - File system support
    - Kernel selection
    - Multiboot info
    **Kernel Entry:**
    - Set up stack
    - Zero BSS
    - Call kernel_main
  ||
  style: {
    fill: "#F8F9FA"
    stroke: "#DEE2E6"
  }
}