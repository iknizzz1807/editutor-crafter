vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    bios: "#4A5568"
    mbr: "#ED8936"
    stage2: "#48BB78"
    pmode: "#4299E1"
    kernel: "#9F7AEA"
    data_flow: "#3182CE"
    hot: "#E53E3E"
  }
}

title: |md
  # Boot Sequence: BIOS to MBR to Protected Mode to C Entry
  **x86 32-bit Bootstrap Trace** | Total time: ~50-100ms
| {
  near: top-center
}

direction: right

timeline_header: {
  grid-columns: 5
  grid-gap: 0
  
  t1: "T0\n0ms" {
    style.fill: transparent
    style.stroke-width: 0
  }
  t2: "T1\n~5ms" {
    style.fill: transparent
    style.stroke-width: 0
  }
  t3: "T2\n~15ms" {
    style.fill: transparent
    style.stroke-width: 0
  }
  t4: "T3\n~25ms" {
    style.fill: transparent
    style.stroke-width: 0
  }
  t5: "T4\n~50ms" {
    style.fill: transparent
    style.stroke-width: 0
  }
}

stage1_bios: BIOS POST {
  style.fill: "${colors.bios}"
  style.font-color: white
  
  post: Power-On Self Test {
    style.fill: "#2D3748"
    style.font-color: white
  }
  
  hardware_init: Hardware Init {
    style.fill: "#2D3748"
    style.font-color: white
  }
  
  mbr_search: Search Boot Disk {
    style.fill: "#2D3748"
    style.font-color: white
  }
  
  post -> hardware_init -> mbr_search
}

bios_load: BIOS Disk Read {
  style.fill: "${colors.bios}"
  
  op: |md
    **INT 13h, AH=02h**
    
    DL = 0x80 (first HDD)
    ES:BX = 0x0000:0x7C00
    AL = 1 sector
  | {
    style.fill: "#2D3748"
    style.font-color: white
  }
  
  signature: "Verify: Bytes 511-512 = 0x55 0xAA" {
    style.fill: "#2D3748"
    style.font-color: white
  }
  
  op -> signature
}

mbr_memory: MBR in Memory {
  style.fill: "${colors.mbr}"
  
  addr: |md
    **Physical Address: 0x7C00**
    
    0x7C00: [Boot code - 446 bytes]
    0x7BE: [Partition table - 64 bytes]
    0x7FE: [0x55]
    0x7FF: [0xAA] - Boot signature
  | {
    style.fill: "#FED7AA"
  }
  
  constraint: "CONSTRAINT: 512 bytes max!" {
    style.fill: "${colors.hot}"
    style.font-color: white
  }
}

stage1_bios -> bios_load: "BIOS jumps to\n0x7C00" {
  style.stroke: "${colors.data_flow}"
  style.stroke-width: 3
}

bios_load -> mbr_memory: "LOAD:\n512 bytes" {
  style.stroke: "${colors.mbr}"
  style.stroke-width: 3
}

stage2_mbr: Stage 1 Bootloader {
  style.fill: "${colors.mbr}"
  
  reg_init: |md
    **Register Initialization**
    
    CLI - Disable interrupts
    XOR AX, AX
    MOV DS, AX - DS = 0x0000
    MOV ES, AX - ES = 0x0000  
    MOV SS, AX - SS = 0x0000
    MOV SP, 0x7C00 - Stack grows down
  | {
    style.fill: "#FED7AA"
  }
  
  a20_enable: |md
    **Enable A20 Line**
    
    IN AL, 0x92
    OR AL, 0x02 - Set A20 bit
    OUT 0x92, AL
    
    Gate 21st address line
    Access memory > 1MB
  | {
    style.fill: "#FED7AA"
  }
  
  reg_init -> a20_enable
}

mbr_memory -> stage2_mbr: "EXECUTE:\nCS:IP = 0x0000:0x7C00" {
  style.stroke: "${colors.mbr}"
  style.stroke-width: 3
  style.animated: true
}

disk_read: Load Kernel from Disk {
  style.fill: "${colors.mbr}"
  
  dap: |md
    **Disk Address Packet**
    
    DAP:
      DB 0x10 - Size = 16 bytes
      DB 0x00 - Reserved
      DW 50 - Sectors to read
      DW 0x0000, 0x1000 - Buffer 0x10000
      DQ 1 - Start LBA = 1
  | {
    style.fill: "#FED7AA"
  }
  
  int13: |md
    **Extended Read**
    
    MOV AH, 0x42 - Extended read
    MOV DL, 0x80 - Drive number
    MOV SI, DAP
    INT 0x13
  | {
    style.fill: "#FED7AA"
  }
  
  dap -> int13
}

stage2_mbr -> disk_read: "LOAD KERNEL\n~25KB from disk" {
  style.stroke: "${colors.mbr}"
  style.stroke-width: 2
}

gdt_setup: GDT Configuration {
  style.fill: "${colors.stage2}"
  
  gdt_mem: |md
    **Global Descriptor Table**
    
    GDT at 0x800 (example):
    
    [0x00] Null Descriptor
           DQ 0x0000000000000000
    
    [0x08] Kernel Code (base=0, limit=4GB)
           DQ 0x00CF9A000000FFFF
           Present, Ring 0
           Executable, Readable
           32-bit, 4KB granularity
    
    [0x10] Kernel Data (base=0, limit=4GB)
           DQ 0x00CF92000000FFFF
           Present, Ring 0
           Writable
           32-bit, 4KB granularity
  | {
    style.fill: "#C6F6D5"
  }
  
  gdtr: |md
    **Load GDTR**
    
    GDTR:
      DW gdt_end - gdt - 1 - Limit
      DD 0x800 - GDT base
    
    LGDT [GDTR]
  | {
    style.fill: "#C6F6D5"
  }
  
  gdt_mem -> gdtr
}

disk_read -> gdt_setup: "GDT in memory" {
  style.stroke: "${colors.stage2}"
}

gdt_detail: GDT Entry Decode {
  style.fill: "${colors.stage2}"
  
  entry: |md
    **Kernel Code Descriptor: 0x00CF9A000000FFFF**
    
    Bits 0-15:  Limit [15:0]    = 0xFFFF
    Bits 16-39: Base [23:0]     = 0x000000
    Bits 40-47: Access Byte     = 0x9A
      Bit 7: Present (P)        = 1
      Bits 5-6: DPL             = 00 (Ring 0)
      Bit 4: System (S)         = 1
      Bit 3: Executable (E)     = 1
      Bit 2: Direction (DC)     = 0
      Bit 1: Readable (R)       = 1
      Bit 0: Accessed (A)       = 0
    Bits 48-51: Limit [19:16]   = 0xF
    Bits 52-55: Flags           = 0xC
      Bit 7: Granularity (G)    = 1 (4KB)
      Bit 6: Size (D/B)         = 1 (32-bit)
      Bit 5: Long (L)           = 0
    Bits 56-63: Base [31:24]    = 0x00
  | {
    style.fill: "#C6F6D5"
  }
}

gdt_setup -> gdt_detail: "Decode" {
  style.stroke-dash: 3
}

pmode_entry: Enter Protected Mode {
  style.fill: "${colors.pmode}"
  
  cr0_set: |md
    **Set CR0.PE Bit**
    
    MOV EAX, CR0
    OR EAX, 0x00000001 - Set PE bit
    MOV CR0, EAX
    
    CPU now in 32-bit protected mode
  | {
    style.fill: "#BEE3F8"
  }
  
  far_jump: |md
    **CRITICAL: Far Jump**
    
    JMP 0x08:protected_mode_entry
    
    - Flushes prefetch queue
    - Loads CS = 0x08 (kernel code selector)
    - CPU validates GDT entry
    - Jumps to 32-bit code
  | {
    style.fill: "${colors.hot}"
    style.font-color: white
  }
  
  cr0_set -> far_jump
}

gdt_setup -> pmode_entry: "Protected Mode\nTransition" {
  style.stroke: "${colors.pmode}"
  style.stroke-width: 3
  style.animated: true
}

seg_load: Load Segment Registers {
  style.fill: "${colors.pmode}"
  
  seg_regs: |md
    **Protected Mode Segment Loads**
    
    [BITS 32]
    protected_mode_entry:
        MOV AX, 0x10 - Kernel data selector
        MOV DS, AX
        MOV ES, AX
        MOV FS, AX
        MOV GS, AX
        MOV SS, AX
        MOV ESP, 0x90000 - Kernel stack
    
    All data segments to Kernel data (GDT index 2)
  | {
    style.fill: "#BEE3F8"
  }
}

pmode_entry -> seg_load: "CS = 0x08\n32-bit mode" {
  style.stroke: "${colors.pmode}"
  style.stroke-width: 3
}

kernel_copy: Copy Kernel to Final Location {
  style.fill: "${colors.pmode}"
  
  copy_op: |md
    **Relocate Kernel**
    
    Copy from 0x10000 to 0x100000
    MOV ESI, 0x10000 - Source
    MOV EDI, 0x100000 - Destination (1MB)
    MOV ECX, kernel_size
    REP MOVSB
  | {
    style.fill: "#BEE3F8"
  }
  
  jump_kernel: |md
    **Jump to Kernel Entry**
    
    JMP 0x08:0x100000
  | {
    style.fill: "#BEE3F8"
  }
  
  copy_op -> jump_kernel
}

seg_load -> kernel_copy: "Copy to\n0x100000" {
  style.stroke: "${colors.pmode}"
}

c_entry: C Kernel Entry {
  style.fill: "${colors.kernel}"
  
  asm_entry: |md
    **kernel_entry.asm**
    
    [BITS 32]
    [GLOBAL kernel_entry]
    [EXTERN kernel_main]
    [EXTERN __bss_start]
    [EXTERN __bss_end]
    
    kernel_entry:
        Zero BSS section
        MOV EDI, __bss_start
        MOV ECX, __bss_end
        SUB ECX, EDI
        XOR EAX, EAX
        REP STOSB
        
        Call C main
        CALL kernel_main
        
        Halt if main returns
        CLI
    .halt:
        HLT
        JMP .halt
  | {
    style.fill: "#E9D8FD"
  }
  
  bss_zero: |md
    **BSS Zeroing**
    
    Memory range:
    __bss_start to __bss_end
    
    Why? No CRT0 in kernel!
    C runtime normally zeros BSS.
    We must do it manually.
  | {
    style.fill: "#E9D8FD"
  }
  
  asm_entry -> bss_zero
}

kernel_copy -> c_entry: "JMP 0x08:0x100000" {
  style.stroke: "${colors.kernel}"
  style.stroke-width: 3
  style.animated: true
}

c_main: kernel_main() {
  style.fill: "${colors.kernel}"
  
  main_code: |md
    **main.c**
    
    void kernel_main(void) {
        vga_init();
        serial_init(COM1_PORT);
        
        kprintf("Welcome to MyOS!");
        kprintf("Kernel at 0x100000");
        
        idt_init();
        pmm_init();
        vmm_init();
        
        while(1) { halt(); }
    }
  | {
    style.fill: "#E9D8FD"
  }
}

c_entry -> c_main: "CALL" {
  style.stroke: "${colors.kernel}"
  style.stroke-width: 3
}

memory_map: Final Memory Layout {
  style.fill: "#2D3748"
  style.font-color: white
  
  layout: |md
    **Physical Memory Map**
    
    0x000000 - 0x00FFFF : Low memory (BIOS, IVT)
    0x007C00 - 0x007DFF : MBR (bootloader)
    0x00800  - 0x00FFF  : GDT
    0x010000 - 0x0FFFFF : Temporary kernel load
    0x100000 - 0x1FFFFF : Kernel (1MB mark)
    0x200000+           : Available RAM
    0xB8000             : VGA text buffer
    0x3F8-0x3FF         : COM1 serial port
  | {
    style.fill: "#1A202C"
  }
}

cpu_state: CPU State Summary {
  style.fill: "#2D3748"
  style.font-color: white
  
  state: |md
    **At kernel_main() entry:**
    
    CR0 = 0x00000001 (PE=1, protected mode)
    CR3 = 0x00000000 (no paging yet)
    CS  = 0x08 (kernel code, GDT index 1)
    DS  = 0x10 (kernel data, GDT index 2)
    SS  = 0x10, ESP = 0x90000
    GDTR = base:0x800, limit:39
    IDTR = not loaded (interrupts disabled)
  | {
    style.fill: "#1A202C"
  }
}

legend: Legend {
  near: bottom-center
  
  grid-columns: 5
  grid-gap: 20
  
  l1: "BIOS" {
    style.fill: "${colors.bios}"
    style.font-color: white
  }
  l2: "MBR/Real Mode" {
    style.fill: "${colors.mbr}"
  }
  l3: "Protected Mode" {
    style.fill: "${colors.pmode}"
  }
  l4: "Kernel" {
    style.fill: "${colors.kernel}"
  }
  l5: "Critical" {
    style.fill: "${colors.hot}"
    style.font-color: white
  }
}

timing: Timing Summary {
  near: bottom-right
  style.fill: "#EDF2F7"
  
  times: |md
    **Boot Timing (approximate)**
    
    T0 (0ms): Power on, BIOS POST
    T1 (5ms): BIOS loads MBR
    T2 (15ms): MBR loads kernel
    T3 (25ms): Enter protected mode
    T4 (50ms): C kernel running
  |
}

critical: Critical Operations {
  near: bottom-left
  style.fill: "${colors.hot}"
  style.font-color: white
  
  ops: |md
    **Never Skip These!**
    
    1. Far jump after CR0.PE - Flushes pipeline
    2. A20 enable - Required for >1MB access
    3. BSS zeroing - Uninitialized globals = 0
    4. CLI before setup - No IDT yet!
  |
}