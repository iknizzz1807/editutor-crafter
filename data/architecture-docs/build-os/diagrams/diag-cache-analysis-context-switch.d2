vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Context Switch: Cache & TLB Impact
  ## The Hidden Cost of Multitasking
| {near: top-center}

direction: right

classes: {
  hardware: {
    style: {
      fill: "#E8E8E8"
      stroke: "#666"
      stroke-width: 2
      border-radius: 8
    }
  }
  process-box: {
    style: {
      fill: "#FFF9E6"
      stroke: "#D4A800"
      stroke-width: 2
      border-radius: 6
    }
  }
  hot: {
    style: {
      fill: "#FFE0E0"
      stroke: "#CC0000"
    }
  }
  cold: {
    style: {
      fill: "#E0E0FF"
      stroke: "#0000CC"
    }
  }
  invalidated: {
    style: {
      fill: "#F0F0F0"
      stroke: "#999"
      stroke-dash: 3
      opacity: 0.5
    }
  }
  cost-label: {
    shape: text
    style: {
      font-size: 14
      bold: true
    }
  }
}

before: Process A Running {
  class: hardware

  cpu_state: CPU State (Process A) {
    style.fill: "#FFE6CC"
    
    cr3_a: CR3 = 0x1000
    registers_a: "EAX, EBX, ECX...\nEIP, ESP, EFLAGS"
  }

  tlb: TLB (50 entries) {
    grid-columns: 5
    grid-gap: 2
    
    tlb_a1: "0x4000→PA" {class: hot}
    tlb_a2: "0x4010→PA" {class: hot}
    tlb_a3: "0x4020→PA" {class: hot}
    tlb_a4: "..." {style.fill: transparent; style.stroke-width: 0}
    tlb_a5: "0x5000→PA" {class: hot}
    tlb_a6: "0x5010→PA" {class: hot}
    tlb_a7: "0x5020→PA" {class: hot}
    tlb_a8: "..." {style.fill: transparent; style.stroke-width: 0}
    tlb_a9: "0x6000→PA" {class: hot}
    tlb_a10: "0x6010→PA" {class: hot}
  }

  l1_cache: L1 Cache (32KB) {
    grid-columns: 4
    grid-gap: 2
    
    l1_a1: "A's code" {class: hot}
    l1_a2: "A's heap" {class: hot}
    l1_a3: "A's stack" {class: hot}
    l1_a4: "A's data" {class: hot}
  }

  branch_pred: Branch Predictor {
    style.fill: "#E6FFE6"
    bp_a: "Process A patterns loaded"
  }

  tlb_cost: "TLB Hit: ~1 cycle" {
    shape: text
    style.font-color: green
  }
}

switch_arrow: "→" {
  shape: text
  style: {
    font-size: 48
    font-color: red
    bold: true
  }
  near: center-right
}

after: Process B Running {
  class: hardware

  cpu_state_b: CPU State (Process B) {
    style.fill: "#E6CCFF"
    
    cr3_b: CR3 = 0x2000
    registers_b: "EAX, EBX, ECX...\nEIP, ESP, EFLAGS"
  }

  tlb_b: TLB (Invalidated!) {
    grid-columns: 5
    grid-gap: 2
    
    tlb_b1: "?" {class: invalidated}
    tlb_b2: "?" {class: invalidated}
    tlb_b3: "?" {class: invalidated}
    tlb_b4: "?" {class: invalidated}
    tlb_b5: "?" {class: invalidated}
    tlb_b6: "?" {class: invalidated}
    tlb_b7: "?" {class: invalidated}
    tlb_b8: "?" {class: invalidated}
    tlb_b9: "?" {class: invalidated}
    tlb_b10: "?" {class: invalidated}
    
    tlb_label: "All 50 entries FLUSHED\n(CR3 write → TLB invalidation)" {
      shape: text
      style.font-color: red
      style.bold: true
    }
  }

  l1_cache_b: L1 Cache (Polluted!) {
    grid-columns: 4
    grid-gap: 2
    
    l1_b1: "B's code" {class: cold}
    l1_b2: "B's heap" {class: cold}
    l1_b3: "B's stack" {class: cold}
    l1_b4: "B's data" {class: cold}
  }

  branch_pred_b: Branch Predictor {
    style.fill: "#FFE6E6"
    bp_b: "Process B patterns (cold)"
  }

  tlb_miss_cost: "TLB Miss: ~100-300 cycles\n(Page table walk)" {
    shape: text
    style.font-color: red
    style.bold: true
  }
}

cost_breakdown: Context Switch Cost Breakdown {
  near: bottom-center
  
  grid-columns: 2
  grid-gap: 20
  
  hardware_cost: Hardware Costs {
    shape: sequence_diagram
    style.fill: "#F5F5F5"
    
    save: Save registers
    load: Load CR3
    flush: TLB Flush
    restore: Restore registers
    
    save -> load: "20-50 cycles"
    load -> flush: "100 cycles\n(CR3 write)"
    flush -> restore: "0 cycles\n(hardware)"
    restore -> save: "20-50 cycles\n(TOTAL: ~100-500)"
  }
  
  memory_cost: Memory Subsystem Costs {
    shape: sequence_diagram
    style.fill: "#FFF5F5"
    
    tlb_miss: TLB Miss
    l1_miss: L1 Miss
    l2_miss: L2 Miss
    l3_miss: L3 Miss
    
    tlb_miss -> l1_miss: "~100-300 cycles\n(page walk)"
    l1_miss -> l2_miss: "~10 cycles"
    l2_miss -> l3_miss: "~40 cycles"
    l3_miss -> tlb_miss: "~100 cycles"
    
    note: "Per first access!\nProcess may access 100+\naddresses → 10,000+ cycles" {
      shape: text
      style.font-color: red
    }
  }
}

timeline: Execution Timeline {
  near: bottom-center
  
  shape: sequence_diagram
  
  Timer
  ProcessA
  Scheduler
  ProcessB
  
  freeze: "Process A executes normally" {
    Timer.t1 -> ProcessA.t1: "running..."
  }
  
  interrupt: "Timer Interrupt" {
    Timer.t2 -> ProcessA.t2: "INT 0x20"
    ProcessA.t2 -> Scheduler.t1: "save state to PCB"
  }
  
  switch_cost: "Context Switch (~500 cycles)" {
    Scheduler.t1 -> Scheduler.t1: "load Process B state"
    Scheduler.t1 -> Scheduler.t1: "write CR3 (TLB flush!)"
  }
  
  warmup: "Process B Warmup (~5000+ cycles)" {
    Scheduler.t1 -> ProcessB.t1: "iret"
    ProcessB.t1 -> ProcessB.t1: "TLB miss!"
    ProcessB.t1 -> ProcessB.t1: "L1 miss!"
    ProcessB.t1 -> ProcessB.t1: "L1 miss!"
    ProcessB.t1 -> ProcessB.t1: "TLB miss!"
  }
  
  steady: "Steady State" {
    ProcessB.t2 -> ProcessB.t2: "cache hits, fast execution"
  }
}

optimization: PCID Mitigation (x86-64) {
  near: top-right
  
  without_pcid: Without PCID {
    style.fill: "#FFE0E0"
    w1: "CR3 write → TLB flush"
    w2: "All 50 entries lost"
    w3: "~100+ TLB misses on resume"
  }
  
  with_pcid: With PCID (Process-Context ID) {
    style.fill: "#E0FFE0"
    p1: "CR3 write preserves TLB"
    p2: "Entries tagged with PCID"
    p3: "Process A: PCID=1, Process B: PCID=2"
    p4: "On switch back: TLB warm!"
    p5: "INVPCID for selective flush"
  }
  
  without_pcid -> with_pcid: "Modern optimization"
}

legend: Legend {
  near: bottom-right
  
  hot_cache: "Hot/Warm" {
    class: hot
    style.fill: "#FFE0E0"
  }
  cold_cache: "Cold" {
    class: cold
    style.fill: "#E0E0FF"
  }
  invalid_cache: "Invalidated" {
    class: invalidated
  }
}