vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Context Switch: Complete Assembly Flow
  ## Timer Interrupt → Register Save → PCB Switch → Register Restore → iret
| {near: top-center}
direction: right
classes: {
  stack_frame: {
    style: {
      fill: "#1a1a2e"
      stroke: "#4a4a6a"
      font-color: "#e0e0e0"
      font: mono
      font-size: 14
    }
  }
  register: {
    shape: rectangle
    width: 60
    height: 24
    style: {
      fill: "#2d2d44"
      stroke: "#6a6a8a"
      font-color: "#00ff88"
      font: mono
    }
  }
  pcb_box: {
    style: {
      fill: "#0d1117"
      stroke: "#30363d"
      stroke-width: 2
      font-color: "#c9d1d9"
    }
  }
  arrow_label: {
    style: {
      font: mono
      font-size: 12
      font-color: "#8b949e"
    }
  }
  timing: {
    shape: rectangle
    style: {
      fill: "#161b22"
      stroke: "#30363d"
      font-color: "#58a6ff"
      font: mono
      font-size: 11
    }
  }
  phase: {
    style: {
      fill: "#21262d"
      stroke: "#f0883e"
      stroke-width: 2
      font-color: "#f0883e"
      bold: true
    }
  }
}
Phase1: {
  label: "PHASE 1\nTimer Interrupt Entry"
  class: phase
  timing1: "~50 cycles" {
    class: timing
    near: top-right
  }
  CPU_Auto: "CPU Auto-Push\n(privilege change)" {
    class: stack_frame
    Stack1: |md
      +0x00: SS     = 0x23 (user data)
      +0x04: ESP    = 0xBFFFFF00 (user stack)
      +0x08: EFLAGS = 0x202 (IF=1)
      +0x0C: CS     = 0x1B (user code)
      +0x10: EIP    = 0x08048123 (return addr)
    |
  }
  note1: |md
    CPU reads TSS.ESP0 (0x0010A000)
    Switches to kernel stack
    Pushes user SS:ESP for return
  | {
    near: CPU_Auto
    shape: text
    style.font-color: "#8b949e"
    style.font-size: 11
  }
}
Phase2: {
  label: "PHASE 2\nISR Stub Push"
  class: phase
  timing2: "~25 cycles" {
    class: timing
    near: top-right
  }
  ISR_Push: "Our ISR Stub Pushes" {
    class: stack_frame
    Stack2: |md
      +0x00: SS     = 0x23
      +0x04: ESP    = 0xBFFFFF00
      +0x08: EFLAGS = 0x202
      +0x0C: CS     = 0x1B
      +0x10: EIP    = 0x08048123
      --------------------------
      +0x14: GS     = 0x23
      +0x18: FS     = 0x23
      +0x1C: ES     = 0x23
      +0x20: DS     = 0x23
      +0x24: EDI    = 0x00000100
      +0x28: ESI    = 0xDEADBEEF
      +0x2C: EBP    = 0xBFFFFF10
      +0x30: ESP    = 0x00109F00 (ignored)
      +0x34: EBX    = 0x12345678
      +0x38: EDX    = 0x00000001
      +0x3C: ECX    = 0x00000000
      +0x40: EAX    = 0x08049000
      +0x44: int_no = 32
      +0x48: err    = 0
    |
  }
  code2: |md
asm
irq0_handler:
  pusha          ; 8 regs
  push ds/es/fs/gs
  mov ax, 0x10   ; kernel DS
  mov ds, ax
  ...

  | {
    shape: text
    style.font-color: "#7ee787"
    style.font-size: 10
  }
}
Phase3: {
  label: "PHASE 3\nSave Current PCB"
  class: phase
  timing3: "~15 cycles" {
    class: timing
    near: top-right
  }
  Save_PCB: {
    class: pcb_box
    Current_PCB: "current_process->kernel_stack" {
      style.fill: "#0d1117"
      style.stroke: "#f85149"
      label: |md
        **struct process *current_process**
        -------------------------------
        .pid = 1
        .state = RUNNING -> READY
        .kernel_stack = **ESP saved here**
        .kernel_stack_top = 0x0010A000
        .page_directory = 0x00111000
      |
    }
  }
  Save_Arrow: Phase2.ISR_Push -> Save_PCB.Current_PCB: "mov [eax+8], esp ; save ESP to PCB" {
    class: arrow_label
    style.stroke: "#f85149"
    style.stroke-width: 2
  }
  code3: |md
asm
; In scheduler_context_switch():
mov eax, [current_process]
mov [eax + 8], esp    ; offset 8 = kernel_stack
; Stack ptr now saved!

  | {
    shape: text
    style.font-color: "#7ee787"
    style.font-size: 10
  }
}
Phase4: {
  label: "PHASE 4\nPick Next Process"
  class: phase
  timing4: "~30 cycles" {
    class: timing
    near: top-right
  }
  Queue: {
    class: pcb_box
    style.fill: "#161b22"
    RunQueue: |md
      **Run Queue State**
      -----------------
      head -> [PID 2] -> [PID 3] -> NULL
               READY     READY
      Pick: dequeue PID 2
      State: READY -> RUNNING
    |
  }
  Next_PCB: "next_process (PID 2)" {
    class: pcb_box
    style.stroke: "#58a6ff"
    label: |md
      **struct process *next_process**
      -------------------------------
      .pid = 2
      .state = RUNNING
      .kernel_stack = **0x00109E00** <- load this!
      .kernel_stack_top = 0x0010B000
      .page_directory = 0x00112000
    |
  }
  Queue_Arrow: Save_PCB.Current_PCB -> Queue: "scheduler_pick_next()" {
    class: arrow_label
    style.stroke: "#8b949e"
    style.stroke-dash: 3
  }
}
Phase5: {
  label: "PHASE 5\nUpdate TSS & CR3"
  class: phase
  timing5: "~50 cycles" {
    class: timing
    near: top-right
  }
  TSS_Update: {
    class: pcb_box
    style.fill: "#0d1117"
    style.stroke: "#a371f7"
    TSS: |md
      **Task State Segment**
      ---------------------
      .ss0  = 0x10 (unchanged)
      .esp0 = **0x0010B000** <- UPDATED!
      This is CRITICAL for next
      user->kernel transition
    |
  }
  CR3_Update: {
    class: pcb_box
    style.fill: "#0d1117"
    style.stroke: "#f0883e"
    CR3: |md
      **CR3 (Page Directory)**
      -----------------------
      Old: 0x00111000 (PID 1)
      New: **0x00112000** (PID 2)
      TLB flushed automatically
    |
  }
  code5: |md
asm
; Update TSS
mov eax, [edi + 16]   ; kernel_stack_top
mov [kernel_tss + 4], eax  ; esp0
; Switch page directory
mov eax, [esi + 12]   ; old->pd
mov ebx, [edi + 12]   ; new->pd
cmp eax, ebx
je .same_pd
mov cr3, ebx          ; TLB flush!
.same_pd:

  | {
    shape: text
    style.font-color: "#7ee787"
    style.font-size: 10
  }
}
Phase6: {
  label: "PHASE 6\nLoad New Stack"
  class: phase
  timing6: "~10 cycles" {
    class: timing
    near: top-right
  }
  Stack_Switch: "CRITICAL: Stack Switch" {
    class: stack_frame
    style.stroke: "#58a6ff"
    style.stroke-width: 3
    label: |md
asm
; Load new process's saved ESP
mov esp, [edi + 8]   ; new->kernel_stack
; We are NOW on PID 2's stack!
; The stack contains PID 2's saved state
; from when IT was last preempted

    |
  }
  New_Stack: "PID 2's Kernel Stack" {
    class: stack_frame
    style.fill: "#0d1f0d"
    style.stroke: "#238636"
    Stack6: |md
      ESP -> +0x00: GS     = 0x23
             +0x04: FS     = 0x23
             +0x08: ES     = 0x23
             +0x0C: DS     = 0x23
             +0x10: EDI    = 0x00000200
             +0x14: ESI    = 0xCAFEBABE
             +0x18: EBP    = 0xBFFFEF10
             +0x1C: ESP    = (ignored)
             +0x20: EBX    = 0x87654321
             +0x24: EDX    = 0x00000002
             +0x28: ECX    = 0x11111111
             +0x2C: EAX    = 0x0804A000
             +0x30: int_no = 32
             +0x34: err    = 0
             +0x38: EIP    = 0x08048567 <- resume here!
             +0x3C: CS     = 0x1B
             +0x40: EFLAGS = 0x202
             +0x44: ESP    = 0xBFFFEF00
             +0x48: SS     = 0x23
    |
  }
  Load_Arrow: Phase5.CR3_Update -> Stack_Switch: "mov esp, [next->kernel_stack]" {
    class: arrow_label
    style.stroke: "#58a6ff"
    style.stroke-width: 2
    style.animated: true
  }
}
Phase7: {
  label: "PHASE 7\nRestore Registers"
  class: phase
  timing7: "~20 cycles" {
    class: timing
    near: top-right
  }
  Restore: "Pop & Restore" {
    class: stack_frame
    label: |md
asm
; Restore segment registers
pop gs      ; 0x23
pop fs      ; 0x23
pop es      ; 0x23
pop ds      ; 0x23
; Restore general registers
popa        ; EDI,ESI,EBX,EDX,ECX,EAX
            ; (ESP,EBP restored but ESP ignored)
; Skip our metadata
add esp, 8  ; skip int_no, err_code

    |
  }
  Reg_State: {
    grid-columns: 4
    grid-gap: 4
    EAX: "EAX: 0x0804A000" {class: register}
    EBX: "EBX: 0x87654321" {class: register}
    ECX: "ECX: 0x11111111" {class: register}
    EDX: "EDX: 0x00000002" {class: register}
    ESI: "ESI: 0xCAFEBABE" {class: register}
    EDI: "EDI: 0x00000200" {class: register}
    EBP: "EBP: 0xBFFFEF10" {class: register}
    ESP_Reg: "ESP: 0xBFFFEF00" {class: register}
  }
  Restore_Arrow: Phase6.New_Stack -> Restore: "popa; pop ds/es/fs/gs" {
    class: arrow_label
    style.stroke: "#238636"
  }
}
Phase8: {
  label: "PHASE 8\niret - Resume Process"
  class: phase
  timing8: "~25 cycles" {
    class: timing
    near: top-right
  }
  IRET: "iret Instruction" {
    class: stack_frame
    style.stroke: "#f85149"
    style.stroke-width: 3
    label: |md
asm
iret    ; The magic instruction
; CPU automatically:
; 1. Pop EIP    = 0x08048567
; 2. Pop CS     = 0x1B (RPL=3)
; 3. Pop EFLAGS = 0x202 (IF=1)
; 4. Detect RPL change (3!=0)
; 5. Pop ESP    = 0xBFFFEF00
; 6. Pop SS     = 0x23
; 7. Jump to CS:EIP in ring 3!

    |
  }
  Result: "PID 2 Resumes!" {
    class: pcb_box
    style.fill: "#0d1f0d"
    style.stroke: "#238636"
    style.stroke-width: 2
    label: |md
      **Process 2 is now running**
      ---------------------------
      - At instruction 0x08048567
      - In user mode (ring 3)
      - With its own page tables
      - Using its own stack
      - Completely unaware it was
        ever paused!
    |
  }
  IRET_Arrow: Phase7.Restore -> IRET: "iret" {
    class: arrow_label
    style.stroke: "#f85149"
    style.stroke-width: 3
    style.animated: true
  }
}
Timing_Summary: |md
  ## Total Context Switch Cost: ~225 cycles (~112 ns @ 2 GHz)
  | Phase | Operation | Cycles | Cumulative |
  |-------|-----------|--------|------------|
  | 1 | CPU auto-push (5 values) | ~50 | 50 |
  | 2 | ISR stub push | ~25 | 75 |
  | 3 | Save ESP to PCB | ~15 | 90 |
  | 4 | Scheduler pick next | ~30 | 120 |
  | 5 | Update TSS + CR3 | ~50 | 170 |
  | 6 | Load new ESP | ~10 | 180 |
  | 7 | Restore registers | ~20 | 200 |
  | 8 | iret + mode switch | ~25 | **225** |
  **Plus: TLB refill (~100-500 cycles) + Cache warming (~1000+ cycles)**
| {near: bottom-center}
Phase1 -> Phase2 -> Phase3 -> Phase4 -> Phase5 -> Phase6 -> Phase7 -> Phase8: "execution flow" {
  style.stroke: "#8b949e"
  style.stroke-dash: 3
}
Legend: |md
  ### Stack State Key
  - **Green box**: New process's stack (resumed)
  - **Red border**: Critical operations
  - **Animated**: Data movement
  ### Register Colors
  - Green: User data registers
  - Blue: Segment selectors
  - Red: Control registers
| {near: bottom-left}