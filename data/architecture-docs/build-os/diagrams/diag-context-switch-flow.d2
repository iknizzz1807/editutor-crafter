vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Context Switch: Save Old → Load New
  Assembly-level trace of timer-triggered process switch
| {near: top-center}

direction: right

Timer_Interrupt: {
  label: Timer IRQ0\nFires
  shape: circle
  style.fill: "#FFE4B5"
  style.stroke: "#FF8C00"
}

CPU_State: {
  label: CPU State\n(Before Switch)
  shape: rectangle
  style.fill: "#E8E8E8"
  
  regs: |md
    
    EAX = 0xDEADBEEF
    EBX = 0x00000042
    ECX = 0x12345678
    EDX = 0xABCDEF00
    ESI = 0x10001000
    EDI = 0x20002000
    EBP = 0x9000FFF0
    ESP = 0x9000FF00  ← Process A stack
    EIP = 0xC0103050  ← Mid-function!
    EFLAGS = 0x202 (IF=1)
    CR3 = 0x00123000  ← Process A PD
    
  |
}

Process_A_PCB: {
  label: Process A PCB
  shape: rectangle
  style.fill: "#FFE4E1"
  style.stroke: "#DC143C"
  
  cpu_state: {
    label: cpu_state_t
    shape: rectangle
    
    offset_table: |md
      
      +0x00: edi      (empty)
      +0x04: esi      (empty)
      +0x08: ebp      (empty)
      +0x0C: esp      (empty)
      +0x10: ebx      (empty)
      +0x14: edx      (empty)
      +0x18: ecx      (empty)
      +0x1C: eax      (empty)
      +0x20: eip      (empty)
      +0x24: cs       (empty)
      +0x28: eflags   (empty)
      +0x2C: useresp  (empty)
      +0x30: ss       (empty)
      +0x34: ds       (empty)
      +0x38: es       (empty)
      +0x3C: cr3      (empty)
      
    |
  }
}

Scheduler: {
  label: Round-Robin\nScheduler
  shape: diamond
  style.fill: "#98FB98"
  style.stroke: "#228B22"
  
  logic: |md
    c
    next = current->next;
    if (next == NULL) 
      next = ready_queue;
    current->state = READY;
    next->state = RUNNING;
    current = next;
    // Pick: Process B
    
  |
}

Process_B_PCB: {
  label: Process B PCB
  shape: rectangle
  style.fill: "#E0FFFF"
  style.stroke: "#008B8B"
  
  cpu_state_filled: {
    label: cpu_state_t (Ready)
    shape: rectangle
    
    offset_table_filled: |md
      
      +0x00: edi = 0x30003000
      +0x04: esi = 0x40004000
      +0x08: ebp = 0xA000FE00
      +0x0C: esp = 0xA000FE00
      +0x10: ebx = 0x00000099
      +0x14: edx = 0xFEDCBA98
      +0x18: ecx = 0x87654321
      +0x1C: eax = 0xCAFEBABE
      +0x20: eip = 0xC0104020  ← Resume here!
      +0x24: cs  = 0x08
      +0x28: eflags = 0x202
      +0x2C: useresp = N/A
      +0x30: ss  = 0x10
      +0x34: ds  = 0x10
      +0x38: es  = 0x10
      +0x3C: cr3 = 0x00134000  ← Process B PD
      
    |
  }
}

ContextSwitch_Save: {
  label: "context_switch: SAVE"
  shape: rectangle
  style.fill: "#FFD700"
  style.stroke: "#B8860B"
  
  asm_save: |md
    asm
    ; Disable interrupts!
    cli
    
    ; Get PCB pointer (EBX = &current->cpu)
    mov ebx, [current_process]
    lea ebx, [ebx + 8]     ; cpu offset
    
    ; Pop from interrupt stack into PCB
    pop dword [ebx + 0x00] ; edi
    pop dword [ebx + 0x04] ; esi  
    pop dword [ebx + 0x08] ; ebp
    pop dword [ebx + 0x0C] ; esp (placeholder)
    pop dword [ebx + 0x10] ; ebx
    pop dword [ebx + 0x14] ; edx
    pop dword [ebx + 0x18] ; ecx
    pop dword [ebx + 0x1C] ; eax
    
    ; Save actual ESP
    mov [ebx + 0x0C], esp
    
    ; Save EIP, CS, EFLAGS from stack
    pop dword [ebx + 0x20] ; eip ← RET ADDR!
    pop dword [ebx + 0x24] ; cs
    pop dword [ebx + 0x28] ; eflags
    
    ; Save segment regs
    mov ax, ds
    mov [ebx + 0x34], ax
    mov ax, es
    mov [ebx + 0x38], ax
    
    ; Save CR3 (page directory)
    mov eax, cr3
    mov [ebx + 0x3C], eax
    
  |
  
  Note_CLI: {
    label: |md
      **Atomicity via CLI**
      asm
      cli  ; Disable interrupts
      ; ... context switch ...
      ; iret restores IF from EFLAGS
      
    |
    shape: rectangle
    style.fill: "#FFE4E1"
    style.stroke-dash: 3
  }
}

ContextSwitch_Load: {
  label: "context_switch: LOAD"
  shape: rectangle
  style.fill: "#87CEEB"
  style.stroke: "#4682B4"
  
  asm_load: |md
    asm
    ; EBX = &next->cpu
    mov eax, [current_process]
    lea ebx, [eax + 8]
    
    ; Load CR3 (flushes TLB!)
    mov eax, [ebx + 0x3C]
    mov cr3, eax           ; ← Page dir switch
    
    ; Load segment regs
    mov ax, [ebx + 0x34]
    mov ds, ax
    mov ax, [ebx + 0x38]
    mov es, ax
    
    ; Push for iret frame
    push dword [ebx + 0x28] ; eflags
    push dword [ebx + 0x24] ; cs
    push dword [ebx + 0x20] ; eip ← Resume addr!
    
    ; Push general regs
    push dword [ebx + 0x1C] ; eax
    push dword [ebx + 0x18] ; ecx
    push dword [ebx + 0x14] ; edx
    push dword [ebx + 0x10] ; ebx
    push dword [ebx + 0x0C] ; esp
    push dword [ebx + 0x08] ; ebp
    push dword [ebx + 0x04] ; esi
    push dword [ebx + 0x00] ; edi
    
    ; Restore and return!
    popa                   ; All GP regs
    iret                   ; EIP, CS, EFLAGS
    
  |
  
  Note_TSS: {
    label: |md
      **TSS ESP0 Update**
      asm
      ; Must update before iret!
      mov eax, [current_process]
      mov ebx, [eax + kernel_stack_top]
      mov [tss + 4], ebx  ; ESP0
      
    |
    shape: rectangle
    style.fill: "#FFFACD"
    style.stroke-dash: 3
  }
  
  Note_TLB: {
    label: |md
      **TLB Flush on CR3 Load**
      - All non-global entries invalidated
      - ~100-500 cycle penalty
      - Kernel pages use PAGE_GLOBAL
    |
    shape: rectangle
    style.fill: "#FFFACD"
    style.stroke-dash: 3
  }
}

CPU_Resumed: {
  label: CPU State\n(After Switch)
  shape: rectangle
  style.fill: "#E8E8E8"
  
  regs_after: |md
    
    EAX = 0xCAFEBABE  ← From B's PCB
    EBX = 0x00000099
    ECX = 0x87654321
    EDX = 0xFEDCBA98
    ESI = 0x40004000
    EDI = 0x30003000
    EBP = 0xA000FE00
    ESP = 0xA000FE00  ← Process B stack!
    EIP = 0xC0104020  ← B's saved PC
    EFLAGS = 0x202 (IF=1)
    CR3 = 0x00134000  ← Process B PD!
    
  |
}

Process_B_Running: {
  label: Process B\nResumes
  shape: circle
  style.fill: "#90EE90"
  style.stroke: "#228B22"
}

# Flow connections
Timer_Interrupt -> CPU_State: "Interrupts\nexecution"
CPU_State -> ContextSwitch_Save: "Current regs\non stack"
ContextSwitch_Save -> Process_A_PCB: "pusha + save\nall to PCB" {
  style.stroke: "#DC143C"
  style.stroke-width: 3
  label: "① SAVE"
}

Process_A_PCB -> Scheduler: "A → READY"
Scheduler -> Process_B_PCB: "Pick B\nB → RUNNING" {
  style.stroke: "#228B22"
  style.stroke-width: 2
}

Process_B_PCB -> ContextSwitch_Load: "Load B's\nsaved state"
ContextSwitch_Load -> CPU_Resumed: "popa + iret\nrestore all" {
  style.stroke: "#4682B4"
  style.stroke-width: 3
  label: "② LOAD"
}

CPU_Resumed -> Process_B_Running: "B executes\nfrom saved EIP"

# Legend
Legend: {
  near: bottom-center
  label: |md
    **Context Switch Timeline**
    1. Timer IRQ → CPU pushes EIP, CS, EFLAGS to stack
    2. Handler calls `pusha` → GP regs on stack
    3. Scheduler picks next PCB from ready queue
    4. Save: Pop stack into old PCB's cpu_state
    5. Load: Push new PCB's cpu_state onto stack
    6. `iret` → CPU pops EIP, CS, EFLAGS, resumes new process
  |
  shape: rectangle
  style.fill: "#F5F5F5"
  style.stroke: "#A9A9A9"
}