vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # OS Debugging: QEMU + GDB + Serial Pipeline
| {near: top-center}

direction: right

classes: {
  hardware: {
    style: {
      fill: "#2D3748"
      font-color: white
      stroke: "#4A5568"
    }
  }
  debugger: {
    style: {
      fill: "#1A365D"
      font-color: white
      stroke: "#2B6CB0"
    }
  }
  target: {
    style: {
      fill: "#744210"
      font-color: white
      stroke: "#D69E2E"
    }
  }
  output: {
    style: {
      fill: "#22543D"
      font-color: white
      stroke: "#38A169"
    }
  }
  critical: {
    style: {
      fill: "#742A2A"
      font-color: white
      stroke: "#E53E3E"
    }
  }
  flow: {
    style: {
      animated: true
      stroke-width: 2
    }
  }
}

debug_env: Debug Environment {
  class: hardware
  
  qemu: QEMU Emulator {
    class: target
    style.fill: "#553C9A"
    
    flags: Startup Flags {
      style.fill: "#6B46C1"
      content: |md
        - `-s`: Open GDB server on :1234
        - `-S`: Freeze CPU at startup
        - `-serial file:debug.log`
        - `-no-reboot`: Halt on triple fault
      |
    }
    
    cpu_state: CPU State Machine {
      style.fill: "#805AD5"
      
      halted: Halted {
        style.fill: "#B794F4"
        style.font-color: black
      }
      running: Running {
        style.fill: "#68D391"
        style.font-color: black
      }
      fault: Triple Fault {
        class: critical
      }
      unknown: Unknown State {
        style.fill: "#FC8181"
      }
      
      halted -> running: "continue (GDB 'c')"
      running -> fault: "unhandled exception"
      fault -> halted: "QEMU -no-reboot"
      running -> halted: "breakpoint hit"
    }
  }
  
  gdb: GDB Debugger {
    class: debugger
    
    connection: {
      style.fill: "#2C5282"
      desc: |md
        target remote localhost:1234
        symbol file: kernel.elf
      |
    }
    
    commands: Essential Commands {
      style.fill: "#2B6CB0"
      
      content: |md
        # Breakpoints
        `break kernel_main`
        `break idt_init`
        `break context_switch`
        
        # Examine
        `x/10i $pc`      # 10 instructions
        `x/20x $esp`     # stack dump
        `info registers` # all regs
        `info tss`       # TSS content
        
        # Step control
        `si`             # single instruction
        `ni`             # step over call
        `finish`         # run until return
      |
    }
    
    breakpoints: Strategic Breakpoints {
      style.fill: "#3182CE"
      
      bp_entry: kernel_entry {
        style.fill: "#63B3ED"
        style.font-color: black
        desc: "First instruction in kernel"
      }
      bp_idt: idt_setup {
        style.fill: "#63B3ED"
        style.font-color: black
        desc: "After IDT loaded"
      }
      bp_ctx: context_switch {
        style.fill: "#63B3ED"
        style.font-color: black
        desc: "Process switch point"
      }
      bp_pf: page_fault_handler {
        style.fill: "#F6AD55"
        style.font-color: black
        desc: "CR2 = fault address"
      }
    }
  }
  
  serial: Serial Output {
    class: output
    
    config: Configuration {
      style.fill: "#276749"
      
      content: |md
        # QEMU flag
        `-serial file:debug.log`
        
        # Kernel serial init
        `outb(0x3F8 + 3, 0x03);  // 8N1`
        `outb(0x3F8 + 1, 0x00);  // no interrupt`
      |
    }
    
    log_format: Log Entry Format {
      style.fill: "#38A169"
      
      content: |md
        
        [0x00100000] kernel_entry: EIP=0x100000
        [0x00100034] idt_load: IDTR=0x10800
        [0x00100200] context_switch: PID 1 -> 2
        [TRIPLE FAULT] last EIP=0x00102340
        
      |
    }
    
    debug_macros: Debug Macros {
      style.fill: "#48BB78"
      
      content: |md
        c
        #define DBG(fmt, ...) \
          serial_printf("[%08x] " fmt "\n", \
            get_eip(), ##__VA_ARGS__)
        
        #define DUMP_REGS() \
          serial_printf("EAX=%x EBX=%x ECX=%x\n", \
            eax, ebx, ecx)
        
      |
    }
  }
}

triple_fault: Triple Fault Diagnosis {
  class: critical
  
  causes: Root Causes {
    style.fill: "#9B2C2C"
    
    cause1: No IDT {
      style.fill: "#E53E3E"
      desc: "IDTR points to garbage"
    }
    cause2: Exception in Handler {
      style.fill: "#E53E3E"
      desc: "Page fault in page fault handler"
    }
    cause3: Corrupt TSS {
      style.fill: "#E53E3E"
      desc: "ESP0 invalid during ring transition"
    }
    cause4: Stack Overflow {
      style.fill: "#E53E3E"
      desc: "Kernel stack exhausted"
    }
  }
  
  diagnosis: Diagnosis Procedure {
    style.fill: "#9B2C2C"
    
    content: |md
      1. Check last serial output
         -> shows EIP before crash
      
      2. In GDB, set catch point:
         `catch signal SIGTRAP`
         `continue`
      
      3. Examine CPU state at crash:
         `info registers`
         `x/20x $esp`
      
      4. Check IDT validity:
         `x/256x &idt_entries`
         `info idt` (QEMU monitor)
      
      5. Verify TSS:
         `info tss`
         `x/1x &tss.esp0`
    |
  }
  
  qemu_monitor: QEMU Monitor Commands {
    style.fill: "#742A2A"
    
    content: |md
      # Start QEMU with monitor
      `qemu-system-i386 -monitor stdio ...`
      
      
      (qemu) info registers    # full CPU state
      (qemu) info tss          # TSS content
      (qemu) info idt          # IDT entries
      (qemu) info mem          # page tables
      (qemu) xp /20x 0x100000  # physical memory
      (qemu) savevm crash      # snapshot state
      
    |
  }
}

workflow: Debug Workflow {
  class: hardware
  
  session: Typical Session {
    style.fill: "#4A5568"
    
    step1: 1. Start QEMU {
      style.fill: "#718096"
      content: |md
        
        qemu-system-i386 -kernel kernel.elf \
          -s -S -serial file:debug.log -no-reboot
        
      |
    }
    
    step2: 2. Connect GDB {
      style.fill: "#718096"
      content: |md
        
        gdb kernel.elf
        (gdb) target remote :1234
        (gdb) break kernel_main
        (gdb) continue
        
      |
    }
    
    step3: 3. Debug Loop {
      style.fill: "#718096"
      content: |md
        
        (gdb) si              # step
        (gdb) x/10i $pc       # disassemble
        (gdb) info registers  # check state
        (gdb) continue        # run more
        
      |
    }
    
    step4: 4. Analyze Crash {
      style.fill: "#F56565"
      content: |md
        # Check serial log
        `tail debug.log`
        
        # In GDB after crash
        `(gdb) bt`              # backtrace
        `(gdb) x/20x $esp`      # stack
      |
    }
    
    step1 -> step2: "GDB connect\nlocalhost:1234" {
      class: flow
      style.stroke: "#63B3ED"
    }
    step2 -> step3: "breakpoint hit" {
      class: flow
      style.stroke: "#68D391"
    }
    step3 -> step4: "triple fault" {
      class: flow
      style.stroke: "#E53E3E"
    }
  }
}

connections: {
  debug_env.gdb -> debug_env.qemu: "TCP :1234\nGDB protocol" {
    class: flow
    style.stroke: "#63B3ED"
  }
  
  debug_env.qemu -> debug_env.serial: "port 0x3F8\nserial_write()" {
    class: flow
    style.stroke: "#68D391"
  }
  
  debug_env.serial -> triple_fault.diagnosis: "debug.log\nlast known state" {
    style.stroke: "#F6AD55"
    style.stroke-dash: 3
  }
  
  triple_fault.causes -> triple_fault.diagnosis: "hypothesis" {
    style.stroke: "#E53E3E"
    style.stroke-dash: 3
  }
}

legend: {
  near: bottom-center
  
  color1: GDB/Debug {
    style.fill: "#1A365D"
    style.font-color: white
  }
  color2: Target/QEMU {
    style.fill: "#553C9A"
    style.font-color: white
  }
  color3: Serial Output {
    style.fill: "#22543D"
    style.font-color: white
  }
  color4: Critical/Fault {
    style.fill: "#742A2A"
    style.font-color: white
  }
}