vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # E820 Memory Map Parsing
  BIOS INT 0x15 → Physical Frame Allocator Initialization
| {near: top-center}

direction: right

# ============ BIOS E820 CALL ============
bios_call: BIOS INT 0x15/E820 {
  style.fill: "#E8F5E9"
  style.stroke: "#4CAF50"
  
  input: Input Registers {
    shape: class
    EAX: "0xE820"
    EBX: "continuation (0=start)"
    ECX: "buffer size (24 bytes)"
    EDX: "\"SMAP\" signature"
    "ES:DI": "buffer address"
  }
  
  output: Output Registers {
    shape: class
    EAX: "\"SMAP\""
    EBX: "next continuation"
    ECX: "entry size returned"
    CF: "clear=success"
  }
  
  input -> output: "Execute\nBIOS call" {
    style.stroke: "#4CAF50"
    style.stroke-width: 2
  }
}

# ============ E820 ENTRY STRUCTURE ============
e820_entry: E820 Entry (24 bytes) {
  style.fill: "#E3F2FD"
  style.stroke: "#1976D2"
  
  layout: Memory Layout {
    shape: class
    
    "+0x00": "base_low (u32)"
    "+0x04": "base_high (u32)"
    "+0x08": "length_low (u32)"
    "+0x0C": "length_high (u32)"
    "+0x10": "type (u32)"
    "+0x14": "ACPI attrs (u32)"
  }
  
  types: Entry Types {
    shape: sql_table
    Type: int {constraint: PK}
    Name: string
    Meaning: string
    
    1: "Usable RAM"
    "2": "Reserved"
    "3": "ACPI Reclaimable"
    "4": "ACPI NVS"
    "5": "Unusable"
  }
}

# ============ EXAMPLE E820 OUTPUT ============
e820_output: Example E820 Output {
  style.fill: "#FFF3E0"
  style.stroke: "#FF9800"
  
  grid-columns: 5
  grid-gap: 0
  
  header_base: Base Address {
    style.underline: true
    style.bold: true
  }
  header_len: Length {
    style.underline: true
    style.bold: true
  }
  header_end: End Address {
    style.underline: true
    style.bold: true
  }
  header_type: Type {
    style.underline: true
    style.bold: true
  }
  header_use: Use? {
    style.underline: true
    style.bold: true
  }
  
  entry1_base: "0x00000000"
  entry1_len: "0x0009FC00"
  entry1_end: "0x0009FBFF"
  entry1_type: "Usable"
  entry1_use: "✓ Low memory (639KB)"
  entry1_type.style.fill: "#C8E6C9"
  
  entry2_base: "0x0009FC00"
  entry2_len: "0x00000400"
  entry2_end: "0x0009FFFF"
  entry2_type: "Reserved"
  entry2_use: "✗ BIOS data area"
  entry2_type.style.fill: "#FFCDD2"
  
  entry3_base: "0x000E8000"
  entry3_len: "0x00018000"
  entry3_end: "0x000FFFFF"
  entry3_type: "Reserved"
  entry3_use: "✗ ROM & BIOS"
  entry3_type.style.fill: "#FFCDD2"
  
  entry4_base: "0x00100000"
  entry4_len: "0x1DF00000"
  entry4_end: "0x1E0FFFFF"
  entry4_type: "Usable"
  entry4_use: "✓ Main RAM (~480MB)"
  entry4_type.style.fill: "#C8E6C9"
  
  entry5_base: "0x1E100000"
  entry5_len: "0x00100000"
  entry5_end: "0x1E1FFFFF"
  entry5_type: "ACPI Reclaim"
  entry5_use: "✓ After parsing"
  entry5_type.style.fill: "#FFF9C4"
  
  entry6_base: "0x1E200000"
  entry6_len: "0x00200000"
  entry6_end: "0x1E3FFFFF"
  entry6_type: "ACPI NVS"
  entry6_use: "✗ Must preserve"
  entry6_type.style.fill: "#FFCDD2"
  
  entry7_base: "0xFEC00000"
  entry7_len: "0x00100000"
  entry7_end: "0xFECFFFFF"
  entry7_type: "Reserved"
  entry7_use: "✗ I/O APIC"
  entry7_type.style.fill: "#FFCDD2"
}

# ============ PHYSICAL MEMORY VISUALIZATION ============
phys_mem: Physical Address Space Layout {
  style.fill: "#FAFAFA"
  style.stroke: "#9E9E9E"
  
  grid-columns: 1
  grid-gap: 2
  
  low_mem: Low Memory (0x0 - 0xFFFFF) {
    grid-columns: 4
    grid-gap: 0
    
    usable_low: Usable (639KB) {
      width: 200
      style.fill: "#4CAF50"
      style.font-color: white
    }
    bios_data: BIOS Data (1KB) {
      width: 20
      style.fill: "#F44336"
      style.font-color: white
      label: ""
    }
    ebda: EBDA {
      width: 30
      style.fill: "#F44336"
      style.font-color: white
      label: ""
    }
    rom: BIOS ROM (256KB) {
      width: 100
      style.fill: "#F44336"
      style.font-color: white
    }
  }
  
  high_mem: Extended Memory (0x100000+) {
    grid-columns: 4
    grid-gap: 0
    
    main_ram: Main RAM (~480MB) {
      width: 300
      style.fill: "#4CAF50"
      style.font-color: white
    }
    acpi_reclaim: ACPI Tables {
      width: 30
      style.fill: "#FFC107"
      style.font-color: black
    }
    acpi_nvs: ACPI NVS {
      width: 40
      style.fill: "#F44336"
      style.font-color: white
    }
    mmio: MMIO (devices) {
      width: 60
      style.fill: "#9E9E9E"
      style.font-color: white
    }
  }
  
  legend: Legend {
    grid-columns: 4
    usable_leg: Usable RAM {
      style.fill: "#4CAF50"
    }
    reserved_leg: Reserved {
      style.fill: "#F44336"
    }
    acpi_leg: ACPI {
      style.fill: "#FFC107"
    }
    mmio_leg: MMIO {
      style.fill: "#9E9E9E"
    }
  }
}

# ============ PFA INITIALIZATION ============
pfa_init: Physical Frame Allocator Init {
  style.fill: "#F3E5F5"
  style.stroke: "#7B1FA2"
  
  step1: 1. Parse E820 Map {
    shape: rectangle
    style.fill: "#E1BEE7"
    
    code1: |c
      // Iterate E820 entries
      while (bios_call_next(&entry)) {
        if (entry.type == 1) { // Usable
          total_ram += entry.length;
        }
      }
    |
  }
  
  step2: 2. Calculate Bitmap Size {
    shape: rectangle
    style.fill: "#E1BEE7"
    
    code2: |c
      // 1 bit per 4KB frame
      num_frames = total_ram / PAGE_SIZE;
      bitmap_size = num_frames / 8;
      // Align up to PAGE_SIZE
      bitmap_pages = (bitmap_size + 4095) / 4096;
    |
  }
  
  step3: 3. Find Bitmap Location {
    shape: rectangle
    style.fill: "#E1BEE7"
    
    code3: |c
      // Find large enough usable region
      for (each e820_entry) {
        if (type == USABLE && 
            length >= bitmap_pages * 4096) {
          bitmap = (u32*)entry.base;
          break;
        }
      }
    |
  }
  
  step4: 4. Initialize Bitmap {
    shape: rectangle
    style.fill: "#E1BEE7"
    
    code4: |c
      // Mark ALL frames as reserved (1)
      memset(bitmap, 0xFF, bitmap_size);
      
      // Then mark usable regions as free (0)
      for (each e820_entry) {
        if (type == USABLE) {
          for (frame in range) {
            bitmap[frame/32] &= ~(1 << (frame%32));
          }
        }
      }
    |
  }
  
  step5: 5. Reserve Kernel and Bitmap {
    shape: rectangle
    style.fill: "#CE93D8"
    
    code5: |c
      // Never allocate these!
      mark_used(kernel_start, kernel_end);
      mark_used(bitmap, bitmap + bitmap_size);
      
      // Also reserve: initrd, boot modules
    |
  }
  
  step1 -> step2: "Next" {
    style.stroke: "#7B1FA2"
    style.stroke-width: 2
  }
  
  step2 -> step3: "Next" {
    style.stroke: "#7B1FA2"
    style.stroke-width: 2
  }
  
  step3 -> step4: "Next" {
    style.stroke: "#7B1FA2"
    style.stroke-width: 2
  }
  
  step4 -> step5: "Next" {
    style.stroke: "#7B1FA2"
    style.stroke-width: 2
  }
}

# ============ BITMAP STRUCTURE ============
bitmap_struct: Bitmap Allocator Structure {
  style.fill: "#ECEFF1"
  style.stroke: "#455A64"
  
  overview: Memory Representation {
    grid-columns: 1
    
    frame0: Frame 0 (0x0000-0x0FFF) {
      style.fill: "#4CAF50"
    }
    frame1: Frame 1 (0x1000-0x1FFF) {
      style.fill: "#4CAF50"
    }
    frame2: Frame 2 (0x2000-0x2FFF) {
      style.fill: "#4CAF50"
    }
    frameK: Frame K (kernel) {
      style.fill: "#F44336"
    }
    frameN: Frame N (bitmap) {
      style.fill: "#F44336"
    }
  }
  
  bitmap_array: Bitmap Array (u32[]) {
    shape: class
    
    "[0]": "0xFFFFFFFC (bits 0,1 free)"
    "[1]": "0x00000000 (all free)"
    "[k/32]": "bit (k%32) = 1 (kernel)"
    "[n/32]": "bit (n%32) = 1 (bitmap)"
  }
  
  operations: O(1) Operations {
    shape: class
    
    alloc: "find_first_zero() -> set_bit()"
    free: "clear_bit(frame_index)"
    is_free: "test_bit(frame_index)"
  }
  
  overview -> bitmap_array: "maps to" {
    style.stroke-dash: 3
  }
}

# ============ FREE LIST ALTERNATIVE ============
freelist: Alternative: Linked Free List {
  style.fill: "#E0F7FA"
  style.stroke: "#00ACC1"
  
  structure: Free Block Header {
    shape: class
    
    "+0x00": "next: *FreeBlock"
    "+0x04": "prev: *FreeBlock"
    "+0x08": "size: usize"
    "+0x0C": "magic: u32 (0xFREE)"
  }
  
  list: Free List State {
    shape: sequence_diagram
    
    head
    block1: 16KB block
    block2: 4KB block
    block3: 64KB block
    
    head -> block1: next
    block1 -> block2: next
    block2 -> block3: next
    block3 -> head: circular
  }
  
  pros: Advantages {
    shape: text
    label: "O(1) alloc from head\nCoalesce adjacent free blocks\nVariable allocation sizes"
  }
  
  cons: Disadvantages {
    shape: text
    label: "Requires usable memory to track\nFragmentation over time\nMore complex coalescing logic"
  }
}

# ============ FLOW CONNECTIONS ============
bios_call -> e820_entry: "fills" {
  style.stroke: "#1976D2"
  style.stroke-width: 2
  label: "24 bytes\nper entry"
}

e820_entry -> e820_output: "produces" {
  style.stroke: "#1976D2"
  style.stroke-width: 2
  label: "memory\nmap"
}

e820_output -> phys_mem: "visualized as" {
  style.stroke: "#FF9800"
  style.stroke-width: 2
}

e820_output -> pfa_init: "consumed by" {
  style.stroke: "#7B1FA2"
  style.stroke-width: 2
  label: "type filter:\nUSABLE only"
}

pfa_init -> bitmap_struct: "creates" {
  style.stroke: "#455A64"
  style.stroke-width: 2
  label: "bitmap\nallocator"
}

phys_mem -> pfa_init: "bitmap lives in\nlargest usable region" {
  style.stroke: "#9E9E9E"
  style.stroke-dash: 5
}

# ============ ALLOCATION PATH ============
alloc_flow: Frame Allocation Path {
  style.fill: "#FFEBEE"
  style.stroke: "#C62828"
  
  request: alloc_frame() {
    shape: oval
    style.fill: "#FFCDD2"
  }
  
  scan: Scan bitmap for 0 bit {
    shape: diamond
  }
  
  found: Found free frame? {
    shape: diamond
    style.fill: "#C8E6C9"
  }
  
  mark: Set bit to 1\nReturn frame address {
    shape: rectangle
    style.fill: "#C8E6C9"
  }
  
  fail: Return NULL\nOut of memory! {
    shape: rectangle
    style.fill: "#FFCDD2"
  }
  
  request -> scan
  scan -> found
  found -> mark: Yes {
    style.stroke: "#4CAF50"
  }
  found -> fail: No {
    style.stroke: "#F44336"
  }
}

# ============ KEY INSIGHTS ============
insights: |md
  ## Key Insights
  
  **Boot-time chicken-and-egg**: The bitmap must live somewhere, but we need the bitmap
  to know where we can put things. Solution: find a usable region large enough first,
  place bitmap there, then mark that region as used.
  
  **Type 3 (ACPI Reclaim)**: ACPI tables occupy memory at boot but can be reclaimed
  after parsing. Common optimization: parse ACPI early, then mark those frames free.
  
  **Bitmap vs Free List**: Bitmap is O(n) to find free frame but works before any
  memory is initialized. Free list is O(1) but requires headers in free memory—a
  catch-22 at boot. Most kernels use bitmap init then free list at runtime.
  
  **4KB granularity**: x86 pages are 4KB, so 1 bit tracks 4KB. 1GB RAM = 256KB bitmap.
  For 64-bit systems with terabytes, sparse structures or radix trees are used.
| {near: bottom-center}

# ============ BACK LINK ============
back: Back to Satellite Map {
  near: top-right
  link: "#memory-management"
  style.fill: "#E3F2FD"
  style.stroke: "#1976D2"
}