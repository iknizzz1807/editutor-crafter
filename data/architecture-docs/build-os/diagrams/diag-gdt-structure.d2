vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    header: "#4A90D9"
    kernel: "#2E7D32"
    user: "#C62828"
    metadata: "#6A1B9A"
    selector: "#F57C00"
    null: "#9E9E9E"
  }
}
title: |md
  # Global Descriptor Table (GDT) Structure
  ### x86 Protected Mode Memory Segmentation
| {near: top-center}
direction: right
gdt_overview: {
  label: ""
  shape: rectangle
  width: 800
  gdt_header: {
    label: "GDT Memory Layout\nBase Address (loaded via LGDT)"
    shape: rectangle
    style: {
      fill: ${colors.header}
      font-color: white
      bold: true
      stroke: "#2C5282"
    }
  }
  gdt_entries: {
    grid-rows: 5
    grid-gap: 4
    null_desc: {
      label: |md
        **Index 0: NULL Descriptor**
        Offset: 0x00 (8 bytes)
        Value:  0x0000000000000000
        *Required by CPU - loading selector 0x00 causes #GP*
      |
      style: {
        fill: ${colors.null}
        font-color: white
        stroke: "#616161"
      }
    }
    kcode_desc: {
      label: |md
        **Index 1: Kernel Code Segment**
        Offset: 0x08 (8 bytes)
        Value:  0x00CF9A000000FFFF
        Selector: 0x08 (RPL=0, TI=0, Index=1)
        Base=0, Limit=0xFFFFF (4GB), DPL=0, Executable+Readable
      |
      style: {
        fill: ${colors.kernel}
        font-color: white
        stroke: "#1B5E20"
      }
    }
    kdata_desc: {
      label: |md
        **Index 2: Kernel Data Segment**
        Offset: 0x10 (8 bytes)
        Value:  0x00CF92000000FFFF
        Selector: 0x10 (RPL=0, TI=0, Index=2)
        Base=0, Limit=0xFFFFF (4GB), DPL=0, Writable
      |
      style: {
        fill: ${colors.kernel}
        font-color: white
        stroke: "#1B5E20"
      }
    }
    ucode_desc: {
      label: |md
        **Index 3: User Code Segment**
        Offset: 0x18 (8 bytes)
        Value:  0x00CFFA000000FFFF
        Selector: 0x1B (RPL=3, TI=0, Index=3)
        Base=0, Limit=0xFFFFF (4GB), DPL=3, Executable+Readable
      |
      style: {
        fill: ${colors.user}
        font-color: white
        stroke: "#8E0000"
      }
    }
    udata_desc: {
      label: |md
        **Index 4: User Data Segment**
        Offset: 0x20 (8 bytes)
        Value:  0x00CFF2000000FFFF
        Selector: 0x23 (RPL=3, TI=0, Index=4)
        Base=0, Limit=0xFFFFF (4GB), DPL=3, Writable
      |
      style: {
        fill: ${colors.user}
        font-color: white
        stroke: "#8E0000"
      }
    }
  }
  gdt_entries -> gdt_header: "Entries" {
    style.stroke: ${colors.header}
  }
}
descriptor_layout: {
  label: ""
  shape: rectangle
  desc_header: {
    label: "Segment Descriptor Bit Layout (8 bytes)"
    shape: rectangle
    style: {
      fill: ${colors.metadata}
      font-color: white
      bold: true
      stroke: "#4A148C"
    }
  }
  bytes_grid: {
    grid-columns: 8
    grid-gap: 2
    byte0: {
      label: |md
        **Byte 0**
        Limit [7:0]
        (bits 0-7 of limit)
      |
      style.fill: "#E8F5E9"
    }
    byte1: {
      label: |md
        **Byte 1**
        Limit [15:8]
        (bits 8-15 of limit)
      |
      style.fill: "#E8F5E9"
    }
    byte2: {
      label: |md
        **Byte 2**
        Base [7:0]
        (bits 0-7 of base)
      |
      style.fill: "#E3F2FD"
    }
    byte3: {
      label: |md
        **Byte 3**
        Base [15:8]
        (bits 8-15 of base)
      |
      style.fill: "#E3F2FD"
    }
    byte4: {
      label: |md
        **Byte 4**
        Base [23:16]
        (bits 16-23 of base)
      |
      style.fill: "#E3F2FD"
    }
    byte5: {
      label: |md
        **Byte 5**
        Access Byte
        (see below)
      |
      style.fill: "#FFF3E0"
    }
    byte6: {
      label: |md
        **Byte 6**
        Flags + Limit [19:16]
      |
      style.fill: "#F3E5F5"
    }
    byte7: {
      label: |md
        **Byte 7**
        Base [31:24]
        (bits 24-31 of base)
      |
      style.fill: "#E3F2FD"
    }
  }
  bytes_grid -> desc_header: "Byte Layout" {
    style.stroke: ${colors.metadata}
  }
}
access_byte: {
  label: ""
  shape: rectangle
  access_header: {
    label: "Access Byte (Byte 5) - Bit Fields"
    shape: rectangle
    style: {
      fill: ${colors.selector}
      font-color: white
      bold: true
      stroke: "#E65100"
    }
  }
  access_bits: {
    grid-columns: 8
    grid-gap: 2
    bit7: {
      label: |md
        **Bit 7**
        **P**
        Present
        1=in memory
      |
      style.fill: "#FFECB3"
    }
    bit6_5: {
      label: |md
        **Bits 6-5**
        **DPL**
        Descriptor
        Privilege Level
        (0-3)
      |
      style.fill: "#FFCCBC"
    }
    bit4: {
      label: |md
        **Bit 4**
        **S**
        System
        0=system
        1=code/data
      |
      style.fill: "#C8E6C9"
    }
    bit3: {
      label: |md
        **Bit 3**
        **E**
        Executable
        1=code
        0=data
      |
      style.fill: "#B3E5FC"
    }
    bit2: {
      label: |md
        **Bit 2**
        **DC**
        Direction/
        Conforming
      |
      style.fill: "#D1C4E9"
    }
    bit1: {
      label: |md
        **Bit 1**
        **RW**
        Readable(code)
        Writable(data)
      |
      style.fill: "#B2DFDB"
    }
    bit0: {
      label: |md
        **Bit 0**
        **A**
        Accessed
        Set by CPU
        on access
      |
      style.fill: "#F0F4C3"
    }
  }
  access_examples: {
    label: |md
      **Access Byte Examples:**
      - `0x9A` = Kernel Code: P(1) DPL(00) S(1) E(1) DC(0) RW(1) A(0) = 10011010b
      - `0x92` = Kernel Data: P(1) DPL(00) S(1) E(0) DC(0) RW(1) A(0) = 10010010b
      - `0xFA` = User Code:   P(1) DPL(11) S(1) E(1) DC(0) RW(1) A(0) = 11111010b
      - `0xF2` = User Data:   P(1) DPL(11) S(1) E(0) DC(0) RW(1) A(0) = 11110010b
    |
    shape: rectangle
    style: {
      fill: "#FAFAFA"
      stroke: "#E0E0E0"
      font: mono
    }
  }
  access_bits -> access_header: "Bits" {
    style.stroke: ${colors.selector}
  }
  access_examples -> access_bits: "Decoded" {
    style.stroke: "#BDBDBD"
  }
}
flags_byte: {
  label: ""
  shape: rectangle
  flags_header: {
    label: "Flags Byte (High Nibble of Byte 6)"
    shape: rectangle
    style: {
      fill: "#00897B"
      font-color: white
      bold: true
    }
  }
  flags_bits: {
    grid-columns: 4
    grid-gap: 4
    flag_g: {
      label: |md
        **Bit 7 (G)**
        **Granularity**
        0 = byte granularity
        1 = 4KB block granularity
        Limit x 4096 if G=1
      |
      style.fill: "#B2DFDB"
    }
    flag_d: {
      label: |md
        **Bit 6 (D/B)**
        **Default Size**
        0 = 16-bit segments
        1 = 32-bit segments
        Affects stack ops
      |
      style.fill: "#B2DFDB"
    }
    flag_l: {
      label: |md
        **Bit 5 (L)**
        **Long Mode**
        1 = 64-bit code
        0 = compatibility
        (x86-64 only)
      |
      style.fill: "#C8E6C9"
    }
    flag_avl: {
      label: |md
        **Bit 4 (AVL)**
        **Available**
        For OS use
        CPU ignores
      |
      style.fill: "#DCEDC8"
    }
  }
  limit_high: {
    label: |md
      **Low Nibble of Byte 6: Limit [19:16]**
      Bits 0-3 contain the upper 4 bits of the 20-bit limit field.
      Combined with Bytes 0-1, forms complete limit value.
    |
    style: {
      fill: "#E8F5E9"
      stroke: "#81C784"
    }
  }
  flags_bits -> flags_header: "Flags" {
    style.stroke: "#00897B"
  }
  limit_high -> flags_bits: "Combined" {
    style.stroke: "#81C784"
  }
}
selector_format: {
  label: ""
  shape: rectangle
  selector_header: {
    label: "Segment Selector Format (16-bit value loaded into CS, DS, ES, SS, FS, GS)"
    shape: rectangle
    style: {
      fill: "#5D4037"
      font-color: white
      bold: true
    }
  }
  selector_bits: {
    grid-columns: 3
    grid-gap: 4
    sel_index: {
      label: |md
        **Bits 15-3: Index**
        Index into GDT/LDT
        0-8191 possible values
        Multiplied by 8 for offset
      |
      style.fill: "#D7CCC8"
    }
    sel_ti: {
      label: |md
        **Bit 2: TI**
        Table Indicator
        0 = GDT
        1 = LDT
      |
      style.fill: "#BCAAA4"
    }
    sel_rpl: {
      label: |md
        **Bits 1-0: RPL**
        Requested Privilege Level
        0-3 (0=highest privilege)
        Must be <= DPL for access
      |
      style.fill: "#A1887F"
    }
  }
  selector_examples: {
    label: |md
      **Selector Examples:**
      - 0x08: Index=1, TI=0, RPL=0 -> Kernel Code
      - 0x10: Index=2, TI=0, RPL=0 -> Kernel Data
      - 0x1B: Index=3, TI=0, RPL=3 -> User Code
      - 0x23: Index=4, TI=0, RPL=3 -> User Data
    |
    shape: rectangle
    style: {
      fill: "#FAFAFA"
      stroke: "#E0E0E0"
      font: mono
    }
  }
  selector_bits -> selector_header: "Format" {
    style.stroke: "#5D4037"
  }
  selector_examples -> selector_bits: "Examples" {
    style.stroke: "#BDBDBD"
  }
}
limit_calc: {
  label: ""
  shape: rectangle
  limit_header: {
    label: "Effective Limit Calculation"
    shape: rectangle
    style: {
      fill: "#1565C0"
      font-color: white
      bold: true
    }
  }
  limit_formula: {
    label: |md
      **When G=0 (byte granularity):**
      Effective Limit = Limit[19:0] (max: 0xFFFFF = 1MB)
      **When G=1 (4KB granularity):**
      Effective Limit = (Limit[19:0] x 4096) + 4095
      Example: Limit=0xFFFFF, G=1 -> 0xFFFFFFFF = 4GB-1
      **Segment Span (bytes):**
      Span = Effective Limit + 1
    |
    shape: rectangle
    style: {
      fill: "#E3F2FD"
      stroke: "#90CAF9"
      font: mono
    }
  }
  limit_formula -> limit_header: "Calculation" {
    style.stroke: "#1565C0"
  }
}
base_assembly: {
  label: ""
  shape: rectangle
  base_header: {
    label: "Base Address Assembly (32-bit)"
    shape: rectangle
    style: {
      fill: "#7B1FA2"
      font-color: white
      bold: true
    }
  }
  base_layout: {
    label: |md
      **Base address is split across THREE non-contiguous locations:**
      Byte 2:  Base [7:0]   (lowest 8 bits)
      Byte 3:  Base [15:8]
      Byte 4:  Base [23:16]
      Byte 7:  Base [31:24] (highest 8 bits)
      **To reconstruct:**
      base = (byte7 << 24) | (byte4 << 16) | (byte3 << 8) | byte2
      **For flat memory model (Base=0):** All base bytes = 0x00
    |
    shape: rectangle
    style: {
      fill: "#F3E5F5"
      stroke: "#CE93D8"
      font: mono
    }
  }
  base_layout -> base_header: "Assembly" {
    style.stroke: "#7B1FA2"
  }
}
legend: {
  near: bottom-center
  label: ""
  shape: rectangle
  style: {
    fill: "#FAFAFA"
    stroke: "#BDBDBD"
  }
  legend_content: {
    grid-columns: 5
    grid-gap: 8
    leg_kernel: {
      label: "Kernel (Ring 0)"
      style: {
        fill: ${colors.kernel}
        font-color: white
      }
    }
    leg_user: {
      label: "User (Ring 3)"
      style: {
        fill: ${colors.user}
        font-color: white
      }
    }
    leg_base: {
      label: "Base Address"
      style.fill: "#E3F2FD"
    }
    leg_limit: {
      label: "Limit"
      style.fill: "#E8F5E9"
    }
    leg_access: {
      label: "Access/Flags"
      style.fill: "#FFF3E0"
    }
  }
}
gdt_overview -> descriptor_layout: "Entry Details" {
  style.stroke-dash: 3
}
descriptor_layout -> access_byte: "Byte 5 Breakdown" {
  style.stroke-dash: 3
}
descriptor_layout -> flags_byte: "Byte 6 Breakdown" {
  style.stroke-dash: 3
}
access_byte -> selector_format: "Selector Uses Index" {
  style.stroke-dash: 3
}
flags_byte -> limit_calc: "Granularity Affects Limit" {
  style.stroke-dash: 3
}
descriptor_layout -> base_assembly: "Base Assembly" {
  style.stroke-dash: 3
}