vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    identity: "#8B4513"
    kernel: "#4169E1"
    heap: "#228B22"
    user: "#708090"
    hardware: "#DC143C"
    free: "#E8E8E8"
    page: "#9370DB"
  }
}

title: |md
  # Address Space: Identity Map + Higher-Half Kernel
  Virtual Memory Layout (x86, 4GB address space)
| {near: top-center}

direction: right

Virtual_Address_Space: {
  label: Virtual Address Space\n(What CPU sees)
  style.fill: "#F5F5F5"
  style.stroke: "#333"
  
  low_null: {
    label: "NULL\n0x00000000"
    height: 30
    style.fill: "#333333"
    style.font-color: white
  }
  
  identity_mapped: {
    label: "Identity-Mapped Region\n0x00100000 - 0x003FFFFF\n(2MB, first 1024 PTEs of PDE[0])\n\nVirt = Phys for kernel boot\nVGA at 0x000B8000\nBoot modules, lowmem structs"
    height: 180
    style.fill: "${colors.identity}"
    style.stroke: "#5D3A1A"
    style.font-color: white
    link: "#identity-detail"
  }
  
  user_space: {
    label: "User Space (Unmapped)\n0x00400000 - 0xBFFFFFFF\n~3GB available for processes"
    height: 150
    style.fill: "${colors.user}"
    style.stroke: "#4A4A5A"
    style.fill-pattern: dots
  }
  
  higher_half_kernel: {
    label: "Higher-Half Kernel\n0xC0000000+ (3GB+)\n\n.text, .rodata, .data, .bss\nMapped in ALL page directories\nPDE[768-1023] reserved"
    height: 200
    style.fill: "${colors.kernel}"
    style.stroke: "#1E3A6E"
    style.font-color: white
    link: "#higherhalf-detail"
  }
  
  kernel_heap: {
    label: "Kernel Heap\n0xD0000000+ (3.25GB+)\n\ndynamic allocations\nkmalloc() region\nexpandable upward"
    height: 120
    style.fill: "${colors.heap}"
    style.stroke: "#0D4D0D"
    style.font-color: white
    link: "#heap-detail"
  }
  
  mmio_space: {
    label: "MMIO Region\n0xE0000000+ (3.5GB+)\n\nDevice mappings\nFramebuffer, PCI BARs"
    height: 80
    style.fill: "${colors.hardware}"
    style.stroke: "#8B0000"
    style.font-color: white
  }
  
  recursive_mapping: {
    label: "Recursive PDE\n0xFFC00000 - 0xFFFFFFFF\n\nLast 4MB maps page tables\nPDE[1023] -> PDE itself"
    height: 60
    style.fill: "${colors.page}"
    style.stroke: "#4B0082"
    style.font-color: white
    link: "#recursive-detail"
  }
}

Physical_Memory: {
  label: Physical Memory\n(RAM, what's on bus)
  style.fill: "#FAFAFA"
  style.stroke: "#333"
  
  phys_low: {
    label: "Low Memory\n0x00000000 - 0x000FFFFF\n(First 1MB)\n\nBIOS, IVT, BDA\nVGA buffer 0xA0000-0xBFFFF"
    height: 100
    style.fill: "${colors.hardware}"
    style.font-color: white
  }
  
  phys_identity: {
    label: "Identity-Mapped RAM\n0x00100000 - 0x003FFFFF\n(2MB)\n\nKernel boot image\nPage tables, structs"
    height: 100
    style.fill: "${colors.identity}"
    style.font-color: white
  }
  
  phys_free: {
    label: "Free Physical Frames\n0x00400000+\n\nPage allocator manages\nFrame bitmap at 0x00300000"
    height: 180
    style.fill: "${colors.free}"
    style.stroke: "#AAA"
  }
  
  phys_kernel_actual: {
    label: "Kernel Code/Data\n(Loaded here by bootloader)\n.grub loads at 1MB\nBut linked to run at 0xC0100000"
    height: 100
    style.fill: "${colors.kernel}"
    style.font-color: white
  }
}

Translation_Mechanism: {
  label: Page Table Translation
  style.fill: "#FFF8DC"
  style.stroke: "#DAA520"
  
  cr3: {
    label: "CR3 -> PDBR\nPoints to Page Directory\n(4KB aligned, physical addr)"
    shape: diamond
    style.fill: "${colors.page}"
    style.font-color: white
  }
  
  page_directory: {
    label: "Page Directory (4KB)\n1024 x PDE (4 bytes each)\n\nPDE[0] -> First 4MB (identity)\nPDE[768] -> 0xC0000000+ (kernel)\nPDE[1023] -> Recursive self-map"
    style.fill: "#E6E6FA"
  }
  
  page_table: {
    label: "Page Table (4KB)\n1024 x PTE (4 bytes each)\n\nEach PTE maps one 4KB frame\nPTE contains:\n  - Physical frame address\n  - Present bit\n  - R/W, User/Supervisor\n  - Accessed, Dirty bits"
    style.fill: "#E6E6FA"
  }
  
  cr3 -> page_directory: "Index by\nbits 31-22"
  page_directory -> page_table: "Index by\nbits 21-12"
}

Virtual_Address_Space.identity_mapped -> Physical_Memory.phys_identity: "1:1 mapping\nVirt 0x00100000\n= Phys 0x00100000" {
  style.stroke: "${colors.identity}"
  style.stroke-width: 3
}

Virtual_Address_Space.higher_half_kernel -> Physical_Memory.phys_kernel_actual: "Offset -0xC0000000\nVirt 0xC0100000\n= Phys 0x00100000" {
  style.stroke: "${colors.kernel}"
  style.stroke-width: 3
  style.stroke-dash: 5
}

Virtual_Address_Space.kernel_heap -> Physical_Memory.phys_free: "Dynamically mapped\non kmalloc()" {
  style.stroke: "${colors.heap}"
  style.stroke-width: 2
  style.stroke-dash: 3
}

layers: {
  identity-detail: {
    label: Identity Mapping Detail
    
    explanation: |md
      ## Identity-Mapped Low Memory
      
      **Why identity map?**
      During boot, we need to access physical memory before
      paging is fully configured. Identity mapping (virt = phys)
      allows code to run identically before and after paging enable.
      
      **Critical addresses:**
      - `0x000B8000`: VGA text buffer (direct write = screen output)
      - `0x00007C00`: Boot sector loaded here by BIOS
      - `0x00100000`: Kernel loaded here by GRUB
      
      **Mapping construction:**
      PDE[0] covers 0x00000000-0x003FFFFF (4MB)
      Identity map first 4MB:
      PDE[0] = (0x00000000) | PRESENT | RW | SIZE_4MB;
      
      **After transition to higher-half:**
      This region can be unmapped to reclaim virtual address space
      for user processes. The kernel no longer needs identity mapping.
| {
      near: center-left
    }
  }
  
  higherhalf-detail: {
    label: Higher-Half Kernel Detail
    
    explanation: |md
      ## Higher-Half Kernel (0xC0000000+)
      
      **Why higher-half?**
      - User processes get full low 3GB address space
      - Kernel is always mapped, always accessible
      - No need to switch page tables on syscall
      
      **Linker script setup:**
      Kernel linked to run at 0xC0100000
      But loaded physically at 0x00100000
      
      **Boot sequence:**
      1. Kernel starts at 1MB physical (identity mapped)
      2. Set up page tables with higher-half mapping
      3. Load CR3 with new page directory
      4. Jump to higher-half address
      5. Unmap identity region (optional)
      
      **Virtual-to-physical conversion:**
      V2P(x) = (x) - 0xC0000000
      P2V(x) = (x) + 0xC0000000
| {
      near: center-left
    }
  }
  
  heap-detail: {
    label: Kernel Heap Detail
    
    explanation: |md
      ## Kernel Heap (0xD0000000+)
      
      **Purpose:**
      Dynamic kernel allocations after boot.
      kmalloc(), kfree() operate here.
      
      **Implementation options:**
      
      1. Linked-list allocator (simple):
         - heap_block struct with size, free flag, next pointer
      
      2. Slab allocator (performance):
         - Pre-allocate objects of common sizes
         - Fast allocation for task_struct, inode, etc.
      
      3. Buddy allocator (page-level):
         - Power-of-2 allocations
         - Easy coalescing on free
      
      **Expansion:**
      When heap exhausted, allocate new physical frame,
      map it to next virtual address in heap region,
      add to allocator free list.
| {
      near: center-left
    }
  }
  
  recursive-detail: {
    label: Recursive Page Table Mapping
    
    explanation: |md
      ## Recursive Mapping (0xFFC00000+)
      
      **The trick:**
      Set PDE[1023] to point to the page directory itself.
      This creates a virtual mapping where:
      
      - 0xFFC00000 accesses the page directory (as PTs)
      - 0xFFFFF000 accesses the page directory itself (as one PT)
      - 0xFFC00000 + (PDE_idx * 4096) = that PDE page table
      - 0xFFC00000 + (PDE_idx * 4096) + (PTE_idx * 4) = that PTE
      
      **Why do this?**
      Without recursive mapping, modifying page tables requires:
      1. Know physical address of PT
      2. Temporarily map it to virtual space
      3. Modify
      4. Unmap
      
      With recursive mapping, direct access via computed address.
      
      **Only costs one PDE slot (4MB of virtual space).**
| {
      near: center-left
    }
  }
}

legend: {
  near: bottom-center
  style.fill: "#F8F8F8"
  style.stroke: "#CCC"
  
  leg1: Identity-Mapped {
    style.fill: "${colors.identity}"
  }
  leg2: Higher-Half Kernel {
    style.fill: "${colors.kernel}"
  }
  leg3: Kernel Heap {
    style.fill: "${colors.heap}"
  }
  leg4: Hardware/MMIO {
    style.fill: "${colors.hardware}"
  }
  leg5: Page Structures {
    style.fill: "${colors.page}"
  }
  leg6: Free/Unmapped {
    style.fill: "${colors.free}"
  }
  
  leg1 -- leg2 -- leg3 -- leg4 -- leg5 -- leg6
}

nav: {
  near: top-right
  shape: text
  label: Back to Satellite
  link: "#satellite-system"
}