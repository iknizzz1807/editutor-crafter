vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    hardware: "#E74C3C"
    cpu: "#3498DB"
    kernel: "#27AE60"
    timing: "#F39C12"
    data: "#9B59B6"
  }
}
title: |md
  # Interrupt Handler: Complete Lifecycle
  ## From Hardware Signal to Process Resumption
| {near: top-center}
direction: right
section_hardware: Hardware Layer {
  style.fill: "${colors.hardware}"
  style.opacity: 0.15
  style.stroke: "${colors.hardware}"
  device: Device Controller {
    shape: rectangle
    style.fill: white
    style.stroke: "${colors.hardware}"
    tooltip: "Keyboard, Timer, Disk, Network"
    signal: IRQ Signal {
      shape: diamond
      style.fill: "${colors.hardware}"
      style.font-color: white
    }
  }
  pic: "8259 PIC" {
    style.fill: white
    style.stroke: "${colors.hardware}"
    irq_pending: IRQ Pending Queue
    priority_logic: Priority Arbiter
    int_pin: "INT Output to CPU" {
      style.stroke-width: 3
      style.stroke: "${colors.hardware}"
    }
    irq_pending -> priority_logic: scan
    priority_logic -> int_pin: "raise IRQ{n}"
  }
}
section_cpu: CPU Core {
  style.fill: "${colors.cpu}"
  style.opacity: 0.15
  style.stroke: "${colors.cpu}"
  pipeline: Instruction Pipeline {
    style.fill: white
    style.stroke: "${colors.cpu}"
    fetch: Fetch
    decode: Decode
    execute: Execute
    writeback: Writeback
    fetch -> decode -> execute -> writeback
  }
  sample_point: Interrupt Sample Point {
    shape: diamond
    style.fill: "${colors.timing}"
    label: "Sample\nbetween\ninstructions"
    tooltip: "CPU checks for pending interrupts after each instruction completes"
  }
  writeback -> sample_point
  auto_push: CPU Auto-Push {
    style.fill: white
    style.stroke: "${colors.cpu}"
    stack_frame: ||md
      SS      (if CPL change)
      ESP     (if CPL change)
      EFLAGS  ← always
      CS      ← always
      EIP     ← always
      Error   (some exceptions)
    ||
    note: "No software involvement!\nCPU does this automatically"
  }
  sample_point -> auto_push: interrupt pending {
    style.stroke: "${colors.cpu}"
    style.stroke-width: 3
    label: "~50-100 cycles"
  }
  idt_lookup: IDT Lookup {
    style.fill: white
    style.stroke: "${colors.cpu}"
    vector: Vector Number {
      shape: rectangle
      tooltip: "0-31: CPU Exceptions\n32-47: Hardware IRQs\n48-255: Software"
    }
    idt_entry: IDT Entry {
      shape: rectangle
      offset_low: "Offset[15:0]"
      selector: Segment Selector
      attributes: "Type | DPL | P"
      offset_high: "Offset[31:16]"
    }
    vector -> idt_entry: "index x 8"
    load_cs_eip: "Load CS:EIP" {
      shape: diamond
      style.fill: "${colors.cpu}"
      style.font-color: white
    }
    idt_entry -> load_cs_eip
  }
  auto_push -> idt_lookup: "~10-20 cycles"
}
section_entry: Handler Entry {
  style.fill: "${colors.kernel}"
  style.opacity: 0.15
  style.stroke: "${colors.kernel}"
  asm_stub: Assembly Stub {
    style.fill: white
    style.stroke: "${colors.kernel}"
    entry: "isr_common_stub / irq_common_stub" {
      style.font: mono
      style.bold: true
    }
    pusha_block: ||md
      asm
      pusha  ; eax,ecx,edx,ebx,esp,ebp,esi,edi
      push ds, es, fs, gs
      mov ax, 0x10  ; kernel DS
      mov ds, ax
      mov es, ax
      
    ||
    push_ptr: "push esp" {
      style.fill: "${colors.data}"
      style.font-color: white
      tooltip: "Pass register state pointer to C handler"
    }
  }
  stack_layout: Complete Stack Frame {
    style.fill: "${colors.data}"
    style.opacity: 0.2
    frame_diagram: ||md
      ESP →  [ptr to state]     ← C argument
             [gs]               ← our push
             [fs]
             [es]
             [ds]
             [edi]              ← pusha
             [esi]
             [ebp]
             [esp] (old)
             [ebx]
             [edx]
             [ecx]
             [eax]
             [int_no]           ← our push
             [err_code]         ← our push
             [EIP]              ← CPU push
             [CS]               ← CPU push
             [EFLAGS]           ← CPU push
             [ESP] (user)       ← CPU (if ring3→ring0)
             [SS] (user)        ← CPU (if ring3→ring0)
    ||
  }
  asm_stub -> stack_layout: "~20-30 cycles"
}
section_handler: C Handler {
  style.fill: "${colors.kernel}"
  style.opacity: 0.15
  style.stroke: "${colors.kernel}"
  c_handler: C Handler Function {
    style.fill: white
    style.stroke: "${colors.kernel}"
    signature: ||md
      c
      void handler(struct cpu_state *regs)
      
    ||
    operations: Handler Operations {
      dispatch: Dispatch by int_no
      timer_ops: Timer Handler {
        tick_counter: "tick_counter++"
        check_time_slice: check_time_slice()
        maybe_schedule: maybe_schedule()
      }
      keyboard_ops: Keyboard Handler {
        scancode: "scancode = inb(0x60)"
        convert_to_ascii: convert_to_ascii()
        buffer_putchar: buffer_putchar()
      }
      exception_ops: Exception Handler {
        read_cr2: "read CR2 (page fault)"
        decode_error: decode error code
        print_diagnostics: print_diagnostics()
        maybe_terminate: maybe_terminate_process()
      }
    }
    dispatch -> timer_ops: "int_no == 32"
    dispatch -> keyboard_ops: "int_no == 33"
    dispatch -> exception_ops: "int_no < 32"
  }
  eoi: Send EOI to PIC {
    style.fill: "${colors.hardware}"
    style.font-color: white
    shape: diamond
    eoi_code: ||md
      c
      void pic_send_eoi(int irq) {
        if (irq >= 8)
          outb(PIC2_CMD, 0x20);
        outb(PIC1_CMD, 0x20);
      }
      
    ||
    warning: "CRITICAL: Missing EOI freezes\nall future interrupts!"
    warning.style.fill: "#FFE0E0"
    warning.style.stroke: "${colors.hardware}"
  }
  c_handler -> eoi: "~50-500 cycles\n(handler dependent)"
}
section_exit: Handler Exit {
  style.fill: "${colors.kernel}"
  style.opacity: 0.15
  style.stroke: "${colors.kernel}"
  asm_exit: Assembly Exit {
    style.fill: white
    style.stroke: "${colors.kernel}"
    restore: ||md
      asm
      pop gs, fs, es, ds
      popa              ; restore all GPRs
      add esp, 8        ; skip int_no, err_code
      iret              ; return from interrupt
      
    ||
    iret_action: IRET Instruction {
      shape: diamond
      style.fill: "${colors.cpu}"
      style.font-color: white
      tooltip: "Pops: EIP, CS, EFLAGS\nAnd if returning to ring 3:\nESP, SS"
    }
  }
}
section_resume: Process Resumption {
  style.fill: "${colors.cpu}"
  style.opacity: 0.15
  style.stroke: "${colors.cpu}"
  resume: Interrupted Code {
    style.fill: white
    style.stroke: "${colors.cpu}"
    state: ||md
      All registers restored to exact
      pre-interrupt state.
      Process continues as if nothing
      happened.
    ||
    invisibility: "The Miracle of Transparency:\nInterrupted code has no knowledge\nit was ever paused"
    invisibility.style.fill: "${colors.timing}"
    invisibility.style.opacity: 0.3
  }
}
device.signal -> pic.irq_pending
pic.int_pin -> section_cpu.sample_point: "IRQ line asserted"
section_cpu.auto_push -> section_cpu.idt_lookup
section_cpu.idt_lookup.load_cs_eip -> section_entry.asm_stub.entry: "Jump to handler"
section_entry.asm_stub.push_ptr -> section_handler.c_handler.signature: "call handler"
section_handler.c_handler -> section_handler.eoi
section_handler.eoi -> section_exit.asm_exit.restore
section_exit.asm_exit.iret_action -> section_resume.resume
timing_panel: Timing Analysis {
  near: bottom-center
  style.fill: white
  style.stroke: "${colors.timing}"
  timing_table: ||md
    | Phase | Cycles | Time @ 2GHz |
    |-------|--------|-------------|
    | IRQ signal | 1 | 0.5 ns |
    | CPU sample | 0-100 | 0-50 ns |
    | Auto push | 20-40 | 10-20 ns |
    | IDT lookup | 10-20 | 5-10 ns |
    | Pipeline flush | 15-20 | 7.5-10 ns |
    | Stub push | 20-30 | 10-15 ns |
    | Handler body | 50-500+ | 25-250+ ns |
    | EOI | 10-20 | 5-10 ns |
    | Restore | 20-30 | 10-15 ns |
    | IRET | 15-25 | 7.5-12.5 ns |
    | **Total** | **200-800+** | **100-400+ ns** |
  ||
}
critical_notes: Critical Requirements {
  near: bottom-right
  style.fill: "#FFF3CD"
  style.stroke: "${colors.timing}"
  notes: ||md
    ### MUST DO:
    1. **Save ALL registers** - missing one corrupts state
    2. **Send EOI** - or PIC freezes forever
    3. **Keep handler fast** - interrupts disabled during handler
    4. **Don't block** - no sleeping in interrupt context
    5. **Check privilege** - ring 3→ring0 needs TSS.ESP0
    ### TIMING CONSTRAINTS:
    - Timer at 100Hz = 10ms between interrupts
    - At 2GHz = 20,000,000 cycles available
    - Handler budget: less than 1% = 200,000 cycles
    - Typical handler: 200-800 cycles
  ||
}
back_to_satellite: "Back to Satellite Map" {
  link: "#diag-satellite-overview"
  near: top-left
  style.fill: white
  style.stroke: gray
}