vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Interrupt Stack Frame Layout
  ## CPU-Generated Stack Contents on Interrupt Entry
| {near: top-center}

direction: right

classes: {
  register: {
    style: {
      fill: "#E8F4FD"
      stroke: "#2E86AB"
      font: mono
      bold: true
    }
  }
  error_code: {
    style: {
      fill: "#FFE5E5"
      stroke: "#C62828"
      font: mono
    }
  }
  stack_ptr: {
    style: {
      fill: "#E8F5E9"
      stroke: "#2E7D32"
      font: mono
      bold: true
    }
  }
  note_box: {
    style: {
      fill: "#FFF8E1"
      stroke: "#F57C00"
      stroke-dash: 3
    }
  }
  section_header: {
    style: {
      fill: "#263238"
      font-color: white
      bold: true
      font-size: 20
    }
  }
}

Same_Privilege: {
  label: "Same-Privilege Interrupt\n(Ring 0 â†’ Ring 0)"
  
  stack_same: {
    label: ""
    
    offset_col: |md
      **Offset**
      `+0x00`
      `+0x04`
      `+0x08`
      `+0x0C`
| {
      class: note_box
      near: left-center
    }
    
    content_col: {
      eip_same: EIP {
        class: register
        tooltip: Return instruction pointer
      }
      cs_same: CS {
        class: register
        tooltip: Return code segment (selector)
      }
      eflags_same: EFLAGS {
        class: register
        tooltip: CPU flags state at interrupt
      }
      near: center
    }
    
    esp_before: ESP_BEFORE {
      class: stack_ptr
      tooltip: "Stack pointer BEFORE interrupt\n(points here after CPU pushes)"
      label.near: outside-right-center
      near: right-center
    }
    
    note_same: |md
      **No privilege change**
      - No SS:ESP push
      - CPU stays on same stack
      - 12 bytes total pushed
| {
      class: note_box
      near: bottom-center
    }
  }
}

Cross_Privilege: {
  label: "Cross-Privilege Interrupt\n(Ring 3 â†’ Ring 0)"
  
  stack_cross: {
    label: ""
    
    offset_cross: |md
      **Offset**
      `+0x00`
      `+0x04`
      `+0x08`
      `+0x0C`
      `+0x10`
      `+0x14`
      `+0x18`
| {
      class: note_box
      near: left-center
    }
    
    content_cross: {
      eip_cross: EIP {
        class: register
        tooltip: Return instruction pointer
      }
      cs_cross: CS {
        class: register
        tooltip: Return code segment (selector)
      }
      eflags_cross: EFLAGS {
        class: register
        tooltip: CPU flags state at interrupt
      }
      esp_user: "ESP (user)" {
        class: stack_ptr
        tooltip: "User-mode stack pointer\n(saved from SS:ESP)"
      }
      ss_user: "SS (user)" {
        class: stack_ptr
        tooltip: "User-mode stack segment\n(saved for return)"
      }
      error_cross: "Error Code" {
        class: error_code
        tooltip: "Only for SOME exceptions\n(Page Fault, Double Fault, etc.)"
      }
      near: center
    }
    
    esp0_after: "ESP0 (kernel)" {
      class: stack_ptr
      tooltip: "Kernel stack pointer AFTER push\n(from TSS.ESP0)"
      label.near: outside-right-center
      near: right-center
    }
    
    note_cross: |md
      **Privilege change (CPL change)**
      - CPU loads SS0:ESP0 from TSS
      - Pushes user SS:ESP for return
      - 20 bytes pushed (24 with error)
      - Error code: exception-specific
| {
      class: note_box
      near: bottom-center
    }
  }
}

Handler_View: {
  label: Handler's View of Stack
  
  handler_stack: {
    label: ""
    
    handler_code: ||asm
      ; Entry point - interrupts disabled
      ; ESP points to saved EIP
      push eax         ; +0x1C (if error) or +0x10
      push ebx
      push ecx
      ; ... save all registers ...
      
      ; Now stack is:
      ; [saved regs] [EIP] [CS] [EFLAGS] [ESP] [SS] [err?]
      
      ; Access saved user ESP:
      mov eax, [esp + 24]  ; user ESP
      mov ebx, [esp + 28]  ; user SS
      
      ; Call C handler with stack pointer
      push esp
      call interrupt_handler
      
      ; Restore and return
      pop ecx
      pop ebx
      pop eax
      add esp, 8      ; skip error code (if present)
      iret            ; pops EIP, CS, EFLAGS, [ESP, SS]
||
    handler_code.near: top-center
    
    handler_note: |md
      **IRET instruction restores:**
      1. EIP â† [ESP+0]
      2. CS â† [ESP+4]
      3. EFLAGS â† [ESP+8]
      4. If CPL changed: ESP â† [ESP+12], SS â† [ESP+16]
      
      **Error Code Presence:**
      | Exception | Error Code |
      |-----------|------------|
      | #PF (14)  | Yes        |
      | #DF (8)   | Yes        |
      | #TS (10)  | Yes        |
      | #GP (13)  | Yes        |
      | #NP (11)  | Yes        |
      | #SS (12)  | Yes        |
      | #AC (17)  | Yes        |
      | Others    | No         |
| {
      class: note_box
      near: bottom-center
    }
  }
}

Memory_Layout: {
  label: Memory Layout Comparison
  
  layout_viz: {
    user_stack: "User Stack\n(Ring 3)" {
      style: {
        fill: "#E3F2FD"
        stroke: "#1565C0"
        stroke-dash: 3
        border-radius: 4
      }
    }
    
    tss: TSS {
      style.fill: "#F3E5F5"
      style.stroke: "#7B1FA2"
    }
    
    kernel_stack: "Kernel Stack\n(Ring 0)" {
      style: {
        fill: "#FFEBEE"
        stroke: "#C62828"
        border-radius: 4
      }
    }
    
    user_stack -> tss: "ESP3, SS3\n(saved context)"
    tss -> kernel_stack: "ESP0 loaded\non privilege change"
  }
}

Same_Privilege -> Cross_Privilege: Compare stacks {
  style: {
    stroke: "#455A64"
    stroke-dash: 5
    animated: true
  }
}

Cross_Privilege -> Handler_View: Handler reads {
  style: {
    stroke: "#2E7D32"
    animated: true
  }
}

Handler_View -> Memory_Layout: Stack switch {
  style: {
    stroke: "#7B1FA2"
    stroke-dash: 3
  }
}

legend: |md
  **Legend:**
  ğŸ”µ Blue = CPU registers pushed by hardware
  ğŸŸ¢ Green = Stack pointers (before/after)
  ğŸ”´ Red = Error code (exception-specific)
  ğŸŸ¡ Yellow = Notes and documentation
| {near: bottom-center}