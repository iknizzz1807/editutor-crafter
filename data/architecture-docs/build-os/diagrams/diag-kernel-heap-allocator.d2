vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    header: "#2E4057"
    used: "#C8553D"
    free: "#588B8B"
    metadata: "#F2E3DB"
    text: "#E8E8E8"
    arrow: "#A6C9BB"
  }
}
title: |md
  # Kernel Heap: kmalloc/kfree Architecture
  ## Virtual Address Range, Block Headers, and Allocation Strategy
| {near: top-center}
virtual_memory: {
  label: Kernel Virtual Address Space
  range_layout: {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.stroke: "#4a4a6a"
    style.stroke-width: 2
    width: 700
    kernel_start: "0xC0000000\nKernel Base" {
      style.fill: transparent
      style.font-color: ${colors.text}
      style.font-size: 14
    }
    kernel_code: ".text .rodata .data .bss" {
      style.fill: "#2d2d44"
      style.font-color: ${colors.text}
      style.font-size: 12
    }
    heap_region: "HEAP REGION\n0xD0000000 - 0xDFFFFFFF\n(256 MB virtual)" {
      style.fill: "#3d5a80"
      style.font-color: "#ffffff"
      style.font-size: 16
      style.bold: true
    }
    heap_start: "HEAP_START\n0xD0000000" {
      style.fill: "#2d2d44"
      style.font-color: ${colors.text}
      style.font-size: 14
    }
    heap_end: "heap_end_virtual\n(grows on demand)" {
      style.fill: "#2d2d44"
      style.font-color: ${colors.text}
      style.font-size: 14
    }
    unused: "Unmapped\n(demand-paged)" {
      style.fill: "#1a1a2e"
      style.font-color: "#666666"
      style.font-size: 12
    }
    kernel_end: "0xFFFFFFFF" {
      style.fill: transparent
      style.font-color: ${colors.text}
      style.font-size: 14
    }
  }
}
block_header: {
  label: Heap Block Header Structure
  header_struct: {
    shape: rectangle
    style.fill: ${colors.header}
    style.stroke: "#4a6fa5"
    style.stroke-width: 2
    width: 600
    fields: {
      shape: rectangle
      style.fill: transparent
      width: 580
      field_size: "size: uint32_t" {
        style.fill: "#3d5a80"
        style.font-color: ${colors.text}
        width: 140
      }
      field_free: "free: uint8_t" {
        style.fill: "#3d5a80"
        style.font-color: ${colors.text}
        width: 140
      }
      field_magic: "magic: uint8_t\n(0xAB)" {
        style.fill: "#3d5a80"
        style.font-color: ${colors.text}
        width: 140
      }
      field_reserved: "reserved:\nuint16_t" {
        style.fill: "#3d5a80"
        style.font-color: ${colors.text}
        width: 140
      }
    }
    ptr_fields: {
      shape: rectangle
      style.fill: transparent
      width: 580
      field_prev: "*prev: pointer" {
        style.fill: "#5a7a9a"
        style.font-color: ${colors.text}
        width: 285
      }
      field_next: "*next: pointer" {
        style.fill: "#5a7a9a"
        style.font-color: ${colors.text}
        width: 285
      }
    }
  }
  notes: ||md
    c
    struct heap_block {
      uint32_t size;      // Size of data area
      uint8_t  free;      // 1 = free, 0 = used
      uint8_t  magic;     // 0xAB for corruption detect
      uint16_t reserved;
      struct heap_block *next;
      struct heap_block *prev;
    } __attribute__((packed));
    #define BLOCK_HEADER_SIZE 16
  || {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.font-color: ${colors.text}
    style.font-size: 11
  }
}
memory_layout: {
  label: Heap Memory Layout (Example State)
  layout: {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.stroke: "#4a4a6a"
    style.stroke-width: 2
    width: 700
    addr_col: {
      shape: rectangle
      style.fill: "#2d2d44"
      style.font-color: "#888888"
      style.font-size: 10
      width: 90
      addr_header: "Address" {style.bold: true}
      addr_0: "0xD0000000"
      addr_1: "0xD0000010"
      addr_2: "0xD0000090"
      addr_3: "0xD0000190"
      addr_4: "0xD0000210"
      addr_5: "0xD0000290"
    }
    block_col: {
      shape: rectangle
      style.fill: "#1a1a2e"
      width: 500
      header_label: "HDR" {
        style.fill: ${colors.header}
        style.font-color: ${colors.text}
        style.font-size: 10
        width: 40
      }
      block1_header: "HDR\nsz=128\nfree=0" {
        style.fill: ${colors.header}
        style.font-color: ${colors.text}
        style.font-size: 9
        width: 40
      }
      block1_data: "USED DATA\n(128 bytes)\nkmalloc(120)" {
        style.fill: ${colors.used}
        style.font-color: "#ffffff"
        style.font-size: 10
        width: 200
      }
      block2_header: "HDR\nsz=256\nfree=1" {
        style.fill: ${colors.header}
        style.font-color: ${colors.text}
        style.font-size: 9
        width: 40
      }
      block2_data: "FREE DATA\n(256 bytes)\nAvailable" {
        style.fill: ${colors.free}
        style.font-color: "#ffffff"
        style.font-size: 10
        width: 200
      }
      block3_header: "HDR\nsz=64\nfree=0" {
        style.fill: ${colors.header}
        style.font-color: ${colors.text}
        style.font-size: 9
        width: 40
      }
      block3_data: "USED\n(64B)" {
        style.fill: ${colors.used}
        style.font-color: "#ffffff"
        style.font-size: 10
        width: 100
      }
      block4_header: "HDR\nsz=128\nfree=1" {
        style.fill: ${colors.header}
        style.font-color: ${colors.text}
        style.font-size: 9
        width: 40
      }
      block4_data: "FREE\n(128B)" {
        style.fill: ${colors.free}
        style.font-color: "#ffffff"
        style.font-size: 10
        width: 100
      }
      unmapped: "UNMAPPED\n(not yet paged-in)" {
        style.fill: "#1a1a2e"
        style.font-color: "#555555"
        style.stroke-dash: 3
        style.stroke: "#444444"
        width: 500
      }
    }
  }
  legend: {
    shape: rectangle
    style.fill: "#1a1a2e"
    width: 600
    leg_header: "HDR = Block Header (16 bytes)" {
      style.fill: ${colors.header}
      style.font-color: ${colors.text}
      style.font-size: 11
    }
    leg_used: "Used Block (allocated via kmalloc)" {
      style.fill: ${colors.used}
      style.font-color: "#ffffff"
      style.font-size: 11
    }
    leg_free: "Free Block (available for allocation)" {
      style.fill: ${colors.free}
      style.font-color: "#ffffff"
      style.font-size: 11
    }
  }
}
kmalloc_flow: {
  label: "kmalloc(size) - First-Fit Algorithm"
  flow: {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.stroke: "#4a4a6a"
    style.stroke-width: 2
    start: "kmalloc(size)" {
      shape: oval
      style.fill: "#3d5a80"
      style.font-color: ${colors.text}
    }
    align: "Align size to 16 bytes\nsize = (size + 15) & ~15" {
      style.fill: "#2d2d44"
      style.font-color: ${colors.text}
    }
    find_block: "Find first free block\nwith size >= request" {
      style.fill: "#2d2d44"
      style.font-color: ${colors.text}
    }
    found_check: "Block\nfound?" {
      shape: diamond
      style.fill: "#4a6fa5"
      style.font-color: ${colors.text}
    }
    expand_heap: "Expand heap:\n1. map new page(s)\n2. create block\n3. coalesce if needed" {
      style.fill: "#5a3d80"
      style.font-color: ${colors.text}
    }
    split_check: "Block much\nlarger?\n(size > needed +\n16 + MIN_BLOCK)" {
      shape: diamond
      style.fill: "#4a6fa5"
      style.font-color: ${colors.text}
    }
    split: "Split block:\n1. Create new header\n2. Adjust sizes\n3. Link blocks" {
      style.fill: "#5a3d80"
      style.font-color: ${colors.text}
    }
    mark_used: "Mark block as used\nblock->free = 0" {
      style.fill: "#3d8050"
      style.font-color: ${colors.text}
    }
    return_ptr: "return (block + 16)\n// pointer after header" {
      shape: oval
      style.fill: "#3d8050"
      style.font-color: ${colors.text}
    }
    return_null: "return NULL\n// Out of memory" {
      shape: oval
      style.fill: ${colors.used}
      style.font-color: "#ffffff"
    }
    start -> align: "enter" {style.stroke: ${colors.arrow}}
    align -> find_block {style.stroke: ${colors.arrow}}
    find_block -> found_check {style.stroke: ${colors.arrow}}
    found_check -> expand_heap: "No" {style.stroke: ${colors.used}}
    found_check -> split_check: "Yes" {style.stroke: ${colors.free}}
    expand_heap -> split_check {style.stroke: ${colors.arrow}}
    split_check -> split: "Yes" {style.stroke: ${colors.free}}
    split -> mark_used {style.stroke: ${colors.arrow}}
    split_check -> mark_used: "No" {style.stroke: ${colors.arrow}}
    mark_used -> return_ptr {style.stroke: ${colors.arrow}}
    expand_heap -> return_null: "Heap limit\nreached" {style.stroke: ${colors.used}}
  }
}
kfree_flow: {
  label: "kfree(ptr) - Free with Coalescing"
  flow: {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.stroke: "#4a4a6a"
    style.stroke-width: 2
    start_free: "kfree(ptr)" {
      shape: oval
      style.fill: "#3d5a80"
      style.font-color: ${colors.text}
    }
    get_header: "Get block header:\nblock = ptr - 16" {
      style.fill: "#2d2d44"
      style.font-color: ${colors.text}
    }
    magic_check: "magic == 0xAB?" {
      shape: diamond
      style.fill: "#4a6fa5"
      style.font-color: ${colors.text}
    }
    free_check: "Already free?" {
      shape: diamond
      style.fill: "#4a6fa5"
      style.font-color: ${colors.text}
    }
    error_corrupt: "ERROR:\nHeap corruption!" {
      style.fill: ${colors.used}
      style.font-color: "#ffffff"
    }
    error_double: "WARNING:\nDouble free!" {
      style.fill: "#806030"
      style.font-color: "#ffffff"
    }
    mark_free: "Mark as free:\nblock->free = 1" {
      style.fill: ${colors.free}
      style.font-color: "#ffffff"
    }
    coalesce_next: "Next block free?\n-> Merge with next" {
      shape: diamond
      style.fill: "#4a6fa5"
      style.font-color: ${colors.text}
    }
    do_coalesce_next: "Coalesce:\nblock->size += next->size + 16\nblock->next = next->next" {
      style.fill: ${colors.free}
      style.font-color: "#ffffff"
    }
    coalesce_prev: "Previous block free?\n-> Merge with prev" {
      shape: diamond
      style.fill: "#4a6fa5"
      style.font-color: ${colors.text}
    }
    do_coalesce_prev: "Coalesce:\nprev->size += block->size + 16\nprev->next = block->next" {
      style.fill: ${colors.free}
      style.font-color: "#ffffff"
    }
    done: "return" {
      shape: oval
      style.fill: ${colors.free}
      style.font-color: "#ffffff"
    }
    start_free -> get_header {style.stroke: ${colors.arrow}}
    get_header -> magic_check {style.stroke: ${colors.arrow}}
    magic_check -> error_corrupt: "No" {style.stroke: ${colors.used}}
    magic_check -> free_check: "Yes" {style.stroke: ${colors.free}}
    free_check -> error_double: "Yes" {style.stroke: "#806030"}
    free_check -> mark_free: "No" {style.stroke: ${colors.free}}
    mark_free -> coalesce_next {style.stroke: ${colors.arrow}}
    coalesce_next -> do_coalesce_next: "Yes" {style.stroke: ${colors.free}}
    do_coalesce_next -> coalesce_prev {style.stroke: ${colors.arrow}}
    coalesce_next -> coalesce_prev: "No" {style.stroke: ${colors.arrow}}
    coalesce_prev -> do_coalesce_prev: "Yes" {style.stroke: ${colors.free}}
    do_coalesce_prev -> done {style.stroke: ${colors.arrow}}
    coalesce_prev -> done: "No" {style.stroke: ${colors.arrow}}
  }
}
coalescing: {
  label: Block Coalescing on Free
  before: {
    label: "Before kfree(ptr)"
    before_blocks: {
      shape: rectangle
      style.fill: "#1a1a2e"
      b1_hdr: "HDR" {style.fill: ${colors.header}; style.font-color: ${colors.text}; style.font-size: 9}
      b1_data: "USED\n64B" {style.fill: ${colors.used}; style.font-color: "#ffffff"; style.font-size: 10}
      b2_hdr: "HDR" {style.fill: ${colors.header}; style.font-color: ${colors.text}; style.font-size: 9}
      b2_data: "FREE\n128B\n<- ptr points here" {style.fill: ${colors.free}; style.font-color: "#ffffff"; style.font-size: 10}
      b3_hdr: "HDR" {style.fill: ${colors.header}; style.font-color: ${colors.text}; style.font-size: 9}
      b3_data: "FREE\n64B" {style.fill: ${colors.free}; style.font-color: "#ffffff"; style.font-size: 10}
    }
  }
  arrow_label: "kfree()" {
    style.fill: ${colors.arrow}
    style.font-color: ${colors.text}
  }
  after: {
    label: "After Coalescing"
    after_blocks: {
      shape: rectangle
      style.fill: "#1a1a2e"
      a1_hdr: "HDR" {style.fill: ${colors.header}; style.font-color: ${colors.text}; style.font-size: 9}
      a1_data: "USED\n64B" {style.fill: ${colors.used}; style.font-color: "#ffffff"; style.font-size: 10}
      a2_hdr: "HDR\n(single)" {style.fill: ${colors.header}; style.font-color: ${colors.text}; style.font-size: 9}
      a2_data: "FREE\n208B\n(128+16+64 merged)" {style.fill: ${colors.free}; style.font-color: "#ffffff"; style.font-size: 10}
    }
  }
  before -> arrow_label -> after
}
comparison: {
  label: Allocator Strategy Comparison
  strategies: {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.stroke: "#4a4a6a"
    style.stroke-width: 2
    grid-columns: 2
    grid-gap: 20
    first_fit: {
      label: "First-Fit (Current Implementation)"
      style.fill: "#2d2d44"
      ff_desc: |md
        **Algorithm:**
        - Linear scan from start
        - Return first block >= size
        **Pros:**
        - Simple implementation
        - O(n) worst case
        - Good locality
        **Cons:**
        - Fragmentation at front
        - No size optimization
      | {
        style.fill: "#1a1a2e"
        style.font-color: ${colors.text}
        style.font-size: 11
      }
      ff_visual: {
        shape: rectangle
        style.fill: "#1a1a2e"
        width: 280
        ff_b1: "128B free" {style.fill: ${colors.free}; style.font-color: "#ffffff"; style.font-size: 10}
        ff_b2: "256B used" {style.fill: ${colors.used}; style.font-color: "#ffffff"; style.font-size: 10}
        ff_b3: "64B free" {style.fill: ${colors.free}; style.font-color: "#ffffff"; style.font-size: 10}
        ff_req: "Request: 64B -> Use block 1" {
          style.fill: "#3d5a80"
          style.font-color: ${colors.text}
          style.font-size: 10
        }
      }
    }
    optimized: {
      label: Potential Optimizations
      style.fill: "#2d2d44"
      opt_desc: |md
        **Best-Fit:**
        - Find smallest block >= size
        - Less wasted space
        - More fragmentation
        **Free List Buckets:**
        - Separate lists per size class
        - O(1) for common sizes
        - More metadata overhead
        **Buddy Allocator:**
        - Power-of-2 block sizes
        - Fast merge/split
        - Internal fragmentation
      | {
        style.fill: "#1a1a2e"
        style.font-color: ${colors.text}
        style.font-size: 11
      }
      opt_visual: {
        shape: rectangle
        style.fill: "#1a1a2e"
        width: 280
        bucket_label: "Bucketed Free Lists:" {style.fill: "#3d5a80"; style.font-color: ${colors.text}; style.font-size: 10}
        bucket_16: "[16-32]:  block -> block" {style.fill: "#2d2d44"; style.font-color: ${colors.text}; style.font-size: 9}
        bucket_32: "[33-64]:  block -> block" {style.fill: "#2d2d44"; style.font-color: ${colors.text}; style.font-size: 9}
        bucket_64: "[65-128]: block -> block" {style.fill: "#2d2d44"; style.font-color: ${colors.text}; style.font-size: 9}
        bucket_128: "[129+]:   block -> block" {style.fill: "#2d2d44"; style.font-color: ${colors.text}; style.font-size: 9}
      }
    }
  }
}
metrics: {
  label: Key Implementation Constants
  constants: {
    shape: rectangle
    style.fill: "#2d2d44"
    style.font-color: ${colors.text}
    const_data: ||md
      | Constant | Value | Purpose |
      |----------|-------|---------|
      | `HEAP_START` | 0xD0000000 | Base virtual address |
      | `HEAP_SIZE` | 0x10000000 (256MB) | Max virtual range |
      | `BLOCK_HEADER_SIZE` | 16 bytes | sizeof(heap_block) |
      | `HEAP_MIN_BLOCK` | 16 bytes | Minimum alloc size |
      | `HEAP_MAGIC` | 0xAB | Corruption detection |
      | Alignment | 16 bytes | All allocations aligned |
    ||
  }
}
virtual_memory -> block_header: "Header defines\nblock structure" {
  style.stroke: ${colors.arrow}
  style.stroke-dash: 3
}
block_header -> memory_layout: "Headers embedded\nin heap memory" {
  style.stroke: ${colors.arrow}
  style.stroke-dash: 3
}
memory_layout -> kmalloc_flow: "Algorithm searches\nblock list" {
  style.stroke: ${colors.arrow}
  style.stroke-dash: 3
}
kmalloc_flow -> kfree_flow: "Allocated blocks\nmust be freed" {
  style.stroke: ${colors.arrow}
  style.stroke-dash: 3
}
kfree_flow -> coalescing: "Free triggers\ncoalescing" {
  style.stroke: ${colors.arrow}
  style.stroke-dash: 3
}
coalescing -> comparison: "Tradeoffs in\ndesign choices" {
  style.stroke: ${colors.arrow}
  style.stroke-dash: 3
}