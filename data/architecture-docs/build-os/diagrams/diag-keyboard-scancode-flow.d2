vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # PS/2 Keyboard: Scancode to ASCII Pipeline
  ## IRQ1 → Port 0x60 → State Machine → Lookup → Buffer
| {near: top-center}
direction: right
classes: {
  hardware: {
    style: {
      fill: "#FFE4B5"
      stroke: "#D2691E"
      stroke-width: 2
    }
  }
  interrupt: {
    style: {
      fill: "#FFB6C1"
      stroke: "#DC143C"
      stroke-width: 2
    }
  }
  state_machine: {
    style: {
      fill: "#98FB98"
      stroke: "#228B22"
      stroke-width: 2
    }
  }
  lookup: {
    style: {
      fill: "#87CEEB"
      stroke: "#4169E1"
      stroke-width: 2
    }
  }
  buffer: {
    style: {
      fill: "#DDA0DD"
      stroke: "#8B008B"
      stroke-width: 2
    }
  }
  decision: {
    shape: diamond
    style: {
      fill: "#FFFACD"
      stroke: "#DAA520"
    }
  }
}
section_hardware: Hardware Layer {
  style.fill: "#FFF8DC"
  keyboard_controller: Keyboard Controller (8042) {
    class: hardware
    port_60: "Data Port 0x60\n(Read Scancode)"
    port_64: "Status Port 0x64\n(Ready Check)"
  }
  pic: PIC 8259 {
    class: hardware
    irq1: IRQ1 Output
  }
  keyboard_controller.port_64 -> pic: "Status bit 0 = 1\n(data ready)" {
    style.stroke: "#D2691E"
    style.stroke-dash: 3
  }
}
section_interrupt: Interrupt Delivery {
  style.fill: "#FFF0F5"
  pic -> cpu: "IRQ1 → INT 33\n(vector 0x21)" {
    class: interrupt
    label: "Raise interrupt\nwhen key pressed/released"
  }
  cpu: CPU {
    class: interrupt
    state: "Push EFLAGS, CS, EIP\nJump to IDT[33]"
  }
}
section_handler: IRQ1 Handler {
  style.fill: "#F0FFF0"
  handler_entry: irq1_handler {
    class: state_machine
    label: ||md
      Assembly Entry:
      - pusha (save regs)
      - push ds,es,fs,gs
      - mov ax, 0x10
      - call C handler
    ||
  }
  cpu -> handler_entry: "CS:EIP = handler" {
    style.stroke: "#DC143C"
  }
}
section_read: Read Scancode {
  style.fill: "#F0FFF0"
  read_port: Read Port 0x60 {
    class: state_machine
    label: ||md
      c
      uint8_t scancode = inb(0x60);
      // e.g., 0x1E (A press)
      //       0x9E (A release)
      //       0xE0 (extended prefix)
    ||
  }
  keyboard_controller.port_60 -> read_port: "inb(0x60)" {
    style.stroke: "#228B22"
    style.stroke-width: 3
    label: "8-bit scancode"
  }
  handler_entry -> read_port: "Call C"
}
section_state_machine: Scancode State Machine {
  style.fill: "#F5FFFA"
  state_normal: NORMAL {
    class: state_machine
    label: ||md
      Default state
      Process single-byte scancodes
    ||
  }
  state_extended: EXTENDED {
    class: state_machine
    label: ||md
      After 0xE0 received
      Wait for second byte
    ||
  }
  check_e0: "scancode == 0xE0?" {
    class: decision
  }
  check_release: "scancode & 0x80?" {
    class: decision
    label: "High bit set?\n(Break code)"
  }
  read_port -> check_e0: "scancode"
  check_e0 -> state_extended: "Yes" {
    label: "Extended prefix\nSet extended=1"
  }
  check_e0 -> check_release: "No" {
    label: "Single-byte\nscancode"
  }
  state_extended -> check_release: "Second byte\nreceived" {
    label: "extended=0\n(process)"
  }
  check_release -> modifier_check: "No (Make)" {
    label: "Key pressed"
    style.stroke: "#228B22"
  }
  check_release -> release_handler: "Yes (Break)" {
    label: "Key released\nscancode &= 0x7F"
    style.stroke: "#DC143C"
  }
}
section_modifiers: Modifier Key Handling {
  style.fill: "#F5FFFA"
  modifier_check: Check Modifier Keys {
    class: state_machine
    label: ||md
      c
      switch (scancode & 0x7F):
      case 0x2A: L-Shift
      case 0x36: R-Shift  
      case 0x1D: Ctrl
      case 0x38: Alt
      case 0x3A: Caps Lock
    ||
  }
  release_handler: Update Modifier State {
    class: state_machine
    label: ||md
      c
      shift_pressed = !released
      ctrl_pressed = !released
      alt_pressed = !released
      caps_lock ^= !released (toggle)
    ||
  }
  modifier_state: Modifier State {
    class: state_machine
    label: ||md
      c
      static int shift_pressed = 0;
      static int ctrl_pressed = 0;
      static int alt_pressed = 0;
      static int caps_lock = 0;
    ||
  }
  modifier_check -> modifier_state: "Update" {
    style.stroke: "#4169E1"
  }
  release_handler -> modifier_state: "Clear bit" {
    style.stroke: "#DC143C"
  }
}
section_lookup: ASCII Translation {
  style.fill: "#F0F8FF"
  lookup_tables: Scancode → ASCII Tables {
    class: lookup
    label: ||md
      c
      const char normal[128] = {
        0,0x1B,'1','2','3','4','5','6',
        '7','8','9','0','-','=',0x08,0x09,
        'q','w','e','r','t','y','u','i',
        'o','p','[',']','\n',0,'a','s',
        // ... continued
      };
      const char shifted[128] = {
        0,0x1B,'!','@','#','$','%','^',
        '&','*','(',')','_','+',0x08,0x09,
        'Q','W','E','R','T','Y','U','I',
        // ... uppercase + symbols
      };
    ||
  }
  select_table: "shift ^ caps_lock?" {
    class: decision
    label: "Use shifted table?"
  }
  modifier_state -> select_table: "shift, caps_lock" {
    style.stroke: "#4169E1"
    style.stroke-dash: 3
  }
  modifier_check -> select_table: "Non-modifier\nscancode"
  select_table -> lookup_tables: "Yes" {
    label: "Use shifted[]"
    style.stroke: "#8B008B"
  }
  select_table -> lookup_tables: "No" {
    label: "Use normal[]"
    style.stroke: "#228B22"
  }
}
section_buffer: Circular Buffer {
  style.fill: "#FFF0F5"
  ascii_result: ASCII Result {
    class: lookup
    label: ||md
      c
      char ascii = table[scancode];
      // e.g., scancode 0x1E → 'a' or 'A'
    ||
  }
  lookup_tables -> ascii_result: "ascii char"
  buffer_struct: Keyboard Buffer {
    class: buffer
    label: ||md
      c
      #define KB_BUFFER_SIZE 256
      static char kb_buffer[256];
      static volatile uint32_t 
          kb_read_pos = 0,
          kb_write_pos = 0;
    ||
  }
  buffer_insert: Insert to Buffer {
    class: buffer
    label: ||md
      c
      uint32_t next = (kb_write_pos + 1) % 256;
      if (next != kb_read_pos) {
          kb_buffer[kb_write_pos] = ascii;
          kb_write_pos = next;
      }
      // If next == read_pos: buffer full, drop char
    ||
  }
  ascii_result -> buffer_insert: "if (ascii != 0)"
  buffer_insert -> buffer_struct: "Store"
  buffer_diagram: Buffer State Visualization {
    class: buffer
    label: ||md
      [R] = read position
      [W] = write position
          R         W
          ↓         ↓
      ┌───┬───┬───┬───┬───┬───┬───┬───┐
      │ H │ e │ l │ l │ o │   │   │   │
      └───┴───┴───┴───┴───┴───┴───┴───┘
        0   1   2   3   4   5   6   7 ...
    ||
  }
  buffer_struct -> buffer_diagram
}
section_eoi: Complete Interrupt {
  style.fill: "#FFF0F5"
  send_eoi: Send EOI {
    class: interrupt
    label: ||md
      c
      // IRQ1 came from master PIC
      outb(0x20, 0x20);  // PIC1_CMD
    ||
  }
  buffer_insert -> send_eoi
  restore_iret: Restore & Return {
    class: interrupt
    label: ||md
      asm
      pop gs, fs, es, ds
      popa
      add esp, 8      ; skip int_no, err_code
      iret            ; return to interrupted code
    ||
  }
  send_eoi -> restore_iret
}
section_api: Consumer API {
  style.fill: "#F5F5F5"
  getchar: keyboard_getchar() {
    class: buffer
    label: ||md
      c
      char keyboard_getchar(void) {
        if (kb_read_pos == kb_write_pos)
          return 0;  // empty
        char c = kb_buffer[kb_read_pos];
        kb_read_pos = (kb_read_pos + 1) % 256;
        return c;
      }
    ||
  }
  has_char: keyboard_has_char() {
    class: buffer
    label: ||md
      c
      int keyboard_has_char(void) {
        return kb_read_pos != kb_write_pos;
      }
    ||
  }
  buffer_diagram -> getchar: "Consumer reads"
  buffer_diagram -> has_char: "Check available"
}
legend: ||md
  ## Scancode Examples (Set 1)
  | Key | Make | Break | ASCII (normal) |
  |-----|------|-------|----------------|
  | A | 0x1E | 0x9E | 'a' |
  | B | 0x30 | 0xB0 | 'b' |
  | Enter | 0x1C | 0x9C | '\n' |
  | Space | 0x39 | 0xB9 | ' ' |
  | L-Shift | 0x2A | 0xAA | (modifier) |
  | R-Shift | 0x36 | 0xB6 | (modifier) |
  | CapsLock | 0x3A | 0xBA | (toggle) |
  **Extended (0xE0 prefix):**
  | Key | Bytes | Notes |
  |-----|-------|-------|
  | Right Arrow | E0 4D | E0 CD (break) |
  | Left Arrow | E0 4B | E0 CB (break) |
  | NumPad Enter | E0 1C | Different from main Enter |
|| {near: bottom-center}