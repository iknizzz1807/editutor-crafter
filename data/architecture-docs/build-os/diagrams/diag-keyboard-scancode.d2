vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Keyboard Input: Scancode to ASCII Pipeline
  **Data Walk: From Key Press to getchar() Return**
| {near: top-center}

direction: right

hardware: Hardware Layer {
  style.fill: "#E8E8E8"
  style.stroke: "#666666"
  
  keyboard_controller: PS/2 Keyboard Controller (8042) {
    style.fill: "#FFE4B5"
    style.stroke: "#CD853F"
    
    output_buffer: Output Buffer Port 0x60 {
      shape: hexagon
      style.fill: "#FFD700"
    }
    
    status_reg: Status Register Port 0x64 {
      shape: diamond
      style.fill: "#87CEEB"
    }
  }
  
  pic: 8259 PIC {
    style.fill: "#98FB98"
    
    irq1: IRQ1 Line {
      shape: circle
      style.fill: "#FF6B6B"
    }
    
    isr: In-Service Register {
      shape: cylinder
      style.fill: "#DDA0DD"
    }
  }
  
  keyboard_controller.output_buffer -> pic.irq1: "Scancode ready (assert IRQ1)" {
    style.stroke: "#FF6B6B"
    style.stroke-width: 3
    style.animated: true
  }
}

cpu_layer: CPU Interrupt Layer {
  style.fill: "#E6E6FA"
  style.stroke: "#483D8B"
  
  idt: IDT Entry 33 {
    style.fill: "#DDA0DD"
    
    gate: Gate Descriptor {
      shape: class
      offset_low: uint16_t
      selector: 0x08
      type_attr: 0x8E
      offset_high: uint16_t
    }
  }
  
  cpu: CPU {
    style.fill: "#87CEEB"
    
    stack: Kernel Stack {
      shape: cylinder
      style.fill: "#F0F8FF"
      
      eflags: "EFLAGS (pushed)"
      cs: "CS = 0x08 (pushed)"
      eip: "EIP (pushed)"
    }
  }
  
  pic.isr -> cpu: "Vector 33 (INTA cycle)" {
    style.stroke: "#9370DB"
    style.stroke-width: 2
  }
  
  cpu -> idt.gate: "Lookup handler" {
    style.stroke: "#483D8B"
    style.stroke-dash: 3
  }
}

hardware.pic.irq1 -> cpu_layer.cpu: "INTR signal" {
  style.stroke: "#FF0000"
  style.stroke-width: 3
  style.animated: true
}

handler: IRQ1 Handler {
  style.fill: "#F0FFF0"
  style.stroke: "#228B22"
  
  asm_stub: Assembly Stub {
    style.fill: "#98FB98"
    
    pusha: "pusha (EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI)"
    push_ds: "push ds, es, fs, gs"
  }
  
  inb: inb(0x60) {
    shape: circle
    style.fill: "#FFD700"
    style.stroke: "#CD853F"
    style.stroke-width: 2
    label.near: outside-top-center
  }
  
  c_handler: keyboard_handler {
    style.fill: "#90EE90"
    
    scancode_var: uint8_t scancode {
      shape: code
      style.fill: "#F5F5DC"
    }
  }
  
  asm_stub.pusha -> inb: "Read port"
  inb -> c_handler.scancode_var: "0x1E (example: A key)"
}

cpu_layer.idt.gate -> handler.asm_stub: "jmp to handler" {
  style.stroke: "#228B22"
  style.stroke-width: 2
}

hardware.keyboard_controller.output_buffer -> handler.inb: "Port I/O read" {
  style.stroke: "#FFD700"
  style.stroke-width: 2
  style.stroke-dash: 5
}

scancode_logic: Scancode Classification {
  style.fill: "#FFF8DC"
  style.stroke: "#DAA520"
  
  raw_scancode: Raw Scancode {
    shape: diamond
    style.fill: "#FFD700"
  }
  
  bit7_check: "Bit 7 Set? (scancode & 0x80)"
  
  make_code: Make Code (Key Down) {
    style.fill: "#90EE90"
    style.stroke: "#228B22"
    
    example_make: |md
      0x1E = A pressed
      0x2A = Left Shift pressed
      0x36 = Right Shift pressed
    |
  }
  
  break_code: Break Code (Key Up) {
    style.fill: "#FFB6C1"
    style.stroke: "#DC143C"
    
    example_break: |md
      0x9E = A released (0x1E | 0x80)
      0xAA = Left Shift released
      0xB6 = Right Shift released
    |
  }
  
  raw_scancode -> bit7_check
  bit7_check -> make_code: "No (bit 7 = 0)"
  bit7_check -> break_code: "Yes (bit 7 = 1)"
}

handler.c_handler.scancode_var -> scancode_logic.raw_scancode: "Classify"

modifier_state: Modifier State Machine {
  style.fill: "#E6E6FA"
  style.stroke: "#483D8B"
  
  shift_state: Shift State {
    shape: circle
    style.fill: "#DDA0DD"
    
    state_label: "shift_pressed = 0 or 1"
  }
  
  ctrl_state: Ctrl State {
    shape: circle
    style.fill: "#87CEEB"
    
    state_label: "ctrl_pressed = 0 or 1"
  }
  
  shift_down: Shift Key Down {
    shape: diamond
    style.fill: "#98FB98"
  }
  
  shift_up: Shift Key Up {
    shape: diamond
    style.fill: "#FFB6C1"
  }
  
  shift_down -> shift_state: "shift_pressed = 1"
  shift_up -> shift_state: "shift_pressed = 0"
}

scancode_logic.make_code -> modifier_state.shift_down: "0x2A or 0x36"
scancode_logic.break_code -> modifier_state.shift_up: "0xAA or 0xB6"

lookup_table: Scancode to ASCII Lookup {
  style.fill: "#F5F5DC"
  style.stroke: "#8B4513"
  
  normal_table: Normal Table {
    shape: sql_table
    scancode: uint8_t {constraint: primary_key}
    ascii: char
  }
  
  shift_table: Shift Table {
    shape: sql_table
    scancode: uint8_t {constraint: primary_key}
    ascii: char
  }
  
  selector: "shift_pressed ? shift_table : normal_table" {
    shape: diamond
    style.fill: "#DDA0DD"
  }
  
  selector -> normal_table: "0"
  selector -> shift_table: "1"
}

scancode_logic.make_code -> lookup_table.selector: "Non-modifier key"
modifier_state.shift_state -> lookup_table.selector: "Select table"

buffer: Circular Keyboard Buffer {
  style.fill: "#E0FFFF"
  style.stroke: "#008B8B"
  
  buffer_array: char kb_buffer[256] {
    shape: cylinder
    style.fill: "#B0E0E6"
  }
  
  write_ptr: write_pos = 0 {
    shape: circle
    style.fill: "#98FB98"
  }
  
  read_ptr: read_pos = 0 {
    shape: circle
    style.fill: "#FFB6C1"
  }
  
  write_op: Write Operation {
    shape: class
    step1: "kb_buffer[write_pos] = ascii"
    step2: "write_pos = (write_pos + 1) % 256"
    step3: "if (write_pos == read_pos) overflow"
  }
  
  buffer_array -> write_op
  write_ptr -> write_op
}

lookup_table.normal_table -> buffer.write_op: "a"
lookup_table.shift_table -> buffer.write_op: "A"

getchar: keyboard_getchar {
  style.fill: "#F0FFF0"
  style.stroke: "#228B22"
  
  check_empty: "read_pos == write_pos ?" {
    shape: diamond
    style.fill: "#FFE4B5"
  }
  
  hlt_wait: "hlt (wait for interrupt)" {
    shape: circle
    style.fill: "#87CEEB"
  }
  
  read_op: Read Operation {
    shape: class
    style.fill: "#90EE90"
    step1: "char c = kb_buffer[read_pos]"
    step2: "read_pos = (read_pos + 1) % 256"
    step3: "return c"
  }
  
  check_empty -> hlt_wait: "Empty (block)"
  hlt_wait -> check_empty: "Interrupt wake"
  check_empty -> read_op: "Data available"
}

buffer.write_op -> getchar.check_empty: "Buffer updated"
buffer.read_ptr -> getchar.read_op: "Read position"

application: Application {
  style.fill: "#F5F5DC"
  style.stroke: "#8B4513"
  
  user_code: |c
    char c = keyboard_getchar();
    if (c == '\n') {
        process_line();
    } else {
        echo(c);
    }
  |
  
  return_value: Return Value {
    shape: circle
    style.fill: "#90EE90"
    
    value_label: "'a' or 'A' (0x61 or 0x41)"
  }
}

getchar.read_op -> application.return_value: "ASCII char"
application.return_value -> application.user_code: "Process input"

eoi: End of Interrupt {
  style.fill: "#FFE4E1"
  style.stroke: "#DC143C"
  
  eoi_call: pic_send_eoi(1) {
    shape: circle
    style.fill: "#FFB6C1"
  }
  
  iret: iret {
    shape: diamond
    style.fill: "#98FB98"
  }
  
  eoi_call -> iret: "PIC cleared, return from int"
}

handler.c_handler -> eoi.eoi_call: "Handler complete"
eoi.iret -> cpu_layer.cpu: "Resume interrupted code (sti via EFLAGS)"

legend: Legend {
  near: bottom-right
  style.fill: "#F8F8FF"
  style.stroke: "#696969"
  
  data_flow: Data Flow {
    shape: text
    style.fill: transparent
  }
  
  control_flow: Control Flow {
    shape: text
    style.fill: transparent
  }
  
  hardware_io: Hardware I/O {
    shape: text
    style.fill: transparent
  }
  
  interrupt: Interrupt Signal {
    shape: text
    style.fill: transparent
  }
}

timing: Timing Notes {
  near: bottom-left
  style.fill: "#FFFACD"
  style.stroke: "#DAA520"
  
  note: |md
    **Latency Breakdown:**
    - Key press to IRQ1: ~1 us (electrical)
    - IRQ1 to handler: ~2 us (CPU context save)
    - inb(0x60): ~1 us (I/O port read)
    - Scancode to ASCII: ~100 ns (table lookup)
    - Buffer write: ~50 ns (memory store)
    - EOI + iret: ~500 ns
  |
}