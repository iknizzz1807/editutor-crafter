vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    header-bg: "#4A5568"
    free-block: "#48BB78"
    used-block: "#F56565"
    page-frame: "#E2E8F0"
    metadata: "#805AD5"
    arrow-alloc: "#3182CE"
    arrow-free: "#38A169"
  }
}

title: |md
  # kmalloc Internals: Block Headers and Free Lists
  Kernel heap allocator using first-fit with block splitting and coalescing
| {near: top-center}

direction: right

classes: {
  page-frame: {
    style: {
      fill: ${colors.page-frame}
      stroke: "#718096"
      stroke-width: 2
    }
  }
  header: {
    style: {
      fill: ${colors.header-bg}
      font-color: white
      bold: true
      font-size: 14
    }
  }
  free-block: {
    style: {
      fill: ${colors.free-block}
      font-color: white
    }
  }
  used-block: {
    style: {
      fill: ${colors.used-block}
      font-color: white
    }
  }
  metadata: {
    style: {
      fill: ${colors.metadata}
      font-color: white
    }
  }
}

legend: {
  near: top-right
  legend_title: Legend {
    shape: text
    style.font-size: 16
    style.bold: true
  }
  
  free: Free Block {
    class: free-block
  }
  used: Used Block {
    class: used-block
  }
  hdr: Block Header {
    class: header
  }
  pg: Page Frame {
    class: page-frame
  }
}

heap_structure: Heap Virtual Address Space (0xD0000000+) {
  direction: right
  
  page1: Page Frame 0 {
    class: page-frame
    direction: down
    
    p1_header: |md
      **HEADER**
      size: 4064
      free: 1
      next: → Block 2
    | {class: header}
    
    p1_data: User Data\n(4064 bytes) {
      class: free-block
      width: 200
      height: 150
    }
  }
  
  page2: Page Frame 1 {
    class: page-frame
    direction: down
    
    p2_b1: Block 1 (Used) {
      direction: down
      p2_b1_header: |md
        **HEADER**
        size: 256
        free: 0
        next: → Block 2
      | {class: header}
      p2_b1_data: User Data\n(256 bytes) {
        class: used-block
        width: 200
        height: 60
      }
    }
    
    p2_b2: Block 2 (Used) {
      direction: down
      p2_b2_header: |md
        **HEADER**
        size: 512
        free: 0
        next: → Block 3
      | {class: header}
      p2_b2_data: User Data\n(512 bytes) {
        class: used-block
        width: 200
        height: 80
      }
    }
    
    p2_b3: Block 3 (Free) {
      direction: down
      p2_b3_header: |md
        **HEADER**
        size: 3248
        free: 1
        next: → Block 4
      | {class: header}
      p2_b3_data: Available\n(3248 bytes) {
        class: free-block
        width: 200
        height: 100
      }
    }
  }
  
  page3: Page Frame 2 {
    class: page-frame
    direction: down
    
    p3_b1: Block 4 (Used) {
      direction: down
      p3_b1_header: |md
        **HEADER**
        size: 128
        free: 0
        next: NULL
      | {class: header}
      p3_b1_data: User Data {
        class: used-block
        width: 200
        height: 50
      }
    }
    
    p3_b2: Block 5 (Free) {
      direction: down
      p3_b2_header: |md
        **HEADER**
        size: 3952
        free: 1
        next: NULL
      | {class: header}
      p3_b2_data: Available\n(3952 bytes) {
        class: free-block
        width: 200
        height: 120
      }
    }
  }
}

free_list: Free List (Linked via next pointers) {
  direction: right
  style.fill: "#EDF2F7"
  
  fl_head: heap_head {
    class: metadata
    shape: diamond
  }
  
  fl_b1: Block 3 {
    class: free-block
  }
  
  fl_b2: Block 5 {
    class: free-block
  }
  
  fl_head -> fl_b1: next
  fl_b1 -> fl_b2: next
  fl_b2 -> null: next
  
  null: NULL {
    shape: circle
    style.fill: "#CBD5E0"
  }
}

header_layout: Block Header Structure (12 bytes) {
  direction: right
  style.fill: "#EDF2F7"
  
  struct: |md
    c
    typedef struct block_header {
      uint32_t size;    // Payload size
      uint32_t free;    // 1=free, 0=used
      struct block_header *next;
    } block_header_t;
    
  | {
    shape: code
    language: c
  }
  
  memory_layout: Memory Layout {
    direction: right
    grid-columns: 3
    grid-gap: 0
    
    size_field: size (4 bytes) {
      class: header
      width: 80
    }
    free_field: free (4 bytes) {
      class: header
      width: 80
    }
    next_field: next (4 bytes) {
      class: header
      width: 80
    }
    
    offset_0: "offset 0" {
      shape: text
      style.font-size: 10
    }
    offset_4: "offset 4" {
      shape: text
      style.font-size: 10
    }
    offset_8: "offset 8" {
      shape: text
      style.font-size: 10
    }
    
    payload: Payload (user data) {
      class: free-block
      width: 240
    }
  }
}

allocation_flow: kmalloc(size) - Allocation Flow {
  direction: right
  style.fill: "#E6FFFA"
  
  step1: 1. Align size\nto 16 bytes {
    shape: diamond
    class: metadata
  }
  
  step2: 2. Traverse free list\n(first-fit search) {
    shape: rectangle
    class: free-block
  }
  
  step3: 3. Found block?\nsize >= request {
    shape: diamond
    class: metadata
  }
  
  step4a: 4a. Split if\nsize > request + 48 {
    shape: rectangle
    class: used-block
  }
  
  step4b: 4b. Mark free=0\nReturn ptr {
    shape: rectangle
    class: used-block
  }
  
  step5: 5. No fit?\nGrow heap {
    shape: rectangle
    class: page-frame
  }
  
  step1 -> step2
  step2 -> step3
  step3 -> step4a: Yes
  step3 -> step5: No
  step4a -> step4b
}

split_example: Block Splitting Example {
  direction: right
  style.fill: "#FEFCBF"
  
  before: Before (Free Block) {
    direction: down
    before_label: "Request: 128 bytes" {
      shape: text
      style.bold: true
    }
    before_hdr: Header\nsize=512 {
      class: header
      width: 150
    }
    before_data: Free Space\n(512 bytes) {
      class: free-block
      width: 150
      height: 120
    }
  }
  
  arrow: "→" {
    shape: text
    style.font-size: 24
    style.fill: transparent
  }
  
  after: After Split {
    direction: down
    after_label: "Split into 2 blocks" {
      shape: text
      style.bold: true
    }
    
    after_b1: Used Block {
      direction: down
      after_b1_hdr: Header\nsize=128 {
        class: header
        width: 150
      }
      after_b1_data: User Data\n(128 bytes) {
        class: used-block
        width: 150
        height: 60
      }
    }
    
    after_b2: Free Block {
      direction: down
      after_b2_hdr: Header\nsize=360 {
        class: header
        width: 150
      }
      after_b2_data: Remaining\n(360 bytes) {
        class: free-block
        width: 150
        height: 80
      }
    }
    
    after_b1 -> after_b2: next
  }
  
  before -> arrow -> after
}

coalesce_flow: kfree(ptr) - Coalescing {
  direction: right
  style.fill: "#FFF5F5"
  
  c_step1: 1. Find header\n(ptr - 12) {
    shape: rectangle
    class: header
  }
  
  c_step2: 2. Mark free=1 {
    shape: rectangle
    class: free-block
  }
  
  c_step3: 3. Coalesce with\nnext if free {
    shape: diamond
    class: metadata
  }
  
  c_step4: 4. Merge headers\nadd sizes {
    shape: rectangle
    class: free-block
  }
  
  c_step1 -> c_step2 -> c_step3
  c_step3 -> c_step4: Yes
}

coalesce_example: Coalescing Example {
  direction: right
  style.fill: "#FED7E2"
  
  c_before: Before kfree(Block 2) {
    direction: down
    cb_label: "Free Block 1 + Used Block 2 + Free Block 3" {
      shape: text
      style.bold: true
    }
    
    cb_b1: Block 1 (Free)\nsize=256 {
      class: free-block
      width: 100
    }
    cb_b2: Block 2 (Used)\nsize=128 {
      class: used-block
      width: 100
    }
    cb_b3: Block 3 (Free)\nsize=512 {
      class: free-block
      width: 100
    }
    
    cb_b1 -> cb_b2 -> cb_b3
  }
  
  c_arrow: "→" {
    shape: text
    style.font-size: 24
    style.fill: transparent
  }
  
  c_after: After Coalesce {
    direction: down
    ca_label: "Single Free Block" {
      shape: text
      style.bold: true
    }
    
    ca_b1: Block 1 (Free)\nsize=920 {
      class: free-block
      width: 200
      height: 100
    }
    
    ca_note: "256 + 128 + 512 + 24 (headers saved)" {
      shape: text
      style.font-size: 12
    }
  }
  
  c_before -> c_arrow -> c_after
}

page_mapping: Physical to Virtual Mapping {
  direction: right
  style.fill: "#EBF8FF"
  
  pmm: Physical Frame\nAllocator {
    class: page-frame
    shape: cylinder
  }
  
  vmm: Page Table\nMapping {
    class: metadata
    shape: hexagon
  }
  
  heap: Heap Virtual\nAddress {
    class: free-block
  }
  
  pmm -> vmm: "pmm_alloc_frame()\nreturns 0xXYZ000"
  vmm -> heap: "vmm_map_page(\n0xD0001000,\n0xXYZ000)"
}

heap_grow: Heap Growth on Demand {
  direction: right
  
  current: Current Heap End {
    heap_end: 0xD0001000 {
      class: metadata
    }
  }
  
  grow: Grow Request {
    new_page: Allocate + Map\nNew Page Frame {
      class: page-frame
      shape: diamond
    }
  }
  
  new_end: New Heap End {
    heap_new: 0xD0002000 {
      class: metadata
    }
  }
  
  current -> grow -> new_end
}

notes: |md
  ## Key Implementation Details
  
  **Alignment**: All allocations aligned to 16 bytes for performance
  
  **Minimum Block Size**: 48 bytes (header + 32 bytes payload) to avoid tiny fragments
  
  **Header Overhead**: 12 bytes per block (size + free + next pointer)
  
  **First-Fit Policy**: Returns first sufficiently-sized free block (simple but can fragment)
  
  **Coalescing**: Only forward (with next block) - doubly-linked list needed for backward coalescing
  
  **Page Granularity**: Heap grows by full 4KB pages; single allocation cannot span pages
| {near: bottom-center}