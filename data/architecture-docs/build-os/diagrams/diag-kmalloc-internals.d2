vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    header: "#6B5B95"
    free: "#88B04B"
    allocated: "#F7786B"
    metadata: "#034F84"
    boundary: "#92A8D1"
    pointer: "#F4A460"
  }
}

title: |md
  # Kernel Heap Allocator: kmalloc/kfree
| {near: top-center}

direction: right

legend: {
  near: top-right
  legend_free: Free Block {
    style.fill: ${colors.free}
    style.opacity: 0.7
  }
  legend_allocated: Allocated Block {
    style.fill: ${colors.allocated}
    style.opacity: 0.7
  }
  legend_header: Block Header (16B) {
    style.fill: ${colors.header}
    style.fill-pattern: lines
  }
  legend_boundary: Boundary Tag (4B) {
    style.fill: ${colors.boundary}
  }
}

heap_memory: Kernel Heap Memory Layout {
  style.fill: "#F5F5F5"
  style.stroke: "#333"
  
  direction: right
  
  free_list_head: free_list_head\n(ptr to first\nfree block) {
    style.fill: ${colors.pointer}
    shape: hexagon
    width: 100
  }
  
  memory_blocks: {
    grid-columns: 1
    grid-gap: 0
    
    block1: {
      direction: right
      
      b1_header: Header {
        style.fill: ${colors.header}
        width: 80
        
        b1_size: |md
          **size: 256**
          (incl header)
        |
        b1_next: |md
          **next: 0x1080**
        |
        b1_prev: |md
          **prev: NULL**
        |
      }
      
      b1_payload: Payload\n(user data)\n240 bytes {
        style.fill: ${colors.free}
        style.opacity: 0.5
        width: 160
      }
      
      b1_boundary: BT\n0x100 {
        style.fill: ${colors.boundary}
        width: 40
        style.font-size: 10
      }
    }
    
    block2: {
      direction: right
      
      b2_header: Header {
        style.fill: ${colors.allocated}
        width: 80
        
        b2_size: |md
          **size: 128**
        |
        b2_next: |md
          *(unused)*
        |
        b2_prev: |md
          *(unused)*
        |
      }
      
      b2_payload: Payload\n(allocated)\n112 bytes {
        style.fill: ${colors.allocated}
        style.opacity: 0.7
        width: 100
      }
      
      b2_boundary: BT\n0x80 {
        style.fill: ${colors.boundary}
        width: 40
        style.font-size: 10
      }
    }
    
    block3: {
      direction: right
      
      b3_header: Header {
        style.fill: ${colors.header}
        width: 80
        
        b3_size: |md
          **size: 512**
        |
        b3_next: |md
          **next: NULL**
        |
        b3_prev: |md
          **prev: 0x1000**
        |
      }
      
      b3_payload: Payload\n(free)\n496 bytes {
        style.fill: ${colors.free}
        style.opacity: 0.5
        width: 180
      }
      
      b3_boundary: BT\n0x200 {
        style.fill: ${colors.boundary}
        width: 40
        style.font-size: 10
      }
    }
    
    block4: {
      direction: right
      
      b4_header: Header {
        style.fill: ${colors.allocated}
        width: 80
        
        b4_size: |md
          **size: 64**
        |
      }
      
      b4_payload: Payload\n48B {
        style.fill: ${colors.allocated}
        style.opacity: 0.7
        width: 60
      }
      
      b4_boundary: BT\n0x40 {
        style.fill: ${colors.boundary}
        width: 40
        style.font-size: 10
      }
    }
  }
}

free_list_head -> memory_blocks.block1.b1_header: "points to"

block_header_struct: Block Header Structure (16 bytes) {
  style.fill: ${colors.metadata}
  near: top-left
  
  shape: class
  
  +size: uint32
  +flags: uint16
  +magic: uint16
  +next_free: void*
  +prev_free: void*
}

boundary_tag_struct: Boundary Tag (4 bytes) {
  style.fill: ${colors.boundary}
  near: center-left
  
  shape: class
  
  +size: uint32
  +in_use: bit 0
}

kmalloc_flow: kmalloc(size) Flow {
  near: bottom-left
  style.fill: "#E8F4F8"
  
  kmalloc_start: Start {
    shape: circle
    style.fill: ${colors.free}
  }
  
  kmalloc_round: Round up to\n8-byte align {
    style.fill: "#FFF"
  }
  
  kmalloc_search: Walk free list\nfind first fit {
    style.fill: "#FFF"
    style.stroke: ${colors.pointer}
    style.stroke-width: 3
  }
  
  kmalloc_found: Block\nfound?
  
  kmalloc_split: Split block\nif remainder > 32B {
    style.fill: ${colors.free}
    style.opacity: 0.5
  }
  
  kmalloc_remove: Remove from\nfree list {
    style.fill: ${colors.allocated}
    style.opacity: 0.5
  }
  
  kmalloc_return: Return\nptr to payload {
    shape: diamond
    style.fill: ${colors.free}
  }
  
  kmalloc_page: Request pages\nfrom page allocator {
    style.fill: "#FFB7B2"
  }
  
  kmalloc_add: Add new block\nto free list {
    style.fill: ${colors.free}
    style.opacity: 0.5
  }
  
  kmalloc_start -> kmalloc_round
  kmalloc_round -> kmalloc_search
  kmalloc_search -> kmalloc_found
  kmalloc_found -> kmalloc_split: yes
  kmalloc_found -> kmalloc_page: no
  kmalloc_split -> kmalloc_remove
  kmalloc_remove -> kmalloc_return
  kmalloc_page -> kmalloc_add
  kmalloc_add -> kmalloc_search
}

kfree_flow: kfree(ptr) Flow {
  near: bottom-right
  style.fill: "#F8E8E8"
  
  kfree_start: Start {
    shape: circle
    style.fill: ${colors.allocated}
  }
  
  kfree_validate: Validate magic\nand pointers {
    style.fill: "#FFF"
    style.stroke: red
    style.stroke-width: 2
  }
  
  kfree_header: Find header\n(ptr - 16) {
    style.fill: "#FFF"
  }
  
  kfree_prev_block: Check prev block\nboundary tag {
    style.fill: ${colors.boundary}
  }
  
  kfree_prev_free: Prev free?
  
  kfree_coalesce_prev: Coalesce with\nprev block {
    style.fill: ${colors.free}
    style.opacity: 0.5
  }
  
  kfree_next_block: Check next block\nvia size offset {
    style.fill: ${colors.boundary}
  }
  
  kfree_next_free: Next free?
  
  kfree_coalesce_next: Coalesce with\nnext block {
    style.fill: ${colors.free}
    style.opacity: 0.5
  }
  
  kfree_add: Add/update\nin free list {
    style.fill: ${colors.free}
  }
  
  kfree_done: Done {
    shape: diamond
    style.fill: ${colors.free}
  }
  
  kfree_start -> kfree_validate
  kfree_validate -> kfree_header
  kfree_header -> kfree_prev_block
  kfree_prev_block -> kfree_prev_free
  kfree_prev_free -> kfree_coalesce_prev: yes
  kfree_prev_free -> kfree_next_block: no
  kfree_coalesce_prev -> kfree_next_block
  kfree_next_block -> kfree_next_free
  kfree_next_free -> kfree_coalesce_next: yes
  kfree_next_free -> kfree_add: no
  kfree_coalesce_next -> kfree_add
  kfree_add -> kfree_done
}

coalescing_example: Block Coalescing Example {
  near: top-right
  style.fill: "#F0F0F0"
  
  before: Before kfree(B) {
    direction: right
    before_a: A\nfree {
      style.fill: ${colors.free}
      style.opacity: 0.5
    }
    before_b: B\nalloc {
      style.fill: ${colors.allocated}
    }
    before_c: C\nfree {
      style.fill: ${colors.free}
      style.opacity: 0.5
    }
    
    before_a -> before_b
    before_b -> before_c
  }
  
  after: After kfree(B) {
    direction: right
    after_merged: A+B+C\nmerged {
      style.fill: ${colors.free}
      style.opacity: 0.5
      width: 180
    }
  }
  
  before -> after: "kfree(B)\ncoalesces\n3 blocks"
}

page_allocator: Page Allocator Interface {
  near: bottom-center
  style.fill: "#FFE4E1"
  
  alloc_pages: alloc_pages(order) {
    shape: class
    +returns: contiguous pages
    +order: 2^order pages
  }
  
  free_pages: free_pages(addr, order) {
    shape: class
    +addr: page-aligned
  }
  
  alloc_pages -> free_pages: "pair"
}

kmalloc_flow.kmalloc_page -> page_allocator.alloc_pages: "calls when\nfree list\nempty"