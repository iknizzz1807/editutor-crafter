vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Kernel Memory Layout
  ## Linker Script → Physical Memory Mapping
| {near: top-center}
direction: right
classes: {
  header: {
    style: {
      fill: "#2D3748"
      font-color: white
      bold: true
      font-size: 20
    }
  }
  code_section: {
    style: {
      fill: "#4A5568"
      font-color: "#E2E8F0"
      font: mono
    }
  }
  rodata_section: {
    style: {
      fill: "#553C9A"
      font-color: "#E9D8FD"
      font: mono
    }
  }
  data_section: {
    style: {
      fill: "#2C5282"
      font-color: "#BEE3F8"
      font: mono
    }
  }
  bss_section: {
    style: {
      fill: "#744210"
      font-color: "#FEFCBF"
      font: mono
    }
  }
  address_label: {
    style: {
      fill: transparent
      font-color: "#718096"
      font: mono
      font-size: 18
      bold: true
    }
  }
  physical_memory: {
    style: {
      fill: "#1A202C"
      stroke: "#4A5568"
      stroke-width: 3
    }
  }
  note_box: {
    style: {
      fill: "#FFFFF0"
      stroke: "#ECC94B"
      stroke-dash: 3
    }
  }
}
linker_script: Linker Script\n(linker.ld) {
  class: header
  style.fill: "#1A365D"
  entry: |md
    `ENTRY(kernel_entry)`
  | {class: code_section}
  sections: SECTIONS {
    class: code_section
    text_block: .text : {
      class: code_section
      label: |md
        `*(.multiboot)`
        `*(.text)`
      |
    }
    rodata_block: .rodata : {
      class: rodata_section
      label: |md
        `*(.rodata)`
      |
    }
    data_block: .data : {
      class: data_section
      label: |md
        `*(.data)`
      |
    }
    bss_block: .bss : {
      class: bss_section
      label: |md
        `__bss_start = .`
        `*(COMMON)`
        `*(.bss)`
        `__bss_end = .`
      |
    }
    end_marker: _kernel_end = . {
      class: code_section
    }
  }
}
linker_script.sections.text_block -> physical_memory.text_region: "0x100000\n(VMA=LMA)" {
  style.stroke: "#68D391"
  style.stroke-width: 3
}
linker_script.sections.rodata_block -> physical_memory.rodata_region: "4KB aligned" {
  style.stroke: "#B794F4"
  style.stroke-width: 2
  style.stroke-dash: 3
}
linker_script.sections.data_block -> physical_memory.data_region: "4KB aligned" {
  style.stroke: "#63B3ED"
  style.stroke-width: 2
  style.stroke-dash: 3
}
linker_script.sections.bss_block -> physical_memory.bss_region: "4KB aligned" {
  style.stroke: "#F6AD55"
  style.stroke-width: 2
  style.stroke-dash: 3
}
physical_memory: Physical Memory at 0x100000 {
  class: physical_memory
  style.fill: "#0D1117"
  addr_1mb: "0x100000 (1 MB)" {
    class: address_label
    near: outside-left-center
  }
  text_region: .text {
    class: code_section
    label: |md
      **Executable Code**
      `kernel_entry`
      `kernel_main`
      All functions...
    |
    style.fill: "#2D3748"
  }
  rodata_region: .rodata {
    class: rodata_section
    label: |md
      **Read-Only Data**
      String literals
      Constants
      Format strings
    |
  }
  data_region: .data {
    class: data_section
    label: |md
      **Initialized Data**
      Global variables
      Static variables
      With initial values
    |
  }
  bss_region: .bss {
    class: bss_section
    label: |md
      **Uninitialized Data**
      `__bss_start`
      Global `int x;`
      Static buffers
      `__bss_end`
    |
  }
  addr_end: "_kernel_end" {
    class: address_label
    near: outside-left-center
  }
  free_memory: Free Memory {
    style: {
      fill: "#1A202C"
      font-color: "#4A5568"
      stroke-dash: 5
      stroke: "#4A5568"
    }
    label: |md
      Available for:
      • Heap
      • Page tables
      • Kernel stacks
    |
  }
}
bss_zeroing: BSS Zeroing\nWhy Required {
  class: note_box
  near: physical_memory.bss_region
  problem: The Problem {
    style.fill: "#FED7D7"
    shape: rectangle
    label: |md
      **Memory contains garbage!**
      After BIOS operations, RAM at
      BSS addresses contains random
      data from POST, boot, etc.
      Uninitialized globals would
      have random values.
    |
  }
  solution: The Fix {
    style.fill: "#C6F6D5"
    shape: rectangle
    label: |md
      **Zero all BSS bytes**
    |
  }
  problem -> solution: "kernel_entry.asm\nbefore kernel_main()" {
    style.stroke: "#38A169"
    style.stroke-width: 2
    style.animated: true
  }
}
why_1mb: Why 0x100000? {
  near: physical_memory.addr_1mb
  class: note_box
  style.fill: "#EBF8FF"
  reason: |md
    **First 1MB is reserved:**
    | Address | Purpose |
    |---------|---------|
    | 0x000-0x3FF | IVT (256 vectors) |
    | 0x400-0x4FF | BIOS Data Area |
    | 0x500-0x7BFF | Free low memory |
    | 0x7C00-0x7DFF | Bootloader (MBR) |
    | 0x7E00-0x9FFFF | Free / BDA |
    | 0xA000-0xBFFF | VGA Video Memory |
    | 0xC000-0xFFFFF | BIOS ROM |
    **0x100000** = First safe address!
  |
}
section_sizes: Typical Section Sizes {
  near: physical_memory.free_memory
  class: note_box
  style.fill: "#FAF5FF"
  sizes: |md
    | Section | Typical Size | Alignment |
    |---------|--------------|-----------|
    | .text | 16-64 KB | 4 KB |
    | .rodata | 4-16 KB | 4 KB |
    | .data | 4-8 KB | 4 KB |
    | .bss | 8-32 KB | 4 KB |
    **Total kernel**: ~50-120 KB
    Grows with: drivers, features,
    debug symbols (stripped)
  |
}
symbols: Exported Symbols {
  near: linker_script
  class: note_box
  style.fill: "#FFF5F5"
  sym_list: |md
    **Available in C code:**
    c
    extern void* __bss_start;
    extern void* __bss_end;
    extern void* _kernel_end;
    
  |
}
ALIGN_4K: 4KB Page Alignment {
  near: linker_script.sections
  class: note_box
  style.fill: "#F0FFF4"
  align_note: |md
    `ALIGN(4K)` ensures each section
    starts on a page boundary.
    **Why?**
    - Page table permissions work
      per-page, not per-byte
    - .text can be read+execute only
    - .data can be read+write
    - .rodata can be read-only
    Without alignment, a page might
    contain both code AND data,
    preventing proper protection.
  |
}