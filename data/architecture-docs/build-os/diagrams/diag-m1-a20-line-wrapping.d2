vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # A20 Line — Address Wrapping Problem
  **Before/After: A20 Disabled vs Enabled** · Historical IBM PC Backwards-Compatibility Hack
| {near: top-center}
# ─────────────────────────────────────────────────────────────────
# BEFORE panel — A20 DISABLED (wrap-around active)
# ─────────────────────────────────────────────────────────────────
before: A20 DISABLED — 8086 Wrap-Around Behavior {
  style: {
    fill: "#2d1b1b"
    stroke: "#cc3333"
    stroke-width: 3
    border-radius: 8
    font-color: "#ff6666"
    bold: true
  }
  cpu_before: CPU (80286+) {
    style.fill: "#4a2020"
    style.stroke: "#cc3333"
    style.font-color: "#ffaaaa"
    style.bold: true
  }
  addr_calc: |md
    **Address Calculation**
    `CS:IP = 0xFFFF:0x0010`
    `= 0xFFFF × 16 + 0x0010`
    `= 0xFFFF0 + 0x10`
    `= 0x100000` ← bit 20 set!
  | {
    style.fill: "#3d1515"
    style.stroke: "#cc3333"
    style.font-color: "#ffcccc"
  }
  a20_gate_off: A20 GATE (CLOSED) {
    style.fill: "#660000"
    style.stroke: "#ff0000"
    style.stroke-width: 4
    style.font-color: "#ff4444"
    style.bold: true
    style.border-radius: 6
    desc: |md
      **Bit 20 of address bus = FORCED TO 0**
      Hardware AND-gate on A20 line
      controlled by keyboard controller (8042)
    | {
      style.fill: "#550000"
      style.stroke: "#990000"
      style.font-color: "#ffaaaa"
    }
  }
  phys_addr_wrong: Physical Address Bus {
    style.fill: "#3d1515"
    style.stroke: "#cc3333"
    style.font-color: "#ffcccc"
    bit20_masked: |md
      A20 line **MASKED** → bit 20 = 0
      `0x100000` becomes `0x000000`
      20-bit bus: max = `0xFFFFF` (1MB)
    | {
      style.fill: "#4a1010"
      style.stroke: "#ff0000"
      style.font-color: "#ff8888"
      style.bold: true
    }
  }
  mem_before: Physical Memory (DRAM) {
    style.fill: "#2d1b1b"
    style.stroke: "#993333"
    style.font-color: "#ff9999"
    low_mem: |md
      `0x00000000`–`0x0009FFFF`
      Conventional RAM (640 KB)
      ← **WRAP TARGET**
      Write to `0x100000` lands HERE
    | {
      style.fill: "#4a2020"
      style.stroke: "#ff3333"
      style.stroke-width: 3
      style.font-color: "#ffcccc"
      style.bold: true
    }
    bios_area: |md
      `0x000A0000`–`0x000FFFFF`
      VGA, BIOS ROM, EBDA
    | {
      style.fill: "#3a1818"
      style.stroke: "#993333"
      style.font-color: "#ffaaaa"
    }
    above_1mb: |md
      `0x00100000`+
      **INACCESSIBLE** with A20 off
      ← address wraps back to `0x00000`
    | {
      style.fill: "#220d0d"
      style.stroke: "#661111"
      style.stroke-width: 2
      style.stroke-dash: 6
      style.font-color: "#cc6666"
    }
  }
  kernel_load_danger: |md
    ⚠ **SILENT CORRUPTION**
    Kernel loaded at `0x100000` wraps to `0x00000`
    Overwrites BIOS data / conventional RAM
    No error — machine proceeds on corrupt data
    Crash appears far from the actual cause
  | {
    style.fill: "#5a0000"
    style.stroke: "#ff2222"
    style.stroke-width: 3
    style.font-color: "#ffaaaa"
    style.bold: true
    style.border-radius: 6
  }
  cpu_before -> addr_calc: "computes address\n`CS×16 + offset`" {
    style.stroke: "#cc6666"
    style.font-color: "#ffaaaa"
  }
  addr_calc -> a20_gate_off: "A20 line (bit 20 = 1)\nhits the gate" {
    style.stroke: "#ff4444"
    style.stroke-width: 3
    style.animated: true
    style.font-color: "#ff8888"
  }
  a20_gate_off -> phys_addr_wrong: "bit 20 ZEROED\nwrap-around applied" {
    style.stroke: "#ff0000"
    style.stroke-width: 3
    style.font-color: "#ff6666"
    style.bold: true
  }
  phys_addr_wrong -> mem_before.low_mem: "`0x100000` → `0x00000`\nreads/writes low memory!" {
    style.stroke: "#ff2222"
    style.stroke-width: 4
    style.animated: true
    style.font-color: "#ff6666"
    style.bold: true
  }
  mem_before.low_mem -> kernel_load_danger: "corruption detected\nmuch later (or never)" {
    style.stroke: "#cc3333"
    style.stroke-dash: 5
    style.font-color: "#ff8888"
  }
}
# ─────────────────────────────────────────────────────────────────
# AFTER panel — A20 ENABLED (correct addressing)
# ─────────────────────────────────────────────────────────────────
after: A20 ENABLED — Full Physical Addressing {
  style: {
    fill: "#1b2d1b"
    stroke: "#33cc33"
    stroke-width: 3
    border-radius: 8
    font-color: "#66ff66"
    bold: true
  }
  cpu_after: CPU (80286+) {
    style.fill: "#204a20"
    style.stroke: "#33cc33"
    style.font-color: "#aaffaa"
    style.bold: true
  }
  addr_calc_ok: |md
    **Address Calculation**
    `CS:IP = 0xFFFF:0x0010`
    `= 0x100000` ← bit 20 set
    **This time: bit 20 PASSES THROUGH**
  | {
    style.fill: "#152d15"
    style.stroke: "#33cc33"
    style.font-color: "#ccffcc"
  }
  a20_gate_on: A20 GATE (OPEN) {
    style.fill: "#004d00"
    style.stroke: "#00ff00"
    style.stroke-width: 4
    style.font-color: "#44ff44"
    style.bold: true
    style.border-radius: 6
    desc: |md
      **Bit 20 passes through unmodified**
      A20 line asserted by one of 3 methods
      32-bit address bus fully functional
    | {
      style.fill: "#003300"
      style.stroke: "#006600"
      style.font-color: "#aaffaa"
    }
  }
  phys_addr_ok: Physical Address Bus (32-bit) {
    style.fill: "#152d15"
    style.stroke: "#33cc33"
    style.font-color: "#ccffcc"
    bit20_live: |md
      A20 line **LIVE** → bit 20 intact
      `0x100000` = `0x100000` ✓
      Addresses `0x00000`–`0xFFFFFFFF` accessible
    | {
      style.fill: "#1a4a1a"
      style.stroke: "#00cc00"
      style.font-color: "#88ff88"
      style.bold: true
    }
  }
  mem_after: Physical Memory (DRAM) {
    style.fill: "#1b2d1b"
    style.stroke: "#339933"
    style.font-color: "#99ff99"
    low_mem_ok: |md
      `0x00000000`–`0x0009FFFF`
      Conventional RAM (640 KB)
      Safe — kernel does NOT land here
    | {
      style.fill: "#204220"
      style.stroke: "#339933"
      style.font-color: "#ccffcc"
    }
    bios_area_ok: |md
      `0x000A0000`–`0x000FFFFF`
      VGA (`0xB8000`), BIOS ROM, EBDA
    | {
      style.fill: "#1a381a"
      style.stroke: "#336633"
      style.font-color: "#aaffaa"
    }
    high_mem: |md
      `0x00100000`–`0x07FFFFFF`
      **Extended Memory — ACCESSIBLE**
      Kernel loads here safely ✓
      (127 MB usable on 128 MB system)
    | {
      style.fill: "#1f4d1f"
      style.stroke: "#00cc00"
      style.stroke-width: 3
      style.font-color: "#88ff88"
      style.bold: true
    }
  }
  kernel_load_ok: |md
    ✓ **CORRECT OPERATION**
    Kernel at `0x100000` reaches extended RAM
    No overlap with BIOS / conventional memory
    Protected-mode setup proceeds safely
  | {
    style.fill: "#004400"
    style.stroke: "#00ff44"
    style.stroke-width: 3
    style.font-color: "#aaffaa"
    style.bold: true
    style.border-radius: 6
  }
  cpu_after -> addr_calc_ok: "computes address\n`CS×16 + offset`" {
    style.stroke: "#66cc66"
    style.font-color: "#aaffaa"
  }
  addr_calc_ok -> a20_gate_on: "A20 line (bit 20 = 1)\ngate is open" {
    style.stroke: "#00ff44"
    style.stroke-width: 3
    style.animated: true
    style.font-color: "#88ff88"
  }
  a20_gate_on -> phys_addr_ok: "bit 20 PRESERVED\nfull 32-bit address" {
    style.stroke: "#00cc00"
    style.stroke-width: 3
    style.font-color: "#66ff66"
    style.bold: true
  }
  phys_addr_ok -> mem_after.high_mem: "`0x100000` reaches\nextended RAM ✓" {
    style.stroke: "#00ff22"
    style.stroke-width: 4
    style.animated: true
    style.font-color: "#66ff66"
    style.bold: true
  }
  mem_after.high_mem -> kernel_load_ok: "kernel loads safely\nno corruption" {
    style.stroke: "#33cc33"
    style.font-color: "#99ff99"
  }
}
# ─────────────────────────────────────────────────────────────────
# The three A20 enable methods
# ─────────────────────────────────────────────────────────────────
methods: Three A20 Enable Methods (try in order) {
  style: {
    fill: "#1b1b2d"
    stroke: "#6666cc"
    stroke-width: 3
    border-radius: 8
    font-color: "#aaaaff"
    bold: true
  }
  method1: Method 1 — BIOS INT 15h/0x2401 {
    style.fill: "#252540"
    style.stroke: "#9999ff"
    style.stroke-width: 2
    style.font-color: "#ccccff"
    style.border-radius: 6
    code1: |asm
      ; Cleanest — call BEFORE entering protected mode
      mov ax, 0x2401    ; function: enable A20
      int 0x15          ; BIOS call
      jc  a20_failed    ; CF=1 on error (not all BIOSes support)
      ; On success: A20 is now enabled
    | {
      style.fill: "#1a1a35"
      style.stroke: "#6666aa"
      style.font-color: "#aaaaee"
    }
    props1: |md
      **Reliability:** Medium — not all BIOSes implement it
      **Speed:** Fast (single BIOS call)
      **When:** Real mode only, before protected mode switch
      **Error detection:** Carry flag set on failure
    | {
      style.fill: "#1e1e3a"
      style.stroke: "#555588"
      style.font-color: "#9999dd"
    }
  }
  method2: Method 2 — Fast A20 (Port 0x92) {
    style.fill: "#252540"
    style.stroke: "#9999ff"
    style.stroke-width: 2
    style.font-color: "#ccccff"
    style.border-radius: 6
    code2: |asm
      ; PS/2 fast gate — supported on most modern systems
      in   al, 0x92       ; read System Control Port A
      or   al, 0x02       ; set bit 1 = A20 enable
      and  al, 0xFE       ; MUST clear bit 0 — prevents CPU RESET!
      out  0x92, al       ; write back
      ; A20 should now be active
    | {
      style.fill: "#1a1a35"
      style.stroke: "#6666aa"
      style.font-color: "#aaaaee"
    }
    props2: |md
      **Reliability:** High on modern hardware
      **Speed:** Very fast (2 port I/O ops, ~200ns)
      **Warning:** Bit 0 = RESET line — never set it!
      **Origin:** IBM PS/2 "fast gate A20" extension
    | {
      style.fill: "#1e1e3a"
      style.stroke: "#555588"
      style.font-color: "#9999dd"
    }
  }
  method3: Method 3 — Keyboard Controller (8042) {
    style.fill: "#252540"
    style.stroke: "#9999ff"
    style.stroke-width: 2
    style.font-color: "#ccccff"
    style.border-radius: 6
    code3: |asm
      ; Most reliable but verbose — uses the 8042 PS/2 controller
      ; The 8042 controls the A20 line on legacy hardware
      call wait_kbd_cmd
      mov  al, 0xAD     ; disable keyboard (avoid conflicts)
      out  0x64, al
      call wait_kbd_cmd
      mov  al, 0xD0     ; read output port
      out  0x64, al
      call wait_kbd_data
      in   al, 0x60     ; get current output port value
      push ax
      call wait_kbd_cmd
      mov  al, 0xD1     ; write output port
      out  0x64, al
      call wait_kbd_cmd
      pop  ax
      or   al, 0x02     ; set A20 bit (bit 1 of output port)
      out  0x60, al
      call wait_kbd_cmd
      mov  al, 0xAE     ; re-enable keyboard
      out  0x64, al
    | {
      style.fill: "#1a1a35"
      style.stroke: "#6666aa"
      style.font-color: "#aaaaee"
    }
    props3: |md
      **Reliability:** Highest — works on all hardware since AT
      **Speed:** Slow (~100μs, poll keyboard status register)
      **History:** Original IBM AT method (1984)
      **Ports:** 0x60=KBD data, 0x64=KBD command/status
      **Why KBD?** IBM routed A20 through 8042 to save chip count
    | {
      style.fill: "#1e1e3a"
      style.stroke: "#555588"
      style.font-color: "#9999dd"
    }
    wait_detail: |md
      **wait_kbd_cmd:** poll 0x64 until bit 1 = 0 (input buffer empty)
      **wait_kbd_data:** poll 0x64 until bit 0 = 1 (output buffer full)
      Required: 8042 runs at 8MHz — CPU writes faster than it processes
    | {
      style.fill: "#151530"
      style.stroke: "#444466"
      style.font-color: "#8888bb"
    }
  }
  verify: A20 Verification Test {
    style.fill: "#202040"
    style.stroke: "#8888cc"
    style.stroke-width: 2
    style.font-color: "#bbbbff"
    style.border-radius: 6
    vcode: |asm
      ; Write sentinel to 0x0000:0x07DFE (just below MBR)
      ; Check if same value appears at 0x0000:0x17FFE (= 0x07DFE + 0x10000)
      ; If A20 off: wrap makes them the SAME address → sentinel echoes
      ; If A20 on:  different physical addresses → values differ
      mov  word [0x7DFE], 0x1234  ; write sentinel to low address
      mov  ax, [0x17FFE]          ; read from +64KB (wraps if A20 off)
      cmp  ax, 0x1234
      je   a20_still_disabled     ; equal = wrap-around = A20 off
      ; Not equal: A20 is enabled ✓
    | {
      style.fill: "#1a1a35"
      style.stroke: "#6666aa"
      style.font-color: "#aaaaee"
    }
  }
  priority: |md
    **Recommended Boot Strategy:**
    1. Try BIOS INT 15h/0x2401 → check carry flag
    2. If failed: try fast A20 port 0x92
    3. If failed: use keyboard controller (8042) method
    4. After each attempt: run verification test
    5. If all fail: halt with error (system too old/broken)
  | {
    style.fill: "#1e1e40"
    style.stroke: "#7777cc"
    style.stroke-width: 2
    style.font-color: "#aaaaff"
    style.bold: true
    style.border-radius: 6
  }
}
# ─────────────────────────────────────────────────────────────────
# Historical context node
# ─────────────────────────────────────────────────────────────────
history: Historical Root Cause {
  style: {
    fill: "#2d2d1b"
    stroke: "#aaaa33"
    stroke-width: 2
    border-radius: 8
    font-color: "#ffffaa"
  }
  intel8086: |md
    **Intel 8086 (1978):** 20-bit address bus → max 1MB (`0x00000`–`0xFFFFF`)
    Some programs used segment wrap-around behavior (`0xFFFF:0x0010` → `0x00000`) intentionally
  | {
    style.fill: "#3d3d15"
    style.stroke: "#aaaa33"
    style.font-color: "#ffffcc"
  }
  ibm_at: |md
    **IBM AT (1984) / Intel 80286:** 24-bit address bus → 16MB
    `0xFFFF:0x0010` now → `0x100000` (actual high memory, NOT wrap)
    Programs relying on 8086 wrap broke → IBM needed compatibility fix
  | {
    style.fill: "#3d3d15"
    style.stroke: "#aaaa33"
    style.font-color: "#ffffcc"
  }
  ibm_solution: |md
    **IBM's hack:** Route address line A20 through the Intel 8042 keyboard controller
    Default: A20 DISABLED (forces wrap, 8086 compatible)
    OS must explicitly ENABLE A20 to access memory above 1MB
    This "temporary" workaround persisted for 40+ years
  | {
    style.fill: "#4a4a10"
    style.stroke: "#cccc22"
    style.stroke-width: 3
    style.font-color: "#ffff88"
    style.bold: true
  }
  intel8086 -> ibm_at: "24-bit bus breaks\n8086 wrap compatibility" {
    style.stroke: "#aaaa33"
    style.font-color: "#cccc88"
  }
  ibm_at -> ibm_solution: "IBM routes A20\nthrough 8042 as gate" {
    style.stroke: "#cccc33"
    style.font-color: "#eeee88"
  }
}
# ─────────────────────────────────────────────────────────────────
# Cross-panel connections
# ─────────────────────────────────────────────────────────────────
before -> after: "A20 ENABLED\n(any of 3 methods)" {
  style.stroke: "#ffaa00"
  style.stroke-width: 4
  style.bold: true
  style.font-color: "#ffcc44"
  style.animated: true
}
history -> before: "root cause:\nIBM AT backwards\ncompat decision" {
  style.stroke: "#aaaa44"
  style.stroke-dash: 4
  style.font-color: "#cccc66"
}
methods -> after: "one of these\nmethods enables A20" {
  style.stroke: "#6666cc"
  style.stroke-dash: 3
  style.font-color: "#9999dd"
}
methods.method1 -> methods.method2: "try next if\ncarry flag set" {
  style.stroke: "#7777aa"
  style.stroke-dash: 4
  style.font-color: "#9999cc"
}
methods.method2 -> methods.method3: "try next if\nunsupported" {
  style.stroke: "#7777aa"
  style.stroke-dash: 4
  style.font-color: "#9999cc"
}
methods.method3 -> methods.verify: "always verify\nafter any method" {
  style.stroke: "#7777aa"
  style.font-color: "#9999cc"
}