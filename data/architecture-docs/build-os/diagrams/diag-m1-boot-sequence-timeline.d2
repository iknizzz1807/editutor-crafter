vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: down
title: |md
  # x86 Boot Sequence â€” BIOS to C Entry Point
  **Power-on â†’ Protected Mode â†’ kernel_main()**
| {near: top-center}
legend: {
  near: bottom-left
  label: Legend
  style: {
    fill: "#1a1a2e"
    stroke: "#444466"
    font-color: white
    border-radius: 8
  }
  l_real: |md
    ðŸŸ¡ **Real Mode** â€” 16-bit, 20-bit addr, no protection
  |
  l_real.style.fill: "#2a2a00"
  l_real.style.stroke: "#888800"
  l_prot: |md
    ðŸ”µ **Protected Mode** â€” 32-bit, segmented, hardware rings
  |
  l_prot.style.fill: "#001a2a"
  l_prot.style.stroke: "#0088cc"
  l_danger: |md
    ðŸ”´ **Skip = Triple Fault / Silent Corruption**
  |
  l_danger.style.fill: "#2a0000"
  l_danger.style.stroke: "#cc0000"
  l_asm: |md
    âš™ï¸ **Assembly Required** â€” C cannot express this
  |
  l_asm.style.fill: "#1a001a"
  l_asm.style.stroke: "#880088"
}
phase0: "PHASE 0 â€” POWER ON" {
  style: {
    fill: "#0d0d1a"
    stroke: "#333366"
    font-color: "#aaaaff"
    bold: true
    border-radius: 6
  }
  p0_reset: "CPU Reset Vector" {
    style: {
      fill: "#1a1a3a"
      stroke: "#4444aa"
      font-color: white
    }
    label: |md
      **EIP = 0xFFFFFFF0**
      CS base = 0xFFFF0000 (hidden descriptor cache)
      Physical: 0xFFFFFFF0 â†’ BIOS ROM
      Mode: Real (16-bit registers, 20-bit addr bus)
      Address width: **20-bit** (A20 forced low)
    |
  }
  p0_post: "BIOS POST" {
    style: {
      fill: "#1a1a3a"
      stroke: "#4444aa"
      font-color: white
    }
    label: |md
      Power-On Self-Test
      â–¸ RAM size test (writes/reads all DRAM)
      â–¸ Enumerates PCI devices
      â–¸ Initializes VGA (text mode 80x25)
      â–¸ Builds Interrupt Vector Table @ 0x00000
        IVT: 256 x 4-byte real-mode far pointers
        INT 0x10 â†’ video  INT 0x13 â†’ disk
      â–¸ Queries memory map (CMOS, E820 prep)
      Skip: No IVT = INT 0x13 disk reads crash
    |
  }
  p0_bootscan: "BIOS Boot Device Scan" {
    style: {
      fill: "#1a1a3a"
      stroke: "#4444aa"
      font-color: white
    }
    label: |md
      For each device in boot order:
        Read LBA 0 â†’ 512 bytes into buffer
        Check bytes [510:511] == 0x55, 0xAA ?
        YES â†’ copy to 0x7C00, JMP 0x0000:0x7C00
        NO  â†’ try next device
      Drive number in DL (0x80 = HDD #0)
      Skip: Never jumps to MBR â†’ machine sits idle
    |
  }
  p0_reset -> p0_post: "POST begins\nCS:EIP = 0xF000:0xFFF0"
  p0_post -> p0_bootscan: "Hardware initialized\nIVT @ 0x00000 ready"
}
phase1: "PHASE 1 â€” MBR STAGE-1 BOOTLOADER (512 bytes)" {
  style: {
    fill: "#1a1100"
    stroke: "#886600"
    font-color: "#ffcc44"
    bold: true
    border-radius: 6
  }
  p1_mbr_entry: "MBR Entry @ 0x7C00" {
    style: {
      fill: "#2a1a00"
      stroke: "#aa8800"
      font-color: white
    }
    label: |md
      **Physical: 0x00007C00**
      Mode: Real (16-bit)  Addr: 20-bit
      CPU: 8086-compatible, seg x 16 + off
      DS=ES=SS=0x0000, SP=0x7C00 (grows downward)
      DL = boot drive number (from BIOS)
      IMMEDIATE SETUP:
        cli              ; no interrupts yet
        xor ax, ax
        mov ds, ax       ; DS = 0
        mov ss, ax       ; SS = 0
        mov sp, 0x7C00   ; stack below MBR
        sti
      Skip segment init: DS garbage â†’
        any data access â†’ wrong address
    |
  }
  p1_a20_check: "A20 Enable" {
    style: {
      fill: "#3a0a0a"
      stroke: "#cc4400"
      font-color: white
    }
    label: |md
      **THE 40-YEAR HACK**
      Problem: 8086 wraps at 0xFFFFF+1 â†’ 0x00000
      286+ has A20 line gated by keyboard ctrl
      Default: A20 disabled (wrap preserved)
      Test first:
        Write val to 0x7DFE
        Read from 0x17FFE (= 0x7DFE + 0x10000)
        Same? A20 disabled. Different? A20 on.
      Method 1 (BIOS):  INT 15h / AX=0x2401
      Method 2 (Fast):  IN 0x92; OR AL,0x02; OUT 0x92,AL
      Method 3 (8042):  Full keyboard controller sequence
      **SKIP = CATASTROPHIC**
      Kernel loaded at 0x100000 physically
      Without A20: 0x100000 wraps â†’ 0x00000
      Kernel load silently overwrites IVT!
    |
  }
  p1_disk_read: "Stage-2 Load via INT 13h" {
    style: {
      fill: "#2a1a00"
      stroke: "#aa8800"
      font-color: white
    }
    label: |md
      BIOS INT 13h Extended Read (AH=0x42)
      Uses Disk Address Packet (DAP):
      DAP offsets:
      +0x00  db 0x10     ; DAP size = 16 bytes
      +0x01  db 0        ; reserved
      +0x02  dw 8        ; sectors to read
      +0x04  dw 0x0000   ; dest offset
      +0x06  dw 0x07E0   ; dest segment â†’ 0x7E00
      +0x08  dd 1        ; LBA start (sector 2)
      +0x0C  dd 0        ; LBA high
      MOV SI, DAP_ptr
      MOV AH, 0x42
      MOV DL, 0x80       ; drive
      INT 0x13
      JC  disk_error     ; CF=1 on error
      Result: Stage-2 loaded at 0x7E00 (4 KB)
    |
  }
  p1_jump_stage2: "JMP to Stage-2" {
    style: {
      fill: "#2a1a00"
      stroke: "#aa8800"
      font-color: white
    }
    label: |md
      JMP 0x0000:0x7E00
      Far jump: CS=0x0000, IP=0x7E00
      Physical: 0x7E00
      Mode: Still Real (16-bit)
      Stage-1 is done. 510 bytes consumed.
      Bytes [510:511] = 0x55, 0xAA (boot sig)
      Skip sig: BIOS never loads MBR â†’ nothing
    |
  }
  p1_mbr_entry -> p1_a20_check: "Stack ready\nDL = drive#"
  p1_a20_check -> p1_disk_read: "A20 confirmed active\n0x100000 accessible"
  p1_disk_read -> p1_jump_stage2: "8 sectors loaded\nStage-2 @ 0x7E00"
}
phase2: "PHASE 2 â€” STAGE-2 LOADER (4 KB, Real Mode â†’ Protected Mode)" {
  style: {
    fill: "#001a00"
    stroke: "#006600"
    font-color: "#44ff44"
    bold: true
    border-radius: 6
  }
  p2_kernel_load: "Kernel Load via INT 13h" {
    style: {
      fill: "#001a00"
      stroke: "#008800"
      font-color: white
    }
    label: |md
      Load kernel from sectors 10-73 (32 KB)
      Destination: 0x10000 (seg 0x1000:0000)
      Physical: 0x10000 â†’ BELOW 1MB (safe in RM)
      DAP: sectors=64, LBA=10, dest=0x1000:0000
      INT 13h / AH=0x42 again (extended read)
      WHY NOT 0x100000 directly?
      Real mode max segment = 0xFFFF
      Max physical = 0xFFFF x 16 + 0xFFFF = 0x10FFEF
      0x100000 reachable only with A20 + unreal
      Simpler: load low, copy after pmode entry
      Skip: kernel not in RAM â†’
            JMP to 0x100000 faults immediately
    |
  }
  p2_e820: "E820 Memory Map Query" {
    style: {
      fill: "#001a00"
      stroke: "#008800"
      font-color: white
    }
    label: |md
      **MUST HAPPEN BEFORE PROTECTED MODE**
      BIOS INT 15h / EAX=0xE820
      Call loop:
        MOV EAX, 0xE820
        MOV EBX, 0          ; continuation = 0
        MOV ECX, 24         ; entry size
        MOV EDX, 0x534D4150 ; magic "SMAP"
        MOV DI, buffer      ; dest
        INT 0x15
        JC done             ; CF=1 â†’ list complete
        CMP EBX, 0
        JE done
      Each entry: base(8B), len(8B), type(4B)
      Type 1=Usable, 2=Reserved, 3=ACPI, 5=Bad
      Store results in low memory (less than 0x90000)
      Skip: PMM has no memory map â†’
            may allocate reserved/MMIO frames â†’
            silent memory corruption
    |
  }
  p2_gdt_build: "GDT Construction" {
    style: {
      fill: "#001a00"
      stroke: "#008800"
      font-color: white
    }
    label: |md
      Build GDT table in DATA segment (real mode)
      GDT physically at e.g. 0x0800:0x0000
      Entry layout (8 bytes each):
      [0] Null descriptor         : 8 x 0x00
      [1] Kernel code  0x9A/0xCF : base=0 lim=4GB R0 exec
      [2] Kernel data  0x92/0xCF : base=0 lim=4GB R0 rw
      [3] User code    0xFA/0xCF : base=0 lim=4GB R3 exec
      [4] User data    0xF2/0xCF : base=0 lim=4GB R3 rw
      Access byte 0x9A: P=1 DPL=00 S=1 E=1 C=0 R=1 A=0
      Flags nibble 0xCF: G=1(4KB gran) D=1(32-bit) L=0
      GDTR structure (6 bytes):
        [0..1] limit = sizeof(GDT)-1 = 39
        [2..5] base  = physical addr of GDT
      Skip GDT: LGDT with null GDTR â†’ CR0.PE set â†’
        every seg access = #GP â†’ triple fault â†’ reset
    |
  }
  p2_kernel_load -> p2_e820: "Kernel in RAM\nat 0x10000"
  p2_e820 -> p2_gdt_build: "Memory map stored\nin low memory"
}
phase3: "PHASE 3 â€” PROTECTED MODE ENTRY (The Point of No Return)" {
  style: {
    fill: "#1a0020"
    stroke: "#660088"
    font-color: "#cc88ff"
    bold: true
    border-radius: 6
  }
  p3_cli: "CLI â€” Disable Interrupts" {
    style: {
      fill: "#2a0030"
      stroke: "#8800aa"
      font-color: white
    }
    label: |md
      **CLI**  ; clear EFLAGS.IF
      WHY: After LGDT, IVT at 0x0000 is invalid.
      If interrupt fires between LGDT and LIDT:
        CPU sees IVT entries as IDT gates (wrong format)
        Real-mode far ptr != protected-mode gate descriptor
        CPU fetches garbage handler address
        Immediate #GP â†’ double fault â†’ triple fault
      Interrupts STAY disabled until LIDT + STI
      in kernel_main (Milestone 2).
      Skip: timing-dependent random crash.
      Worst kind of bug: non-deterministic.
    |
  }
  p3_lgdt: "LGDT â€” Load GDT Register" {
    style: {
      fill: "#2a0030"
      stroke: "#8800aa"
      font-color: white
    }
    label: |md
      **LGDT [gdtr_ptr]**
      gdtr_ptr: 6-byte structure { limit16, base32 }
      CPU action:
        GDTR.limit â† [gdtr_ptr+0..1]
        GDTR.base  â† [gdtr_ptr+2..5]
      After LGDT: GDT is registered but NOT active.
      Protected mode not entered yet (CR0.PE=0).
      Segment registers still hold real-mode values.
      CPU still interprets memory as real mode.
      Important: base must be PHYSICAL address.
      Skip: CR0.PE=1 with GDTR.base=0 â†’
            CPU walks null GDT â†’
            every selector = invalid descriptor â†’
            immediate #GP â†’ triple fault
    |
  }
  p3_cr0: "Set CR0.PE (Bit 0)" {
    style: {
      fill: "#3a0040"
      stroke: "#aa0088"
      font-color: white
    }
    label: |md
      **Assembly REQUIRED â€” Cannot be done in C**
      MOV EAX, CR0
      OR  EAX, 0x01    ; set PE (Protection Enable)
      MOV CR0, EAX     ; Protected Mode NOW ACTIVE
      What changes INSTANTLY:
      â–¸ Every memory access now goes through GDT lookup
      â–¸ CS still holds 0x0000 (real-mode value)
        BUT CPU now treats it as a selector index
        Index 0 = null descriptor â†’ #GP on code fetch
      â–¸ Instruction already in pipeline executes,
        but CS validation is broken
      PIPELINE HAZARD:
      CPU prefetch queue may hold instructions
      decoded with real-mode CS semantics.
      Protected-mode execution unit is now active.
      THE FAR JUMP IS MANDATORY (next step).
      Skip far jump: next instruction â†’ #GP â†’ reset.
    |
  }
  p3_far_jump: "Far Jump â†’ Flush Pipeline + Load CS" {
    style: {
      fill: "#3a0040"
      stroke: "#aa0088"
      font-color: white
    }
    label: |md
      **JMP 0x08:protected_entry**
      Selector 0x08 = GDT[1] = kernel code (ring 0)
      This single instruction atomically:
      1. Validates selector 0x08 against GDT[1]
         DPL=0, present=1, type=code â†’ OK
      2. Loads CS descriptor cache:
         base=0, limit=0xFFFFFFFF, DPL=0, 32-bit
      3. Loads EIP = physical addr of protected_entry
      4. FLUSHES the prefetch queue
         All partially-decoded real-mode instructions
         are discarded. Fresh 32-bit decode begins.
      5. CPL = CS.RPL = 0 (ring 0)
      WHY FAR (not near)?
      Near jump only changes EIP.
      Far jump changes CS AND EIP atomically.
      Only far jump can load a new segment selector.
      After this: CPU is fully in 32-bit protected mode.
      Skip: #GP on very next instruction â†’ reset
    |
  }
  p3_cli -> p3_lgdt: "IF=0\nno spurious interrupts"
  p3_lgdt -> p3_cr0: "GDTR loaded\nGDT registered"
  p3_cr0 -> p3_far_jump: "CR0.PE=1\nprotected mode on\n(CS still invalid!)"
}
phase4: "PHASE 4 â€” SEGMENT REGISTER RELOAD + 32-BIT STACK" {
  style: {
    fill: "#001a1a"
    stroke: "#006688"
    font-color: "#44ccff"
    bold: true
    border-radius: 6
  }
  p4_segreload: "Reload DS / ES / SS / FS / GS" {
    style: {
      fill: "#002030"
      stroke: "#008899"
      font-color: white
    }
    label: |md
      **Assembly â€” Every segment reg must be reset**
      After far jump: CS = 0x08 (kernel code, ring 0)
      But DS, ES, SS, FS, GS still hold 0x0000
      In protected mode 0x0000 = null selector â†’ #GP
      on any data access.
      protected_entry:
      [BITS 32]
        MOV AX, 0x10    ; GDT[2] = kernel data selector
        MOV DS, AX      ; data segment
        MOV ES, AX      ; extra segment
        MOV FS, AX      ; FS (general purpose)
        MOV GS, AX      ; GS (general purpose / TLS later)
        MOV SS, AX      ; stack segment
      Selector 0x10 = index 2, TI=0, RPL=0
      Index 2 in GDT = kernel data descriptor:
        base=0, limit=4GB, DPL=0, writable, present
      Each MOV to segment reg:
        CPU validates selector against GDT
        Loads 8-byte descriptor into hidden cache
        No GDT read per access (only on reload)
      Skip any segment: first use of that seg â†’ #GP
      Skip SS: immediate crash on next PUSH/POP
    |
  }
  p4_stack: "32-bit Stack Setup" {
    style: {
      fill: "#002030"
      stroke: "#008899"
      font-color: white
    }
    label: |md
      MOV ESP, 0x0009FC00
      (Just below EBDA â€” Extended BIOS Data Area)
      EBDA starts at 0x9FC00 on most systems.
      Stack grows DOWNWARD from 0x9FC00.
      Safe range: 0x7E00+stage2_size to 0x9FC00
      ~100 KB of stack space available.
      WHY BEFORE C:
      C calling convention uses PUSH/POP/CALL/RET
      All require a valid SS:ESP.
      First PUSH with old real-mode SS (null in PM)
      â†’ #SS (stack fault) â†’ #DF â†’ triple fault
      After this: 32-bit stack fully operational.
    |
  }
  p4_segreload -> p4_stack: "All segments valid\nflat memory model active"
}
phase5: "PHASE 5 â€” KERNEL ENTRY POINT (Assembly Stub)" {
  style: {
    fill: "#1a0a00"
    stroke: "#884400"
    font-color: "#ffaa44"
    bold: true
    border-radius: 6
  }
  p5_copy_high: "Copy Kernel to 0x100000" {
    style: {
      fill: "#2a1000"
      stroke: "#996600"
      font-color: white
    }
    label: |md
      REP MOVSD  (32-bit word copy)
      ESI = 0x10000    ; source (loaded by stage-2)
      EDI = 0x100000   ; dest   (1MB mark)
      ECX = kernel_size / 4
      WHY 0x100000?
      Below 0xA0000: conventional memory (fragile)
      0xA0000-0xFFFFF: VGA/ROM/BIOS reserved
      0x100000+: high memory, safe, large, contiguous
      Kernel linked at VMA 0xC0100000 (M3) but
      LMA = 0x00100000 for initial load.
      A20 must be enabled for this copy to work.
      Without A20: writes to 0x100000 wrap â†’ 0x0.
      After copy: kernel binary at physical 0x100000.
    |
  }
  p5_bss_zero: "BSS Section Zero" {
    style: {
      fill: "#2a1000"
      stroke: "#996600"
      font-color: white
    }
    label: |md
      **MANDATORY â€” No CRT0 in freestanding kernel**
      EXTERN __bss_start   ; from linker script
      EXTERN __bss_end     ; from linker script
      MOV EDI, __bss_start
      MOV ECX, __bss_end
      SUB ECX, EDI         ; bytes to zero
      XOR EAX, EAX
      REP STOSB            ; zero ECX bytes at EDI
      WHY:
      BSS = uninitialized global/static variables
      Disk image stores NO data for BSS (saves space)
      Whatever was in RAM at those addresses = garbage
      C standard guarantees all globals zero-init.
      Without zeroing: static variables = garbage â†’
        linked list heads not NULL â†’ instant crash
        spinlock counts wrong â†’ deadlocks
      Skip: subtle, non-reproducible data corruption.
    |
  }
  p5_cld: "CLD â€” Clear Direction Flag" {
    style: {
      fill: "#2a1000"
      stroke: "#996600"
      font-color: white
    }
    label: |md
      **CLD**  ; DF = 0
      x86 EFLAGS.DF controls string instruction direction:
      DF=0: ESI/EDI increment (forward â€” normal)
      DF=1: ESI/EDI decrement (backward)
      C ABI (cdecl, SysV i386) requires DF=0 on
      every function entry and exit.
      If BIOS left DF=1:
        memcpy(dst, src, n) runs BACKWARDS
        Result: completely wrong memory contents
        No error, no crash â€” just wrong data
      Skip: memcpy/memset broken for certain calls.
    |
  }
  p5_ebp_zero: "EBP = 0 â€” Stack Frame Anchor" {
    style: {
      fill: "#2a1000"
      stroke: "#996600"
      font-color: white
    }
    label: |md
      XOR EBP, EBP    ; EBP = 0
      EBP is the frame pointer in the x86 calling
      convention. Stack unwinders follow the chain:
        [EBP+0] = saved previous EBP
        [EBP+4] = return address
      Walk until EBP = 0 â†’ bottom of call stack.
      Setting EBP=0 before CALL kernel_main marks
      kernel_main as the root frame.
      Enables:
        GDB backtrace to terminate cleanly
        Kernel panic stack trace to show correctly
        DWARF unwinding for debugging
      Skip: stack traces show garbage frames beyond
      kernel_main â†’ confuses debugging enormously.
    |
  }
  p5_call_c: "CALL kernel_main" {
    style: {
      fill: "#3a1500"
      stroke: "#cc6600"
      font-color: white
    }
    label: |md
      **CALL kernel_main**
      C ABI (cdecl): arguments pushed right-to-left
      CALL pushes return EIP, jumps to kernel_main
      Before this call, the following are guaranteed:
      âœ“ CPU: 32-bit protected mode, ring 0
      âœ“ CS = 0x08 (kernel code)
      âœ“ DS=ES=SS=FS=GS = 0x10 (kernel data)
      âœ“ ESP = valid 32-bit kernel stack
      âœ“ EFLAGS.IF = 0 (interrupts disabled)
      âœ“ EFLAGS.DF = 0 (string direction = forward)
      âœ“ EBP = 0 (stack frame anchor)
      âœ“ BSS = all zeros
      âœ“ Kernel binary at physical 0x100000
      âœ“ A20 enabled (full 32-bit address bus)
      âœ“ GDT loaded (5 entries, flat model)
      âœ“ BIOS E820 map stored in low memory
      kernel_main is freestanding C:
        -ffreestanding -nostdlib -nostdinc
      If kernel_main returns (should never happen):
      .hang: CLI / HLT / JMP .hang
    |
  }
  p5_copy_high -> p5_bss_zero: "Kernel at 0x100000\nready to execute"
  p5_bss_zero -> p5_cld: "Globals zeroed\nC semantics satisfied"
  p5_cld -> p5_ebp_zero: "DF=0\nstring ops correct"
  p5_ebp_zero -> p5_call_c: "EBP=0\nstack trace anchored"
}
skip_table: "SKIP THIS â†’ CONSEQUENCE TABLE" {
  near: bottom-right
  style: {
    fill: "#1a0000"
    stroke: "#880000"
    font-color: "#ff6666"
    bold: true
    border-radius: 6
  }
  table: |`md
    | Step Skipped         | Immediate Result                    | Observed As                  |
    |----------------------|-------------------------------------|------------------------------|
    | BIOS POST / IVT      | INT 13h has no handler              | Disk read â†’ hang             |
    | A20 Enable           | 0x100000 wraps to 0x00000           | Silent IVT/stack corruption  |
    | E820 query           | PMM allocates MMIO/ROM frames       | Silent memory corruption     |
    | CLI before LGDT      | Interrupt fires â†’ IVT in PM â†’ #GP  | Non-deterministic reset      |
    | LGDT                 | GDTR.base=0 â†’ null GDT              | Immediate #GP â†’ triple fault |
    | CR0.PE set           | Stay in real mode â†’ no protection  | Kernel never starts          |
    | Far jump after CR0   | CS invalid in PM â†’ #GP             | Immediate reset (silent)     |
    | Reload DS/ES/SS      | Null selector data access â†’ #GP    | Crash on first C instruction |
    | MOV ESP (stack)      | PUSH on null SS â†’ #SS              | Crash on first PUSH/CALL     |
    | Copy to 0x100000     | JMP to zeros or garbage             | Invalid opcode / #GP         |
    | BSS zeroing          | Global vars contain garbage         | Non-deterministic data bugs  |
    | CLD                  | DF may be 1 â†’ memcpy backwards      | Wrong data, no crash         |
    | EBP = 0              | Stack trace garbage past main       | Confusing debug output only  |
  `|
}
cpu_mode_col: "CPU MODE TIMELINE" {
  near: top-right
  style: {
    fill: "#0d0d0d"
    stroke: "#444444"
    font-color: white
    border-radius: 8
    bold: true
  }
  m0: "Power-On Reset" {
    style: {
      fill: "#2a2a00"
      stroke: "#888800"
      font-color: "#ffff44"
    }
    label: |md
      Mode: **REAL**
      Reg width: **16-bit** (EXX via 0x66 prefix)
      Addr width: **20-bit** (A20 gated OFF)
      Addr formula: seg x 16 + off
      Max physical: **0xFFFFF (1 MB)**
      Protection: **NONE**
      BIOS interrupts: **ACTIVE** (IVT @ 0x0000)
    |
  }
  m1: "After CR0.PE + far jump" {
    style: {
      fill: "#001a2a"
      stroke: "#0088cc"
      font-color: "#44ccff"
    }
    label: |md
      Mode: **PROTECTED**
      Reg width: **32-bit** (full EAX/EBX/...)
      Addr width: **32-bit** (A20 enabled â†’ 4 GB)
      Addr formula: GDT[sel].base + off
      Max physical: **0xFFFFFFFF (4 GB)**
      Protection: **SEGMENTATION** (DPL enforcement)
      BIOS interrupts: **BROKEN** (IVT invalid in PM)
    |
  }
  m0 -> m1: "CR0.PE = 1\n+ far jump\n(Phase 3)"
}
phase0 -> phase1: "BIOS JMPs to 0x7C00\nboot signature verified\nDL = 0x80 (drive)" {
  style: {
    stroke: "#886600"
    stroke-width: 2
    animated: true
  }
}
phase1 -> phase2: "JMP 0x0000:0x7E00\nstage-2 loaded\nstill real mode" {
  style: {
    stroke: "#006600"
    stroke-width: 2
    animated: true
  }
}
phase2 -> phase3: "E820 done, GDT built\nkernel in RAM @ 0x10000\nready for PM switch" {
  style: {
    stroke: "#660088"
    stroke-width: 2
    animated: true
  }
}
phase3 -> phase4: "CS = 0x08 (kernel code)\n32-bit protected mode\nEIP = protected_entry" {
  style: {
    stroke: "#006688"
    stroke-width: 2
    stroke-dash: 4
  }
}
phase4 -> phase5: "All segments = 0x10\nESP = 0x9FC00\nflat model active" {
  style: {
    stroke: "#884400"
    stroke-width: 2
    stroke-dash: 4
  }
}
phase5.p5_call_c -> kernel_main_c: "CALL kernel_main\nAll preconditions met" {
  style: {
    stroke: "#00cc44"
    stroke-width: 3
    animated: true
  }
}
kernel_main_c: "kernel_main() â€” C Entry Point" {
  style: {
    fill: "#003300"
    stroke: "#00cc00"
    font-color: "#00ff88"
    bold: true
    border-radius: 8
    shadow: true
    font-size: 16
  }
  label: |md
    **void kernel_main(void)**
    Guaranteed invariants on entry:
    âœ“ 32-bit protected mode, ring 0 (CPL=0)
    âœ“ CS=0x08 DS=ES=SS=FS=GS=0x10
    âœ“ ESP = valid kernel stack (~100 KB)
    âœ“ EFLAGS.IF=0 (interrupts disabled)
    âœ“ EFLAGS.DF=0 (string ops forward)
    âœ“ EBP=0 (stack trace anchor)
    âœ“ .bss = all zeros
    âœ“ Physical 0x100000 = kernel .text start
    âœ“ A20 on, full 32-bit address space
    âœ“ GDT: 5 entries, flat model
    âœ“ E820 map in low memory
    âœ— IDT not loaded (interrupts MUST stay off)
    âœ— Paging disabled (CR0.PG=0)
    âœ— kmalloc not available
    âœ— No process context
    Next: GDT reinit â†’ IDT install â†’ PIC remap
          â†’ PIT â†’ STI (Milestone 2)
  |
  link: "#build-os-m2"
}
mem_map: "Physical Address Space at Kernel Entry" {
  near: center-right
  style: {
    fill: "#0d0d0d"
    stroke: "#555555"
    font-color: white
    border-radius: 6
  }
  label: |md
    0x00000000  IVT (256x4B real-mode)   0x0000-0x03FF
                BIOS Data Area           0x0400-0x04FF
                E820 results (stored)    0x0500-0x7BFF
    0x00007C00  MBR / Stage-1            0x7C00-0x7DFF
    0x00007E00  Stage-2 loader           0x7E00-0x8FFF
    0x00010000  Kernel copy (temp)       0x10000-0x1FFFF
    0x0009FC00  EBDA â€” stack lives below here
    0x000A0000  VGA text buffer          0xB8000 (80x25)
    0x000C0000  Video BIOS ROM
    0x000F0000  System BIOS ROM          0xF0000-0xFFFFF
    0x00100000  KERNEL ENTRY
                .text .rodata .data .bss
                kernel LMA: 0x00100000 (now)
                kernel VMA: 0xC0100000 (post-paging M3)
    0x07FE0000  ACPI Tables (reserved)
    0xFFFC0000  BIOS flash / ROM
    0xFFFFFFFF  end
  |
}