vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: down
title: |md
  # x86 Boot Sequence — BIOS to C Entry Point
  ### Every Step from Power-On to kernel_main()
| {near: top-center}
back_to_map: "⬆ Satellite Map" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#2d2d2d"
    font-color: "#aaaaaa"
    stroke: "#555555"
    border-radius: 8
    font-size: 11
  }
}
legend: {
  near: bottom-right
  style.fill: "#1a1a2e"
  style.stroke: "#444466"
  style.border-radius: 6
  l1: "Real Mode (16-bit, 20-bit addr)" {
    style.fill: "#4a1942"
    style.font-color: "#ff99cc"
    style.border-radius: 4
  }
  l2: "Transition / One-Shot" {
    style.fill: "#1a3a1a"
    style.font-color: "#88ff88"
    style.border-radius: 4
  }
  l3: "Protected Mode (32-bit, full addr)" {
    style.fill: "#1a2a4a"
    style.font-color: "#88bbff"
    style.border-radius: 4
  }
  l4: "CRITICAL — skip = triple fault" {
    style.fill: "#3a1a1a"
    style.font-color: "#ff6666"
    style.border-radius: 4
  }
  l5: "Red arrow = hot path / danger" {
    style.fill: "#1a1a1a"
    style.font-color: "#ff8888"
    style.border-radius: 4
  }
}
s0: "PHASE 0 — POWER-ON RESET VECTOR" {
  style.fill: "#4a1942"
  style.stroke: "#cc44aa"
  style.bold: true
  style.border-radius: 6
  s0_cpu: |md
    **CPU Hard Reset State**
    CS = 0xF000 | IP = 0xFFF0
    Physical: 0xFFFF0 (top of 1MB)
    EIP = 0x0000FFF0 (real mode shadow)
    Mode: **16-bit REAL MODE**
    Address width: **20-bit** (A0-A19)
    Max addressable: **0xFFFFF = 1,048,575**
  | {
    style.fill: "#3a0f32"
    style.font-color: "#ffaadd"
    style.border-radius: 4
  }
  s0_bios: |md
    **BIOS Firmware (ROM)**
    Mapped at 0xF0000-0xFFFFF (64KB)
    Contains: POST code, device init,
    disk services (INT 13h),
    video (INT 10h), boot scan loop.
    IF SKIPPED: Impossible — this IS
    the first code the CPU runs.
  | {
    style.fill: "#2a0a22"
    style.font-color: "#cc88bb"
    style.border-radius: 4
  }
  s0_post: |md
    **POST (Power-On Self-Test)**
    1. Test CPU registers
    2. Initialize chipset
    3. Size + test RAM
    4. Initialize PCI bus
    5. Enumerate boot devices
    6. Search for boot sector (0x55AA)
    IF SKIPPED: Hardware may be
    uninitialized; RAM contents
    undefined; disk unreachable.
  | {
    style.fill: "#2a0a22"
    style.font-color: "#cc88bb"
    style.border-radius: 4
  }
}
s1: "PHASE 1 — MBR / STAGE-1 BOOTLOADER at 0x7C00" {
  style.fill: "#4a1942"
  style.stroke: "#cc44aa"
  style.bold: true
  style.border-radius: 6
  s1_load: |md
    **BIOS Reads Sector 0 to 0x7C00**
    INT 13h, AH=02h, DL=0x80
    Reads: 512 bytes from LBA 0
    Checks bytes [510..511] == 0x55, 0xAA
    Physical load addr: **0x00007C00**
    BIOS jumps: CS=0x0000, IP=0x7C00
    IF SKIPPED (no 0x55AA signature):
    BIOS skips device; tries next.
    "No bootable device found."
  | {
    style.fill: "#3a0f32"
    style.font-color: "#ffaadd"
    style.border-radius: 4
  }
  s1_stack: |md
    **Stage-1 Stack Setup**
      cli           ; MUST — touching seg regs
      xor ax, ax
      mov ds, ax    ; DS = 0x0000
      mov es, ax    ; ES = 0x0000
      mov ss, ax    ; SS = 0x0000
      mov sp, 0x7C00 ; stack grows DOWN from MBR
      sti
    Real-mode addr: SEG*16 + OFF
    0x0000*16 + 0x7C00 = **0x7C00**
    IF SKIPPED: SS/DS undefined;
    first push/pop corrupts memory.
  | {
    style.fill: "#2a0a22"
    style.font-color: "#cc88bb"
    style.border-radius: 4
  }
  s1_constraint: |md
    **The 510-Byte Constraint**
    Bytes 0-509: your code + data
    Bytes 510-511: 0x55, 0xAA (signature)
    Fits: stack setup + INT 13h read
    Does NOT fit: full GDT, IDT,
    A20 fallback chain, kernel load.
    SOLUTION: Two-stage loading.
    Stage 1 loads Stage 2 from
    sectors 2-9 (4KB) to 0x7E00.
  | {
    style.fill: "#2a0a22"
    style.font-color: "#ff9999"
    style.border-radius: 4
  }
}
s2: "PHASE 2 — INT 13h DISK READS" {
  style.fill: "#4a1942"
  style.stroke: "#cc44aa"
  style.bold: true
  style.border-radius: 6
  s2_int13: |md
    **BIOS INT 13h Extended Read (AH=0x42)**
    Uses Disk Address Packet (DAP) at DS:SI
      +0x00  db 0x10      ; DAP size = 16
      +0x01  db 0x00      ; reserved
      +0x02  dw 64        ; sectors to read
      +0x04  dw 0x0000    ; target offset
      +0x06  dw 0x1000    ; target segment -> phys 0x10000
      +0x08  dd 2         ; LBA start (lo)
      +0x0C  dd 0         ; LBA start (hi)
    CF=0 on success; CF=1 on error.
  | {
    style.fill: "#3a0f32"
    style.font-color: "#ffaadd"
    style.border-radius: 4
  }
  s2_layout: |md
    **Disk Image Layout**
      Sector 0      [0x000000]: Stage 1 (MBR, 512B)
      Sector 1      [0x000200]: (padding)
      Sectors 2-9   [0x000400]: Stage 2 (4KB to 0x7E00)
      Sectors 10-73 [0x001400]: Kernel binary (32KB max)
                                Loaded to 0x10000 initially
                                Copied to 0x100000 after A20+PM
    IF SKIPPED: Kernel never reaches RAM.
    CPU executes BIOS ROM or zeroes.
    Immediate triple-fault.
  | {
    style.fill: "#2a0a22"
    style.font-color: "#cc88bb"
    style.border-radius: 4
  }
  s2_error: |md
    **Error Handling (mandatory)**
      int 0x13
      jc disk_error      ; CF=1 means error
      cmp ah, 0          ; AH=0 means success
      jne disk_error
      disk_error:
        mov si, err_msg
        call print_str   ; BIOS INT 10h
        hlt
    Without error check: silent load
    of partial/corrupt data causes
    mysterious triple-fault later.
  | {
    style.fill: "#2a0a22"
    style.font-color: "#ff9999"
    style.border-radius: 4
  }
}
s3: "PHASE 3 — A20 ADDRESS LINE ENABLE" {
  style.fill: "#4a1942"
  style.stroke: "#cc44aa"
  style.bold: true
  style.border-radius: 6
  s3_problem: |md
    **The Problem (IBM PC, 1981)**
    8086: 20-bit bus (A0-A19), max 0xFFFFF
    Programs used WRAP-AROUND:
    0xFFFF:0x0010 = 0x10000F wraps to 0x0000F
    Some 8086 code DEPENDED on this.
    80286: 24-bit bus (A0-A23)
    0x10000F now addresses REAL memory.
    Wrap-around broken — programs crash.
    IBM FIX: Gate A20 through keyboard
    controller (8042). A20 DISABLED by
    default to restore 8086 wrap behavior.
  | {
    style.fill: "#3a0f32"
    style.font-color: "#ffaadd"
    style.border-radius: 4
  }
  s3_consequence: |md
    **IF A20 NOT ENABLED:**
    Kernel at 0x100000 (1MB mark) wraps
    to 0x000000 (physical zero!) because
    address bit 20 is forced to zero.
    Every write to 0x100000-0x10FFFF
    SILENTLY OVERWRITES 0x00000-0x0FFFF
    (BIOS data area, IVT, stack).
    System corrupts itself and crashes
    with NO error message.
  | {
    style.fill: "#3a1a1a"
    style.font-color: "#ff6666"
    style.border-radius: 4
    style.bold: true
  }
  s3_methods: |md
    **3 Methods (try in order)**
    METHOD 1 — BIOS INT 15h/0x2401:
      mov ax, 0x2401
      int 0x15
      jc  try_method2   ; CF=1 = unsupported
    METHOD 2 — Fast A20 (port 0x92):
      in  al, 0x92
      or  al, 0x02      ; bit1 = A20 enable
      and al, 0xFE      ; bit0 = RESET — DON'T SET
      out 0x92, al
    METHOD 3 — 8042 keyboard controller:
    Write 0xAD (disable kbd) to 0x64,
    write 0xD0 (read output port) to 0x64,
    read byte from 0x60, OR in bit 1,
    write back via 0xD1, write 0xAE to 0x64.
    VERIFY: Write 0xAA to 0x7DFE.
    Read 0x17FFE. If different: A20 ON.
  | {
    style.fill: "#2a0a22"
    style.font-color: "#cc88bb"
    style.border-radius: 4
  }
}
s4: "PHASE 4 — GDT CONSTRUCTION and LGDT" {
  style.fill: "#1a3a1a"
  style.stroke: "#44aa44"
  style.bold: true
  style.border-radius: 6
  s4_structure: |md
    **GDT Memory Layout (40 bytes total)**
    Base addr (physical): 0x00008000
      Offset 0x00: NULL descriptor
        [0x0000000000000000]
      Offset 0x08: Kernel Code (sel 0x08)
        Base=0, Limit=4GB, DPL=0, Execute/Read
        Access=0x9A, Flags=0xCF
      Offset 0x10: Kernel Data (sel 0x10)
        Base=0, Limit=4GB, DPL=0, Read/Write
        Access=0x92, Flags=0xCF
      Offset 0x18: User Code (sel 0x1B, RPL=3)
        Access=0xFA, Flags=0xCF
      Offset 0x20: User Data (sel 0x23, RPL=3)
        Access=0xF2, Flags=0xCF
  | {
    style.fill: "#0a2a0a"
    style.font-color: "#88ff88"
    style.border-radius: 4
  }
  s4_entry_layout: |md
    **8-Byte Descriptor Bit Layout**
      63    56 55  52 51 48 47    40 39   32
      Base31:24 Flags Lim19:16 Access Base23:16
      31       16 15           0
      Base 15:0    Limit 15:0
    Flags nibble (bits 55-52):
      G=1   limit in 4KB pages
      D/B=1 32-bit default operand
      L=0   not 64-bit
      AVL=0 OS-available
    Access byte 0x9A decoded:
      P=1   (present)
      DPL=00 (ring 0)
      S=1   (code/data, not system)
      E=1   (executable = code)
      C=0   (non-conforming)
      R=1   (readable)
      A=0   (not accessed yet)
  | {
    style.fill: "#0a2a0a"
    style.font-color: "#88ff88"
    style.border-radius: 4
  }
  s4_lgdt: |md
    **LGDT Instruction**
      gdt_descriptor:
        dw 39          ; limit = 5 entries * 8 - 1
        dd 0x00008000  ; base = physical addr of GDT
      lgdt [gdt_descriptor]
    Loads 6-byte GDTR register:
      GDTR.base  = physical addr of table
      GDTR.limit = table_size - 1
    IF SKIPPED: CR0.PE set with
    uninitialized GDTR. First memory
    access after mode switch reads
    garbage descriptors, causes #GP,
    then #DF, then triple-fault, then RESET.
    No error message. Ever.
  | {
    style.fill: "#1a3a1a"
    style.font-color: "#ff6666"
    style.border-radius: 4
    style.bold: true
  }
}
s5: "PHASE 5 — CLI and CR0.PE = 1 (THE MODE SWITCH)" {
  style.fill: "#3a1a1a"
  style.stroke: "#cc4444"
  style.bold: true
  style.border-radius: 6
  s5_cli: |md
    **CLI — Disable Interrupts (MANDATORY)**
      cli
    BIOS left an IVT at physical 0x00000-0x003FF.
    IVT entries are real-mode far pointers (4 bytes: SEGMENT:OFFSET).
    After LGDT but before LIDT:
    If ANY interrupt fires, CPU looks up
    the IDT (not set yet). It reads the
    IVT entry as a protected-mode gate
    descriptor — garbage — causing #GP,
    then #DF, then triple-fault.
    CLI buys time to set up IDT (Milestone 2).
    Do NOT call STI until IDT is loaded.
  | {
    style.fill: "#2a0a0a"
    style.font-color: "#ff9999"
    style.border-radius: 4
    style.bold: true
  }
  s5_cr0: |md
    **Set CR0.PE (bit 0) — Enter Protected Mode**
      mov eax, cr0
      or  eax, 0x00000001   ; Set PE bit
      mov cr0, eax
    CR0 Control Register bits (relevant):
      Bit  0 (PE): Protection Enable — WE SET THIS
      Bit  1 (MP): Monitor Coprocessor
      Bit 16 (WP): Write Protect (for COW later)
      Bit 31 (PG): Paging (Milestone 3)
    AFTER THIS INSTRUCTION:
    + Segmentation is now ENFORCED
    + Ring 0/3 distinction is REAL
    - BIOS interrupts BROKEN FOREVER
    - CS still holds real-mode value
    - Prefetch queue has real-mode instrs
    Next instruction MUST be far jump.
  | {
    style.fill: "#2a0a0a"
    style.font-color: "#ff9999"
    style.border-radius: 4
  }
}
s6: "PHASE 6 — FAR JUMP (JMP 0x08:protected_entry)" {
  style.fill: "#3a1a1a"
  style.stroke: "#cc4444"
  style.bold: true
  style.border-radius: 6
  s6_why: |md
    **WHY THE FAR JUMP IS NOT OPTIONAL**
    After "mov cr0, eax":
    - CPU execution unit: PROTECTED MODE
    - CS register: still 0x0000 (real-mode value)
    - Prefetch queue: may hold real-mode decoded instrs
    The CPU is in a schizophrenic state for
    the next few cycles. The far jump
    atomically does THREE things:
    1. Loads CS = 0x08 (kernel code selector)
    2. Validates CS against GDT descriptor
    3. FLUSHES the instruction prefetch queue,
       discarding all partially-decoded
       real-mode instructions.
    WITHOUT THE FAR JUMP:
    Next instruction executes with CS=0x0000
    in protected mode, causing #GP (invalid selector),
    then #DF (no double fault handler yet),
    then triple-fault, then RESET.
  | {
    style.fill: "#2a0a0a"
    style.font-color: "#ff9999"
    style.border-radius: 4
    style.bold: true
  }
  s6_code: |md
    **The Far Jump Instruction**
      ; [BITS 16] — still in 16-bit context
      ; but operand-size prefix makes this 32-bit
      jmp dword 0x08:protected_mode_entry
      ; Target in [BITS 32] section:
      [BITS 32]
      protected_mode_entry:
        ; CS = 0x08 (kernel code, ring 0)
        ; Mode: 32-bit PROTECTED MODE
        ; Pipeline: flushed, clean state
    After this jump:
    CPU Mode: **32-BIT PROTECTED MODE**
    CS = 0x08 (GDT[1]: kernel code, DPL=0)
    EIP = virtual address of protected_mode_entry
    All other segment regs: STALE (must reload)
  | {
    style.fill: "#2a0a0a"
    style.font-color: "#ff9999"
    style.border-radius: 4
  }
  s6_spectre: |md
    **Connection: Spectre Variant 1**
    The prefetch queue flush requirement reveals
    that the CPU pipeline maintains state
    INDEPENDENT of privilege enforcement.
    Spectre exploits this same gap: CPU
    speculatively executes instructions BEFORE
    validating permissions, leaving cache
    side-channel evidence that attackers read.
    The far jump and Spectre share the same
    root: pipeline state is not synchronous
    with architectural state.
  | {
    style.fill: "#1a1a2a"
    style.font-color: "#aaaaff"
    style.border-radius: 4
    style.italic: true
  }
}
s7: "PHASE 7 — RELOAD ALL SEGMENT REGISTERS" {
  style.fill: "#1a2a4a"
  style.stroke: "#4488cc"
  style.bold: true
  style.border-radius: 6
  s7_code: |md
    **Reload DS, ES, FS, GS, SS**
      ; After far jump, CS=0x08 (correct)
      ; DS, ES, FS, GS, SS = stale real-mode values
      mov ax, 0x10        ; Kernel data selector
      mov ds, ax          ; DS = GDT[2] (kernel data)
      mov es, ax          ; ES = GDT[2]
      mov fs, ax          ; FS = GDT[2]
      mov gs, ax          ; GS = GDT[2] (later: TLS)
      mov ss, ax          ; SS = GDT[2] (stack segment)
      mov esp, 0x00090000 ; 32-bit stack below EBDA
                          ; EBDA starts at ~0x9FC00
    Each "mov segReg, ax" causes the CPU to
    read GDT[2] and cache the descriptor into
    a hidden segment descriptor cache register.
  | {
    style.fill: "#0a1a2a"
    style.font-color: "#88bbff"
    style.border-radius: 4
  }
  s7_hidden: |md
    **Segment Descriptor Cache (Hidden Registers)**
    Each segment register (CS, DS, SS, etc.)
    has a 64-bit HIDDEN cache filled from
    the GDT on each seg-reg load.
    Cached fields per segment:
    - Base address (32 bits)
    - Limit (20 bits + granularity)
    - Access rights (type, DPL, present)
    In the flat model (Base=0, Limit=4GB),
    the cache makes segmentation a NO-OP:
    every logical address = linear address.
    IF SKIPPED (don't reload DS/SS):
    DS still holds 0x0000 as a PM selector.
    GDT[0] is the NULL descriptor (always invalid).
    First data access causes #GP(0x0000).
    Triple-fault.
  | {
    style.fill: "#0a1a2a"
    style.font-color: "#88bbff"
    style.border-radius: 4
  }
  s7_esp: |md
    **32-Bit ESP — Physical Memory Layout**
      0x00000000  Real-mode IVT (1KB)
      0x00000400  BIOS Data Area (256B)
      0x00007C00  Stage-1 MBR (512B)
      0x00007E00  Stage-2 (4KB)
      0x0009FC00  EBDA (up to 128B, varies)
      0x000A0000  VGA/video RAM (128KB)
      0x000C0000  VGA BIOS ROM
      0x000F0000  System BIOS ROM (64KB)
      0x00100000  KERNEL LOADED HERE (1MB mark)
    Stack at 0x90000: below EBDA, above
    stage-2 + MBR. Safe for small kernels.
    In Milestone 3 this becomes 0xC0090000
    after higher-half paging is enabled.
  | {
    style.fill: "#0a1a2a"
    style.font-color: "#88bbff"
    style.border-radius: 4
  }
}
s8: "PHASE 8 — ZERO THE BSS SECTION" {
  style.fill: "#1a2a4a"
  style.stroke: "#4488cc"
  style.bold: true
  style.border-radius: 6
  s8_why: |md
    **WHY BSS MUST BE ZEROED MANUALLY**
    The kernel binary on disk stores:
    + .text section: compiled code
    + .rodata section: string literals, const
    + .data section: initialized globals
    - .bss section: NOT STORED (size only)
    The disk image doesn't store 4KB of zeros
    for "int my_counter = 0;" — waste of space.
    The linker records BSS start + size only.
    When the bootloader copies kernel.bin to
    0x100000, it copies text+rodata+data.
    BSS region contains WHATEVER WAS IN RAM
    at those addresses previously.
    IF BSS NOT ZEROED:
    Global variables declared as "int x;" have
    garbage values. Any C code that relies on
    "uninitialized globals default to zero"
    (guaranteed by the C standard) will fail
    silently or spectacularly.
  | {
    style.fill: "#0a1a2a"
    style.font-color: "#88bbff"
    style.border-radius: 4
  }
  s8_code: |md
    **Assembly BSS Zero Routine**
      ; __bss_start and __bss_end exported by linker script
      extern __bss_start
      extern __bss_end
      mov edi, __bss_start   ; destination ptr
      mov ecx, __bss_end
      sub ecx, edi           ; byte count
      xor eax, eax           ; value = 0x00000000
      rep stosb              ; zero ECX bytes at [EDI]
    rep stosb: stores AL (= 0) into [EDI],
    increments EDI, decrements ECX.
    Repeats until ECX = 0.
    Linear write pattern: excellent cache
    performance, no conditional branches.
    BSS zeroed in ~(BSS_size / 4) cycles
    using rep stosd (32-bit version).
  | {
    style.fill: "#0a1a2a"
    style.font-color: "#88bbff"
    style.border-radius: 4
  }
}
s9: "PHASE 9 — CALL kernel_main()" {
  style.fill: "#1a2a4a"
  style.stroke: "#44aaff"
  style.bold: true
  style.border-radius: 6
  s9_pre: |md
    **Final Pre-C Setup**
      ; Clear direction flag (C ABI: DF=0 required)
      ; Without this: memcpy/memset run backwards
      cld
      ; Set frame pointer = 0 (marks bottom of
      ; call chain for stack unwinding/backtraces)
      xor ebp, ebp
      ; ESP is set (phase 7), stack is valid.
      ; BSS is zeroed (phase 8).
      ; Interrupts are disabled (safe for now).
      ; GDT is loaded and valid.
      ; We are in 32-bit protected mode.
      ; CR0.PE = 1, CR0.PG = 0 (paging off).
      ; Physical addr = virtual addr.
      ; If using Multiboot (GRUB):
      ; EAX = 0x2BADB002 (magic number)
      ; EBX = physical addr of multiboot_info_t
      push ebx          ; pass multiboot_info to C
      call kernel_main  ; NEVER RETURNS (we hope)
  | {
    style.fill: "#0a1a2a"
    style.font-color: "#88bbff"
    style.border-radius: 4
  }
  s9_state: |md
    **CPU State at kernel_main() Entry**
      Mode:     32-bit PROTECTED MODE
      Paging:   DISABLED (physical = virtual)
      EIP:      0x00100xxx (physical)
      ESP:      0x00090000 (stack top)
      CS:       0x0008 (GDT[1]: ring-0 code)
      DS/ES/SS: 0x0010 (GDT[2]: ring-0 data)
      EFLAGS:   IF=0 (interrupts disabled)
      CR0:      PE=1, PG=0, WP=0
      CR3:      undefined (no page tables yet)
      GDTR:     loaded (5 entries, physical addr)
      IDTR:     undefined (IDT not set up yet)
      EBX:      multiboot_info_t* (if via GRUB)
      EAX:      0x2BADB002 (Multiboot magic)
  | {
    style.fill: "#0a1a2a"
    style.font-color: "#44ffaa"
    style.border-radius: 4
  }
  s9_next: |md
    **What Comes Next (Milestones 2-4)**
    1. IDT init + PIC remap — exceptions work
    2. PIT timer — scheduler heartbeat
    3. E820 parse + PMM init — frame allocator
    4. Page tables + CR0.PG=1 — virtual memory
    5. Kernel heap (kmalloc/kfree)
    6. TSS + process_create — PCBs
    7. context_switch_asm — round-robin sched
    8. INT 0x80 gate — system calls
    9. enter_user_mode (iretd) — ring 3 procs
    The dependency chain is absolute:
    No IDT — no page faults — no demand paging.
    No paging — no process isolation.
    No isolation — no user mode.
    No user mode — no OS.
  | {
    style.fill: "#0a1a3a"
    style.font-color: "#8888ff"
    style.border-radius: 4
  }
}
memmap: "PHYSICAL ADDRESS SPACE at kernel_main() Entry" {
  style.fill: "#1a1a2a"
  style.stroke: "#666688"
  style.border-radius: 6
  mm_layout: |||md
    | Physical Range    | Contents                     | Writable?        |
    |-------------------|------------------------------|------------------|
    | 0x00000-0x003FF   | BIOS IVT (256 vectors x 4B)  | NO (leave alone) |
    | 0x00400-0x004FF   | BIOS Data Area               | NO               |
    | 0x00500-0x07BFF   | Conventional RAM (free)      | YES              |
    | 0x07C00-0x07DFF   | Stage-1 MBR (512B)           | YES (dead code)  |
    | 0x07E00-0x08DFF   | Stage-2 loader (4KB)         | YES (dead code)  |
    | 0x08E00-0x08FFF   | GDT (40B at 0x8000 + pad)    | YES (but dont)   |
    | 0x09000-0x09FBF   | Kernel stack (grows down)    | YES              |
    | 0x09FC0-0x09FFF   | EBDA (Extended BIOS Data)    | NO               |
    | 0x0A000-0x0BFFF   | VGA/EGA video memory         | YES (to display) |
    | 0x0C000-0x0FFFF   | Video BIOS ROM               | NO (ROM)         |
    | 0x0F000-0x0FFFF   | System BIOS ROM              | NO (ROM)         |
    | 0x10000-0x1FFFF   | Kernel initial load (64KB)   | YES              |
    | 0x100000-0x1FFFFF | Kernel final position (1MB+) | YES              |
    | 0x200000-RAM_TOP  | Usable RAM (E820 type 1)     | YES              |
  ||| {
    style.fill: "#111122"
    style.font-color: "#aaaacc"
    style.border-radius: 4
  }
}
s0 -> s1: "BIOS finds 0x55AA signature\nJumps to CS=0x0000:IP=0x7C00\nMode: REAL (16-bit, 20-bit addr)" {
  style.stroke: "#cc44aa"
  style.font-color: "#cc44aa"
  style.stroke-width: 3
  style.animated: true
}
s1 -> s2: "Stage-1 stack ready\nNeeds to load stage-2 + kernel\nOnly tool: BIOS INT 13h" {
  style.stroke: "#cc44aa"
  style.font-color: "#cc44aa"
  style.stroke-width: 3
}
s2 -> s3: "Kernel binary at 0x10000\nMust enable A20 BEFORE\ncopying to 0x100000\nMode: still REAL" {
  style.stroke: "#cc44aa"
  style.font-color: "#cc44aa"
  style.stroke-width: 3
  style.animated: true
}
s3 -> s4: "A20 verified active\n21st address bit now works\nCan safely address > 1MB\nBuild GDT in stage-2 RAM" {
  style.stroke: "#44aa44"
  style.font-color: "#44aa44"
  style.stroke-width: 3
}
s4 -> s5: "LGDT loaded — GDTR valid\nNow safe to set CR0.PE\nMUST cli first (no IDT yet)\nLast act before mode change" {
  style.stroke: "#cc4444"
  style.font-color: "#cc4444"
  style.stroke-width: 4
  style.animated: true
}
s5 -> s6: "CR0.PE=1 set\nCPU in protected mode but\nCS still stale, pipeline dirty\nFAR JUMP IS MANDATORY" {
  style.stroke: "#cc4444"
  style.font-color: "#ff4444"
  style.stroke-width: 5
  style.animated: true
}
s6 -> s7: "CS=0x08 loaded + validated\nPipeline flushed\nMode: 32-bit PROTECTED\nNow reload DS/SS/ES/FS/GS" {
  style.stroke: "#4488cc"
  style.font-color: "#4488cc"
  style.stroke-width: 3
}
s7 -> s8: "All segment regs valid\n32-bit stack at 0x90000\nFlat memory model active\nNow zero BSS before C" {
  style.stroke: "#4488cc"
  style.font-color: "#4488cc"
  style.stroke-width: 3
}
s8 -> s9: "BSS zeroed (all C globals = 0)\nCLD executed (DF=0 for ABI)\nEBP=0 (clean backtrace chain)\nREADY to call kernel_main" {
  style.stroke: "#44aaff"
  style.font-color: "#44aaff"
  style.stroke-width: 4
  style.animated: true
}
s9 -> memmap: "Reference: physical layout\nat kernel_main() entry" {
  style.stroke: "#666688"
  style.stroke-dash: 5
  style.font-color: "#666688"
}
skip_a20: "SKIP A20:\n0x100000 wraps to 0x00000\nKernel silently overwrites IVT\nNo error message — delayed crash" {
  style.fill: "#3a0000"
  style.font-color: "#ff4444"
  style.stroke: "#880000"
  style.border-radius: 6
  style.italic: true
}
skip_gdt: "SKIP GDT:\nCR0.PE=1 with garbage GDTR\nFirst memory access — #GP\nthen #DF — Triple-fault — RESET" {
  style.fill: "#3a0000"
  style.font-color: "#ff4444"
  style.stroke: "#880000"
  style.border-radius: 6
  style.italic: true
}
skip_jmp: "SKIP FAR JMP:\nCS holds real-mode value 0x0000\nNext instruction — #GP\nthen #DF — Triple-fault — RESET" {
  style.fill: "#3a0000"
  style.font-color: "#ff4444"
  style.stroke: "#880000"
  style.border-radius: 6
  style.italic: true
}
skip_bss: "SKIP BSS ZERO:\nC globals contain RAM garbage\nsilent data corruption\ncrash far from the bug site" {
  style.fill: "#3a0000"
  style.font-color: "#ff4444"
  style.stroke: "#880000"
  style.border-radius: 6
  style.italic: true
}
s3 -> skip_a20: "if skipped" {
  style.stroke: "#880000"
  style.stroke-dash: 4
  style.font-color: "#880000"
}
s4 -> skip_gdt: "if skipped" {
  style.stroke: "#880000"
  style.stroke-dash: 4
  style.font-color: "#880000"
}
s6 -> skip_jmp: "if skipped" {
  style.stroke: "#880000"
  style.stroke-dash: 4
  style.font-color: "#880000"
}
s8 -> skip_bss: "if skipped" {
  style.stroke: "#880000"
  style.stroke-dash: 4
  style.font-color: "#880000"
}