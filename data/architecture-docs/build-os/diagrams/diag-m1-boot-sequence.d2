vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # x86 Boot Sequence: BIOS to kernel main()
  ### Control Transfer Timeline — Physical Addresses, Registers & Hardware State
| {near: top-center}

style: {
  fill: "#0d1117"
  stroke: "#30363d"
}

classes: {
  phase_bios: {
    style: {
      fill: "#1a1f2e"
      stroke: "#3d5a80"
      stroke-width: 2
      font-color: "#7eb8f7"
      bold: true
      font-size: 13
    }
  }
  phase_real: {
    style: {
      fill: "#1a2010"
      stroke: "#3d6b20"
      stroke-width: 2
      font-color: "#8dc870"
      bold: true
      font-size: 13
    }
  }
  phase_prot: {
    style: {
      fill: "#1f1a0a"
      stroke: "#7a5200"
      stroke-width: 2
      font-color: "#e8a840"
      bold: true
      font-size: 13
    }
  }
  phase_kernel: {
    style: {
      fill: "#1a0f1a"
      stroke: "#6b2080"
      stroke-width: 2
      font-color: "#c880e8"
      bold: true
      font-size: 13
    }
  }
  step_box: {
    style: {
      fill: "#161b22"
      stroke: "#444c56"
      stroke-width: 1
      font-color: "#e6edf3"
      font-size: 11
      border-radius: 4
    }
  }
  reg_box: {
    style: {
      fill: "#0d1117"
      stroke: "#bb8009"
      stroke-width: 1
      font-color: "#e3b341"
      font-size: 10
      font: mono
    }
  }
  addr_box: {
    style: {
      fill: "#0d1117"
      stroke: "#1f6feb"
      stroke-width: 1
      font-color: "#58a6ff"
      font-size: 10
      font: mono
    }
  }
  danger: {
    style: {
      fill: "#2d0f0f"
      stroke: "#f85149"
      stroke-width: 2
      font-color: "#ff7b72"
      font-size: 11
      border-radius: 3
    }
  }
  safe: {
    style: {
      fill: "#0d2016"
      stroke: "#2ea043"
      stroke-width: 2
      font-color: "#56d364"
      font-size: 11
      border-radius: 3
    }
  }
}

p0: "PHASE 0 — CPU POWER-ON RESET" {
  class: phase_bios

  s0_reset: "Step 0: Hardware Reset Vector" {
    class: step_box
    label: "Step 0: Hardware Reset Vector\nCPU drives all address lines HIGH except A20\nBegins executing at physical 0xFFFFFFF0\n(maps to firmware ROM via chipset)"
  }

  r0: "CPU State at Reset" {
    class: reg_box
    label: "CPU State at Reset\nCS  = 0xF000  (base=0xFFFF0000, shadow)\nIP  = 0xFFF0\nPhysical = 0xFFFFFFF0\nCR0 = 0x60000010  (PE=0, PG=0)\nEFLAGS = 0x00000002  (IF=0)\nMode: 16-bit Real Mode"
  }

  s0_reset -> r0: "Reset vector fetch\n(ROM mapped here by chipset)"
}

p1: "PHASE 1 — BIOS POST & Firmware Init" {
  class: phase_bios

  s1_post: "POST Power-On Self-Test" {
    class: step_box
    label: "BIOS POST Sequence\n1. CPU registers initialized\n2. Cache controller configured\n3. RAM detection and test (below 1MB)\n4. PIC initialized (default: IRQ0 to vec 8 WARNING)\n5. PIT timer configured\n6. Keyboard controller (8042) init\n7. VGA BIOS initialized to 80x25 text mode\n8. Boot device enumeration\n9. INT 13h handlers installed in IVT"
  }

  s1_ivt: "IVT at 0x00000000" {
    class: addr_box
    label: "Interrupt Vector Table (real mode)\n0x0000-0x03FF = 256 x 4-byte vectors\n[INT_NUM x 4] = seg:offset pair\nINT 13h = disk BIOS handler addr\nINT 10h = video BIOS handler addr\nWARNING: vec 8 = IRQ0 (timer) in default PIC config"
  }

  s1_bda: "BIOS Data Area 0x0400-0x04FF" {
    class: step_box
    label: "BIOS Data Area\nDisk geometry tables\nSerial/parallel port addresses\nMemory size (below 1MB)"
  }

  s1_post -> s1_ivt: "BIOS installs\ninterrupt handlers"
  s1_post -> s1_bda: "BIOS writes\nhardware info"
}

p2: "PHASE 2 — Boot Device and MBR Load" {
  class: phase_real

  s2_scan: "Boot Device Scan" {
    class: step_box
    label: "Boot Device Scan\nBIOS checks boot order: floppy -> HDD -> USB -> PXE\nReads first 512 bytes of boot device\nChecks bytes 510-511 == 0x55 0xAA\nIf signature valid: copy to 0x7C00, jump there"
  }

  s2_sig: "Boot Signature Check" {
    class: safe
    label: "Boot Signature Check\nBytes 510-511 of disk sector 0:\n0x55 0xAA = valid boot sector\nother     = BIOS skips this device\nLittle-endian: dw 0xAA55 in NASM\nstored as 0x55, 0xAA in memory"
  }

  s2_load: "MBR Loaded at 0x7C00" {
    class: addr_box
    label: "MBR Loaded at Physical 0x00007C00\n512 bytes copied from disk by BIOS\nBIOS executes: jmp 0x0000:0x7C00\nCS:IP = 0x0000:0x7C00\nDL = boot drive number (e.g. 0x80 = HDD)\nStack: undefined -- bootloader must set it\nAvailable RAM: ~608KB (below 0xA0000)"
  }

  s2_constraint: "512-byte Stage 1 Constraint" {
    class: danger
    label: "WARNING: Stage 1 Must Fit in 512 Bytes\nMust include: stack setup, A20, INT 13h, GDT, CR0\nSolution: Two-stage bootloader\nStage 1 (MBR): loads Stage 2 from disk\nStage 2 (4KB+): does full initialization"
  }

  s2_scan -> s2_sig: "Read sector 0"
  s2_sig -> s2_load: "Signature OK\nBIOS jmp 0x7C00"
  s2_load -> s2_constraint: "Stage 1 cannot\nfit everything"
}

p3: "PHASE 3 — Stage 1 Bootloader at 0x7C00" {
  class: phase_real

  s3_stack: "Step 3a Stack Setup" {
    class: step_box
    label: "Step 3a: Stack Setup\nFirst instruction of MBR:\n  xor ax, ax\n  mov ss, ax       ; SS = 0\n  mov sp, 0x7C00   ; SP = 0x7C00 (grows down)\nStack occupies 0x7BF0 downward\nSafe: below MBR, above IVT+BDA"
  }

  s3_a20: "Step 3b Enable A20 Line" {
    class: danger
    label: "WARNING: A20 Gate -- Address Line 20\n8086 compatibility: addresses wrapped at 1MB\nIBM PC gated A20 via keyboard controller\nModern hardware: often already enabled\nMethod (BIOS -- most portable):\n  mov ax, 0x2401\n  int 0x15        ; BIOS A20 enable\n  jc a20_error    ; CF=1 = failed\nWithout A20: kernel at 0x100000 is unreachable\n(odd MB addresses alias to first 64KB)"
  }

  s3_int13: "Step 3c INT 13h Disk Read" {
    class: step_box
    label: "Step 3c: BIOS Disk Read (CHS mode)\n  mov ah, 0x02    ; Function: read sectors\n  mov al, 15      ; Count: 15 sectors = 7680 bytes\n  mov ch, 0       ; Cylinder 0\n  mov cl, 2       ; Sector 2 (MBR=1, 1-indexed)\n  mov dh, 0       ; Head 0\n  ; DL = boot drive (set by BIOS)\n  mov bx, 0x7E00  ; Destination: after MBR\n  int 0x13        ; Call BIOS disk service\n  jc disk_error   ; CF=1 = error\n  ; Stage 2 now at physical 0x7E00"
  }

  s3_jump2: "Step 3d Jump to Stage 2" {
    class: safe
    label: "Step 3d: Jump to Stage 2\n  jmp 0x0000:0x7E00\nStage 2 begins execution at physical 0x7E00\nStage 2 has ~7680 bytes to work with\nCS:IP = 0x0000:0x7E00"
  }

  s3_stack -> s3_a20: "Stack ready"
  s3_a20 -> s3_int13: "A20 enabled\n>1MB accessible"
  s3_int13 -> s3_jump2: "Stage 2 loaded\nat 0x7E00"
}

p4: "PHASE 4 — Stage 2: Load Kernel and Configure GDT" {
  class: phase_real

  s4_loadkernel: "Step 4a Load Kernel at 1MB" {
    class: step_box
    label: "Step 4a: Load Kernel to 0x100000 (1MB)\nUses INT 13h extended read (LBA mode):\n  ; DAP (Disk Address Packet) on stack:\n  ; Size=16, Reserved=0, Count=N_sectors\n  ; Dest=0x0000:0x100000 via ES:BX workaround\n  ; LBA_low=kernel_start_sector, LBA_high=0\n  mov ah, 0x42    ; Extended read\n  mov si, dap_ptr ; DS:SI -> DAP\n  int 0x13\nKernel lives above 1MB -- clear of BIOS data\nMust have A20 enabled to reach 0x100000"
  }

  s4_gdt_data: "Step 4b GDT Data Structure" {
    class: addr_box
    label: "Step 4b: GDT Layout (5 entries x 8 bytes = 40 bytes)\n[0x00] Null descriptor  -- required by CPU spec\n[0x08] Kernel code  DPL=0  base=0 lim=4GB  access=0x9A\n[0x10] Kernel data  DPL=0  base=0 lim=4GB  access=0x92\n[0x18] User code    DPL=3  base=0 lim=4GB  access=0xFA\n[0x20] User data    DPL=3  base=0 lim=4GB  access=0xF2\nAccess byte 0x9A = 1001_1010b\n  P=1, DPL=00, S=1, Type=1010 (code, readable)\nGranularity 0xCF = 4KB gran, 32-bit, Lim[19:16]=F"
  }

  s4_gdtr: "Step 4c GDTR Descriptor" {
    class: reg_box
    label: "Step 4c: 6-byte GDTR value\n[0..1] Limit = sizeof(GDT) - 1 = 39\n[2..5] Base  = physical addr of GDT\n  gdt_descriptor:\n    dw gdt_end - gdt_start - 1  ; limit\n    dd gdt_start                 ; base"
  }

  s4_lgdt: "Step 4d lgdt Instruction" {
    class: safe
    label: "Step 4d: lgdt [gdt_descriptor]\nLoads the 6-byte GDTR register\nCPU now knows GDT location and size\nNOT yet using GDT -- still in real mode\nCS/DS/SS still real-mode segment values"
  }

  s4_loadkernel -> s4_gdt_data: "Kernel at 0x100000\nStage 2 builds GDT"
  s4_gdt_data -> s4_gdtr: "GDT structure\ncomplete"
  s4_gdtr -> s4_lgdt: "lgdt loads\nGDTR register"
}

p5: "PHASE 5 — Protected Mode Switch" {
  class: phase_prot

  s5_cli: "Step 5a CLI Disable Interrupts" {
    class: danger
    label: "MANDATORY FIRST STEP\n  cli    ; Clear Interrupt Flag\nEFLAGS.IF = 0 -> hardware IRQs masked\nWhy: IVT at 0x0000 is real-mode only.\nIf timer fires (IRQ0 -> vec 8 = double fault!)\nCPU reads IVT as gate descriptors -> triple fault.\nNo interrupt must fire between cli and sti\n(after protected-mode IDT is loaded)."
  }

  s5_cr0: "Step 5b Set CR0.PE" {
    class: step_box
    label: "Step 5b: Set CR0.PE\n  mov eax, cr0\n  or  eax, 1       ; Set bit 0: PE\n  mov cr0, eax\nCR0 before: 0x60000010 (PE=0, PG=0)\nCR0 after:  0x60000011 (PE=1, PG=0)\nCPU is now in Protected Mode.\nSegmentation hardware active.\nBUT: CS still has old real-mode value!\nPipeline may have prefetched real-mode instrs.\nMust execute far jump IMMEDIATELY."
  }

  s5_farjmp: "Step 5c Far Jump Pipeline Flush" {
    class: safe
    label: "Step 5c: Far Jump -- Pipeline Flush\n  jmp 0x08:protected_mode_32bit\n      ^^^^ kernel code selector = GDT[1]\nThis far jump does TWO critical things:\n1. Loads CS with 0x08 (kernel code segment)\n   CPU looks up GDT[1]: base=0, lim=4GB, DPL=0\n2. Flushes the instruction pipeline\n   Discards real-mode prefetched instructions\n   CPU restarts fetch under protected-mode rules\nWithout this: undefined behavior (pipeline mismatch)\nThis is the point of no return."
  }

  s5_segs: "Step 5d Load Data Segment Registers" {
    class: step_box
    label: "Step 5d: Load Data Segment Registers\n  [bits 32]\n  protected_mode_32bit:\n    mov ax, 0x10     ; kernel data selector = GDT[2]\n    mov ds, ax       ; DS -> kernel data segment\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    mov ss, ax       ; SS -> kernel data segment\n    mov esp, KERNEL_STACK_TOP\nCritical: Until these loads, DS/ES/SS contain\nreal-mode values interpreted as protected-mode\nselectors -> likely null -> GPF on first mem access\nCS was loaded by the far jump.\nSS+ESP: establishes a valid 32-bit stack."
  }

  s5_state: "CPU State After Transition" {
    class: reg_box
    label: "Protected Mode CPU State:\nCS  = 0x08  (kernel code, DPL=0, flat 4GB)\nDS  = 0x10  (kernel data, DPL=0, flat 4GB)\nSS  = 0x10  (kernel stack, DPL=0)\nESP = KERNEL_STACK_TOP\nCR0 = 0x60000011  (PE=1, PG=0)\nEFLAGS = 0x00000002  (IF=0 -- interrupts OFF)\nPaging: disabled (CR0.PG=0)\nVirtual addr = Physical addr (for now)"
  }

  s5_cli -> s5_cr0: "Interrupts masked\nsafe to proceed"
  s5_cr0 -> s5_farjmp: "PE=1 set\nneed CS reload"
  s5_farjmp -> s5_segs: "CS=0x08\npipeline flushed\n[bits 32] begins"
  s5_segs -> s5_state: "All segments\ninitialized"
}

p6: "PHASE 6 — Kernel Entry: BSS Zero and Call kmain()" {
  class: phase_kernel

  s6_bss: "Step 6a Zero the BSS Section" {
    class: step_box
    label: "Step 6a: Zero the BSS Section\nBSS = Block Started by Symbol\nC guarantees global int x; starts at zero.\nELF BSS occupies NO disk space -- linker records only size.\nYOUR kernel must zero it (no OS to do it for you).\n  ; Linker exports these symbols from kernel.ld:\n  ; extern __bss_start\n  ; extern __bss_end\n  kernel_entry:\n    mov edi, __bss_start\n    mov ecx, __bss_end\n    sub ecx, edi          ; byte count\n    xor eax, eax          ; value = 0\n    rep stosd             ; store 4 bytes per iter\n  ; Note: if BSS not mult of 4, use rep stosb\nSkip this -> global int arr[1000] has garbage.\nBug manifests far from cause (used much later)."
  }

  s6_linker: "Linker Script Memory Map" {
    class: addr_box
    label: "kernel.ld -- identity-mapped (virt = phys)\nENTRY(kernel_entry)\nSECTIONS {\n  . = 0x100000;      /* load at 1MB */\n  .text   : { *(.text)   }\n  .rodata : { *(.rodata) }\n  .data   : { *(.data)   }\n  .bss    : {\n    __bss_start = .;\n    *(.bss) *(COMMON)\n    __bss_end = .;\n  }\n}\nBuild steps:\n  i686-elf-gcc -ffreestanding -c kernel.c\n  i686-elf-ld -T kernel.ld -o kernel.elf ...\n  objcopy -O binary kernel.elf kernel.bin"
  }

  s6_verify: "Symbol Address Verification" {
    class: safe
    label: "Verify before running:\n  nm kernel.elf | grep kmain\n  # Should show: 00100000 T kmain (or nearby)\n  objdump -h kernel.elf | grep -E 'Idx|text|bss'\n  # .text VMA should be 0x100000\nIf kernel linked at wrong address:\nall function calls, global accesses -> wrong addrs\n-> immediate triple fault in kmain"
  }

  s6_kmain: "Step 6b Call kmain()" {
    class: safe
    label: "Step 6b: Call kmain()\n  ; Stack is set, BSS is zeroed\n  call kmain        ; Far call to C entry point\n  ; kmain should never return.\n  ; If it does -- halt forever:\n  .hang:\n    cli\n    hlt\n    jmp .hang\nAt this point:\n  32-bit protected mode\n  Flat 4GB address space (seg base=0)\n  Valid stack at KERNEL_STACK_TOP\n  BSS zeroed\n  C calling convention satisfied\nkmain(void) begins executing."
  }

  s6_kmain_c: "kmain() First Actions" {
    class: step_box
    label: "kmain() First Actions:\nvoid kmain(void) {\n  serial_init();       // COM1 debug output\n  vga_clear();         // 0xB8000 cleared\n  kprintf(\"Kernel!\\n\"); // VGA + serial\n  // Milestone 2: IDT, PIC remap, PIT\n  // Milestone 3: PMM, VMM, heap\n  // Milestone 4: processes, scheduler\n  for (;;) { asm(\"hlt\"); }\n}\nVGA buffer at phys 0xB8000 -- MMIO, no cache\nSerial at I/O port 0x3F8 -- port-mapped I/O\nFirst kernel output visible on screen + QEMU stdio"
  }

  s6_bss -> s6_linker: "linker symbols\ndefine BSS range"
  s6_linker -> s6_verify: "verify build\ncorrectness"
  s6_verify -> s6_kmain: "BSS zeroed\ncall kmain"
  s6_kmain -> s6_kmain_c: "C execution\nbegins"
}

memmap: "Physical Address Space at Kernel Entry" {
  style: {
    fill: "#0d1117"
    stroke: "#444c56"
    stroke-width: 1
    font-color: "#8b949e"
    font-size: 11
  }

  m0: "0x00000000-0x000003FF: IVT (256 x 4B vectors)" {
    style: {fill: "#1a1f2e"; stroke: "#3d5a80"; font-color: "#7eb8f7"; font-size: 10}
  }
  m1: "0x00000400-0x000004FF: BIOS Data Area (BDA)" {
    style: {fill: "#1a1f2e"; stroke: "#3d5a80"; font-color: "#7eb8f7"; font-size: 10}
  }
  m2: "0x00007C00-0x00007DFF: Stage 1 MBR (512 bytes)" {
    style: {fill: "#1a2010"; stroke: "#3d6b20"; font-color: "#8dc870"; font-size: 10}
  }
  m3: "0x00007E00-0x00009FFF: Stage 2 bootloader (up to 7.5KB)" {
    style: {fill: "#1a2010"; stroke: "#3d6b20"; font-color: "#8dc870"; font-size: 10}
  }
  m4: "0x0009FC00-0x0009FFFF: Extended BIOS Data (EBDA) -- avoid" {
    style: {fill: "#2d1a0a"; stroke: "#7a5200"; font-color: "#e8a840"; font-size: 10}
  }
  m5: "0x000A0000-0x000BFFFF: VGA frame/text buffers (MMIO)" {
    style: {fill: "#2d0f0f"; stroke: "#f85149"; font-color: "#ff7b72"; font-size: 10}
  }
  m6: "0x000B8000: VGA text mode buffer (80x25 x 2B = 4000B)" {
    style: {fill: "#2d0f0f"; stroke: "#f85149"; font-color: "#ff7b72"; font-size: 10}
  }
  m7: "0x000C0000-0x000FFFFF: Option ROMs + BIOS ROM -- avoid" {
    style: {fill: "#2d1a0a"; stroke: "#7a5200"; font-color: "#e8a840"; font-size: 10}
  }
  m8: "0x00100000: KERNEL LOADS HERE (1MB boundary)" {
    style: {fill: "#0d2016"; stroke: "#2ea043"; font-color: "#56d364"; bold: true; font-size: 10}
  }
  m9: "0x00100000+size: .text .rodata .data .bss sections" {
    style: {fill: "#0d2016"; stroke: "#2ea043"; font-color: "#56d364"; font-size: 10}
  }
  m10: "above kernel: Stack, future heap, page tables" {
    style: {fill: "#1a0f1a"; stroke: "#6b2080"; font-color: "#c880e8"; font-size: 10}
  }
  m11: "0xFEC00000: I/O APIC (MMIO)" {
    style: {fill: "#2d1a0a"; stroke: "#7a5200"; font-color: "#e8a840"; font-size: 10}
  }
  m12: "0xFEE00000: Local APIC (MMIO)" {
    style: {fill: "#2d1a0a"; stroke: "#7a5200"; font-color: "#e8a840"; font-size: 10}
  }
  m13: "0xFFFFFFF0: CPU Reset Vector (ROM, 16 bytes before 4GB)" {
    style: {fill: "#1a1f2e"; stroke: "#3d5a80"; font-color: "#7eb8f7"; font-size: 10}
  }

  m0 -> m1: ""
  m1 -> m2: ""
  m2 -> m3: ""
  m3 -> m4: ""
  m4 -> m5: ""
  m5 -> m6: ""
  m6 -> m7: ""
  m7 -> m8: ""
  m8 -> m9: ""
  m9 -> m10: ""
  m10 -> m11: ""
  m11 -> m12: ""
  m12 -> m13: ""
}

regtimeline: "Register State at Each Phase Boundary" {
  style: {
    fill: "#0d1117"
    stroke: "#444c56"
    stroke-width: 1
    font-color: "#8b949e"
    font-size: 11
  }

  r_reset: "At CPU Reset" {
    class: reg_box
    label: "At CPU Reset\nCS=0xF000 shadow=0xFFFF0000\nIP=0xFFF0 -> phys=0xFFFFFFF0\nCR0=0x60000010 (PE=0)\nIF=0 (interrupts off at reset)\nMode: 16-bit Real"
  }

  r_mbr: "At 0x7C00 MBR Entry" {
    class: reg_box
    label: "At 0x7C00 MBR Entry\nCS=0x0000 IP=0x7C00\nDL=0x80 (boot drive, set by BIOS)\nCR0=0x60000010 (PE=0)\nSS=??? SP=??? UNDEFINED\nMode: 16-bit Real"
  }

  r_stage2: "At 0x7E00 Stage 2 Entry" {
    class: reg_box
    label: "At 0x7E00 Stage 2 Entry\nCS=0x0000 IP=0x7E00\nSS=0x0000 SP=0x7C00 (set by Stage 1)\nDL=0x80 (preserved from BIOS)\nCR0=0x60000010 (PE=0)\nMode: 16-bit Real"
  }

  r_afterlgdt: "After lgdt Before CR0 Write" {
    class: reg_box
    label: "After lgdt Before CR0 Write\nGDTR.base = addr of gdt_data\nGDTR.limit = 39 (5 entries)\nCR0=0x60000010 (PE still 0)\nIF=0 (cli executed)\nGDT loaded but not yet active\nSegment registers still real-mode"
  }

  r_prot: "After Far Jump Protected Mode" {
    class: reg_box
    label: "After Far Jump -- Protected Mode\nCS=0x08 (GDT[1]: code, DPL=0, base=0)\nDS=ES=FS=GS=SS=0x10\nESP=KERNEL_STACK_TOP\nCR0=0x60000011 (PE=1, PG=0)\nIF=0 (still disabled)\nMode: 32-bit Protected, No Paging"
  }

  r_kmain: "At kmain() Entry" {
    class: reg_box
    label: "At kmain() Entry\nCS=0x08 DS=0x10 SS=0x10\nESP=valid stack pointer\nCR0=0x60000011 (PG=0 until M3)\nIF=0 (until sti after IDT setup)\nBSS zeroed, C environment ready\nMode: 32-bit Protected Flat"
  }

  r_reset -> r_mbr: "BIOS POST\ncomplete"
  r_mbr -> r_stage2: "Stage 1 loads\nStage 2, jmp"
  r_stage2 -> r_afterlgdt: "lgdt + cli\nexecuted"
  r_afterlgdt -> r_prot: "CR0.PE=1\nfar jmp 0x08:..."
  r_prot -> r_kmain: "BSS zeroed\ncall kmain"
}

pitfalls: "Common Triple-Fault Points" {
  style: {
    fill: "#1a0a0a"
    stroke: "#f85149"
    stroke-width: 2
    font-color: "#ff7b72"
    font-size: 11
  }

  pf1: "Pitfall 1: PIC not remapped before sti" {
    class: danger
    label: "WARNING: PIC not remapped before sti\nDefault: IRQ0 (timer) -> CPU vector 8 = double fault\nFirst tick fires -> double fault handler -> triple fault\nFix: remap PIC to vectors 32-47 before sti"
  }

  pf2: "Pitfall 2: No far jump after CR0.PE" {
    class: danger
    label: "WARNING: No far jump after CR0.PE\nCPU pipeline prefetched real-mode instructions\nUndefined behavior in protected mode execution\nFix: jmp 0x08:label immediately after CR0 write"
  }

  pf3: "Pitfall 3: Segment regs not reloaded" {
    class: danger
    label: "WARNING: Segment regs not reloaded after far jump\nCS loaded by far jump; DS/ES/SS still real-mode\nFirst memory access -> null descriptor -> GPF\nFix: mov ax,0x10; mov ds,ax etc. after jmp"
  }

  pf4: "Pitfall 4: BSS not zeroed" {
    class: danger
    label: "WARNING: BSS not zeroed\nGlobal int x = 0; may contain RAM garbage\nC standard requires zero-init; libc normally does it\nFix: rep stosd from __bss_start to __bss_end"
  }

  pf5: "Pitfall 5: A20 not enabled" {
    class: danger
    label: "WARNING: A20 not enabled\nKernel at 0x100000: odd-MB addresses wrap to 0x00000\nReads from 0x100000 return bytes at 0x000000 (IVT!)\nFix: BIOS INT 15h AX=0x2401 in Stage 2"
  }

  pf6: "Pitfall 6: Linker address mismatch" {
    class: danger
    label: "WARNING: Linker address mismatch\nKernel linked at 0x200000 but loaded at 0x100000\nAll absolute addresses off by 0x100000\nFix: nm kernel.elf | grep kmain -> must show 0x100xxx"
  }
}

p0 -> p1: "0xFFFFFFF0 -> firmware runs POST\n(real mode, CS shadow covers ROM)"
p1 -> p2: "POST complete\nBIOS searches for bootable disk"
p2 -> p3: "MBR valid (0x55 0xAA)\nBIOS jmp 0x0000:0x7C00\nDL = drive number"
p3 -> p4: "jmp 0x0000:0x7E00\nStage 2 running\nall real-mode setup done"
p4 -> p5: "Kernel binary at 0x100000\nGDT built, lgdt executed\ncli: interrupts masked"
p5 -> p6: "CS=0x08, DS=0x10, SS=0x10\nESP set, CR0.PE=1\n32-bit protected mode active"
p6 -> memmap: "Runtime layout\nestablished"
p6 -> regtimeline: "Register state\ntimeline reference"
p5 -> pitfalls: "Most triple faults\noccur in this phase"
p6 -> pitfalls: "BSS and linker\npitfalls here"