vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: down

title: |md
  # MBR and Disk Layout: Two-Stage Bootloader
  512-byte hard constraint drives the two-stage strategy
| {near: top-center}

disk: Physical Disk Layout {
  style: {
    fill: "#1a1a2e"
    stroke: "#4a4a8a"
    stroke-width: 3
    font-color: "#aaaaff"
    bold: true
    font-size: 16
  }

  sector0: Sector 0 — MBR (LBA 0, 512 bytes total) {
    style: {
      fill: "#16213e"
      stroke: "#e94560"
      stroke-width: 2
      font-color: "#e94560"
      bold: true
      font-size: 14
    }

    bootstrap_code: Stage 1 Bootstrap Code — 446 bytes (offsets 0x000-0x1BD) {
      style: {
        fill: "#c0392b"
        stroke: "#e74c3c"
        stroke-width: 2
        font-color: white
        bold: true
        font-size: 13
        border-radius: 4
        multiple: true
      }
    }

    bootstrap_detail: |md
      **[org 0x7C00] — BIOS loads here**
      - Stack setup: SS=0, SP=0x7C00
      - DS/ES = 0 (segment base = 0)
      - INT 13h AH=02h: read Stage 2 sectors
      - JMP 0x7E00 (immediately after MBR)
      - Disk error handler + message
      - Padding: `times 446-($-$$) db 0`
    | {
      style: {
        fill: "#7b241c"
        stroke: "#e74c3c"
        font-color: "#fadbd8"
        font-size: 12
      }
    }

    partition_table: Partition Table — 64 bytes (offsets 0x1BE-0x1FD) {
      style: {
        fill: "#6c3483"
        stroke: "#9b59b6"
        stroke-width: 2
        font-color: white
        bold: true
        font-size: 12
        border-radius: 4
      }
    }

    pt_entry_detail: |md
      **4 entries x 16 bytes each:**
      Byte 0: Status (0x80=bootable, 0x00=inactive)
      Bytes 1-3: CHS Start address
      Byte 4: Partition type (0x83=Linux ext4)
      Bytes 5-7: CHS End address
      Bytes 8-11: LBA Start (little-endian u32)
      Bytes 12-15: Sector count (little-endian u32)
    | {
      style: {
        fill: "#4a235a"
        stroke: "#9b59b6"
        font-color: "#e8daef"
        font-size: 11
      }
    }

    boot_sig: Boot Signature — 2 bytes (offsets 0x1FE-0x1FF) {
      style: {
        fill: "#d4ac0d"
        stroke: "#f1c40f"
        stroke-width: 2
        font-color: "#1a1a00"
        bold: true
        font-size: 13
        border-radius: 4
      }
    }

    sig_detail: |md
      **Byte 510 = 0x55, Byte 511 = 0xAA**
      NASM: `dw 0xAA55` (little-endian stores 0x55 first)
      BIOS hard-checks before jumping to 0x7C00
      Missing or wrong value = BIOS skips this disk
      `times 510-($-$$) db 0` pads to exact offset
    | {
      style: {
        fill: "#7d6608"
        stroke: "#f1c40f"
        font-color: "#fef9e7"
        font-size: 11
      }
    }

    bootstrap_code -> bootstrap_detail: "contents (446 bytes max)"
    bootstrap_code -> partition_table: "immediately follows at offset 0x1BE"
    partition_table -> pt_entry_detail: "entry structure x4"
    partition_table -> boot_sig: "immediately follows at offset 0x1FE"
    boot_sig -> sig_detail: "BIOS validation requirement"
  }

  stage2_sectors: Sectors 1-15 — Stage 2 Bootloader (7680 bytes = 15 x 512) {
    style: {
      fill: "#16213e"
      stroke: "#27ae60"
      stroke-width: 2
      font-color: "#27ae60"
      bold: true
      font-size: 14
    }

    s2_load: Loaded to 0x7E00 by Stage 1 via INT 13h AH=02h {
      style: {
        fill: "#145a32"
        stroke: "#27ae60"
        stroke-width: 2
        font-color: "#d5f5e3"
        bold: true
        font-size: 12
        border-radius: 4
      }
    }

    s2_tasks: |md
      **[org 0x7E00] — no size constraint**
      Stage 2 responsibilities (in order):
      1. Enable A20 line (INT 15h AX=2401h) ~50 bytes
      2. Query E820 memory map (INT 15h AX=E820h) ~80 bytes
      3. Load kernel to 0x100000 via INT 13h ext LBA ~60 bytes
      4. Build GDT in memory + lgdt instruction ~50 bytes
      5. cli; set CR0.PE=1; far jmp to 32-bit code
      6. Load DS/ES/FS/GS/SS = 0x10 (kernel data)
      7. Zero BSS; set ESP; call kmain()
      **Total: ~5-15 KB — impossible in 446 bytes**
    | {
      style: {
        fill: "#0e3d25"
        stroke: "#27ae60"
        font-color: "#a9dfbf"
        font-size: 12
      }
    }
  }

  kernel_sectors: Sectors 16+ — Kernel Flat Binary {
    style: {
      fill: "#16213e"
      stroke: "#3498db"
      stroke-width: 2
      font-color: "#3498db"
      bold: true
      font-size: 14
    }

    k_load: Loaded to physical 0x100000 (1 MB mark) by Stage 2 {
      style: {
        fill: "#154360"
        stroke: "#3498db"
        stroke-width: 2
        font-color: "#d6eaf8"
        bold: true
        font-size: 12
        border-radius: 4
        shadow: true
      }
    }

    k_layout: |md
      **objcopy -O binary kernel.elf kernel.bin**
      On-disk order matches in-memory layout:
      .text   — executable code (entry at offset 0)
      .rodata — string literals, const tables
      .data   — initialized globals
      (BSS not stored: zero-filled by Stage 2 at runtime)

      Stage 2 reads N sectors = ceil(kernel_size / 512)
      Writes sequentially: 0x100000, 0x100200, 0x100400...
    | {
      style: {
        fill: "#0d2d45"
        stroke: "#3498db"
        font-color: "#aed6f1"
        font-size: 12
      }
    }
  }

  sector0 -> stage2_sectors: "INT 13h AH=02h: CL=2 (sector 2), AL=15 (count)\nES:BX = 0x0000:0x7E00 → physical 0x7E00\nStage1 jmp 0x7E00 on success"
  stage2_sectors -> kernel_sectors: "INT 13h AH=42h: LBA Disk Address Packet\nDAP.dest = 0x1000:0x0000 = physical 0x10000\nActual target: 0x100000 via segment trick"
}

bios_mechanics: BIOS Load Mechanics and org Directive {
  style: {
    fill: "#1c1c1c"
    stroke: "#e67e22"
    stroke-width: 2
    font-color: "#e67e22"
    bold: true
    font-size: 15
  }

  bios_action: BIOS loads MBR to physical 0x7C00 {
    style: {
      fill: "#784212"
      stroke: "#e67e22"
      stroke-width: 2
      font-color: "#fdebd0"
      bold: true
      font-size: 13
      border-radius: 4
      shadow: true
    }
  }

  org_effect: org 0x7C00 in NASM {
    style: {
      fill: "#1b2631"
      stroke: "#5dade2"
      stroke-width: 2
      font-color: "#aed6f1"
      bold: true
      font-size: 13
      border-radius: 4
      font: mono
    }
  }

  org_explain: |md
    **What org 0x7C00 does:**
    Tells assembler: assume this file's first byte
    is located at virtual address 0x7C00

    All symbol addresses are offset from 0x7C00:
    - `jmp boot_start` resolves to e.g. 0x7C05
    - `mov si, err_msg` resolves to e.g. 0x7C3A
    - `lgdt [gdt_ptr]` resolves to e.g. 0x7C80

    **Without org 0x7C00:**
    Symbols resolved from 0x0000
    jmp boot_start resolves to 0x0005
    CPU fetches from wrong address → triple fault
    Every label reference is wrong by 0x7C00
  | {
    style: {
      fill: "#17202a"
      stroke: "#5dade2"
      font-color: "#d6eaf8"
      font-size: 12
    }
  }

  s2_org: org 0x7E00 for Stage 2 {
    style: {
      fill: "#1b2631"
      stroke: "#27ae60"
      stroke-width: 2
      font-color: "#a9dfbf"
      bold: true
      font-size: 13
      border-radius: 4
      font: mono
    }
  }

  bios_action -> org_effect: "BIOS jump to 0x7C00\nmakes all org-computed addresses correct"
  org_effect -> org_explain: "assembler arithmetic consequence"
  bios_action -> s2_org: "Stage1 loads Stage2 to 0x7E00\nStage2 assembled with org 0x7E00\n(same principle)"
}

addressing: INT 13h Addressing Modes {
  style: {
    fill: "#1c1c1c"
    stroke: "#9b59b6"
    stroke-width: 2
    font-color: "#9b59b6"
    bold: true
    font-size: 15
  }

  chs_mode: CHS — Cylinder-Head-Sector (INT 13h AH=02h) {
    style: {
      fill: "#4a235a"
      stroke: "#9b59b6"
      stroke-width: 2
      font-color: "#e8daef"
      bold: true
      font-size: 13
      border-radius: 4
    }
  }

  chs_detail: |md
    **Used by Stage 1 (simpler, always available)**
    Formula: LBA = (C x Hmax + H) x Smax + (S-1)

    Register protocol for INT 13h AH=02h:
    AH = 0x02 (read sectors function)
    AL = sector count to read
    CH = cylinder bits [7:0]
    CL[7:6] = cylinder bits [9:8], CL[5:0] = sector (1-indexed!)
    DH = head number
    DL = drive number (0x80 = first hard disk)
    ES:BX = destination buffer address

    Max addressable: 1023 cylinders x 255 heads x 63 sectors
    Limit: approximately 8 GB — sufficient for bootloader
    Sectors are 1-indexed (CL=1 = sector 1 = MBR itself)
  | {
    style: {
      fill: "#2e1553"
      stroke: "#9b59b6"
      font-color: "#d7bde2"
      font-size: 11
    }
  }

  lba_mode: LBA — Logical Block Address Extended (INT 13h AH=42h) {
    style: {
      fill: "#1a5276"
      stroke: "#3498db"
      stroke-width: 2
      font-color: "#d6eaf8"
      bold: true
      font-size: 13
      border-radius: 4
    }
  }

  lba_detail: |md
    **Used by Stage 2 for kernel load (handles large kernels)**
    Requires Disk Address Packet (DAP) in memory:

    Offset Size  Field
    0x00   1B    DAP size = 0x10 (16 bytes)
    0x01   1B    Reserved = 0x00
    0x02   2B    Sectors to read (little-endian)
    0x04   2B    Destination buffer offset
    0x06   2B    Destination buffer segment
    0x08   8B    LBA start sector (64-bit little-endian)

    DS:SI points to DAP; AH=0x42; DL=drive number
    Segment:Offset 0x1000:0x0000 = physical 0x10000
    Use 0xFFFF:0x0010 trick for physical 0x100000
    Supports 48-bit LBA: up to 128 PiB
  | {
    style: {
      fill: "#154360"
      stroke: "#3498db"
      font-color: "#aed6f1"
      font-size: 11
      font: mono
    }
  }

  chs_mode -> chs_detail: "register protocol"
  lba_mode -> lba_detail: "DAP packet structure"
}

memmap: Physical Memory Map After Bootload (real mode, before paging) {
  style: {
    fill: "#1c1c1c"
    stroke: "#2ecc71"
    stroke-width: 2
    font-color: "#2ecc71"
    bold: true
    font-size: 15
  }

  m_ivt: "0x00000 - 0x003FF | 1 KB | Real-mode IVT — 256 x 4-byte far pointers" {
    style: { fill: "#616a6b"; stroke: "#aab7b8"; font-color: "#e8e8e8"; font-size: 12; border-radius: 2 }
  }
  m_bda: "0x00400 - 0x004FF | 256 B | BIOS Data Area — hardware state tables" {
    style: { fill: "#616a6b"; stroke: "#aab7b8"; font-color: "#e8e8e8"; font-size: 12; border-radius: 2 }
  }
  m_free_low: "0x00500 - 0x07BFF | ~30 KB | Free — usable for Stage 1 stack" {
    style: { fill: "#1e8449"; stroke: "#27ae60"; font-color: "#d5f5e3"; font-size: 12; border-radius: 2 }
  }
  m_mbr: "0x07C00 - 0x07DFF | 512 B | MBR Stage 1 [org 0x7C00] — BIOS loads here" {
    style: {
      fill: "#c0392b"
      stroke: "#e74c3c"
      font-color: white
      bold: true
      font-size: 12
      border-radius: 4
    }
  }
  m_s2: "0x07E00 - 0x0BFFF | ~16 KB | Stage 2 [org 0x7E00] — Stage 1 loads here" {
    style: {
      fill: "#1a5632"
      stroke: "#27ae60"
      font-color: "#a9dfbf"
      bold: true
      font-size: 12
      border-radius: 4
    }
  }
  m_ebda: "0x80000 - 0x9FFFF | 128 KB | EBDA — Extended BIOS Data Area, avoid!" {
    style: { fill: "#7d6608"; stroke: "#f1c40f"; font-color: "#fef9e7"; font-size: 12; border-radius: 2 }
  }
  m_vga_fb: "0xA0000 - 0xB7FFF | 96 KB | VGA graphics framebuffer — MMIO uncached" {
    style: { fill: "#512e5f"; stroke: "#8e44ad"; font-color: "#e8daef"; font-size: 12; border-radius: 2 }
  }
  m_vga_txt: "0xB8000 - 0xB8F9F | 4 KB | VGA text buffer — kprintf MMIO target" {
    style: {
      fill: "#6c3483"
      stroke: "#af7ac5"
      font-color: white
      bold: true
      font-size: 12
      border-radius: 4
    }
  }
  m_rom: "0xC0000 - 0xFFFFF | 256 KB | Video BIOS + System BIOS ROM — not RAM" {
    style: { fill: "#424949"; stroke: "#717d7e"; font-color: "#d5d8dc"; font-size: 12; border-radius: 2 }
  }
  m_a20_barrier: "--- 1 MB BARRIER: A20 line must be enabled to address above here ---" {
    style: {
      fill: "#7b241c"
      stroke: "#e74c3c"
      stroke-dash: 5
      font-color: "#f1948a"
      bold: true
      font-size: 12
    }
  }
  m_kernel: "0x100000+ | Kernel binary — Stage 2 loads flat binary here via INT 13h LBA" {
    style: {
      fill: "#154360"
      stroke: "#3498db"
      font-color: "#aed6f1"
      bold: true
      font-size: 13
      border-radius: 4
      shadow: true
    }
  }

  m_ivt -> m_bda: "contiguous"
  m_bda -> m_free_low: "contiguous"
  m_free_low -> m_mbr: "BIOS loads MBR here"
  m_mbr -> m_s2: "jmp 0x7E00 after INT 13h load"
  m_s2 -> m_ebda: "gap (usable for Stage 2 data)"
  m_ebda -> m_vga_fb: "hardware boundary"
  m_vga_fb -> m_vga_txt: "sub-range within VGA region"
  m_vga_txt -> m_rom: "contiguous"
  m_rom -> m_a20_barrier: "end of first megabyte"
  m_a20_barrier -> m_kernel: "A20 enabled by Stage 2\nbefore loading kernel here"
}

strategy: Two-Stage Strategy — Why 446 Bytes Forces the Split {
  style: {
    fill: "#1c1c1c"
    stroke: "#e67e22"
    stroke-width: 3
    font-color: "#e67e22"
    bold: true
    font-size: 15
  }

  constraint_box: The 512-Byte Hard Constraint {
    style: {
      fill: "#922b21"
      stroke: "#e74c3c"
      stroke-width: 2
      font-color: white
      bold: true
      font-size: 14
      border-radius: 6
      shadow: true
    }
  }

  what_fits: |md
    **What fits in 446 bytes (Stage 1 budget):**
    Stack setup + segment init: ~15 bytes
    INT 13h CHS read of Stage 2: ~25 bytes
    Error handler + message: ~40 bytes
    JMP to Stage 2: ~3 bytes
    Padding to 510 bytes: automatic
    Boot signature dw 0xAA55: 2 bytes
    **Total comfortable: ~83 bytes used, 363 spare**

    **What CANNOT fit alongside Stage 1:**
    A20 enablement (INT 15h method): ~50 bytes
    E820 memory map query loop: ~80 bytes
    GDT table (5 entries x 8 bytes) + lgdt: ~60 bytes
    Protected mode switch + far jump: ~30 bytes
    Segment register reload (6 registers): ~20 bytes
    INT 13h LBA DAP structure + read loop: ~60 bytes
    BSS zero loop + kmain call: ~25 bytes
    **Would-be total: ~325 bytes — over budget by 2x**
    **(and this ignores any real kernel format parsing)**
  | {
    style: {
      fill: "#641e16"
      stroke: "#e74c3c"
      font-color: "#fadbd8"
      font-size: 12
    }
  }

  solution_box: Two-Stage Solution {
    style: {
      fill: "#1a5276"
      stroke: "#2980b9"
      stroke-width: 2
      font-color: white
      bold: true
      font-size: 14
      border-radius: 6
      shadow: true
    }
  }

  solution_detail: |md
    **Stage 1 (exactly 512 bytes on disk):**
    Single job: load Stage 2 from sectors 1-N
    Uses CHS INT 13h (simplest, no DAP needed)
    Rarely modified — stable, minimal, trusted

    **Stage 2 (N x 512 bytes, no limit):**
    Full bootloader: A20 + E820 + GDT + PM + kernel load
    Can be 4 KB, 15 KB, or 64 KB as needed
    Easily extended: add VESA, config parsing, etc.

    **Analogy — GRUB architecture:**
    boot.img = Stage 1 (512 bytes, MBR)
    core.img = Stage 2 (30-50 KB, sectors 1-63)
    Normal GRUB = Stage 3 loaded from filesystem

    **The invariant:** Stage 1 is never the bottleneck
    Stage 2 can grow arbitrarily with the kernel
  | {
    style: {
      fill: "#154360"
      stroke: "#2980b9"
      font-color: "#d6eaf8"
      font-size: 12
    }
  }

  nasm_skeleton: |md
    Stage 1 NASM skeleton — 446 bytes budget

    [org 0x7C00]
    [bits 16]
    start:
        xor ax, ax
        mov ds, ax
        mov es, ax
        mov ss, ax
        mov sp, 0x7C00

        mov ah, 0x02
        mov al, 15
        mov ch, 0
        mov cl, 2
        mov dh, 0
        mov bx, 0x7E00
        int 0x13
        jc .error
        jmp 0x7E00

    .error:
        mov si, msg
    .loop: lodsb
        or al, al
        jz .halt
        mov ah, 0x0E
        int 0x10
        jmp .loop
    .halt: cli; hlt
    msg db "Disk error", 0

    times 510-($-$$) db 0
    dw 0xAA55
  | {
    style: {
      fill: "#1c2833"
      stroke: "#566573"
      font-color: "#d5d8dc"
      font-size: 11
      font: mono
    }
  }

  constraint_box -> what_fits: "byte budget analysis"
  constraint_box -> solution_box: "motivates the split"
  solution_box -> solution_detail: "architectural consequences"
  solution_box -> nasm_skeleton: "reference implementation"
}

disk -> bios_mechanics: "BIOS reads sector 0, validates 0x55AA\njumps to physical 0x7C00"
disk -> addressing: "INT 13h modes used at each stage"
disk -> memmap: "all load targets in physical address space"
disk -> strategy: "why two stages are architecturally necessary"
bios_mechanics -> strategy: "org directive bridges BIOS load address\nto assembler symbol resolution"