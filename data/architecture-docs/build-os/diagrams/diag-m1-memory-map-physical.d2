Looking at the errors, the issues are:
1. **"unexpected text after md block string"** - The `|md ... |` blocks inside containers that are used as *values* (like `ivt_content: |md ... |`) need to use the node label syntax properly. The content nodes like `ivt_content: |md ... |` inside a container are fine, but the problem is these nodes are inside containers that have styles, and D2 is choking on the md block strings in certain contexts.
2. **"key length exceeds maximum"** - Long node keys (the label strings used as keys like `"IVT 0x0000-0x03FF"`) exceed 518 chars. Wait, these are short - the issue is the *content* of md blocks being parsed as keys.
3. The root cause: when `|md ... |` is used as a node value (`ivt_content: |md ... |`), and that node is inside a container, D2 is treating subsequent lines as continuation. The `|md` blocks need the content to not have lines that look like D2 syntax.
4. **"unexpected text after map key"** - The `seq_*` node labels contain `\n` in quoted strings used as keys - these work, but the connection labels with `\n` and quoted strings may cause issues.
The main fixes: Replace `|md ... |` content blocks with `shape: text` nodes using plain labels, and shorten/simplify the md blocks using `|||md ... |||` or `|` `` ` `` `md` to avoid pipe conflicts. Also fix the long key names for sequence nodes.
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Physical Memory Map — First 16 MB at Boot (x86 Real Mode → Protected Mode)
  **Color Key:** Reserved/Dangerous · BIOS/Firmware · Bootloader · Safe/Usable · MMIO
| {near: top-center}
back_to_map: "Satellite Map (diag-satellite-os-map)" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#1a1a2e"
    font-color: "#e0e0ff"
    stroke: "#5555cc"
    stroke-width: 2
    border-radius: 6
    font-size: 12
  }
}
legend: {
  label: "LEGEND"
  style: {
    fill: "#1e1e2e"
    stroke: "#444466"
    font-color: "#ccccff"
    border-radius: 8
  }
  l_reserved: "BIOS/HW Reserved — DO NOT WRITE" {
    style.fill: "#3d0000"
    style.font-color: "#ff8888"
    style.border-radius: 4
  }
  l_firmware: "Firmware Data — Read Only at Runtime" {
    style.fill: "#2d2200"
    style.font-color: "#ffdd88"
    style.border-radius: 4
  }
  l_bootloader: "Bootloader Region — Temporary Use" {
    style.fill: "#001a3d"
    style.font-color: "#88aaff"
    style.border-radius: 4
  }
  l_usable: "General Use RAM — Safe to Allocate" {
    style.fill: "#003d00"
    style.font-color: "#88ff88"
    style.border-radius: 4
  }
  l_mmio: "Memory-Mapped I/O — volatile access only" {
    style.fill: "#2d003d"
    style.font-color: "#cc88ff"
    style.border-radius: 4
  }
  l_hole: "Address Space Hole — nothing mapped" {
    style.fill: "#1a1a1a"
    style.font-color: "#888888"
    style.border-radius: 4
  }
}
phys_map: "PHYSICAL ADDRESS SPACE (0x00000000 to 0x00FFFFFF : First 16 MB)" {
  style: {
    fill: "#0d0d1a"
    stroke: "#3333aa"
    stroke-width: 3
    border-radius: 10
    font-color: "#aaaaee"
  }
  r_ivt: "IVT — 0x0000-0x03FF" {
    style: {
      fill: "#2a0000"
      stroke: "#880000"
      font-color: "#ffaaaa"
      border-radius: 4
    }
    ivt_meta: "1 KB | Interrupt Vector Table | RESERVED — DO NOT WRITE" {
      style: {
        fill: "#1a0000"
        stroke: "#660000"
        font-color: "#cc8888"
        border-radius: 4
      }
    }
    ivt_detail: |md
      256 x 4-byte real-mode interrupt vectors.
      Format: OFFSET:16 / SEGMENT:16.
      Installed by BIOS at POST.
      After protected mode, IDT replaces this.
      Writing here while BIOS active causes triple-fault.
    | {
      style: {
        fill: "#1a0000"
        stroke: "#660000"
        font-color: "#ffbbbb"
        border-radius: 4
      }
    }
  }
  r_bda: "BDA — 0x0400-0x04FF" {
    style: {
      fill: "#2a1500"
      stroke: "#885500"
      font-color: "#ffcc88"
      border-radius: 4
    }
    bda_meta: "256 B | BIOS Data Area | BIOS DATA — Read-only useful" {
      style: {
        fill: "#1a0d00"
        stroke: "#664400"
        font-color: "#cc9966"
        border-radius: 4
      }
    }
    bda_detail: |md
      BIOS stores hardware state here.
      0x0413: Conventional memory size in KB.
      0x046C: Timer tick counter at 18.2 Hz.
      0x0417: Keyboard shift-state flags.
      COM/LPT port addresses stored here.
      Read before protected mode switch.
    | {
      style: {
        fill: "#1a0d00"
        stroke: "#664400"
        font-color: "#ffddaa"
        border-radius: 4
      }
    }
  }
  r_conv1: "CONV1 — 0x0500-0x7BFF" {
    style: {
      fill: "#003300"
      stroke: "#006600"
      font-color: "#88ff88"
      border-radius: 4
    }
    conv1_meta: "~30 KB | Low Conventional RAM | USABLE — Stage-1 stack here" {
      style: {
        fill: "#002200"
        stroke: "#005500"
        font-color: "#66cc66"
        border-radius: 4
      }
    }
    conv1_detail: |md
      General-purpose usable RAM.
      Used by stage-1 stack during boot.
      SP = 0x7C00, grows downward into here.
      Stage-1 stack occupies ~0x7B00-0x7BFF.
      E820 type=1 (usable). Safe for PMM after boot.
    | {
      style: {
        fill: "#002200"
        stroke: "#005500"
        font-color: "#aaffaa"
        border-radius: 4
      }
    }
  }
  r_mbr: "MBR — 0x7C00-0x7DFF" {
    style: {
      fill: "#00113d"
      stroke: "#003388"
      font-color: "#88aaff"
      border-radius: 4
    }
    mbr_meta: "512 B | Stage-1 Bootloader (MBR) | BOOTLOADER — BIOS jumps here" {
      style: {
        fill: "#000d2a"
        stroke: "#002266"
        font-color: "#6688cc"
        border-radius: 4
      }
    }
    mbr_detail: |md
      BIOS loads 512-byte MBR here from disk sector 0.
      BIOS magic check: bytes 510-511 must = 0x55 0xAA.
      Executes at 0x0000:0x7C00 (physical 0x7C00).
      Contains: A20 attempt, stage-2 load via INT 13h,
      minimal stack setup, boot signature.
      510 bytes of actual code maximum.
    | {
      style: {
        fill: "#000d2a"
        stroke: "#002266"
        font-color: "#aabbff"
        border-radius: 4
      }
    }
  }
  r_stage2: "STAGE2 — 0x7E00-0x9FBFF" {
    style: {
      fill: "#001133"
      stroke: "#002266"
      font-color: "#99bbff"
      border-radius: 4
    }
    stage2_meta: "~120 KB | Stage-2 Loader + Free Conventional RAM | BOOTLOADER + Free RAM" {
      style: {
        fill: "#000d22"
        stroke: "#001a44"
        font-color: "#7799cc"
        border-radius: 4
      }
    }
    stage2_detail: |md
      Stage-2 loaded by MBR at 0x7E00 (right after MBR).
      Stage-2 code: GDT setup, full A20 enable (3 methods),
      E820 memory map query, kernel copy to 0x100000,
      protected-mode switch + far jump.
      Above stage-2: free conventional memory (~120 KB).
      GRUB stage-2 also lives here.
    | {
      style: {
        fill: "#000d22"
        stroke: "#001a44"
        font-color: "#bbccff"
        border-radius: 4
      }
    }
  }
  r_ebda: "EBDA — 0x9FC00-0x9FFFF" {
    style: {
      fill: "#2a1500"
      stroke: "#885500"
      font-color: "#ffcc88"
      border-radius: 4
    }
    ebda_meta: "1 KB | Extended BIOS Data Area | RESERVED — E820 type=2" {
      style: {
        fill: "#1a0d00"
        stroke: "#664400"
        font-color: "#cc9966"
        border-radius: 4
      }
    }
    ebda_detail: |md
      Additional BIOS data: keyboard buffer, ACPI tables,
      disk parameters, PnP BIOS data.
      Address varies! Check 0x040E (BDA) for actual base.
      E820 reports as type=2 (reserved).
      Do not use for kernel data.
    | {
      style: {
        fill: "#1a0d00"
        stroke: "#664400"
        font-color: "#ffddaa"
        border-radius: 4
      }
    }
  }
  r_vga_mmio: "VGAMMIO — 0xA0000-0xB7FFF" {
    style: {
      fill: "#1a0033"
      stroke: "#550088"
      font-color: "#cc88ff"
      border-radius: 4
    }
    vga_mmio_meta: "96 KB | VGA Graphics Framebuffer (MMIO) | MMIO — Not for data" {
      style: {
        fill: "#110022"
        stroke: "#440066"
        font-color: "#aa66cc"
        border-radius: 4
      }
    }
    vga_mmio_detail: |md
      VGA graphics mode framebuffer.
      Direct writes produce pixels on screen (graphics modes).
      Not used by text-mode kernel (use 0xB8000 instead).
      Memory-mapped: writes go to VGA card RAM, not DRAM.
      Requires volatile pointer for all accesses.
      E820 type=2 (reserved).
    | {
      style: {
        fill: "#110022"
        stroke: "#440066"
        font-color: "#ddbbff"
        border-radius: 4
      }
    }
  }
  r_vga_text: "VGATXT — 0xB8000-0xB8F9F" {
    style: {
      fill: "#2a0044"
      stroke: "#8800cc"
      font-color: "#ee99ff"
      border-radius: 4
      bold: true
    }
    vga_text_meta: "4000 B (80x25x2) | VGA Text Mode Buffer — YOUR TERMINAL | USE THIS" {
      style: {
        fill: "#1a0033"
        stroke: "#660099"
        font-color: "#cc77ee"
        border-radius: 4
      }
    }
    vga_text_detail: |md
      volatile uint16_t VGA = (uint16_t)0xB8000
      Layout: 80 columns x 25 rows x 2 bytes per cell.
      Each cell: color_attr:8 / ascii_char:8.
      Color byte: bg:4 / fg:4 (nibbles).
      Write char A white-on-black at row 0 col 0:
      VGA[0] = (0x0F << 8) | 'A'
      volatile MANDATORY: compiler must not optimize writes.
      Higher-half: mapped at 0xC00B8000 after paging.
    | {
      style: {
        fill: "#1a0033"
        stroke: "#660099"
        font-color: "#ffccff"
        border-radius: 4
      }
    }
  }
  r_vga_rest: "VGARST — 0xB9000-0xBFFFF" {
    style: {
      fill: "#1a0033"
      stroke: "#550088"
      font-color: "#cc88ff"
      border-radius: 4
    }
    vga_rest_meta: "28 KB | VGA Attribute Controller / CGA Mirror | MMIO — E820 type=2" {
      style: {
        fill: "#110022"
        stroke: "#440066"
        font-color: "#aa66cc"
        border-radius: 4
      }
    }
    vga_rest_detail: |md
      Remainder of VGA MMIO window.
      Monochrome adapter at 0xB0000-0xB7FFF (CGA mirror).
      Additional VGA memory pages for some modes.
      E820 type=2. Not usable as RAM.
    | {
      style: {
        fill: "#110022"
        stroke: "#440066"
        font-color: "#ddbbff"
        border-radius: 4
      }
    }
  }
  r_bios_rom: "BIOSROM — 0xC0000-0xFFFFF" {
    style: {
      fill: "#2a0000"
      stroke: "#880000"
      font-color: "#ffaaaa"
      border-radius: 4
    }
    bios_rom_meta: "256 KB | BIOS ROM + Option ROMs | DO NOT WRITE — Reset vector 0xFFFF0" {
      style: {
        fill: "#1a0000"
        stroke: "#660000"
        font-color: "#cc8888"
        border-radius: 4
      }
    }
    bios_rom_detail: |md
      0xC0000-0xC7FFF: VGA Option ROM (video BIOS).
      0xC8000-0xEFFFF: Other Option ROMs (NIC, RAID, etc.).
      0xF0000-0xFFFFF: System BIOS ROM.
      Last 16 bytes at 0xFFFF0: Reset vector (CPU starts here).
      E820 type=2. Shadow-copied to RAM on some systems.
      Writing here causes undefined behavior / ROM fault.
    | {
      style: {
        fill: "#1a0000"
        stroke: "#660000"
        font-color: "#ffbbbb"
        border-radius: 4
      }
    }
  }
  r_1mb_barrier: "1 MB BOUNDARY — 0x100000 — A20 line must be enabled to cross!" {
    style: {
      fill: "#1a1a00"
      stroke: "#aaaa00"
      font-color: "#ffff44"
      border-radius: 4
      bold: true
      stroke-width: 3
    }
  }
  r_kernel: "KERNEL — 0x100000-0x4FFFFF" {
    style: {
      fill: "#003300"
      stroke: "#00aa00"
      font-color: "#88ff88"
      border-radius: 4
      bold: true
    }
    kernel_meta: "up to 4 MB | Kernel Binary loaded by stage-2 | USABLE RAM — PMM must reserve" {
      style: {
        fill: "#002200"
        stroke: "#007700"
        font-color: "#66cc66"
        border-radius: 4
      }
    }
    kernel_detail: |md
      LMA (Load Address): 0x00100000 (physical).
      VMA (Link Address): 0xC0100000 (after paging).
      Stage-2 loads kernel here via INT 13h ext. read.
      Sections: .text / .rodata / .data / .bss.
      Linker symbol __kernel_end marks top.
      PMM must mark these frames as USED during init.
      E820 type=1 (usable RAM — OS must self-reserve).
    | {
      style: {
        fill: "#002200"
        stroke: "#007700"
        font-color: "#aaffaa"
        border-radius: 4
      }
    }
  }
  r_free_high: "FREEHIGH — 0x500000-0xFFFFFF" {
    style: {
      fill: "#003300"
      stroke: "#006600"
      font-color: "#88ff88"
      border-radius: 4
    }
    free_high_meta: "~11 MB | Free High Memory (general allocation pool) | USABLE — PMM managed" {
      style: {
        fill: "#002200"
        stroke: "#005500"
        font-color: "#66cc66"
        border-radius: 4
      }
    }
    free_high_detail: |md
      E820 type=1: usable RAM.
      PMM bitmap allocator manages this region.
      Used for: kernel heap pages, page tables,
      per-process page directories, user stacks.
      Extended by however much physical RAM exists.
      QEMU default: 128 MB, up to 0x7FDFFFF usable.
    | {
      style: {
        fill: "#002200"
        stroke: "#005500"
        font-color: "#aaffaa"
        border-radius: 4
      }
    }
  }
}
annotations: "CRITICAL BOOT CONSTRAINTS" {
  style: {
    fill: "#0d0d22"
    stroke: "#4444aa"
    stroke-width: 2
    border-radius: 8
    font-color: "#aaaaee"
  }
  a1: "A20 GATE" {
    style: {
      fill: "#1a1a00"
      stroke: "#aaaa00"
      font-color: "#ffffaa"
      border-radius: 6
    }
    a1_detail: |md
      Without A20: 0x100000 wraps to 0x00000.
      Any write to physical 0x100000 silently hits 0x00000 — IVT corruption — triple fault.
      Must enable A20 BEFORE loading kernel to 0x100000.
      Methods (try in order): INT 15h/2401, Port 0x92, 8042 keyboard controller.
      Verify: write to 0x7DFE, check 0x17FFE differs (A20 active = they differ).
    | {
      style: {
        fill: "#1a1a00"
        stroke: "#888800"
        font-color: "#ffffaa"
        border-radius: 4
      }
    }
  }
  a2: "VGA BUFFER — volatile is not optional" {
    style: {
      fill: "#1a001a"
      stroke: "#aa00aa"
      font-color: "#ffaaff"
      border-radius: 6
    }
    a2_detail: |md
      0xB8000 is MMIO, not DRAM. Writes go to VGA hardware register, not cache.
      Without volatile, compiler eliminates redundant writes — nothing appears on screen.
      In protected mode + higher-half: access via 0xC00B8000 (after paging maps VGA range).
      Identity map 0x00000000-0x003FFFFF covers 0xB8000 for early boot.
    | {
      style: {
        fill: "#1a001a"
        stroke: "#880088"
        font-color: "#ffaaff"
        border-radius: 4
      }
    }
  }
  a3: "KERNEL LOAD ADDRESS — LMA != VMA after paging" {
    style: {
      fill: "#001a00"
      stroke: "#00aa00"
      font-color: "#aaffaa"
      border-radius: 6
    }
    a3_detail: |md
      Kernel loaded at physical 0x100000 (LMA).
      Kernel linked at virtual 0xC0100000 (VMA) in higher-half design.
      Pre-paging code MUST use physical addresses.
      After setting PG bit in CR0, the identity map (virt 0x100000 = phys 0x100000)
      lets the next instruction execute.
      Far jump to 0xC0100000 removes dependence on identity map.
    | {
      style: {
        fill: "#001a00"
        stroke: "#008800"
        font-color: "#aaffaa"
        border-radius: 4
      }
    }
  }
  a4: "FRAME ALLOCATOR MUST SELF-EXCLUDE" {
    style: {
      fill: "#1a0000"
      stroke: "#cc0000"
      font-color: "#ffaaaa"
      border-radius: 6
    }
    a4_detail: |md
      E820 marks 0x100000+ as type=1 (usable). The kernel binary sits there.
      PMM init must mark kernel frames (0x100000 to __kernel_end) as USED.
      Also mark frame 0 as USED: NULL pointer dereference = immediate page fault (good).
      Also mark EBDA, BIOS ROM, VGA MMIO ranges as USED (from E820 type=2 entries).
    | {
      style: {
        fill: "#1a0000"
        stroke: "#aa0000"
        font-color: "#ffaaaa"
        border-radius: 4
      }
    }
  }
}
address_flow: "SEQUENTIAL ADDRESS SPACE (low to high)" {
  style: {
    fill: "#080810"
    stroke: "#222244"
    stroke-width: 2
    border-radius: 8
    font-color: "#8888cc"
  }
  seq_ivt: "0x00000\nIVT\n1 KB" {
    style: {
      fill: "#2a0000"
      stroke: "#880000"
      font-color: "#ffaaaa"
      border-radius: 4
      font-size: 11
    }
  }
  seq_bda: "0x00400\nBDA\n256 B" {
    style: {
      fill: "#2a1500"
      stroke: "#885500"
      font-color: "#ffcc88"
      border-radius: 4
      font-size: 11
    }
  }
  seq_conv: "0x00500\nFree RAM\n~30 KB" {
    style: {
      fill: "#003300"
      stroke: "#006600"
      font-color: "#88ff88"
      border-radius: 4
      font-size: 11
    }
  }
  seq_mbr: "0x07C00\nMBR\n512 B" {
    style: {
      fill: "#00113d"
      stroke: "#003388"
      font-color: "#88aaff"
      border-radius: 4
      font-size: 11
    }
  }
  seq_s2: "0x07E00\nStage-2\n+Free RAM" {
    style: {
      fill: "#001133"
      stroke: "#002266"
      font-color: "#99bbff"
      border-radius: 4
      font-size: 11
    }
  }
  seq_ebda: "0x9FC00\nEBDA\n1 KB" {
    style: {
      fill: "#2a1500"
      stroke: "#885500"
      font-color: "#ffcc88"
      border-radius: 4
      font-size: 11
    }
  }
  seq_vga_gr: "0xA0000\nVGA GFX\n96 KB" {
    style: {
      fill: "#1a0033"
      stroke: "#550088"
      font-color: "#cc88ff"
      border-radius: 4
      font-size: 11
    }
  }
  seq_vga_txt: "0xB8000\nVGA TXT\n4000 B" {
    style: {
      fill: "#2a0044"
      stroke: "#8800cc"
      font-color: "#ee99ff"
      border-radius: 4
      font-size: 11
      bold: true
    }
  }
  seq_bios: "0xC0000\nBIOS ROM\n256 KB" {
    style: {
      fill: "#2a0000"
      stroke: "#880000"
      font-color: "#ffaaaa"
      border-radius: 4
      font-size: 11
    }
  }
  seq_a20: "1 MB\nA20 Gate\nBoundary" {
    style: {
      fill: "#1a1a00"
      stroke: "#aaaa00"
      font-color: "#ffff44"
      border-radius: 4
      font-size: 11
      bold: true
    }
  }
  seq_kernel: "0x100000\nKERNEL\nLMA here" {
    style: {
      fill: "#003300"
      stroke: "#00aa00"
      font-color: "#88ff88"
      border-radius: 4
      font-size: 11
      bold: true
    }
  }
  seq_free: "0x500000+\nFree RAM\nPMM pool" {
    style: {
      fill: "#003300"
      stroke: "#006600"
      font-color: "#88ff88"
      border-radius: 4
      font-size: 11
    }
  }
  seq_ivt -> seq_bda: "0x400"
  seq_bda -> seq_conv: "0x500"
  seq_conv -> seq_mbr: "0x7C00"
  seq_mbr -> seq_s2: "0x7E00 / BIOS jumps to 0x7C00"
  seq_s2 -> seq_ebda: "0x9FC00"
  seq_ebda -> seq_vga_gr: "0xA0000"
  seq_vga_gr -> seq_vga_txt: "0xB8000 / MMIO window"
  seq_vga_txt -> seq_bios: "0xC0000"
  seq_bios -> seq_a20: "0x100000 / A20 required!"
  seq_a20 -> seq_kernel: "Stage-2 loads kernel"
  seq_kernel -> seq_free: "kernel_end / PMM manages"
}
phys_map -> annotations: "constraints apply to" {
  style: {
    stroke: "#5555aa"
    stroke-dash: 4
    font-size: 11
  }
}
phys_map -> address_flow: "sequential view" {
  style: {
    stroke: "#5555aa"
    stroke-dash: 4
    font-size: 11
  }
}
legend -> phys_map: "color coding" {
  style: {
    stroke: "#444466"
    stroke-dash: 5
    font-size: 11
  }
}