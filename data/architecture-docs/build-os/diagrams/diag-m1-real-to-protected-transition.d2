vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: right
title: |md
  ## Real Mode â†’ Protected Mode: The Critical Transition
  **The far jump is mandatory â€” it is not ceremony**
| {near: top-center}
back_to_map: "â†‘ Satellite Map" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#334155"
    font-color: "#94a3b8"
    stroke: "#475569"
    border-radius: 8
    font-size: 11
  }
}
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# BEFORE PANEL
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
before: "BEFORE: mov cr0, eax executed (CR0.PE=1)" {
  style: {
    fill: "#1e1b2e"
    stroke: "#dc2626"
    stroke-width: 3
    border-radius: 10
    font-color: "#fca5a5"
    bold: true
  }
  danger_label: |md
    ðŸ”´ **SCHIZOPHRENIC HALF-STATE**
    CR0.PE=1 â†’ hardware expects protected-mode semantics
    CS still = 0x0000 â†’ real-mode segment value, not a GDT selector
  | {
    style: {
      fill: "#450a0a"
      stroke: "#dc2626"
      stroke-width: 2
      font-color: "#fca5a5"
      border-radius: 6
    }
  }
  cpu_before: "CPU Internal State" {
    style: {
      fill: "#1c1917"
      stroke: "#78716c"
      border-radius: 8
      font-color: "#e7e5e4"
    }
    cr0_reg: "CR0 Register" {
      style: { fill: "#7f1d1d"; stroke: "#dc2626"; border-radius: 4; font-color: "#fca5a5" }
      cr0_val: |md
        **Bit 31 (PG):** 0  â€” paging OFF
        **Bit 0  (PE):** 1  â€” âš ï¸ PROTECTED MODE SET
        Value: `0x00000001`
      |
    }
    cs_reg: "CS Register (DANGER)" {
      style: { fill: "#7f1d1d"; stroke: "#f87171"; stroke-width: 2; border-radius: 4; font-color: "#fca5a5" }
      cs_val: |md
        **CS = 0x0000**  (real-mode paragraph value)
        Descriptor cache still holds real-mode semantics:
        â€¢ Base  = 0x00000
        â€¢ Limit = 0xFFFF  (64 KB, 16-bit limit)
        â€¢ DPL   = 0
        âŒ NOT a valid protected-mode selector
      |
    }
    other_segs: "DS / ES / SS (real-mode)" {
      style: { fill: "#292524"; stroke: "#57534e"; border-radius: 4; font-color: "#a8a29e" }
      seg_val: |md
        DS = ES = SS = 0x0000
        All using real-mode 64 KB window semantics
        Will break on first data access in PM
      |
    }
    eip_reg: "EIP (instruction pointer)" {
      style: { fill: "#292524"; stroke: "#57534e"; border-radius: 4; font-color: "#a8a29e" }
      eip_val: |md
        EIP â‰ˆ 0x7E1C  (points to instruction AFTER mov cr0, eax)
        CPU is about to fetch next instruction at CS:EIP
        = 0x0000 Ã— 16 + 0x7E1C = physical **0x7E1C**
      |
    }
  }
  prefetch_before: "Instruction Prefetch Queue" {
    style: {
      fill: "#1c1917"
      stroke: "#b45309"
      stroke-width: 2
      border-radius: 8
      font-color: "#fcd34d"
    }
    pq_label: |md
      **âš ï¸  STALE / DANGEROUS**
      Instructions decoded using **real-mode** address semantics:
      
      [0x7E1C]  jmp  far 0x08:0x7E20   â† next instruction (not yet fetched)
      [0x7E18]  mov  cr0, eax           â† just executed
      [0x7E14]  or   eax, 0x1           â† already retired
      
      If the CPU fetched anything past `mov cr0, eax` speculatively,
      those bytes were decoded as **16-bit real-mode**.
      In PM they will be **reinterpreted incorrectly** unless the
      pipeline is flushed â†’ this is WHY the far jump is mandatory.
    |
  }
  mem_access_before: "Memory Access Model" {
    style: {
      fill: "#1c1917"
      stroke: "#78716c"
      border-radius: 8
      font-color: "#e7e5e4"
    }
    ma_label: |md
      **Addressing formula still active in pipeline:**
      `physical = CS Ã— 16 + offset`
      = `0x0000 Ã— 16 + EIP`  = `EIP` (flat, 20-bit)
      **Hardware reality (CR0.PE=1):**
      MMU now expects GDT lookup for CS
      â†’ contradiction between pipeline state and hardware expectation
      â†’ **General Protection Fault #13 on next instruction** if not resolved
    |
  }
  cpu_before.cr0_reg -> cpu_before.cs_reg: "PE=1 but CS invalid\n(half-state active)" {
    style: { stroke: "#dc2626"; stroke-dash: 4; font-color: "#f87171" }
  }
  cpu_before.cs_reg -> prefetch_before: "CS:EIP used to fill prefetch queue\nwith REAL-MODE decoded bytes" {
    style: { stroke: "#b45309"; stroke-dash: 4; font-color: "#fbbf24" }
  }
  prefetch_before -> mem_access_before: "Real-mode bytes in queue\ncannot be executed in PM" {
    style: { stroke: "#dc2626"; animated: true; font-color: "#f87171" }
  }
  danger_label -> cpu_before: "" { style: { stroke: "#dc2626"; stroke-dash: 3 } }
}
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# THE TRANSITION ARROW â€” the far jump
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
far_jump: "jmp 0x08:protected_entry" {
  style: {
    fill: "#14532d"
    stroke: "#16a34a"
    stroke-width: 3
    border-radius: 8
    font-color: "#86efac"
    bold: true
  }
  fj_detail: |md
    **The far jump does THREE things atomically:**
    1. **Loads CS â† 0x08**
       CPU validates 0x08 against GDT[1] (kernel code descriptor)
       Descriptor cache updated: base=0, limit=4GB, DPL=0, executable
    2. **Loads EIP â† protected_entry address**
       EIP now points to the first true 32-bit protected-mode instruction
    3. **Flushes the instruction prefetch queue**
       All speculatively-decoded real-mode bytes are discarded
       CPU re-fetches from the new CS:EIP using PM semantics
    **Without this far jump:**
    â†’ CPU tries to decode next byte with stale real-mode pipeline state
    â†’ #GP (General Protection Fault)
    â†’ IDT not set up yet â†’ #DF (Double Fault)
    â†’ Double fault handler not set up â†’ Triple Fault â†’ **CPU RESET**
    â†’ Machine reboots silently. No error message. Ever.
  |
}
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# AFTER PANEL
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
after: "AFTER: protected_entry executing (Full 32-bit Protected Mode)" {
  style: {
    fill: "#0f1f0f"
    stroke: "#16a34a"
    stroke-width: 3
    border-radius: 10
    font-color: "#86efac"
    bold: true
  }
  success_label: |md
    âœ… **STABLE STATE â€” CPU fully in 32-bit Protected Mode**
    All registers using GDT-backed segment descriptors
    Prefetch queue contains valid 32-bit PM instructions
  | {
    style: {
      fill: "#052e16"
      stroke: "#16a34a"
      stroke-width: 2
      font-color: "#86efac"
      border-radius: 6
    }
  }
  cpu_after: "CPU Internal State" {
    style: {
      fill: "#0c1a0c"
      stroke: "#166534"
      border-radius: 8
      font-color: "#d1fae5"
    }
    cr0_after: "CR0 Register" {
      style: { fill: "#14532d"; stroke: "#16a34a"; border-radius: 4; font-color: "#86efac" }
      cr0_aval: |md
        **Bit 31 (PG):** 0  â€” paging still OFF (Milestone 3)
        **Bit 0  (PE):** 1  â€” Protected Mode active
        Value: `0x00000001`
      |
    }
    cs_after: "CS Register âœ…" {
      style: { fill: "#14532d"; stroke: "#4ade80"; stroke-width: 2; border-radius: 4; font-color: "#86efac" }
      cs_aval: |md
        **CS = 0x08**  (GDT index 1, RPL=0)
        Descriptor cache updated by far jump:
        â€¢ Base  = 0x00000000  (flat, all 4 GB)
        â€¢ Limit = 0xFFFFFFFF  (4 GB)
        â€¢ DPL   = 0           (ring 0 / kernel)
        â€¢ Type  = Code, readable, non-conforming
        âœ… Valid protected-mode kernel code selector
      |
    }
    segs_todo: "DS / ES / SS / FS / GS (must reload)" {
      style: { fill: "#1a2e1a"; stroke: "#4d7c0f"; border-radius: 4; font-color: "#bef264" }
      segs_detail: |md
        Still hold stale real-mode descriptor cache values!
        **NEXT instructions must be:**
        nasm
        mov ax, 0x10   ; kernel data selector
        mov ds, ax
        mov es, ax
        mov ss, ax
        mov fs, ax
        mov gs, ax
        mov esp, 0x9FC00  ; 32-bit stack
        
        Until these execute, data segment accesses use
        the old 64KB real-mode descriptor cache window.
      |
    }
    eip_after: "EIP (32-bit)" {
      style: { fill: "#1a2e1a"; stroke: "#166534"; border-radius: 4; font-color: "#d1fae5" }
      eip_aval: |md
        EIP = address of `protected_entry` label
        Now a full 32-bit offset into the CS segment
        (base=0, so physical = EIP directly)
      |
    }
  }
  prefetch_after: "Instruction Prefetch Queue" {
    style: {
      fill: "#0c1a0c"
      stroke: "#16a34a"
      stroke-width: 2
      border-radius: 8
      font-color: "#d1fae5"
    }
    pq_after_label: |md
      **âœ… FLUSHED & REFILLED â€” 32-bit PM decoded bytes**
      nasm
      [protected_entry+0]  mov ax, 0x10    ; â† executing now
      [protected_entry+3]  mov ds, ax
      [protected_entry+5]  mov es, ax
      [protected_entry+7]  mov ss, ax
      [protected_entry+9]  mov esp, 0x9FC00
      [protected_entry+14] call kernel_main
      
      All instructions decoded with 32-bit default operand size.
      No stale real-mode bytes remain in the pipeline.
    |
  }
  gdt_walk: "GDT Lookup (every memory access)" {
    style: {
      fill: "#0c1a0c"
      stroke: "#1d4ed8"
      border-radius: 8
      font-color: "#bfdbfe"
    }
    gdt_walk_detail: |md
      **Address translation formula (flat model):**
      `linear_addr = GDT[CS.index].base + EIP`
                   `= 0x00000000 + EIP = EIP`
      Segmentation is a **no-op** in the flat model.
      The interesting protection check is the **DPL comparison**:
      â€¢ CS.DPL = 0 â†’ ring 0 (kernel)
      â€¢ CPL (from CS bits 0-1) = 0 â†’ kernel mode confirmed
      Every load/store similarly validated through DS descriptor.
    |
  }
  mem_access_after: "Memory Access Model âœ…" {
    style: {
      fill: "#0c1a0c"
      stroke: "#166534"
      border-radius: 8
      font-color: "#d1fae5"
    }
    ma_after_label: |md
      **New formula: linear = Seg.base + offset**
      For flat model: linear = 0 + offset = offset
      Physical = linear (paging disabled until Milestone 3)
      **Protection enforced on every access:**
      â€¢ Limit check: offset â‰¤ segment limit
      â€¢ Privilege check: CPL â‰¤ DPL for data, CPL = DPL for stack
      â€¢ Type check: code segments are not writable
    |
  }
  cpu_after.cs_after -> prefetch_after: "CS=0x08 used to fetch instructions\nfrom GDT[1] (kernel code, ring 0)" {
    style: { stroke: "#16a34a"; font-color: "#86efac" }
  }
  prefetch_after -> gdt_walk: "32-bit instructions fetch operands\nthrough GDT segment lookup" {
    style: { stroke: "#1d4ed8"; font-color: "#93c5fd" }
  }
  gdt_walk -> mem_access_after: "Flat model: linear = physical\nprotection checks active" {
    style: { stroke: "#16a34a"; font-color: "#86efac" }
  }
  cpu_after.cs_after -> cpu_after.segs_todo: "CS fixed by far jump\nDS/ES/SS still need explicit reload" {
    style: { stroke: "#ca8a04"; stroke-dash: 3; font-color: "#fbbf24" }
  }
  success_label -> cpu_after: "" { style: { stroke: "#16a34a"; stroke-dash: 3 } }
}
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# GDT reference panel
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
gdt_ref: "GDT (loaded via lgdt before CR0.PE set)" {
  style: {
    fill: "#0f172a"
    stroke: "#4f46e5"
    stroke-width: 2
    border-radius: 8
    font-color: "#c7d2fe"
  }
  null_desc: "GDT[0] â€” Null Descriptor" {
    style: { fill: "#1e1b4b"; stroke: "#4338ca"; border-radius: 4; font-color: "#a5b4fc" }
    nd_val: |md
      Selector: 0x00
      All fields = 0. CPU raises #GP if loaded into CS/DS.
      Required by architecture spec (must be first entry).
    |
  }
  kcode_desc: "GDT[1] â€” Kernel Code â† CS=0x08 points here" {
    style: { fill: "#1e1b4b"; stroke: "#818cf8"; stroke-width: 2; border-radius: 4; font-color: "#c7d2fe"; bold: true }
    kc_val: |md
      Selector: **0x08**  (index=1, TI=0, RPL=0)
      Base:  0x00000000   Limit: 0xFFFFF (Ã—4KB = 4GB)
      Access byte: **0x9A** = P=1, DPL=0, S=1, E=1, R=1
      Flags: **0xC** = G=1 (4KB granularity), D=1 (32-bit)
    |
  }
  kdata_desc: "GDT[2] â€” Kernel Data â† DS/ES/SS=0x10" {
    style: { fill: "#1e1b4b"; stroke: "#4338ca"; border-radius: 4; font-color: "#a5b4fc" }
    kd_val: |md
      Selector: **0x10**  (index=2, TI=0, RPL=0)
      Base:  0x00000000   Limit: 0xFFFFF (Ã—4KB = 4GB)
      Access byte: **0x92** = P=1, DPL=0, S=1, E=0, W=1
      Flags: **0xC** = G=1, D=1 (32-bit)
    |
  }
  ucode_desc: "GDT[3] â€” User Code (ring 3, future)" {
    style: { fill: "#1e1b4b"; stroke: "#4338ca"; border-radius: 4; font-color: "#a5b4fc" }
    uc_val: |md
      Selector: **0x1B**  (index=3, TI=0, RPL=3)
      Access byte: **0xFA** = P=1, DPL=3, S=1, E=1, R=1
      Used in Milestone 4 for ring-3 user processes.
    |
  }
  udata_desc: "GDT[4] â€” User Data (ring 3, future)" {
    style: { fill: "#1e1b4b"; stroke: "#4338ca"; border-radius: 4; font-color: "#a5b4fc" }
    ud_val: |md
      Selector: **0x23**  (index=4, TI=0, RPL=3)
      Access byte: **0xF2** = P=1, DPL=3, S=1, E=0, W=1
      Used in Milestone 4 for ring-3 user data.
    |
  }
  selector_decode: "Selector Bit Anatomy: 0x08 = 0b0000_1000" {
    style: { fill: "#0f172a"; stroke: "#6366f1"; border-radius: 4; font-color: "#e0e7ff" }
    sd_val: |md
      Bits 15â€“3: **Index = 1**  â†’ GDT[1]
      Bit  2:    **TI   = 0**  â†’ GDT (not LDT)
      Bits 1â€“0:  **RPL  = 0**  â†’ Requested Privilege Level = ring 0
    |
  }
}
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TRIPLE FAULT WARNING
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
triple_fault_warning: "What happens if you omit the far jump?" {
  style: {
    fill: "#450a0a"
    stroke: "#dc2626"
    stroke-width: 3
    border-radius: 8
    font-color: "#fca5a5"
    bold: true
  }
  tf_detail: |md
    1. CPU executes `mov cr0, eax` â†’ CR0.PE=1
    2. Next instruction fetched: CS=0x0000 (real-mode value)
       CPU tries to validate 0x0000 as a protected-mode selector
    3. GDT[0] = Null descriptor â†’ **#GP (General Protection Fault, vector 13)**
    4. IDT not yet loaded â†’ CPU tries to use IVT (real-mode interrupt table)
       In protected mode, address 0x0000 is interpreted as an IDT gate descriptor
       â†’ **#DF (Double Fault, vector 8)**
    5. Double fault handler also invalid â†’ **Triple Fault**
    6. CPU asserts RESET pin â†’ **Machine reboots silently**
    **You will see no error message. The QEMU window will flash.
    Without `-no-reboot`, the cycle repeats endlessly.
    Add: `qemu-system-i386 -d int,cpu_reset -no-reboot` to observe.**
  |
}
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CONNECTIONS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
before -> far_jump: "CR0.PE set\nSchizophrenic half-state begins" {
  style: {
    stroke: "#dc2626"
    stroke-width: 3
    font-color: "#f87171"
    bold: true
    animated: true
  }
}
far_jump -> after: "Pipeline flush + CS reload\nStable PM state achieved" {
  style: {
    stroke: "#16a34a"
    stroke-width: 3
    font-color: "#86efac"
    bold: true
    animated: true
  }
}
far_jump -> gdt_ref: "far jump validates CS=0x08\nagainst this GDT entry" {
  style: { stroke: "#4f46e5"; stroke-dash: 3; font-color: "#a5b4fc" }
}
before -> triple_fault_warning: "Omitting the far jump\ncauses this cascade" {
  style: { stroke: "#dc2626"; stroke-dash: 5; font-color: "#f87171" }
}
back_to_map -> before: "" { style: { stroke: "#475569"; stroke-dash: 3 } }