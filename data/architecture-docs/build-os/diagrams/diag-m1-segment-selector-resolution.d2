vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: right
title: |md
  ## Segment Selector → GDT → Linear Address Resolution
  *data\_walk: how CS=0x08 and CS=0x1B are decoded by the CPU on every memory access*
| {near: top-center}
back_to_map: "↖ Satellite Map" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#2d2d2d"
    font-color: "#aaaaaa"
    stroke: "#555555"
    border-radius: 6
    font-size: 11
  }
}
lane_a: "LANE A — Kernel Code  CS = 0x08" {
  style: {
    fill: "#0d1f2d"
    stroke: "#1e6fa8"
    stroke-width: 2
    border-radius: 8
    font-color: "#7ec8e3"
    font-size: 13
  }
  sel_a: "Selector  0x08" {
    style: {fill: "#1a3a52"; stroke: "#1e6fa8"; font-color: "#ffffff"; border-radius: 4}
  }
  bits_a: |||md
    **Bit Decomposition (16-bit value)**
    | Field | Bits | Value | Meaning |
    |-------|------|-------|---------|
    | Index | 15-3 | **1** | GDT entry 1 |
    | TI    | 2    | **0** | Use GDT (not LDT) |
    | RPL   | 1-0  | **0** | Ring 0 (kernel) |
    Binary: `0000 0000 0000 1 0 00`
  ||| {
    style: {fill: "#0d2233"; stroke: "#1e6fa8"; border-radius: 4}
  }
  gdt_lookup_a: "GDT[1] — Kernel Code Descriptor" {
    style: {fill: "#0a3d5c"; stroke: "#00bfff"; stroke-width: 2; border-radius: 4; font-color: "#00e5ff"}
    desc_a: |md
      **Byte layout (8 bytes / 64 bits)**
      Byte 7   Base\[31:24\]  = 0x00
      Byte 6   Flags+Lim    = 0xCF   G=1,D=1,L=0
      Byte 5   Access       = 0x9A   P=1,DPL=00,S=1,E=1,R=1
      Byte 4   Base\[23:16\]  = 0x00
      Byte 3   Base\[15:8\]   = 0x00
      Byte 2   Base\[7:0\]    = 0x00
      Bytes 1-0 Limit\[15:0\] = 0xFFFF
      **Base  = 0x00000000**
      **Limit = 0xFFFFF x 4KB = 4 GB**
      **DPL   = 0  (ring 0 only)**
    | {
      style: {fill: "#071c2e"; stroke: "#1e6fa8"; border-radius: 4}
    }
  }
  linear_a: "Linear Address" {
    style: {fill: "#003d1f"; stroke: "#00c853"; stroke-width: 2; border-radius: 4; font-color: "#69ff47"}
    formula_a: |md
      **Linear = Base + Logical Offset**
      `0x00000000 + offset = offset`
      Flat model: linear = logical
      Paging then maps linear to physical
      CPL = 0  (ring 0 enforced in CS)
    | {
      style: {fill: "#001a0d"; stroke: "#00c853"; border-radius: 4}
    }
  }
  sel_a -> bits_a: "CPU decomposes\n16-bit selector" {
    style: {stroke: "#1e6fa8"; font-color: "#7ec8e3"; stroke-width: 2}
  }
  bits_a -> gdt_lookup_a: "Index=1, TI=0\nread GDTR.base + 1x8" {
    style: {stroke: "#00bfff"; font-color: "#7ec8e3"; stroke-width: 2}
  }
  gdt_lookup_a -> linear_a: "Base=0 extracted\nLimit check passes" {
    style: {stroke: "#00c853"; font-color: "#69ff47"; stroke-width: 2}
  }
}
lane_b: "LANE B — User Code  CS = 0x1B  (RPL=3)" {
  style: {
    fill: "#1f1020"
    stroke: "#8b2fc9"
    stroke-width: 2
    border-radius: 8
    font-color: "#ce93d8"
    font-size: 13
  }
  sel_b: "Selector  0x1B" {
    style: {fill: "#3a1a52"; stroke: "#8b2fc9"; font-color: "#ffffff"; border-radius: 4}
  }
  bits_b: |||md
    **Bit Decomposition (16-bit value)**
    | Field | Bits | Value | Meaning |
    |-------|------|-------|---------|
    | Index | 15-3 | **3** | GDT entry 3 |
    | TI    | 2    | **0** | Use GDT |
    | RPL   | 1-0  | **3** | Ring 3 (user) |
    Binary: `0000 0000 0001 1 0 11`
    `0x1B = 27 = (3<<3) or 3`
  ||| {
    style: {fill: "#1a0a2e"; stroke: "#8b2fc9"; border-radius: 4}
  }
  gdt_lookup_b: "GDT[3] — User Code Descriptor" {
    style: {fill: "#2d0a4e"; stroke: "#ce93d8"; stroke-width: 2; border-radius: 4; font-color: "#e1bee7"}
    desc_b: |md
      **Byte layout (8 bytes / 64 bits)**
      Byte 7   Base\[31:24\]  = 0x00
      Byte 6   Flags+Lim    = 0xCF   G=1,D=1,L=0
      Byte 5   Access       = 0xFA   P=1,DPL=11,S=1,E=1,R=1
      Byte 4   Base\[23:16\]  = 0x00
      Byte 3   Base\[15:8\]   = 0x00
      Byte 2   Base\[7:0\]    = 0x00
      Bytes 1-0 Limit\[15:0\] = 0xFFFF
      **Base  = 0x00000000**
      **Limit = 0xFFFFF x 4KB = 4 GB**
      **DPL   = 3  (ring 3 required)**
    | {
      style: {fill: "#12051e"; stroke: "#8b2fc9"; border-radius: 4}
    }
  }
  linear_b: "Linear Address" {
    style: {fill: "#1a0a00"; stroke: "#ff9800"; stroke-width: 2; border-radius: 4; font-color: "#ffcc80"}
    formula_b: |md
      **Linear = Base + Logical Offset**
      `0x00000000 + offset = offset`
      Flat model: linear = logical
      Paging enforces U/S bit per page
      CPL = 3  (ring 3 enforced in CS)
      Kernel pages (U/S=0) cause \#PF on access
    | {
      style: {fill: "#120700"; stroke: "#ff9800"; border-radius: 4}
    }
  }
  sel_b -> bits_b: "CPU decomposes\n16-bit selector" {
    style: {stroke: "#8b2fc9"; font-color: "#ce93d8"; stroke-width: 2}
  }
  bits_b -> gdt_lookup_b: "Index=3, TI=0\nread GDTR.base + 3x8" {
    style: {stroke: "#ce93d8"; font-color: "#ce93d8"; stroke-width: 2}
  }
  gdt_lookup_b -> linear_b: "Base=0 extracted\nDPL=3 check: CPL<=DPL OK" {
    style: {stroke: "#ff9800"; font-color: "#ffcc80"; stroke-width: 2}
  }
}
gdtr_box: "GDTR Register  (6 bytes, loaded by lgdt)" {
  style: {
    fill: "#1a1a0a"
    stroke: "#f5c518"
    stroke-width: 2
    border-radius: 6
    font-color: "#f5c518"
  }
  gdtr_content: |md
    Bits 47-16 : Base  = 0xC0105000  (kernel virt addr of GDT array)
    Bits 15-0  : Limit = 0x0027      (5 entries x 8 bytes - 1 = 39)
    CPU uses: **physical\_entry = GDTR.Base + (Index x 8)**
  | {
    style: {fill: "#0d0d00"; stroke: "#f5c518"; border-radius: 4}
  }
}
gdt_table: "GDT in Memory  (40 bytes = 5 x 8-byte descriptors)" {
  style: {
    fill: "#111111"
    stroke: "#888888"
    stroke-width: 2
    border-radius: 6
    font-color: "#cccccc"
  }
  gdt_rows: |||md
    | Offset | Selector | Entry | Base | Limit | Access | DPL |
    |--------|----------|-------|------|-------|--------|-----|
    | +0x00  | 0x00 | Null descriptor | - | - | 0x00 | - |
    | +0x08  | 0x08 | Kernel Code | 0x0 | 4 GB | 0x9A | 0 |
    | +0x10  | 0x10 | Kernel Data | 0x0 | 4 GB | 0x92 | 0 |
    | +0x18  | 0x1B | User Code | 0x0 | 4 GB | 0xFA | 3 |
    | +0x20  | 0x23 | User Data | 0x0 | 4 GB | 0xF2 | 3 |
    RPL=3 added by selector (e.g. 0x18 base index OR 3 = 0x1B)
  ||| {
    style: {fill: "#0a0a0a"; stroke: "#555555"; border-radius: 4}
  }
}
enforce: "Hardware Access Check: max(CPL, RPL) <= DPL" {
  style: {
    fill: "#1a0000"
    stroke: "#ff3333"
    stroke-width: 2
    border-radius: 6
    font-color: "#ff8888"
  }
  enforce_detail: |||md
    **Three privilege fields compared on every segment load:**
    | Field | Source | Meaning |
    |-------|--------|---------|
    | CPL | CS bits 1-0 | Current Privilege Level (who is running) |
    | DPL | GDT descriptor bits 14-13 | Required privilege to access this segment |
    | RPL | Selector bits 1-0 | Requested Privilege Level (caller assertion) |
    **Rule:** `max(CPL, RPL) <= DPL` must be true, else **#GP (General Protection Fault)**
    **Examples:**
    - Ring 0 code loads DS=0x10 (DPL=0): max(0,0)=0 <= 0  OK
    - Ring 3 code loads DS=0x10 (DPL=0): max(3,0)=3 > 0   #GP!
    - Ring 3 code loads DS=0x23 (DPL=3): max(3,3)=3 <= 3  OK
  ||| {
    style: {fill: "#0d0000"; stroke: "#ff3333"; border-radius: 4}
  }
}
paging_note: "Next stage: Paging (CR3 -> Page Directory -> Physical)" {
  style: {
    fill: "#002200"
    stroke: "#00cc44"
    stroke-width: 1
    stroke-dash: 5
    border-radius: 6
    font-color: "#44ff88"
    font-size: 12
  }
  paging_detail: |md
    **Segmentation produces a linear address.**
    With the flat model (Base=0), linear = logical offset.
    The MMU then applies paging:
    linear\[31:22\] -> Page Directory index
    linear\[21:12\] -> Page Table index
    linear\[11:0\]  -> 4 KB page offset
    Physical = PTE.frame\_addr OR offset
    Paging also re-checks the **U/S bit** per page:
    - U/S=0 and CPL=3 causes **\#PF** (page fault, protection violation)
    This is why ring-3 processes cannot read kernel pages
    even though GDT segments span the full 4 GB.
  | {
    style: {fill: "#001100"; stroke: "#00cc44"; border-radius: 4}
  }
}
gdtr_box -> gdt_table: "GDTR.Base addresses\nthe GDT array in memory" {
  style: {stroke: "#f5c518"; font-color: "#f5c518"; stroke-width: 2}
}
lane_a -> gdtr_box: "Index=1 -> GDTR.Base + 8" {
  style: {stroke: "#1e6fa8"; font-color: "#7ec8e3"; stroke-dash: 4}
}
lane_b -> gdtr_box: "Index=3 -> GDTR.Base + 24" {
  style: {stroke: "#8b2fc9"; font-color: "#ce93d8"; stroke-dash: 4}
}
gdt_table -> enforce: "Descriptor DPL field\npassed to access check" {
  style: {stroke: "#ff3333"; font-color: "#ff8888"; stroke-width: 2}
}
lane_a.linear_a -> paging_note: "linear addr (flat:\noffset unchanged)" {
  style: {stroke: "#00c853"; font-color: "#69ff47"; stroke-dash: 5}
}
lane_b.linear_b -> paging_note: "linear addr -> paging\nU/S bit enforces ring 3" {
  style: {stroke: "#ff9800"; font-color: "#ffcc80"; stroke-dash: 5}
}