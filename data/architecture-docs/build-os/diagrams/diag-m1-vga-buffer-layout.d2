vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |'md
  # VGA Text Mode Buffer: Memory-Mapped I/O at 0xB8000
  Physical 0xB8000–0xB8FA0 · 80×25×2 = 4,000 bytes · Writes bypass DRAM → VGA card registers
'| {near: top-center}

bus_decode: "Memory Bus Decode Logic (NOT RAM)" {
  style: {
    fill: "#1a0a0a"
    stroke: "#e94560"
    stroke-width: 3
    border-radius: 8
    font-color: "#ff8899"
    bold: true
  }
  exp: |'md
    When CPU writes to 0xB8000–0xB8FFF:
    - Memory controller decodes address range
    - Routes to VGA chip register (not DRAM)
    - VGA hardware latches data immediately
    - No cache line fill, no write-back delay
    - volatile keyword REQUIRED in C code
    - Without volatile: compiler eliminates dead stores = blank screen
'|
}

buffer_layout: "VGA Text Buffer Physical Layout" {
  style: {
    fill: "#0d0020"
    stroke: "#7b2d8b"
    stroke-width: 2
    border-radius: 6
    font-color: "#cc99ff"
    bold: true
  }

  addr_start: "0xB8000 — Buffer Start" {
    style: { fill: "#3d0060"; stroke: "#cc99ff"; font-color: "#ffffff"; border-radius: 4 }
  }

  addr_end: "0xB8FA0 — Buffer End" {
    style: { fill: "#3d0060"; stroke: "#cc99ff"; font-color: "#ffffff"; border-radius: 4 }
  }

  size_info: |'md
    80 columns x 25 rows = 2,000 cells
    Each cell = 2 bytes: 2,000 x 2 = 4,000 bytes
    Row stride = 80 x 2 = 160 bytes
    Entire buffer fits in one 4KB page frame
'|

  formula: |'md
    Cell Address Formula:
    cell_addr = 0xB8000 + (row x 80 + col) x 2
    byte 0 = ASCII character code  [cell_addr + 0]
    byte 1 = Attribute byte        [cell_addr + 1]
'| {
    style: { fill: "#1a0035"; stroke: "#9966cc"; font-color: "#ddbbff"; border-radius: 4 }
  }

  addr_start -> addr_end: "4,000 bytes total · 25 rows · 160 bytes per row"
}

cell_anatomy: "Single Cell Anatomy (2 Bytes)" {
  style: {
    fill: "#000d1a"
    stroke: "#1e90ff"
    stroke-width: 2
    border-radius: 6
    font-color: "#66b3ff"
    bold: true
  }

  byte0: "Byte 0: Character Code bits 7-0" {
    style: { fill: "#00264d"; stroke: "#1e90ff"; font-color: "#99ccff"; border-radius: 4; bold: true }
    detail: |'md
      bits [7:0] = ASCII code (0x00 to 0xFF)

      0x48 = H     0x65 = e
      0x6C = l     0x6F = o
      0x20 = space 0x41 = A
      0x00 = NUL   0x21 = exclamation

      Extended 0x80-0xFF: box-drawing chars,
      block elements, accented letters
'|
  }

  byte1: "Byte 1: Attribute Byte bits 7-0" {
    style: { fill: "#001a00"; stroke: "#00cc44"; font-color: "#99ffcc"; border-radius: 4; bold: true }
    detail: |'md
      bit  [7]   = Blink enable (or bright bg)
      bits [6:4] = Background color (3 bits = 0 to 7)
      bits [3:0] = Foreground color (4 bits = 0 to 15)

      Bit layout:
      [7]  [6][5][4]  [3][2][1][0]
      BLK  BG2 BG1 BG0  FG3 FG2 FG1 FG0

      Example 0x0A:
      0 000 1010
      bkg=Black  fg=Light Green
'|
  }

  byte0 -> byte1: "packed as uint16_t: char OR (attr shifted left 8)"
}

color_table: "VGA 16-Color Table" {
  style: {
    fill: "#0a0a0a"
    stroke: "#888888"
    stroke-width: 2
    border-radius: 6
    font-color: "#cccccc"
    bold: true
  }

  dark_cols: "Dark Colors 0x0 to 0x7 (fg and bg)" {
    style: { fill: "#111111"; stroke: "#666666"; font-color: "#cccccc"; border-radius: 4 }
    list: |'md
      0x0  Black        000000
      0x1  Blue         0000AA
      0x2  Green        00AA00
      0x3  Cyan         00AAAA
      0x4  Red          AA0000
      0x5  Magenta      AA00AA
      0x6  Brown        AA5500
      0x7  Light Gray   AAAAAA
'|
  }

  bright_cols: "Bright Colors 0x8 to 0xF (foreground only)" {
    style: { fill: "#111111"; stroke: "#999999"; font-color: "#eeeeee"; border-radius: 4 }
    list: |'md
      0x8  Dark Gray      555555
      0x9  Light Blue     5555FF
      0xA  Light Green    55FF55  (demo uses this)
      0xB  Light Cyan     55FFFF
      0xC  Light Red      FF5555
      0xD  Light Magenta  FF55FF
      0xE  Yellow         FFFF55
      0xF  White          FFFFFF
'|
  }

  bg_note: |'md
    Background: 3 bits only, values 0x0 to 0x7
    Bit 7: bright-background OR blink (VGA register 0x10 bit 3)
    Foreground: full 4 bits, 0x0 to 0xF (16 colors)
'| {
    style: { fill: "#1a1100"; stroke: "#aa8800"; font-color: "#ffdd66"; border-radius: 4 }
  }
}

write_example: "Concrete Example: Write H Green-on-Black at Row 0 Col 0" {
  style: {
    fill: "#001a0a"
    stroke: "#00aa44"
    stroke-width: 3
    border-radius: 8
    font-color: "#00ff88"
    bold: true
  }

  step1: "Step 1: Compute Physical Address" {
    style: { fill: "#001400"; stroke: "#00aa44"; font-color: "#88ffcc"; border-radius: 4 }
    calc: |'md
      row = 0,  col = 0

      cell_addr = 0xB8000 + (0 x 80 + 0) x 2
               = 0xB8000 + 0
               = 0xB8000

      Byte 0 (char) at physical 0xB8000
      Byte 1 (attr) at physical 0xB8001
'|
  }

  step2: "Step 2: Encode Character and Attribute" {
    style: { fill: "#001400"; stroke: "#00cc55"; font-color: "#88ffcc"; border-radius: 4 }
    encode: |'md
      Character: H = 0x48 (ASCII decimal 72)

      Attribute green-on-black:
        Foreground = Light Green = 0xA = 1010b
        Background = Black       = 0x0 = 000b
        Blink      = 0

      Attribute byte = 0_000_1010 = 0x0A

      Packed uint16_t value:
        0x0048 OR (0x0A shifted left 8)
      = 0x0048 OR 0x0A00
      = 0x0A48

      In memory (little-endian):
        [0xB8000] = 0x48  (ASCII H)
        [0xB8001] = 0x0A  (green-on-black attribute)
'|
  }

  step3: "Step 3: C Code (volatile MANDATORY)" {
    style: { fill: "#001400"; stroke: "#00ff66"; font-color: "#aaffcc"; border-radius: 4 }
    code: |'md
      volatile uint16_t *VGA_BASE = (volatile uint16_t *)0xB8000;

      static inline uint16_t vga_entry(char c, uint8_t fg, uint8_t bg) {
          return (uint16_t)c | ((uint16_t)((bg << 4) | fg) << 8);
      }

      VGA_BASE[0 * 80 + 0] = vga_entry('H', 0xA, 0x0);
      Stores 0x0A48:
        0x48 written to 0xB8000
        0x0A written to 0xB8001
'|
  }

  step1 -> step2: "address computed → encode value"
  step2 -> step3: "0x0A48 ready → write via volatile ptr to 0xB8000"
}

grid_view: "80x25 Cell Grid Address Map" {
  style: {
    fill: "#00000f"
    stroke: "#4455aa"
    stroke-width: 2
    border-radius: 6
    font-color: "#8899dd"
    bold: true
  }

  row0: "Row 0  offset +0x000  addr 0xB8000 to 0xB809F" {
    style: { fill: "#00001a"; stroke: "#334488"; font-color: "#aabbee"; border-radius: 4 }
    r0d: |'md
      col:   [0]        [1]        [2]       ... [79]
      addr:  0xB8000   0xB8002   0xB8004   ... 0xB809E
      bytes: [CH][AT]  [CH][AT]  [CH][AT]  ... [CH][AT]

      Cell [0,0] = 0xB8000
      Example: 0x48 0x0A = H green-on-black
'|
  }

  row1: "Row 1  offset +0x0A0  addr 0xB80A0 to 0xB813F" {
    style: { fill: "#00001a"; stroke: "#334488"; font-color: "#aabbee"; border-radius: 4 }
    r1d: |'md
      base = 0xB8000 + 1 x 160 = 0xB80A0
      col [0] = 0xB80A0
      col [1] = 0xB80A2
      col [79] = 0xB813E
'|
  }

  row_dots: "Rows 2 to 23  (22 rows each 160 bytes)" {
    style: { fill: "#000010"; stroke: "#223366"; font-color: "#778899"; border-radius: 4 }
    rdd: |'md
      Row N base = 0xB8000 + N x 160
      Each row: 80 cells x 2 bytes = 160 bytes
'|
  }

  row24: "Row 24  offset +0xF00  addr 0xB8F00 to 0xB8F9F  LAST ROW" {
    style: { fill: "#00001a"; stroke: "#5566bb"; font-color: "#bbccff"; border-radius: 4 }
    r24d: |'md
      base = 0xB8000 + 24 x 160 = 0xB8F00
      Last cell [24,79]: 0xB8F00 + 79 x 2 = 0xB8F9E
      End of buffer: 0xB8F9E + 2 = 0xB8FA0 (confirmed)
'|
  }

  row0 -> row1: "+160 bytes (one full row)"
  row1 -> row_dots: "+160 bytes per row"
  row_dots -> row24: "+160 bytes (row 23 to row 24)"
}

memory_map: "Physical Memory Context" {
  style: {
    fill: "#0d0a00"
    stroke: "#cc8800"
    stroke-width: 2
    border-radius: 6
    font-color: "#ffcc44"
    bold: true
  }

  regions: |'md
    Physical Range             Size     Region
    0x00000000-0x000003FF      1 KB     Real-mode IVT (legacy)
    0x00000400-0x000004FF      256 B    BIOS Data Area
    0x00007C00-0x00007DFF      512 B    MBR bootloader
    0x00100000 and up          varies   Kernel (loaded here)
    0x000A0000-0x000AFFFF      64 KB    VGA graphics framebuffer
    0x000B8000-0x000B8FA0      4 KB     VGA TEXT BUFFER (this diagram)
    0x000C0000-0x000FFFFF      256 KB   Video BIOS ROM
    0xFEE00000                 4 KB     Local APIC MMIO
'|

  mmio_note: |'md
    MMIO vs RAM:
    RAM write  -> L1 cache (write-back) -> DRAM eventually
    MMIO write -> cache BYPASSED (UC Uncacheable MTRR type)
                  -> device register on memory bus IMMEDIATELY
    VGA text: each cell write appears on screen at next
    raster scan (approx 16ms at 60Hz)
'| {
    style: { fill: "#1a1000"; stroke: "#dd9900"; font-color: "#ffe0aa"; border-radius: 4 }
  }
}

volatile_warning: "WARNING: volatile Is Not Optional" {
  style: {
    fill: "#1a0000"
    stroke: "#ff3333"
    stroke-width: 3
    border-radius: 8
    font-color: "#ff6666"
    bold: true
  }
  warn: |'md
    WITHOUT volatile (BAD):
      uint16_t *VGA = (uint16_t *)0xB8000;
      for (int i = 0; i < 80; i++)
          VGA[i] = vga_entry(' ', 0xF, 0x0);
    GCC -O2: writes never read, eliminates ALL as dead stores
    Screen: unchanged. No warning. Completely silent bug.

    WITH volatile (CORRECT):
      volatile uint16_t *VGA = (volatile uint16_t *)0xB8000;
    Compiler emits store instruction for EVERY write
    Screen updates as expected

    Same rule applies to: UART MMIO, Local APIC registers,
    PCIe BAR registers, GPU VRAM control registers.
'|
}

bus_decode -> buffer_layout: "0xB8000-0xB8FFF decoded to VGA chip\nnot DRAM, direct hardware path" {
  style: { stroke: "#e94560"; stroke-width: 2; animated: true; font-color: "#e94560" }
}

buffer_layout -> cell_anatomy: "each of 2,000 cells\nis exactly 2 bytes" {
  style: { stroke: "#7b2d8b"; stroke-width: 2; font-color: "#cc99ff" }
}

cell_anatomy -> color_table: "attribute byte\nencodes fg and bg from 16-color palette" {
  style: { stroke: "#00cc44"; stroke-width: 2; font-color: "#00ff88" }
}

cell_anatomy -> write_example: "concrete encoding example\nH=0x48 attr=0x0A cell=0x0A48" {
  style: { stroke: "#1e90ff"; stroke-width: 2; font-color: "#66b3ff" }
}

buffer_layout -> grid_view: "80x25 layout\nrow and col address arithmetic" {
  style: { stroke: "#4455aa"; stroke-width: 2; font-color: "#8899dd" }
}

write_example -> volatile_warning: "volatile REQUIRED\nfor all MMIO writes" {
  style: { stroke: "#ff3333"; stroke-width: 2; stroke-dash: 4; font-color: "#ff6666" }
}

buffer_layout -> memory_map: "physical placement\nin full memory map context" {
  style: { stroke: "#cc8800"; stroke-width: 2; font-color: "#ffcc44" }
}