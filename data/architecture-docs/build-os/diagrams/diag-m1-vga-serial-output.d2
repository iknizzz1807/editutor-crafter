Looking at the errors, the main issues are:
1. Line 9: `title` block uses `|md ... |` with `{near: top-center}` — the `{` after the closing `|` is the problem. The block string closing `|` cannot have inline map attributes on the same line in this context. Need to use a separate node with `near`.
2. The `||md ... ||` block strings inside containers with `{ style: ... }` blocks appended after the closing `||` — D2 does not allow `{ }` after a block string value when it's used as a node value inline. The style must be on the parent node, not appended after the block string.
3. `bold: true` inside `style` blocks on containers — `bold` is a style property but only valid on connections/shapes directly, not as a container-level style in all contexts. Actually it should be fine. Let me re-examine.
The core issues:
- `| { style: ... }` after a `|md` block string — this syntax isn't valid when the block string IS the node value. Need to make the md block a child node.
- `||md ... || { style: ... }` — same issue, can't have map after block string terminator.
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: "VGA Text Buffer vs Serial Port — Memory-Mapped I/O vs Port I/O\nVGA: Physical 0xB8000 | COM1: I/O Port 0x3F8 | Milestone 1 — Output Subsystems" {
  near: top-center
  style: {
    font-size: 13
    bold: true
  }
}
back_to_map: "↖ Satellite Map" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#2d2d2d"
    font-color: "#aaaaaa"
    stroke: "#555555"
    border-radius: 4
    font-size: 11
  }
}
vga_panel: "VGA Text Mode Buffer" {
  link: "#vga-text-mode-writing-directly-to-the-screen"
  style: {
    fill: "#0d1b2a"
    stroke: "#1e88e5"
    stroke-width: 2
    border-radius: 6
    font-color: "#90caf9"
    bold: true
    font-size: 13
  }
  vga_header: "Access Method: Memory-Mapped I/O (MMIO)\nPhysical base address: 0xB8000 -> Kernel VA: 0xC00B8000\nGrid: 80 columns x 25 rows = 2,000 character cells\nTotal buffer size: 2,000 x 2 bytes = 4,000 bytes\nBacked by VGA card framebuffer — NOT system DRAM" {
    style: {
      fill: "#0a2540"
      stroke: "#1565c0"
      border-radius: 4
      font-size: 11
    }
  }
  cell_layout: "2-Byte Character Cell Format" {
    style: {
      fill: "#0a1929"
      stroke: "#42a5f5"
      stroke-width: 2
      border-radius: 4
      font-color: "#bbdefb"
      font-size: 12
    }
    byte0_label: "Byte 0 — ASCII Code (offset +0)" {
      style: {
        fill: "#1a237e"
        stroke: "#3949ab"
        font-color: "#c5cae9"
        font-size: 11
      }
    }
    byte0_bits: "[7:0] — 8-bit ASCII character value\nExample: 'A' = 0x41 = 0100 0001\nExample: ' ' = 0x20 = 0010 0000\nExample: 'K' = 0x4B = 0100 1011" {
      style: {
        fill: "#1565c0"
        stroke: "#42a5f5"
        font-color: "#e3f2fd"
        font-size: 11
      }
    }
    byte1_label: "Byte 1 — Color Attribute (offset +1)" {
      style: {
        fill: "#4a148c"
        stroke: "#7b1fa2"
        font-color: "#e1bee7"
        font-size: 11
      }
    }
    byte1_bits: "[7:4] — Background color (4 bits = 16 colors)\n[3:0] — Foreground color (4 bits = 16 colors)\nBit [7] can also = blink enable (mode-dependent)" {
      style: {
        fill: "#6a1b9a"
        stroke: "#ab47bc"
        font-color: "#f3e5f5"
        font-size: 11
      }
    }
    byte0_label -> byte0_bits: "encodes"
    byte1_label -> byte1_bits: "encodes"
  }
  color_table: "Color Attribute Encoding" {
    style: {
      fill: "#0a1929"
      stroke: "#29b6f6"
      border-radius: 4
      font-color: "#b3e5fc"
      font-size: 12
    }
    colors: |md
      | Value | Color      | Value | Color          |
      |-------|------------|-------|----------------|
      | 0x0   | Black      | 0x8   | Dark Gray      |
      | 0x1   | Blue       | 0x9   | Light Blue     |
      | 0x2   | Green      | 0xA   | Light Green    |
      | 0x3   | Cyan       | 0xB   | Light Cyan     |
      | 0x4   | Red        | 0xC   | Light Red      |
      | 0x5   | Magenta    | 0xD   | Light Magenta  |
      | 0x6   | Brown      | 0xE   | Yellow         |
      | 0x7   | Light Gray | 0xF   | White          |
    | {
      style: {
        fill: "#0d2137"
        stroke: "#0288d1"
        font-size: 11
      }
    }
  }
  addr_calc: "Address Formula" {
    style: {
      fill: "#003300"
      stroke: "#4caf50"
      border-radius: 4
      font-color: "#c8e6c9"
      font-size: 12
    }
    formula: |md
      **Linear buffer index:**
      index = row x 80 + col
      **Physical address of cell (row, col):**
      addr = 0xB8000 + (row x 80 + col) x 2
      **Example: char at row=2, col=5**
      index = 2x80+5 = 165
      addr  = 0xB8000 + 165x2 = 0xB814A
      Write: (uint16_t*)0xB814A = (color<<8) OR ascii
      **Why volatile?**
      Writes have hardware side-effects (pixels on screen).
      Compiler cannot prove they are "redundant" — must not
      eliminate or reorder. Use volatile uint16_t *buf.
    | {
      style: {
        fill: "#1b2e1b"
        stroke: "#388e3c"
        font-size: 11
      }
    }
  }
  mem_map: "Physical Memory Footprint" {
    style: {
      fill: "#0a1929"
      stroke: "#ef5350"
      border-radius: 4
      font-color: "#ffcdd2"
      font-size: 12
    }
    offsets: |md
      | Offset  | Address  | Contents                         |
      |---------|----------|----------------------------------|
      | +0x000  | 0xB8000  | Row 0, Col 0 (char+attr)         |
      | +0x002  | 0xB8002  | Row 0, Col 1                     |
      | +0x09E  | 0xB809E  | Row 0, Col 79 (last col)         |
      | +0x0A0  | 0xB80A0  | Row 1, Col 0                     |
      | +0xF9E  | 0xB8F9E  | Row 24, Col 79 (bottom-right)    |
      | +0xFA0  | 0xB8FA0  | End of buffer (4000 bytes)       |
      Not system RAM — routes to VGA card via chipset decode.
      cache_disable bit should be set in MTRRs for MMIO.
    | {
      style: {
        fill: "#1a0a0a"
        stroke: "#c62828"
        font-size: 11
      }
    }
  }
  vga_header -> cell_layout: "each cell is" {
    style.stroke: "#42a5f5"
  }
  cell_layout -> color_table: "color table" {
    style.stroke: "#29b6f6"
  }
  cell_layout -> addr_calc: "linear addressing" {
    style.stroke: "#66bb6a"
  }
  addr_calc -> mem_map: "physical layout" {
    style.stroke: "#ef5350"
  }
}
vga_code: "VGA Driver — C Implementation" {
  style: {
    fill: "#1a1a2e"
    stroke: "#5c6bc0"
    stroke-width: 2
    border-radius: 6
    font-color: "#9fa8da"
    font-size: 12
  }
  code: |c
    #define VGA_BUFFER  ((volatile uint16_t *)0xB8000)
    #define VGA_WIDTH   80
    #define VGA_HEIGHT  25
    /* Color byte: bg<<4 | fg */
    #define VGA_COLOR(fg, bg)  ((bg) << 4 | (fg))
    /* Full 16-bit cell: color<<8 | ascii */
    #define VGA_ENTRY(ch, col) ((uint16_t)(col) << 8 | (uint8_t)(ch))
    /* Example: white 'A' on black at (row=0, col=0) */
    VGA_BUFFER[0] = VGA_ENTRY('A', VGA_COLOR(15, 0));
    /* White (15) on Black (0): attr = 0x0F, cell = 0x0F41 */
    void vga_putchar_at(char c, uint8_t color, int row, int col) {
        const int index = row * VGA_WIDTH + col;
        VGA_BUFFER[index] = VGA_ENTRY(c, color);
    }
    void vga_scroll(void) {
        for (int i = 0; i < (VGA_HEIGHT-1)*VGA_WIDTH; i++)
            VGA_BUFFER[i] = VGA_BUFFER[i + VGA_WIDTH];
        for (int i = (VGA_HEIGHT-1)*VGA_WIDTH;
                 i < VGA_HEIGHT*VGA_WIDTH; i++)
            VGA_BUFFER[i] = VGA_ENTRY(' ', VGA_COLOR(7,0));
    }
  | {
    style: {
      fill: "#0e0e1a"
      stroke: "#3949ab"
      font-size: 11
    }
  }
}
serial_panel: "Serial Port COM1 — UART 16550" {
  link: "#serial-port-debug-output-that-never-lies"
  style: {
    fill: "#1a0d00"
    stroke: "#ff8f00"
    stroke-width: 2
    border-radius: 6
    font-color: "#ffcc80"
    bold: true
    font-size: 13
  }
  serial_header: "Access Method: Port-Mapped I/O (PMIO)\nI/O base address: COM1 = 0x3F8 (x86 IN/OUT instructions)\nChip: Intel 8250/16550 UART (Universal Async Receiver/Transmitter)\nProtocol: 8N1 — 8 data bits, No parity, 1 stop bit\nBaud rate: 115200 (divisor = 1 from 115200Hz internal clock)\nQEMU flag: -serial stdio or -serial file:serial.log" {
    style: {
      fill: "#1a0d00"
      stroke: "#e65100"
      border-radius: 4
      font-color: "#ffe0b2"
      font-size: 11
    }
  }
  reg_map: "COM1 Register Map (base = 0x3F8)" {
    style: {
      fill: "#0d0600"
      stroke: "#f57c00"
      border-radius: 4
      font-color: "#ffcc02"
      font-size: 12
    }
    regs: |md
      | Port  | DLAB | Name                  | R/W | Purpose                           |
      |-------|------|-----------------------|-----|-----------------------------------|
      | 0x3F8 | 0    | RBR / THR             | R/W | Receive Buffer / Transmit Holding |
      | 0x3F8 | 1    | DLL Divisor Low       | R/W | Baud rate divisor [7:0]           |
      | 0x3F9 | 0    | IER Interrupt Enable  | R/W | Enable TX/RX interrupts           |
      | 0x3F9 | 1    | DLH Divisor High      | R/W | Baud rate divisor [15:8]          |
      | 0x3FA | -    | IIR / FCR             | R/W | Interrupt ID / FIFO Control       |
      | 0x3FB | -    | LCR Line Control      | R/W | Data format, DLAB gate            |
      | 0x3FC | -    | MCR Modem Control     | R/W | RTS/DTR control                   |
      | 0x3FD | -    | LSR Line Status       | R   | TX empty, RX ready flags          |
      | 0x3FE | -    | MSR Modem Status      | R   | CTS/DSR status                    |
      DLAB = Divisor Latch Access Bit (LCR bit 7).
      When DLAB=1: ports 0x3F8 and 0x3F9 access the divisor registers.
      When DLAB=0: ports 0x3F8 and 0x3F9 access RBR/THR and IER.
    | {
      style: {
        fill: "#1a0d00"
        stroke: "#ef6c00"
        font-size: 11
      }
    }
  }
  lcr_bits: "LCR — Line Control Register (0x3FB)" {
    style: {
      fill: "#0d0600"
      stroke: "#ff9800"
      border-radius: 4
      font-color: "#ffe082"
      font-size: 12
    }
    layout: |md
      Bit  7  : DLAB  — Divisor Latch Access Bit
                1 = expose divisor regs at 0x3F8/0x3F9
                0 = normal RBR/THR/IER access
      Bit  6  : Break — Force TX line to break condition
      Bit  5  : Stick — Stick parity (unusual, leave 0)
      Bit  4  : EPS   — Even parity select (0=odd, unused in 8N1)
      Bit  3  : PEN   — Parity enable (0 = no parity, 8N1)
      Bit  2  : STB   — Stop bits (0 = 1 stop bit, 8N1)
      Bits 1:0: WLS  — Word length: 00=5bit 01=6bit 10=7bit 11=8bit
      **8N1 value: 0x03** = 0000 0011
      WLS=11(8 data), PEN=0(no parity), STB=0(1 stop bit)
    | {
      style: {
        fill: "#1a0d00"
        stroke: "#ffa726"
        font-size: 11
      }
    }
  }
  lsr_bits: "LSR — Line Status Register (0x3FD)" {
    style: {
      fill: "#0d0600"
      stroke: "#ff9800"
      border-radius: 4
      font-color: "#ffe082"
      font-size: 12
    }
    layout: |md
      Bit 7: ERR  — Error in receiver FIFO
      Bit 6: TEMT — Transmitter Empty (THR + shift reg empty)
      Bit 5: THRE — TX Holding Register Empty (POLL THIS)
               1 = safe to write next byte to THR (0x3F8)
               0 = TX buffer full, must wait
      Bit 4: BI   — Break Interrupt
      Bit 3: FE   — Framing Error
      Bit 2: PE   — Parity Error
      Bit 1: OE   — Overrun Error
      Bit 0: DR   — Data Ready (1 = byte received, read RBR)
      **Polling loop:** while (!(inb(0x3FD) & 0x20));
      Then write: outb(0x3F8, char_byte);
    | {
      style: {
        fill: "#1a0d00"
        stroke: "#ffa726"
        font-size: 11
      }
    }
  }
  baud_calc: "Baud Rate Divisor Calculation" {
    style: {
      fill: "#003300"
      stroke: "#4caf50"
      border-radius: 4
      font-color: "#c8e6c9"
      font-size: 12
    }
    formula: |md
      **UART internal oscillator: 115,200 Hz**
      (IBM PC: 14.318 MHz crystal / 12 / 4 — historical accident)
      Baud = 115200 / Divisor
      Divisor = 115200 / desired_baud
      | Baud Rate | Divisor | DLL  | DLH  |
      |-----------|---------|------|------|
      | 115200    | 1       | 0x01 | 0x00 |
      | 57600     | 2       | 0x02 | 0x00 |
      | 38400     | 3       | 0x03 | 0x00 |
      | 9600      | 12      | 0x0C | 0x00 |
      | 2400      | 48      | 0x30 | 0x00 |
    | {
      style: {
        fill: "#1b2e1b"
        stroke: "#388e3c"
        font-size: 11
      }
    }
  }
  serial_header -> reg_map: "8 registers" {
    style.stroke: "#f57c00"
  }
  reg_map -> lcr_bits: "LCR (0x3FB)" {
    style.stroke: "#ff9800"
  }
  reg_map -> lsr_bits: "LSR (0x3FD)" {
    style.stroke: "#ff9800"
  }
  reg_map -> baud_calc: "DLL/DLH baud" {
    style.stroke: "#66bb6a"
  }
}
serial_code: "Serial Init Sequence — Exact Port Write Order" {
  style: {
    fill: "#1a0a00"
    stroke: "#bf360c"
    stroke-width: 2
    border-radius: 6
    font-color: "#ffab91"
    font-size: 12
  }
  init_steps: "ORDER IS MANDATORY — each write builds on the previous:" {
    style: {
      fill: "#1a0a00"
      stroke: "#d84315"
      font-size: 11
    }
  }
  step1: |md
    **Step 1:** outb(0x3F9, 0x00)
    Write IER = 0x00 — Disable all UART interrupts.
    Must do FIRST — prevents spurious IRQ4 before init is complete.
    Port 0x3F9 with DLAB=0 addresses IER.
  | {
    style: {
      fill: "#1a0600"
      stroke: "#e64a19"
      font-color: "#ff8a65"
      font-size: 11
    }
  }
  step2: |md
    **Step 2:** outb(0x3FB, 0x80)
    Write LCR = 0x80 — Set DLAB=1 (bit 7).
    This "unlocks" the divisor latch registers at 0x3F8/0x3F9.
    Without this, writing to 0x3F8 would go to THR (data), not DLL.
  | {
    style: {
      fill: "#1a0600"
      stroke: "#e64a19"
      font-color: "#ff8a65"
      font-size: 11
    }
  }
  step3: |md
    **Step 3:** outb(0x3F8, 0x01) + outb(0x3F9, 0x00)
    DLL = 0x01, DLH = 0x00 — Divisor = 1 — 115200 baud.
    DLAB must still be 1 for these writes to reach the divisor.
    Writing high byte 0 is mandatory (don't assume it's zeroed).
  | {
    style: {
      fill: "#1a0600"
      stroke: "#e64a19"
      font-color: "#ff8a65"
      font-size: 11
    }
  }
  step4: |md
    **Step 4:** outb(0x3FB, 0x03)
    Write LCR = 0x03 — Clears DLAB=0, sets 8N1 format.
    After this: ports 0x3F8/0x3F9 address THR/RBR and IER again.
    8 data bits (WLS=11), No parity (PEN=0), 1 stop bit (STB=0).
  | {
    style: {
      fill: "#1a0600"
      stroke: "#e64a19"
      font-color: "#ff8a65"
      font-size: 11
    }
  }
  step5: |md
    **Step 5:** outb(0x3FA, 0xC7)
    Write FCR = 0xC7 — Enable FIFO, clear TX+RX FIFOs, 14-byte threshold.
    Bit 0: FIFO enable. Bits 1-2: Clear FIFOs. Bits 6-7: Trigger level.
    Required for 16550 operation; 8250 ignores this register.
  | {
    style: {
      fill: "#1a0600"
      stroke: "#e64a19"
      font-color: "#ff8a65"
      font-size: 11
    }
  }
  step6: |md
    **Step 6:** outb(0x3FC, 0x0B)
    Write MCR = 0x0B — Enable IRQ (bit 3=OUT2), set RTS (bit 1), DTR (bit 0).
    0x0B = 0000 1011: OUT2=1, RTS=1, DTR=1.
    OUT2 gates IRQ4 to the system bus — without it, UART IRQs are suppressed.
  | {
    style: {
      fill: "#1a0600"
      stroke: "#e64a19"
      font-color: "#ff8a65"
      font-size: 11
    }
  }
  step6_done: |md
    **Init complete. Transmit a byte:**
    void serial_putchar(char c) {
        while (!(inb(0x3FD) & 0x20)); /* Wait: THRE=1 */
        outb(0x3F8, c);               /* Write to THR  */
    }
    IN/OUT instructions are **ring 0 only** in protected mode.
    User-mode code cannot access hardware ports directly.
    (IOPL field in EFLAGS controls this; TSS IOPM can grant exceptions.)
  | {
    style: {
      fill: "#003300"
      stroke: "#1b5e20"
      font-color: "#a5d6a7"
      font-size: 11
    }
  }
  init_steps -> step1: "1st"
  step1 -> step2: "2nd (unlock DLAB)"
  step2 -> step3: "3rd (set baud)"
  step3 -> step4: "4th (clear DLAB, set 8N1)"
  step4 -> step5: "5th (enable FIFO)"
  step5 -> step6: "6th (enable IRQ)"
  step6 -> step6_done: "ready to transmit"
}
contrast: "MMIO vs Port I/O — Architectural Comparison" {
  style: {
    fill: "#1a1a1a"
    stroke: "#616161"
    stroke-width: 2
    border-radius: 6
    font-color: "#eeeeee"
    font-size: 12
  }
  mmio_col: "Memory-Mapped I/O (MMIO)" {
    style: {
      fill: "#0a1929"
      stroke: "#1e88e5"
      border-radius: 4
      font-color: "#90caf9"
      font-size: 12
    }
    details: |md
      **Instruction:** Normal MOV, MOVS, pointer dereference
      **Address space:** Lives in the 32-bit physical address space
      **VGA example:** *(uint16_t*)0xB8000 = 0x0741
      **Privilege:** Accessible from any ring if page is mapped
      **Cache:** Must use volatile (or MTRR uncacheable) — not real RAM
      **Routing:** Chipset decodes address, routes to device registers
      **Used by:** VGA buffer, PCIe BARs, LAPIC, HPET, GPU VRAM
      **Pros:** Uses standard load/store; fast with write-combining
      **Cons:** Consumes physical address space; needs page table entry
    | {
      style: {
        fill: "#0d1b2a"
        stroke: "#1565c0"
        font-size: 11
      }
    }
  }
  pmio_col: "Port-Mapped I/O (PMIO)" {
    style: {
      fill: "#1a0d00"
      stroke: "#ff8f00"
      border-radius: 4
      font-color: "#ffcc80"
      font-size: 12
    }
    details: |md
      **Instruction:** IN AL, DX / OUT DX, AL (special x86 instructions)
      **Address space:** Separate 16-bit I/O port space (0x0000-0xFFFF)
      **UART example:** outb(0x3FB, 0x03) — LCR register
      **Privilege:** RING 0 ONLY (or IOPL>=CPL or TSS IOPM grants)
      **Cache:** No cache; each IN/OUT is always a real hardware access
      **Routing:** Separate I/O bus cycle (IO/M# signal asserted)
      **Used by:** PIC (0x20/0xA0), PIT (0x40), PS/2 (0x60/0x64), UART, IDE
      **Pros:** Cannot conflict with physical RAM address space
      **Cons:** Limited to 65536 ports; only IN/OUT instructions work
    | {
      style: {
        fill: "#1a0600"
        stroke: "#e65100"
        font-size: 11
      }
    }
  }
  mmio_col -> pmio_col: "x86 provides BOTH — device type determines which" {
    style.stroke: "#9e9e9e"
    style.stroke-dash: 4
  }
}
vga_panel -> vga_code: "implementation" {
  style.stroke: "#1e88e5"
  style.stroke-dash: 3
}
serial_panel -> serial_code: "init sequence" {
  style.stroke: "#ff8f00"
  style.stroke-dash: 3
}
vga_panel -> contrast: "MMIO mechanism" {
  style.stroke: "#42a5f5"
  style.stroke-dash: 5
  style.animated: true
}
serial_panel -> contrast: "PMIO mechanism" {
  style.stroke: "#ffa726"
  style.stroke-dash: 5
  style.animated: true
}
legend: Legend {
  near: bottom-right
  style: {
    fill: "#1a1a1a"
    stroke: "#424242"
    border-radius: 4
    font-color: "#bdbdbd"
    font-size: 11
  }
  items: |md
    Blue = VGA / MMIO path
    Orange = Serial / Port I/O path
    Green = formulas / calculations
    Red = memory layout / offsets
    volatile = required for MMIO writes
    IN/OUT = ring 0 privilege required
  |
}