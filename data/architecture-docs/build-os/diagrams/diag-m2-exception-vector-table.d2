vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: ||md
  # x86 CPU Exception Vectors 0–31 — Classification Table
  **Intel SDM Vol.3A §6.3** · Every vector's name, type, error-code status, and severity
|| {near: top-center}

back_to_map: "↩ Satellite Map" {
  link: "#anchor-id"
  style: {
    fill: "#1a1a2e"
    font-color: "#a0c4ff"
    stroke: "#a0c4ff"
    stroke-dash: 3
    border-radius: 6
    font-size: 11
  }
}

legend: Legend {
  style: {
    fill: "#1a1a2e"
    stroke: "#444466"
    border-radius: 8
    font-size: 11
  }
  near: bottom-right
  l_abort: "■ ABORT — unrecoverable" {
    style.fill: "#3d0000"
    style.stroke: "#cc0000"
    style.font-color: "#ff6b6b"
    style.border-radius: 4
  }
  l_critical: "■ FAULT critical — common in dev" {
    style.fill: "#2d1a00"
    style.stroke: "#cc6600"
    style.font-color: "#ffaa44"
    style.border-radius: 4
  }
  l_fault: "■ FAULT — restartable after fix" {
    style.fill: "#0d2d0d"
    style.stroke: "#336633"
    style.font-color: "#88cc88"
    style.border-radius: 4
  }
  l_trap: "■ TRAP — EIP past instruction" {
    style.fill: "#0d1a2d"
    style.stroke: "#335588"
    style.font-color: "#88aadd"
    style.border-radius: 4
  }
  l_reserved: "■ RESERVED — do not use" {
    style.fill: "#1e1e1e"
    style.stroke: "#444444"
    style.font-color: "#666666"
    style.border-radius: 4
  }
  l_err: "✦ Error code pushed by CPU" {
    style.fill: "#1a1a1a"
    style.stroke: "#886600"
    style.font-color: "#ddaa00"
    style.border-radius: 4
  }
}

no_err_group: "GROUP A — No Error Code Pushed (CPU pushes: EFLAGS, CS, EIP only)" {
  style: {
    fill: "#0d0d1a"
    stroke: "#334466"
    stroke-width: 2
    border-radius: 8
    font-color: "#8888bb"
    font-size: 12
  }

  vec0: "VEC #0 · #DE · Divide Error" {
    style: {
      fill: "#2d1a00"
      stroke: "#cc6600"
      font-color: "#ffaa44"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✗ None  
      **Trigger:** `DIV` / `IDIV` with zero divisor, or quotient overflow  
      **EIP points to:** The faulting divide instruction (restartable)  
      **Common in dev:** `int x = 1/0;` triggers this immediately  
      **Handler action:** Print message → kill process (or halt in early kernel)
    ||
  }

  vec1: "VEC #1 · #DB · Debug" {
    style: {
      fill: "#0d1a2d"
      stroke: "#335588"
      font-color: "#88aadd"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT/TRAP (depends on cause)  
      **Error Code:** ✗ None  
      **Trigger:** Hardware breakpoint (DR0–DR3), single-step (TF flag), etc.  
      **Used by:** Debuggers (GDB sets DR0 watchpoints to trigger this)  
      **Note:** May be fault (EIP at instruction) or trap (EIP past instruction)
    ||
  }

  vec2: "VEC #2 · #NMI · Non-Maskable Interrupt" {
    style: {
      fill: "#1a1a1a"
      stroke: "#555555"
      font-color: "#999999"
      border-radius: 5
    }
    detail: ||md
      **Type:** INTERRUPT (not maskable by CLI)  
      **Error Code:** ✗ None  
      **Trigger:** Hardware failure signal, IOCHK#, SERR# (memory parity error)  
      **Critical:** Cannot be masked. Fired by: ECC errors, watchdog timers, IPMI  
      **Handler:** Usually: log, attempt graceful shutdown, or MCE handler
    ||
  }

  vec3: "VEC #3 · #BP · Breakpoint" {
    style: {
      fill: "#0d1a2d"
      stroke: "#335588"
      font-color: "#88aadd"
      border-radius: 5
    }
    detail: ||md
      **Type:** TRAP  
      **Error Code:** ✗ None  
      **Trigger:** `INT3` instruction (opcode 0xCC, 1 byte)  
      **EIP points to:** Instruction AFTER INT3  
      **GDB uses:** Replaces target byte with 0xCC, restores on breakpoint hit  
      **IDT DPL:** Usually DPL=3 so debuggers can set breakpoints from user space
    ||
  }

  vec4: "VEC #4 · #OF · Overflow" {
    style: {
      fill: "#0d1a2d"
      stroke: "#335588"
      font-color: "#88aadd"
      border-radius: 5
    }
    detail: ||md
      **Type:** TRAP  
      **Error Code:** ✗ None  
      **Trigger:** `INTO` instruction when OF flag is set  
      **EIP points to:** Instruction after INTO  
      **Rarity:** Almost never used in modern code (INTO is 32-bit only, no 64-bit)
    ||
  }

  vec5: "VEC #5 · #BR · BOUND Range Exceeded" {
    style: {
      fill: "#0d1a2d"
      stroke: "#335588"
      font-color: "#88aadd"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✗ None  
      **Trigger:** `BOUND` instruction — array index out of range  
      **EIP points to:** The BOUND instruction (restartable)  
      **Rarity:** Obsolete; removed in 64-bit long mode
    ||
  }

  vec6: "VEC #6 · #UD · Invalid Opcode" {
    style: {
      fill: "#2d1a00"
      stroke: "#cc6600"
      font-color: "#ffaa44"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✗ None  
      **Trigger:** Undefined opcode, `UD2`, privileged instruction from ring 3  
      **EIP points to:** The invalid instruction  
      **Common in dev:** Bad cross-compiler, wrong -m32/-m64 flag, corrupted jump  
      **`UD2` use:** Compiler-emitted "should be unreachable" assertion marker
    ||
  }

  vec7: "VEC #7 · #NM · Device Not Available" {
    style: {
      fill: "#0d2d0d"
      stroke: "#336633"
      font-color: "#88cc88"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✗ None  
      **Trigger:** FPU/MMX/SSE instruction when CR0.TS=1 (task switched) or CR0.EM=1  
      **OS use:** Lazy FPU context switching — only save/restore FPU state when needed  
      **Handler:** Save FPU state of old process, restore for current, clear CR0.TS
    ||
  }

  vec9: "VEC #9 · Coprocessor Overrun (OBSOLETE)" {
    style: {
      fill: "#1e1e1e"
      stroke: "#444444"
      font-color: "#666666"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT (obsolete — never fires on 486+)  
      **Error Code:** ✗ None  
      **Note:** Historical 80387 coprocessor segment overrun. Never seen on modern hardware.  
      **Handler:** Install stub that halts — this should never fire
    ||
  }

  vec16: "VEC #16 · #MF · x87 Floating-Point" {
    style: {
      fill: "#0d2d0d"
      stroke: "#336633"
      font-color: "#88cc88"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✗ None  
      **Trigger:** x87 FPU exception (masked by default; fires only when unmasked)  
      **Note:** FPU exceptions are deferred — fires on NEXT FP instruction  
      **SW use:** High-precision math libraries that need exact FP error detection
    ||
  }

  vec18: "VEC #18 · #MC · Machine Check" {
    style: {
      fill: "#3d0000"
      stroke: "#cc0000"
      font-color: "#ff6b6b"
      border-radius: 5
    }
    detail: ||md
      **Type:** ABORT  
      **Error Code:** ✗ None (error info in MSRs IA32_MC*_STATUS)  
      **Trigger:** CPU-detected hardware error: bus error, ECC DRAM failure, thermal  
      **Severity:** ABORT — recovery impossible  
      **Handler:** Log MSRs, display panic message. Linux: `mce_panic()`. System must reboot.
    ||
  }

  vec19: "VEC #19 · #XM · SIMD Floating-Point" {
    style: {
      fill: "#0d2d0d"
      stroke: "#336633"
      font-color: "#88cc88"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✗ None  
      **Trigger:** SSE/SSE2/AVX exception (when unmasked in MXCSR register)  
      **Handler:** Read MXCSR for exact cause, report to process
    ||
  }

  vec1_3_4_5: "VEC #1, #3, #4, #5 — Note on TRAP vs FAULT" {
    style: {
      fill: "#111122"
      stroke: "#334466"
      font-color: "#7788aa"
      border-radius: 5
      font-size: 11
    }
    detail: ||md
      **FAULT:** EIP saved = address of faulting instruction. Handler can fix and `iret` to RETRY.  
      **TRAP:** EIP saved = address AFTER instruction. The instruction already executed; no retry.  
      **ABORT:** State too corrupt to retry. Must halt or reboot.  
      `#DB` can be either, depending on cause. `#BP` (#3) is always TRAP (INT3 already ran).
    ||
  }

  reserved_group: "VEC #15, #20–#31 — RESERVED by Intel" {
    style: {
      fill: "#111111"
      stroke: "#333333"
      font-color: "#555555"
      border-radius: 5
    }
    detail: ||md
      **Status:** Reserved — no hardware currently generates these  
      **Action:** Install stub ISRs that print "Reserved exception #N — kernel bug" and halt  
      **Why install them:** If a bad IDT entry or bug triggers one, you want a diagnostic, not a silent triple-fault
    ||
  }
}

err_group: "GROUP B — Error Code Pushed by CPU  ✦  (CPU pushes: EFLAGS, CS, EIP, ERROR_CODE)" {
  style: {
    fill: "#0d0d0a"
    stroke: "#665500"
    stroke-width: 2
    border-radius: 8
    font-color: "#bbaa44"
    font-size: 12
  }

  err_note: "Error Code Format (16-bit, zero-extended to 32-bit)" {
    style: {
      fill: "#1a1500"
      stroke: "#886600"
      font-color: "#ddaa00"
      border-radius: 5
    }
    detail: ||md
      Bits 15–3 : Selector Index (GDT/LDT entry that caused the fault, or 0)
      Bit  2    : TI  — 0=GDT, 1=LDT
      Bit  1    : IDT — 1 if index refers to IDT gate (e.g., double fault cause)
      Bit  0    : EXT — 1 if fault was caused by an event external to the program
      
      **Exception:** #PF (vec 14) error code has COMPLETELY DIFFERENT meaning.  
      **Exception:** #DF (vec 8) error code is ALWAYS 0.  
      **Stack effect:** `add esp, 4` MUST be done before `iret`.
    ||
  }

  vec8: "VEC #8 · #DF · Double Fault  ⚠ ABORT" {
    style: {
      fill: "#3d0000"
      stroke: "#cc0000"
      stroke-width: 3
      font-color: "#ff6b6b"
      border-radius: 5
      bold: true
    }
    detail: ||md
      **Type:** ABORT — recovery impossible  
      **Error Code:** ✦ ALWAYS 0  
      **Trigger:** Exception fires WHILE handling another exception (fault-pair matrix)  
      **Handler:** Print: "DOUBLE FAULT — stack corrupt" → CLI+HLT
    ||
  }

  vec10: "VEC #10 · #TS · Invalid TSS" {
    style: {
      fill: "#2d1500"
      stroke: "#885500"
      font-color: "#ddaa44"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✦ Selector index of the invalid TSS descriptor  
      **Trigger:** Loading a selector that refers to an invalid or absent TSS
    ||
  }

  vec11: "VEC #11 · #NP · Segment Not Present" {
    style: {
      fill: "#2d1500"
      stroke: "#885500"
      font-color: "#ddaa44"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✦ Selector of the not-present segment  
      **Trigger:** Loading a segment selector where GDT/LDT entry has P=0
    ||
  }

  vec12: "VEC #12 · #SS · Stack Segment Fault" {
    style: {
      fill: "#2d1500"
      stroke: "#885500"
      font-color: "#ddaa44"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✦ SS selector (or 0)  
      **Trigger:** Stack operation exceeds SS limit
    ||
  }

  vec13: "VEC #13 · #GP · General Protection Fault  ⚠ CRITICAL" {
    style: {
      fill: "#2d1a00"
      stroke: "#cc6600"
      stroke-width: 3
      font-color: "#ffaa44"
      border-radius: 5
      bold: true
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✦ Selector index or 0  
      **Trigger:** Ring 3 executes privileged instruction, loading null selector, DPL mismatch.
    ||
  }

  vec14: "VEC #14 · #PF · Page Fault  ⚠ CRITICAL" {
    style: {
      fill: "#001a2d"
      stroke: "#0066cc"
      stroke-width: 3
      font-color: "#44aaff"
      border-radius: 5
      bold: true
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✦ SPECIAL P|W|U|R|I bits  
      **CR2 register:** Contains the FAULTING VIRTUAL ADDRESS  
      **Use:** Engine for demand paging, fork COW, and stack growth
    ||
  }

  vec17: "VEC #17 · #AC · Alignment Check" {
    style: {
      fill: "#2d1500"
      stroke: "#885500"
      font-color: "#ddaa44"
      border-radius: 5
    }
    detail: ||md
      **Type:** FAULT  
      **Error Code:** ✦ Always 0  
      **Trigger:** Misaligned memory access (CR0.AM=1, EFLAGS.AC=1, CPL=3)
    ||
  }
}

stack_diagram: "Kernel Stack Layout: Exception Entry" {
  style: {
    fill: "#0a0a1a"
    stroke: "#445566"
    stroke-width: 2
    border-radius: 8
    font-color: "#aabbcc"
    font-size: 11
  }
  near: bottom-left
  layout: ||md
    **WITH error code (#8,#10–#14,#17):**
    
    ┌──────────────────────────────┐ ← ESP+16
    │  EFLAGS                      │
    ├──────────────────────────────┤ ← ESP+12
    │  CS                          │
    ├──────────────────────────────┤ ← ESP+8
    │  EIP (faulting instruction)  │
    ├──────────────────────────────┤ ← ESP+4
    │  ERROR CODE  ✦               │ ← pushed by CPU
    ├──────────────────────────────┤ ← ESP ← handler entry
  ||
}

severity_matrix: "Severity × Recoverability Matrix" {
  style: {
    fill: "#0a0a0a"
    stroke: "#555555"
    border-radius: 8
    font-size: 11
    font-color: "#aaaaaa"
  }
  matrix: ||md
    | Severity | Vectors | Kernel Recovery? | Process Recovery? |
    |----------|---------|-----------------|-------------------|
    | **ABORT** (red) | #8 #18 | ✗ Must halt | ✗ Impossible |
    | **CRITICAL FAULT** (orange) | #0 #6 #13 #14 | ✓ Yes | Kill process |
    | **FAULT** (green) | #5 #7 #10–12 #16–17 | ✓ Fix & retry | Kill or continue |
    | **TRAP** (blue) | #1 #3 #4 | ✓ EIP past insn | Continue |
  ||
}

back_to_map -> no_err_group: "vec 0–7, 9, 15–19, 20–31" {
  style: { stroke: "#334466"; stroke-dash: 4; font-size: 10 }
}
back_to_map -> err_group: "vec 8, 10–14, 17" {
  style: { stroke: "#665500"; stroke-dash: 4; font-size: 10 }
}
vec8 -> stack_diagram: "error code = 0"
vec13 -> stack_diagram: "error code = selector"
vec14 -> stack_diagram: "error code = flags"
err_note -> vec14: "Special P|W|U|R|I bits" { style: { stroke: "#0066cc"; font-color: "#44aaff" } }