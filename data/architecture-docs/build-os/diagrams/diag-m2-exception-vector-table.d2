vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # CPU Exception Vectors 0â€“31 â€” Classification Table
  **x86 Protected Mode Â· Intel SDM Vol. 3A Â§6.15**
| {near: top-center}
legend: {
  near: bottom-left
  style: {
    fill: "#1a1a2e"
    stroke: "#444466"
    border-radius: 8
  }
  content: |md
    **Color Semantics**
    ðŸŸ¥ Abort â€” Unrecoverable, system must halt
    ðŸŸ§ Fault/Critical â€” EIP â†’ faulting instr; handler can recover
    ðŸŸ¨ Fault/Warn â€” Common during development
    ðŸŸ© Trap â€” EIP â†’ NEXT instr after trap
    â¬œ Reserved â€” Do not use
    **Error Code** âœ“ = CPU pushes extra 32-bit word before calling handler
  |
}
back_to_map: "â†– Satellite Map" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#2a2a4a"
    stroke: "#6666aa"
    font-color: "#aaaadd"
    border-radius: 6
    font-size: 11
  }
}
# â”€â”€ COLUMN HEADERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
headers: {
  style: {
    fill: "#0d0d1a"
    stroke: "#333366"
    border-radius: 4
  }
  h: |md
    Vec | Mnemonic | Name | Type | Err? | EIP Points To | Trigger
    \# | SYM | Description | Class | Code | Recovery | Cause
  |
}
# â”€â”€ GROUP A: ARITHMETIC & LOGIC (0â€“7) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
group_arith: "Group A â€” Arithmetic & Logic Â· Vectors 0â€“7 Â· No Error Code" {
  style: {
    fill: "#1a1a2e"
    stroke: "#555588"
    border-radius: 6
    font-color: "#aaaacc"
    font-size: 12
  }
  vec0: {
    style: { fill: "#3d1a1a"; stroke: "#cc4444"; border-radius: 4 }
    label: |md
      **#0 â€” #DE â€” Divide Error**
      Type: **FAULT** Â· Error Code: **NO** Â· EIP â†’ faulting div/idiv instr
      Trigger: DIV or IDIV with divisor=0, or quotient overflows register
      Handler: Print diagnostic + kill process (or return error to userspace)
      Common bug: int x = value / 0; or divide result > 32-bit range
    |
  }
  vec1: {
    style: { fill: "#1a2a1a"; stroke: "#44aa44"; border-radius: 4 }
    label: |md
      **#1 â€” #DB â€” Debug**
      Type: **FAULT/TRAP** Â· Error Code: **NO** Â· EIP varies by sub-type
      Trigger: Hardware breakpoint (DR0â€“DR3), single-step (EFLAGS.TF=1)
      Fault: EIP â†’ faulting instr. Trap: EIP â†’ NEXT instr.
      Used by: GDB hardware breakpoint, CPU performance counters
    |
  }
  vec2: {
    style: { fill: "#2a1a3a"; stroke: "#9944cc"; border-radius: 4 }
    label: |md
      **#2 â€” NMI â€” Non-Maskable Interrupt**
      Type: **INTERRUPT** Â· Error Code: **NO** Â· Fires regardless of cli
      Trigger: Hardware failure (RAM ECC error), watchdog timer, debugger
      Cannot be masked with cli. Always delivered. System usually must halt.
      Used by: Hardware health monitoring, IPMI, kernel debuggers (kgdb)
    |
  }
  vec3: {
    style: { fill: "#1a2a1a"; stroke: "#44aa44"; border-radius: 4 }
    label: |md
      **#3 â€” #BP â€” Breakpoint**
      Type: **TRAP** Â· Error Code: **NO** Â· EIP â†’ instruction AFTER int3
      Trigger: INT3 (1-byte opcode 0xCC) â€” inserted by debugger in code
      EIP points past the INT3, so handler can inspect/resume cleanly
      Used by: GDB software breakpoints, profilers, dynamic instrumentation
    |
  }
  vec4: {
    style: { fill: "#1a2a1a"; stroke: "#44aa44"; border-radius: 4 }
    label: |md
      **#4 â€” #OF â€” Overflow**
      Type: **TRAP** Â· Error Code: **NO** Â· EIP â†’ instruction AFTER into
      Trigger: INTO instruction when EFLAGS.OF=1 (overflow flag set)
      Rarely used in modern code. INTO was common in 8086-era programs.
      EIP points to instruction after INTO; result of computation already done.
    |
  }
  vec5: {
    style: { fill: "#1a2a3a"; stroke: "#4466aa"; border-radius: 4 }
    label: |md
      **#5 â€” #BR â€” BOUND Range Exceeded**
      Type: **FAULT** Â· Error Code: **NO** Â· EIP â†’ bound instruction
      Trigger: BOUND instruction checks array index against memory limits
      EIP â†’ the BOUND instruction (can retry after fixing bounds).
      Rarely used. No compiler generates BOUND in modern toolchains.
    |
  }
  vec6: {
    style: { fill: "#3d2a1a"; stroke: "#cc8844"; border-radius: 4 }
    label: |md
      **#6 â€” #UD â€” Invalid Opcode**
      Type: **FAULT** Â· Error Code: **NO** Â· EIP â†’ invalid instruction
      Trigger: CPU encounters undefined opcode, UD2 (deliberate), misaligned
      SSE instruction, privilege violation (ring-3 executing hlt, lidt)
      EIP â†’ the bad instruction. Handler can emulate it or kill the process.
      Dev note: Often indicates wrong architecture (64-bit code on 32-bit CPU)
    |
  }
  vec7: {
    style: { fill: "#1a2a3a"; stroke: "#4466aa"; border-radius: 4 }
    label: |md
      **#7 â€” #NM â€” Device Not Available**
      Type: **FAULT** Â· Error Code: **NO** Â· EIP â†’ FPU/SSE instruction
      Trigger: FPU/MMX/SSE instruction when CR0.TS=1 (task-switched flag)
      OS uses CR0.TS to defer FPU context saves â€” fault triggers actual save.
      Handler: Save previous task's FPU state, load current task's FPU state.
    |
  }
}
# â”€â”€ GROUP B: CRITICAL SYSTEM FAULTS (8â€“14) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
group_critical: "Group B â€” Critical System Faults Â· Vectors 8â€“14 Â· Error Code Required" {
  style: {
    fill: "#1a0d0d"
    stroke: "#aa2222"
    border-radius: 6
    font-color: "#ddaaaa"
    font-size: 12
  }
  vec8: {
    style: { fill: "#5a0000"; stroke: "#ff2222"; stroke-width: 3; border-radius: 4; shadow: true }
    label: |md
      **#8 â€” #DF â€” DOUBLE FAULT â€” ABORT**
      Type: **ABORT** Â· Error Code: **YES (always 0)** Â· UNRECOVERABLE
      Trigger: Exception while handling another exception (cascade failure)
      OR: Handler address unmapped, stack overflowed into unmapped page
      Error code = 0 ALWAYS (CPU cannot encode which original fault caused it)
      **Handler MUST halt** â€” any further fault = TRIPLE FAULT = CPU RESET
      Dev note: Use dedicated IST stack (via TSS) to survive stack-corruption #DF
      EIP = address of faulting instruction in the FIRST exception handler
    |
  }
  vec9: {
    style: { fill: "#2a2a1a"; stroke: "#888844"; border-radius: 4 }
    label: |md
      **#9 â€” Coprocessor Segment Overrun (OBSOLETE)**
      Type: **ABORT** Â· Error Code: **NO** Â· Only on 386/486 with 387 FPU
      Trigger: FPU operand or result crossed a segment boundary (pre-486)
      Modern CPUs: Never generated. Vector reserved, must have valid handler.
      Handler: Just halt. This exception is a historical artifact.
    |
  }
  vec10: {
    style: { fill: "#3d1a1a"; stroke: "#cc4444"; border-radius: 4 }
    label: |md
      **#10 â€” #TS â€” Invalid TSS**
      Type: **FAULT** Â· Error Code: **YES (selector index)** Â· EIP â†’ faulting instr
      Trigger: Hardware task switch to TSS with invalid descriptor, or
      iret to a task whose TSS is invalid/not-present
      Error code = selector index of invalid segment + table indicator bits
      In software-switched OS: only fires if TSS descriptor itself is corrupt.
    |
  }
  vec11: {
    style: { fill: "#3d1a1a"; stroke: "#cc4444"; border-radius: 4 }
    label: |md
      **#11 â€” #NP â€” Segment Not Present**
      Type: **FAULT** Â· Error Code: **YES (selector index)** Â· EIP â†’ faulting instr
      Trigger: Loading a segment register with a selector whose descriptor P=0
      Error code = selector that was not present (GDT/LDT index + TI + RPL bits)
      Handler: Load the segment descriptor (e.g., from disk) and set P=1, retry.
      Modern OS: Rarely seen unless swapping segment descriptors (unusual).
    |
  }
  vec12: {
    style: { fill: "#3d1a1a"; stroke: "#cc4444"; border-radius: 4 }
    label: |md
      **#12 â€” #SS â€” Stack-Segment Fault**
      Type: **FAULT** Â· Error Code: **YES (selector or 0)** Â· EIP â†’ faulting instr
      Trigger: Stack access beyond SS segment limit, or loading SS with invalid desc
      Error code = SS selector if descriptor error; 0 if stack limit violation
      Common cause: Kernel stack overflow â€” stack grows into unmapped page
      If SS itself is invalid: double fault may follow immediately
    |
  }
  vec13: {
    style: { fill: "#5a1a00"; stroke: "#ff6600"; stroke-width: 3; border-radius: 4; shadow: true }
    label: |md
      **#13 â€” #GP â€” General Protection Fault â€” HOT PATH**
      Type: **FAULT** Â· Error Code: **YES (selector or 0)** Â· EIP â†’ faulting instr
      Trigger: Ring-3 code executes privileged instr (hlt, lgdt, lidt, in, out)
      OR: Loading CS/SS/DS/ES with descriptor of wrong DPL for CPL
      OR: Null segment selector used for memory access
      OR: Any other protection violation not covered by #NP, #SS, #PF
      Error code: selector index if segment-related; 0 for other violations
      **Most frequent kernel development fault** â€” almost every protection
      violation ends here. Print EIP + error code for diagnosis.
    |
  }
  vec14: {
    style: { fill: "#5a2a00"; stroke: "#ff8800"; stroke-width: 3; border-radius: 4; shadow: true }
    label: |md
      **#14 â€” #PF â€” Page Fault â€” CRITICAL / DEMAND PAGING ENGINE**
      Type: **FAULT** Â· Error Code: **YES (P/W/U/R/I bits)** Â· EIP â†’ faulting instr
      Trigger: Any memory access that violates page table permissions or unmapped
      **CR2** = virtual address that caused the fault (MUST read CR2 in handler!)
      Error code bit layout:
      Bit 0 (P): 0=page not present, 1=protection violation (page IS present)
      Bit 1 (W): 0=read access, 1=write access
      Bit 2 (U): 0=kernel mode fault, 1=user mode fault
      Bit 3 (R): 1=reserved bit set in PTE (CPU/kernel bug)
      Bit 4 (I): 1=instruction fetch (NX bit violation, if NX enabled)
      **Demand paging**: P=0 â†’ allocate frame, map, retry faulting instruction
      **Copy-on-Write**: P=1,W=1 â†’ duplicate frame, remap, retry write
      **Null deref**: CR2â‰ˆ0 â†’ kernel/user null pointer â€” kill process or panic
      **Kernel #PF**: Always a bug â€” print CR2, EIP, error code, halt.
    |
  }
}
# â”€â”€ GROUP C: FP / SIMD / ALIGNMENT (15â€“19) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
group_fp: "Group C â€” FP, SIMD, Alignment Â· Vectors 15â€“19 Â· Mixed Error Codes" {
  style: {
    fill: "#0d1a1a"
    stroke: "#336666"
    border-radius: 6
    font-color: "#aacccc"
    font-size: 12
  }
  vec15: {
    style: { fill: "#1a1a2a"; stroke: "#555588"; border-radius: 4 }
    label: |md
      **#15 â€” RESERVED (Intel Reserved)**
      Type: **â€”** Â· Error Code: **â€”** Â· Never generated by CPU
      Must have a valid IDT handler (install a stub that halts or logs).
      If this fires, the CPU has a serious bug or your IDT is corrupt.
    |
  }
  vec16: {
    style: { fill: "#1a2a3a"; stroke: "#4466aa"; border-radius: 4 }
    label: |md
      **#16 â€” #MF â€” x87 Floating-Point Exception (Math Fault)**
      Type: **FAULT** Â· Error Code: **NO** Â· EIP â†’ NEXT instruction (!)
      Trigger: x87 FPU encounters unmasked floating-point exception:
      divide-by-zero, overflow, underflow, precision, invalid operation
      Note: EIP â†’ instruction AFTER the FP instruction (deferred reporting)
      Handler must read FPU status word (fnstsw ax) to determine sub-cause.
    |
  }
  vec17: {
    style: { fill: "#1a2a3a"; stroke: "#4466aa"; border-radius: 4 }
    label: |md
      **#17 â€” #AC â€” Alignment Check**
      Type: **FAULT** Â· Error Code: **YES (always 0)** Â· EIP â†’ unaligned access
      Trigger: CR0.AM=1 + EFLAGS.AC=1 + ring-3 accesses unaligned memory
      (e.g., 4-byte int at address 0x3 â€” not 4-byte aligned)
      Disabled by default in most OSes. Error code always 0.
      Handler: log + kill process (or fix alignment in kernel if kernel fault)
    |
  }
  vec18: {
    style: { fill: "#5a0000"; stroke: "#ff2222"; stroke-width: 2; border-radius: 4 }
    label: |md
      **#18 â€” #MC â€” Machine Check â€” ABORT**
      Type: **ABORT** Â· Error Code: **NO (uses MSRs)** Â· UNRECOVERABLE
      Trigger: Hardware error detected by CPU: RAM ECC failure, bus error,
      cache parity error, thermal throttle violation, microcode error
      Diagnostic info in MSRs (IA32_MCi_STATUS, IA32_MCi_ADDR, etc.)
      Handler: Log MCi_STATUS MSRs, then halt â€” hardware is unreliable.
      Modern systems: MCA (Machine Check Architecture) provides detailed info.
    |
  }
  vec19: {
    style: { fill: "#1a2a3a"; stroke: "#4466aa"; border-radius: 4 }
    label: |md
      **#19 â€” #XM â€” SIMD Floating-Point Exception**
      Type: **FAULT** Â· Error Code: **NO** Â· EIP â†’ faulting SSE instruction
      Trigger: SSE/SSE2/SSE3 instruction with unmasked FP exception:
      MXCSR.IM, .DM, .ZM, .OM, .UM, .PM control masking
      Handler: Read MXCSR status bits to determine sub-cause.
      Similar to #MF but for SSE registers (XMM0â€“XMM7).
    |
  }
}
# â”€â”€ GROUP D: RESERVED 20â€“31 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
group_reserved: "Group D â€” Intel Reserved Â· Vectors 20â€“31 Â· Never Generated" {
  style: {
    fill: "#0d0d0d"
    stroke: "#333333"
    border-radius: 6
    font-color: "#666666"
    font-size: 11
  }
  reserved_block: {
    style: { fill: "#141414"; stroke: "#333333"; border-radius: 4 }
    label: |md
      **Vectors 20â€“31 â€” RESERVED by Intel Architecture**
      #20 (0x14) Â· #21 (0x15) Â· #22 (0x16) Â· #23 (0x17)
      #24 (0x18) Â· #25 (0x19) Â· #26 (0x1A) Â· #27 (0x1B)
      #28 (0x1C) Â· #29 (0x1D) Â· #30 (0x1E) Â· #31 (0x1F)
      Status: Not generated by any current x86 CPU.
      Rule: Install stubs anyway â€” if they fire, the IDT is corrupt
      or a future CPU revision has assigned them. Halt + log.
      Your IDT[20..31] must have valid, present gate descriptors.
      Error code: NONE for all reserved vectors.
    |
  }
}
# â”€â”€ ERROR CODE REFERENCE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
errcode_ref: "Error Code Format (when pushed by CPU)" {
  style: {
    fill: "#1a1a0d"
    stroke: "#666633"
    border-radius: 6
    font-color: "#ccccaa"
  }
  content: |md
    **Selector-based error code (used by #10, #11, #12, #13):**
    Bits 31-16: Reserved (0)
    Bits 15-3 : Selector index (which GDT/LDT/IDT entry caused the fault)
    Bit  2    : TI â€” 0=GDT, 1=LDT
    Bit  1    : IDT â€” 1=error refers to IDT gate descriptor
    Bit  0    : EXT â€” 1=external event (e.g., hardware interrupt) caused this
    **Page fault error code (used by #14):**
    Bit 4 (I) : Instruction fetch (NX violation)
    Bit 3 (R) : Reserved PTE bit was set (CPU bug or kernel bug)
    Bit 2 (U) : 1=user-mode access,  0=kernel-mode access
    Bit 1 (W) : 1=write access,      0=read access
    Bit 0 (P) : 1=page present (permission violation), 0=page not mapped
    **Stack layout when error code IS pushed (e.g., #PF):**
    [ESP+16] EFLAGS
    [ESP+12] CS
    [ESP+8]  EIP  â† return address (faulting instruction)
    [ESP+4]  Error code  â† pushed by CPU BEFORE calling handler
    [ESP+0]  â† ESP when your ISR stub receives control
    **CRITICAL:** Remove error code (pop or add esp,4) BEFORE iret.
    Failing to do so causes iret to pop the error code as EFLAGS â†’ crash.
  |
}
# â”€â”€ QUICK REFERENCE SUMMARY TABLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
summary: "Quick Reference â€” Error Code / No Error Code Split" {
  style: {
    fill: "#0d1a0d"
    stroke: "#336633"
    border-radius: 6
  }
  content: |md
    **Exceptions without Error Code:** #0,#1,#2,#3,#4,#5,#6,#7,#9,#16,#18,#19
    **Exceptions with Error Code:** #8,#10,#11,#12,#13,#14,#17
    **Reserved:** #15, #20â€“#31
    **Exceptions that require immediate halt (Aborts):**
    #8 Double Fault Â· #18 Machine Check
    **Exceptions that drive OS features (hot path):**
    #14 Page Fault â†’ demand paging, CoW, mmap
    #13 General Protection â†’ ring enforcement, segfault
    #1 Debug / #3 Breakpoint â†’ debugger support
    **Your ISR stub strategy:**
    ISR_NOERR: push 0 (fake err code) + push vec_num â†’ isr_common_stub
    ISR_ERR:   (CPU already pushed err code) + push vec_num â†’ isr_common_stub
    Result: uniform stack frame for all 256 handlers in C
  |
}
# â”€â”€ CONNECTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
group_arith -> group_critical: "escalates to #DF if handler faults" {
  style: { stroke: "#aa2222"; stroke-dash: 5; font-size: 11; font-color: "#cc4444" }
}
group_critical -> errcode_ref: "error code format applies to #8,#10â€“#14" {
  style: { stroke: "#cc6600"; font-size: 11; font-color: "#cc8844" }
}
group_fp -> errcode_ref: "#17 also pushes error code (always 0)" {
  style: { stroke: "#446688"; stroke-dash: 4; font-size: 11; font-color: "#6688aa" }
}
group_critical -> summary: "most critical exceptions summarized" {
  style: { stroke: "#336633"; stroke-dash: 3; font-size: 11; font-color: "#44aa44" }
}
group_reserved -> summary: "reserved range noted" {
  style: { stroke: "#444444"; stroke-dash: 6; font-size: 11; font-color: "#666666" }
}