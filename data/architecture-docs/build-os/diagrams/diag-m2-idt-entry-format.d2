The error is on line 228: the `c_struct` node uses `|||go` block string but the closing delimiter `|||` is being parsed incorrectly because there's a `{...}` style block appended after it inline. In D2, you cannot attach a map `{ }` after a block string on the same closing line — the style block must be a separate statement, or the node must be declared separately.
The fix: declare `c_struct` as a keyed node, then set its style properties separately (or use a label with the code block and attach style via dot notation).
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  ## IDT Gate Descriptor — 8-Byte Entry Layout
  *x86 Protected Mode · Intel SDM Vol. 3A §6.11*
| {near: top-center}
back_to_map: "↖ Satellite Map" {
  link: "#anchor-id-satellite-os-map"
  style: {
    fill: "#2d2d2d"
    font-color: "#aaaaaa"
    font-size: 11
    border-radius: 4
    stroke: "#555555"
  }
}
ruler: "Byte Offset" {
  style: {
    fill: "#1a1a2e"
    font-color: "#888888"
    stroke: "#333366"
    font-size: 12
    bold: true
  }
  b0: "Byte 0" {
    style.fill: "#1a1a2e"
    style.font-color: "#666699"
    style.stroke: "#333366"
    style.font-size: 11
  }
  b1: "Byte 1" {
    style.fill: "#1a1a2e"
    style.font-color: "#666699"
    style.stroke: "#333366"
    style.font-size: 11
  }
  b2: "Byte 2" {
    style.fill: "#1a1a2e"
    style.font-color: "#666699"
    style.stroke: "#333366"
    style.font-size: 11
  }
  b3: "Byte 3" {
    style.fill: "#1a1a2e"
    style.font-color: "#666699"
    style.stroke: "#333366"
    style.font-size: 11
  }
  b4: "Byte 4" {
    style.fill: "#1a1a2e"
    style.font-color: "#666699"
    style.stroke: "#333366"
    style.font-size: 11
  }
  b5: "Byte 5" {
    style.fill: "#1a1a2e"
    style.font-color: "#666699"
    style.stroke: "#333366"
    style.font-size: 11
  }
  b6: "Byte 6" {
    style.fill: "#1a1a2e"
    style.font-color: "#666699"
    style.stroke: "#333366"
    style.font-size: 11
  }
  b7: "Byte 7" {
    style.fill: "#1a1a2e"
    style.font-color: "#666699"
    style.stroke: "#333366"
    style.font-size: 11
  }
}
descriptor: "IDT Gate Descriptor  [8 bytes = 64 bits]" {
  link: "#anchor-id-idt"
  style: {
    fill: "#0d1117"
    stroke: "#58a6ff"
    stroke-width: 2
    font-color: "#e6edf3"
    font-size: 14
    bold: true
    border-radius: 4
  }
  offset_low: |md
    **OFFSET [15:0]** — Bytes 0-1
    Handler address bits 15 down to 0
    (low word of ISR virtual address)
    uint16\_t offset\_low
    Example: isr\_14 at 0xC0104A20
    offset\_low = 0x4A20
  | {
    style: {
      fill: "#0d3b6e"
      stroke: "#1f6feb"
      stroke-width: 2
      font-color: "#79c0ff"
      font-size: 12
      border-radius: 3
    }
  }
  selector: |md
    **SEGMENT SELECTOR** — Bytes 2-3
    GDT index that defines the handler's
    code segment. Always 0x0008
    GDT entry 1 (Kernel Code, Ring 0)
    Bits[15:3]=1, TI=0, RPL=0
    uint16\_t selector = 0x0008
  | {
    style: {
      fill: "#1a3a1a"
      stroke: "#3fb950"
      stroke-width: 2
      font-color: "#7ee787"
      font-size: 12
      border-radius: 3
    }
  }
  reserved: |md
    **RESERVED** — Byte 4
    Must be 0x00
    Architecture requirement.
    Any non-zero value causes GP fault
    on IDT load or interrupt dispatch
    uint8\_t reserved = 0x00
  | {
    style: {
      fill: "#2d2d2d"
      stroke: "#666666"
      stroke-dash: 4
      font-color: "#888888"
      font-size: 12
      border-radius: 3
    }
  }
  type_attr: "TYPE + ATTRIBUTES — Byte 5" {
    style: {
      fill: "#3d1a00"
      stroke: "#d29922"
      stroke-width: 2
      font-color: "#e3b341"
      font-size: 13
      bold: true
      border-radius: 3
    }
    bit7_P: |md
      **Bit 7: P (Present)**
      1 = descriptor valid
      0 = descriptor invalid
      CPU raises NP if P=0
      Must be 1 for active handlers
    | {
      style.fill: "#3d1a00"
      style.stroke: "#d29922"
      style.font-color: "#e3b341"
      style.font-size: 11
    }
    bits65_DPL: |md
      **Bits 6-5: DPL**
      Descriptor Privilege Level
      DPL=0 (00b): Only ring-0 code
      can invoke via int n instruction
      (hardware IRQs bypass DPL check)
      DPL=3 (11b): User code can
      invoke via int 0x80 (syscall)
    | {
      style.fill: "#3d1a00"
      style.stroke: "#d29922"
      style.font-color: "#e3b341"
      style.font-size: 11
    }
    bit4_S: |md
      **Bit 4: S = 0**
      System descriptor (not code/data)
      Always 0 for gate descriptors
    | {
      style.fill: "#3d1a00"
      style.stroke: "#d29922"
      style.font-color: "#888888"
      style.font-size: 11
    }
    bits30_type: |md
      **Bits 3-0: Gate Type**
      1110 (0xE) = 32-bit Interrupt Gate
      1111 (0xF) = 32-bit Trap Gate
      0101 (0x5) = 32-bit Task Gate
      Task Gate used only for DF/vector 8
    | {
      style.fill: "#3d1a00"
      style.stroke: "#d29922"
      style.font-color: "#e3b341"
      style.font-size: 11
    }
  }
  offset_high: |md
    **OFFSET [31:16]** — Bytes 6-7
    Handler address bits 31 down to 16
    (high word of ISR virtual address)
    uint16\_t offset\_high
    Example: isr\_14 at 0xC0104A20
    offset\_high = 0xC010
  | {
    style: {
      fill: "#0d3b6e"
      stroke: "#1f6feb"
      stroke-width: 2
      font-color: "#79c0ff"
      font-size: 12
      border-radius: 3
    }
  }
}
reconstruction: "ISR Address Reconstruction by CPU" {
  style: {
    fill: "#161b22"
    stroke: "#388bfd"
    stroke-width: 1
    font-color: "#cdd9e5"
    font-size: 13
    border-radius: 4
  }
  formula: |md
    **ISR Physical Address (reconstructed by MMU):**
    full\_offset = (offset\_high << 16) | offset\_low
    **Example — Page Fault Handler (vector 14):**
    offset\_high = 0xC010   [bits 31:16]
    offset\_low  = 0x4A20   [bits 15:0]
    full\_offset = 0xC0104A20  <- isr\_14 virtual address
    CPU fetches instruction at GDT[selector].base + full\_offset
    With flat model (base=0): physical = 0xC0104A20 -> MMU -> physical frame
  | {
    style: {
      fill: "#0d1f3c"
      stroke: "#388bfd"
      font-color: "#79c0ff"
      font-size: 12
      border-radius: 3
    }
  }
  c_struct: "C struct — idt\_entry (8 bytes packed)" {
    style: {
      fill: "#161b22"
      stroke: "#3fb950"
      font-color: "#7ee787"
      font-size: 11
      border-radius: 3
    }
  }
  c_struct_code: |`go
    // C struct encoding the 8-byte descriptor
    struct idt_entry {
        uint16_t offset_low;   // [1:0]  Bytes 0-1
        uint16_t selector;     // [3:2]  Bytes 2-3  always 0x0008
        uint8_t  reserved;     // [4]    Byte  4    always 0x00
        uint8_t  flags;        // [5]    Byte  5    P|DPL|0|type
        uint16_t offset_high;  // [7:6]  Bytes 6-7
    } __attribute__((packed));  // 8 bytes total -- no padding
    // Set an interrupt gate (clears IF on entry):
    flags = 0x8E;  // 1000_1110b  P=1 DPL=0 S=0 type=0xE
    // Set a trap gate (leaves IF unchanged):
    flags = 0x8F;  // 1000_1111b  P=1 DPL=0 S=0 type=0xF
    // Set syscall trap gate (user-invokable):
    flags = 0xEF;  // 1110_1111b  P=1 DPL=3 S=0 type=0xF
  `| {
    style: {
      fill: "#161b22"
      stroke: "#3fb950"
      font-color: "#7ee787"
      font-size: 11
      border-radius: 3
    }
  }
}
gate_comparison: "Interrupt Gate vs Trap Gate — The IF Flag Difference" {
  style: {
    fill: "#0d1117"
    stroke: "#f78166"
    stroke-width: 2
    font-color: "#e6edf3"
    font-size: 13
    bold: true
    border-radius: 4
  }
  interrupt_gate: "32-bit INTERRUPT GATE  (type=0xE, flags=0x8E)" {
    style: {
      fill: "#3d0000"
      stroke: "#f85149"
      stroke-width: 2
      font-color: "#ffa198"
      font-size: 12
      bold: true
      border-radius: 3
    }
    desc: |md
      **Behavior:** CPU clears IF (bit 9 of EFLAGS) on entry
      Interrupts are DISABLED inside the handler
      **When to use:**
      - All hardware IRQ handlers (timer, keyboard, disk, NIC)
      - Exception handlers where re-entrancy would corrupt state
      - The double-fault handler (DF, vector 8)
      **Effect on EFLAGS:**
      Entry:  EFLAGS.IF = 0  <- CPU cleared it atomically
      Return: EFLAGS.IF = 1  <- popfd in iretd restores original
      **Risk of NOT using:** Nested timer interrupt fires while
      handling another IRQ -> stack overflow, corrupted IRQ state
    | {
      style: {
        fill: "#2d0000"
        stroke: "#f85149"
        font-color: "#ffa198"
        font-size: 11
        border-radius: 3
      }
    }
    example_flags: |md
      **Encoded flag bytes for common vectors:**
      Vector  0 (DE):  flags=0x8E  DPL=0 INT gate
      Vector 13 (GP):  flags=0x8E  DPL=0 INT gate
      Vector 14 (PF):  flags=0x8E  DPL=0 INT gate
      Vector 32 (IRQ0): flags=0x8E  DPL=0 INT gate
      Vector 33 (IRQ1): flags=0x8E  DPL=0 INT gate
    | {
      style: {
        fill: "#2d0000"
        stroke: "#f85149"
        font-color: "#ff7b72"
        font-size: 11
        border-radius: 3
      }
    }
  }
  trap_gate: "32-bit TRAP GATE  (type=0xF, flags=0x8F / 0xEF)" {
    style: {
      fill: "#003d1a"
      stroke: "#3fb950"
      stroke-width: 2
      font-color: "#7ee787"
      font-size: 12
      bold: true
      border-radius: 3
    }
    desc: |md
      **Behavior:** CPU does NOT clear IF on entry
      Interrupts remain ENABLED inside the handler
      **When to use:**
      - System call gate (INT 0x80, vector 128)
        kernel must stay preemptible during long syscalls
      - Debug breakpoint (BP, vector 3) — trap gates
        allow debugger to remain interruptible
      - Software exceptions where re-entrancy is acceptable
      **Effect on EFLAGS:**
      Entry:  EFLAGS.IF = 1  <- CPU left it unchanged
      Return: EFLAGS.IF = 1  <- unchanged
      **Requirement for INT 0x80:** DPL must be 3
      flags=0xEF (P=1, DPL=3, type=0xF)
      Allows ring-3 user code to invoke the gate
    | {
      style: {
        fill: "#001f0d"
        stroke: "#3fb950"
        font-color: "#7ee787"
        font-size: 11
        border-radius: 3
      }
    }
    example_flags: |md
      **Encoded flag bytes for common vectors:**
      Vector   1 (DB):  flags=0x8F  DPL=0 TRAP gate
      Vector   3 (BP):  flags=0x8F  DPL=0 TRAP gate
      Vector 128 (0x80): flags=0xEF  DPL=3 TRAP gate <- syscall
    | {
      style: {
        fill: "#001f0d"
        stroke: "#3fb950"
        font-color: "#56d364"
        font-size: 11
        border-radius: 3
      }
    }
  }
}
flags_byte: "Byte 5 — Type/Attributes Bit Breakdown" {
  style: {
    fill: "#161b22"
    stroke: "#d29922"
    stroke-width: 2
    font-color: "#e3b341"
    font-size: 13
    border-radius: 4
  }
  grid_layout: |md
    Bit:   7    6    5    4    3    2    1    0
    0x8E:  1    0    0    0    1    1    1    0   INT gate  DPL=0
    0x8F:  1    0    0    0    1    1    1    1   TRAP gate DPL=0
    0xEF:  1    1    1    0    1    1    1    1   TRAP gate DPL=3
           P   DPL  DPL   S   Gate Type
    **P=1:**  Descriptor present (must be 1 for valid gate)
    **DPL:** 00=ring0 only via int n; 11=ring3 can invoke via int n
    **S=0:**  System descriptor (0=system, 1=code/data)
    **Type:** 1110=INT gate (IF cleared); 1111=TRAP gate (IF untouched)
  | {
    style: {
      fill: "#1c1600"
      stroke: "#d29922"
      font-color: "#e3b341"
      font-size: 12
      border-radius: 3
    }
  }
}
dispatch_sequence: "CPU Dispatch Sequence (interrupt fires to handler runs)" {
  style: {
    fill: "#161b22"
    stroke: "#bc8cff"
    stroke-width: 1
    font-color: "#cdd9e5"
    font-size: 12
    border-radius: 4
  }
  steps: |md
    **1. Interrupt signal received** (hardware INTR pin or software int n)
    **2. CPU reads IDTR** (base + limit loaded via lidt)
    base + (vector x 8) = address of this 8-byte gate descriptor
    **3. Privilege check**
    If software int n: require CPL <= gate.DPL (else GP)
    Hardware interrupts: bypass DPL check entirely
    **4. Gate type determines IF behavior**
    INT gate (0xE): atomically clear EFLAGS.IF
    TRAP gate (0xF): EFLAGS.IF unchanged
    **5. Privilege transition (if CPL > gate descriptor segment DPL)**
    Read TSS.SS0:ESP0 -> switch to kernel stack
    Push: SS\_old, ESP\_old, EFLAGS, CS\_old, EIP\_old
    **6. Load CS = gate.selector = 0x0008 (kernel code)**
    **7. Load EIP = (gate.offset\_high << 16) | gate.offset\_low**
    CPU now fetches the ISR first instruction
  | {
    style: {
      fill: "#1a1035"
      stroke: "#bc8cff"
      font-color: "#d2a8ff"
      font-size: 11
      border-radius: 3
    }
  }
}
descriptor.offset_low -> reconstruction.formula: "bits [15:0] concatenated" {
  style.stroke: "#1f6feb"
  style.stroke-dash: 3
  style.animated: true
}
descriptor.offset_high -> reconstruction.formula: "bits [31:16] concatenated" {
  style.stroke: "#1f6feb"
  style.stroke-dash: 3
  style.animated: true
}
descriptor.selector -> dispatch_sequence.steps: "0x0008 = kernel code segment" {
  style.stroke: "#3fb950"
  style.stroke-dash: 3
}
descriptor.type_attr -> gate_comparison: "type nibble determines IF behavior" {
  style.stroke: "#d29922"
  style.stroke-width: 2
  style.animated: true
}
descriptor.type_attr -> flags_byte: "full flags byte = P|DPL|S|type" {
  style.stroke: "#d29922"
  style.stroke-dash: 4
}
reconstruction.formula -> dispatch_sequence.steps: "reconstructed EIP loaded into CPU" {
  style.stroke: "#388bfd"
  style.stroke-width: 2
  style.animated: true
}
gate_comparison.interrupt_gate -> dispatch_sequence.steps: "clears IF before handler runs" {
  style.stroke: "#f85149"
  style.stroke-dash: 3
}
gate_comparison.trap_gate -> dispatch_sequence.steps: "leaves IF set — handler is interruptible" {
  style.stroke: "#3fb950"
  style.stroke-dash: 3
}