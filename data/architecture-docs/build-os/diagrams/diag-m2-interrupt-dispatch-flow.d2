vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: right
# â”€â”€â”€ Color legend â”€â”€â”€
legend: {
  near: bottom-right
  label: "Legend"
  style: {
    fill: "#1a1a2e"
    stroke: "#444466"
    border-radius: 8
    font-size: 12
  }
  hw: "ğŸ”´ Hardware Path" { style.fill: "#3a0000"; style.stroke: "#cc2222"; style.font-color: "#ff8888"; style.border-radius: 4 }
  cpu: "ğŸŸ¡ CPU Microcode" { style.fill: "#2a2000"; style.stroke: "#cc8800"; style.font-color: "#ffcc44"; style.border-radius: 4 }
  asm: "ğŸŸ£ ASM Handler" { style.fill: "#1a0033"; style.stroke: "#8844cc"; style.font-color: "#cc88ff"; style.border-radius: 4 }
  c: "ğŸ”µ C Dispatch" { style.fill: "#001a33"; style.stroke: "#2266cc"; style.font-color: "#66aaff"; style.border-radius: 4 }
  eoi: "ğŸŸ¢ EOI / Return" { style.fill: "#001a00"; style.stroke: "#228822"; style.font-color: "#66ff66"; style.border-radius: 4 }
  stk: "â¬œ Stack Layout" { style.fill: "#1a1a1a"; style.stroke: "#888888"; style.font-color: "#cccccc"; style.border-radius: 4 }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LANE 1 â€” HARDWARE ORIGIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
hw_origin: "â‘  HARDWARE ORIGIN" {
  style: {
    fill: "#200000"
    stroke: "#cc2222"
    border-radius: 10
    font-color: "#ff6666"
    bold: true
    font-size: 14
  }
  irq0: "IRQ0 â€” PIT Timer\n(fires every 10ms @ 100Hz)\nPhysical wire asserted HIGH" {
    style: { fill: "#3a0000"; stroke: "#cc2222"; font-color: "#ffaaaa"; border-radius: 6 }
  }
  irq1: "IRQ1 â€” PS/2 Keyboard\n(scancode ready in port 0x60)\nPhysical wire asserted HIGH" {
    style: { fill: "#3a0000"; stroke: "#cc2222"; font-color: "#ffaaaa"; border-radius: 6 }
  }
  exc14: "#PF â€” Page Fault\n(CPU internal signal, NOT a wire)\nMemory access violated PTE" {
    style: { fill: "#1a0010"; stroke: "#aa2266"; font-color: "#ffaacc"; border-radius: 6 }
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LANE 2 â€” PIC ARBITRATION (hardware IRQs only)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
pic_arb: "â‘¡ PIC ARBITRATION  (8259A master/slave cascade)" {
  style: {
    fill: "#1a0f00"
    stroke: "#cc6600"
    border-radius: 10
    font-color: "#ffaa44"
    bold: true
    font-size: 14
  }
  irr_reg: "IRR â€” Interrupt Request Register\nbits set when IRQ line asserted\nIRQ0â†’bit0  IRQ1â†’bit1  â€¦" {
    style: { fill: "#2a1800"; stroke: "#cc6600"; font-color: "#ffcc88"; border-radius: 6 }
  }
  imr_check: "IMR â€” Interrupt Mask Register\nbitwise AND with IRR\n0=pass  1=block\nDefault: 0xFC (only IRQ0+IRQ1 open)" {
    style: { fill: "#2a1800"; stroke: "#cc6600"; font-color: "#ffcc88"; border-radius: 6 }
  }
  priority: "Priority Arbitration\nLowest IRQ# wins\nIRQ0 > IRQ1 > â€¦ > IRQ15\nSlave cascades through IRQ2" {
    style: { fill: "#2a1800"; stroke: "#cc6600"; font-color: "#ffcc88"; border-radius: 6 }
  }
  intr_pin: "Assert CPU INTR pin\n(electrical signal to CPU)\nVector will be returned\nduring INTA cycle" {
    style: { fill: "#3a1000"; stroke: "#ff8800"; font-color: "#ffdd88"; border-radius: 6; bold: true }
  }
  isr_set: "ISR bit SET\n(blocks further IRQs at same\nor lower priority until EOI)" {
    style: { fill: "#2a1000"; stroke: "#aa5500"; font-color: "#ffaa55"; border-radius: 6 }
  }
  irr_reg -> imr_check: "masked bits dropped"
  imr_check -> priority: "unmasked IRQs"
  priority -> intr_pin: "winning IRQ drives INTR"
  priority -> isr_set: "ISR[n] = 1"
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LANE 3 â€” CPU CHECKS & INTA CYCLE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
cpu_check: "â‘¢ CPU INTERRUPT ACKNOWLEDGMENT" {
  style: {
    fill: "#1a1800"
    stroke: "#ccaa00"
    border-radius: 10
    font-color: "#ffee44"
    bold: true
    font-size: 14
  }
  if_check: "Check EFLAGS.IF (bit 9)\nIF=1 â†’ interrupts enabled â†’ proceed\nIF=0 â†’ interrupt masked by software\n(cli instruction sets IF=0)" {
    style: { fill: "#2a2800"; stroke: "#ccaa00"; font-color: "#ffffaa"; border-radius: 6 }
  }
  finish_instr: "Finish current instruction\n(x86 guarantees atomicity\nof the current instruction)\nOnly then respond to INTR" {
    style: { fill: "#2a2800"; stroke: "#ccaa00"; font-color: "#ffffaa"; border-radius: 6 }
  }
  inta_cycle: "INTA bus cycle (Ã—2)\nCycle 1: acknowledge INTR signal\nCycle 2: PIC puts vector# on data bus\n8-bit vector read by CPU" {
    style: { fill: "#3a2800"; stroke: "#ffcc00"; font-color: "#ffee88"; border-radius: 6; bold: true }
  }
  vector_calc: "Vector resolution\nIRQ0 â†’ vector 32  (0x08 + 0x20 remapped)\nIRQ1 â†’ vector 33\n#PF  â†’ vector 14  (fixed by Intel)" {
    style: { fill: "#2a2200"; stroke: "#aaaa00"; font-color: "#eeee88"; border-radius: 6 }
    shape: hexagon
  }
  if_check -> finish_instr: "IF=1, INTR asserted"
  finish_instr -> inta_cycle: "current instr retired"
  inta_cycle -> vector_calc: "vector# off data bus"
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LANE 4 â€” IDT LOOKUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
idt_lookup: "â‘£ IDT LOOKUP  (CPU microcode, transparent)" {
  style: {
    fill: "#001820"
    stroke: "#0088aa"
    border-radius: 10
    font-color: "#44ccff"
    bold: true
    font-size: 14
  }
  idtr_read: "Read IDTR register\nbase: 0xC0104000 (example)\nlimit: 0x07FF  (256 Ã— 8 âˆ’ 1)\nIDTR set by lidt instruction in idt_init()" {
    style: { fill: "#001a2a"; stroke: "#0088aa"; font-color: "#88ddff"; border-radius: 6 }
  }
  gate_addr: "Gate address = IDTR.base + vector Ã— 8\nExample (IRQ0 â†’ vec 32):\n0xC0104000 + 32Ã—8 = 0xC0104100\n2 memory reads (likely L1 cache hit)" {
    style: { fill: "#001a2a"; stroke: "#0088aa"; font-color: "#88ddff"; border-radius: 6 }
  }
  gate_decode: |md
    **8-byte Interrupt Gate Descriptor**
    
    Bytes 1-0:  offset_low  = 0x1234  (handler addr low)
    Bytes 3-2:  selector    = 0x0008  (kernel CS)
    Byte  4:    reserved    = 0x00
    Byte  5:    flags       = 0x8E    (P=1,DPL=0,type=IntGate)
    Bytes 7-6:  offset_high = 0xC010  (handler addr high)
    â†’ handler = 0xC0101234
    
  | {
    style: { fill: "#001530"; stroke: "#0066aa"; font-color: "#aaddff"; border-radius: 6; font-size: 11 }
  }
  dpl_check: "DPL check:\nmax(CPL, RPL) â‰¤ DPL?\nKernel except: CPL=0, DPL=0 â†’ OK\nSyscall gate: CPL=3, DPL=3 â†’ OK\nUser calling kernel vec: CPL=3>DPL=0 â†’ #GP!" {
    style: { fill: "#001a2a"; stroke: "#cc4400"; font-color: "#ff9966"; border-radius: 6 }
  }
  idtr_read -> gate_addr: "offset into IDT"
  gate_addr -> gate_decode: "fetch 8 bytes from IDT"
  gate_decode -> dpl_check: "parse flags byte"
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LANE 5 â€” HARDWARE STACK PUSH (automatic, no software involvement)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
hw_stack_push: "â‘¤ CPU AUTOMATIC STACK PUSH  (hardware, your code does NOTHING here)" {
  style: {
    fill: "#100020"
    stroke: "#8800cc"
    border-radius: 10
    font-color: "#cc88ff"
    bold: true
    font-size: 14
  }
  priv_change: "Privilege level change?\nCPL(current) â‰  DPL(gate)?\nYes (ring3â†’ring0): read TSS.ESP0+SS0\nNo  (ring0â†’ring0): use current SS:ESP" {
    style: { fill: "#200030"; stroke: "#8800cc"; font-color: "#cc88ff"; border-radius: 6 }
  }
  stack_noerr: |md
    **Stack WITHOUT error code** (IRQs, exceptions 0-7, 9, 15-31)
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â† ESP before interrupt
    â”‚  (user code)    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ SS    [+20]     â”‚  â† old stack segment  (pushed only if CPL changed)
    â”‚ ESP   [+16]     â”‚  â† old stack pointer  (pushed only if CPL changed)
    â”‚ EFLAGS[+12]     â”‚  â† processor flags (IF, DF, etc.)
    â”‚ CS    [+8]      â”‚  â† code segment selector
    â”‚ EIP   [+4]      â”‚  â† return address
    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
    â”‚ ESPâ†’  [+0]      â”‚  â† new ESP (kernel stack)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
  | {
    style: { fill: "#1a0028"; stroke: "#7700bb"; font-color: "#ddaaff"; border-radius: 6; font-size: 11 }
  }
  stack_err: |md
    **Stack WITH error code** (exceptions 8, 10, 11, 12, 13, 14)
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ SS    [+24]     â”‚
    â”‚ ESP   [+20]     â”‚
    â”‚ EFLAGS[+16]     â”‚
    â”‚ CS    [+12]     â”‚
    â”‚ EIP   [+8]      â”‚
    â”‚ ERRCODE[+4]     â”‚  â† CPU pushes error code
    â”‚ ESPâ†’  [+0]      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Error code for #PF (vec 14):
      bit0 P   = 0 not present / 1 protection
      bit1 W/R = 0 read / 1 write
      bit2 U/S = 0 kernel / 1 user mode
      bit3 RSVD = reserved bit set in PTE
    CR2 = faulting virtual address (read separately)
    
  | {
    style: { fill: "#1a0028"; stroke: "#aa44dd"; font-color: "#ffccff"; border-radius: 6; font-size: 11 }
  }
  clear_if: "CPU clears EFLAGS.IF (Interrupt Gate only)\nPrevents nested interrupts mid-dispatch\nTrap gate: IF is NOT cleared\n(syscall gate INT 0x80 uses trap gate)" {
    style: { fill: "#200030"; stroke: "#660099"; font-color: "#bb88ff"; border-radius: 6 }
  }
  load_cs_eip: "Load CS = gate.selector (0x08)\nLoad EIP = gate.offset_high:offset_low\nCPU now executing isr_N in ring 0" {
    style: { fill: "#200030"; stroke: "#8800cc"; font-color: "#cc88ff"; border-radius: 6; bold: true }
  }
  priv_change -> stack_noerr: "no error code exceptions / IRQs"
  priv_change -> stack_err: "error code exceptions"
  stack_noerr -> clear_if: "stack prepared"
  stack_err -> clear_if: "stack prepared"
  clear_if -> load_cs_eip: "IF=0, jump to handler"
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LANE 6 â€” ISR STUB (assembly isr_N + isr_common_stub)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
isr_stub: "â‘¥ ISR STUB  (assembly: isr_N â†’ isr_common_stub)" {
  style: {
    fill: "#0a001a"
    stroke: "#6633cc"
    border-radius: 10
    font-color: "#aa77ff"
    bold: true
    font-size: 14
  }
  macro_stub: |md
    **NASM macro generates per-vector stub:**
    nasm
    isr_32:                     ; IRQ0 (timer) â†’ vector 32
        push dword 0            ; fake error code (uniform frame)
        push dword 32           ; interrupt number
        jmp  isr_common_stub
    isr_14:                     ; #PF â†’ vector 14 (already has error code)
        push dword 14           ; interrupt number (CPU pushed error code)
        jmp  isr_common_stub
    
  | {
    style: { fill: "#0d0020"; stroke: "#5522aa"; font-color: "#cc99ff"; border-radius: 6; font-size: 11 }
  }
  common_stub: |md
    **isr_common_stub:**
    nasm
    pusha               ; push EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI (32 bytes)
    push ds             ; save segment registers (8 bytes)
    push es
    push fs
    push gs
    mov  ax, 0x10       ; kernel data selector
    mov  ds, ax         ; reload DS (was potentially user 0x23)
    mov  es, ax
    mov  fs, ax
    mov  gs, ax
    push esp            ; push pointer to full frame â†’ arg to C function
    call interrupt_dispatch
    add  esp, 4         ; discard pushed ESP arg
    pop  gs             ; restore segment regs
    pop  fs
    pop  es
    pop  ds
    popa                ; restore general-purpose registers
    add  esp, 8         ; discard int_no + err_code
    iret                ; restore EIP, CS, EFLAGS (+ ESP,SS if CPL changed)
    
  | {
    style: { fill: "#0d0020"; stroke: "#7744cc"; font-color: "#ddbbff"; border-radius: 6; font-size: 11 }
  }
  full_frame: |md
    **Full interrupt_frame on kernel stack after pusha:**
    
    [ESP+0]   EDI  â”€â”
    [ESP+4]   ESI   â”‚  pusha pushed 8 regs
    [ESP+8]   EBP   â”‚  (32 bytes)
    [ESP+12]  ESP*  â”‚  (*saved ESP value)
    [ESP+16]  EBX   â”‚
    [ESP+20]  EDX   â”‚
    [ESP+24]  ECX   â”‚
    [ESP+28]  EAX  â”€â”˜
    [ESP+32]  GS  â”€â”
    [ESP+36]  FS   â”‚ segment regs
    [ESP+40]  ES   â”‚ (16 bytes)
    [ESP+44]  DS  â”€â”˜
    [ESP+48]  int_no    â† pushed by isr_N stub
    [ESP+52]  err_code  â† pushed by CPU or fake 0
    [ESP+56]  EIP      â”€â” pushed by CPU
    [ESP+60]  CS        â”‚ (20 bytes if CPL changed)
    [ESP+64]  EFLAGS    â”‚
    [ESP+68]  user_ESP  â”‚
    [ESP+72]  user_SS  â”€â”˜
    
  | {
    style: { fill: "#0a0018"; stroke: "#553399"; font-color: "#ccaaff"; border-radius: 6; font-size: 11 }
  }
  macro_stub -> common_stub: "jump to common path"
  common_stub -> full_frame: "stack layout after pusha"
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LANE 7 â€” C DISPATCH
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
c_dispatch: "â‘¦ C INTERRUPT DISPATCH  (interrupt_dispatch â†’ handler)" {
  style: {
    fill: "#000d1a"
    stroke: "#1155aa"
    border-radius: 10
    font-color: "#5599ff"
    bold: true
    font-size: 14
  }
  dispatch_router: |md
    **interrupt_dispatch(struct interrupt_frame \*frame)**
    c
    if (frame->int_no < 32)      â†’ exception_handler(frame)
    else if (frame->int_no < 48) â†’ irq_dispatch(int_noâˆ’32, frame)
    else if (frame->int_no==0x80)â†’ syscall_dispatch(frame)
    
  | {
    style: { fill: "#001022"; stroke: "#1155aa"; font-color: "#88bbff"; border-radius: 6; font-size: 11 }
  }
  exc_handler: "Exception Handler (#PF example)\nread CR2 (faulting address)\ndecode err_code bits (P/W/U)\nprint EIP, CS, EFLAGS\nhalt or demand-page (M3)" {
    style: { fill: "#001022"; stroke: "#3377cc"; font-color: "#aaccff"; border-radius: 6 }
  }
  irq_handler_timer: "IRQ0 â†’ timer_handler()\ntick_counter++\nscheduler_tick() (M4)\n[NO return value â€” void]" {
    style: { fill: "#001533"; stroke: "#2255bb"; font-color: "#99bbff"; border-radius: 6 }
  }
  irq_handler_kbd: "IRQ1 â†’ keyboard_handler()\ninb(0x60) â†’ scancode\nscancode_to_ascii lookup\nring_push(&kbd_buf, ascii)" {
    style: { fill: "#001533"; stroke: "#2255bb"; font-color: "#99bbff"; border-radius: 6 }
  }
  syscall_disp: "0x80 â†’ syscall_dispatch()\nEAX=syscall# EBX=arg1\ndispatch table lookup\nreturn value â†’ frame->eax\n(iret restores EAX to user)" {
    style: { fill: "#001533"; stroke: "#446699"; font-color: "#aabbdd"; border-radius: 6 }
  }
  dispatch_router -> exc_handler: "int_no < 32"
  dispatch_router -> irq_handler_timer: "int_no == 32 (IRQ0)"
  dispatch_router -> irq_handler_kbd: "int_no == 33 (IRQ1)"
  dispatch_router -> syscall_disp: "int_no == 0x80"
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LANE 8 â€” EOI PROTOCOL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
eoi_protocol: "â‘§ EOI â€” END OF INTERRUPT  (hardware IRQs only)" {
  style: {
    fill: "#001500"
    stroke: "#228822"
    border-radius: 10
    font-color: "#55cc55"
    bold: true
    font-size: 14
  }
  eoi_decision: "Which PICs need EOI?\nIRQ0â€“IRQ7  â†’ master only\nIRQ8â€“IRQ15 â†’ slave AND master\n(slave routes through master IRQ2)" {
    style: { fill: "#002200"; stroke: "#228822"; font-color: "#88ee88"; border-radius: 6 }
  }
  eoi_write: "outb(0x20, 0x20)  ; EOI to master PIC\noutb(0xA0, 0x20)  ; EOI to slave (if IRQ8-15)\n\nClears ISR bit â†’ PIC can\ndeliver next interrupt" {
    style: { fill: "#002200"; stroke: "#33aa33"; font-color: "#aaffaa"; border-radius: 6; bold: true }
  }
  spurious: "Spurious IRQ check (IRQ7/IRQ15):\nRead ISR register (OCW3)\nIf ISR bit NOT set â†’ spurious!\nDo NOT send EOI for spurious\n(would prematurely clear real IRQ)" {
    style: { fill: "#001a00"; stroke: "#116611"; font-color: "#77bb77"; border-radius: 6 }
  }
  eoi_decision -> eoi_write: "send to correct PIC(s)"
  eoi_decision -> spurious: "IRQ7 or IRQ15: verify first"
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LANE 9 â€” IRET RESTORATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
iret_restore: "â‘¨ IRET â€” RESTORE AND RETURN  (atomic, hardware)" {
  style: {
    fill: "#001a0d"
    stroke: "#007744"
    border-radius: 10
    font-color: "#44ffaa"
    bold: true
    font-size: 14
  }
  popa_segs: "isr_common_stub unwinds:\n1. add esp,4     (drop C arg)\n2. pop gs,fs,es,ds  (restore segs)\n3. popa          (restore 8 GPregs)\n4. add esp,8     (drop int_no+err_code)" {
    style: { fill: "#001a0d"; stroke: "#007744"; font-color: "#88ffcc"; border-radius: 6 }
  }
  iret_frame: |md
    **iret pops (in this order from current ESP):**
    
    pop EIP    â†’ resume at return address
    pop CS     â†’ restore code segment
    pop EFLAGS â†’ restore flags (IF restored here!)
    â€” if CS.RPL > CPL (returning to ring 3):
    pop ESP    â†’ restore user stack pointer
    pop SS     â†’ restore user stack segment
    
    IF bit in EFLAGS is restored atomically by iret.
    If EFLAGS.IF was 1 before interrupt, it is 1 again.
    No explicit sti needed.
  | {
    style: { fill: "#001508"; stroke: "#006633"; font-color: "#aaffdd"; border-radius: 6; font-size: 11 }
  }
  resume: "Execution resumes at EIP\nExactly the instruction that was\ninterrupted (for faults: re-executed)\n(for traps/IRQs: next instruction)\nProcess is unaware it was interrupted" {
    style: { fill: "#002a10"; stroke: "#00aa44"; font-color: "#88ffbb"; border-radius: 6; bold: true }
    shape: hexagon
  }
  popa_segs -> iret_frame: "ESP now at CPU-pushed frame"
  iret_frame -> resume: "iret executed"
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CROSS-LANE CONNECTIONS (the actual data walk)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
hw_origin.irq0 -> pic_arb.irr_reg: "IRQ0 asserts master PIC pin 0\n(physical wire, ~10ns)" {
  style: { stroke: "#cc2222"; stroke-width: 3; font-color: "#ff6666" }
}
hw_origin.irq1 -> pic_arb.irr_reg: "IRQ1 asserts master PIC pin 1" {
  style: { stroke: "#cc2222"; stroke-width: 2; font-color: "#ff6666" }
}
hw_origin.exc14 -> cpu_check.finish_instr: "#PF bypasses PIC entirely\n(internal CPU exception)" {
  style: { stroke: "#aa2266"; stroke-width: 2; stroke-dash: 5; font-color: "#ff88cc" }
}
pic_arb.intr_pin -> cpu_check.if_check: "INTR pin HIGH\n(electrical signal to CPU)" {
  style: { stroke: "#ff8800"; stroke-width: 3; font-color: "#ffcc44" }
}
cpu_check.vector_calc -> idt_lookup.idtr_read: "vector# (8-bit: 32, 33, 14â€¦)\nlook up IDT[vector]" {
  style: { stroke: "#ccaa00"; stroke-width: 3; font-color: "#ffee44" }
}
idt_lookup.dpl_check -> hw_stack_push.priv_change: "DPL check passed\nCPU saves context" {
  style: { stroke: "#0088aa"; stroke-width: 3; font-color: "#44ccff" }
}
hw_stack_push.load_cs_eip -> isr_stub.macro_stub: "CS=0x08  EIP=isr_N addr\nCPU jumps to your ASM stub" {
  style: { stroke: "#8800cc"; stroke-width: 3; font-color: "#cc88ff" }
}
isr_stub.common_stub -> c_dispatch.dispatch_router: "push esp (frame ptr)\ncall interrupt_dispatch" {
  style: { stroke: "#6633cc"; stroke-width: 3; font-color: "#aa88ff" }
}
c_dispatch.irq_handler_timer -> eoi_protocol.eoi_decision: "handler body complete\npic_send_eoi(irq) called\nby irq_dispatch wrapper" {
  style: { stroke: "#228822"; stroke-width: 3; font-color: "#88ee88" }
}
c_dispatch.irq_handler_kbd -> eoi_protocol.eoi_decision: "keyboard handler done\npic_send_eoi(1)" {
  style: { stroke: "#228822"; stroke-width: 2; font-color: "#88ee88" }
}
c_dispatch.exc_handler -> isr_stub.common_stub: "returns to stub\n(no EOI for exceptions)" {
  style: { stroke: "#555599"; stroke-width: 2; stroke-dash: 4; font-color: "#8888bb" }
}
c_dispatch.syscall_disp -> isr_stub.common_stub: "returns to stub\n(no EOI for software int)" {
  style: { stroke: "#555599"; stroke-width: 2; stroke-dash: 4; font-color: "#8888bb" }
}
eoi_protocol.eoi_write -> isr_stub.common_stub: "EOI sent\nreturn from C handler\nto isr_common_stub epilogue" {
  style: { stroke: "#33aa33"; stroke-width: 3; font-color: "#aaffaa" }
}
pic_arb.isr_set -> eoi_protocol.eoi_write: "ISR bit cleared by EOI\n(enables lower-priority IRQs again)" {
  style: { stroke: "#aa6600"; stroke-width: 2; stroke-dash: 5; font-color: "#ffaa44" }
}
isr_stub.common_stub -> iret_restore.popa_segs: "popa + iret\n(epilogue path)" {
  style: { stroke: "#007744"; stroke-width: 3; font-color: "#44ffaa" }
}
iret_restore.resume -> hw_origin.irq0: "idle â†’ hlt â†’ next IRQ0\n(10ms later, cycle repeats)" {
  style: { stroke: "#006644"; stroke-width: 2; stroke-dash: 6; font-color: "#55bb88" }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANNOTATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
note_timing: "â± Latency breakdown (approx, hot cache)\nâ‘  Wire assertion:        ~0 ns (hardware)\nâ‘¡ PIC arbitration:       ~50 ns\nâ‘¢ INTRâ†’CPU acknowledge:  ~2 cycles\nâ‘£ IDT fetch (L1 hit):    ~4 cycles\nâ‘¤ Stack push (5 words):  ~5 cycles\nâ‘¥ ISR stub (pusha etc):  ~20 cycles\nâ‘¦ C dispatch + handler:  ~50-500 cycles\nâ‘§ EOI (outb to PIC):     ~100 ns\nâ‘¨ popa + iret:           ~15 cycles\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTotal min (kernel path): ~200 cycles â‰ˆ 67 ns @ 3GHz" {
  near: top-right
  style: {
    fill: "#0d0d0d"
    stroke: "#444444"
    font-color: "#aaaaaa"
    font-size: 11
    border-radius: 8
  }
  shape: text
}
note_irq_vs_exc: "KEY DISTINCTION\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nHardware IRQ (timer, keyboard):\n  â€¢ Routes through 8259 PIC\n  â€¢ REQUIRES EOI to unmask PIC\n  â€¢ Does NOT push error code\n  â€¢ Vector# from INTA bus cycle\n\nCPU Exception (#PF, #GP, #DE):\n  â€¢ Bypasses PIC entirely\n  â€¢ NO EOI required\n  â€¢ Some push error code (8,10-14)\n  â€¢ Vector# fixed by Intel\n\nSoftware INT 0x80 (syscall):\n  â€¢ Bypasses PIC\n  â€¢ NO EOI required\n  â€¢ Does NOT push error code\n  â€¢ Trap gate: IF not cleared" {
  near: top-left
  style: {
    fill: "#0a0a1a"
    stroke: "#333355"
    font-color: "#9999cc"
    font-size: 11
    border-radius: 8
  }
  shape: text
}