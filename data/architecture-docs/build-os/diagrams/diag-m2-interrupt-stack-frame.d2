vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: right
title: |md
  ## Interrupt Stack Frame Layout â€” With vs Without Error Code
  *Unified ISR stub normalizes both cases by pushing dummy error code (0) for no-error-code exceptions*
| {near: top-center}
# â”€â”€â”€ LEGEND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
legend: {
  near: bottom-center
  style.fill: "#1a1a2e"
  style.stroke: "#444466"
  style.border-radius: 6
  label: |md
    **Color Key:**  ğŸŸ¥ CPU auto-pushed (hardware)  ğŸŸ¨ Stub-pushed (software)  ğŸŸ¦ ISR common frame  ğŸŸ© Privilege-change only
  |
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LEFT PANEL â€” No Error Code (e.g., #DE Divide Error, vector 0)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
no_err_panel: "CASE A â€” No Error Code (e.g., #DE Divide Error, Vector 0)" {
  style.fill: "#0d1b2a"
  style.stroke: "#4488cc"
  style.stroke-width: 2
  style.border-radius: 8
  note_a: |md
    **Exceptions WITHOUT error code:**
    Vectors 0,1,2,3,4,5,6,7,9,15,16,18,19,20â€“31
  | {
    style.fill: "#112233"
    style.stroke: "#4488cc"
    style.font-size: 13
  }
  stack_a: {
    style.fill: "#0d1b2a"
    style.stroke: transparent
    # Stack grows downward. Highest address at top of diagram = bottom of stack visually.
    # We show addresses relative to ESP-at-handler-entry (after ALL pushes by stub).
    off_ss_a: "[ESP+52] SS_user  (0x23)" {
      style.fill: "#1a4a1a"
      style.stroke: "#44aa44"
      style.font-color: "#aaffaa"
      style.bold: true
    }
    off_esp_a: "[ESP+48] ESP_user  (user stack ptr)" {
      style.fill: "#1a4a1a"
      style.stroke: "#44aa44"
      style.font-color: "#aaffaa"
      style.bold: true
    }
    off_efl_a: "[ESP+44] EFLAGS   (CPL=3â†’0 saves IF state)" {
      style.fill: "#4a1a00"
      style.stroke: "#cc6622"
      style.font-color: "#ffcc88"
    }
    off_cs_a: "[ESP+40] CS_user  (0x1B â€” RPL=3)" {
      style.fill: "#4a1a00"
      style.stroke: "#cc6622"
      style.font-color: "#ffcc88"
    }
    off_eip_a: "[ESP+36] EIP      (faulting or next instr)" {
      style.fill: "#4a1a00"
      style.stroke: "#cc6622"
      style.font-color: "#ffcc88"
    }
    off_fake_a: "[ESP+32] err_code = 0x00000000  â—„ FAKE (stub pushes)" {
      style.fill: "#4a3000"
      style.stroke: "#ccaa00"
      style.font-color: "#ffee88"
      style.bold: true
    }
    off_intno_a: "[ESP+28] int_no   = 0  (stub pushes)" {
      style.fill: "#1e1a3a"
      style.stroke: "#7766cc"
      style.font-color: "#ccbbff"
    }
    off_edi_a: "[ESP+24] EDI  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_esi_a: "[ESP+20] ESI  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_ebp_a: "[ESP+16] EBP  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_esp_dummy_a: "[ESP+12] ESP_dummy (pusha â€” value before pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_ebx_a: "[ESP+8]  EBX  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_edx_a: "[ESP+4]  EDX  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_ecx_a: "[ESP+0]  ECX  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    esp_ptr_a: "â—„ ESP when C handler is called\n   interrupt_frame *frame = ESP" {
      style.fill: "#002200"
      style.stroke: "#00aa00"
      style.font-color: "#00ff88"
      style.bold: true
      style.border-radius: 4
    }
  }
  # Vertical byte-offset ruler
  ruler_a: "Byte Offsets\n(from ESP\nat C entry)" {
    style.fill: "#111122"
    style.stroke: "#333355"
    style.font-color: "#6688bb"
    style.font-size: 11
  }
  # Assembly stub for case A
  stub_a: |asm
    isr_0:                          ; Divide Error â€” no error code
        push  dword 0               ; â† FAKE error code pushed here
        push  dword 0               ; â† interrupt number
        jmp   isr_common_stub       ; jump to shared path
  | {
    style.fill: "#0f1f10"
    style.stroke: "#336633"
    style.font-size: 12
  }
  note_a -> stack_a.off_ss_a: "Only present on ring-change\n(CPL 3â†’0)" {
    style.stroke: "#44aa44"
    style.stroke-dash: 4
    style.font-color: "#44aa44"
  }
  stack_a.off_fake_a -> stub_a: "ISR stub inserts 0\nto normalize frame" {
    style.stroke: "#ccaa00"
    style.stroke-dash: 3
    style.font-color: "#ccaa00"
  }
  stub_a -> stack_a.esp_ptr_a: "After pusha â†’ call handler" {
    style.stroke: "#00aa44"
    style.animated: true
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RIGHT PANEL â€” With Error Code (e.g., #PF Page Fault, vector 14)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
err_panel: "CASE B â€” With Error Code (e.g., #PF Page Fault, Vector 14)" {
  style.fill: "#1a0d0d"
  style.stroke: "#cc4444"
  style.stroke-width: 2
  style.border-radius: 8
  note_b: |md
    **Exceptions WITH error code:**
    Vectors 8(#DF), 10(#TS), 11(#NP), 12(#SS), 13(#GP), 14(#PF), 17(#AC)
  | {
    style.fill: "#2a1111"
    style.stroke: "#cc4444"
    style.font-size: 13
  }
  stack_b: {
    style.fill: "#1a0d0d"
    style.stroke: transparent
    off_ss_b: "[ESP+52] SS_user  (0x23)" {
      style.fill: "#1a4a1a"
      style.stroke: "#44aa44"
      style.font-color: "#aaffaa"
      style.bold: true
    }
    off_esp_b: "[ESP+48] ESP_user  (user stack ptr)" {
      style.fill: "#1a4a1a"
      style.stroke: "#44aa44"
      style.font-color: "#aaffaa"
      style.bold: true
    }
    off_efl_b: "[ESP+44] EFLAGS   (CPL=3â†’0 saves IF state)" {
      style.fill: "#4a1a00"
      style.stroke: "#cc6622"
      style.font-color: "#ffcc88"
    }
    off_cs_b: "[ESP+40] CS_user  (0x1B â€” RPL=3)" {
      style.fill: "#4a1a00"
      style.stroke: "#cc6622"
      style.font-color: "#ffcc88"
    }
    off_eip_b: "[ESP+36] EIP      (faulting instruction addr)" {
      style.fill: "#4a1a00"
      style.stroke: "#cc6622"
      style.font-color: "#ffcc88"
    }
    off_real_b: "[ESP+32] err_code = 0x00000005  â—„ REAL (CPU pushes)" {
      style.fill: "#4a0000"
      style.stroke: "#ff3333"
      style.font-color: "#ff9999"
      style.bold: true
    }
    off_intno_b: "[ESP+28] int_no   = 14  (stub pushes)" {
      style.fill: "#1e1a3a"
      style.stroke: "#7766cc"
      style.font-color: "#ccbbff"
    }
    off_edi_b: "[ESP+24] EDI  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_esi_b: "[ESP+20] ESI  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_ebp_b: "[ESP+16] EBP  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_esp_dummy_b: "[ESP+12] ESP_dummy (pusha â€” value before pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_ebx_b: "[ESP+8]  EBX  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_edx_b: "[ESP+4]  EDX  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    off_ecx_b: "[ESP+0]  ECX  (pusha)" {
      style.fill: "#0a2040"
      style.stroke: "#3366aa"
      style.font-color: "#88bbff"
    }
    esp_ptr_b: "â—„ ESP when C handler is called\n   interrupt_frame *frame = ESP" {
      style.fill: "#002200"
      style.stroke: "#00aa00"
      style.font-color: "#00ff88"
      style.bold: true
      style.border-radius: 4
    }
  }
  # Error code decoder for #PF
  pf_errcode: "#PF Error Code Bits (err_code = 0x5 = 0b101)" {
    style.fill: "#2a0808"
    style.stroke: "#cc2222"
    style.border-radius: 4
    bit_p: "Bit 0 (P)=1   Page PRESENT â€” protection violation\n              (not missing page, but wrong permissions)" {
      style.fill: "#3a1010"
      style.stroke: "#aa2222"
      style.font-color: "#ff8888"
    }
    bit_w: "Bit 1 (W)=0   READ access (not a write)" {
      style.fill: "#3a1010"
      style.stroke: "#aa2222"
      style.font-color: "#ff8888"
    }
    bit_u: "Bit 2 (U)=1   USER mode access (CPL=3)\n              â†’ kernel page read from ring 3" {
      style.fill: "#3a1010"
      style.stroke: "#aa2222"
      style.font-color: "#ff8888"
    }
    bit_r: "Bit 3 (R)=0   No reserved-bit violation" {
      style.fill: "#3a1010"
      style.stroke: "#aa2222"
      style.font-color: "#ff8888"
    }
    bit_i: "Bit 4 (I)=0   Not an instruction fetch" {
      style.fill: "#3a1010"
      style.stroke: "#aa2222"
      style.font-color: "#ff8888"
    }
    cr2_note: "CR2 register = virtual address that faulted\n(must be read INSIDE the handler, not from frame)" {
      style.fill: "#1a0030"
      style.stroke: "#9933ff"
      style.font-color: "#cc88ff"
      style.bold: true
    }
  }
  # Assembly stub for case B
  stub_b: |asm
    isr_14:                         ; Page Fault â€” CPU already pushed error code
        ;  <error code already on stack â€” do NOT push dummy>
        push  dword 14              ; â† interrupt number only
        jmp   isr_common_stub       ; jump to shared path
  | {
    style.fill: "#1f0f0f"
    style.stroke: "#663333"
    style.font-size: 12
  }
  note_b -> stack_b.off_ss_b: "Only present on ring-change\n(CPL 3â†’0)" {
    style.stroke: "#44aa44"
    style.stroke-dash: 4
    style.font-color: "#44aa44"
  }
  stack_b.off_real_b -> pf_errcode: "Decode error code bits\nto determine fault type" {
    style.stroke: "#ff4444"
    style.font-color: "#ff8888"
  }
  stub_b -> stack_b.esp_ptr_b: "After pusha â†’ call handler" {
    style.stroke: "#00aa44"
    style.animated: true
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMMON STUB â€” shared by both paths
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
common_stub: "isr_common_stub  â€” Shared by ALL 256 Vectors" {
  style.fill: "#0a0a1a"
  style.stroke: "#5555aa"
  style.stroke-width: 2
  style.border-radius: 8
  stub_code: |asm
    isr_common_stub:
        pusha                    ; Push EAX,ECX,EDX,EBX,ESP_dummy,EBP,ESI,EDI (32 bytes)
        push ds                  ; Save segment registers
        push es
        push fs
        push gs
        mov  ax, 0x10            ; Load kernel data segment (selector 0x10)
        mov  ds, ax
        mov  es, ax
        mov  fs, ax
        mov  gs, ax
        push esp                 ; Pass pointer to full frame as C argument
        call interrupt_dispatch  ; void interrupt_dispatch(interrupt_frame *frame)
        add  esp, 4              ; Clean pushed ESP argument
        pop  gs                  ; Restore segment registers
        pop  fs
        pop  es
        pop  ds
        popa                     ; Restore EAX,ECX,EDX,EBX,EBP,ESI,EDI (and dummy ESP)
        add  esp, 8              ; Discard int_no + err_code (8 bytes)
        iretd                    ; Restore EIP, CS, EFLAGS (+ ESP, SS if privilege change)
  | {
    style.fill: "#0f0f22"
    style.stroke: "#4444aa"
    style.font-size: 12
  }
  c_struct: |c
    // C struct matching the stack layout exactly
    // (offsets measured from ESP at point of 'call interrupt_dispatch')
    typedef struct interrupt_frame {
        // Pushed by pusha (offset 0 = bottom of pusha block)
        uint32_t edi, esi, ebp, esp_dummy;   // +0, +4, +8, +12
        uint32_t ebx, edx, ecx, eax;         // +16, +20, +24, +28
        // Pushed by stub
        uint32_t int_no;      // +32  vector number (0-255)
        uint32_t err_code;    // +36  real or 0x00000000 (normalized)
        // Pushed by CPU (always)
        uint32_t eip;         // +40  return address (fault = faulting instr)
        uint32_t cs;          // +44  code segment (RPL = caller ring)
        uint32_t eflags;      // +48  flags at interrupt time
        // Pushed by CPU (ONLY on ring change CPL 3â†’0)
        uint32_t user_esp;    // +52
        uint32_t user_ss;     // +56
    } __attribute__((packed)) interrupt_frame_t;
  | {
    style.fill: "#0f1a0f"
    style.stroke: "#336633"
    style.font-size: 12
  }
  iret_detail: "iretd Restores (in order from stack):" {
    style.fill: "#1a1a00"
    style.stroke: "#888800"
    style.border-radius: 4
    iret1: "1. EIP     â€” resumes interrupted code" { style.fill: "#2a2a00"; style.stroke: "#aaaa00"; style.font-color: "#ffff88" }
    iret2: "2. CS      â€” restores code segment + CPL" { style.fill: "#2a2a00"; style.stroke: "#aaaa00"; style.font-color: "#ffff88" }
    iret3: "3. EFLAGS  â€” including IF (re-enables interrupts)" { style.fill: "#2a2a00"; style.stroke: "#aaaa00"; style.font-color: "#ffff88" }
    iret4: "4. ESP/SS  â€” ONLY if CS.RPL > current CPL\n   (returning from ring 0 â†’ ring 3)" { style.fill: "#1a3a00"; style.stroke: "#44aa00"; style.font-color: "#aaffaa"; style.bold: true }
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# KEY DIFFERENCE CALLOUT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
diff_callout: "âš   The Critical Difference" {
  style.fill: "#2a1a00"
  style.stroke: "#ffaa00"
  style.stroke-width: 2
  style.border-radius: 6
  near: top-right
  diff_text: |md
    **Without error code** â†’ stub does: `push 0` then `push int_no`
    **With error code**    â†’ CPU already pushed it; stub does only: `push int_no`
    Both paths arrive at `isr_common_stub` with **identical stack layout**.
    The C handler always finds `err_code` at `frame->err_code` (offset +36).
    For no-error-code exceptions, `frame->err_code == 0`.
    **Why normalize?**  Without this, the C struct offsets would differ
    by 4 bytes between the two cases â€” requiring separate structs or
    runtime branching before every field access.  The dummy push makes
    one universal `interrupt_frame_t` possible.
  | {
    style.fill: "#221500"
    style.stroke: "#cc8800"
    style.font-size: 13
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONNECTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
no_err_panel -> common_stub: "isr_N (no-err): push 0 + int_no\nthen jmp isr_common_stub" {
  style.stroke: "#ccaa00"
  style.stroke-width: 2
  style.font-color: "#ccaa00"
}
err_panel -> common_stub: "isr_14 (err): push int_no only\nthen jmp isr_common_stub" {
  style.stroke: "#cc4444"
  style.stroke-width: 2
  style.font-color: "#cc4444"
}
common_stub -> diff_callout: "normalization\nenables this" {
  style.stroke: "#ffaa00"
  style.stroke-dash: 5
  style.font-color: "#ffaa00"
}