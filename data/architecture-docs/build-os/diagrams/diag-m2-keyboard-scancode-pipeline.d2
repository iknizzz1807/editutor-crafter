vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: right

title: |md
  ## PS/2 Keyboard: Scancode to Keypress Pipeline
| {near: top-center}

classes: {
  hardware: {
    style: {
      fill: "#3d1f5e"
      stroke: "#9b59ff"
      font-color: "#e8d5ff"
      stroke-width: 2
      border-radius: 6
    }
  }
  controller: {
    style: {
      fill: "#1a3a1a"
      stroke: "#27ae60"
      font-color: "#a8ffb8"
      stroke-width: 2
      border-radius: 6
    }
  }
  cpu_path: {
    style: {
      fill: "#3a1a1a"
      stroke: "#e74c3c"
      font-color: "#ffb0b0"
      stroke-width: 2
      border-radius: 6
    }
  }
  kernel: {
    style: {
      fill: "#1a2a3a"
      stroke: "#3498db"
      font-color: "#aad4ff"
      stroke-width: 2
      border-radius: 6
    }
  }
  buf_style: {
    style: {
      fill: "#2a2a1a"
      stroke: "#f1c40f"
      font-color: "#fff0a0"
      stroke-width: 2
      border-radius: 6
    }
  }
}

# ══ LAYER 0 — Physical Hardware ══

phys: Physical Layer {
  style: {
    fill: "#1a0a2e"
    stroke: "#7f00ff"
    font-color: "#cc99ff"
    stroke-width: 2
    border-radius: 8
  }

  key: "Key Switch\n(mechanical contact)" {
    class: hardware
    width: 180
  }

  matrix: "Keyboard Matrix Scanner\n(~1kHz scan rate)" {
    class: hardware
    width: 220
  }

  debounce: "Debounce Logic\n(5-20ms bounce filtered)" {
    class: hardware
    width: 220
  }

  key -> matrix: "contact closes\n(electrical signal)" {
    style.stroke: "#9b59ff"
    style.animated: true
  }
  matrix -> debounce: "raw scan position\n(1kHz polling)" {
    style.stroke: "#9b59ff"
  }
}

# ══ LAYER 1 — PS/2 Controller ══

ps2ctrl: "PS/2 Controller (Intel 8042)" {
  style: {
    fill: "#0a1a0a"
    stroke: "#27ae60"
    font-color: "#a8ffb8"
    stroke-width: 2
    border-radius: 8
  }

  serial_rx: "Serial Receiver\n(PS/2 protocol, 10-16kHz\n11 bits per scancode byte)" {
    class: controller
    width: 260
  }

  scancode_buf: "Output Buffer Register\nPort 0x60 (1-byte)\nStatus: Port 0x64 bit0\n= OBF (Output Buffer Full)" {
    class: controller
    width: 280
    style.3d: true
  }

  irq1_assert: "Assert IRQ1\n(OBF=1 triggers interrupt)" {
    class: controller
    shape: diamond
    width: 220
  }

  serial_rx -> scancode_buf: "assembled scancode\n(Scancode Set 1 default)" {
    style.stroke: "#27ae60"
  }
  scancode_buf -> irq1_assert: "OBF flag set\ntrigger interrupt" {
    style.stroke: "#27ae60"
    style.animated: true
  }
}

# ══ SCANCODE TABLE ══

scancode_ref: "Scancode Set 1 Reference\nKey    Make   Break   ASCII\nA      0x1E   0x9E    a\nS      0x1F   0x9F    s\nZ      0x2C   0xAC    z\n0      0x0B   0x8B    0\nESC    0x01   0x81    -\nLShift 0x2A   0xAA    -\nEnter  0x1C   0x9C   \\n\nSpace  0x39   0xB9    space\n\nBreak rule: break = make OR 0x80\nExtended keys prefixed by 0xE0" {
  style: {
    fill: "#111122"
    stroke: "#444466"
    font-color: "#ccccee"
    border-radius: 6
    font: mono
  }
  width: 340
}

# ══ LAYER 2 — CPU Interrupt Path ══

cpu_int: "CPU Interrupt Path" {
  style: {
    fill: "#2a0a0a"
    stroke: "#e74c3c"
    font-color: "#ffaaaa"
    stroke-width: 2
    border-radius: 8
  }

  pic_master: "Master PIC (8259A)\nIRQ1 input line\nAfter remap:\nIRQ1 -> Vector 33 (0x21)" {
    class: cpu_path
    width: 260
    style.3d: true
  }

  cpu_accept: "CPU Interrupt Accept\nChecks IF=1 in EFLAGS\nAt instruction boundary\nReads TSS.ESP0 (ring-3)\nPushes: EFLAGS, CS, EIP\n(+SS, ESP if from ring-3)" {
    class: cpu_path
    width: 280
  }

  idt_lookup: "IDT Entry [33]\nType: Interrupt Gate 0x8E\n(IF cleared on entry)\nDPL: 0 (kernel only)\nSeg: 0x08 (kernel code)\nOffset: irq1_stub addr" {
    class: cpu_path
    width: 280
    style.3d: true
  }

  pic_master -> cpu_accept: "INTR signal raised\n(PIC arbitrates priority)" {
    style.stroke: "#e74c3c"
    style.animated: true
    style.stroke-width: 3
  }
  cpu_accept -> idt_lookup: "vector 33 index\ngate descriptor fetch\n(~10 cycles, L2 cache)" {
    style.stroke: "#e74c3c"
  }
}

# ══ LAYER 3 — ISR Assembly Stub ══

isr_stub: "ISR Assembly Stub" {
  style: {
    fill: "#0a0a2a"
    stroke: "#e67e22"
    font-color: "#ffd0a0"
    stroke-width: 2
    border-radius: 8
  }

  irq1_entry: "irq1 entry stub\ncli\npush 0       (dummy error)\npush 33      (IRQ vector)\njmp irq_common_stub" {
    class: cpu_path
    style.stroke: "#e67e22"
    style.font-color: "#ffd0a0"
    style.fill: "#1a1a0a"
    width: 280
    style.font: mono
  }

  common_stub: "irq_common_stub\npusha\npush ds/es/fs/gs\nmov ax, 0x10\nmov ds/es/fs/gs, ax\npush esp\ncall irq_dispatcher" {
    class: cpu_path
    style.stroke: "#e67e22"
    style.font-color: "#ffd0a0"
    style.fill: "#1a1a0a"
    width: 300
    style.font: mono
  }

  stub_exit: "Stub Exit\npop eax\npop gs/fs/es/ds\npopa\nadd esp, 8\niret" {
    class: cpu_path
    style.stroke: "#e67e22"
    style.font-color: "#ffd0a0"
    style.fill: "#1a1a0a"
    width: 260
    style.font: mono
  }

  irq1_entry -> common_stub: "fall through\nto common path" {
    style.stroke: "#e67e22"
  }
  common_stub -> stub_exit: "returns from\nirq_dispatcher()" {
    style.stroke: "#e67e22"
  }
}

# ══ LAYER 4 — C Kernel Handler ══

c_handler: "keyboard_handler() in C" {
  style: {
    fill: "#0a1a2a"
    stroke: "#3498db"
    font-color: "#aad4ff"
    stroke-width: 2
    border-radius: 8
  }

  port_read: "Read scancode\ninb(0x60)\n~1-4 us I/O bus stall\nClears OBF in controller" {
    class: kernel
    width: 260
    style.font: mono
  }

  make_break: "Make / Break Detection\nif (scancode AND 0x80) != 0\n  -> BREAK event\nelse\n  -> MAKE event" {
    class: kernel
    shape: diamond
    width: 280
    style.font: mono
  }

  break_path: "Break Code Path\nif make==0x2A or 0x36:\n  kb_shift = 0\n  (Shift released)\nreturn (ignore release)" {
    class: kernel
    style.fill: "#2a1a0a"
    style.stroke: "#e67e22"
    style.font-color: "#ffd0a0"
    width: 280
    style.font: mono
  }

  shift_check: "Shift Key Check\nif scancode==0x2A or 0x36:\n  kb_shift = 1\n  return" {
    class: kernel
    width: 270
    style.font: mono
  }

  ascii_lookup: "Scancode to ASCII Lookup\nc = scancode_to_ascii[scancode]\nif (c == 0) return (unmapped)\nif (kb_shift AND a<=c<=z):\n  c = c - 'a' + 'A'" {
    class: kernel
    width: 310
    style.3d: true
    style.font: mono
  }

  eoi: "Send EOI to PIC\noutb(0x20, 0x20)\n(master PIC acknowledge)\nRe-enables IRQ1 line" {
    class: kernel
    style.fill: "#2a1a2a"
    style.stroke: "#9b59b6"
    style.font-color: "#ddb8ff"
    width: 260
    style.font: mono
  }

  port_read -> make_break: "raw byte 0x00-0xFF\ne.g. 0x1E = A pressed\n     0x9E = A released" {
    style.stroke: "#3498db"
  }
  make_break -> break_path: "bit 7 = 1\n(break code)" {
    style.stroke: "#e67e22"
  }
  make_break -> shift_check: "bit 7 = 0\n(make code)" {
    style.stroke: "#27ae60"
    style.animated: true
  }
  shift_check -> ascii_lookup: "not a modifier\ntranslate to char" {
    style.stroke: "#3498db"
  }
  ascii_lookup -> eoi: "c = ASCII char\ne.g. 'A' = 0x41" {
    style.stroke: "#3498db"
  }
}

# ══ LAYER 5 — Ring Buffer ══

ring_buf: "Circular Keyboard Buffer (256 bytes)" {
  style: {
    fill: "#1a1a0a"
    stroke: "#f1c40f"
    font-color: "#fff0a0"
    stroke-width: 2
    border-radius: 8
  }

  buf_check: "Buffer Full Check\nnext_head = (head+1) % 256\nif next_head == tail:\n  discard (overflow)" {
    class: buf_style
    shape: diamond
    width: 290
    style.font: mono
  }

  enqueue: "Enqueue Character\nkb_buffer[head] = c\nhead = (head+1) % 256\n(O(1) no shifting)" {
    class: buf_style
    width: 280
    style.3d: true
    style.font: mono
  }

  buf_visual: "Buffer Layout (256 bytes)\n[h][e][l][l][o][ ][__][__]\n  ^tail              ^head\n  (next read)   (next write)\nhead=6  tail=0  used=6" {
    class: buf_style
    width: 400
    style.font: mono
    style.fill: "#111100"
  }

  consumer: "keyboard_getchar()\nif head == tail: return 0\nc = kb_buffer[tail]\ntail = (tail+1) % 256\nreturn c" {
    class: buf_style
    style.fill: "#2a2a0a"
    width: 260
    style.font: mono
  }

  buf_check -> enqueue: "space available\n(head+1 != tail)" {
    style.stroke: "#f1c40f"
    style.animated: true
  }
  enqueue -> buf_visual: "char stored at\nhead position" {
    style.stroke: "#f1c40f"
  }
  buf_visual -> consumer: "kernel polls or\nevent-driven read" {
    style.stroke: "#f1c40f"
    style.stroke-dash: 3
  }
}

# ══ TIMING NOTE ══

timing_note: "End-to-End Latency\nStage              Duration\nKey contact bounce  5-20 ms\nPS/2 serial xfer    ~60 us\nPIC arbitration     ~1 us\nCPU interrupt accept ~75 ns\nISR + pusha         ~50 ns\ninb(0x60) I/O stall ~2 us\nASCII lookup        <5 ns\nRing buffer enqueue <5 ns\nTotal perceived     ~20 ms\n(dominated by debounce)" {
  near: bottom-center
  style: {
    fill: "#111122"
    stroke: "#444466"
    font-color: "#ccccee"
    border-radius: 6
    font: mono
  }
  width: 380
}

# ══ INTER-LAYER PIPELINE CONNECTIONS ══

phys.debounce -> ps2ctrl.serial_rx: "PS/2 serial bitstream\nCLK + DATA lines\n10-16kHz" {
  style.stroke: "#9b59ff"
  style.stroke-width: 3
  style.animated: true
}

ps2ctrl.irq1_assert -> cpu_int.pic_master: "IRQ1 hardware line\nasserted high\n(~60us after keypress)" {
  style.stroke: "#e74c3c"
  style.stroke-width: 3
  style.animated: true
}

cpu_int.idt_lookup -> isr_stub.irq1_entry: "pipeline flush + jump\nto handler address\n(~20 cycles total)" {
  style.stroke: "#e67e22"
  style.stroke-width: 3
  style.animated: true
}

isr_stub.common_stub -> c_handler.port_read: "irq_dispatcher routes\nIRQ1 to keyboard_handler\ninterrupt_frame_t passed" {
  style.stroke: "#3498db"
  style.stroke-width: 3
  style.animated: true
}

c_handler.ascii_lookup -> ring_buf.buf_check: "ASCII char c\ne.g. 'A' = 0x41\npassed to enqueue" {
  style.stroke: "#f1c40f"
  style.stroke-width: 3
  style.animated: true
}

c_handler.eoi -> isr_stub.stub_exit: "EOI sent\nhandler returns\nto stub exit path" {
  style.stroke: "#9b59b6"
  style.stroke-width: 2
}