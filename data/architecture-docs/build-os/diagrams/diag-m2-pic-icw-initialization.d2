vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # PIC 8259A ICW Initialization Sequence
  ### Master (0x20/0x21) + Slave (0xA0/0xA1) â€” Boot-time PIC Remapping
| {near: top-center}

# â”€â”€â”€ LEGEND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
legend: {
  near: bottom-right
  style.fill: "#1a1a2e"
  style.stroke: "#444466"
  style.border-radius: 8
  label: |md
    **Color Semantics**
    ðŸ”´ Red = dangerous / collision zone
    ðŸŸ¢ Green = correct target vectors
    ðŸ”µ Blue = data flow (OUT instruction)
    ðŸŸ£ Purple = hardware metadata/registers
    ðŸŸ¡ Yellow = I/O wait (timing caution)
    â¬œ Gray = unused / masked IRQs
  |
}

# â”€â”€â”€ CPU CODE BLOCK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cpu_code: CPU Code (pic_remap) {
  style.fill: "#0d1117"
  style.stroke: "#58a6ff"
  style.stroke-width: 2
  style.border-radius: 6

  step0: |c
    // Step 0: Save existing masks
    uint8_t m1 = inb(0x21); // master mask
    uint8_t m2 = inb(0xA1); // slave mask
  | {style.fill: "#161b22"; style.stroke: "#30363d"}

  step_icw1: |c
    // ICW1 â€” Start init sequence (BOTH PICs simultaneously)
    outb(0x20, 0x11);  // master CMD port
    io_wait();          // jmp $+2  (~1Âµs delay)
    outb(0xA0, 0x11);  // slave CMD port
    io_wait();
    // 0x11 = 0b00010001
    //         ^^^^      bit4=1 â†’ init mode
    //              ^^   bit1=0 â†’ edge triggered
    //               ^  bit0=1 â†’ ICW4 needed
  | {style.fill: "#161b22"; style.stroke: "#30363d"}

  step_icw2: |c
    // ICW2 â€” Vector Offsets (THE FIX for the collision!)
    outb(0x21, 0x20);  // master DATA: IRQ0â†’vec32
    io_wait();
    outb(0xA1, 0x28);  // slave DATA:  IRQ8â†’vec40
    io_wait();
    // Master: 0x20=32  â†’ IRQ0..7  map to vectors 32..39
    // Slave:  0x28=40  â†’ IRQ8..15 map to vectors 40..47
  | {style.fill: "#161b22"; style.stroke: "#30363d"}

  step_icw3: |c
    // ICW3 â€” Cascade Wiring
    outb(0x21, 0x04);  // master DATA: slave at IRQ2
    io_wait();          //  0x04 = bitmask bit2 set
    outb(0xA1, 0x02);  // slave DATA:  slave ID=2
    io_wait();          //  0x02 = numeric ID (not bitmask)
  | {style.fill: "#161b22"; style.stroke: "#30363d"}

  step_icw4: |c
    // ICW4 â€” 8086 Mode
    outb(0x21, 0x01);  // master DATA: 8086/88 mode
    io_wait();
    outb(0xA1, 0x01);  // slave DATA:  8086/88 mode
    io_wait();
    // 0x01 = bit0=1 â†’ 8086 mode (not MCS-80/85)
    // bit1=0 â†’ normal EOI (manual, not AEOI)
  | {style.fill: "#161b22"; style.stroke: "#30363d"}

  step_ocw1: |c
    // OCW1 â€” Restore masks (enable only IRQ0 + IRQ1)
    // IMR: 1=masked(disabled), 0=enabled
    outb(0x21, m1);    // restore master mask
    outb(0xA1, m2);    // restore slave mask
    // Typical boot mask: 0xFC = 11111100b
    //   â†’ only IRQ0(timer) + IRQ1(kbd) unmasked
  | {style.fill: "#161b22"; style.stroke: "#30363d"}

  step0 -> step_icw1: "begin"
  step_icw1 -> step_icw2: "PIC enters init\nstate machine"
  step_icw2 -> step_icw3
  step_icw3 -> step_icw4
  step_icw4 -> step_ocw1: "init complete\nâ†’ restore masks"
}

# â”€â”€â”€ MASTER PIC CHIP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
master_pic: Master 8259A PIC {
  style.fill: "#0f2027"
  style.stroke: "#e74c3c"
  style.stroke-width: 3
  style.border-radius: 8

  ports: I/O Ports {
    style.fill: "#1a1a2e"
    style.stroke: "#e74c3c"
    cmd_port: CMD Port 0x20 {style.fill: "#2d1b1b"; style.stroke: "#e74c3c"; style.font-color: "#ff6b6b"}
    data_port: DATA Port 0x21 {style.fill: "#2d1b1b"; style.stroke: "#e74c3c"; style.font-color: "#ff6b6b"}
  }

  state_machine: PIC Internal State Machine {
    style.fill: "#111827"
    style.stroke: "#8b5cf6"
    style.stroke-width: 2

    s_init: INIT\n(awaiting ICW1) {style.fill: "#1e1b4b"; style.stroke: "#8b5cf6"; style.font-color: "#a78bfa"}
    s_icw2: ICW2\nExpected {style.fill: "#1e1b4b"; style.stroke: "#8b5cf6"; style.font-color: "#a78bfa"}
    s_icw3: ICW3\nExpected {style.fill: "#1e1b4b"; style.stroke: "#8b5cf6"; style.font-color: "#a78bfa"}
    s_icw4: ICW4\nExpected {style.fill: "#1e1b4b"; style.stroke: "#8b5cf6"; style.font-color: "#a78bfa"}
    s_ready: OPERATIONAL {style.fill: "#052e16"; style.stroke: "#22c55e"; style.font-color: "#4ade80"}

    s_init -> s_icw2: "ICW1=0x11\nreceived on\nCMD port"
    s_icw2 -> s_icw3: "ICW2=0x20\noffset=32\nwritten to\nDATA port"
    s_icw3 -> s_icw4: "ICW3=0x04\nslave on\nIRQ2 bitmask\nwritten"
    s_icw4 -> s_ready: "ICW4=0x01\n8086 mode\naccepted"
  }

  irq_map_before: BEFORE Remap (DANGEROUS) {
    style.fill: "#2d1515"
    style.stroke: "#ef4444"
    style.stroke-width: 2
    b0: "IRQ0 (Timer)  â†’ CPU vec  8 â† DOUBLE FAULT!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
    b1: "IRQ1 (Keybd)  â†’ CPU vec  9 â† INVALID TSS!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
    b2: "IRQ2 (Cascde) â†’ CPU vec 10 â† SEG NOT PRES!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
    b3: "IRQ3 (COM2)   â†’ CPU vec 11 â† STACK FAULT!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
    b4: "IRQ4 (COM1)   â†’ CPU vec 12 â† STACK FAULT!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
    b5: "IRQ5 (LPT2)   â†’ CPU vec 13 â† GPF!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
    b6: "IRQ6 (Floppy) â†’ CPU vec 14 â† PAGE FAULT!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
    b7: "IRQ7 (Spur.)  â†’ CPU vec 15 â† RESERVED!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
  }

  irq_map_after: AFTER Remap (CORRECT) {
    style.fill: "#052e16"
    style.stroke: "#22c55e"
    style.stroke-width: 2
    a0: "IRQ0 (Timer)  â†’ CPU vec 32 âœ“ user-defined" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a1: "IRQ1 (Keybd)  â†’ CPU vec 33 âœ“ user-defined" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a2: "IRQ2 (Cascde) â†’ CPU vec 34 âœ“ user-defined" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a3: "IRQ3 (COM2)   â†’ CPU vec 35 âœ“ user-defined" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a4: "IRQ4 (COM1)   â†’ CPU vec 36 âœ“ user-defined" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a5: "IRQ5 (LPT2)   â†’ CPU vec 37 âœ“ user-defined" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a6: "IRQ6 (Floppy) â†’ CPU vec 38 âœ“ user-defined" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a7: "IRQ7 (Spur.)  â†’ CPU vec 39 âœ“ check ISR" {style.fill: "#0a3323"; style.font-color: "#86efac"}
  }

  imr_reg: IMR (Interrupt Mask Register) {
    style.fill: "#1c1c2e"
    style.stroke: "#6366f1"
    imr_label: |md
      **Mask byte written to 0x21 (DATA)**
      `0xFC = 1111 1100b`
      bit0=0 â†’ IRQ0 **ENABLED** (timer)
      bit1=0 â†’ IRQ1 **ENABLED** (keyboard)
      bit2=1 â†’ IRQ2 masked (cascade handles it)
      bit3..7=1 â†’ IRQ3-7 masked
    | {style.fill: "#1c1c2e"; style.stroke: "#6366f1"}
  }
}

# â”€â”€â”€ SLAVE PIC CHIP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
slave_pic: Slave 8259A PIC {
  style.fill: "#0f1f27"
  style.stroke: "#3b82f6"
  style.stroke-width: 3
  style.border-radius: 8

  ports: I/O Ports {
    style.fill: "#1a1a2e"
    style.stroke: "#3b82f6"
    cmd_port: CMD Port 0xA0 {style.fill: "#1b2d3b"; style.stroke: "#3b82f6"; style.font-color: "#60a5fa"}
    data_port: DATA Port 0xA1 {style.fill: "#1b2d3b"; style.stroke: "#3b82f6"; style.font-color: "#60a5fa"}
  }

  state_machine: PIC Internal State Machine {
    style.fill: "#111827"
    style.stroke: "#8b5cf6"
    style.stroke-width: 2

    s_init: INIT\n(awaiting ICW1) {style.fill: "#1e1b4b"; style.stroke: "#8b5cf6"; style.font-color: "#a78bfa"}
    s_icw2: ICW2\nExpected {style.fill: "#1e1b4b"; style.stroke: "#8b5cf6"; style.font-color: "#a78bfa"}
    s_icw3: ICW3\nExpected {style.fill: "#1e1b4b"; style.stroke: "#8b5cf6"; style.font-color: "#a78bfa"}
    s_icw4: ICW4\nExpected {style.fill: "#1e1b4b"; style.stroke: "#8b5cf6"; style.font-color: "#a78bfa"}
    s_ready: OPERATIONAL {style.fill: "#052e16"; style.stroke: "#22c55e"; style.font-color: "#4ade80"}

    s_init -> s_icw2: "ICW1=0x11\nreceived on\nCMD port"
    s_icw2 -> s_icw3: "ICW2=0x28\noffset=40\nwritten to\nDATA port"
    s_icw3 -> s_icw4: "ICW3=0x02\nslave ID=2\nnumeric (not\nbitmask)"
    s_icw4 -> s_ready: "ICW4=0x01\n8086 mode\naccepted"
  }

  irq_map_after: AFTER Remap (CORRECT) {
    style.fill: "#052e16"
    style.stroke: "#22c55e"
    style.stroke-width: 2
    a8:  "IRQ8  (RTC)    â†’ CPU vec 40 âœ“" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a9:  "IRQ9  (Free)   â†’ CPU vec 41 âœ“" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a10: "IRQ10 (Free)   â†’ CPU vec 42 âœ“" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a11: "IRQ11 (Free)   â†’ CPU vec 43 âœ“" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a12: "IRQ12 (Mouse)  â†’ CPU vec 44 âœ“" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a13: "IRQ13 (FPU)    â†’ CPU vec 45 âœ“" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a14: "IRQ14 (ATA1)   â†’ CPU vec 46 âœ“" {style.fill: "#052e16"; style.font-color: "#4ade80"}
    a15: "IRQ15 (ATA2)   â†’ CPU vec 47 âœ“ check ISR" {style.fill: "#0a3323"; style.font-color: "#86efac"}
  }
}

# â”€â”€â”€ ICW BIT ANATOMY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
icw_anatomy: ICW Bit-Level Anatomy {
  style.fill: "#0d1117"
  style.stroke: "#f59e0b"
  style.stroke-width: 2
  style.border-radius: 6

  icw1_bits: ICW1 = 0x11 = 0001 0001b {
    style.fill: "#1c1400"
    style.stroke: "#f59e0b"
    b7: "bit7..5 = 000  (ignored in cascade mode)" {style.fill: "#111"; style.font-color: "#9ca3af"}
    b4: "bit4    =   1  â† MUST BE 1: signals ICW1 (vs OCW)" {style.fill: "#1a1000"; style.font-color: "#fbbf24"}
    b3: "bit3    =   0  â† level triggered=1 / edge=0" {style.fill: "#111"; style.font-color: "#9ca3af"}
    b2: "bit2    =   0  â† call interval 8 (x86 always 0)" {style.fill: "#111"; style.font-color: "#9ca3af"}
    b1: "bit1    =   0  â† cascade mode (1=single PIC)" {style.fill: "#111"; style.font-color: "#9ca3af"}
    b0: "bit0    =   1  â† ICW4 needed (required for 8086)" {style.fill: "#1a1000"; style.font-color: "#fbbf24"}
  }

  icw2_master: ICW2 Master = 0x20 = 0010 0000b {
    style.fill: "#001a00"
    style.stroke: "#22c55e"
    bvec: "bits7..3 = 00100  â† T7..T3: vector offset = 32 (0x20)" {style.fill: "#001a00"; style.font-color: "#4ade80"}
    bres: "bits2..0 = 000    â† ignored (auto-filled by PIC with IRQ#)" {style.fill: "#111"; style.font-color: "#9ca3af"}
    bnote: "Result: IRQ0â†’32, IRQ1â†’33, ... IRQ7â†’39" {style.fill: "#001a00"; style.font-color: "#86efac"}
  }

  icw2_slave: ICW2 Slave = 0x28 = 0010 1000b {
    style.fill: "#001a00"
    style.stroke: "#22c55e"
    bvec: "bits7..3 = 00101  â† T7..T3: vector offset = 40 (0x28)" {style.fill: "#001a00"; style.font-color: "#4ade80"}
    bres: "bits2..0 = 000    â† ignored" {style.fill: "#111"; style.font-color: "#9ca3af"}
    bnote: "Result: IRQ8â†’40, IRQ9â†’41, ... IRQ15â†’47" {style.fill: "#001a00"; style.font-color: "#86efac"}
  }

  icw3_master: ICW3 Master = 0x04 = 0000 0100b {
    style.fill: "#1a001a"
    style.stroke: "#a855f7"
    bm: "BITMASK: bit2=1 means IRQ line 2 has a slave" {style.fill: "#1a001a"; style.font-color: "#c084fc"}
    bnote: "Hardware: slave INT output wired to master IRQ2 input" {style.fill: "#1a001a"; style.font-color: "#a78bfa"}
  }

  icw3_slave: ICW3 Slave = 0x02 = 0000 0010b {
    style.fill: "#1a001a"
    style.stroke: "#a855f7"
    bs: "NUMERIC ID: slave identity = 2 (matches master bit2)" {style.fill: "#1a001a"; style.font-color: "#c084fc"}
    bnote: "Used by master to know which slave to cascade to" {style.fill: "#1a001a"; style.font-color: "#a78bfa"}
  }

  icw4_bits: ICW4 = 0x01 = 0000 0001b {
    style.fill: "#1a0a00"
    style.stroke: "#f97316"
    b0_4: "bit0    =   1  â† 8086/88 mode (REQUIRED for protected mode)" {style.fill: "#1a0a00"; style.font-color: "#fb923c"}
    b1_4: "bit1    =   0  â† normal EOI (manual; AEOI=1 is auto but risky)" {style.fill: "#111"; style.font-color: "#9ca3af"}
    b2_4: "bit2    =   0  â† non-buffered mode" {style.fill: "#111"; style.font-color: "#9ca3af"}
    b3_4: "bit3    =   0  â† not special fully-nested mode" {style.fill: "#111"; style.font-color: "#9ca3af"}
    b4_4: "bit4    =   0  â† (reserved, must be 0)" {style.fill: "#111"; style.font-color: "#9ca3af"}
  }
}

# â”€â”€â”€ IO_WAIT EXPLANATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
io_wait_block: io_wait() â€” Why It Exists {
  style.fill: "#1a1500"
  style.stroke: "#eab308"
  style.stroke-width: 2
  style.border-radius: 6

  timing: Real Hardware Timing Constraint {
    style.fill: "#111"
    style.stroke: "#eab308"
    t1: "8259A PIC requires ~1Âµs to process each ICW write" {style.fill: "#1a1500"; style.font-color: "#fde047"}
    t2: "Modern CPUs execute OUT in ~10ns â€” 100Ã— too fast!" {style.fill: "#1a1500"; style.font-color: "#fde047"}
    t3: "Without delay: PIC misses ICW bytes â†’ stuck in wrong state" {style.fill: "#2d1b00"; style.font-color: "#fb923c"}
  }

  impl: Implementation {
    style.fill: "#111"
    style.stroke: "#eab308"
    code: |asm
      ; Classic io_wait: write to port 0x80 (POST diagnostic)
      ; Port 0x80 is unused but ISA bus timing guarantees ~1Âµs
      io_wait:
          out 0x80, al    ; any value; port 0x80 = safe waste cycle
          ret
      
      ; Alternative: short jmp (2-byte NOP with bus cycle)
      ; jmp $+2           ; consume ~1-2 bus cycles
      ; nop
    | {style.fill: "#0d1117"; style.stroke: "#30363d"}
    note: "QEMU/VMs: io_wait is a no-op (device emulation is instant)" {style.font-color: "#86efac"}
    note2: "Real hardware (ISA bus): each OUT + io_wait = ~1Âµs total" {style.font-color: "#fbbf24"}
  }
}

# â”€â”€â”€ CPU VECTOR MAP (before/after comparison) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
vector_map: CPU Exception/IRQ Vector Map {
  style.fill: "#0d1117"
  style.stroke: "#6366f1"
  style.border-radius: 6

  reserved_exc: Vectors 0..31 â€” Intel Reserved (Exceptions) {
    style.fill: "#1e1b4b"
    style.stroke: "#6366f1"
    e0:  "vec  0 = Divide Error (#DE)" {style.font-color: "#a78bfa"}
    e8:  "vec  8 = Double Fault (#DF) â† was IRQ0 before remap!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
    e13: "vec 13 = General Protection (#GP) â† was IRQ5!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
    e14: "vec 14 = Page Fault (#PF) â† was IRQ6!" {style.fill: "#3b0a0a"; style.font-color: "#fca5a5"}
  }

  irq_zone: Vectors 32..47 â€” Hardware IRQs (after remap) {
    style.fill: "#052e16"
    style.stroke: "#22c55e"
    i32: "vec 32 = IRQ0  (PIT Timer 100Hz)" {style.font-color: "#4ade80"}
    i33: "vec 33 = IRQ1  (PS/2 Keyboard)" {style.font-color: "#4ade80"}
    i34: "vec 34 = IRQ2  (PIC Cascade â€” never fires to handler)" {style.font-color: "#86efac"}
    i40: "vec 40 = IRQ8  (CMOS RTC)" {style.font-color: "#4ade80"}
    i47: "vec 47 = IRQ15 (Secondary ATA / Spurious slave)" {style.font-color: "#86efac"}
  }

  software_zone: Vectors 48..255 â€” Software/User Defined {
    style.fill: "#111827"
    style.stroke: "#374151"
    s80: "vec 0x80 = INT 0x80 System Call Gate (Milestone 4)" {style.font-color: "#9ca3af"}
    s_rest: "vec 48..127, 129..255 = available" {style.font-color: "#6b7280"}
  }
}

# â”€â”€â”€ EOI NOTE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eoi_note: EOI â€” End of Interrupt (Post-Handler Requirement) {
  style.fill: "#0d1117"
  style.stroke: "#ef4444"
  style.border-radius: 6

  rule: |md
    **After EVERY IRQ handler, you MUST send EOI or the PIC freezes that IRQ line forever.**

    For IRQ0-7 (master only):    `outb(0x20, 0x20)`
    For IRQ8-15 (slave + master): `outb(0xA0, 0x20)` then `outb(0x20, 0x20)`

    Spurious IRQ7:  do NOT send EOI (PIC's ISR bit was never set)
    Spurious IRQ15: send EOI to master only (slave did not set ISR)
  | {style.fill: "#1a0a0a"; style.stroke: "#ef4444"}
}

# â”€â”€â”€ CONNECTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# CPU code â†’ Master PIC ports
cpu_code.step_icw1 -> master_pic.ports.cmd_port: "outb(0x20, 0x11)\nICW1: start init" {
  style.stroke: "#e74c3c"
  style.stroke-width: 2
  style.animated: true
}
cpu_code.step_icw2 -> master_pic.ports.data_port: "outb(0x21, 0x20)\nICW2: offset=32" {
  style.stroke: "#22c55e"
  style.stroke-width: 2
  style.animated: true
}
cpu_code.step_icw3 -> master_pic.ports.data_port: "outb(0x21, 0x04)\nICW3: slave@IRQ2" {
  style.stroke: "#a855f7"
  style.stroke-width: 2
}
cpu_code.step_icw4 -> master_pic.ports.data_port: "outb(0x21, 0x01)\nICW4: 8086 mode" {
  style.stroke: "#f97316"
  style.stroke-width: 2
}
cpu_code.step_ocw1 -> master_pic.ports.data_port: "outb(0x21, mask)\nOCW1: set IMR" {
  style.stroke: "#6366f1"
  style.stroke-width: 2
}

# CPU code â†’ Slave PIC ports
cpu_code.step_icw1 -> slave_pic.ports.cmd_port: "outb(0xA0, 0x11)\nICW1: start init" {
  style.stroke: "#3b82f6"
  style.stroke-width: 2
  style.animated: true
}
cpu_code.step_icw2 -> slave_pic.ports.data_port: "outb(0xA1, 0x28)\nICW2: offset=40" {
  style.stroke: "#22c55e"
  style.stroke-width: 2
  style.animated: true
}
cpu_code.step_icw3 -> slave_pic.ports.data_port: "outb(0xA1, 0x02)\nICW3: slaveID=2" {
  style.stroke: "#a855f7"
  style.stroke-width: 2
}
cpu_code.step_icw4 -> slave_pic.ports.data_port: "outb(0xA1, 0x01)\nICW4: 8086 mode" {
  style.stroke: "#f97316"
  style.stroke-width: 2
}
cpu_code.step_ocw1 -> slave_pic.ports.data_port: "outb(0xA1, mask)\nOCW1: set IMR" {
  style.stroke: "#6366f1"
  style.stroke-width: 2
}

# Master state machine triggered by port writes
master_pic.ports.cmd_port -> master_pic.state_machine.s_init: "CMD write triggers\nINIT state" {
  style.stroke: "#8b5cf6"
  style.stroke-dash: 3
}
master_pic.state_machine.s_ready -> master_pic.irq_map_after: "now routes\nIRQs correctly" {
  style.stroke: "#22c55e"
}
master_pic.irq_map_before -> master_pic.irq_map_after: "REMAP\nfixes this" {
  style.stroke: "#ef4444"
  style.stroke-width: 3
  style.stroke-dash: 5
}

# Slave state machine
slave_pic.ports.cmd_port -> slave_pic.state_machine.s_init: "CMD write triggers\nINIT state" {
  style.stroke: "#8b5cf6"
  style.stroke-dash: 3
}
slave_pic.state_machine.s_ready -> slave_pic.irq_map_after: "now routes\nIRQs correctly" {
  style.stroke: "#22c55e"
}

# Cascade wiring
master_pic.irq_map_after.a2 -> slave_pic.irq_map_after: "IRQ2 cascade line\nhardware wired\nmaster pin â†’ slave INT" {
  style.stroke: "#6366f1"
  style.stroke-width: 2
  style.stroke-dash: 4
}

# Vector map relationships
master_pic.irq_map_after -> vector_map.irq_zone: "IRQ0..7 â†’ vec 32..39\n(safe zone above exceptions)" {
  style.stroke: "#22c55e"
  style.stroke-width: 2
}
slave_pic.irq_map_after -> vector_map.irq_zone: "IRQ8..15 â†’ vec 40..47\n(safe zone)" {
  style.stroke: "#22c55e"
  style.stroke-width: 2
}

# io_wait in the flow
cpu_code.step_icw1 -> io_wait_block: "io_wait() called\nbetween every OUT" {
  style.stroke: "#eab308"
  style.stroke-dash: 4
}

# Bit anatomy references
icw_anatomy -> cpu_code: "bit-level explanation\nfor each ICW value" {
  style.stroke: "#f59e0b"
  style.stroke-dash: 5
  style.font-color: "#f59e0b"
}