The error is caused by the markdown table in `bit_decode` inside `step1` — the `|` characters in the table conflict with D2's block string delimiter. The fix is to use an alternate block string delimiter (e.g., `|||md ... |||`) for that block. Also the `freq_table` at the bottom has the same issue.
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  ## PIT Channel 0 — 100 Hz Frequency Configuration
  **Trace:** `pit_init(100)` → ports 0x43 / 0x40 → 10 ms tick
| {near: top-center}
back_to_map: "↖ Satellite Map" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#1a1a2e"
    font-color: "#aaaaff"
    stroke: "#aaaaff"
    stroke-dash: 4
    border-radius: 6
    font-size: 11
  }
}
clock_src: "Intel 8253/8254 PIT\nClock Source" {
  style: {
    fill: "#0d1b2a"
    stroke: "#4fc3f7"
    stroke-width: 2
    font-color: "#4fc3f7"
    bold: true
    border-radius: 6
  }
  xtal: "14.318 MHz Crystal\n(IBM PC original)" {
    style.fill: "#0a3d62"
    style.stroke: "#4fc3f7"
    style.font-color: "#b3e5fc"
    style.border-radius: 4
  }
  div12: "÷ 12 (chipset prescaler)" {
    style.fill: "#0a3d62"
    style.stroke: "#4fc3f7"
    style.font-color: "#b3e5fc"
    style.border-radius: 4
  }
  base_clk: "1.193182 MHz\nBase Clock → CNT_CLK" {
    style.fill: "#0a3d62"
    style.stroke: "#4fc3f7"
    style.font-color: "#e1f5fe"
    style.bold: true
    style.border-radius: 4
  }
  xtal -> div12: "raw oscillator"
  div12 -> base_clk: "÷ 12 = 1.193182 MHz"
}
math: "Divisor Calculation" {
  style: {
    fill: "#1a0533"
    stroke: "#ce93d8"
    stroke-width: 2
    font-color: "#ce93d8"
    bold: true
    border-radius: 6
  }
  formula: |md
    **Formula**
    `divisor = base_freq / target_freq`
    `divisor = 1,193,182 / 100`
    `divisor = 11,931.82 → 11,932 (0x2E9C)`
  | {
    style.fill: "#2d0545"
    style.stroke: "#9c27b0"
    style.border-radius: 4
  }
  bytes: "Byte Split\n(little-endian, lo first)" {
    style.fill: "#2d0545"
    style.stroke: "#9c27b0"
    style.font-color: "#e1bee7"
    style.border-radius: 4
  }
  lo_byte: "Low Byte\n0x9C  (11932 & 0xFF)" {
    style.fill: "#4a0072"
    style.stroke: "#9c27b0"
    style.font-color: "#f3e5f5"
    style.border-radius: 4
  }
  hi_byte: "High Byte\n0x2E  (11932 >> 8)" {
    style.fill: "#4a0072"
    style.stroke: "#9c27b0"
    style.font-color: "#f3e5f5"
    style.border-radius: 4
  }
  formula -> bytes: "integer truncation\n(floor → 11,932)"
  bytes -> lo_byte: "11932 & 0xFF"
  bytes -> hi_byte: "11932 >> 8"
}
c_code: "pit_init(100) — C Source" {
  style: {
    fill: "#001b00"
    stroke: "#66bb6a"
    stroke-width: 2
    font-color: "#66bb6a"
    bold: true
    border-radius: 6
  }
  src: |go
    void pit_init(uint32_t frequency) {
        uint16_t divisor = 1193182 / frequency;
        // ① Command byte → 0x43
        outb(0x43, 0x36);
        // ② Low byte  → 0x40
        outb(0x40, divisor & 0xFF);
        // ③ High byte → 0x40
        outb(0x40, (divisor >> 8) & 0xFF);
    }
  | {
    style.fill: "#002200"
    style.stroke: "#388e3c"
    style.border-radius: 4
  }
}
step1: "① outb(0x43, 0x36)\nMode/Command Register" {
  style: {
    fill: "#1a1200"
    stroke: "#ffd54f"
    stroke-width: 2
    font-color: "#ffd54f"
    bold: true
    border-radius: 6
  }
  port43: "I/O Port 0x43\n(Write-only command register)" {
    style.fill: "#332200"
    style.stroke: "#ffc107"
    style.font-color: "#fff9c4"
    style.border-radius: 4
  }
  cmd_byte: "Command Byte: 0x36\n= 0b 00 11 011 0" {
    style.fill: "#332200"
    style.stroke: "#ffc107"
    style.font-color: "#fff9c4"
    style.border-radius: 4
  }
  bit_decode: |||md
    | Bits | Value | Meaning |
    |------|-------|---------|
    | 7-6  | 00    | Channel 0 (IRQ0 timer) |
    | 5-4  | 11    | Access: lo/hi byte |
    | 3-1  | 011   | Mode 3 Square Wave |
    | 0    | 0     | Binary counter |
  ||| {
    style.fill: "#3d2900"
    style.stroke: "#ffa000"
    style.border-radius: 4
  }
  port43 -> cmd_byte: "write 0x36"
  cmd_byte -> bit_decode: "decoded"
}
step2: "② outb(0x40, 0x9C)\nLow Byte of Divisor" {
  style: {
    fill: "#001a1a"
    stroke: "#4dd0e1"
    stroke-width: 2
    font-color: "#4dd0e1"
    bold: true
    border-radius: 6
  }
  port40_lo: "I/O Port 0x40\nChannel 0 Data Register" {
    style.fill: "#002929"
    style.stroke: "#00838f"
    style.font-color: "#b2ebf2"
    style.border-radius: 4
  }
  lo_val: "Write: 0x9C\n(11932 & 0xFF = 156)" {
    style.fill: "#002929"
    style.stroke: "#00838f"
    style.font-color: "#e0f7fa"
    style.border-radius: 4
  }
  port40_lo -> lo_val: "first write (lo byte)"
}
step3: "③ outb(0x40, 0x2E)\nHigh Byte of Divisor" {
  style: {
    fill: "#001a0a"
    stroke: "#81c784"
    stroke-width: 2
    font-color: "#81c784"
    bold: true
    border-radius: 6
  }
  port40_hi: "I/O Port 0x40\nChannel 0 Data Register" {
    style.fill: "#002b10"
    style.stroke: "#388e3c"
    style.font-color: "#c8e6c9"
    style.border-radius: 4
  }
  hi_val: "Write: 0x2E\n(11932 >> 8 = 46)" {
    style.fill: "#002b10"
    style.stroke: "#388e3c"
    style.font-color: "#e8f5e9"
    style.border-radius: 4
  }
  port40_hi -> hi_val: "second write (hi byte)\nPIT latches full 16-bit divisor"
}
pit_hw: "PIT Channel 0 — Internal Hardware" {
  style: {
    fill: "#0d0d1a"
    stroke: "#7986cb"
    stroke-width: 2
    font-color: "#9fa8da"
    bold: true
    border-radius: 6
  }
  counter_reg: "16-bit Counter Register\nLoaded: 11,932 (0x2E9C)" {
    style.fill: "#1a1a33"
    style.stroke: "#5c6bc0"
    style.font-color: "#c5cae9"
    style.border-radius: 4
  }
  mode3_op: "Mode 3 — Square Wave\nCounts DOWN each CNT_CLK pulse\nAuto-reloads when → 0" {
    style.fill: "#1a1a33"
    style.stroke: "#5c6bc0"
    style.font-color: "#c5cae9"
    style.border-radius: 4
  }
  out_pin: "OUT0 Pin\nToggle every 11,932 ticks\n→ Square wave @ 100 Hz" {
    style.fill: "#1a1a33"
    style.stroke: "#5c6bc0"
    style.font-color: "#e8eaf6"
    style.bold: true
    style.border-radius: 4
  }
  counter_reg -> mode3_op: "decrement per CNT_CLK\n(1.193182 MHz)"
  mode3_op -> out_pin: "asserts IRQ0 every\n11,932 × (1/1,193,182 s)\n= 10.000 ms"
}
output: "Resulting Timer Interrupt" {
  style: {
    fill: "#1a0000"
    stroke: "#ef5350"
    stroke-width: 2
    font-color: "#ef9a9a"
    bold: true
    border-radius: 6
  }
  irq0: "IRQ0 → PIC → CPU Vector 32\n(after PIC remapping from M2)" {
    style.fill: "#330000"
    style.stroke: "#c62828"
    style.font-color: "#ffcdd2"
    style.border-radius: 4
  }
  handler: "timer_handler()\n→ tick_counter++\n→ scheduler_tick() [M4]" {
    style.fill: "#330000"
    style.stroke: "#c62828"
    style.font-color: "#ffcdd2"
    style.border-radius: 4
  }
  freq_out: "Interrupt Rate\n100 Hz = every 10 ms\nDivisor error: < 0.001%" {
    style.fill: "#4d0000"
    style.stroke: "#b71c1c"
    style.font-color: "#ff8a80"
    style.bold: true
    style.border-radius: 4
  }
  irq0 -> handler: "IDT[32] dispatch"
  handler -> freq_out
}
clock_src.base_clk -> pit_hw.counter_reg: "1.193182 MHz\nCNT_CLK pulses\n(continuous hardware signal)" {
  style.stroke: "#4fc3f7"
  style.stroke-width: 2
  style.animated: true
}
c_code -> step1: "① call outb(0x43, 0x36)\n(must be first — sets mode)" {
  style.stroke: "#ffd54f"
  style.stroke-width: 2
}
c_code -> math: "divisor = 1193182 / 100" {
  style.stroke: "#ce93d8"
  style.stroke-dash: 3
}
math.lo_byte -> step2: "0x9C → port 0x40" {
  style.stroke: "#4dd0e1"
  style.stroke-width: 2
}
math.hi_byte -> step3: "0x2E → port 0x40" {
  style.stroke: "#81c784"
  style.stroke-width: 2
}
step1.port43 -> pit_hw: "programs channel 0\naccess mode + square wave" {
  style.stroke: "#ffd54f"
  style.stroke-dash: 3
}
step2.port40_lo -> pit_hw.counter_reg: "low byte latched\n(PIT awaits hi byte)" {
  style.stroke: "#4dd0e1"
}
step3.port40_hi -> pit_hw.counter_reg: "hi byte latched →\nPIT starts counting" {
  style.stroke: "#81c784"
  style.stroke-width: 2
}
pit_hw.out_pin -> output.irq0: "OUT0 asserted\nevery 10 ms" {
  style.stroke: "#ef5350"
  style.stroke-width: 2
  style.animated: true
}
freq_table: |||md
  | Target Hz | Divisor | Low Byte | High Byte | Actual Hz  | Note              |
  |-----------|---------|----------|-----------|------------|-------------------|
  | 18.2 Hz   | 65536   | 0x00     | 0x00      | 18.206 Hz  | default BIOS rate |
  | 100 Hz    | 11932   | 0x9C     | 0x2E      | 100.00 Hz  | this diagram      |
  | 250 Hz    | 4772    | 0xE4     | 0x12      | 250.04 Hz  | 0.016% error      |
  | 1000 Hz   | 1193    | 0xC9     | 0x04      | 1000.15 Hz | 0.015% error      |
||| {
  near: bottom-center
  style.fill: "#111111"
  style.stroke: "#444444"
  style.font-color: "#cccccc"
  style.border-radius: 4
}