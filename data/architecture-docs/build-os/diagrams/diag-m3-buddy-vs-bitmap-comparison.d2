vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: right

title: |md
  # Physical Allocator Comparison: Bitmap vs Buddy System
| {near: top-center}

bitmap_panel: Bitmap Allocator {
  style: {
    fill: "#1a2a3a"
    stroke: "#4a9eff"
    stroke-width: 2
    border-radius: 8
  }

  bm_title: Implement This First {
    style: {
      fill: "#0d1f2d"
      stroke: "#4a9eff"
      font-color: "#4a9eff"
      bold: true
      font-size: 18
    }
  }

  bm_metadata: Metadata Cost {
    style: {
      fill: "#0a2a1a"
      stroke: "#00cc66"
      stroke-width: 2
    }
    bm_meta_detail: |md
      **4GB RAM at 4KB pages = 1M frames**

      1 bit per frame = **128 KB bitmap**

      Fits entirely in L2/L3 cache (256KB-1MB)

      Each 64B cache line = 512 bits = 512 frames = 2MB RAM
    |
  }

  bm_complexity: Complexity {
    style: {
      fill: "#1a1a0a"
      stroke: "#ccaa00"
      stroke-width: 2
    }
    alloc_row: "Allocate: O(n) scan - worst case 32768 reads" {
      style.fill: "#2a1a00"
      style.stroke: "#ccaa00"
      style.font-color: "#ffdd44"
    }
    free_row: "Free: O(1) - clear one bit, done" {
      style.fill: "#0a2a0a"
      style.stroke: "#00cc66"
      style.font-color: "#44ff44"
    }
    contig_row: "Contiguous N frames: O(n) scan for N consecutive 0-bits" {
      style.fill: "#2a1a00"
      style.stroke: "#ccaa00"
      style.font-color: "#ffdd44"
    }
    dbl_free_row: "Double-free detect: O(1) - test bit before clear" {
      style.fill: "#0a2a0a"
      style.stroke: "#00cc66"
      style.font-color: "#44ff44"
    }
  }

  bm_layout: Memory Bitmap Layout {
    style: {
      fill: "#0d1a2a"
      stroke: "#4a9eff"
      stroke-width: 2
    }

    w0: "Word[0]: frames 0-31\nphys 0x0-0x1FFFF\nRESERVED (IVT+BIOS)" {
      style.fill: "#8b0000"
      style.stroke: "#ff4444"
      style.font-color: white
    }
    w1: "Word[1-63]: frames 32-2047\nphys 0x20000-0x7FFFFF\nRESERVED (video+ROM)" {
      style.fill: "#8b0000"
      style.stroke: "#ff4444"
      style.font-color: white
    }
    w2: "Word[64-100]: frames 2048-3231\nphys 0x800000-0xC9FFFF\nKERNEL CODE+DATA USED" {
      style.fill: "#4a0080"
      style.stroke: "#aa44ff"
      style.font-color: white
    }
    w3: "Word[101]+: frames 3232+\nphys 0xCA0000+\nFREE usable RAM" {
      style.fill: "#0a3a0a"
      style.stroke: "#00cc66"
      style.font-color: white
    }
    w4: "Word[32767]: frames 1048544-1048575\nphys top of 4GB\nFREE" {
      style.fill: "#0a3a0a"
      style.stroke: "#00cc66"
      style.font-color: white
    }

    w0 -> w1: "sequential layout"
    w1 -> w2: "..."
    w2 -> w3: "search_hint\nstarts here"
    w3 -> w4: "..."
  }

  bm_hint: Next-Fit search_hint Optimization {
    style: {
      fill: "#0d0d2a"
      stroke: "#4a9eff"
      stroke-width: 2
    }
    hint_detail: |md
      Scan starts from last successful allocation

      Sequential reads trigger hardware prefetcher

      Hot path: same cache line holds 512 adjacent frames

      After warm-up: 128KB bitmap stays resident in L2 cache
    |
  }

  bm_verdict: Pros {
    style.fill: "#0a2a0a"
    style.stroke: "#00cc66"
    style.border-radius: 6
    p1: "128KB metadata fits entirely in cache" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    p2: "Sequential scan is HW-prefetch friendly" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    p3: "O(1) free with double-free detection" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    p4: "Simple: ~100 lines of C" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    p5: "Sufficient for learning OS under 256MB" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
  }

  bm_issues: Cons {
    style.fill: "#2a0a0a"
    style.stroke: "#cc4444"
    style.border-radius: 6
    c1: "O(n) allocation slow for large bitmaps" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
    c2: "No native contiguous multi-frame alloc" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
    c3: "External fragmentation: free frames scattered" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
    c4: "Linux migrated away due to fragmentation at scale" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
  }
}

buddy_panel: Buddy System Allocator {
  style: {
    fill: "#1a0a2a"
    stroke: "#cc44ff"
    stroke-width: 2
    border-radius: 8
  }

  bd_title: Linux Kernel Production Implementation {
    style: {
      fill: "#0d0a1f"
      stroke: "#cc44ff"
      font-color: "#cc44ff"
      bold: true
      font-size: 18
    }
  }

  bd_orders: Free Lists by Order (11 levels) {
    style: {
      fill: "#0a0a2a"
      stroke: "#4a9eff"
      stroke-width: 2
    }
    o0: "Order 0: 4KB  (1 frame)   [][][]..." {style.fill: "#0a1a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
    o1: "Order 1: 8KB  (2 frames)  [][]...." {style.fill: "#0a1a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
    o2: "Order 2: 16KB (4 frames)  []......" {style.fill: "#0a1a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
    o3: "Order 3: 32KB (8 frames)  []......" {style.fill: "#0a1a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
    o4: "Order 4: 64KB (16 frames) []......" {style.fill: "#0a1a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
    o5: "Order 5: 128KB (32 frames) ......." {style.fill: "#0a1a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
    o9: "Order 9: 2MB  (512 frames) ......" {style.fill: "#1a0a2a"; style.stroke: "#cc44ff"; style.font-color: "#cc88ff"}
    o10: "Order 10: 4MB (1024 frames) huge" {style.fill: "#1a0a2a"; style.stroke: "#cc44ff"; style.font-color: "#cc88ff"}
    o0 -> o1: "each is a\nlinked list"
    o1 -> o2
    o2 -> o3
    o3 -> o4
    o4 -> o5
    o5 -> o9: "..."
    o9 -> o10
  }

  bd_complexity: Complexity {
    style: {
      fill: "#1a0a1a"
      stroke: "#cc44ff"
      stroke-width: 2
    }
    ba1: "Allocate: O(log n) - find order, pop from free list" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    ba2: "Free: O(log n) - coalesce buddies up the tree" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    ba3: "Contiguous N frames: O(1) - pop from correct order" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    ba4: "External fragmentation: ZERO for power-of-2 sizes" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    bc1: "Internal fragmentation: 17KB request wastes 32KB" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
  }

  bd_split_tree: Buddy Split Tree: 64KB satisfying 16KB Request {
    style: {
      fill: "#0d0a1a"
      stroke: "#cc44ff"
      stroke-width: 2
    }

    root_blk: "Order-4 Block: 64KB\nframes 0-15 (0x100000-0x10FFFF)\nINITIAL STATE: FREE" {
      style.fill: "#0a3a0a"
      style.stroke: "#00cc66"
      style.stroke-width: 3
      style.font-color: white
      style.bold: true
    }

    split1: "SPLIT 1: 16KB request arrives\nOrder-2 free list empty\nSplit 64KB into two 32KB blocks" {
      style.fill: "#2a2a0a"
      style.stroke: "#ccaa00"
      style.font-color: "#ffdd44"
    }

    ord3L: "Order-3 Left: 32KB\nframes 0-7\n0x100000-0x107FFF\nSplit further" {
      style.fill: "#1a2a1a"
      style.stroke: "#44cc44"
      style.font-color: white
    }

    ord3R: "Order-3 Right: 32KB\nframes 8-15\n0x108000-0x10FFFF\nAdded to Order-3 FREE LIST" {
      style.fill: "#0a3a0a"
      style.stroke: "#00cc66"
      style.font-color: white
    }

    split2: "SPLIT 2: Still no Order-2 block\nSplit Order-3 Left into two Order-2 blocks" {
      style.fill: "#2a2a0a"
      style.stroke: "#ccaa00"
      style.font-color: "#ffdd44"
    }

    ord2L: "Order-2 Left: 16KB ALLOCATED\nframes 0-3\n0x100000-0x103FFF\nReturned to caller" {
      style.fill: "#8b0000"
      style.stroke: "#ff4444"
      style.stroke-width: 3
      style.font-color: white
      style.bold: true
    }

    ord2R: "Order-2 Right: 16KB FREE\nframes 4-7\n0x104000-0x107FFF\nAdded to Order-2 FREE LIST" {
      style.fill: "#0a3a0a"
      style.stroke: "#00cc66"
      style.font-color: white
    }

    root_blk -> split1: "alloc_pages(order=2)\n16KB request"
    split1 -> ord3L: "left half"
    split1 -> ord3R: "right half\nto free list"
    ord3L -> split2: "too large\nfor 16KB"
    split2 -> ord2L: "ALLOCATED"
    split2 -> ord2R: "to Order-2\nfree list"
  }

  bd_coalesce: Buddy Coalescing Formula {
    style: {
      fill: "#0a0a2a"
      stroke: "#4a9eff"
      stroke-width: 2
    }
    formula: "buddy_addr = addr XOR (1 << (order + PAGE_SHIFT))" {
      style.fill: "#0d0d2a"
      style.stroke: "#4a9eff"
      style.font-color: "#88ccff"
      style.bold: true
      style.font: mono
    }
    ex1: "Free Order-2 Left (0x100000):" {style.fill: "#0a0a2a"; style.stroke: "#4a9eff"; style.font-color: white}
    ex2: "buddy = 0x100000 XOR 0x4000 = 0x104000 (Order-2 Right)" {style.fill: "#0a0a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"; style.font: mono}
    ex3: "Order-2 Right in free list? YES -> merge to Order-3" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    ex4: "Order-3 buddy (0x108000) free? YES -> merge to Order-4" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    ex5: "Result: full 64KB block restored. Zero fragmentation." {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: white; style.bold: true}
    formula -> ex1
    ex1 -> ex2
    ex2 -> ex3
    ex3 -> ex4
    ex4 -> ex5
  }

  bd_fl_state: Free List State After Allocation {
    style: {
      fill: "#0d0a1a"
      stroke: "#cc44ff"
      stroke-width: 2
    }
    fl0: "Order 0: empty" {style.fill: "#1a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
    fl1: "Order 1: empty" {style.fill: "#1a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
    fl2: "Order 2: [0x104000] <- 16KB right half" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    fl3: "Order 3: [0x108000] <- 32KB right half" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    fl4: "Order 4: empty (was consumed)" {style.fill: "#1a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
  }

  bd_verdict: Pros {
    style.fill: "#0a2a0a"
    style.stroke: "#00cc66"
    style.border-radius: 6
    bp1: "O(log n) alloc and free - fast at scale" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    bp2: "Natural contiguous multi-frame alloc (huge pages)" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    bp3: "Buddy coalescing eliminates external fragmentation" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    bp4: "Powers Linux alloc_pages() and 2MB/1GB huge pages" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    bp5: "Free list per order = cache-friendly for common sizes" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
  }

  bd_issues: Cons {
    style.fill: "#2a0a0a"
    style.stroke: "#cc4444"
    style.border-radius: 6
    bc1: "Internal fragmentation: 17KB request wastes 32KB" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
    bc2: "Metadata: bitmap PLUS free list pointers per order" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
    bc3: "Complex to implement correctly: ~500 lines of C" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
    bc4: "Overkill for small systems under 64MB RAM" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
  }
}

comparison: Head-to-Head Comparison {
  style: {
    fill: "#0d1a2a"
    stroke: "#4a9eff"
    stroke-width: 2
    border-radius: 8
  }

  row_alloc: "Alloc complexity" {style.fill: "#0d1a2a"; style.stroke: "#4a9eff"; style.font-color: white; style.bold: true}
  bm_alloc: "O(n) scan" {style.fill: "#2a1a00"; style.stroke: "#ccaa00"; style.font-color: "#ffdd44"}
  bd_alloc: "O(log n) WIN" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"; style.bold: true}

  row_free: "Free complexity" {style.fill: "#0d1a2a"; style.stroke: "#4a9eff"; style.font-color: white; style.bold: true}
  bm_free: "O(1) WIN" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"; style.bold: true}
  bd_free: "O(log n) coalesce" {style.fill: "#2a1a00"; style.stroke: "#ccaa00"; style.font-color: "#ffdd44"}

  row_meta: "Metadata for 4GB" {style.fill: "#0d1a2a"; style.stroke: "#4a9eff"; style.font-color: white; style.bold: true}
  bm_meta: "128 KB WIN" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"; style.bold: true}
  bd_meta: "~256 KB" {style.fill: "#2a1a00"; style.stroke: "#ccaa00"; style.font-color: "#ffdd44"}

  row_extfrag: "External fragmentation" {style.fill: "#0d1a2a"; style.stroke: "#4a9eff"; style.font-color: white; style.bold: true}
  bm_extfrag: "HIGH at scale" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}
  bd_extfrag: "ZERO for power-of-2 WIN" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"; style.bold: true}

  row_intfrag: "Internal fragmentation" {style.fill: "#0d1a2a"; style.stroke: "#4a9eff"; style.font-color: white; style.bold: true}
  bm_intfrag: "None WIN" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"; style.bold: true}
  bd_intfrag: "Up to 50% (17KB->32KB)" {style.fill: "#2a1a00"; style.stroke: "#ccaa00"; style.font-color: "#ffdd44"}

  row_contig: "Contiguous alloc" {style.fill: "#0d1a2a"; style.stroke: "#4a9eff"; style.font-color: white; style.bold: true}
  bm_contig: "O(n) scan" {style.fill: "#2a1a00"; style.stroke: "#ccaa00"; style.font-color: "#ffdd44"}
  bd_contig: "O(1) list pop WIN" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"; style.bold: true}

  row_impl: "Implementation" {style.fill: "#0d1a2a"; style.stroke: "#4a9eff"; style.font-color: white; style.bold: true}
  bm_impl: "~100 lines WIN" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"; style.bold: true}
  bd_impl: "~500 lines" {style.fill: "#2a1a00"; style.stroke: "#ccaa00"; style.font-color: "#ffdd44"}

  row_use: "Used by" {style.fill: "#0d1a2a"; style.stroke: "#4a9eff"; style.font-color: white; style.bold: true}
  bm_use: "Learning kernels" {style.fill: "#0d1a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
  bd_use: "Linux, FreeBSD, XNU WIN" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"; style.bold: true}

  row_first: "Implement first?" {style.fill: "#1a2a0a"; style.stroke: "#00cc66"; style.font-color: white; style.bold: true}
  bm_first: "YES - start here" {style.fill: "#0a3a0a"; style.stroke: "#00ff66"; style.font-color: white; style.bold: true}
  bd_first: "After bitmap works" {style.fill: "#1a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff6666"}

  row_alloc -> bm_alloc: "bitmap"
  row_alloc -> bd_alloc: "buddy"
  row_free -> bm_free
  row_free -> bd_free
  row_meta -> bm_meta
  row_meta -> bd_meta
  row_extfrag -> bm_extfrag
  row_extfrag -> bd_extfrag
  row_intfrag -> bm_intfrag
  row_intfrag -> bd_intfrag
  row_contig -> bm_contig
  row_contig -> bd_contig
  row_impl -> bm_impl
  row_impl -> bd_impl
  row_use -> bm_use
  row_use -> bd_use
  row_first -> bm_first
  row_first -> bd_first
}

why_migrate: Why Linux Migrated Bitmap to Buddy {
  style: {
    fill: "#1a0a0a"
    stroke: "#ff6644"
    stroke-width: 2
    border-radius: 8
  }

  problem: The Fragmentation Problem at Scale {
    style.fill: "#2a0a0a"
    style.stroke: "#cc4444"
    p1: "4GB RAM with thousands of processes" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff8866"}
    p2: "Bitmap: free frames scattered across address space" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff8866"}
    p3: "2MB request (huge page, DMA buffer, GPU memory)" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff8866"}
    p4: "Must scan 128KB bitmap for 512 contiguous frames" {style.fill: "#2a0a0a"; style.stroke: "#cc4444"; style.font-color: "#ff8866"}
    p5: "FAILS even with 1GB free RAM if no contiguous run exists" {style.fill: "#8b0000"; style.stroke: "#ff4444"; style.font-color: white; style.bold: true}
    p1 -> p2 -> p3 -> p4 -> p5
  }

  solution: The Buddy Solution {
    style.fill: "#0a2a0a"
    style.stroke: "#00cc66"
    s1: "Every free block of size 2^k is aligned to 2^k pages" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    s2: "2MB request (order-9): O(1) pop from order-9 list" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    s3: "Coalescing on free restores higher-order blocks automatically" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    s4: "No fragmentation possible for power-of-2 aligned requests" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: white; style.bold: true}
    s1 -> s2 -> s3 -> s4
  }

  linux_stack: Linux Hybrid Memory Stack {
    style.fill: "#0a0a2a"
    style.stroke: "#4a9eff"
    l1: "alloc_pages(order) - buddy per NUMA zone (orders 0-10)" {style.fill: "#0a0a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"; style.bold: true}
    l2: "kmem_cache_alloc() - SLUB slab allocator above buddy for typed objects" {style.fill: "#0a0a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
    l3: "kmalloc() - SLUB size-class slabs for variable kernel allocations" {style.fill: "#0a0a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
    l4: "vmalloc() - virtual contiguous but physically scattered (large)" {style.fill: "#0a0a2a"; style.stroke: "#4a9eff"; style.font-color: "#88ccff"}
    l1 -> l2: "typed objects\nuse SLUB above"
    l1 -> l3: "variable size"
    l1 -> l4: "large virtual"
  }

  problem -> solution: "buddy solves\nfragmentation"
  solution -> linux_stack: "Linux production\nstrategy"
}

strategy: Implementation Strategy {
  style: {
    fill: "#0a1a0a"
    stroke: "#00cc66"
    stroke-width: 3
    border-radius: 8
  }
  st1: "Step 1: Bitmap (this milestone)" {
    style.fill: "#0a3a0a"
    style.stroke: "#00ff66"
    style.font-color: white
    style.bold: true
    d1: "Simple and correct: ~100 lines of C" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    d2: "Use search_hint for amortized O(1) sequential allocs" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    d3: "128KB metadata fits in L2 cache after warm-up" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
    d4: "Sufficient for learning OS with small RAM and few processes" {style.fill: "#0a2a0a"; style.stroke: "#00cc66"; style.font-color: "#44ff44"}
  }
  st2: "Step 2: Buddy (production evolution)" {
    style.fill: "#0a0a2a"
    style.stroke: "#cc44ff"
    style.font-color: white
    style.bold: true
    d1: "Required for huge pages and DMA contiguous alloc" {style.fill: "#0a0a2a"; style.stroke: "#cc44ff"; style.font-color: "#cc88ff"}
    d2: "Replace pmm_alloc_frame() with pmm_alloc_pages(order)" {style.fill: "#0a0a2a"; style.stroke: "#cc44ff"; style.font-color: "#cc88ff"}
    d3: "Add SLUB slab allocator above buddy for typed kernel objects" {style.fill: "#0a0a2a"; style.stroke: "#cc44ff"; style.font-color: "#cc88ff"}
    d4: "Necessary for systems over 1GB RAM and production workloads" {style.fill: "#0a0a2a"; style.stroke: "#cc44ff"; style.font-color: "#cc88ff"}
  }
  st1 -> st2: "master bitmap first\nthen graduate to buddy"
}

bitmap_panel -> comparison: "O(n) alloc, O(1) free\n128KB metadata" {
  style.stroke: "#4a9eff"
  style.font-color: "#4a9eff"
  style.stroke-width: 2
}

buddy_panel -> comparison: "O(log n) alloc+free\nzero external fragmentation" {
  style.stroke: "#cc44ff"
  style.font-color: "#cc44ff"
  style.stroke-width: 2
}

comparison -> why_migrate: "fragmentation at scale\ndrives migration to buddy" {
  style.stroke: "#ff6644"
  style.font-color: "#ff6644"
  style.stroke-width: 2
  style.animated: true
}

why_migrate -> strategy: "implementation\nroadmap" {
  style.stroke: "#00cc66"
  style.font-color: "#00cc66"
  style.stroke-width: 2
}