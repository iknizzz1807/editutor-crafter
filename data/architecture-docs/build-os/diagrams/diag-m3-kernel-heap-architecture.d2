vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: ||md
  ## Kernel Heap — Virtual Memory Backing
  `kmalloc` → Free-List Allocator → Page Mapper → Bitmap PMM → Physical Frames
|| {near: top-center}

back_to_map: "↩ Satellite Map" {
  link: "#anchor-id"
  style: {
    fill: "#2d2d2d"
    font-color: "#aaaaaa"
    stroke: "#555555"
    font-size: 11
    border-radius: 4
  }
}

# ─────────────────────────────────────────────────
# LAYER 0 — VIRTUAL ADDRESS SPACE RULER
# ─────────────────────────────────────────────────
vas: "Virtual Address Space (32-bit, 4 GB total)" {
  style: {
    fill: "#1a1a2e"
    stroke: "#444466"
    font-color: "#ccccff"
    bold: true
    font-size: 13
  }
  r_null: "0x00000000\n─────────\nNULL guard\n(unmapped)" {
    style: { fill: "#3a1a1a"; stroke: "#cc3333"; font-color: "#ff8888"; font-size: 10 }
  }
  r_user: "0x00400000 – 0xBFFFFFFF\n─────────────────────\nUser Process Space\n(per-process page dirs)" {
    style: { fill: "#1a2a1a"; stroke: "#336633"; font-color: "#88cc88"; font-size: 10 }
  }
  r_kernel_code: "0xC0100000 – 0xC03FFFFF\n─────────────────────\nKernel .text / .data / .bss\n(Higher-half, LMA=0x00100000)" {
    style: { fill: "#1a1a3a"; stroke: "#4444aa"; font-color: "#8888ff"; font-size: 10 }
  }
  r_heap: "0xD0000000 – 0xDFFFFFFF\n─────────────────────\nKernel Heap Arena  (256 MB virtual)\nkmalloc / kfree space" {
    style: { fill: "#2a1a2a"; stroke: "#884488"; font-color: "#cc88cc"; bold: true; font-size: 10 }
  }
  r_reserved: "0xE0000000 – 0xFFBFFFFF\n─────────────────────\nReserved — future kernel use" {
    style: { fill: "#222222"; stroke: "#444444"; font-color: "#666666"; font-size: 10 }
  }

  r_null -> r_user: "↓ address increases" { style: { stroke: "#555555"; stroke-dash: 4; font-size: 9; font-color: "#777777" } }
  r_user -> r_kernel_code { style: { stroke: "#555555"; stroke-dash: 4 } }
  r_kernel_code -> r_heap { style: { stroke: "#884488"; stroke-dash: 4; font-color: "#aa66aa" } }
  r_heap -> r_reserved { style: { stroke: "#555555"; stroke-dash: 4 } }
}

# ─────────────────────────────────────────────────
# LAYER 1 — HEAP ARENA DETAIL (virtual pages)
# ─────────────────────────────────────────────────
heap_arena: "Heap Arena  0xD0000000 – 0xDFFFFFFF" {
  style: {
    fill: "#1e0f1e"
    stroke: "#884488"
    font-color: "#cc88cc"
    bold: true
    font-size: 12
  }
  brk_ptr: "heap_brk  =  0xD0003000  (current)\nAdvances by PAGE_SIZE on demand\nVirtual range above brk = uncommitted" {
    style: { fill: "#2a1a2a"; stroke: "#aa55aa"; font-color: "#ddaadd"; font-size: 10; border-radius: 4 }
  }
  committed: "Committed Virtual Pages  (4 KB each)" {
    style: { fill: "#1a1218"; stroke: "#664466"; font-color: "#bb99bb"; font-size: 11 }
    pg0: "Page 0\n0xD0000000\n– 0xD0000FFF\n(4 KB)" {
      style: { fill: "#2d1a3a"; stroke: "#775577"; font-color: "#cc99cc"; font-size: 9 }
    }
    pg1: "Page 1\n0xD0001000\n– 0xD0001FFF\n(4 KB)" {
      style: { fill: "#2d1a3a"; stroke: "#775577"; font-color: "#cc99cc"; font-size: 9 }
    }
    pg2: "Page 2\n0xD0002000\n– 0xD0002FFF\n(4 KB)" {
      style: { fill: "#2d1a3a"; stroke: "#775577"; font-color: "#cc99cc"; font-size: 9 }
    }
  }
  uncommitted: "Uncommitted Virtual Range\n0xD0003000 – 0xDFFFFFFF\n(grown lazily — no physical frame yet)\nNext paging_map() call commits next page" {
    style: { fill: "#111111"; stroke: "#333333"; font-color: "#555555"; stroke-dash: 6; font-size: 9 }
  }
  brk_ptr -> committed: "pages below brk\nare committed" {
    style: { stroke: "#aa55aa"; font-color: "#aa55aa"; font-size: 9 }
  }
  brk_ptr -> uncommitted: "pages above brk\nnot yet mapped" {
    style: { stroke: "#444444"; stroke-dash: 5; font-color: "#555555"; font-size: 9 }
  }
}

# ─────────────────────────────────────────────────
# LAYER 2 — FREE-LIST ALLOCATOR (boundary-tag)
# ─────────────────────────────────────────────────
freelist: "Free-List Allocator  (boundary-tag / first-fit)" {
  style: {
    fill: "#0f1a2a"
    stroke: "#336699"
    font-color: "#88aadd"
    bold: true
    font-size: 12
  }
  legend: ||md
    **Block layout in memory (header immediately before user data):**
    | Offset | Field | Size | Notes |
    |--------|-------|------|-------|
    | −20 | `prev`  | 4 B | Previous block pointer |
    | −16 | `next`  | 4 B | Next block pointer |
    | −12 | `magic` | 4 B | `0xDEADBEEF` — corruption guard |
    | −8  | `used`  | 1 B | 0 = free, 1 = allocated |
    | −7  | _pad_   | 3 B | alignment |
    | −4  | `size`  | 4 B | data area size (excl. header) |
    | **0** | **↑ ptr returned to caller** | | |
  || {
    style: { fill: "#0d1622"; stroke: "#224466"; font-color: "#99bbdd"; font-size: 10 }
  }
  blk_a: "Block A  [USED]\naddr: 0xD0000014\nsize: 64 B (data)\nmagic: 0xDEADBEEF\nnext → Block B" {
    style: { fill: "#1a3a1a"; stroke: "#33aa33"; font-color: "#88dd88"; font-size: 9; border-radius: 3 }
  }
  blk_b: "Block B  [FREE]\naddr: 0xD0000068\nsize: 120 B (data)\nmagic: 0xDEADBEEF\nnext → Block C" {
    style: { fill: "#3a3a1a"; stroke: "#aaaa33"; font-color: "#dddd88"; font-size: 9; border-radius: 3 }
  }
  blk_c: "Block C  [USED]\naddr: 0xD0000100\nsize: 32 B (data)\nmagic: 0xDEADBEEF\nnext → NULL" {
    style: { fill: "#1a3a1a"; stroke: "#33aa33"; font-color: "#88dd88"; font-size: 9; border-radius: 3 }
  }
  blk_new: "Block D  [FREE — new]\naddr: 0xD0001014  (page 1)\nsize: 4076 B (rest of page)\nnext → NULL" {
    style: { fill: "#3a3a1a"; stroke: "#aaaa33"; font-color: "#dddd88"; font-size: 9; border-radius: 3; stroke-dash: 5 }
  }

  blk_a -> blk_b: "next (doubly-linked)\nblk_b.prev → blk_a" { style: { stroke: "#557755"; font-size: 8; font-color: "#88aa88" } }
  blk_b -> blk_c: "next" { style: { stroke: "#557755"; font-size: 8; font-color: "#88aa88" } }
  blk_c -> blk_new: "next\n(crosses page boundary)" { style: { stroke: "#777733"; stroke-dash: 4; font-size: 8; font-color: "#aaaa66" } }

  ops: "kmalloc / kfree operations" {
    style: { fill: "#0a0f18"; stroke: "#224466"; font-color: "#7799cc"; font-size: 10 }
    alloc: ||go
      void *kmalloc(uint32_t size) {
          size = ALIGN8(size);
          // 1. First-fit scan free list
          heap_block_t *b = heap_head;
          while (b) {
              if (!b->used && b->size >= size) {
                  if (b->size >= size + HDR + 8) split(b, size);
                  b->used = 1;
                  return b + 1;  // ptr past header
              }
              b = b->next;
          }
          // 2. No fit → extend heap by page(s)
          heap_extend(size);
          return kmalloc(size);  // retry
      }
    ||
    free: ||go
      void kfree(void *ptr) {
          heap_block_t *b = (heap_block_t*)ptr - 1;
          ASSERT(b->magic == 0xDEADBEEF);
          ASSERT(b->used);         // double-free guard
          b->used = 0;
          coalesce_next(b);        // merge with b->next if free
          coalesce_prev(b);        // merge with b->prev if free
      }
    ||
    extend: ||go
      static heap_block_t *heap_extend(uint32_t need) {
          uint32_t pages = CEIL_DIV(need + HDR, PAGE_SIZE);
          for (uint32_t i = 0; i < pages; i++) {
              uint32_t phys = pmm_alloc_frame();   // bitmap allocator
              paging_map(kernel_pd, heap_brk,
                         phys, PTE_PRESENT|PTE_WRITABLE);
              heap_brk += PAGE_SIZE;
          }
          // init block header at base of new region
          heap_block_t *b = (heap_block_t*)(heap_brk - pages*PAGE_SIZE);
          b->size  = pages*PAGE_SIZE - HDR;
          b->magic = 0xDEADBEEF;
          b->used  = 0;
          list_append(b);
          return b;
      }
    ||
  }
}

# ─────────────────────────────────────────────────
# LAYER 3 — PAGE MAPPER  (paging_map)
# ─────────────────────────────────────────────────
page_mapper: "paging_map()  —  Virtual→Physical Binding" {
  style: {
    fill: "#1a1000"
    stroke: "#886600"
    font-color: "#ddaa44"
    bold: true
    font-size: 12
  }
  walk: "Two-level page table walk\n(kernel page directory)" {
    style: { fill: "#251800"; stroke: "#664400"; font-color: "#cc9944"; font-size: 10 }
  }
  pd_entry: "Page Directory Entry\n[PDE idx = virt >> 22]\nPoints to Page Table (physical addr)\nPDE flags: PRESENT | WRITABLE" {
    style: { fill: "#1a1200"; stroke: "#775500"; font-color: "#ddaa55"; font-size: 9; border-radius: 3 }
  }
  pt_entry: "Page Table Entry\n[PTE idx = (virt>>12)&0x3FF]\nStores: phys_frame | PRESENT | WRITABLE\n(no PTE_USER — kernel-only page)" {
    style: { fill: "#1a1200"; stroke: "#775500"; font-color: "#ddaa55"; font-size: 9; border-radius: 3 }
  }
  tlb_flush: "invlpg  virt_addr\n(flush single TLB entry)\nMUST follow every PTE write\n—stale entry = Heisenbug" {
    style: { fill: "#3a1a00"; stroke: "#cc5500"; font-color: "#ff9944"; font-size: 9; border-radius: 3 }
  }
  walk -> pd_entry: "virt[31:22]\nselects PDE" { style: { stroke: "#886633"; font-size: 8; font-color: "#aa8844" } }
  pd_entry -> pt_entry: "virt[21:12]\nselects PTE" { style: { stroke: "#886633"; font-size: 8; font-color: "#aa8844" } }
  pt_entry -> tlb_flush: "after PTE write\nflush TLB" { style: { stroke: "#cc5500"; font-size: 8; font-color: "#cc7722" } }
}

# ─────────────────────────────────────────────────
# LAYER 4 — BITMAP PMM
# ─────────────────────────────────────────────────
pmm: "Bitmap Physical Frame Allocator  (pmm_alloc_frame / pmm_free_frame)" {
  style: {
    fill: "#0a1a0a"
    stroke: "#226622"
    font-color: "#66cc66"
    bold: true
    font-size: 12
  }
  bitmap_desc: "frame_bitmap[MAX_FRAMES/32]\n1 bit per 4 KB frame\n0 = free,  1 = used / reserved\nFor 128 MB RAM: 32 768 frames → 4 KB bitmap" {
    style: { fill: "#0d1a0d"; stroke: "#335533"; font-color: "#88cc88"; font-size: 10; border-radius: 3 }
  }
  bitmap_vis: "Bitmap word example  (32 frames per uint32_t word)" {
    style: { fill: "#0a120a"; stroke: "#224422"; font-color: "#55aa55"; font-size: 9 }
    word0: "word[0]  frames 0–31\n0xFF FF 9C 00\n= 1111 1111 1111 1111 1001 1100 0000 0000\n  ←used (BIOS/kernel)──→ ←free frames──→" {
      style: { fill: "#112211"; stroke: "#336633"; font-color: "#77bb77"; font-size: 9; font: mono }
    }
    word1: "word[1]  frames 32–63\n0x00 00 00 00\n= all bits 0 = all FREE" {
      style: { fill: "#112211"; stroke: "#336633"; font-color: "#77bb77"; font-size: 9; font: mono }
    }
    word_k: "word[k]  frames k*32 – k*32+31\n... (kernel binary region) ...\n0xFF FF FF FF  = all USED" {
      style: { fill: "#221111"; stroke: "#663333"; font-color: "#bb7777"; font-size: 9; font: mono; multiple: true }
    }
  }
  alloc_code: ||go
    uint32_t pmm_alloc_frame(void) {
        for (uint32_t i = 0; i < total_frames/32; i++) {
            if (frame_bitmap[i] == 0xFFFFFFFF) continue; // fast skip
            uint32_t bit = __builtin_ctz(~frame_bitmap[i]); // BSF: O(1)
            uint32_t frame = i*32 + bit;
            frame_bitmap[i] |= (1u << bit);   // mark used
            free_frames--;
            return frame * PAGE_SIZE;          // physical address
        }
        PANIC("OOM: no free physical frames");
    }
  ||
  free_code: ||go
    void pmm_free_frame(uint32_t phys) {
        uint32_t frame = phys / PAGE_SIZE;
        if (!frame_test(frame)) PANIC("double-free at 0x%x", phys);
        frame_clear(frame);
        free_frames++;
    }
  ||
  bitmap_desc -> bitmap_vis: "layout" { style: { stroke: "#335533"; font-size: 8 } }
}

# ─────────────────────────────────────────────────
# LAYER 5 — PHYSICAL FRAMES
# ─────────────────────────────────────────────────
phys_frames: "Physical RAM  (E820 Type-1 Usable Regions)" {
  style: {
    fill: "#1a0a0a"
    stroke: "#884444"
    font-color: "#dd8888"
    bold: true
    font-size: 12
  }
  frame_pool: "Frame Pool  (4 KB each)" {
    style: { fill: "#1e0e0e"; stroke: "#664444"; font-color: "#cc8888"; font-size: 10 }
    fr0: "Frame 0x100\nPhys: 0x00100000\n(reserved—kernel)" {
      style: { fill: "#3a1a1a"; stroke: "#884444"; font-color: "#ff8888"; font-size: 9 }
    }
    fr1: "Frame 0x1F4\nPhys: 0x001F4000\n→ heap pg 0\n[D0000000]" {
      style: { fill: "#1a3a1a"; stroke: "#448844"; font-color: "#88ff88"; font-size: 9 }
    }
    fr2: "Frame 0x2A0\nPhys: 0x002A0000\n→ heap pg 1\n[D0001000]" {
      style: { fill: "#1a3a1a"; stroke: "#448844"; font-color: "#88ff88"; font-size: 9 }
    }
    fr3: "Frame 0x3B1\nPhys: 0x003B1000\n→ heap pg 2\n[D0002000]" {
      style: { fill: "#1a3a1a"; stroke: "#448844"; font-color: "#88ff88"; font-size: 9 }
    }
    fr_free: "Frames 0x400–0x7FFF\n(free pool — 127 MB\nof usable RAM)" {
      style: { fill: "#111111"; stroke: "#333333"; font-color: "#555555"; font-size: 9; multiple: true }
    }
  }
  e820_map: "E820 Physical Memory Map (typical 128 MB QEMU)" {
    style: { fill: "#150808"; stroke: "#553333"; font-color: "#bb7777"; font-size: 9 }
    e_low: "0x00000000 – 0x0009FBFF  Usable (639 KB)" { style: { fill: "#1a2a1a"; stroke: "#336633"; font-color: "#88bb88"; font-size: 8 } }
    e_ebda: "0x0009FC00 – 0x000FFFFF  Reserved (EBDA + BIOS ROM)" { style: { fill: "#2a1a1a"; stroke: "#663333"; font-color: "#bb8888"; font-size: 8 } }
    e_high: "0x00100000 – 0x07FDFFFF  Usable (~127 MB) ← KERNEL + HEAP here" { style: { fill: "#1a2a1a"; stroke: "#336633"; font-color: "#88bb88"; font-size: 8; bold: true } }
    e_acpi: "0x07FE0000 – 0xFFFFFFFF  Reserved (ACPI, MMIO, BIOS flash)" { style: { fill: "#2a1a1a"; stroke: "#663333"; font-color: "#bb8888"; font-size: 8 } }
  }
}

# ─────────────────────────────────────────────────
# INTER-LAYER CONNECTIONS  (the call/data flow)
# ─────────────────────────────────────────────────
vas.r_heap -> heap_arena: "heap virtual range\n0xD0000000–0xDFFFFFFF\n(virtual address window)" {
  style: { stroke: "#884488"; font-color: "#aa66aa"; font-size: 9; stroke-width: 2 }
}
heap_arena.committed.pg0 -> freelist.blk_a: "page 0 hosts\nBlocks A, B\n(4 KB page contains\nmultiple heap blocks)" {
  style: { stroke: "#6644aa"; font-color: "#9977cc"; font-size: 9 }
}
heap_arena.committed.pg1 -> freelist.blk_new: "page 1 hosts\nBlock D\n(freshly extended)" {
  style: { stroke: "#6644aa"; stroke-dash: 4; font-color: "#9977cc"; font-size: 9 }
}
freelist.ops.extend -> page_mapper: "heap_extend() calls\npaging_map(kernel_pd,\n  heap_brk, phys_frame,\n  PTE_PRESENT|PTE_WRITABLE)" {
  style: { stroke: "#cc8800"; font-color: "#ddaa33"; font-size: 9; stroke-width: 2 }
}
freelist.ops.extend -> pmm: "pmm_alloc_frame()\n→ returns physical address\n(one 4 KB frame per call)" {
  style: { stroke: "#33aa33"; font-color: "#55cc55"; font-size: 9; stroke-width: 2 }
}
page_mapper.pt_entry -> heap_arena.committed.pg0: "PTE stores\nphys frame addr\n→ backs virt page" {
  style: { stroke: "#886600"; stroke-dash: 4; font-color: "#aa8833"; font-size: 9 }
}
pmm.bitmap_desc -> phys_frames.frame_pool: "bit cleared in\nframe_bitmap →\nframe allocated" {
  style: { stroke: "#33aa33"; font-color: "#55cc55"; font-size: 9 }
}
phys_frames.frame_pool.fr1 -> page_mapper: "physical frame\n0x001F4000\npassed to paging_map()\nas 'phys' arg" {
  style: { stroke: "#884444"; font-color: "#cc6666"; font-size: 9; stroke-dash: 3 }
}

# ─────────────────────────────────────────────────
# ANNOTATIONS — KEY INVARIANTS
# ─────────────────────────────────────────────────
invariants: ||md
  ### Key Invariants
  | # | Invariant | Violation Consequence |
  |---|-----------|----------------------|
  | 1 | Every committed heap page has exactly one physical frame in the bitmap marked **used** | Double allocation / UAF |
  | 2 | `invlpg` called after **every** PTE write | Stale TLB → Heisenbug |
  | 3 | `heap_brk` never decreases; pages are never unmapped while heap blocks exist | Dangling virtual pages |
  | 4 | `magic == 0xDEADBEEF` checked on every `kfree` | Buffer overrun detection |
  | 5 | TSS `ESP0` updated on context switch (M4) | Wrong kernel stack on IRQ |
|| {
  near: bottom-center
  style: {
    fill: "#111122"
    stroke: "#334455"
    font-color: "#aabbcc"
    font-size: 10
    border-radius: 4
  }
}