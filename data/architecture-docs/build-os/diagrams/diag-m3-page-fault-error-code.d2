vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |'md
  ## Page Fault (#14) — CR2 & Error Code Decoding
  **Protection Violation vs. Not-Present Fault**
'|
title.near: top-center

back_to_map: "↖ Satellite Map" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#2d2d2d"
    font-color: "#aaaaaa"
    font-size: 11
    border-radius: 4
    stroke: "#555555"
    stroke-width: 1
  }
}

# ─────────────────────────────────────────────
# SCENARIO A — Protection Violation (your trace)
# ─────────────────────────────────────────────
scenario_a: "SCENARIO A — Protection Violation  (P=1, U/S mismatch)" {
  link: "#page-fault-handler"
  style: {
    fill: "#1a0a0a"
    stroke: "#cc2200"
    stroke-width: 2
    border-radius: 6
    font-color: "#ff6644"
    bold: true
  }

  user_proc: "User Process (ring 3)\nCPL = 3\nEIP = 0x004001A0" {
    style: {
      fill: "#1c1c2e"
      stroke: "#6666cc"
      stroke-width: 2
      border-radius: 4
      font-color: "#aaaaff"
    }
  }

  bad_access: "MOV EAX, [0xC0100000]\n(kernel text — read attempt)" {
    style: {
      fill: "#2a0000"
      stroke: "#ff4444"
      stroke-width: 2
      border-radius: 3
      font-color: "#ff8888"
      italic: true
    }
  }

  mmu_walk: "MMU Hardware Walk" {
    style: {
      fill: "#0a1a2a"
      stroke: "#4488cc"
      stroke-width: 2
      border-radius: 4
      font-color: "#88bbff"
      bold: true
    }

    cr3_read: "Read CR3\n= 0x00004000\n(phys addr of Page Dir)" {
      style: { fill: "#0d1f33"; stroke: "#336699"; border-radius: 3; font-color: "#88ccff"; font-size: 12 }
    }

    pde_lookup: "PDE Lookup\nDir index = 0xC0100000 >> 22 = 768\nPD[768].present = 1  ✓\nPD[768].frame → PT @ 0x00005000" {
      style: { fill: "#0d1f33"; stroke: "#336699"; border-radius: 3; font-color: "#88ccff"; font-size: 12 }
    }

    pte_lookup: "PTE Lookup\nTable index = (0xC0100000 >> 12) & 0x3FF = 256\nPT[256].present = 1  ✓\nPT[256].U/S    = 0  ✗  ← SUPERVISOR ONLY\nPT[256].frame  = 0x00100 (phys 0x100000)" {
      style: {
        fill: "#2a0a00"
        stroke: "#cc4400"
        stroke-width: 2
        border-radius: 3
        font-color: "#ffaa44"
        font-size: 12
      }
    }

    pte_bits: |'md
      **PTE bit layout (32-bit):**
      | Bits  | Field    | Value | Meaning              |
      |-------|----------|-------|----------------------|
      | 31–12 | Frame    | 0x00100 | phys 0x100000      |
      | 8     | Global   | 1     | kernel global page   |
      | 3     | PWT      | 0     | write-back cache     |
      | 2     | **U/S**  | **0** | **Supervisor only ← FAULT** |
      | 1     | R/W      | 1     | read+write           |
      | 0     | Present  | 1     | page in RAM          |
    '|
    pte_bits.style: { fill: "#1a0800"; stroke: "#994400"; border-radius: 3; font-color: "#ffcc88"; font-size: 11 }

    cr3_read -> pde_lookup: "Step 1: index = virt >> 22"
    pde_lookup -> pte_lookup: "Step 2: index = (virt>>12)&0x3FF"
    pte_lookup -> pte_bits: "U/S=0 vs CPL=3\n→ PROTECTION FAULT"
  }

  cpu_fault_actions: "CPU Fault Actions (hardware, automatic)" {
    style: {
      fill: "#0a0a1a"
      stroke: "#8844cc"
      stroke-width: 2
      border-radius: 4
      font-color: "#cc88ff"
      bold: true
    }

    store_cr2: "CR2 ← 0xC0100000\n(faulting virtual address)" {
      style: { fill: "#1a0a2a"; stroke: "#7733bb"; border-radius: 3; font-color: "#cc88ff"; font-size: 12 }
    }

    build_errcode: "Build Error Code (32-bit value pushed on kernel stack)" {
      style: { fill: "#1a0a2a"; stroke: "#7733bb"; border-radius: 3; font-color: "#cc88ff"; font-size: 12 }
    }

    errcode_bits: |'md
      **Error Code — Scenario A value = 0x00000005**
      | Bit | Name | Value | Meaning                          |
      |-----|------|-------|----------------------------------|
      | 0   | **P**    | **1** | **Page WAS present** (prot. viol.) |
      | 1   | **W/R**  | **0** | **Read** access (not write)       |
      | 2   | **U/S**  | **1** | **User-mode** access (CPL=3)      |
      | 3   | RSVD | 0     | No reserved bit violation         |
      | 4   | I/D  | 0     | Data access (not instr. fetch)    |
      → **0b00000101 = 0x05**
    '|
    errcode_bits.style: {
      fill: "#200a00"
      stroke: "#cc4400"
      stroke-width: 2
      border-radius: 3
      font-color: "#ffaa66"
      font-size: 11
    }

    push_frame: "Push on kernel stack (TSS.ESP0):\n[SS_user][ESP_user][EFLAGS][CS=0x1B][EIP=0x004001A0]\n[Error Code = 0x00000005]" {
      style: { fill: "#1a0a2a"; stroke: "#7733bb"; border-radius: 3; font-color: "#cc88ff"; font-size: 11 }
    }

    jump_handler: "IDT[14] → isr_14\n→ isr_common_stub\n→ page_fault_handler(frame)" {
      style: { fill: "#0a1a0a"; stroke: "#338833"; border-radius: 3; font-color: "#88cc88"; font-size: 12 }
    }

    store_cr2 -> build_errcode
    build_errcode -> errcode_bits
    errcode_bits -> push_frame
    push_frame -> jump_handler
  }

  pf_handler_a: "page_fault_handler() — Scenario A Decision" {
    link: "#page-fault-handler"
    style: {
      fill: "#0a1a0a"
      stroke: "#338844"
      stroke-width: 2
      border-radius: 4
      font-color: "#88cc88"
      bold: true
    }

    read_cr2: "fault_addr = read_cr2()\n→ 0xC0100000" {
      style: { fill: "#0d2010"; stroke: "#335533"; border-radius: 3; font-color: "#aaffaa"; font-size: 12 }
    }

    decode: "Decode error code 0x05:\npresent = err & 1     → 1  (P=1)\nwrite   = (err>>1)&1  → 0  (read)\nuser    = (err>>2)&1  → 1  (ring 3)\nreserved= (err>>3)&1  → 0\nifetch  = (err>>4)&1  → 0" {
      style: { fill: "#0d2010"; stroke: "#335533"; border-radius: 3; font-color: "#aaffaa"; font-size: 12 }
    }

    decision_a: "present=1 + user=1 + write=0\n→ User tried to READ kernel page\n→ PROTECTION VIOLATION\n→ Kill process (SIGSEGV equivalent)" {
      style: {
        fill: "#2a0000"
        stroke: "#ff4444"
        stroke-width: 2
        border-radius: 3
        font-color: "#ff8888"
        bold: true
      }
    }

    read_cr2 -> decode: "CR2 = faulting address"
    decode -> decision_a: "P=1 + U=1 → not demand-page\n→ not COW → segfault"
  }

  user_proc -> bad_access: "Executes instruction\n(ring 3, CPL=3)"
  bad_access -> mmu_walk: "Virtual addr 0xC0100000\nhits MMU on memory bus"
  mmu_walk -> cpu_fault_actions: "U/S=0 while CPL=3\n→ #PF fired" {
    style: { stroke: "#ff4444"; stroke-width: 2; font-color: "#ff8888" }
  }
  cpu_fault_actions -> pf_handler_a: "Kernel takes control\n(ring 0, kernel stack)"
}

# ─────────────────────────────────────────────
# SCENARIO B — Not-Present Fault (demand paging)
# ─────────────────────────────────────────────
scenario_b: "SCENARIO B — Not-Present Fault (Demand Paging, P=0)" {
  link: "#page-fault-handler"
  style: {
    fill: "#0a1a0a"
    stroke: "#22aa44"
    stroke-width: 2
    border-radius: 6
    font-color: "#44cc77"
    bold: true
  }

  user_proc_b: "User Process (ring 3)\nCPL = 3\nEIP = 0x00401050" {
    style: {
      fill: "#1c1c2e"
      stroke: "#6666cc"
      stroke-width: 2
      border-radius: 4
      font-color: "#aaaaff"
    }
  }

  not_present_access: "MOV [0x00600000], EBX\n(first write to heap page\n— not yet mapped)" {
    style: {
      fill: "#001a00"
      stroke: "#44aa44"
      stroke-width: 2
      border-radius: 3
      font-color: "#88ee88"
      italic: true
    }
  }

  mmu_walk_b: "MMU Walk → PTE.present = 0\n(page table entry all-zeros)" {
    style: { fill: "#0a1a0a"; stroke: "#338844"; border-radius: 4; font-color: "#88cc88" }
  }

  errcode_b: |'md
    **Error Code — Scenario B value = 0x00000002**
    | Bit | Name   | Value | Meaning                        |
    |-----|--------|-------|--------------------------------|
    | 0   | **P**  | **0** | **Page NOT present** → demand pg |
    | 1   | **W/R**| **1** | **Write** access               |
    | 2   | **U/S**| **0** | **Kernel**-mode write (0x00600000 via kernel path) |
    → **0b00000010 = 0x02**
    *(If user-mode write: bit 2=1 → 0x06)*
  '|
  errcode_b.style: {
    fill: "#001a00"
    stroke: "#22aa44"
    stroke-width: 2
    border-radius: 3
    font-color: "#aaffaa"
    font-size: 11
  }

  pf_handler_b: "page_fault_handler() — Scenario B Decision" {
    link: "#page-fault-handler"
    style: {
      fill: "#0a1a0a"
      stroke: "#22aa44"
      stroke-width: 2
      border-radius: 4
      font-color: "#88cc88"
      bold: true
    }

    decode_b: "present = err & 1  → 0 (NOT PRESENT)\nwrite   = (err>>1)&1 → 1\nCR2 = 0x00600000" {
      style: { fill: "#0d2010"; stroke: "#335533"; border-radius: 3; font-color: "#aaffaa"; font-size: 12 }
    }

    demand_page: "present=0 + valid VMA range?\n→ YES: DEMAND PAGE\n1. pmm_alloc_frame()     → phys 0xXXXXX000\n2. paging_map(pd, 0x00600000,\n              phys, PTE_PRESENT|PTE_WRITABLE|PTE_USER)\n3. tlb_flush_page(0x00600000)\n4. return (iret re-executes faulting MOV)" {
      style: {
        fill: "#002a00"
        stroke: "#44dd44"
        stroke-width: 2
        border-radius: 3
        font-color: "#aaffaa"
        bold: true
        font-size: 11
      }
    }

    retry: "iret → ring 3\nCPU re-executes\nMOV [0x00600000], EBX\n→ SUCCEEDS ✓" {
      style: {
        fill: "#003300"
        stroke: "#00cc44"
        stroke-width: 2
        border-radius: 3
        font-color: "#00ff88"
        bold: true
      }
    }

    decode_b -> demand_page: "P=0 → allocate+map"
    demand_page -> retry: "page now present\n→ transparent to user"
  }

  user_proc_b -> not_present_access
  not_present_access -> mmu_walk_b: "MMU finds PTE.present=0\n→ #PF (no U/S check needed)"
  mmu_walk_b -> errcode_b: "CR2 ← 0x00600000\nerror code built"
  errcode_b -> pf_handler_b: "Kernel handler\ndecodes error"
}

# ─────────────────────────────────────────────
# COMPARISON TABLE
# ─────────────────────────────────────────────
comparison: |'md
  ## Error Code Bit Decoder — Quick Reference
  | Bit 0 (P) | Bit 1 (W/R) | Bit 2 (U/S) | Interpretation                    | Action                        |
  |-----------|-------------|-------------|-----------------------------------|-------------------------------|
  | **0**     | 0           | 0           | Kernel read unmapped page         | Kernel bug / panic            |
  | **0**     | 0           | 1           | User read unmapped page           | Demand-page if valid VMA      |
  | **0**     | 1           | 0           | Kernel write unmapped page        | Kernel bug / panic            |
  | **0**     | 1           | 1           | User write unmapped page          | Demand-page / COW if valid    |
  | **1**     | 0           | 0           | Kernel read protected page        | Kernel bug / panic            |
  | **1**     | 0           | **1**       | **User read kernel page ← Scenario A** | **SEGFAULT — kill process** |
  | **1**     | 1           | 1           | User write read-only page         | COW if shared, else SEGFAULT  |
  | —         | —           | —           | Bit 3=1: reserved PTE bit set     | Hardware/kernel corruption    |
  | —         | —           | —           | Bit 4=1: instruction fetch fault  | NX (No-Execute) violation     |
  **CR2** always holds the exact virtual address that caused the fault.
  Read CR2 immediately — it is overwritten by any subsequent fault.
'|
comparison.near: bottom-center
comparison.style: {
  fill: "#0d0d1a"
  stroke: "#555599"
  stroke-width: 1
  border-radius: 6
  font-color: "#ccccff"
  font-size: 11
}

# ─────────────────────────────────────────────
# TOP-LEVEL CONNECTIONS
# ─────────────────────────────────────────────
scenario_a -> scenario_b: "CONTRAST:\nSame #14 vector,\ndifferent error code\n→ different handler path" {
  style: {
    stroke: "#888888"
    stroke-dash: 5
    font-color: "#aaaaaa"
    font-size: 11
  }
}