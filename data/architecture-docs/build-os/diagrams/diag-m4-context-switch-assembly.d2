vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Context Switch â€” Register Save/Restore Trace
  **data_walk**: Instruction-by-instruction trace through `context_switch_asm`
  Blue = Old Process Stack Active Â· Green = New Process Stack Active Â· Red = Identity Swap Point
| {near: top-center}
back_to_map: "â†‘ Satellite Map" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#2d2d2d"
    font-color: "#ffffff"
    border-radius: 6
    font-size: 11
  }
}
# â”€â”€â”€ LEGEND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
legend: Legend {
  near: bottom-right
  style.fill: "#1e1e2e"
  style.stroke: "#555"
  style.border-radius: 6
  l_blue: "Blue border  = OLD process stack" {
    style.fill: "#0d2240"
    style.stroke: "#4a90d9"
    style.font-color: "#cce3ff"
    style.font-size: 11
  }
  l_green: "Green border = NEW process stack" {
    style.fill: "#0d2a10"
    style.stroke: "#4caf50"
    style.font-color: "#c8f0c8"
    style.font-size: 11
  }
  l_red: "Red          = Identity Swap (ESP pivot)" {
    style.fill: "#2a0d0d"
    style.stroke: "#f44336"
    style.font-color: "#ffcccc"
    style.font-size: 11
  }
  l_purple: "Purple       = PCB context field" {
    style.fill: "#1a0d2a"
    style.stroke: "#9c27b0"
    style.font-color: "#e8ccff"
    style.font-size: 11
  }
  l_yellow: "Yellow       = Instruction executed" {
    style.fill: "#2a2200"
    style.stroke: "#ffc107"
    style.font-color: "#fff3c0"
    style.font-size: 11
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 0 â€” CALL ENTRY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
phase0: "â‘  CALL ENTRY â€” timer IRQ fires, scheduler calls context_switch_asm" {
  style.fill: "#111122"
  style.stroke: "#4a90d9"
  style.stroke-width: 2
  style.border-radius: 8
  caller_note: |md
    
    ; C call from context_switch():
    ;   context_switch_asm(&old->context, &new->context)
    ; cdecl: args pushed right-to-left before CALL
    ; CALL itself pushes return EIP onto the stack
    
  | {style.fill: transparent; style.stroke: transparent}
  stack0: "OLD PROCESS Kernel Stack @ entry" {
    style.fill: "#0d2240"
    style.stroke: "#4a90d9"
    style.stroke-width: 2
    style.border-radius: 4
    s0_new_ctx: |md
      **[ESP+28]** `new_ctx*`  â† ptr to new PCB context
    | {style.fill: "#0a1a30"}
    s0_old_ctx: |md
      **[ESP+24]** `old_ctx*`  â† ptr to old PCB context
    | {style.fill: "#0a1a30"}
    s0_ret: |md
      **[ESP+20]** Return EIP  â† pushed by `CALL` instruction
    | {style.fill: "#102030"}
    s0_esp_marker: "â†‘ ESP points here at function entry" {
      style.fill: "#0d2240"
      style.stroke: "#4a90d9"
      style.stroke-dash: 4
      style.font-color: "#88aadd"
      style.font-size: 11
    }
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 1 â€” SAVE OLD PROCESS REGISTERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
phase1: "â‘¡ SAVE PHASE â€” push callee-saved registers onto OLD stack" {
  style.fill: "#111122"
  style.stroke: "#4a90d9"
  style.stroke-width: 2
  style.border-radius: 8
  instructions1: |md
    nasm
    push ebx      ; callee-saved (cdecl ABI)
    push esi      ; callee-saved
    push edi      ; callee-saved
    push ebp      ; frame pointer
    pushfd        ; EFLAGS â€” CRITICAL: saves IF (interrupt flag)
    
  | {
    style.fill: "#1a1500"
    style.stroke: "#ffc107"
    style.border-radius: 4
    style.font-size: 12
  }
  stack1: "OLD PROCESS Stack â€” after 5 pushes" {
    style.fill: "#0d2240"
    style.stroke: "#4a90d9"
    style.stroke-width: 2
    style.border-radius: 4
    s1_new_ctx: |md
      **[ESP+28]** `new_ctx*`
    | {style.fill: "#0a1a30"}
    s1_old_ctx: |md
      **[ESP+24]** `old_ctx*`
    | {style.fill: "#0a1a30"}
    s1_ret: |md
      **[ESP+20]** Return EIP
    | {style.fill: "#102030"}
    s1_ebx: |md
      **[ESP+16]** EBX  = 0x00000003
    | {style.fill: "#0f1f35"}
    s1_esi: |md
      **[ESP+12]** ESI  = 0xC0412800
    | {style.fill: "#0f1f35"}
    s1_edi: |md
      **[ESP+8]**  EDI  = 0x00000000
    | {style.fill: "#0f1f35"}
    s1_ebp: |md
      **[ESP+4]**  EBP  = 0xC0A03FE0
    | {style.fill: "#0f1f35"}
    s1_eflags: |md
      **[ESP+0]**  EFLAGS = 0x00000202  â† IF=1 (bit 9)
    | {style.fill: "#1a2a1a"; style.stroke: "#4caf50"; style.stroke-width: 1}
    s1_esp_marker: "â†‘ ESP here (ESPâ‚€âˆ’20 from entry)" {
      style.fill: "#0d2240"
      style.stroke: "#4a90d9"
      style.stroke-dash: 4
      style.font-color: "#88aadd"
      style.font-size: 11
    }
  }
  eflags_note: |md
    âš ï¸ **EFLAGS must be saved/restored correctly.**
    IF (bit 9) = 1 means interrupts enabled.
    If forgotten: new process runs with IRQs disabled forever â†’ system freeze.
    0x00000202 = bit9(IF)=1 + bit1(reserved)=1
  | {
    style.fill: "#2a2200"
    style.stroke: "#ffc107"
    style.border-radius: 4
    style.font-size: 11
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 2 â€” SAVE ESP TO OLD PCB
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
phase2: "â‘¢ SAVE OLD ESP â€” capture stack snapshot into old_ctxâ†’esp" {
  style.fill: "#111122"
  style.stroke: "#4a90d9"
  style.stroke-width: 2
  style.border-radius: 8
  instructions2: |md
    nasm
    mov eax, [esp+24]      ; EAX = old_ctx* (arg0, now at +24 after 5 pushes)
    mov [eax + 16], esp    ; old_ctx->esp = current ESP
    
  | {
    style.fill: "#1a1500"
    style.stroke: "#ffc107"
    style.border-radius: 4
    style.font-size: 12
  }
  old_pcb: "OLD PCB  cpu_context_t" {
    style.fill: "#1a0d2a"
    style.stroke: "#9c27b0"
    style.stroke-width: 2
    style.border-radius: 4
    pcb_edi:    "offset 0:  edi    (not stored â€” lives on stack)" {style.fill: "#120920"; style.font-color: "#888"}
    pcb_esi:    "offset 4:  esi    (not stored â€” lives on stack)" {style.fill: "#120920"; style.font-color: "#888"}
    pcb_ebx:    "offset 8:  ebx    (not stored â€” lives on stack)" {style.fill: "#120920"; style.font-color: "#888"}
    pcb_ebp:    "offset 12: ebp    (not stored â€” lives on stack)" {style.fill: "#120920"; style.font-color: "#888"}
    pcb_esp:    "offset 16: esp  â† WRITTEN NOW  = 0xC0A03F80" {style.fill: "#2a1040"; style.stroke: "#9c27b0"; style.font-color: "#e0aaff"}
    pcb_eip:    "offset 20: eip    (was Return EIP on stack)" {style.fill: "#120920"; style.font-color: "#888"}
    pcb_eflags: "offset 24: eflags (lives on stack as pushfd)" {style.fill: "#120920"; style.font-color: "#888"}
    pcb_note: |md
      The struct stores only ESP.
      All other registers live ON the stack
      pointed to by that ESP. This is the
      minimal representation â€” the stack
      IS the saved context.
    | {style.fill: "#1a0d2a"; style.stroke: transparent; style.font-size: 11; style.font-color: "#bb88ff"}
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 3 â€” THE IDENTITY SWAP (ESP PIVOT)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
phase3: "â‘£ â˜… IDENTITY SWAP â˜… â€” ESP changes: old process â†’ new process" {
  style.fill: "#2a0505"
  style.stroke: "#f44336"
  style.stroke-width: 4
  style.border-radius: 8
  swap_instruction: |md
    nasm
    mov eax, [esp+28]      ; EAX = new_ctx*  (arg1, at +28 after 5 pushes)
    mov esp, [eax + 16]    ; ESP = new_ctx->esp  â—„â”€â”€ PIVOT POINT
    
  | {
    style.fill: "#3a0808"
    style.stroke: "#f44336"
    style.stroke-width: 2
    style.border-radius: 4
    style.font-size: 12
  }
  swap_timeline: "Stack ownership timeline" {
    style.fill: "#200000"
    style.stroke: "#f44336"
    style.border-radius: 4
    before_swap: |md
      **Before `mov esp, [eax+16]`:**
      - ESP â†’ OLD process kernel stack
      - All pushes/pops touch OLD stack
      - CPU is logically "Process A"
    | {style.fill: "#2a0d0d"; style.font-color: "#ffaaaa"}
    after_swap: |md
      **After `mov esp, [eax+16]`:**
      - ESP â†’ NEW process kernel stack
      - All pushes/pops touch NEW stack
      - CPU is logically "Process B"
      - This single instruction IS the context switch
    | {style.fill: "#0d2a0d"; style.stroke: "#4caf50"; style.font-color: "#aaffaa"}
  }
  new_pcb: "NEW PCB  cpu_context_t" {
    style.fill: "#1a0d2a"
    style.stroke: "#9c27b0"
    style.stroke-width: 2
    style.border-radius: 4
    npcb_esp: "offset 16: esp = 0xC0B07F40  â† READ NOW (loaded into ESP)" {
      style.fill: "#2a1040"
      style.stroke: "#9c27b0"
      style.font-color: "#e0aaff"
    }
    npcb_note: |md
      This value was stored when
      Process B was last switched out.
      (Or fabricated by process_create
      for first-time scheduling.)
    | {style.fill: "#1a0d2a"; style.stroke: transparent; style.font-size: 11; style.font-color: "#bb88ff"}
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 4 â€” RESTORE NEW PROCESS REGISTERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
phase4: "â‘¤ RESTORE PHASE â€” pop from NEW process stack" {
  style.fill: "#0d1a0d"
  style.stroke: "#4caf50"
  style.stroke-width: 2
  style.border-radius: 8
  instructions4: |md
    nasm
    popfd         ; Restore new process EFLAGS â€” re-enables IRQs (IF=1)
    pop ebp       ; Restore new process EBP
    pop edi       ; Restore new process EDI
    pop esi       ; Restore new process ESI
    pop ebx       ; Restore new process EBX
    ret           ; POP new process EIP from stack â†’ resume at saved suspension point
    
  | {
    style.fill: "#0f2010"
    style.stroke: "#4caf50"
    style.border-radius: 4
    style.font-size: 12
  }
  stack4: "NEW PROCESS Kernel Stack â€” before pops" {
    style.fill: "#0d2a10"
    style.stroke: "#4caf50"
    style.stroke-width: 2
    style.border-radius: 4
    s4_ret_eip: |md
      **[ESP+20]** Return EIP  = 0xC010A234  â† `ret` will jump here
    | {style.fill: "#152a15"; style.stroke: "#4caf50"}
    s4_ebx: |md
      **[ESP+16]** EBX  = 0x00000007
    | {style.fill: "#0d2010"}
    s4_esi: |md
      **[ESP+12]** ESI  = 0xC0413000
    | {style.fill: "#0d2010"}
    s4_edi: |md
      **[ESP+8]**  EDI  = 0x00000001
    | {style.fill: "#0d2010"}
    s4_ebp: |md
      **[ESP+4]**  EBP  = 0xC0B07FE0
    | {style.fill: "#0d2010"}
    s4_eflags: |md
      **[ESP+0]**  EFLAGS = 0x00000202  â† `popfd` restores IF=1 (IRQs re-enabled)
    | {style.fill: "#152a15"; style.stroke: "#4caf50"; style.stroke-width: 1}
    s4_esp_marker: "â†‘ ESP = new_ctxâ†’esp (loaded in Phase 3)" {
      style.fill: "#0d2a10"
      style.stroke: "#4caf50"
      style.stroke-dash: 4
      style.font-color: "#88dd88"
      style.font-size: 11
    }
  }
  irq_note: |md
    ðŸ”‘ **`popfd` is the IRQ re-enable point.**
    EFLAGS.IF transitions from 0 (inside interrupt handler)
    to 1 (new process context) at this instruction.
    After this, the timer can preempt the new process.
  | {
    style.fill: "#0f2010"
    style.stroke: "#4caf50"
    style.border-radius: 4
    style.font-size: 11
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 5 â€” RET / RESUME
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
phase5: "â‘¥ RET â€” new process resumes at its saved EIP" {
  style.fill: "#0d1a0d"
  style.stroke: "#4caf50"
  style.stroke-width: 2
  style.border-radius: 8
  ret_note: |md
    nasm
    ret    ; POP EIP from NEW stack â†’ jump to 0xC010A234
    
    The `ret` pops the EIP that was pushed when Process B last called `context_switch_asm`.
    **For a brand-new process**, this is the *fabricated* entry address set by `process_create`:
    c
    *--stack = (uint32_t)entry_function;  // fabricated EIP
    
    Process B resumes exactly where it was suspended â€” it has no knowledge that any time passed.
  | {
    style.fill: "#0f2010"
    style.stroke: "#4caf50"
    style.border-radius: 4
    style.font-size: 12
  }
  resume_state: "CPU State After Return" {
    style.fill: "#0d2a10"
    style.stroke: "#4caf50"
    style.stroke-width: 2
    style.border-radius: 4
    rs_eip:    "EIP    = 0xC010A234  (Process B's suspension point)" {style.fill: "#152a15"}
    rs_esp:    "ESP    = 0xC0B07F58  (Process B's kernel stack, 5 words above saved frame)" {style.fill: "#152a15"}
    rs_ebp:    "EBP    = 0xC0B07FE0  (Process B's frame pointer)" {style.fill: "#0d2010"}
    rs_ebx:    "EBX    = 0x00000007  (Process B's general register)" {style.fill: "#0d2010"}
    rs_eflags: "EFLAGS = 0x00000202  IF=1 â†’ interrupts ENABLED" {style.fill: "#152a15"; style.stroke: "#4caf50"}
    rs_cr3:    "CR3    = Phys addr of Process B page dir (set before context_switch_asm)" {style.fill: "#1a2a1a"}
    rs_tss:    "TSS.ESP0 = Process B kernel_stack_top (set before context_switch_asm)" {style.fill: "#1a2a1a"}
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WHAT HAPPENS TO OLD PROCESS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
old_fate: "What happens to the OLD process (Process A)?" {
  style.fill: "#111122"
  style.stroke: "#4a90d9"
  style.stroke-width: 2
  style.border-radius: 8
  old_fate_note: |md
    Process A's state is completely preserved on its kernel stack.
    Its `cpu_context_t.esp` = 0xC0A03F80 points to the saved frame.
    **The next time the scheduler picks Process A:**
    `context_switch_asm` will load `esp = old_ctxâ†’esp = 0xC0A03F80`,
    then pop EFLAGS â†’ EBP â†’ EDI â†’ ESI â†’ EBX â†’ ret.
    Process A resumes at its Return EIP, believing `context_switch_asm` just returned.
    **From Process A's perspective:** `context_switch_asm` was called and returned
    normally (possibly thousands of timer ticks later). Zero observable side effects.
  | {
    style.fill: "#0d0d2a"
    style.stroke: "#4a90d9"
    style.border-radius: 4
    style.font-size: 12
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FULL INSTRUCTION TIMELINE (left rail)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
timeline: "Instruction Timeline" {
  style.fill: "#111111"
  style.stroke: "#555555"
  style.border-radius: 6
  t1:  "â‘  CALL context_switch_asm  â†’ pushes Return EIP" {style.fill: "#0d2240"; style.stroke: "#4a90d9"; style.font-size: 11}
  t2:  "â‘¡ push ebx                 â†’ save EBX [OLD stack]" {style.fill: "#0d2240"; style.stroke: "#4a90d9"; style.font-size: 11}
  t3:  "â‘¢ push esi                 â†’ save ESI [OLD stack]" {style.fill: "#0d2240"; style.stroke: "#4a90d9"; style.font-size: 11}
  t4:  "â‘£ push edi                 â†’ save EDI [OLD stack]" {style.fill: "#0d2240"; style.stroke: "#4a90d9"; style.font-size: 11}
  t5:  "â‘¤ push ebp                 â†’ save EBP [OLD stack]" {style.fill: "#0d2240"; style.stroke: "#4a90d9"; style.font-size: 11}
  t6:  "â‘¥ pushfd                  â†’ save EFLAGS [OLD stack]" {style.fill: "#0d2240"; style.stroke: "#4a90d9"; style.font-size: 11}
  t7:  "â‘¦ mov eax,[esp+24]        â†’ load old_ctx*" {style.fill: "#0d2240"; style.stroke: "#4a90d9"; style.font-size: 11}
  t8:  "â‘§ mov [eax+16],esp        â†’ SAVE OLD ESP into old_ctx" {style.fill: "#1a0d2a"; style.stroke: "#9c27b0"; style.font-size: 11}
  t9:  "â‘¨ mov eax,[esp+28]        â†’ load new_ctx*" {style.fill: "#2a0d0d"; style.stroke: "#f44336"; style.font-size: 11}
  t10: "â˜… mov esp,[eax+16]        â†’ LOAD NEW ESP â† IDENTITY SWAP" {style.fill: "#2a0505"; style.stroke: "#f44336"; style.stroke-width: 3; style.font-size: 11; style.bold: true}
  t11: "â‘ª popfd                   â†’ restore EFLAGS [NEW stack]" {style.fill: "#0d2a10"; style.stroke: "#4caf50"; style.font-size: 11}
  t12: "â‘« pop ebp                 â†’ restore EBP [NEW stack]" {style.fill: "#0d2a10"; style.stroke: "#4caf50"; style.font-size: 11}
  t13: "â‘¬ pop edi                 â†’ restore EDI [NEW stack]" {style.fill: "#0d2a10"; style.stroke: "#4caf50"; style.font-size: 11}
  t14: "â‘­ pop esi                 â†’ restore ESI [NEW stack]" {style.fill: "#0d2a10"; style.stroke: "#4caf50"; style.font-size: 11}
  t15: "â‘® pop ebx                 â†’ restore EBX [NEW stack]" {style.fill: "#0d2a10"; style.stroke: "#4caf50"; style.font-size: 11}
  t16: "â‘¯ ret                     â†’ POP new EIP â†’ resume Process B" {style.fill: "#0d2a10"; style.stroke: "#4caf50"; style.font-size: 11}
  t1 -> t2: "OLD stack" {style.stroke: "#4a90d9"; style.stroke-width: 2}
  t2 -> t3: "OLD stack" {style.stroke: "#4a90d9"; style.stroke-width: 2}
  t3 -> t4: "OLD stack" {style.stroke: "#4a90d9"; style.stroke-width: 2}
  t4 -> t5: "OLD stack" {style.stroke: "#4a90d9"; style.stroke-width: 2}
  t5 -> t6: "OLD stack" {style.stroke: "#4a90d9"; style.stroke-width: 2}
  t6 -> t7: "OLD stack" {style.stroke: "#4a90d9"; style.stroke-width: 2}
  t7 -> t8: "OLD stack" {style.stroke: "#4a90d9"; style.stroke-width: 2}
  t8 -> t9: "OLD stack" {style.stroke: "#4a90d9"; style.stroke-width: 2}
  t9 -> t10: "SWAP" {style.stroke: "#f44336"; style.stroke-width: 4; style.animated: true; style.font-color: "#f44336"}
  t10 -> t11: "NEW stack" {style.stroke: "#4caf50"; style.stroke-width: 2}
  t11 -> t12: "NEW stack" {style.stroke: "#4caf50"; style.stroke-width: 2}
  t12 -> t13: "NEW stack" {style.stroke: "#4caf50"; style.stroke-width: 2}
  t13 -> t14: "NEW stack" {style.stroke: "#4caf50"; style.stroke-width: 2}
  t14 -> t15: "NEW stack" {style.stroke: "#4caf50"; style.stroke-width: 2}
  t15 -> t16: "NEW stack â†’ ret" {style.stroke: "#4caf50"; style.stroke-width: 2}
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ARROWS: data flow between phases
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
phase0 -> phase1: "execute push Ã— 5" {
  style.stroke: "#4a90d9"
  style.stroke-width: 2
  style.animated: true
}
phase1 -> phase2: "save ESP â†’ PCB" {
  style.stroke: "#9c27b0"
  style.stroke-width: 2
}
phase2 -> phase3: "load new ESP (PIVOT)" {
  style.stroke: "#f44336"
  style.stroke-width: 4
  style.animated: true
}
phase3 -> phase4: "now on NEW stack" {
  style.stroke: "#4caf50"
  style.stroke-width: 2
  style.animated: true
}
phase4 -> phase5: "ret â†’ resume" {
  style.stroke: "#4caf50"
  style.stroke-width: 2
}
phase2 -> old_pcb: "mov [eax+16], esp\nwrites ESP here" {
  style.stroke: "#9c27b0"
  style.stroke-width: 2
  style.stroke-dash: 4
}
phase3 -> new_pcb: "mov esp, [eax+16]\nreads ESP from here" {
  style.stroke: "#f44336"
  style.stroke-width: 2
  style.stroke-dash: 4
}
phase5 -> old_fate: "old process fate" {
  style.stroke: "#4a90d9"
  style.stroke-dash: 5
}
back_to_map -> phase0: "entry point" {
  style.stroke: "#555"
  style.stroke-dash: 3
  style.font-size: 10
}