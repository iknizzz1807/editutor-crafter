vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Interrupt Enable/Disable â€” Critical Section During Context Switch
  **Danger Window:** nested timer interrupts mid-switch corrupt partially-saved state
| {near: top-center}
# â”€â”€â”€ COLOR LEGEND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
legend: {
  near: bottom-left
  label: ""
  style.fill: "#1a1a2e"
  style.stroke: "#444"
  style.border-radius: 8
  l1: |md
    ðŸ”´ **Red** = Danger / hot path
    ðŸŸ¢ **Green** = Safe / correct
    ðŸŸ¡ **Yellow** = Warning / caution
    ðŸ”µ **Blue** = Data flow
    ðŸŸ£ **Purple** = CPU hardware action
    â¬œ **Gray** = Padding / unused / disabled
  | {style.fill: "#1a1a2e"; style.font-color: "#ccc"}
}
# â”€â”€â”€ TIMELINE: Process A running in user mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
timeline: Timeline {
  style.fill: "#0d1117"
  style.stroke: "#30363d"
  style.border-radius: 10
  direction: down
  t0: |md
    **T=0ms  â€” Process A running (Ring 3, EFLAGS.IF=1)**
    `EAX=0x1234  EBX=0x5678  ESPâ†’user_stack  CS=0x1B`
  | {
    style.fill: "#1c3a1c"
    style.stroke: "#2ea043"
    style.font-color: "#7ee787"
    style.border-radius: 6
  }
  t1_irq: |md
    **T=10ms â€” PIT IRQ0 fires â†’ CPU asserts INTR**
    CPU checks: EFLAGS.IF=1 â†’ accept interrupt
    CPU auto-pushes: `SS, ESP, EFLAGS, CS, EIP` â†’ kernel stack (via TSS.ESP0)
    CPL 3â†’0 transition Â· loads IDT\[32\] handler address
  | {
    style.fill: "#3d2000"
    style.stroke: "#f85149"
    style.font-color: "#ffa657"
    style.border-radius: 6
  }
  t2_isr: |md
    **isr\_32 stub running (Ring 0)**
    `push 0`  â† fake error code
    `push 32` â† interrupt number
    `jmp isr_common_stub`
    `pusha`   â† saves EAX..EDI (8 regs Ã— 4B = **32 bytes**)
    EFLAGS.IF = **0** (interrupt gate cleared IF on entry)
  | {
    style.fill: "#1c2a3d"
    style.stroke: "#388bfd"
    style.font-color: "#79c0ff"
    style.border-radius: 6
  }
  t3_dispatch: |md
    **interrupt\_dispatch() â†’ timer\_handler() â†’ scheduler\_tick()**
    `tick_counter++`
    Finds next READY process (Process B)
    Sets oldâ†’READY, newâ†’RUNNING
    Calls `context_switch(procA, procB)`
  | {
    style.fill: "#1c2a3d"
    style.stroke: "#388bfd"
    style.font-color: "#79c0ff"
    style.border-radius: 6
  }
  t4_switch: context_switch() â€” THE CRITICAL SECTION {
    style.fill: "#1a0a0a"
    style.stroke: "#f85149"
    style.stroke-width: 3
    style.border-radius: 8
    cs1: |md
      **â‘  CR3 â† procBâ†’page\_directory (phys addr)**
      Address space switches to Process B's page tables
      TLB flush occurs (full CR3 reload)
    | {style.fill: "#2d1b00"; style.stroke: "#e3b341"; style.font-color: "#e3b341"; style.border-radius: 4}
    cs2: |md
      **â‘¡ TSS.ESP0 â† procBâ†’kernel\_stack\_top**
      MUST happen before next interrupt
      Wrong value â†’ next IRQ corrupts Process B's kernel stack
    | {style.fill: "#2d1b00"; style.stroke: "#e3b341"; style.font-color: "#e3b341"; style.border-radius: 4}
    cs3: |md
      **â‘¢ current\_process â† procB**
    | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#aaa"; style.border-radius: 4}
    cs4: context_switch_asm() ASSEMBLY CORE {
      style.fill: "#0d0d1a"
      style.stroke: "#bc8cff"
      style.stroke-width: 2
      style.border-radius: 6
      asm1: |md
        `push ebx` Â· `push esi` Â· `push edi` Â· `push ebp`
        `pushfd`
        â† 5 pushes onto **Process A's** kernel stack
        EFLAGS.IF = 0 here (still in interrupt, IF was cleared by gate)
      | {style.fill: "#1a0a2e"; style.stroke: "#bc8cff"; style.font-color: "#d2a8ff"; style.border-radius: 4}
      asm2: |md
        `mov [procAâ†’context.esp], esp`
        â† Saves Process A's ESP (stack with all regs on it)
        Process A is now fully suspended
      | {style.fill: "#1a0a2e"; style.stroke: "#bc8cff"; style.font-color: "#d2a8ff"; style.border-radius: 4}
      esp_swap: |md
        âš¡ `mov esp, [procBâ†’context.esp]`
        **THE IDENTITY SWAP â€” ESP now points to Process B's kernel stack**
        Before this: every push/pop = Process A's stack
        After this: every push/pop = Process B's stack
      | {
        style.fill: "#3d0000"
        style.stroke: "#f85149"
        style.stroke-width: 3
        style.font-color: "#ff7b72"
        style.bold: true
        style.border-radius: 4
      }
      asm3: |md
        `popfd`  â† restores Process B's EFLAGS
        **EFLAGS.IF must be 1 in saved state or B runs forever with IRQs off**
        `pop ebp` Â· `pop edi` Â· `pop esi` Â· `pop ebx`
        `ret`    â† pops Process B's saved EIP â†’ resumes B
      | {style.fill: "#0d200d"; style.stroke: "#2ea043"; style.font-color: "#7ee787"; style.border-radius: 4}
      asm1 -> asm2: "procA registers on stack"
      asm2 -> esp_swap: "procA ESP saved"
      esp_swap -> asm3: "NOW on procB stack"
    }
    cs1 -> cs2: "then update TSS"
    cs2 -> cs3: "then update current"
    cs3 -> cs4: "then swap registers"
  }
  t5_resume: |md
    **Process B resumes â€” `isr_common_stub` return path (if B was previously preempted)**
    `pop gs/fs/es/ds`  Â· `popa`  Â· `add esp, 8`
    `iretd` â†’ pops EIP, CS=0x1B, EFLAGS (IF=1), ESP, SS=0x23
    Process B runs in Ring 3 with interrupts enabled
  | {
    style.fill: "#1c3a1c"
    style.stroke: "#2ea043"
    style.font-color: "#7ee787"
    style.border-radius: 6
  }
  t0 -> t1_irq: "10ms elapses\nPIT counter=0, IRQ0 asserted" {
    style.stroke: "#f85149"
    style.stroke-width: 2
  }
  t1_irq -> t2_isr: "CPU auto-pushes 5 regs\nIF cleared by interrupt gate" {
    style.stroke: "#bc8cff"
    style.animated: true
  }
  t2_isr -> t3_dispatch: "call interrupt_dispatch(frame)" {
    style.stroke: "#388bfd"
  }
  t3_dispatch -> t4_switch: "context_switch(procA, procB)" {
    style.stroke: "#e3b341"
    style.stroke-width: 2
  }
  t4_switch -> t5_resume: "Process B EIP restored via ret+iretd" {
    style.stroke: "#2ea043"
    style.stroke-width: 2
  }
}
# â”€â”€â”€ DANGER SCENARIO: What if IF=1 during the critical section? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
danger: DANGER SCENARIO â€” Nested Interrupt Mid-Switch (IF=1 during switch) {
  style.fill: "#2d0000"
  style.stroke: "#f85149"
  style.stroke-width: 3
  style.border-radius: 8
  d1: |md
    **âŒ Bug: `sti` called too early (before ESP swap)**
    IF=1 while procA registers partially pushed but ESP not yet saved
  | {style.fill: "#3d0000"; style.stroke: "#f85149"; style.font-color: "#ff7b72"; style.border-radius: 4}
  d2: |md
    **Second timer IRQ fires mid-switch**
    CPU reads TSS.ESP0 (still points to procA kernel stack top)
    Pushes EFLAGS/CS/EIP *on top of* partially-saved procA context
  | {style.fill: "#3d0000"; style.stroke: "#f85149"; style.font-color: "#ff7b72"; style.border-radius: 4}
  d3: |md
    **Nested scheduler\_tick() runs**
    Tries to save "current process" registers â€” but stack is corrupted
    `procAâ†’context.esp` gets wrong value (offset by 12â€“20 bytes)
    ESP swap writes garbage address into procBâ†’context.esp
  | {style.fill: "#3d0000"; style.stroke: "#f85149"; style.font-color: "#ff7b72"; style.border-radius: 4}
  d4: |md
    **Result: Non-deterministic triple-fault**
    Next `context_switch_asm` `ret` jumps to garbage EIP
    Fault cascades: #GP â†’ #DF â†’ triple fault â†’ silent reboot
    Bug is *timing-dependent*: appears only at certain interrupt rates
  | {style.fill: "#5d0000"; style.stroke: "#f85149"; style.stroke-width: 2; style.font-color: "#ff7b72"; style.border-radius: 4}
  d1 -> d2: "IRQ fires during push sequence" {style.stroke: "#f85149"; style.animated: true}
  d2 -> d3: "nested scheduler corrupts stack" {style.stroke: "#f85149"; style.animated: true}
  d3 -> d4: "cascading fault" {style.stroke: "#f85149"; style.animated: true}
}
# â”€â”€â”€ IF FLAG EFLAGS STATE MACHINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eflags_states: EFLAGS.IF State Through the Transition {
  style.fill: "#0d1117"
  style.stroke: "#30363d"
  style.border-radius: 8
  s_user: |md
    **User mode running**
    EFLAGS.IF = **1**
    Interrupts enabled
    `0x00003202`
  | {style.fill: "#1c3a1c"; style.stroke: "#2ea043"; style.font-color: "#7ee787"; style.border-radius: 6}
  s_gate: |md
    **Interrupt gate entry**
    EFLAGS.IF â† **0** (hardware clears IF)
    Prevents nested interrupts automatically
    CPU: `EFLAGS &= ~0x200`
  | {style.fill: "#2d1b00"; style.stroke: "#e3b341"; style.font-color: "#e3b341"; style.border-radius: 6}
  s_pushfd: |md
    **`pushfd` in context\_switch\_asm**
    Saves EFLAGS with **IF=0** onto procA stack
    âœ… Correct: procA will restore this on re-entry
    (procA re-enters via isr\_common\_stub which does iretd,
    restoring the original user EFLAGS with IF=1)
  | {style.fill: "#1c2a3d"; style.stroke: "#388bfd"; style.font-color: "#79c0ff"; style.border-radius: 6}
  s_b_saved: |md
    **procB saved EFLAGS (from when B was last preempted)**
    Must have **IF=1** â€” set during fabrication:
    `*--stack = 0x00000202;`  â† bit 9 = IF
    If IF=0 here: procB runs forever, timer never fires, system freezes
  | {
    style.fill: "#1c3a1c"
    style.stroke: "#2ea043"
    style.stroke-width: 2
    style.font-color: "#7ee787"
    style.border-radius: 6
  }
  s_popfd: |md
    **`popfd` in context\_switch\_asm**
    Restores procB's EFLAGS â†’ **IF=1** re-enabled
    âš ï¸  After this instruction, next IRQ can fire
    Only `pop` + `ret` remain â€” safe window
  | {style.fill: "#1c3a1c"; style.stroke: "#2ea043"; style.font-color: "#7ee787"; style.border-radius: 6}
  s_user -> s_gate: "IRQ0 fires\nhardware clears IF" {style.stroke: "#f85149"; style.stroke-width: 2}
  s_gate -> s_pushfd: "context_switch_asm\npushfd (saves IF=0)" {style.stroke: "#388bfd"}
  s_pushfd -> s_b_saved: "ESP swap â€”\nnow on procB stack" {style.stroke: "#bc8cff"; style.stroke-width: 2}
  s_b_saved -> s_popfd: "popfd restores\nprocB EFLAGS (IF=1)" {style.stroke: "#2ea043"; style.stroke-width: 2}
}
# â”€â”€â”€ STACK LAYOUT COMPARISON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
stacks: Kernel Stack State at Each Phase {
  style.fill: "#0d1117"
  style.stroke: "#30363d"
  style.border-radius: 8
  direction: right
  stack_a: Process A Kernel Stack (after pusha + pushfd) {
    style.fill: "#1a1a2e"
    style.stroke: "#bc8cff"
    style.border-radius: 6
    a7: |md `[ESP+0 ]` EFLAGS (IF=0) â† **ESP here** | {style.fill: "#1a0a2e"; style.stroke: "#bc8cff"; style.font-color: "#d2a8ff"}
    a6: |md `[ESP+4 ]` EBP = 0       | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    a5: |md `[ESP+8 ]` EDI           | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    a4: |md `[ESP+12]` ESI           | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    a3: |md `[ESP+16]` EBX           | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    a2: |md `[ESP+20]` return EIP (into isr_common_stub) | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    a1: |md `[ESP+24]` old_ctx ptr (procA) | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    a0: |md `[ESP+28]` new_ctx ptr (procB) | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    # Below: isr_common_stub frame: int_no, err_code, EIP_user, CS_user, EFLAGS_user, ESP_user, SS_user
    a7 -> a6 -> a5 -> a4 -> a3 -> a2 -> a1 -> a0
  }
  stack_b: Process B Kernel Stack (fabricated initial frame) {
    style.fill: "#0d200d"
    style.stroke: "#2ea043"
    style.border-radius: 6
    b5: |md `[ESP+0 ]` EFLAGS = **0x00000202** (IF=1) â† **ESP loaded here** | {style.fill: "#0d200d"; style.stroke: "#2ea043"; style.font-color: "#7ee787"; style.bold: true}
    b4: |md `[ESP+4 ]` EBP = 0  (bottom of call chain)   | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    b3: |md `[ESP+8 ]` EDI = 0                            | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    b2: |md `[ESP+12]` ESI = 0                            | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    b1: |md `[ESP+16]` EBX = 0                            | {style.fill: "#1a1a2e"; style.stroke: "#555"; style.font-color: "#8b949e"}
    b0: |md `[ESP+20]` EIP = **entry\_function** (fabricated) | {style.fill: "#0d200d"; style.stroke: "#2ea043"; style.font-color: "#7ee787"; style.bold: true}
    b5 -> b4 -> b3 -> b2 -> b1 -> b0
  }
}
# â”€â”€â”€ GUARD CONDITIONS TABLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
guards: Guard Conditions â€” What Must Be True {
  style.fill: "#161b22"
  style.stroke: "#30363d"
  style.border-radius: 8
  g1: |md
    **BEFORE entering context\_switch\_asm**
    âœ… Interrupts already disabled (entered via interrupt gate, IF=0)
    âœ… CR3 updated to new process's page directory
    âœ… TSS.ESP0 updated to new process's kernel\_stack\_top
    âœ… current\_process pointer updated
  | {style.fill: "#1c3a1c"; style.stroke: "#2ea043"; style.font-color: "#7ee787"; style.border-radius: 4}
  g2: |md
    **DURING ESP swap**
    âœ… IF=0 â€” no interrupt can fire between pushfd and popfd
    âœ… New process's context.esp is valid (non-zero, in kernel heap range)
    âœ… New stack has correct frame: EFLAGS, EBP, EDI, ESI, EBX, EIP in order
  | {style.fill: "#1c3a1c"; style.stroke: "#2ea043"; style.font-color: "#7ee787"; style.border-radius: 4}
  g3: |md
    **AFTER popfd (new process)**
    âœ… EFLAGS.IF = 1 (from saved state; process runs with IRQs enabled)
    âœ… EBP, EDI, ESI, EBX correctly restored from new stack
    âœ… `ret` lands at valid EIP (first-time: entry\_fn; subsequent: isr\_common\_stub path)
  | {style.fill: "#1c3a1c"; style.stroke: "#2ea043"; style.font-color: "#7ee787"; style.border-radius: 4}
  g4: |md
    **CRITICAL: EFLAGS.IF=0 in procA's saved state is correct**
    procA was interrupted â†’ IF=0 on save
    procA will re-enter via isr\_common\_stub â†’ `iretd` restores original user EFLAGS (IF=1)
    **Never** manually force IF=1 in the pushfd'd EFLAGS on the kernel stack
  | {style.fill: "#2d1b00"; style.stroke: "#e3b341"; style.font-color: "#e3b341"; style.border-radius: 4}
  g1 -> g2: "enter asm stub" {style.stroke: "#2ea043"}
  g2 -> g3: "ESP swapped" {style.stroke: "#2ea043"}
  g3 -> g4: "verify saved state" {style.stroke: "#e3b341"}
}
# â”€â”€â”€ TOP-LEVEL CONNECTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
timeline -> danger: "if sti called prematurely\n(IF=1 during critical section)" {
  style.stroke: "#f85149"
  style.stroke-width: 2
  style.stroke-dash: 5
  style.font-color: "#f85149"
}
timeline -> eflags_states: "EFLAGS.IF trace through transition" {
  style.stroke: "#e3b341"
  style.stroke-dash: 3
}
timeline -> stacks: "stack layout at key moments" {
  style.stroke: "#bc8cff"
  style.stroke-dash: 3
}
timeline -> guards: "invariants that must hold" {
  style.stroke: "#2ea043"
  style.stroke-dash: 3
}