vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Per-Process Kernel Stack Layout During Context Switch
  **Microscopic view: P1 preempted, P2 running — TSS.ESP0 integrity**
| {near: top-center}

# ─────────────────────────────────────────────────────────────────
# COLOR SEMANTICS
#   Red    = danger / hot path / corruption zone
#   Green  = safe / current running process
#   Blue   = data flow / saved register values
#   Purple = metadata / CPU hardware structures
#   Yellow = caution / transition state
#   Gray   = unused / padding / guard
# ─────────────────────────────────────────────────────────────────

classes: {
  stack_cell: {
    shape: rectangle
    style: {
      font: mono
      font-size: 13
      border-radius: 2
    }
  }
  header: {
    shape: rectangle
    style: {
      bold: true
      font-size: 14
      border-radius: 4
    }
  }
  annotation: {
    shape: rectangle
    style: {
      stroke-dash: 5
      font-size: 12
      italic: true
      border-radius: 6
    }
  }
  arrow_label: {
    shape: rectangle
    style: {
      fill: transparent
      stroke: transparent
      font-size: 12
      bold: true
    }
  }
}

# ═══════════════════════════════════════════════════════════════
# P1 KERNEL STACK — PREEMPTED STATE (saved, cold, waiting)
# ═══════════════════════════════════════════════════════════════
p1_stack: "P1 Kernel Stack (8 KB)\nstate = PROCESS_READY (preempted)" {
  style: {
    fill: "#1a2a3a"
    stroke: "#4a90d9"
    stroke-width: 3
    border-radius: 8
    font-size: 14
    bold: true
    font-color: "#4a90d9"
  }

  p1_guard: "0x... +0000  [STACK GUARD PAGE — unmapped, P=0]" {
    class: stack_cell
    style: {
      fill: "#2d2d2d"
      stroke: "#555555"
      font-color: "#888888"
      stroke-dash: 4
    }
  }

  p1_unused: "0x... +0008  [ unused — grows downward ↑ ]" {
    class: stack_cell
    style: {
      fill: "#1e1e2e"
      stroke: "#333355"
      font-color: "#555577"
    }
  }

  p1_gap: "         . . . (unused kernel stack space ~7 KB) . . ." {
    class: stack_cell
    style: {
      fill: "#1e1e2e"
      stroke: "#333355"
      font-color: "#444466"
      stroke-dash: 6
    }
  }

  p1_user_ss: "ESP−20  user_ss  = 0x00000023  ← CPU pushed (ring3→0 xsition)" {
    class: stack_cell
    style: {
      fill: "#2a1a4a"
      stroke: "#8855cc"
      font-color: "#cc99ff"
    }
  }

  p1_user_esp: "ESP−16  user_esp = 0x00BFFFF0  ← CPU pushed (ring3→0 xsition)" {
    class: stack_cell
    style: {
      fill: "#2a1a4a"
      stroke: "#8855cc"
      font-color: "#cc99ff"
    }
  }

  p1_eflags: "ESP−12  EFLAGS   = 0x00000202  ← CPU pushed (IF=1 ✓)" {
    class: stack_cell
    style: {
      fill: "#1a3a2a"
      stroke: "#33aa66"
      font-color: "#88ffbb"
    }
  }

  p1_cs: "ESP−08  CS       = 0x0000001B  ← CPU pushed (ring3 code seg)" {
    class: stack_cell
    style: {
      fill: "#1a3a2a"
      stroke: "#33aa66"
      font-color: "#88ffbb"
    }
  }

  p1_eip: "ESP−04  EIP      = 0x00401234  ← CPU pushed (resume address ✓)" {
    class: stack_cell
    style: {
      fill: "#1a3a2a"
      stroke: "#55cc88"
      font-color: "#aaffcc"
      bold: true
    }
  }

  p1_vec_err: "ESP+00  vec=32 / err=0        ← pushed by IRQ stub" {
    class: stack_cell
    style: {
      fill: "#2a2a1a"
      stroke: "#aaaa33"
      font-color: "#dddd88"
    }
  }

  p1_gs: "ESP+04  GS=0x10 / FS=0x10        ← pushed by irq_common_stub" {
    class: stack_cell
    style: {
      fill: "#2a2a1a"
      stroke: "#aaaa33"
      font-color: "#dddd88"
    }
  }

  p1_es_ds: "ESP+08  ES=0x10 / DS=0x10        ← pushed by irq_common_stub" {
    class: stack_cell
    style: {
      fill: "#2a2a1a"
      stroke: "#aaaa33"
      font-color: "#dddd88"
    }
  }

  p1_pusha: |md
    ESP+0C  pusha block (32 bytes = 8 × 4B):
            EDI ESI EBP ESP EBX EDX ECX EAX
            saved general-purpose register state
  | {
    style: {
      fill: "#1a2a4a"
      stroke: "#4488cc"
      font-color: "#88bbff"
      font: mono
      border-radius: 4
    }
  }

  p1_ret_addr: "ESP+2C  ret_addr → irq_return_trampoline  ← context_switch ret target" {
    class: stack_cell
    style: {
      fill: "#3a1a1a"
      stroke: "#cc4444"
      font-color: "#ffaaaa"
      bold: true
    }
  }

  p1_stack_top_label: "↑ PCB.kernel_stack_top = 0xC010_8000  (stack base = top-8KB)" {
    class: stack_cell
    style: {
      fill: "#0a0a0a"
      stroke: "#666666"
      font-color: "#aaaaaa"
      stroke-dash: 3
      font-size: 11
    }
  }

  # Stack ordering (top to bottom = low to high addr in diagram)
  p1_stack_top_label -> p1_ret_addr: "grows ↓ (ESP decrements on push)" {
    style.stroke: "#666666"
    style.stroke-dash: 4
    target-arrowhead.shape: arrow
  }
  p1_ret_addr -> p1_pusha
  p1_pusha -> p1_es_ds
  p1_es_ds -> p1_gs
  p1_gs -> p1_vec_err
  p1_vec_err -> p1_eip
  p1_eip -> p1_cs
  p1_cs -> p1_eflags
  p1_eflags -> p1_user_esp
  p1_user_esp -> p1_user_ss
  p1_user_ss -> p1_gap
  p1_gap -> p1_unused
  p1_unused -> p1_guard
}

# ═══════════════════════════════════════════════════════════════
# P1 PCB (left of P1 stack)
# ═══════════════════════════════════════════════════════════════
p1_pcb: "PCB: process_t P1\nPID=1  state=PROCESS_READY" {
  style: {
    fill: "#0d1a2a"
    stroke: "#4a90d9"
    stroke-width: 2
    border-radius: 8
    font-color: "#4a90d9"
    font-size: 13
  }

  p1_pcb_pid: "pid             = 1" {
    class: stack_cell
    style.fill: "#0d1a2a"
    style.stroke: "#334455"
    style.font-color: "#8899aa"
  }
  p1_pcb_state: "state           = PROCESS_READY" {
    class: stack_cell
    style.fill: "#1a2a1a"
    style.stroke: "#334433"
    style.font-color: "#88aa88"
  }
  p1_pcb_ticks: "ticks_remaining = 0  (slice expired)" {
    class: stack_cell
    style.fill: "#2a1a1a"
    style.stroke: "#443333"
    style.font-color: "#aa8888"
  }
  p1_pcb_cpu_esp: "cpu.esp         = 0xC010_7FB4  ◄── SAVED KERNEL ESP" {
    class: stack_cell
    style: {
      fill: "#1a1a3a"
      stroke: "#4444cc"
      font-color: "#aaaaff"
      bold: true
    }
  }
  p1_pcb_cr3: "page_directory  = 0x0020_0000  (phys addr of PD)" {
    class: stack_cell
    style.fill: "#1a1a2a"
    style.stroke: "#333366"
    style.font-color: "#8888cc"
  }
  p1_pcb_kstop: "kernel_stack_top= 0xC010_8000" {
    class: stack_cell
    style.fill: "#0d1a2a"
    style.stroke: "#334455"
    style.font-color: "#8899aa"
  }
  p1_pcb_kstack: "kernel_stack[8192] @ 0xC010_6000" {
    class: stack_cell
    style.fill: "#0d1a2a"
    style.stroke: "#334455"
    style.font-color: "#8899aa"
  }
}

# ═══════════════════════════════════════════════════════════════
# P2 KERNEL STACK — RUNNING STATE (active, hot, TSS points here)
# ═══════════════════════════════════════════════════════════════
p2_stack: "P2 Kernel Stack (8 KB)\nstate = PROCESS_RUNNING ← current" {
  style: {
    fill: "#1a2a1a"
    stroke: "#44cc44"
    stroke-width: 4
    border-radius: 8
    font-size: 14
    bold: true
    font-color: "#44cc44"
  }

  p2_guard: "0x... +0000  [STACK GUARD PAGE — unmapped, P=0]" {
    class: stack_cell
    style: {
      fill: "#2d2d2d"
      stroke: "#555555"
      font-color: "#888888"
      stroke-dash: 4
    }
  }

  p2_unused: "0x... +0008  [ unused — grows downward ↑ ]" {
    class: stack_cell
    style: {
      fill: "#1e2e1e"
      stroke: "#335533"
      font-color: "#557755"
    }
  }

  p2_gap: "         . . . (unused kernel stack space, ~7.8 KB free) . . ." {
    class: stack_cell
    style: {
      fill: "#1e2e1e"
      stroke: "#335533"
      font-color: "#446644"
      stroke-dash: 6
    }
  }

  p2_live_note: |md
    ← P2 currently EXECUTING in kernel (inside sched_schedule / timer IRQ handler)
    ESP is somewhere here — actively being used, not yet saved to PCB
  | {
    style: {
      fill: "#223322"
      stroke: "#55aa55"
      font-color: "#aaffaa"
      font-size: 12
      stroke-dash: 3
      border-radius: 4
    }
  }

  p2_stack_top_label: "↑ PCB.kernel_stack_top = 0xC010_A000  (stack base = top-8KB)" {
    class: stack_cell
    style: {
      fill: "#0a0a0a"
      stroke: "#555555"
      font-color: "#aaaaaa"
      stroke-dash: 3
      font-size: 11
    }
  }

  p2_stack_top_label -> p2_live_note: "grows ↓" {
    style.stroke: "#666666"
    style.stroke-dash: 4
    target-arrowhead.shape: arrow
  }
  p2_live_note -> p2_gap
  p2_gap -> p2_unused
  p2_unused -> p2_guard
}

# ═══════════════════════════════════════════════════════════════
# P2 PCB
# ═══════════════════════════════════════════════════════════════
p2_pcb: "PCB: process_t P2\nPID=2  state=PROCESS_RUNNING" {
  style: {
    fill: "#0d1a0d"
    stroke: "#44cc44"
    stroke-width: 2
    border-radius: 8
    font-color: "#44cc44"
    font-size: 13
  }

  p2_pcb_pid: "pid             = 2" {
    class: stack_cell
    style.fill: "#0d1a0d"
    style.stroke: "#334433"
    style.font-color: "#88aa88"
  }
  p2_pcb_state: "state           = PROCESS_RUNNING" {
    class: stack_cell
    style.fill: "#1a3a1a"
    style.stroke: "#33aa33"
    style.font-color: "#88ff88"
    style.bold: true
  }
  p2_pcb_ticks: "ticks_remaining = 5  (fresh slice)" {
    class: stack_cell
    style.fill: "#1a2a1a"
    style.stroke: "#334433"
    style.font-color: "#aaffaa"
  }
  p2_pcb_cpu_esp: "cpu.esp         = 0xC010_9FC0  (last preempted pos)" {
    class: stack_cell
    style.fill: "#1a2a1a"
    style.stroke: "#335533"
    style.font-color: "#88aa88"
  }
  p2_pcb_cr3: "page_directory  = 0x0030_0000  (own address space)" {
    class: stack_cell
    style.fill: "#1a1a2a"
    style.stroke: "#333366"
    style.font-color: "#8888cc"
  }
  p2_pcb_kstop: "kernel_stack_top= 0xC010_A000  ◄── TSS.ESP0 points here" {
    class: stack_cell
    style: {
      fill: "#1a3a1a"
      stroke: "#33cc33"
      font-color: "#aaffaa"
      bold: true
    }
  }
  p2_pcb_kstack: "kernel_stack[8192] @ 0xC010_8000" {
    class: stack_cell
    style.fill: "#0d1a0d"
    style.stroke: "#334433"
    style.font-color: "#88aa88"
  }
}

# ═══════════════════════════════════════════════════════════════
# TSS HARDWARE STRUCTURE
# ═══════════════════════════════════════════════════════════════
tss: "TSS (Task State Segment)\nhardware-read on every ring3→ring0 transition" {
  style: {
    fill: "#2a1a3a"
    stroke: "#aa55ff"
    stroke-width: 3
    border-radius: 8
    font-color: "#cc88ff"
    font-size: 13
    bold: true
  }

  tss_prev: "prev_task  = 0x0000      (unused — no hw task switching)" {
    class: stack_cell
    style.fill: "#1a1a2a"
    style.stroke: "#333355"
    style.font-color: "#666688"
  }

  tss_esp0: "esp0       = 0xC010_A000  ◄── P2.kernel_stack_top  ★ CRITICAL ★" {
    class: stack_cell
    style: {
      fill: "#3a1a4a"
      stroke: "#cc44ff"
      font-color: "#ff99ff"
      bold: true
      font-size: 14
    }
  }

  tss_ss0: "ss0        = 0x0010       (kernel data segment selector)" {
    class: stack_cell
    style.fill: "#2a1a3a"
    style.stroke: "#553366"
    style.font-color: "#aa88cc"
  }

  tss_iomap: "iomap_base = 0x0068       (all I/O restricted to ring0)" {
    class: stack_cell
    style.fill: "#1a1a2a"
    style.stroke: "#333355"
    style.font-color: "#666688"
  }

  tss_note: |md
    CPU reads esp0 on EVERY interrupt/exception
    while ring-3 code is executing.
    Must be updated by tss_set_kernel_stack()
    before each context switch completes.
  | {
    style: {
      fill: "#1a0a2a"
      stroke: "#9933cc"
      font-color: "#cc88ff"
      font-size: 12
      stroke-dash: 3
      border-radius: 6
    }
  }
}

# ═══════════════════════════════════════════════════════════════
# CORRUPTION BUG PANEL — shared stack scenario
# ═══════════════════════════════════════════════════════════════
bug_panel: "⚠ THE BUG: Two Processes Sharing ONE Kernel Stack" {
  style: {
    fill: "#3a0a0a"
    stroke: "#ff2222"
    stroke-width: 3
    border-radius: 8
    font-color: "#ff4444"
    font-size: 14
    bold: true
  }

  bug_step1: "1. P1 is preempted → IRQ pushes frame onto shared stack @ ESP=0xC010_8F00" {
    class: stack_cell
    style.fill: "#2a0a0a"
    style.stroke: "#aa2222"
    style.font-color: "#ff8888"
  }
  bug_step2: "2. Scheduler runs P2 → P2 enters kernel, IRQ uses SAME stack (TSS.ESP0 unchanged)" {
    class: stack_cell
    style.fill: "#2a0a0a"
    style.stroke: "#aa2222"
    style.font-color: "#ff8888"
  }
  bug_step3: "3. P2's IRQ frame pushed @ ESP=0xC010_8EFC  ← OVERWRITES P1's saved EIP!" {
    class: stack_cell
    style: {
      fill: "#4a0a0a"
      stroke: "#ff3333"
      font-color: "#ffcccc"
      bold: true
    }
  }
  bug_step4: "4. P1 resumes from corrupted stack → iret pops wrong EIP/EFLAGS → GPF / triple fault" {
    class: stack_cell
    style: {
      fill: "#4a0a0a"
      stroke: "#ff3333"
      font-color: "#ffcccc"
      bold: true
    }
  }
  bug_fix: "✓ FIX: tss_set_kernel_stack(next→kernel_stack_top) before context_switch_asm()" {
    class: stack_cell
    style: {
      fill: "#0a2a0a"
      stroke: "#33aa33"
      font-color: "#88ff88"
      bold: true
    }
  }

  bug_step1 -> bug_step2 -> bug_step3 -> bug_step4 -> bug_fix
}

# ═══════════════════════════════════════════════════════════════
# CONTEXT SWITCH SEQUENCE ANNOTATION
# ═══════════════════════════════════════════════════════════════
switch_seq: "context_switch_asm() Sequence (P2→P1 switch next time)" {
  style: {
    fill: "#1a1a2a"
    stroke: "#4488cc"
    stroke-width: 2
    border-radius: 8
    font-color: "#88aaff"
    font-size: 13
    bold: true
  }

  seq1: "① old_esp = &P2→cpu.esp  → save current ESP into P2 PCB" {
    class: stack_cell
    style.fill: "#1a1a2a"
    style.stroke: "#334466"
    style.font-color: "#8899cc"
  }
  seq2: "② mov esp, P1→cpu.esp   → NOW ON P1's saved kernel stack" {
    class: stack_cell
    style: {
      fill: "#1a2a3a"
      stroke: "#3355aa"
      font-color: "#aabbff"
      bold: true
    }
  }
  seq3: "③ cmp/mov cr3, P1→page_directory  → flush TLB, new address space" {
    class: stack_cell
    style.fill: "#1a1a2a"
    style.stroke: "#334466"
    style.font-color: "#8899cc"
  }
  seq4: "④ ret  → pops irq_return_trampoline addr from P1's stack" {
    class: stack_cell
    style.fill: "#1a1a2a"
    style.stroke: "#334466"
    style.font-color: "#8899cc"
  }
  seq5: "⑤ irq_common_stub exit: pop gs/fs/es/ds → popa → add esp,8 → iret" {
    class: stack_cell
    style.fill: "#1a1a2a"
    style.stroke: "#334466"
    style.font-color: "#8899cc"
  }
  seq6: "⑥ iret pops EIP/CS/EFLAGS/ESP/SS from P1's stack → P1 resumes at 0x00401234" {
    class: stack_cell
    style: {
      fill: "#1a3a2a"
      stroke: "#338855"
      font-color: "#88ffbb"
      bold: true
    }
  }

  seq1 -> seq2 -> seq3 -> seq4 -> seq5 -> seq6
}

# ═══════════════════════════════════════════════════════════════
# CONNECTIONS / ARROWS
# ═══════════════════════════════════════════════════════════════

# P1 PCB → P1 stack: cpu.esp points to saved position
p1_pcb.p1_pcb_cpu_esp -> p1_stack.p1_ret_addr: "cpu.esp → top of P1's\nsaved register block\n(0xC010_7FB4)" {
  style: {
    stroke: "#4a90d9"
    stroke-width: 2
    stroke-dash: 3
    font-color: "#4a90d9"
    font-size: 11
  }
}

# P2 PCB → P2 stack: kernel_stack_top
p2_pcb.p2_pcb_kstop -> p2_stack.p2_stack_top_label: "kernel_stack_top\n= 0xC010_A000" {
  style: {
    stroke: "#44cc44"
    stroke-width: 2
    font-color: "#44cc44"
    font-size: 11
  }
}

# TSS.esp0 → P2 stack top (CORRECT — P2 is running)
tss.tss_esp0 -> p2_stack.p2_stack_top_label: "TSS.ESP0 = P2.kernel_stack_top\n★ CPU reads this on next IRQ\nwhile P2 is in ring3" {
  style: {
    stroke: "#cc44ff"
    stroke-width: 3
    font-color: "#ee88ff"
    font-size: 12
    bold: true
    animated: true
  }
  target-arrowhead: * {
    shape: arrow
  }
}

# tss_set_kernel_stack call arrow
p2_pcb.p2_pcb_kstop -> tss.tss_esp0: "tss_set_kernel_stack(\n  next→kernel_stack_top\n)\ncalled by sched_schedule()\nBEFORE context_switch_asm()" {
  style: {
    stroke: "#ffaa00"
    stroke-width: 2
    stroke-dash: 5
    font-color: "#ffcc44"
    font-size: 11
  }
  target-arrowhead: * {
    shape: diamond
    style.filled: true
  }
}

# Bug panel: wrong TSS scenario
tss.tss_esp0 -> bug_panel.bug_step2: "if TSS.ESP0 still = P1.stack_top\nwhen P2 runs → BUG PATH" {
  style: {
    stroke: "#ff3333"
    stroke-width: 2
    stroke-dash: 8
    font-color: "#ff6666"
    font-size: 11
  }
  target-arrowhead: * {
    shape: arrow
  }
}

# P1 stack EIP → resume point annotation
p1_stack.p1_eip -> switch_seq.seq6: "iret will restore this EIP\n→ P1 resumes in user code" {
  style: {
    stroke: "#55cc88"
    stroke-width: 2
    stroke-dash: 4
    font-color: "#88ffcc"
    font-size: 11
  }
}

# context switch sequence drives the stack pivot
switch_seq.seq2 -> p1_stack.p1_pusha: "mov esp, P1→cpu.esp\n→ now reading P1's saved regs" {
  style: {
    stroke: "#4488cc"
    stroke-width: 2
    font-color: "#88aaff"
    font-size: 11
  }
  target-arrowhead: * {
    shape: arrow
  }
}

# scale indicators
scale1: "← 4 bytes per stack cell (uint32_t)\n   One cache line = 64 bytes = 16 cells" {
  style: {
    fill: "#0f0f0f"
    stroke: "#333333"
    font-color: "#666666"
    font-size: 11
    italic: true
    border-radius: 4
  }
}

scale2: "Each kernel stack = 8 KB = 2 physical pages\nAllocated via kmalloc() / static PCB array" {
  style: {
    fill: "#0f0f0f"
    stroke: "#333333"
    font-color: "#666666"
    font-size: 11
    italic: true
    border-radius: 4
  }
}