vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: right
# ── Navigation ──────────────────────────────────────────────────────────────
nav: "↑ Back to Satellite Map" {
  link: "#diag-satellite-os-map"
  style: {
    fill: "#1a1a2e"
    stroke: "#4a9eff"
    font-color: "#4a9eff"
    font-size: 11
    border-radius: 4
  }
}
# ── Legend ───────────────────────────────────────────────────────────────────
legend: {
  near: bottom-right
  label: "Legend"
  style: {
    fill: "#0d0d1a"
    stroke: "#333355"
    border-radius: 6
    font-size: 11
    font-color: "#aaaacc"
  }
  hw_save: "⬛  Saved by HARDWARE (CPU on interrupt entry)" {
    shape: text
    style.font-color: "#ff6b6b"
    style.font-size: 11
  }
  sw_save: "⬛  Saved by SOFTWARE (context_switch_asm)" {
    shape: text
    style.font-color: "#4ecdc4"
    style.font-size: 11
  }
  meta: "⬛  Kernel metadata (never restored to CPU)" {
    shape: text
    style.font-color: "#a29bfe"
    style.font-size: 11
  }
  cache: "⬛  Cache-line boundary" {
    shape: text
    style.font-color: "#ffd93d"
    style.font-size: 11
  }
}
# ── Title ────────────────────────────────────────────────────────────────────
title: |md
  ## `process_t` PCB — Byte-Level Structure Layout
  **Milestone 4 · process.h** · Total size: 112 bytes (2 cache lines)
| {
  near: top-center
  style: {
    font-size: 14
    font-color: "#e0e0ff"
  }
}
# ── Main struct layout ───────────────────────────────────────────────────────
pcb: process_t {
  link: "#build-os-m4"
  style: {
    fill: "#0d0d1a"
    stroke: "#4a9eff"
    stroke-width: 2
    border-radius: 8
    font-color: "#e0e0ff"
    font-size: 13
    bold: true
  }
  # ── Cache Line 0 : 0x00 – 0x3F (64 bytes) ─────────────────────────────
  cl0: "CACHE LINE 0   [0x00 – 0x3F]   64 bytes" {
    style: {
      fill: "#0a1628"
      stroke: "#ffd93d"
      stroke-width: 2
      stroke-dash: 4
      border-radius: 4
      font-color: "#ffd93d"
      font-size: 11
      bold: true
    }
    f_pid: |md
      **+0x00** `uint32_t pid`
      4 bytes · Process ID
      Monotonically increasing counter
      _Never written after creation_
    | {
      style: {
        fill: "#1a0a3e"
        stroke: "#a29bfe"
        stroke-width: 1
        border-radius: 3
        font-size: 11
      }
    }
    f_state: |md
      **+0x04** `process_state_t state`
      4 bytes · Scheduler state enum
      READY=0 · RUNNING=1
      BLOCKED=2 · DEAD=3
    | {
      style: {
        fill: "#1a0a3e"
        stroke: "#a29bfe"
        stroke-width: 1
        border-radius: 3
        font-size: 11
      }
    }
    f_name: |md
      **+0x08** `char name[32]`
      32 bytes · Debug label
      e.g. "proc_a\0…"
      _Metadata only — never in CPU_
    | {
      style: {
        fill: "#1a0a3e"
        stroke: "#a29bfe"
        stroke-width: 1
        border-radius: 3
        font-size: 11
      }
    }
    f_pid -> f_state: "+4" {
      style: { stroke: "#555577"; font-size: 10 }
    }
    f_state -> f_name: "+4" {
      style: { stroke: "#555577"; font-size: 10 }
    }
  }
  # ── Cache Line 1 : 0x40 – 0x7F (64 bytes) ─────────────────────────────
  cl1: "CACHE LINE 1   [0x28 – 0x6F]   64 bytes  ← HOT during context switch" {
    style: {
      fill: "#0a2818"
      stroke: "#ffd93d"
      stroke-width: 2
      stroke-dash: 4
      border-radius: 4
      font-color: "#ffd93d"
      font-size: 11
      bold: true
    }
    # ── cpu_context_t sub-struct ─────────────────────────────────────
    ctx: cpu_context_t {
      style: {
        fill: "#0a1e0a"
        stroke: "#4ecdc4"
        stroke-width: 2
        border-radius: 4
        font-color: "#4ecdc4"
        font-size: 12
        bold: true
      }
      f_edi: |md
        **+0x28** `uint32_t edi`
        4 bytes
        push edi / pop edi
        _SW save — callee saved_
      | {
        style: {
          fill: "#0a2a1a"
          stroke: "#4ecdc4"
          border-radius: 3
          font-size: 11
        }
      }
      f_esi: |md
        **+0x2C** `uint32_t esi`
        4 bytes
        push esi / pop esi
        _SW save — callee saved_
      | {
        style: {
          fill: "#0a2a1a"
          stroke: "#4ecdc4"
          border-radius: 3
          font-size: 11
        }
      }
      f_ebx: |md
        **+0x30** `uint32_t ebx`
        4 bytes
        push ebx / pop ebx
        _SW save — callee saved_
      | {
        style: {
          fill: "#0a2a1a"
          stroke: "#4ecdc4"
          border-radius: 3
          font-size: 11
        }
      }
      f_ebp: |md
        **+0x34** `uint32_t ebp`
        4 bytes
        push ebp / pop ebp
        _SW save — frame ptr_
      | {
        style: {
          fill: "#0a2a1a"
          stroke: "#4ecdc4"
          border-radius: 3
          font-size: 11
        }
      }
      f_esp: |md
        **+0x38** `uint32_t esp`
        4 bytes · ★ THE PIVOT ★
        mov [ctx+16], esp
        _SW save — stack pointer_
      | {
        style: {
          fill: "#1a3a0a"
          stroke: "#00ff88"
          stroke-width: 2
          border-radius: 3
          font-size: 11
          font-color: "#00ff88"
          bold: true
        }
      }
      f_eip: |md
        **+0x3C** `uint32_t eip`
        4 bytes
        ret → pops this
        _SW save — resume addr_
      | {
        style: {
          fill: "#0a2a1a"
          stroke: "#4ecdc4"
          border-radius: 3
          font-size: 11
        }
      }
      f_eflags: |md
        **+0x40** `uint32_t eflags`
        4 bytes · bit 9 = IF
        pushfd / popfd
        _SW save — must have IF=1_
      | {
        style: {
          fill: "#2a1a0a"
          stroke: "#ff9f43"
          border-radius: 3
          font-size: 11
        }
      }
      f_edi -> f_esi: "+4"  { style: { stroke: "#4ecdc4"; font-size: 10 } }
      f_esi -> f_ebx: "+4"  { style: { stroke: "#4ecdc4"; font-size: 10 } }
      f_ebx -> f_ebp: "+4"  { style: { stroke: "#4ecdc4"; font-size: 10 } }
      f_ebp -> f_esp: "+4"  { style: { stroke: "#00ff88"; stroke-width: 2; font-size: 10 } }
      f_esp -> f_eip: "+4"  { style: { stroke: "#4ecdc4"; font-size: 10 } }
      f_eip -> f_eflags: "+4" { style: { stroke: "#ff9f43"; font-size: 10 } }
    }
    # ── HW-saved registers on interrupt ─────────────────────────────
    hw_saved: "HW-pushed on IRQ entry (on kernel stack, NOT in PCB fields)" {
      style: {
        fill: "#280a0a"
        stroke: "#ff6b6b"
        stroke-width: 2
        border-radius: 4
        font-color: "#ff6b6b"
        font-size: 11
        bold: true
      }
      f_hw_eip: |md
        _kernel stack_ `EIP`
        Interrupted instr addr
        CPU pushes automatically
        _HW save — ring 3→0_
      | {
        style: {
          fill: "#380a0a"
          stroke: "#ff6b6b"
          border-radius: 3
          font-size: 11
          stroke-dash: 3
        }
      }
      f_hw_cs: |md
        _kernel stack_ `CS`
        0x1B = user code seg
        CPU pushes automatically
        _HW save_
      | {
        style: {
          fill: "#380a0a"
          stroke: "#ff6b6b"
          border-radius: 3
          font-size: 11
          stroke-dash: 3
        }
      }
      f_hw_eflags: |md
        _kernel stack_ `EFLAGS`
        User IF state preserved
        CPU pushes automatically
        _HW save_
      | {
        style: {
          fill: "#380a0a"
          stroke: "#ff6b6b"
          border-radius: 3
          font-size: 11
          stroke-dash: 3
        }
      }
      f_hw_esp: |md
        _kernel stack_ `ESP_user`
        User stack pointer
        CPU pushes (ring change)
        _HW save — privilege chg_
      | {
        style: {
          fill: "#380a0a"
          stroke: "#ff6b6b"
          border-radius: 3
          font-size: 11
          stroke-dash: 3
        }
      }
      f_hw_ss: |md
        _kernel stack_ `SS_user`
        0x23 = user data seg
        CPU pushes (ring change)
        _HW save — privilege chg_
      | {
        style: {
          fill: "#380a0a"
          stroke: "#ff6b6b"
          border-radius: 3
          font-size: 11
          stroke-dash: 3
        }
      }
    }
    # ── Memory management ────────────────────────────────────────────
    f_pd: |md
      **+0x44** `uint32_t *page_directory`
      4 bytes · **PHYSICAL** address
      Written to CR3 on switch
      _Metadata — kernel only_
    | {
      style: {
        fill: "#1a0a3e"
        stroke: "#a29bfe"
        border-radius: 3
        font-size: 11
      }
    }
    f_kstop: |md
      **+0x48** `uint32_t kernel_stack_top`
      4 bytes · Initial stack top
      Written to TSS.ESP0
      _MUST update before iret_
    | {
      style: {
        fill: "#2a0a2a"
        stroke: "#fd79a8"
        border-radius: 3
        font-size: 11
      }
    }
    f_kstack: |md
      **+0x4C** `uint8_t *kernel_stack`
      4 bytes · kmalloc base ptr
      8KB allocation
      _Metadata — alloc tracking_
    | {
      style: {
        fill: "#1a0a3e"
        stroke: "#a29bfe"
        border-radius: 3
        font-size: 11
      }
    }
    f_uesp: |md
      **+0x50** `uint32_t user_esp`
      4 bytes · User stack ptr
      Saved in isr_common_stub
      _Ring-3 processes only_
    | {
      style: {
        fill: "#1a0a3e"
        stroke: "#a29bfe"
        border-radius: 3
        font-size: 11
      }
    }
    f_ticks: |md
      **+0x54** `uint32_t total_ticks`
      4 bytes · CPU accounting
      Incremented in timer ISR
      _Scheduler metadata_
    | {
      style: {
        fill: "#1a0a3e"
        stroke: "#a29bfe"
        border-radius: 3
        font-size: 11
      }
    }
    f_next: |md
      **+0x58** `struct process *next`
      4 bytes · Ready-queue link
      Circular singly-linked list
      _Scheduler metadata_
    | {
      style: {
        fill: "#1a1a3e"
        stroke: "#6c5ce7"
        border-radius: 3
        font-size: 11
      }
    }
    f_pad: |md
      **+0x5C** _padding / reserved_
      4 bytes · Align to 64B
      Total struct = 0x60 = 96 B
      _(or more with name[32])_
    | {
      style: {
        fill: "#111111"
        stroke: "#333333"
        font-color: "#555555"
        border-radius: 3
        font-size: 11
        stroke-dash: 5
      }
    }
  }
}
# ── Context switch assembly annotation ──────────────────────────────────────
asm_box: context_switch_asm {
  link: "#build-os-m4"
  style: {
    fill: "#0a1e0a"
    stroke: "#4ecdc4"
    stroke-width: 2
    border-radius: 6
    font-color: "#4ecdc4"
    font-size: 12
    bold: true
  }
  asm_code: |asm
    ; SAVE old process (push onto old kernel stack)
    push ebx        ; +0x30 in ctx
    push esi        ; +0x2C
    push edi        ; +0x28
    push ebp        ; +0x34
    pushfd          ; +0x40  ← bit9=IF critical!
    mov [old_ctx+16], esp   ; ctx.esp ← old ESP
    ; ── IDENTITY SWAP ──────────────────────────
    mov esp, [new_ctx+16]   ; ESP ← new ctx.esp
    ; ↑ We are now on the NEW process's stack
    ; RESTORE new process (pop from new kernel stack)
    popfd           ; restore EFLAGS (IF re-enabled here)
    pop ebp
    pop edi
    pop esi
    pop ebx
    ret             ; pops EIP → resumes new process
  | {
    style: {
      fill: "#061206"
      stroke: "#4ecdc4"
      border-radius: 4
      font-size: 11
    }
  }
  pivot_note: |md
    **★ Identity swap at `mov esp, [new_ctx+16]`**
    Before: ESP on Process A's kernel stack
    After: ESP on Process B's kernel stack
    The function begins as A, returns as B.
  | {
    style: {
      fill: "#0a280a"
      stroke: "#00ff88"
      stroke-width: 2
      border-radius: 4
      font-size: 11
      font-color: "#00ff88"
    }
  }
}
# ── TSS relationship ─────────────────────────────────────────────────────────
tss_box: "TSS (Task State Segment)" {
  link: "#build-os-m4"
  style: {
    fill: "#1e0a28"
    stroke: "#fd79a8"
    stroke-width: 2
    border-radius: 6
    font-color: "#fd79a8"
    font-size: 12
    bold: true
  }
  tss_esp0: |md
    **TSS.ESP0** (+0x04 in TSS)
    uint32_t — kernel stack top
    CPU reads this on EVERY
    ring-3 → ring-0 transition
    ← must match `kernel_stack_top`
  | {
    style: {
      fill: "#2e0a3e"
      stroke: "#fd79a8"
      border-radius: 3
      font-size: 11
    }
  }
  tss_ss0: |md
    **TSS.SS0** (+0x08 in TSS)
    uint16_t = 0x10
    Kernel data segment selector
    Set once in tss_init()
    Never changes
  | {
    style: {
      fill: "#2e0a3e"
      stroke: "#fd79a8"
      border-radius: 3
      font-size: 11
    }
  }
  tss_iomap: |md
    **TSS.IOMAP_BASE** (+0x66)
    uint16_t = sizeof(tss_t)
    No I/O from ring 3 by default
    (in/out instructions → #GP)
  | {
    style: {
      fill: "#2e0a3e"
      stroke: "#fd79a8"
      border-radius: 3
      font-size: 11
    }
  }
}
# ── Cache line analysis panel ────────────────────────────────────────────────
cache_analysis: "Cache Line Analysis (64-byte lines)" {
  style: {
    fill: "#1a1a0a"
    stroke: "#ffd93d"
    stroke-width: 2
    border-radius: 6
    font-color: "#ffd93d"
    font-size: 12
    bold: true
  }
  cl0_note: |md
    **Cache Line 0** [+0x00 – +0x3F]
    pid(4) + state(4) + name(32) +
    _padding(24)_
    → Metadata: read at creation &
      scheduler decisions only.
    **Cold during context switch.**
  | {
    style: {
      fill: "#1a1a06"
      stroke: "#ffd93d"
      border-radius: 3
      font-size: 11
    }
  }
  cl1_note: |md
    **Cache Line 1** [+0x28 – +0x67]
    cpu_context_t(28B) + page_dir(4)
    + kstack_top(4) + kstack(4) +
    user_esp(4) + total_ticks(4) +
    next(4) + pad(4) = 56 bytes
    **HOT: touched on every switch.**
    → Keep cpu_context_t at CL1 start.
  | {
    style: {
      fill: "#2a2a06"
      stroke: "#ffd93d"
      border-radius: 3
      font-size: 11
    }
  }
  cl_verdict: |md
    **Verdict: 2 cache lines total.**
    Critical path (cpu_context_t +
    page_dir + kstack_top) = 36 bytes
    → fits in **single** cache line.
    Typical L1 hit: ~4 cycles.
    L1 miss (cold): ~200 cycles.
    ∴ align PCB to 64B for best perf.
  | {
    style: {
      fill: "#0a1a06"
      stroke: "#00ff88"
      stroke-width: 2
      border-radius: 3
      font-size: 11
      font-color: "#00ff88"
    }
  }
}
# ── Fabricated initial stack panel ───────────────────────────────────────────
initial_stack: "process_create() — Fabricated Kernel Stack" {
  style: {
    fill: "#0a0a1e"
    stroke: "#6c5ce7"
    stroke-width: 2
    border-radius: 6
    font-color: "#6c5ce7"
    font-size: 12
    bold: true
  }
  istack_note: |md
    Stack grows ↓ from `kernel_stack_top`
    
    [top - 4]  0x00000202   ← EFLAGS  (IF=1 !)
    [top - 8]  0x00000000   ← EBP = 0 (backtrace sentinel)
    [top -12]  0x00000000   ← EDI = 0
    [top -16]  0x00000000   ← ESI = 0
    [top -20]  0x00000000   ← EBX = 0
    [top -24]  entry_func   ← EIP  ← ret pops this
    
    ctx.esp = top - 24
    First context_switch_asm restore:
    popfd → EBP → EDI → ESI → EBX → ret
    ret pops entry_func → process starts!
  | {
    style: {
      fill: "#060620"
      stroke: "#6c5ce7"
      border-radius: 4
      font-size: 11
      font-color: "#c0b0ff"
    }
  }
  eflags_warn: |md
    ⚠ EFLAGS bit 9 (IF) MUST = 1
    If IF=0: process runs forever
    with interrupts disabled —
    scheduler never preempts it.
    Symptom: first process runs,
    nothing else ever executes.
  | {
    style: {
      fill: "#2a0a0a"
      stroke: "#ff6b6b"
      stroke-width: 2
      border-radius: 4
      font-size: 11
      font-color: "#ff9999"
    }
  }
}
# ── Connections ──────────────────────────────────────────────────────────────
# PCB → context switch
pcb.cl1.ctx -> asm_box.asm_code: "cpu_context_t\nread/written\nby context_switch_asm" {
  style: {
    stroke: "#4ecdc4"
    stroke-width: 2
    animated: true
    font-size: 11
    font-color: "#4ecdc4"
  }
}
# PCB.kernel_stack_top → TSS
pcb.cl1.f_kstop -> tss_box.tss_esp0: "tss_set_kernel_stack(p->kernel_stack_top)\nCALL ON EVERY SWITCH" {
  style: {
    stroke: "#fd79a8"
    stroke-width: 2
    animated: true
    font-size: 11
    font-color: "#fd79a8"
  }
}
# TSS → CPU (conceptual — hardware reads)
tss_box.tss_esp0 -> pcb.cl1.hw_saved: "CPU reads ESP0 on IRQ\n(ring 3→0 transition)\nautomatic, every interrupt" {
  style: {
    stroke: "#ff6b6b"
    stroke-width: 2
    stroke-dash: 4
    font-size: 11
    font-color: "#ff6b6b"
  }
}
# PCB.page_directory → CR3
pcb.cl1.f_pd -> asm_box.pivot_note: "mov cr3, p->page_directory\n(physical addr)\nbefore register swap" {
  style: {
    stroke: "#a29bfe"
    stroke-width: 1
    stroke-dash: 3
    font-size: 10
    font-color: "#a29bfe"
  }
}
# initial stack → ctx.esp
initial_stack.istack_note -> pcb.cl1.ctx.f_esp: "process_create()\nwrites ctx.esp = top-24" {
  style: {
    stroke: "#6c5ce7"
    stroke-width: 1
    stroke-dash: 4
    font-size: 10
    font-color: "#6c5ce7"
  }
}
# PCB.next → scheduler
pcb.cl1.f_next -> cache_analysis: "circular ready-queue\npointer traversal\nin scheduler_tick()" {
  style: {
    stroke: "#ffd93d"
    stroke-width: 1
    stroke-dash: 3
    font-size: 10
    font-color: "#888855"
  }
}
# HW fields annotation
pcb.cl1.hw_saved -> asm_box.asm_code: "pushed on interrupt entry\n(part of interrupt_frame,\nnot stored in PCB fields)" {
  style: {
    stroke: "#ff6b6b"
    stroke-width: 1
    stroke-dash: 5
    font-size: 10
    font-color: "#ff6b6b"
  }
}