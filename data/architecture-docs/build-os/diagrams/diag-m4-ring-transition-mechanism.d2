vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: right
# â”€â”€ Legend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
legend: |md
  **Color Semantics**
  ğŸ”´ Red = privilege-change / danger path
  ğŸ”µ Blue = data pushed onto stack
  ğŸŸ¢ Green = success / return path
  ğŸŸ£ Purple = hardware-read metadata / TSS
  â¬œ Gray = CPU internal state
| {
  near: bottom-left
  style.fill: "#1a1a2e"
  style.stroke: "#444"
  style.font-color: white
  style.font-size: 11
  style.border-radius: 6
}
back_to_map: "â†‘ Satellite Map" {
  link: "#satellite-os-map"
  style.fill: "#2d2d44"
  style.stroke: "#888"
  style.font-color: "#aaa"
  style.font-size: 11
  style.border-radius: 4
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 0 â€” USER MODE EXECUTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
user_exec: "USER SPACE  (Ring 3 / CPL=3)" {
  link: "#milestone-4-processes-and-preemptive-scheduling"
  style.fill: "#0d1b2a"
  style.stroke: "#3a86ff"
  style.stroke-width: 3
  style.font-color: "#3a86ff"
  style.font-size: 14
  style.bold: true
  user_code: "User Code\n(EIP = 0x00401234)" {
    style.fill: "#1a3a5c"
    style.stroke: "#3a86ff"
    style.font-color: "#90c8ff"
    style.border-radius: 4
  }
  int_instr: |md
    **INT 0x80**
    asm
    mov eax, 4     ; SYS_WRITE
    mov ebx, 1     ; fd=stdout
    mov ecx, buf   ; ptr
    mov edx, len   ; count
    int 0x80       ; â† software interrupt
    
  | {
    style.fill: "#1a0000"
    style.stroke: "#ff4444"
    style.stroke-width: 2
    style.font-color: "#ffaaaa"
    style.border-radius: 4
  }
  user_stack: "User Stack (SS=0x23 / Ring 3)" {
    style.fill: "#0a2a0a"
    style.stroke: "#3a86ff"
    style.stroke-dash: 3
    style.font-color: "#90c8ff"
    style.border-radius: 4
    us_data: |md
      **Stack contents (before INT)**
      `0xBFFFF000` ... user local vars ...
      `0xBFFFFFF0` ... return addr to caller ...
      â†’ **ESP_user = 0xBFFFFEFC**
    | {
      style.fill: "#0f1f0f"
      style.stroke: "#2a5a2a"
      style.font-color: "#8aca8a"
      style.font-size: 11
    }
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 1 â€” CPU HARDWARE TRANSITION LOGIC
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
cpu_hw: "CPU HARDWARE (Interrupt Processing)" {
  style.fill: "#1a1a1a"
  style.stroke: "#888888"
  style.stroke-width: 2
  style.font-color: "#cccccc"
  style.font-size: 13
  style.bold: true
  step1: "â‘  Check EFLAGS.IF" {
    style.fill: "#2a2a00"
    style.stroke: "#aaaa00"
    style.font-color: "#ffff80"
    style.border-radius: 4
  }
  step2: "â‘¡ Vector = 0x80 â†’ IDT[128]" {
    style.fill: "#2a2a00"
    style.stroke: "#aaaa00"
    style.font-color: "#ffff80"
    style.border-radius: 4
  }
  step3: "â‘¢ Read IDT[128] gate descriptor\nDPL=3  type=trap-gate  present=1\nhandler = 0xC0101ABC  selector=0x08" {
    style.fill: "#2a1a00"
    style.stroke: "#cc8800"
    style.font-color: "#ffcc80"
    style.border-radius: 4
  }
  step4: "â‘£ Privilege check: CPL(3) > DPL-of-target(0)\nâ†’ RING TRANSITION REQUIRED" {
    style.fill: "#2a0000"
    style.stroke: "#ff4444"
    style.stroke-width: 2
    style.font-color: "#ff8888"
    style.border-radius: 4
    style.bold: true
  }
  step5: "â‘¤ Read TSS\n   SS0  = 0x10 (kernel data)\n   ESP0 = 0xC0205FFC (kernel stack top)" {
    style.fill: "#1a0a2a"
    style.stroke: "#aa44ff"
    style.stroke-width: 2
    style.font-color: "#cc88ff"
    style.border-radius: 4
    style.bold: true
  }
  step6: "â‘¥ Load SS=SS0, ESP=ESP0\nâ†’ CPU now on KERNEL stack" {
    style.fill: "#2a0000"
    style.stroke: "#ff4444"
    style.stroke-width: 2
    style.font-color: "#ff8888"
    style.border-radius: 4
    style.bold: true
  }
  step7: "â‘¦ Push 5 values onto kernel stack\n(privilege-change variant)" {
    style.fill: "#002a1a"
    style.stroke: "#44cc88"
    style.font-color: "#88ffcc"
    style.border-radius: 4
  }
  step8: "â‘§ Load CS = 0x08 (kernel code)\n    EIP = 0xC0101ABC (handler)\nâ†’ jump to IDT handler" {
    style.fill: "#2a0000"
    style.stroke: "#ff4444"
    style.font-color: "#ff8888"
    style.border-radius: 4
    style.bold: true
  }
  step1 -> step2: "IF=1 âœ“\ninterrupts enabled" {
    style.stroke: "#aaaa00"
    style.font-color: "#ffff80"
    style.font-size: 10
  }
  step2 -> step3: "vector 128\nIDT lookup" {
    style.stroke: "#aaaa00"
    style.font-color: "#ffff80"
    style.font-size: 10
  }
  step3 -> step4: "gate valid,\ncheck privilege" {
    style.stroke: "#cc8800"
    style.font-color: "#ffcc80"
    style.font-size: 10
  }
  step4 -> step5: "ring change\nneeded â†’ read TSS" {
    style.stroke: "#ff4444"
    style.font-color: "#ff8888"
    style.font-size: 10
    style.stroke-width: 2
  }
  step5 -> step6: "load kernel\nSS0:ESP0" {
    style.stroke: "#aa44ff"
    style.font-color: "#cc88ff"
    style.font-size: 10
  }
  step6 -> step7: "kernel stack\nactive" {
    style.stroke: "#ff4444"
    style.font-color: "#ff8888"
    style.font-size: 10
  }
  step7 -> step8: "frame built\njump to handler" {
    style.stroke: "#44cc88"
    style.font-color: "#88ffcc"
    style.font-size: 10
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TSS  (the hardware reads this)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
tss_box: "TSS  (Task State Segment)\nâ€” loaded via selector 0x28 in TR register â€”" {
  link: "#phase-2-understanding-hardware-stack-switching-the-tss"
  style.fill: "#1e0a2e"
  style.stroke: "#aa44ff"
  style.stroke-width: 2
  style.font-color: "#cc88ff"
  style.font-size: 12
  style.bold: true
  tss_fields: {
    shape: sql_table
    prev_tss: "0x00000000  (unused)" { constraint: "offset 0" }
    esp0:     "0xC0205FFC  â† kernel stack top" { constraint: "offset 4" }
    ss0:      "0x0010      â† kernel data seg" { constraint: "offset 8" }
    esp1:     "0x00000000  (unused)" { constraint: "offset 12" }
    ss1:      "0x0000      (unused)" { constraint: "offset 16" }
    iomap:    "sizeof(tss)  â† I/O bitmap disabled" { constraint: "offset 102" }
  }
  tss_note: |md
    **Key rule:** `ESP0` must be updated on
    every context switch to the new process's
    `kernel_stack_top`. Stale ESP0 â†’ kernel
    stack corruption on next ring transition.
  | {
    style.fill: "#2a0a3a"
    style.stroke: "#7700aa"
    style.font-color: "#cc88ff"
    style.font-size: 10
    style.border-radius: 4
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# IDT GATE 128
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
idt_gate: "IDT[128] â€” Trap Gate  (INT 0x80)" {
  link: "#the-interrupt-descriptor-table-256-gates-to-the-kernel"
  style.fill: "#1a1a00"
  style.stroke: "#aaaa00"
  style.font-color: "#ffff80"
  style.font-size: 12
  style.bold: true
  gate_bits: {
    shape: sql_table
    offset_hi: "0xC010  (bits 31-16 of handler)" { constraint: "bytes 7-6" }
    flags:     "0xEF = P=1, DPL=3, type=trap(F)" { constraint: "byte 5" }
    reserved:  "0x00" { constraint: "byte 4" }
    selector:  "0x08  (kernel code segment)" { constraint: "bytes 3-2" }
    offset_lo: "0x1ABC (bits 15-0 of handler)" { constraint: "bytes 1-0" }
  }
  gate_note: |md
    **DPL=3** â†’ user code may invoke via `int 0x80`
    **type=trap** â†’ IF not cleared, kernel stays interruptible
    **selector=0x08** â†’ handler runs in kernel code segment
  | {
    style.fill: "#2a2a00"
    style.stroke: "#888800"
    style.font-color: "#dddd80"
    style.font-size: 10
    style.border-radius: 4
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# KERNEL STACK â€” what gets pushed / popped
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
kernel_stack: "KERNEL STACK  (Ring 0)\nphys mapped at 0xC0200000, top=0xC0205FFC" {
  style.fill: "#001a00"
  style.stroke: "#44cc44"
  style.stroke-width: 2
  style.font-color: "#88ff88"
  style.font-size: 12
  style.bold: true
  push_order: "â† Push Order (CPU, on ring change) â†’" {
    style.fill: "#002a00"
    style.stroke: "#336633"
    style.font-color: "#aaffaa"
    style.font-size: 10
    style.bold: true
  }
  frame: {
    shape: sql_table
    ss_user:   "0x00000023  user SS  (RPL=3 â†’ user stack seg)" { constraint: "[ESP0-4]  pushed â‘ " }
    esp_user:  "0xBFFFFEFC  user ESP (user stack ptr before INT)" { constraint: "[ESP0-8]  pushed â‘¡" }
    eflags:    "0x00000202  EFLAGS   (IF=1 saved, user flags)" { constraint: "[ESP0-12] pushed â‘¢" }
    cs_user:   "0x0000001B  user CS  (RPL=3 â†’ ring 3 code)" { constraint: "[ESP0-16] pushed â‘£" }
    eip_user:  "0x00401237  user EIP (return addr: instr after INT)" { constraint: "[ESP0-20] pushed â‘¤" }
    isr_stub:  "â”€â”€â”€ ISR stub pushes below â”€â”€â”€" { constraint: "" }
    err_code:  "0x00000000  fake error code (int gate, no err)" { constraint: "[ESP0-24] isr_128" }
    int_no:    "0x00000080  = 128 (vector)" { constraint: "[ESP0-28] isr_128" }
    pusha_gp:  "EDI ESI EBP ESP EBX EDX ECX EAX" { constraint: "[ESP0-60] pusha (32 bytes)" }
    seg_regs:  "DS ES FS GS  (saved before kernel segs loaded)" { constraint: "[ESP0-76] pushed" }
    esp_frame: "â†’ ESP passed to C handler as 'interrupt_frame *'" { constraint: "[ESP0-80] push esp" }
  }
  stack_legend: |md
    **iret pop order (return path):**
    â‘  EIP  â‘¡ CS  â‘¢ EFLAGS
    (CS.RPL=3 detected â†’ also pops:)
    â‘£ ESP  â‘¤ SS  â†’ switch back to user stack
  | {
    style.fill: "#003300"
    style.stroke: "#226622"
    style.font-color: "#aaffaa"
    style.font-size: 10
    style.border-radius: 4
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RING 0 HANDLER EXECUTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ring0_exec: "RING 0 EXECUTION  (Kernel Mode)" {
  link: "#milestone-4-processes-and-preemptive-scheduling"
  style.fill: "#1a000a"
  style.stroke: "#ff4444"
  style.stroke-width: 3
  style.font-color: "#ff8888"
  style.font-size: 14
  style.bold: true
  isr_stub_asm: |md
    **isr_128: (NASM)**
    asm
    push dword 0       ; fake err_code
    push dword 128     ; int_no
    jmp  isr_common_stub
    
  | {
    style.fill: "#2a0010"
    style.stroke: "#cc2244"
    style.font-color: "#ffaacc"
    style.border-radius: 4
  }
  common_stub: |md
    **isr_common_stub:**
    asm
    pusha               ; save EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX
    push ds / es / fs / gs
    mov ax, 0x10        ; load kernel data segments
    mov ds/es/fs/gs, ax
    push esp            ; â†’ interrupt_frame * arg
    call interrupt_dispatch
    add esp, 4
    pop gs/fs/es/ds
    popa
    add esp, 8          ; remove int_no + err_code
    iretd               ; â† THE RETURN INSTRUCTION
    
  | {
    style.fill: "#1a0010"
    style.stroke: "#882244"
    style.font-color: "#ffaacc"
    style.border-radius: 4
    style.font-size: 11
  }
  c_dispatch: "interrupt_dispatch(frame)" {
    style.fill: "#2a0020"
    style.stroke: "#cc2244"
    style.font-color: "#ffaacc"
    style.border-radius: 4
  }
  syscall_dispatch: "syscall_dispatch(frame)\nâ†’ reads EAX=4 (SYS_WRITE)\nâ†’ validates ECX (user ptr < 0xC0000000)\nâ†’ calls sys_write(fd=1, buf, len)\nâ†’ writes frame->eax = return_value" {
    style.fill: "#0a0a2a"
    style.stroke: "#4444cc"
    style.font-color: "#aaaaff"
    style.border-radius: 4
  }
  isr_stub_asm -> common_stub: "falls through\nto common stub" {
    style.stroke: "#cc2244"
    style.font-color: "#ffaacc"
    style.font-size: 10
  }
  common_stub -> c_dispatch: "call (cdecl)\nframe ptr in EAX" {
    style.stroke: "#cc2244"
    style.font-color: "#ffaacc"
    style.font-size: 10
  }
  c_dispatch -> syscall_dispatch: "int_no == 0x80\nroute to syscall" {
    style.stroke: "#4444cc"
    style.font-color: "#aaaaff"
    style.font-size: 10
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# IRET RETURN PATH
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
iret_path: "IRET â€” Return to Ring 3" {
  style.fill: "#001a00"
  style.stroke: "#44cc44"
  style.stroke-width: 3
  style.font-color: "#88ff88"
  style.font-size: 14
  style.bold: true
  iret_steps: |md
    **`iretd` execution (hardware):**
    **Step â‘ ** Pop EIP  â†’ 0x00401237  (user return addr)
    **Step â‘¡** Pop CS   â†’ 0x0000001B  (RPL=3 detected!)
    **Step â‘¢** Pop EFLAGS â†’ 0x00000202 (IF=1 restored)
    â†“ CS.RPL(3) > CPL(0) â†’ privilege change on return
    **Step â‘£** Pop ESP  â†’ 0xBFFFFEFC  (user stack ptr)
    **Step â‘¤** Pop SS   â†’ 0x00000023  (user stack seg)
    **â†’ CPU switches active stack to user stack**
    **â†’ CPL becomes 3 (from CS bits 0-1)**
    **â†’ Execution resumes at 0x00401237 in ring 3**
    **â†’ EAX = sys_write return value (bytes written)**
  | {
    style.fill: "#001800"
    style.stroke: "#226622"
    style.font-color: "#aaffaa"
    style.border-radius: 6
    style.font-size: 11
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REGISTER SNAPSHOTS â€” before and after
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
reg_before: "Register State  BEFORE INT 0x80" {
  style.fill: "#0d1b2a"
  style.stroke: "#3a86ff"
  style.font-color: "#90c8ff"
  style.font-size: 11
  rb: {
    shape: sql_table
    cs:     "0x1B  (ring-3 code segment, RPL=3)" { constraint: "segment" }
    ss:     "0x23  (ring-3 data segment, RPL=3)" { constraint: "segment" }
    eip:    "0x00401234  (INT instruction)" { constraint: "exec" }
    esp:    "0xBFFFFEFC  (user stack top)" { constraint: "stack" }
    eflags: "0x00000202  (IF=1)" { constraint: "flags" }
    eax:    "0x00000004  (SYS_WRITE)" { constraint: "arg" }
    ebx:    "0x00000001  (fd=1)" { constraint: "arg" }
    ecx:    "0x00400800  (buf ptr)" { constraint: "arg" }
    edx:    "0x0000000D  (len=13)" { constraint: "arg" }
  }
}
reg_after: "Register State  AFTER iretd" {
  style.fill: "#001800"
  style.stroke: "#44cc44"
  style.font-color: "#aaffaa"
  style.font-size: 11
  ra: {
    shape: sql_table
    cs:     "0x1B  (ring-3 code segment, restored)" { constraint: "segment" }
    ss:     "0x23  (ring-3 data segment, restored)" { constraint: "segment" }
    eip:    "0x00401237  (instruction AFTER int 0x80)" { constraint: "exec" }
    esp:    "0xBFFFFEFC  (user stack, restored)" { constraint: "stack" }
    eflags: "0x00000202  (IF=1, restored from stack)" { constraint: "flags" }
    eax:    "0x0000000D  (return value: 13 bytes written)" { constraint: "result" }
    ebx:    "0x00000001  (callee-saved, unchanged)" { constraint: "arg" }
    ecx:    "0x00400800  (callee-saved, unchanged)" { constraint: "arg" }
    edx:    "0x0000000D  (callee-saved, unchanged)" { constraint: "arg" }
  }
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONNECTIONS â€” the data flow
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# User issues the INT
user_exec.int_instr -> cpu_hw.step1: "INT 0x80 issued\n(software interrupt)" {
  style.stroke: "#ff4444"
  style.stroke-width: 3
  style.font-color: "#ff8888"
  style.bold: true
  style.animated: true
}
# CPU reads IDT
cpu_hw.step2 -> idt_gate: "hardware lookup\nIDT[0x80]" {
  style.stroke: "#aaaa00"
  style.font-color: "#ffff80"
  style.font-size: 10
  style.stroke-dash: 3
}
# CPU reads TSS
cpu_hw.step4 -> tss_box: "ring change:\nread SS0:ESP0\nfrom TSS" {
  style.stroke: "#aa44ff"
  style.stroke-width: 2
  style.font-color: "#cc88ff"
  style.bold: true
  style.animated: true
}
# CPU pushes onto kernel stack
cpu_hw.step7 -> kernel_stack: "push 5 values\n(SS,ESP,EFLAGS,CS,EIP)\nonto kernel stack" {
  style.stroke: "#44cc44"
  style.stroke-width: 2
  style.font-color: "#88ff88"
  style.bold: true
  style.animated: true
}
# CPU jumps to handler
cpu_hw.step8 -> ring0_exec.isr_stub_asm: "jump to IDT handler\nCS=0x08, CPLâ†’0" {
  style.stroke: "#ff4444"
  style.stroke-width: 3
  style.font-color: "#ff8888"
  style.bold: true
  style.animated: true
}
# ISR reads from kernel stack
ring0_exec.common_stub -> kernel_stack: "reads interrupt_frame\nfrom kernel stack\n(push esp trick)" {
  style.stroke: "#4444cc"
  style.stroke-dash: 5
  style.font-color: "#aaaaff"
  style.font-size: 10
}
# Handler finishes â†’ iretd
ring0_exec.common_stub -> iret_path: "iretd executed\n(pops frame from kernel stack)" {
  style.stroke: "#44cc44"
  style.stroke-width: 3
  style.font-color: "#88ff88"
  style.bold: true
  style.animated: true
}
# iretd returns to user
iret_path -> user_exec.user_stack: "resume user stack\n(ESP,SS popped)\nCPLâ†’3" {
  style.stroke: "#3a86ff"
  style.stroke-width: 3
  style.font-color: "#90c8ff"
  style.bold: true
  style.animated: true
}
# Register snapshots
reg_before -> user_exec.int_instr: "regs at INT instruction" {
  style.stroke: "#3a86ff"
  style.stroke-dash: 5
  style.font-color: "#90c8ff"
  style.font-size: 10
}
iret_path -> reg_after: "regs after return" {
  style.stroke: "#44cc44"
  style.stroke-dash: 5
  style.font-color: "#88ff88"
  style.font-size: 10
}
# TSS update reminder
tss_box -> kernel_stack.push_order: "ESP0 gives initial\nkernel stack ptr" {
  style.stroke: "#aa44ff"
  style.stroke-dash: 5
  style.font-color: "#cc88ff"
  style.font-size: 10
}