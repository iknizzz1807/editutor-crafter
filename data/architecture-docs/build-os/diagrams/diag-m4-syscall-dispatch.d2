vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: right

# â”€â”€ Color legend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
legend: {
  near: bottom-left
  label: ""
  shape: rectangle
  style: {
    fill: "#1a1a2e"
    stroke: "#444466"
    border-radius: 8
    font-size: 11
  }
  l1: "ðŸ”´ Red  = hot path / ring-transition danger" {
    shape: text
    style.font-color: "#ff6b6b"
    style.font-size: 11
  }
  l2: "ðŸ”µ Blue = data flow / register values" {
    shape: text
    style.font-color: "#74b9ff"
    style.font-size: 11
  }
  l3: "ðŸŸ¢ Green = success / safe return path" {
    shape: text
    style.font-color: "#55efc4"
    style.font-size: 11
  }
  l4: "ðŸŸ£ Purple = metadata / kernel structures" {
    shape: text
    style.font-color: "#a29bfe"
    style.font-size: 11
  }
  l5: "âš« Gray = unused / padding" {
    shape: text
    style.font-color: "#b2bec3"
    style.font-size: 11
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ZONE 1 â€” USER MODE (ring 3)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
user_zone: "RING 3  Â·  User Mode  (CPL = 3)" {
  link: "#ring3-user-mode"
  style: {
    fill: "#0d1b2a"
    stroke: "#2d6a9f"
    stroke-width: 3
    border-radius: 10
    font-color: "#74b9ff"
    font-size: 13
    bold: true
  }
  user_proc: "user_process_entry()" {
    style: {
      fill: "#1a3a5c"
      stroke: "#74b9ff"
      stroke-width: 2
      border-radius: 6
      font-color: "#cce5ff"
      font-size: 12
      bold: true
    }
  }
  reg_setup: |'md
    **Register Setup (cdecl-via-registers)**
    | Register | Value | Meaning |
    |----------|-------|---------|
    | `EAX` | `0x04` | SYS_WRITE |
    | `EBX` | `0x01` | fd = 1 (stdout) |
    | `ECX` | `0xBF001000` | buf ptr (user VA) |
    | `EDX` | `0x13` | count = 19 bytes |
    | `ESI` | â€” | (unused) |
    | `EDI` | â€” | (unused) |
  '| {
    style: {
      fill: "#0d2137"
      stroke: "#2d6a9f"
      border-radius: 5
      font-size: 11
    }
  }
  int80_instr: "INT  0x80" {
    shape: hexagon
    style: {
      fill: "#7f0000"
      stroke: "#ff4757"
      stroke-width: 3
      font-color: "#fff"
      font-size: 15
      bold: true
      shadow: true
    }
  }
  user_proc -> reg_setup: "1. set args\nbefore syscall" {
    style.stroke: "#74b9ff"
    style.font-color: "#74b9ff"
    style.font-size: 10
  }
  reg_setup -> int80_instr: "2. execute INT 0x80\n(software interrupt)" {
    style.stroke: "#ff4757"
    style.stroke-width: 2
    style.font-color: "#ff6b6b"
    style.font-size: 10
    style.bold: true
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ZONE 2 â€” HARDWARE PRIVILEGE TRANSITION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
hw_zone: "CPU HARDWARE  Â·  Privilege Transition  (CPL 3 â†’ 0)" {
  link: "#cpu-hardware-transition"
  style: {
    fill: "#1a0a00"
    stroke: "#e17055"
    stroke-width: 3
    border-radius: 10
    font-color: "#e17055"
    font-size: 13
    bold: true
  }
  idt_lookup: "IDT[0x80] Lookup" {
    style: {
      fill: "#2d1a00"
      stroke: "#e17055"
      stroke-width: 2
      border-radius: 5
      font-color: "#ffeaa7"
      font-size: 12
    }
  }
  idt_entry: |'md
    **IDT Gate Descriptor  Â·  Vector 0x80**
    | Field | Value | Notes |
    |-------|-------|-------|
    | `offset_low` | `isr_128[15:0]` | handler addr lo |
    | `selector` | `0x08` | kernel code seg |
    | `type` | `0x8F` | 32-bit trap gate |
    | `DPL` | `3` | user can invoke |
    | `P` | `1` | present |
    | `offset_high` | `isr_128[31:16]` | handler addr hi |
    *(trap gate: IF not cleared â†’ kernel stays interruptible)*
  '| {
    style: {
      fill: "#1a0e00"
      stroke: "#e17055"
      border-radius: 5
      font-size: 11
    }
  }
  tss_read: "TSS.ESP0 Read" {
    style: {
      fill: "#2d1a00"
      stroke: "#fdcb6e"
      stroke-width: 2
      border-radius: 5
      font-color: "#ffeaa7"
      font-size: 12
    }
  }
  tss_struct: |'md
    **Task State Segment (kernel_tss)**
    | Offset | Field | Value |
    |--------|-------|-------|
    | +0 | prev_tss | 0 |
    | **+4** | **ESP0** | **0xC011FFFC** â† kernel stack top |
    | +8 | SS0 | 0x10 (kernel data) |
    | +12 | esp1 | 0 (unused) |
    | â€¦ | â€¦ | â€¦ |
    | +102 | iomap_base | sizeof(tss) |
    *TR register loaded by `ltr 0x28` in tss_init()*
  '| {
    style: {
      fill: "#1a0e00"
      stroke: "#fdcb6e"
      border-radius: 5
      font-size: 11
    }
  }
  stack_switch: "Kernel Stack Switch" {
    style: {
      fill: "#2d0d0d"
      stroke: "#ff4757"
      stroke-width: 3
      border-radius: 5
      font-color: "#ff6b6b"
      font-size: 12
      bold: true
    }
  }
  pushed_frame: |'md
    **CPU auto-pushes onto kernel stack @ ESP0**
    
    [kernel stack top âˆ’ 20]  SS_user   = 0x23
    [kernel stack top âˆ’ 16]  ESP_user  = 0xBFFFFFF0
    [kernel stack top âˆ’ 12]  EFLAGS    = 0x00000202  (IF=1)
    [kernel stack top âˆ’  8]  CS_user   = 0x1B        (ring-3 code)
    [kernel stack top âˆ’  4]  EIP_user  = 0x00400042  (faulting insn)
    â† ESP now points here (privilege changed: ring3â†’ring0)
    
    *5 values Ã— 4 bytes = 20 bytes consumed from kernel stack*
  '| {
    style: {
      fill: "#1a0000"
      stroke: "#ff4757"
      border-radius: 5
      font-size: 11
    }
  }
  idt_lookup -> idt_entry: "read gate descriptor\n(P=1, DPL=3 âœ“, type=trap)" {
    style.stroke: "#e17055"
    style.font-color: "#e17055"
    style.font-size: 10
  }
  idt_lookup -> tss_read: "privilege change detected\n(CS.RPL=3, gate DPL=0)" {
    style.stroke: "#fdcb6e"
    style.font-color: "#fdcb6e"
    style.font-size: 10
  }
  tss_read -> tss_struct: "read TSS.SS0 + TSS.ESP0" {
    style.stroke: "#fdcb6e"
    style.font-color: "#fdcb6e"
    style.font-size: 10
  }
  tss_read -> stack_switch: "switch ESP â†’ TSS.ESP0\n(0xC011FFFC)" {
    style.stroke: "#ff4757"
    style.stroke-width: 2
    style.font-color: "#ff6b6b"
    style.font-size: 10
    style.bold: true
  }
  stack_switch -> pushed_frame: "push SS/ESP/EFLAGS/CS/EIP\nonto kernel stack (20 bytes)" {
    style.stroke: "#ff4757"
    style.stroke-width: 2
    style.font-color: "#ff6b6b"
    style.font-size: 10
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ZONE 3 â€” KERNEL MODE (ring 0) â€” ISR stub
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
isr_zone: "RING 0  Â·  ISR Common Stub  (isr_128 â†’ isr_common_stub)" {
  link: "#isr-common-stub"
  style: {
    fill: "#0a1a0a"
    stroke: "#00b894"
    stroke-width: 3
    border-radius: 10
    font-color: "#55efc4"
    font-size: 13
    bold: true
  }
  isr128: "isr_128:" {
    style: {
      fill: "#0d2b0d"
      stroke: "#00b894"
      stroke-width: 2
      border-radius: 5
      font-color: "#55efc4"
      font-size: 12
    }
  }
  isr128_code: |'go
    push dword 0     ; fake err_code (no CPU error code for int 0x80)
    push dword 128   ; int_no = 0x80
    jmp  isr_common_stub
  '| {
    style: {
      fill: "#061406"
      stroke: "#00b894"
      border-radius: 4
      font-size: 11
    }
  }
  common_stub: "isr_common_stub:" {
    style: {
      fill: "#0d2b0d"
      stroke: "#00b894"
      stroke-width: 2
      border-radius: 5
      font-color: "#55efc4"
      font-size: 12
    }
  }
  stub_code: |'go
    pusha              ; save EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX (32 bytes)
    push ds            ; save segment registers
    push es ; push fs ; push gs
    mov  ax, 0x10      ; load kernel data segment
    mov  ds, ax ; mov es, ax ; mov fs, ax ; mov gs, ax
    push esp           ; arg0 = pointer to interrupt_frame on stack
    call interrupt_dispatch
    add  esp, 4        ; clean up arg
    pop  gs ; pop fs ; pop es ; pop ds
    popa               ; restore GP registers
    add  esp, 8        ; discard int_no + err_code
    iretd              ; restore EIP/CS/EFLAGS/ESP/SS â†’ back to ring 3
  '| {
    style: {
      fill: "#061406"
      stroke: "#00b894"
      border-radius: 4
      font-size: 11
    }
  }
  iframe_layout: |'md
    **interrupt_frame  Â·  Stack layout (ESP â†’ top)**
    | Offset | Field | Value |
    |--------|-------|-------|
    | +0 | `gs` | user gs |
    | +4 | `fs` | user fs |
    | +8 | `es` | user es |
    | +12 | `ds` | user ds |
    | +16 | `edi` | 0 |
    | +20 | `esi` | 0 |
    | +24 | `ebp` | user EBP |
    | +28 | `esp_dummy` | (pusha ESP snapshot) |
    | +32 | `ebx` | **0x01** (fd=1) |
    | +36 | `edx` | **0x13** (len=19) |
    | +40 | `ecx` | **0xBF001000** (buf) |
    | +44 | **`eax`** | **0x04** (SYS_WRITE) |
    | +48 | `int_no` | 128 (0x80) |
    | +52 | `err_code` | 0 (faked) |
    | +56 | `eip` | 0x00400042 |
    | +60 | `cs` | 0x1B |
    | +64 | `eflags` | 0x00000202 |
    | +68 | `user_esp` | 0xBFFFFFF0 |
    | +72 | `user_ss` | 0x23 |
  '| {
    style: {
      fill: "#061406"
      stroke: "#55efc4"
      border-radius: 5
      font-size: 11
    }
  }
  isr128 -> isr128_code: "executes" {
    style.stroke: "#00b894"
    style.font-size: 10
  }
  isr128 -> common_stub: "jmp isr_common_stub" {
    style.stroke: "#00b894"
    style.stroke-width: 2
    style.font-color: "#55efc4"
    style.font-size: 10
  }
  common_stub -> stub_code: "executes" {
    style.stroke: "#00b894"
    style.font-size: 10
  }
  common_stub -> iframe_layout: "pusha builds this\nstack frame" {
    style.stroke: "#55efc4"
    style.font-color: "#55efc4"
    style.font-size: 10
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ZONE 4 â€” DISPATCH + SYSCALL TABLE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
dispatch_zone: "RING 0  Â·  interrupt_dispatch â†’ syscall_dispatch" {
  link: "#dispatch-logic"
  style: {
    fill: "#150a2d"
    stroke: "#a29bfe"
    stroke-width: 3
    border-radius: 10
    font-color: "#a29bfe"
    font-size: 13
    bold: true
  }
  int_dispatch: "interrupt_dispatch\n(struct interrupt_frame *frame)" {
    style: {
      fill: "#1e1040"
      stroke: "#a29bfe"
      stroke-width: 2
      border-radius: 5
      font-color: "#d4c4ff"
      font-size: 12
    }
  }
  dispatch_logic: |'go
    if frame->int_no < 32    { /* exception handler */ }
    else if int_no < 48      { irq_dispatch(...); pic_send_eoi(); }
    else if int_no == 0x80   { syscall_dispatch(frame); }  // â† our path
  '| {
    style: {
      fill: "#0d0820"
      stroke: "#a29bfe"
      border-radius: 4
      font-size: 11
    }
  }
  syscall_dispatch_fn: "syscall_dispatch\n(struct interrupt_frame *frame)" {
    style: {
      fill: "#1e1040"
      stroke: "#6c5ce7"
      stroke-width: 2
      border-radius: 5
      font-color: "#d4c4ff"
      font-size: 12
    }
  }
  dispatch_read_eax: |'md
    **Read syscall number from saved frame**
    c
    uint32_t syscall_no = frame->eax;  // = 4 (SYS_WRITE)
    uint32_t arg1       = frame->ebx;  // = 1  (fd)
    uint32_t arg2       = frame->ecx;  // = 0xBF001000 (buf)
    uint32_t arg3       = frame->edx;  // = 19 (count)
    
    Bounds check:
    c
    if (syscall_no >= SYSCALL_COUNT        // 4 < 5 âœ“
        || !syscall_table[syscall_no])     // non-NULL âœ“
    
  '| {
    style: {
      fill: "#0d0820"
      stroke: "#6c5ce7"
      border-radius: 5
      font-size: 11
    }
  }
  syscall_table_node: "syscall_table[ ]" {
    style: {
      fill: "#2d1060"
      stroke: "#a29bfe"
      stroke-width: 3
      border-radius: 6
      font-color: "#ffffff"
      font-size: 13
      bold: true
      multiple: true
      shadow: true
    }
  }
  syscall_table_layout: |'md
    **static syscall_handler_t syscall_table[5]**
    | Index | Symbol | Points to |
    |-------|--------|-----------|
    | [0] | â€” | `NULL` |
    | [1] | `SYS_EXIT` | `sys_exit` |
    | [2] | `SYS_FORK` | `NULL` (unimplemented) |
    | [3] | `SYS_READ` | `NULL` (unimplemented) |
    | **[4]** | **`SYS_WRITE`** | **`sys_write` â† selected** |
    *typedef int32_t (\*syscall_handler_t)(uint32_t, uint32_t, uint32_t)*
  '| {
    style: {
      fill: "#1a0840"
      stroke: "#a29bfe"
      border-radius: 5
      font-size: 11
    }
  }
  index_arrow: "EAX=4  â†’  table[4]" {
    shape: diamond
    style: {
      fill: "#3d1080"
      stroke: "#a29bfe"
      stroke-width: 2
      font-color: "#e0d4ff"
      font-size: 11
      bold: true
    }
  }
  int_dispatch -> dispatch_logic: "routes on int_no" {
    style.stroke: "#a29bfe"
    style.font-size: 10
  }
  int_dispatch -> syscall_dispatch_fn: "int_no == 0x80 branch" {
    style.stroke: "#6c5ce7"
    style.stroke-width: 2
    style.font-color: "#a29bfe"
    style.font-size: 10
    style.bold: true
  }
  syscall_dispatch_fn -> dispatch_read_eax: "read frame->eax\nread frame->ebx/ecx/edx" {
    style.stroke: "#6c5ce7"
    style.font-color: "#a29bfe"
    style.font-size: 10
  }
  syscall_dispatch_fn -> syscall_table_node: "index with EAX=4" {
    style.stroke: "#a29bfe"
    style.stroke-width: 2
    style.font-color: "#d4c4ff"
    style.font-size: 10
  }
  syscall_table_node -> syscall_table_layout: "function pointer\narray in .bss" {
    style.stroke: "#a29bfe"
    style.font-size: 10
  }
  syscall_table_node -> index_arrow: "syscall_table[4]\n= &sys_write" {
    style.stroke: "#a29bfe"
    style.stroke-width: 2
    style.font-color: "#e0d4ff"
    style.font-size: 10
    style.bold: true
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ZONE 5 â€” sys_write IMPLEMENTATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
syswrite_zone: "RING 0  Â·  sys_write  Implementation" {
  link: "#sys-write-impl"
  style: {
    fill: "#001a0d"
    stroke: "#00cec9"
    stroke-width: 3
    border-radius: 10
    font-color: "#00cec9"
    font-size: 13
    bold: true
  }
  sys_write_fn: "sys_write(fd=1, buf=0xBF001000, count=19)" {
    style: {
      fill: "#003322"
      stroke: "#00cec9"
      stroke-width: 2
      border-radius: 5
      font-color: "#b2fef7"
      font-size: 12
      bold: true
    }
  }
  validation: |'md
    **Pointer Validation  (security boundary)**
    c
    if (fd != 1) return -1;           // only stdout
    if (buf_virt >= 0xC0000000)       // kernel addr? EFAULT
        return -1;                    // reject â€” kernel ptr from user
    // buf_virt = 0xBF001000 < 0xC0000000 âœ“
    
    *CPL=0 can read user pages (U/S bit irrelevant at ring 0)*
  '| {
    style: {
      fill: "#001a0d"
      stroke: "#00cec9"
      border-radius: 5
      font-size: 11
    }
  }
  write_loop: |'go
    const char *buf = (const char *)0xBF001000;
    uint32_t written = 0;
    for (uint32_t i = 0; i < 19; i++) {
        char c = buf[i];        // reads user VA (paging translates)
        vga_putchar(c);         // â†’ 0xC00B8000 (VGA MMIO)
        serial_putchar(c);      // â†’ I/O port 0x3F8 (COM1)
        written++;
    }
    return (int32_t)written;    // = 19
  '| {
    style: {
      fill: "#001a0d"
      stroke: "#00cec9"
      border-radius: 4
      font-size: 11
    }
  }
  vga_out: "VGA Buffer\n0xC00B8000" {
    shape: cylinder
    style: {
      fill: "#1a0033"
      stroke: "#fd79a8"
      stroke-width: 2
      font-color: "#fd79a8"
      font-size: 11
    }
  }
  serial_out: "COM1 Serial\nI/O port 0x3F8" {
    shape: cylinder
    style: {
      fill: "#1a0033"
      stroke: "#fd79a8"
      stroke-width: 2
      font-color: "#fd79a8"
      font-size: 11
    }
  }
  ret_val: "return 19\n(int32_t)" {
    style: {
      fill: "#004422"
      stroke: "#55efc4"
      stroke-width: 2
      border-radius: 5
      font-color: "#55efc4"
      font-size: 12
      bold: true
    }
  }
  sys_write_fn -> validation: "check fd, check pointer" {
    style.stroke: "#00cec9"
    style.font-size: 10
  }
  sys_write_fn -> write_loop: "iterate count bytes" {
    style.stroke: "#00cec9"
    style.stroke-width: 2
    style.font-size: 10
  }
  write_loop -> vga_out: "vga_putchar(c)\nMMIO write" {
    style.stroke: "#fd79a8"
    style.font-color: "#fd79a8"
    style.font-size: 10
  }
  write_loop -> serial_out: "serial_putchar(c)\noutb(0x3F8, c)" {
    style.stroke: "#fd79a8"
    style.font-color: "#fd79a8"
    style.font-size: 10
  }
  write_loop -> ret_val: "loop done\nreturn written=19" {
    style.stroke: "#55efc4"
    style.stroke-width: 2
    style.font-color: "#55efc4"
    style.font-size: 10
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ZONE 6 â€” RETURN PATH
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
return_zone: "RING 0 â†’ 3  Â·  Return Path  (iretd)" {
  link: "#return-path"
  style: {
    fill: "#0d1a00"
    stroke: "#6ab04c"
    stroke-width: 3
    border-radius: 10
    font-color: "#6ab04c"
    font-size: 13
    bold: true
  }
  write_retval_to_frame: |'go
    // In syscall_dispatch, after handler returns:
    int32_t result = syscall_table[4](arg1, arg2, arg3);  // = 19
    frame->eax = (uint32_t)result;  // write 19 back into saved EAX
    // isr_common_stub will popa â†’ restores modified EAX to user process
  '| {
    style: {
      fill: "#0a1400"
      stroke: "#6ab04c"
      border-radius: 4
      font-size: 11
    }
  }
  iretd_action: |'md
    **iretd  â€”  Atomic return to ring 3**
    CPU pops from kernel stack (in order):
    
    1. EIP    â† 0x00400042  (resumes after INT 0x80)
    2. CS     â† 0x1B        (ring-3 code selector, RPL=3)
    3. EFLAGS â† 0x00000202  (IF=1 restored)
    
    CS.RPL=3 > current CPL=0 â†’ additional pops:
    
    4. ESP    â† 0xBFFFFFF0  (user stack restored)
    5. SS     â† 0x23        (user stack selector)
    
    **CPU is now executing at ring 3.**
  '| {
    style: {
      fill: "#0a1400"
      stroke: "#6ab04c"
      border-radius: 5
      font-size: 11
    }
  }
  user_resume: "User code resumes\nat EIP = 0x00400042" {
    style: {
      fill: "#1a3300"
      stroke: "#6ab04c"
      stroke-width: 2
      border-radius: 5
      font-color: "#b8e994"
      font-size: 12
      bold: true
    }
  }
  eax_visible: |'md
    **EAX = 19 (return value)**
    User code sees `user_write()` returned 19
    (bytes written successfully)
  '| {
    style: {
      fill: "#0a1400"
      stroke: "#55efc4"
      border-radius: 5
      font-size: 11
    }
  }
  write_retval_to_frame -> iretd_action: "popa restores EAX=19\niretd fires" {
    style.stroke: "#6ab04c"
    style.stroke-width: 2
    style.font-color: "#b8e994"
    style.font-size: 10
    style.bold: true
  }
  iretd_action -> user_resume: "CPL = 3 restored\nstack = user stack" {
    style.stroke: "#6ab04c"
    style.stroke-width: 2
    style.font-color: "#b8e994"
    style.font-size: 10
    style.bold: true
  }
  user_resume -> eax_visible: "EAX visible\nto user code" {
    style.stroke: "#55efc4"
    style.font-color: "#55efc4"
    style.font-size: 10
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CROSS-ZONE CONNECTIONS (the main data-walk spine)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
user_zone.int80_instr -> hw_zone.idt_lookup: "3. INT 0x80 fires\nCPU checks IDT[128]" {
  style.stroke: "#ff4757"
  style.stroke-width: 3
  style.font-color: "#ff6b6b"
  style.font-size: 11
  style.bold: true
  style.animated: true
}
hw_zone.pushed_frame -> isr_zone.isr128: "4. CPU jumps to isr_128\n(loaded from IDT gate)" {
  style.stroke: "#e17055"
  style.stroke-width: 3
  style.font-color: "#e17055"
  style.font-size: 11
  style.bold: true
  style.animated: true
}
isr_zone.common_stub -> dispatch_zone.int_dispatch: "5. call interrupt_dispatch\n(ESP â†’ interrupt_frame *)" {
  style.stroke: "#00b894"
  style.stroke-width: 3
  style.font-color: "#55efc4"
  style.font-size: 11
  style.bold: true
  style.animated: true
}
dispatch_zone.index_arrow -> syswrite_zone.sys_write_fn: "6. indirect call\n  syscall_table[4](1, 0xBF001000, 19)" {
  style.stroke: "#a29bfe"
  style.stroke-width: 3
  style.font-color: "#d4c4ff"
  style.font-size: 11
  style.bold: true
  style.animated: true
}
syswrite_zone.ret_val -> return_zone.write_retval_to_frame: "7. result = 19\nframe->eax = 19" {
  style.stroke: "#55efc4"
  style.stroke-width: 3
  style.font-color: "#55efc4"
  style.font-size: 11
  style.bold: true
  style.animated: true
}
return_zone.user_resume -> user_zone.user_proc: "8. execution resumes\nEAX = 19 in user regs" {
  style.stroke: "#6ab04c"
  style.stroke-width: 3
  style.font-color: "#b8e994"
  style.font-size: 11
  style.bold: true
  style.animated: true
}

# â”€â”€ Title â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
title: |'md
  # System Call Dispatch â€” INT 0x80 â†’ sys_write
  **data_walk**: user_process_entry() â†’ INT 0x80 â†’ IDT[0x80] â†’ TSS â†’ ring-0 stack â†’
  isr_common_stub â†’ interrupt_dispatch â†’ syscall_dispatch â†’ syscall_table[EAX=4] â†’
  sys_write(fd=1, buf, 19) â†’ VGA+serial â†’ return 19 â†’ iretd â†’ user mode
'| {
  near: top-center
  style: {
    font-size: 13
    fill: "#0a0a0a"
    stroke: "#333"
    border-radius: 8
  }
}