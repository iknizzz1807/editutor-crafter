vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |'md
# Task State Segment — Structure, SS0:ESP0, and GDT Descriptor
**104-byte hardware structure • Ring 3→0 privilege transition kernel stack pointer**
'| {near: top-center}

# ─── COLOR SEMANTICS ───────────────────────────────────────────────────────
# Red    = critical / hot path fields (SS0, ESP0)
# Purple = metadata / headers / descriptor structure
# Blue   = data flow arrows
# Gray   = unused / zero fields
# Green  = success / correct operations

# ─── GDT LAYOUT (left panel) ─────────────────────────────────────────────
gdt: "Global Descriptor Table (GDT)" {
  link: "#gdt-ref"
  style: {
    fill: "#1a1a2e"
    stroke: "#7c3aed"
    stroke-width: 2
    border-radius: 6
    font-color: "#e2e8f0"
    bold: true
  }
  e0: |'md
**Index 0 · Selector 0x00**
Null Descriptor
*(required by architecture)*
'| {
    style.fill: "#374151"
    style.stroke: "#6b7280"
    style.font-color: "#9ca3af"
    style.border-radius: 4
  }
  e1: |'md
**Index 1 · Selector 0x08**
Kernel Code  DPL=0
Base=0  Limit=4GB  G=1  D=1
'| {
    style.fill: "#1e3a5f"
    style.stroke: "#3b82f6"
    style.font-color: "#93c5fd"
    style.border-radius: 4
  }
  e2: |'md
**Index 2 · Selector 0x10**
Kernel Data  DPL=0
Base=0  Limit=4GB  G=1  D=1
'| {
    style.fill: "#1e3a5f"
    style.stroke: "#3b82f6"
    style.font-color: "#93c5fd"
    style.border-radius: 4
  }
  e3: |'md
**Index 3 · Selector 0x1B** *(RPL=3)*
User Code  DPL=3
Base=0  Limit=4GB  G=1  D=1
'| {
    style.fill: "#1e2a1e"
    style.stroke: "#16a34a"
    style.font-color: "#86efac"
    style.border-radius: 4
  }
  e4: |'md
**Index 4 · Selector 0x23** *(RPL=3)*
User Data  DPL=3
Base=0  Limit=4GB  G=1  D=1
'| {
    style.fill: "#1e2a1e"
    style.stroke: "#16a34a"
    style.font-color: "#86efac"
    style.border-radius: 4
  }
  e5: |'md
**Index 5 · Selector 0x28  ← TSS DESCRIPTOR**
Type=0x89 (32-bit TSS, Available)
S=0 (system)  DPL=0  P=1
Base = &kernel_tss  Limit = 0x67 (103)
Granularity=0 (byte granularity)
'| {
    style.fill: "#3b0764"
    style.stroke: "#a855f7"
    style.stroke-width: 3
    style.font-color: "#e9d5ff"
    style.border-radius: 4
    style.bold: true
  }
}

# ─── TSS STRUCTURE (center panel) ────────────────────────────────────────
tss: "Task State Segment (tss_t) — 104 bytes" {
  link: "#tss-structure"
  style: {
    fill: "#0f172a"
    stroke: "#7c3aed"
    stroke-width: 3
    border-radius: 8
    font-color: "#e2e8f0"
    bold: true
    shadow: true
  }
  hdr: |'md
**Byte Layout — x86 Hardware-Mandated Format**
All offsets are fixed by architecture (IA-32 SDM Vol. 3, §7.2.1)
'| {
    style.fill: "#1e1b4b"
    style.stroke: "#4338ca"
    style.font-color: "#a5b4fc"
    style.border-radius: 4
  }
  off00: |'md
**Offset 0x00** · prev_tss (uint32_t)
Link to previous TSS — hardware task switch chain
**→ Always 0x00000000 for software task switching**
'| {
    style.fill: "#1f2937"
    style.stroke: "#374151"
    style.font-color: "#9ca3af"
    style.border-radius: 4
  }
  off04: |'md
**Offset 0x04** · **esp0** (uint32_t) ◄ CRITICAL FIELD
Ring 0 (kernel) stack pointer. CPU reads this on 3→0 transition.
**MUST be updated on every context switch.**
'| {
    style.fill: "#450a0a"
    style.stroke: "#dc2626"
    style.stroke-width: 3
    style.font-color: "#fca5a5"
    style.border-radius: 4
    style.bold: true
  }
  off08: |'md
**Offset 0x08** · **ss0** (uint32_t) ◄ CRITICAL FIELD
Ring 0 (kernel) stack segment selector.
**Fixed: 0x00000010 (GDT entry 2 = kernel data)**
'| {
    style.fill: "#450a0a"
    style.stroke: "#dc2626"
    style.stroke-width: 3
    style.font-color: "#fca5a5"
    style.border-radius: 4
    style.bold: true
  }
  off0c: |'md
**0x0C–0x17** · esp1, ss1, esp2, ss2
Ring 1/2 stacks — unused on Linux/modern kernels.
**→ All zeros**
'| {
    style.fill: "#1f2937"
    style.stroke: "#374151"
    style.font-color: "#6b7280"
    style.border-radius: 4
  }
  off1c: |'md
**Offset 0x1C** · cr3 (uint32_t)
Page directory for hardware task switch — unused.
'| {
    style.fill: "#1f2937"
    style.stroke: "#374151"
    style.font-color: "#6b7280"
    style.border-radius: 4
  }
  off20: |'md
**0x20–0x5B** · GPR Snapshot
eax, ecx, edx, ebx, esp, ebp, esi, edi, etc.
**→ All zeros (software task switching uses stack)**
'| {
    style.fill: "#1f2937"
    style.stroke: "#374151"
    style.font-color: "#6b7280"
    style.border-radius: 4
  }
  off5c: |'md
**0x5C–0x6B** · Segment Snapshot
es, cs, ss, ds, fs, gs, ldt
**→ All zeros**
'| {
    style.fill: "#1f2937"
    style.stroke: "#374151"
    style.font-color: "#6b7280"
    style.border-radius: 4
  }
  off6c: |'md
**Offset 0x64** · trap (uint16_t)
Trap on task switch bit — **→ 0x0000**
'| {
    style.fill: "#1f2937"
    style.stroke: "#374151"
    style.font-color: "#6b7280"
    style.border-radius: 4
  }
  off6e: |'md
**Offset 0x66** · iomap_base (uint16_t)
I/O permission bitmap offset.
**→ 0x0068 = sizeof(tss_t)** (bitmap empty)
'| {
    style.fill: "#292524"
    style.stroke: "#78716c"
    style.font-color: "#d6d3d1"
    style.border-radius: 4
  }
}

# ─── TSS DESCRIPTOR BIT LAYOUT (right panel) ─────────────────────────────
desc_layout: "TSS Descriptor (8 bytes)" {
  link: "#descriptor-layout"
  style: {
    fill: "#1a0533"
    stroke: "#a855f7"
    stroke-width: 2
    border-radius: 6
    font-color: "#e9d5ff"
    bold: true
  }
  bits_hi: |'md
**Bytes 7–4 (High Dword)**
31      24 23 22 21 20 19    16 15 14 13 12 11   8 7       0
┌─────────┬──┬──┬──┬──┬────────┬──┬─────┬──┬─────┬─────────┐
│Base31:24│G │0 │0 │A │Lim19:16│P │ DPL │0 │Type │Base23:16│
│(8 bits) │0 │  │  │0 │(4 bits)│1 │ 0 0 │  │1001 │(8 bits) │
└─────────┴──┴──┴──┴──┴────────┴──┴─────┴──┴─────┴─────────┘
G=0, P=1, DPL=0, Type=0x9 (32-bit TSS)
'| {
    style.fill: "#2e1065"
    style.stroke: "#7c3aed"
    style.font-color: "#ddd6fe"
    style.border-radius: 4
    style.font: mono
  }
  bits_lo: |'md
**Bytes 3–0 (Low Dword)**
31              16 15              0
┌─────────────────┬────────────────┐
│   Base 15:0     │  Limit 15:0    │
│  (16 bits)      │  0x0067 (103)  │
└─────────────────┴────────────────┘
Base[15:0] = lower 16 bits of &kernel_tss
Limit = 0x67 (sizeof(tss_t) - 1)
'| {
    style.fill: "#2e1065"
    style.stroke: "#7c3aed"
    style.font-color: "#ddd6fe"
    style.border-radius: 4
    style.font: mono
  }
}

# ─── OPERATIONS PANEL ────────────────────────────────────────────────────
ops: "Operations — tss_init() and update" {
  style: {
    fill: "#0c1a0c"
    stroke: "#16a34a"
    stroke-width: 2
    border-radius: 6
    font-color: "#d1fae5"
    bold: true
  }
  init_code: |'go
// tss_init() — called ONCE during startup
void tss_init(void) {
    memset(&kernel_tss, 0, sizeof(tss_t));
    kernel_tss.ss0        = 0x10;        
    kernel_tss.iomap_base = sizeof(tss_t);
    uint32_t base  = (uint32_t)&kernel_tss;
    uint32_t limit = sizeof(tss_t) - 1;
    gdt_set_tss_entry(5, base, limit);
    // Load TR with TSS selector 0x28 (5 << 3) | 0
    __asm__ volatile("ltr %0" : : "r"((uint16_t)0x28));
}
'| {
    style.fill: "#052e16"
    style.stroke: "#15803d"
    style.font-color: "#bbf7d0"
    style.border-radius: 4
  }
  update_code: |'go
// tss_set_kernel_stack() — EVERY context switch
void tss_set_kernel_stack(uint32_t esp0) {
    kernel_tss.esp0 = esp0;
    // WHY: next interrupt must push frame onto
    // NEW process's kernel stack.
}
'| {
    style.fill: "#052e16"
    style.stroke: "#15803d"
    style.font-color: "#bbf7d0"
    style.border-radius: 4
  }
}

# ─── TRANSITION FLOW PANEL ───────────────────────────────────────────────
flow: "Ring 3→0 Transition Flow" {
  style: {
    fill: "#1a0a00"
    stroke: "#ea580c"
    stroke-width: 2
    border-radius: 6
    font-color: "#fed7aa"
    bold: true
  }
  step1: "① Timer fires (IRQ0) at CPL=3" {
    style.fill: "#431407"; style.stroke: "#c2410c"
  }
  step2: "② CPU reads TSS.SS0 and TSS.ESP0" {
    style.fill: "#450a0a"; style.stroke: "#dc2626"; style.bold: true
  }
  step3: "③ ESP ← TSS.ESP0, user state saved" {
    style.fill: "#431407"; style.stroke: "#c2410c"
  }
  step4: "④ CS:EIP ← IDT[32], isr_32 starts" {
    style.fill: "#14532d"; style.stroke: "#16a34a"
  }
  wrong: |'md
**⚠ IF TSS.ESP0 IS STALE:**
CPU corrupts WRONG stack.
'| {
    style.fill: "#3b0764"; style.stroke: "#a855f7"
  }
}

# ─── CRITICAL INVARIANT ──────────────────────────────────────────────────
invariant: |'md
**The Invariant:** TSS.ESP0 Must Equal new_proc->kernel_stack_top BEFORE context_switch_asm() Swaps ESP
'| {
  near: bottom-center
  style: {
    fill: "#0c0a00"; stroke: "#eab308"; stroke-width: 3
    font-color: "#fef08a"; border-radius: 8; bold: true
  }
}

# ─── CONNECTIONS ─────────────────────────────────────────────────────────
gdt.e5 -> tss.hdr: "Base points to &kernel_tss" {
  style.stroke: "#a855f7"; style.animated: true
}
ops.init_code -> gdt.e5: "gdt_set_tss_entry(5, ...)" {
  style.stroke: "#16a34a"
}
ops.update_code -> tss.off04: "updates esp0" {
  style.stroke: "#dc2626"; style.stroke-width: 3; style.animated: true
}
tss.off04 -> flow.step2: "Hardware read" {
  style.stroke: "#dc2626"; style.stroke-dash: 4
}
flow.step1 -> flow.step2: "trigger"
flow.step2 -> flow.step3: "load"
flow.step3 -> flow.step4: "exec"
gdt.e5 -> desc_layout.bits_hi: "bit fields" { style.stroke-dash: 3 }
gdt.e5 -> desc_layout.bits_lo: "bit fields" { style.stroke-dash: 3 }
flow.step2 -> flow.wrong: "bug path" { style.stroke: "#a855f7"; style.stroke-dash: 5 }