direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    code: "#E8F5E9"
    partition: "#E3F2FD"
    signature: "#FFF3E0"
    reserved: "#FFEBEE"
    used: "#C8E6C9"
    critical: "#FFCDD2"
  }
}
title: |md
  # Master Boot Record: 512-Byte Prison
  The most constrained code you'll ever write
| {near: top-center}
mbr_sector: {
  label: MBR Sector (512 bytes)\nLoaded at 0x7C00 by BIOS
  style.fill: "#FAFAFA"
  style.stroke: "#424242"
  style.stroke-width: 3
  code_section: {
    label: ""
    style.fill: transparent
    style.stroke: transparent
    code_area: {
      label: "Bootloader Code & Data\n(Bytes 0x000 - 0x1BD)"
      style.fill: ${colors.code}
      style.stroke: "#2E7D32"
      style.stroke-width: 2
      width: 300
      code_detail: |md
        
        0x000: jmp short start
        0x002: nop
        0x003: [BPB - BIOS Parameter Block]
               OEMName, BytesPerSec...
        0x03E: start:
               cli; xor ax,ax
               mov ds,ax; mov es,ax
               mov ss,ax; mov sp,0x7C00
               ; ... enable A20 ...
               ; ... load GDT ...
               ; ... enter protected mode ...
               ; ... load kernel from disk ...
        
      |
    }
    code_constraints: {
      label: "Critical Constraints"
      style.fill: "#F1F8E9"
      style.stroke: "#558B2F"
      constraint1: "• ~446 bytes for actual code"
      constraint2: "• Must set up stack manually"
      constraint3: "• No C runtime, no stdlib"
      constraint4: "• BIOS services only (INT 13h)"
      constraint5: "• Real mode (16-bit) initially"
    }
  }
  partition_section: {
    label: ""
    style.fill: transparent
    style.stroke: transparent
    partition_table: {
      label: "Partition Table\n(64 bytes at 0x1BE - 0x1FD)"
      style.fill: ${colors.partition}
      style.stroke: "#1565C0"
      style.stroke-width: 2
      width: 320
      pt_header: |md
        
        Offset  Size  Field
        ─────────────────────────
        0x1BE   16    Entry #1
        0x1CE   16    Entry #2
        0x1DE   16    Entry #3
        0x1EE   16    Entry #4
        
      |
      pt_entry: {
        label: "Partition Entry (16 bytes each)"
        style.fill: "#BBDEFB"
        style.stroke: "#1976D2"
        entry_detail: |md
          
          +0   Boot flag (0x80=bootable)
          +1   CHS start (head)
          +2   CHS start (sector/cyl)
          +3   CHS start (cylinder)
          +4   Partition type
               0x07=NTFS, 0x83=Linux
               0x0B=FAT32, 0xEE=GPT
          +5   CHS end (head)
          +6   CHS end (sector/cyl)
          +7   CHS end (cylinder)
          +8   LBA start (4 bytes)
          +12  Sector count (4 bytes)
          
        |
      }
    }
  }
  signature_section: {
    label: ""
    style.fill: transparent
    style.stroke: transparent
    boot_signature: {
      label: "Boot Signature\n(2 bytes at 0x1FE - 0x1FF)"
      style.fill: ${colors.signature}
      style.stroke: "#E65100"
      style.stroke-width: 3
      width: 200
      sig_detail: |md
        
        0x1FE: 0x55
        0x1FF: 0xAA
        
        **REQUIRED** - BIOS checks
        these bytes before boot.
        Missing = "No bootable device"
      |
    }
  }
}
byte_allocation: {
  label: "Byte Budget"
  style.fill: "#FAFAFA"
  style.stroke: "#616161"
  grid-columns: 4
  grid-gap: 8
  total: "Total: 512 bytes" {
    style.fill: "#ECEFF1"
    style.font: mono
  }
  code: "Code: 446 bytes" {
    style.fill: ${colors.code}
    style.font: mono
  }
  parts: "Partitions: 64 bytes" {
    style.fill: ${colors.partition}
    style.font: mono
  }
  sig: "Signature: 2 bytes" {
    style.fill: ${colors.signature}
    style.font: mono
  }
}
memory_layout: {
  label: "Memory Layout After BIOS Load"
  style.fill: "#FAFAFA"
  style.stroke: "#424242"
  mem_stack: {
    label: ""
    style.fill: transparent
    mem_7e00: {
      label: "0x7E00+"
      style.fill: "#E8EAF6"
      style.stroke: "#3F51B5"
      note: "Free for stage 2 loader"
    }
    mem_7c00: {
      label: "0x7C00 - 0x7DFF"
      style.fill: ${colors.code}
      style.stroke: "#2E7D32"
      style.stroke-width: 2
      note: "MBR loaded here (512 bytes)"
    }
    mem_stack_area: {
      label: "0x7BFF ↓"
      style.fill: "#FFCDD2"
      style.stroke: "#C62828"
      note: "Stack grows DOWN from 0x7C00"
    }
    mem_7a00: {
      label: "0x7A00 and below"
      style.fill: "#E8EAF6"
      style.stroke: "#3F51B5"
      note: "BIOS data area, IVT, etc."
    }
  }
}
why_two_stage: {
  label: "Why Two-Stage Bootloaders?"
  style.fill: "#FFF8E1"
  style.stroke: "#F57C00"
  style.stroke-width: 2
  stage1: {
    label: "Stage 1 (MBR)"
    style.fill: "#FFE0B2"
    s1_tasks: |md
      - Fit in 446 bytes
      - Enable A20 line
      - Load GDT
      - Enter protected mode
      - Load Stage 2 from disk
      - Jump to Stage 2
    |
  }
  stage2: {
    label: "Stage 2 (LBA 1+)"
    style.fill: "#C8E6C9"
    s2_tasks: |md
      - No size limit (can be KB/MB)
      - Parse filesystem (FAT32/ext2)
      - Load kernel from files
      - Set up memory map
      - Pass info to kernel
      - Transfer control
    |
  }
  stage1 -> stage2: "Handoff" {
    style.stroke: "#F57C00"
    style.stroke-width: 2
    style.animated: true
  }
}
timeline: {
  label: "Boot Sequence Timeline"
  step1: "BIOS POST" {
    style.fill: "#E3F2FD"
  }
  step2: "BIOS reads sector 0" {
    style.fill: "#E3F2FD"
  }
  step3: "Check 0x55AA signature" {
    style.fill: ${colors.signature}
  }
  step4: "Load to 0x7C00" {
    style.fill: ${colors.code}
  }
  step5: "Jump to 0x7C00" {
    style.fill: ${colors.code}
  }
  step6: "MBR code executes" {
    style.fill: ${colors.code}
  }
  step1 -> step2 -> step3 -> step4 -> step5 -> step6
}
mbr_sector.code_section.code_area -> memory_layout.mem_stack.mem_7c00: "Loaded at"
why_two_stage.stage1 -> mbr_sector.code_section.code_area: "Must fit in"