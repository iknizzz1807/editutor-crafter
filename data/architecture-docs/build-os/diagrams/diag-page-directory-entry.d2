vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Page Directory/Table Entry (PDE/PTE) - 32-bit Structure
  4-byte entry controlling memory access, caching, and protection
| {near: top-center}

direction: right

entry_layout: {
  label: ""
  
  bit31_12: {
    label: Frame Address\n(Bits 31-12)
    width: 280
    style.fill: "#E8F4FD"
    style.stroke: "#2196F3"
    style.font: mono
  }
  
  bit11_9: {
    label: Available\n(Bits 11-9)
    width: 80
    style.fill: "#FFF3E0"
    style.stroke: "#FF9800"
    style.font: mono
  }
  
  bit8: {
    label: G\n(Bit 8)
    width: 50
    style.fill: "#E8F5E9"
    style.stroke: "#4CAF50"
    style.font: mono
  }
  
  bit7: {
    label: PS\n(Bit 7)
    width: 50
    style.fill: "#FCE4EC"
    style.stroke: "#E91E63"
    style.font: mono
  }
  
  bit6: {
    label: D\n(Bit 6)
    width: 50
    style.fill: "#F3E5F5"
    style.stroke: "#9C27B0"
    style.font: mono
  }
  
  bit5: {
    label: A\n(Bit 5)
    width: 50
    style.fill: "#FFF8E1"
    style.stroke: "#FFC107"
    style.font: mono
  }
  
  bit4: {
    label: PCD\n(Bit 4)
    width: 55
    style.fill: "#E0F7FA"
    style.stroke: "#00BCD4"
    style.font: mono
  }
  
  bit3: {
    label: PWT\n(Bit 3)
    width: 55
    style.fill: "#E0F2F1"
    style.stroke: "#009688"
    style.font: mono
  }
  
  bit2: {
    label: U/S\n(Bit 2)
    width: 55
    style.fill: "#FFEBEE"
    style.stroke: "#F44336"
    style.font: mono
    style.bold: true
  }
  
  bit1: {
    label: R/W\n(Bit 1)
    width: 55
    style.fill: "#FFEBEE"
    style.stroke: "#F44336"
    style.font: mono
    style.bold: true
  }
  
  bit0: {
    label: P\n(Bit 0)
    width: 50
    style.fill: "#FFEBEE"
    style.stroke: "#F44336"
    style.font: mono
    style.bold: true
  }
}

bit0_detail: Present Bit {
  style.fill: "#FFEBEE"
  style.stroke: "#F44336"
  
  value_0: |md
    **P=0**: Page not in memory
    - Access triggers #PF
    - Remaining bits ignored
    - OS can store swap info
  |
  
  value_1: |md
    **P=1**: Page present
    - Entry is valid
    - Frame address used
    - Access permitted (check other bits)
  |
  
  security: |md
    ### Security Implications
    - **Demand paging**: Load pages on-demand
    - **Swap management**: Track swapped pages
    - **DoS potential**: Exhaust memory→thrashing
  |
  
  value_0 -> value_1: OS loads page {
    style.stroke-dash: 3
    style.animated: true
  }
}

bit1_detail: Read/Write Bit {
  style.fill: "#FFEBEE"
  style.stroke: "#F44336"
  
  value_0: |md
    **R/W=0**: Read-only
    - User mode: cannot write
    - Kernel mode: can write (if CR0.WP=0)
    - Code pages typically R/O
  |
  
  value_1: |md
    **R/W=1**: Read/Write
    - Full access permitted
    - Data pages need this
    - Stack must be writable
  |
  
  security: |md
    ### Security Implications
    - **W^X violation**: Write+Execute = exploit
    - **Code injection**: Writable code pages
    - **Return-to-libc**: R/O doesn't help alone
    - **CR0.WP bypass**: Kernel ignores if WP=0
  |
}

bit2_detail: User/Supervisor Bit {
  style.fill: "#FFEBEE"
  style.stroke: "#F44336"
  
  value_0: |md
    **U/S=0**: Supervisor only
    - Ring 0-2 can access
    - Ring 3 causes #PF
    - Kernel pages use this
  |
  
  value_1: |md
    **U/S=1**: User accessible
    - All rings can access
    - User code/data pages
    - Shared libraries
  |
  
  security: |md
    ### Security Implications
    - **Kernel mapping**: Must be U/S=0
    - **Spectre/Meltdown**: Speculative bypass
    - **KPTI mitigation**: Unmap kernel on user switch
    - **Null pointer**: U/S=0 catches deref
  |
  
  cross_privilege: Ring 3 to Ring 0 page {
    style.stroke: red
    style.stroke-width: 3
    style.animated: true
  }
}

bit3_detail: Page Write-Through {
  style.fill: "#E0F2F1"
  style.stroke: "#009688"
  
  desc: |md
    **PWT (Bit 3)**: Write-through caching
    
    **PWT=0**: Write-back
    - CPU caches writes
    - Delayed write to memory
    - Better performance
    - Must handle cache coherency
    
    **PWT=1**: Write-through  
    - Every write goes to memory
    - Slower but simpler
    - Used for memory-mapped I/O
  |
  
  security: |md
    ### Security Implications
    - **Timing attacks**: Cache vs memory timing
    - **Rowhammer**: Write-back amplifies
    - **MMIO protection**: Prevent cache interference
  |
}

bit4_detail: Page Cache Disable {
  style.fill: "#E0F7FA"
  style.stroke: "#00BCD4"
  
  desc: |md
    **PCD (Bit 4)**: Cache disable
    
    **PCD=0**: Caching enabled
    - Normal memory access
    - CPU uses L1/L2/L3
    
    **PCD=1**: Caching disabled
    - Accesses go to memory
    - Used for device memory
    - Prevents cache pollution
  |
  
  security: |md
    ### Security Implications
    - **Side-channel resistance**: Disable cache for sensitive data
    - **Constant-time crypto**: Avoid cache timing
    - **Device registers**: Must be uncached
  |
}

bit5_detail: Accessed Bit {
  style.fill: "#FFF8E1"
  style.stroke: "#FFC107"
  
  desc: |md
    **A (Bit 5)**: Accessed flag
    - Set by CPU on ANY access (read OR write)
    - Must be cleared by software
    - Used for page replacement
    - Present in both PDE and PTE
  |
  
  usage: |md
    ### OS Usage Pattern
    1. Clear A bit on all pages
    2. Let process run
    3. Scan for A=1 pages
    4. Those are "recently used"
    5. Clear again, repeat
    
    → Clock algorithm for LRU approximation
  |
}

bit6_detail: Dirty Bit {
  style.fill: "#F3E5F5"
  style.stroke: "#9C27B0"
  
  desc: |md
    **D (Bit 6)**: Dirty flag (PTE ONLY)
    - Set by CPU on WRITE
    - Not updated on reads
    - Only in PTE, not PDE
    - Cleared by software
  |
  
  usage: |md
    ### OS Usage Pattern
    - Page read but D=0: No swap write needed
    - Page written D=1: Must write to swap
    - Copy-on-write: Check before sharing
    
    **Performance win**: Skip clean pages during swap-out
  |
  
  cow: |md
    ### Copy-on-Write Flow
    1. Fork: Mark pages R/O, D=0
    2. Both parent/child share frame
    3. Write triggers #PF
    4. If D=1, page was modified
    5. OS copies page to new frame
  |
}

bit7_detail: Page Size Bit {
  style.fill: "#FCE4EC"
  style.stroke: "#E91E63"
  
  desc: |md
    **PS (Bit 7)**: Page size (PDE ONLY)
    
    **PS=0**: 4KB pages
    - Standard page size
    - Two-level walk (PD→PT→Page)
    
    **PS=1**: 4MB pages (PSE enabled)
    - Single-level for this entry
    - PDE points directly to 4MB
    - No page table needed
  |
  
  security: |md
    ### Security Implications
    - **TLB coverage**: 1 huge page vs 1024 small
    - **Granularity trade-off**: Less precise protection
    - **ASLR weakness**: Larger pages = less randomization
    - **Kernel mapping**: Often uses huge pages
  |
}

bit8_detail: Global Bit {
  style.fill: "#E8F5E9"
  style.stroke: "#4CAF50"
  
  desc: |md
    **G (Bit 8)**: Global page (PGE enabled)
    
    **G=0**: Process-local
    - TLB entry flushed on CR3 reload
    - Normal per-process page
    
    **G=1**: Global across processes
    - TLB entry NOT flushed
    - Shared kernel pages
    - Requires CR4.PGE=1
  |
  
  security: |md
    ### Security Implications
    - **TLB persistence**: Data leaks across processes
    - **KASLR bypass**: TLB reveals kernel addresses
    - **Side-channel**: Shared TLB entries = timing leaks
    - **Mitigation**: PCID instead of global pages
  |
}

bit11_9_detail: Available Bits {
  style.fill: "#FFF3E0"
  style.stroke: "#FF9800"
  
  desc: |md
    **Bits 11-9**: Available to OS
    - CPU ignores these
    - OS can store metadata
    - 3 bits = 8 possible flags
  |
  
  usage: |md
    ### Common OS Uses
    - Bit 9: Software dirty bit
    - Bit 10: Page in swap
    - Bit 11: Memory-mapped file
    - Custom page flags
    
    **Example**: Linux uses for:
    - _PAGE_BIT_SOFTW1 (0x200)
    - _PAGE_BIT_SOFTW2 (0x400)  
    - _PAGE_BIT_SOFTW3 (0x800)
  |
}

bit31_12_detail: Frame Address {
  style.fill: "#E8F4FD"
  style.stroke: "#2196F3"
  
  desc: |md
    **Bits 31-12**: Physical frame address
    
    - 20 bits = 2²⁰ = 1M frames
    - Each frame = 4KB
    - Total addressable: 4GB
    - Frame number, NOT full address
    - Lower 12 bits are always 0 (4KB aligned)
  |
  
  translation: |md
    ### Address Translation
    Virtual Address: 0x12345678
    ┌─────────┬────────┬────────┐
    │ PD Index│PT Index│ Offset │
    │ (10 bit)│(10 bit)│(12 bit)│
    └─────────┴────────┴────────┘
         ↓
    PDE at: CR3 + (PD Index × 4)
         ↓
    PTE at: (PDE.frame × 4096) + (PT Index × 4)
         ↓
    Physical: (PTE.frame × 4096) + Offset
  |
}

privilege_check: Privilege Check Sequence {
  direction: right
  
  access: Memory Access Request {
    shape: oval
    style.fill: "#E3F2FD"
  }
  
  check_p: P=1? {
    shape: diamond
    style.fill: "#FFEBEE"
  }
  
  pf_present: "#PF (Not Present)" {
    style.fill: "#FFCDD2"
  }
  
  check_us: "U/S allows?" {
    shape: diamond
    style.fill: "#FFEBEE"
  }
  
  pf_priv: "#PF (Protection)" {
    style.fill: "#FFCDD2"
  }
  
  check_rw: "R/W allows?" {
    shape: diamond
    style.fill: "#FFEBEE"
  }
  
  pf_write: "#PF (Write Protect)" {
    style.fill: "#FFCDD2"
  }
  
  grant: Access Granted {
    shape: oval
    style.fill: "#C8E6C9"
  }
  
  access -> check_p
  check_p -> pf_present: No {
    style.stroke: red
  }
  check_p -> check_us: Yes {
    style.stroke: green
  }
  check_us -> pf_priv: No {
    style.stroke: red
  }
  check_us -> check_rw: Yes {
    style.stroke: green
  }
  check_rw -> pf_write: "Write & R/W=0" {
    style.stroke: red
  }
  check_rw -> grant: Yes {
    style.stroke: green
  }
}

security_summary: Security Bit Matrix {
  content: ||md
  | Bit | Attack Vector | Mitigation |
  |-----|--------------|------------|
  | U/S | Ring crossing exploits | KPTI, SMAP/SMEP |
  | R/W | Code injection | W^X, NX bit |
  | P | Demand paging DoS | mlock(), ulimit |
  | G | TLB side-channel | PCID, flush on switch |
  | PCD | Cache timing attacks | Constant-time crypto |
  | D | COW bypass | Check before share |
  | PS | Coarse ASLR | Prefer 4KB pages |
  ||
}

connections: {
  bit0_detail -> bit1_detail: "Next check" {
    style.stroke: "#666"
    style.stroke-dash: 2
  }
  bit1_detail -> bit2_detail
  bit2_detail -> privilege_check: "All checks combined" {
    style.stroke: blue
  }
}

legend: {
  near: bottom-center
  
  critical: Critical for Security {
    style.fill: "#FFEBEE"
    style.stroke: "#F44336"
  }
  
  performance: Performance Related {
    style.fill: "#E8F4FD"
    style.stroke: "#2196F3"
  }
  
  os_controlled: OS Controlled {
    style.fill: "#FFF3E0"
    style.stroke: "#FF9800"
  }
}