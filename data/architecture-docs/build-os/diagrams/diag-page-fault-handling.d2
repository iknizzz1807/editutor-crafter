vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Page Fault Handler: CR2 → Diagnostic → Action
  Exception 14 - Vector 0x0E
| {near: top-center}

classes: {
  cpu_action: {
    style: {
      fill: "#FFE4E1"
      stroke: "#DC143C"
      stroke-width: 2
    }
  }
  handler_action: {
    style: {
      fill: "#E6F3FF"
      stroke: "#4169E1"
      stroke-width: 2
    }
  }
  decision: {
    shape: diamond
    width: 140
    style: {
      fill: "#FFFACD"
      stroke: "#DAA520"
      stroke-width: 2
    }
  }
  register: {
    shape: hexagon
    style: {
      fill: "#E8E8E8"
      stroke: "#696969"
      font: mono
    }
  }
  data: {
    shape: page
    style: {
      fill: "#F0FFF0"
      stroke: "#228B22"
    }
  }
  terminal: {
    shape: circle
    style: {
      fill: "#2F4F4F"
      font-color: white
    }
  }
}

start: "" {
  class: terminal
  near: top-center
}

cpu_exception: CPU Exception Triggered {
  class: cpu_action
  label: |md
    **Page Fault (INT 14)**
    ---
    Triggered by:
    - Access non-present page
    - Write to read-only
    - User access to supervisor
    - Reserved bit set
  |
}

cpu_push_stack: CPU Pushes to Stack {
  class: cpu_action
  label: |md
    **Stack Frame (automatic)**
    ---
    SS      (if CPL change)
    ESP     (if CPL change)  
    EFLAGS
    CS
    EIP
    Error Code ← pushed by CPU
  |
}

cpu_cr2: CPU Loads CR2 {
  class: cpu_action
  label: |md
    **CR2 ← Faulting Address**
    ---
    The linear address that
    caused the page fault.
    Loaded automatically by CPU.
  |
}

cr2_register: CR2 {
  class: register
  label: |md
    **0xDEADBEEF**
    (example)
  |
}

error_code_stack: Error Code on Stack {
  class: register
  label: |md
    Bit 0 (P): 0=not present
    Bit 1 (W): 0=read, 1=write
    Bit 2 (U): 0=kernel, 1=user
    Bit 3 (R): reserved bit set
    Bit 4 (I): instruction fetch
  |
}

handler_entry: Handler Entry (isr14) {
  class: handler_action
  label: |md
    **Assembly Stub**
    ---
    `isr14:`
    `  cli`
    `  push byte 14`
    `  jmp isr_common_stub`
  |
}

handler_save: Save All Registers {
  class: handler_action
  label: |md
    **Common Stub**
    ---
    `pusha           ; EAX..EDI`
    `push ds/es/fs/gs`
    `mov ax, 0x10    ; kernel DS`
    `mov ds, ax`
    `call page_fault_handler`
  |
}

read_cr2: Read CR2 {
  class: handler_action
  label: |md
    **Get Faulting Address**
    ---
    `uint32_t fault_addr;`
    `asm volatile("mov %%cr2, %0"`
    `             : "=r"(fault_addr));`
  |
}

read_error: Read Error Code {
  class: handler_action
  label: |md
    **From Stack Frame**
    ---
    `// In registers_t struct`
    `uint32_t err = regs->err_code;`
  |
}

diagnostic: Print Diagnostic {
  class: handler_action
  style: {
    fill: "#FFF8DC"
    stroke: "#B8860B"
    stroke-width: 3
  }
  label: |md
    **Diagnostic Output**
    ---
    `kprintf("=== PAGE FAULT ===\n");`
    `kprintf("CR2: 0x%x\n", fault_addr);`
    `kprintf("Error: 0x%x\n", err);`
    `kprintf("Present: %d\n", err & 1);`
    `kprintf("Write:   %d\n", (err>>1)&1);`
    `kprintf("User:    %d\n", (err>>2)&1);`
    `kprintf("EIP:     0x%x\n", regs->eip);`
  |
}

decision_present: Page Present? {
  class: decision
}

decision_cause: Fault Cause? {
  class: decision
}

action_alloc: Allocate Page {
  class: handler_action
  style: {
    fill: "#90EE90"
  }
  label: |md
    **Demand Paging**
    ---
    `void *frame = pmm_alloc_frame();`
    `vmm_map_page(pd, fault_addr & ~0xFFF,`
    `             frame, PAGE_USER |`
    `             PAGE_WRITABLE);`
  |
}

action_cow: Copy-on-Write {
  class: handler_action
  style: {
    fill: "#90EE90"
  }
  label: |md
    **COW Handler**
    ---
    `// 1. Allocate new frame`
    `// 2. Copy data from shared`
    `// 3. Update page table`
    `// 4. Set writable`
  |
}

action_kill: Kill Process {
  class: handler_action
  style: {
    fill: "#FF6B6B"
    stroke: "#8B0000"
  }
  label: |md
    **SIGSEGV Equivalent**
    ---
    `kprintf("Segmentation fault\n");`
    `current_process->state = ZOMBIE;`
    `schedule(); // never returns`
  |
}

action_panic: Kernel Panic {
  class: handler_action
  style: {
    fill: "#8B0000"
    font-color: white
  }
  label: |md
    **Kernel Mode Fault**
    ---
    `if (!(err & 4)) { // kernel mode`
    `  panic("Kernel page fault!");`
    `}`
  |
}

return_path: Return to Process {
  class: handler_action
  style: {
    fill: "#98FB98"
  }
  label: |md
    **Resume Execution**
    ---
    `pop gs/fs/es/ds`
    `popa`
    `add esp, 8    ; cleanup`
    `iret          ; restore EIP/CS/EFLAGS`
  |
}

end: "" {
  class: terminal
}

memory_ref: Stack Layout {
  class: data
  near: bottom-right
  label: |md
    **High Address**
    
    +------------+
    | SS         | if privilege change
    +------------+
    | ESP        | if privilege change
    +------------+
    | EFLAGS     |
    +------------+
    | CS         |
    +------------+
    | EIP        | ← return here
    +------------+
    | Error Code | ← pushed by CPU
    +------------+
    | Int No     | ← pushed by stub
    +------------+
    | EAX..EDI   | ← pusha
    +------------+
    | DS..GS     | ← segment saves
    +------------+ ← ESP
    
    **Low Address**
  |
}

start -> cpu_exception: Memory access triggers fault

cpu_exception -> cpu_push_stack: Automatic
cpu_exception -> cpu_cr2: Parallel

cpu_push_stack -> error_code_stack: Creates
cpu_cr2 -> cr2_register: Loads

cr2_register -> read_cr2: Handler reads
error_code_stack -> read_error: Handler reads

cpu_push_stack -> handler_entry: Jump to IDT[14]
handler_entry -> handler_save

handler_save -> read_cr2
handler_save -> read_error

read_cr2 -> diagnostic
read_error -> diagnostic

diagnostic -> decision_present

decision_present -> decision_cause: "Yes (P=1)"
decision_present -> action_alloc: "No (P=0) Demand Page"

decision_cause -> action_cow: "Write to read-only"
decision_cause -> action_kill: "Invalid access"
decision_cause -> action_panic: "Kernel mode"

action_alloc -> return_path: Page mapped
action_cow -> return_path: Copied
action_kill -> end: Process terminated
action_panic -> end: System halted

return_path -> end: Process resumes

annotation: |md
  **Key Registers**
  - **CR2**: Faulting linear address (data, not instruction)
  - **EIP**: Instruction that caused the fault
  - **Error Code**: Reason bits pushed by CPU
| {
  near: top-right
  shape: text
  style: {
    font-size: 14
    fill: transparent
  }
}