vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Physical Memory Map: E820/Multiboot Regions
  ### Data Walk: From Firmware Tables to Frame Allocator Bitmap
| {near: top-center}

direction: right

classes: {
  reserved: {
    style: {
      fill: "#FFE4E1"
      stroke: "#CD5C5C"
      stroke-width: 2
    }
  }
  firmware: {
    style: {
      fill: "#E6E6FA"
      stroke: "#9370DB"
      stroke-width: 2
    }
  }
  kernel: {
    style: {
      fill: "#98FB98"
      stroke: "#228B22"
      stroke-width: 2
    }
  }
  usable: {
    style: {
      fill: "#E0FFFF"
      stroke: "#20B2AA"
      stroke-width: 2
    }
  }
  acpi: {
    style: {
      fill: "#FFFACD"
      stroke: "#DAA520"
      stroke-width: 2
    }
  }
  mmio: {
    style: {
      fill: "#FFB6C1"
      stroke: "#FF69B4"
      stroke-width: 2
    }
  }
  metadata: {
    style: {
      fill: "#F5F5F5"
      stroke: "#A9A9A9"
      stroke-dash: 3
    }
  }
}

region_0: {
  label: "0x00000000\n0x000003FF"
  class: reserved
  desc: |md
    **IVT**
    Interrupt Vector Table
    256 Ã— 4-byte far pointers
    (BIOS real-mode)
  |
}

region_1: {
  label: "0x00000400\n0x000004FF"
  class: firmware
  desc: |md
    **BDA**
    BIOS Data Area
    Equipment config, serial ports
  |
}

region_2: {
  label: "0x00000500\n0x00007BFF"
  class: usable
  desc: |md
    **Low Memory**
    Free (conventional)
    ~30 KB available
  |
}

region_3: {
  label: "0x00007C00\n0x00007DFF"
  class: reserved
  desc: |md
    **Boot Sector**
    MBR loaded by BIOS
    512 bytes at 0x7C00
    Signature: 0x55 0xAA
  |
}

region_4: {
  label: "0x00007E00\n0x0009FFFF"
  class: usable
  desc: |md
    **Extended Low**
    Free conventional memory
    ~608 KB available
  |
}

region_5: {
  label: "0x000A0000\n0x000BFFFF"
  class: mmio
  desc: |md
    **VGA/MMIO**
    Video memory
    Text buffer: 0xB8000
    Graphics: 0xA0000
  |
}

region_6: {
  label: "0x000C0000\n0x000FFFFF"
  class: firmware
  desc: |md
    **BIOS ROM**
    Video BIOS: 0xC0000
    Motherboard: 0xF0000
    (Read-only, shadowed)
  |
}

region_7: {
  label: "0x00100000\n0x00FFFFFF"
  class: kernel
  desc: |md
    **Kernel Space**
    Physical: 0x100000+
    .text, .data, .bss
    Page tables, structures
  |
}

region_8: {
  label: "0x01000000\n0xXXXXXXXX"
  class: usable
  desc: |md
    **Main Memory**
    Usable RAM
    E820 type=1
    (Largest region)
  |
}

region_9: {
  label: "0xXXXXXXXX"
  class: acpi
  desc: |md
    **ACPI Tables**
    E820 type=3,4
    RSDP, RSDT, MADT
    NVS: non-volatile
  |
}

region_10: {
  label: "0xXXXXXXXX"
  class: mmio
  desc: |md
    **PCIe MMIO**
    Memory-mapped I/O
    BAR regions
    (High addresses)
  |
}

region_0 -> region_1: "+0x400"
region_1 -> region_2: "+0x100"
region_2 -> region_3: "+0x7700"
region_3 -> region_4: "+0x200"
region_4 -> region_5: "+0x92200"
region_5 -> region_6: "+0x20000"
region_6 -> region_7: "+0x40000\n(1MB boundary)"
region_7 -> region_8: "+0xF00000"
region_8 -> region_9: "hole"
region_9 -> region_10: "hole"

e820_table: {
  label: "E820 Memory Map"
  class: metadata
  
  header: {
    shape: sql_table
    entry: int {constraint: primary_key}
    base: uint64
    length: uint64
    type: uint32
    type_str: string
  }
  
  data_row_0: ||md
    | entry | base | length | type |
    |-------|------|--------|------|
    | 0 | 0x00000000 | 0x0009FC00 | 1 (Usable) |
    | 1 | 0x0009FC00 | 0x00000400 | 2 (Reserved) |
    | 2 | 0x000E0000 | 0x00020000 | 2 (Reserved) |
    | 3 | 0x00100000 | 0x1DF00000 | 1 (Usable) |
    | 4 | 0x1FF00000 | 0x00100000 | 3 (ACPI) |
    | 5 | 0x20000000 | 0x40000000 | 2 (Reserved) |
  ||
}

e820_table -> region_0: "Entry 0\n0x0-0x9FBFF"
e820_table -> region_5: "Entry 2\nBIOS ROM"
e820_table -> region_8: "Entry 3\nMain RAM"

multiboot_info: {
  class: metadata
  label: "Multiboot Info"
  
  mbi_struct: {
    shape: sql_table
    flags: uint32
    mem_lower: uint32
    mem_upper: uint32
    mmap_addr: uint32
    mmap_length: uint32
  }
  
  mbi_desc: |md
    *Passed in EBX by GRUB*
    
    - `mem_lower`: KB below 1MB
    - `mem_upper`: KB above 1MB  
    - `mmap_addr`: E820 table ptr
    - `mmap_length`: table size
  |
}

multiboot_info -> e820_table: "mmap_addr\npoints to"

pmm_allocator: {
  label: "Physical Frame Allocator"
  class: metadata
  
  bitmap: {
    label: "Bitmap (1 bit per 4KB frame)"
    shape: rectangle
    
    frame_0: {label: "0"; class: reserved}
    frame_1: {label: "0"; class: reserved}
    frame_2: {label: "1"; class: usable}
    frame_3: {label: "1"; class: usable}
    dots_1: "..."
    frame_n: {label: "0"; class: kernel}
    frame_n1: {label: "1"; class: usable}
    dots_2: "..."
  }
  
  legend: |md
    **Bitmap Encoding**
    - `1` = Allocated/Reserved
    - `0` = Available for allocation
  |
  
  init_code: |go
    // Initialize from E820
    for each region:
      if region.type == USABLE:
        mark_range_free(region.base,
                        region.length)
      else:
        mark_range_used(region.base,
                        region.length)
    
    // Always reserve:
    mark_range_used(0, 0x100000)  // Low 1MB
  |
}

pmm_allocator -> region_7: "Kernel frames\nmarked used"
pmm_allocator -> region_8: "Main memory\ninitially free"

alloc_flow: {
  label: "Allocation Flow"
  
  step_1: {
    label: "1. E820 Query"
    desc: |md
      BIOS INT 15h/E820 or
      Multiboot mmap
      returns regions
    |
  }
  
  step_2: {
    label: "2. Region Classification"
    desc: |md
      Type 1 = Usable RAM
      Type 2 = Reserved
      Type 3 = ACPI Reclaimable
      Type 4 = ACPI NVS
      Type 5 = Bad Memory
    |
  }
  
  step_3: {
    label: "3. Bitmap Init"
    desc: |md
      Default: all frames used
      For each USABLE region:
        clear bits for frames
    |
  }
  
  step_4: {
    label: "4. Kernel Reserve"
    desc: |md
      Calculate kernel bounds:
      __kernel_start = 0x100000
      __kernel_end from linker
      
      Mark kernel frames used
      Mark page tables used
    |
  }
  
  step_5: {
    label: "5. Ready for Alloc"
    desc: |md
      pmm_alloc_frame():
      Linear scan for bit=0
      Set bit=1
      Return frame address
    |
  }
  
  step_1 -> step_2 -> step_3 -> step_4 -> step_5
}

alloc_flow -> pmm_allocator

address_space: {
  label: "4GB Physical Address Space"
  
  low_1mb: {
    label: "Low 1MB\n0x00000000-0x000FFFFF"
    class: reserved
    desc: |md
      Always marked used
      - IVT, BDA, Boot sector
      - VGA MMIO at 0xB8000
      - BIOS ROM at 0xF0000
    |
  }
  
  kernel_region: {
    label: "Kernel\n0x00100000+"
    class: kernel
    desc: |md
      Marked used by:
      - Kernel .text/.data/.bss
      - Page directory (1 frame)
      - Page tables (N frames)
      - kmalloc heap
    |
  }
  
  free_pool: {
    label: "Free Pool\nVariable"
    class: usable
    desc: |md
      Available for:
      - User process pages
      - Additional kernel structures
      - Page table expansion
    |
  }
  
  holes: {
    label: "Memory Holes"
    class: mmio
    desc: |md
      ACPI, MMIO, Reserved
      Never allocated
      (BIOS reports these)
    |
  }
  
  low_1mb -> kernel_region -> free_pool
  holes -> free_pool: "interspersed"
}

data_walk_annotation: ||md
  ### Frame Allocator Logic
  
  
  Frame Index = Physical Address / 4096
  Bitmap Word = Frame Index / 32
  Bit Position = Frame Index % 32
  
  // Mark frame as used
  bitmap[word] |= (1 << bit)
  
  // Mark frame as free
  bitmap[word] &= ~(1 << bit)
  
  // Find free frame
  for word in bitmap:
    if word != 0xFFFFFFFF:
      bit = find_first_zero(word)
      return word * 32 + bit
  
  
  **4GB system**: 1,048,576 frames
  **Bitmap size**: 128 KB (32,768 words)
|| {near: bottom-center}