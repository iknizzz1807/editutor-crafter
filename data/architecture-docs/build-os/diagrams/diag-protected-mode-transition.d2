vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: Protected Mode Transition: Before/After {
  near: top-center
  shape: text
  style: {
    font-size: 32
    bold: true
  }
}

before: Real Mode (16-bit) {
  style: {
    fill: "#FFE4E1"
    stroke: "#CD5C5C"
    stroke-width: 3
  }

  regs_before: ||md
    ## CPU Registers

    | Register | Value | Purpose |
    |----------|-------|---------|
    | **CS** | `0x07C0` | Code segment base |
    | **IP** | `0x0000` | Instruction offset |
    | **DS/ES/SS** | `0x07C0` | Data segments |
    | **CR0.PE** | `0` | Protection disabled |
    | **EFLAGS** | `0x0002` | Reserved bit only |

    **Effective Address**: `CS × 16 + IP`
    = `0x07C00` (boot sector)
  ||
  regs_before.shape: rectangle
  regs_before.style.fill: white
  regs_before.style.stroke: "#CD5C5C"

  mem_before: ||md
    ## Memory Model

    0x00000 ┌─────────────────┐
            │ IVT (1KB)       │
    0x00400 ├─────────────────┤
            │ BDA             │
    0x00500 ├─────────────────┤
            │ ...unused...    │
    0x07C00 ├─────────────────┤ ← CS:IP
            │ Boot Sector     │ (0x07C0:0x0000)
            │ (512 bytes)     │
    0x07E00 ├─────────────────┤
            │ ...unused...    │
    0x9FC00 ├─────────────────┤
            │ EBDA            │
    0xA0000 ├─────────────────┤
            │ Video RAM       │
    0xFFFFF └─────────────────┘

    **Limit**: 1MB (20-bit addresses)
  ||
  mem_before.style.fill: white
  mem_before.style.stroke: "#CD5C5C"

  seg_before: ||md
    ## Segment Translation

    Logical:  0x07C0:0x0000
                 │       │
                 │       └── Offset (16-bit)
                 └── Segment (16-bit)
                        │
                        ▼
                 0x07C0 × 16 = 0x07C00
                        │
                        ▼ Linear
                 0x07C00 + 0x0000 = 0x07C00

    **No protection checks**
    **No privilege levels**
  ||
  seg_before.style.fill: white
  seg_before.style.stroke: "#CD5C5C"
}

after: Protected Mode (32-bit) {
  style: {
    fill: "#E0FFE0"
    stroke: "#228B22"
    stroke-width: 3
  }

  regs_after: ||md
    ## CPU Registers

    | Register | Value | Purpose |
    |----------|-------|---------|
    | **CS** | `0x08` | Code selector (index=1) |
    | **EIP** | `0x00100000` | Full 32-bit offset |
    | **DS/ES/SS** | `0x10` | Data selector (index=2) |
    | **CR0.PE** | `1` | Protection enabled |
    | **EFLAGS** | `0x00000202` | IF=1, reserved |

    **Effective Address**: `GDT[CS.index].base + EIP`
    = `0x00000000 + 0x00100000`
  ||
  regs_after.style.fill: white
  regs_after.style.stroke: "#228B22"

  mem_after: ||md
    ## Memory Model

    0x00000000 ┌─────────────────┐
               │ GDT (6 bytes+)  │
    0x00001000 ├─────────────────┤
               │ IDT (future)    │
    0x00100000 ├─────────────────┤ ← CS:EIP
               │ Kernel Code     │ (0x08:0x00100000)
               │                 │
               │ ...             │
    0x00200000 ├─────────────────┤
               │ Kernel Data     │
               │ ...             │
    0xFFFFFFFF └─────────────────┘

    **Limit**: 4GB (32-bit addresses)
  ||
  mem_after.style.fill: white
  mem_after.style.stroke: "#228B22"

  seg_after: ||md
    ## Segment Translation

    Logical:  0x08:0x00100000
                 │       │
                 │       └── Offset (32-bit)
                 └── Selector
                        │
                  ┌─────┴─────┐
                  │ Index=1   │
                  │ TI=0 (GDT)│
                  │ RPL=0     │
                  └─────┬─────┘
                        ▼
                 GDT[1] = {
                   base:  0x00000000
                   limit: 0xFFFFFFFF
                   type:  Code/Execute
                   DPL:   0 (Ring 0)
                 }
                        │
                        ▼ Linear
                 0x00000000 + 0x00100000
                 = 0x00100000

    **Protection checks enforced**
    **4 privilege levels (0-3)**
  ||
  seg_after.style.fill: white
  seg_after.style.stroke: "#228B22"
}

gdt_detail: GDT (Global Descriptor Table) {
  style: {
    fill: "#E6E6FA"
    stroke: "#4B0082"
  }

  gdt_content: ||md
    ## GDT Layout (Minimum Required)

    | Index | Selector | Type | Base | Limit | DPL |
    |-------|----------|------|------|-------|-----|
    | 0 | `0x00` | Null | — | — | — |
    | 1 | `0x08` | Code | `0x00000000` | `0xFFFFFFFF` | 0 |
    | 2 | `0x10` | Data | `0x00000000` | `0xFFFFFFFF` | 0 |

    Entry 1 (Code Selector 0x08):
    ┌────────────────────────────────────────┐
    │ Base [31:24] │G│D│L│A│ Limit[19:16] │P│DPL│S│ Type  │Base[23:16]│
    │     0x00     │1│1│0│0│    0x0F      │1│ 0 │1│ 0xA   │   0x00    │
    ├────────────────────────────────────────┤
    │           Base [15:0]          │       Limit [15:0]          │
    │            0x0000              │          0xFFFF             │
    └────────────────────────────────────────┘

    **Selector Format**: `Index(13) | TI(1) | RPL(2)`
    - `0x08` = index=1, TI=0, RPL=0
    - `0x10` = index=2, TI=0, RPL=0
  ||
}

transition: Transition Steps {
  style: {
    fill: "#FFFACD"
    stroke: "#DAA520"
  }

  transition_content: ||md
    ## Required Sequence (Must be exact!)

    1. Disable interrupts
       `cli`                      ; IF = 0

    2. Load GDT
       `lgdt [gdt_descriptor]`    ; GDTR = base + limit

    3. Set PE bit in CR0
       `mov eax, cr0`
       `or  eax, 1`               ; Set bit 0
       `mov cr0, eax`             ; ← NOW IN PROTECTED MODE

    4. Far jump to flush pipeline
       `jmp 0x08:protected_mode`  ; Load CS with selector

    5. Load segment registers
       `mov ax, 0x10`             ; Data selector
       `mov ds, ax`
       `mov es, ax`
       `mov fs, ax`
       `mov gs, ax`
       `mov ss, ax`

    6. Re-enable interrupts (optional)
       `sti`                      ; IF = 1

    ⚠️ **Critical**: Step 4 MUST be a far jump to reload CS
    Pipeline contains real-mode instructions!
  ||
}

before -> after: "mov cr0, eax\n(PE bit set)" {
  style: {
    stroke: "#8B0000"
    stroke-width: 4
    animated: true
  }
}

gdt_detail -> after: "Selector 0x08\nreferences GDT[1]" {
  style: {
    stroke: "#4B0082"
    stroke-dash: 3
  }
}

changes: What Changes and Why {
  near: bottom-center
  style: {
    fill: "#F0F8FF"
    stroke: "#4682B4"
  }

  changes_content: ||md
    ## Register Changes Summary

    | Aspect | Real Mode | Protected Mode | Why |
    |--------|-----------|----------------|-----|
    | **CS meaning** | Segment × 16 | GDT selector index | Enable segmentation with protection |
    | **IP width** | 16-bit | 32-bit (EIP) | Access full 4GB address space |
    | **Address calc** | `CS<<4 + IP` | `GDT[CS].base + EIP` | Hardware-enforced limits & privileges |
    | **CR0.PE** | 0 | 1 | Toggle protection mechanism |
    | **Limit** | 1MB (20-bit) | 4GB (32-bit) | A20 gate + 32-bit registers |
    | **Privilege** | None | Ring 0-3 | Isolation & security |
    | **GDT** | N/A | Required | Segment descriptors live here |

    ### Why far jump after CR0?
    The CPU pipeline may contain prefetched real-mode instructions.
    Far jump flushes pipeline and loads CS with proper selector.
    Otherwise, garbage execution leads to triple fault.
  ||
}