vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    danger: "#E5484D"
    safe: "#4DAF73"
    caution: "#E5A000"
    data_blue: "#3B82F6"
    meta_purple: "#8B5CF6"
    gray: "#6B7280"
    header_bg: "#F3F4F6"
  }
}

title: |md
  # Real Mode vs. Protected Mode: Address Translation
  ### The Fundamental CPU Mode Transition
| {near: top-center}

# ==================== BEFORE: REAL MODE ====================

before_container: {
  label: "BEFORE: Real Mode (16-bit)"
  style: {
    fill: "#FEF2F2"
    stroke: "${colors.danger}"
    stroke-width: 3
  }

  real_mode_header: |md
    **CPU State at Boot: 16-bit Real Mode**
    - CS:IP = 0xF000:0xFFF0 (reset vector)
    - No memory protection
    - Addresses wrap at 1MB boundary
  |

  # Segment:Offset calculation
  calc_box: {
    label: "Address Calculation"
    style.fill: "${colors.header_bg}"
    
    segment: {
      label: "Segment Register\n(CS, DS, ES, SS)"
      shape: rectangle
      style: {
        fill: "${colors.meta_purple}"
        font-color: white
        bold: true
      }
    }
    
    shift_op: {
      label: "<< 4"
      shape: text
      style: {
        font-size: 24
        bold: true
        font-color: "${colors.danger}"
      }
    }
    
    offset: {
      label: "Offset Register\n(IP, BX, SI, DI)"
      shape: rectangle
      style: {
        fill: "${colors.data_blue}"
        font-color: white
        bold: true
      }
    }
    
    plus_op: {
      label: "+"
      shape: text
      style: {
        font-size: 28
        bold: true
      }
    }
    
    physical: {
      label: "20-bit Physical\nAddress"
      shape: rectangle
      style: {
        fill: "${colors.caution}"
        font-color: white
        bold: true
      }
    }
    
    segment -> shift_op -> plus_op
    offset -> plus_op -> physical
  }
  
  # Example calculation
  example_real: {
    label: "Example: CS=0xF000, IP=0xFFF0"
    style.fill: "white"
    style.stroke: "${colors.gray}"
    
    calc_line: |md
      
      Physical = (0xF000 × 16) + 0xFFF0
               = 0xF0000 + 0xFFF0
               = 0xFFFF0    (1MB - 16 bytes)
      
    |
    
    limit_line: |md
      **Maximum addressable: 0x10FFEF**
      (wraps to 0x0EFFEF due to 20-bit limit)
    | {style.font-color: "${colors.danger}"}
  }
  
  # Limitations
  limits_real: {
    label: "Real Mode Limitations"
    style: {
      fill: "#FEF2F2"
      stroke: "${colors.danger}"
    }
    
    limit1: "• 1MB addressable memory (20-bit)"
    limit2: "• No privilege levels (everything ring 0)"
    limit3: "• No memory protection"
    limit4: "• No paging support"
    limit5: "• Segment = shift value, not selector"
  }
}

# ==================== TRANSITION ====================

transition_container: {
  label: "THE TRANSITION"
  style: {
    fill: "#FFFBEB"
    stroke: "${colors.caution}"
    stroke-width: 3
    stroke-dash: 5
  }
  
  transition_header: |md
    ## Critical: The Pipeline Problem
  |
  
  step1: {
    label: "1. Load GDT"
    style.fill: "white"
    desc1: |md
      `lgdt [gdt_descriptor]`
      
      Loads GDTR with:
      - Limit (16-bit): GDT size - 1
      - Base (32-bit): GDT linear address
    |
  }
  
  step2: {
    label: "2. Set CR0.PE"
    style.fill: "white"
    desc2: |md
      asm
      mov eax, cr0
      or eax, 1        ; Set Protection Enable
      mov cr0, eax
      
      
      CPU is NOW in protected mode!
    |
  }
  
  step3: {
    label: "3. FAR JUMP (Required!)"
    style: {
      fill: "#DCFCE7"
      stroke: "${colors.safe}"
      stroke-width: 3
    }
    desc3: |md
      asm
      jmp 0x08:protected_mode_entry
      
      
      **Why required:**
      - Reloads CS with segment SELECTOR
      - Flushes 16-bit prefetch queue
      - Loads new CS base/limit from GDT
      
      **0x08 = GDT index 1, RPL=0, TI=0**
    |
  }
  
  step4: {
    label: "4. Load Data Segments"
    style.fill: "white"
    desc4: |md
      asm
      mov ax, 0x10    ; Kernel data selector
      mov ds, ax
      mov es, ax
      mov ss, ax
      
    |
  }
  
  step1 -> step2: "GDT ready" {
    style: {
      stroke: "${colors.safe}"
      animated: true
    }
  }
  step2 -> step3: "PE bit set\nbut pipeline\ncorrupted!" {
    style: {
      stroke: "${colors.danger}"
      bold: true
    }
  }
  step3 -> step4: "Pipeline\nflushed,\nCS reloaded" {
    style: {
      stroke: "${colors.safe}"
      animated: true
    }
  }
}

# ==================== AFTER: PROTECTED MODE ====================

after_container: {
  label: "AFTER: Protected Mode (32-bit)"
  style: {
    fill: "#ECFDF5"
    stroke: "${colors.safe}"
    stroke-width: 3
  }
  
  protected_mode_header: |md
    **CPU State After Transition: 32-bit Protected Mode**
    - CS = 0x08 (selector pointing to GDT entry 1)
    - Segments defined by GDT descriptors
    - Full 4GB address space accessible
  |
  
  # GDT-based translation
  gdt_box: {
    label: "Address Translation via GDT"
    style.fill: "${colors.header_bg}"
    
    selector: {
      label: "Segment Selector\n(CS, DS, ES, SS, FS, GS)"
      shape: rectangle
      style: {
        fill: "${colors.meta_purple}"
        font-color: white
        bold: true
      }
    }
    
    gdt_lookup: {
      label: "GDT\nLookup"
      shape: diamond
      style: {
        fill: "${colors.caution}"
        font-color: white
      }
    }
    
    descriptor: {
      label: "Segment Descriptor\n(Base, Limit, Access)"
      shape: rectangle
      style: {
        fill: "${colors.meta_purple}"
        font-color: white
        bold: true
      }
    }
    
    offset_pm: {
      label: "32-bit Offset"
      shape: rectangle
      style: {
        fill: "${colors.data_blue}"
        font-color: white
        bold: true
      }
    }
    
    add_op: {
      label: "+"
      shape: text
      style: {
        font-size: 28
        bold: true
      }
    }
    
    linear_addr: {
      label: "Linear Address\n(→ Page Tables)"
      shape: rectangle
      style: {
        fill: "${colors.safe}"
        font-color: white
        bold: true
      }
    }
    
    selector -> gdt_lookup: "Index" {
      label: "Index into GDT"
    }
    gdt_lookup -> descriptor
    descriptor -> add_op: "Base (32-bit)"
    offset_pm -> add_op
    add_op -> linear_addr
  }
  
  # Selector breakdown
  selector_detail: {
    label: "Segment Selector Format (16 bits)"
    style: {
      fill: "white"
      stroke: "${colors.gray}"
    }
    
    bits: {
      grid-columns: 3
      grid-gap: 0
      
      index_part: {
        label: "Index\n(bits 15-3)"
        style: {
          fill: "${colors.meta_purple}"
          font-color: white
        }
      }
      ti_part: {
        label: "TI\n(bit 2)"
        style: {
          fill: "${colors.caution}"
          font-color: white
        }
      }
      rpl_part: {
        label: "RPL\n(bits 1-0)"
        style: {
          fill: "${colors.data_blue}"
          font-color: white
        }
      }
    }
    
    legend: |md
      - **Index**: GDT/LDT entry number (0-8191)
      - **TI**: Table Indicator (0=GDT, 1=LDT)
      - **RPL**: Requestor Privilege Level (0-3)
    |
  }
  
  # Capabilities
  caps_pm: {
    label: "Protected Mode Capabilities"
    style: {
      fill: "#ECFDF5"
      stroke: "${colors.safe}"
    }
    
    cap1: "• 4GB addressable memory (32-bit)"
    cap2: "• 4 privilege rings (0=kernel, 3=user)"
    cap3: "• Segment-level protection"
    cap4: "• Paging support (CR0.PG)"
    cap5: "• Virtual memory & isolation"
  }
}

# ==================== GDT ENTRY DETAIL ====================

gdt_entry: {
  label: "GDT Entry: 8-Byte Segment Descriptor"
  style: {
    fill: "${colors.header_bg}"
    stroke: "${colors.meta_purple}"
    stroke-width: 2
  }
  
  entry_layout: {
    grid-columns: 5
    grid-gap: 0
    
    base_31_24: {
      label: "Base\n31:24"
      style: {
        fill: "${colors.meta_purple}"
        font-color: white
      }
    }
    flags_limit: {
      label: "Flags &\nLimit 19:16"
      style: {
        fill: "${colors.caution}"
        font-color: white
      }
    }
    access: {
      label: "Access\nByte"
      style: {
        fill: "${colors.danger}"
        font-color: white
      }
    }
    base_23_16: {
      label: "Base\n23:16"
      style: {
        fill: "${colors.meta_purple}"
        font-color: white
      }
    }
    base_limit_low: {
      label: "Base 15:0 |\nLimit 15:0"
      style: {
        fill: "${colors.meta_purple}"
        font-color: white
      }
    }
  }
  
  access_detail: {
    label: "Access Byte Breakdown"
    style.fill: "white"
    
    access_bits: |md
      
      Bit 7: Present (P)     - 1 = segment in memory
      Bits 6-5: DPL          - Privilege level (0-3)
      Bit 4: System (S)      - 1 = code/data, 0 = system
      Bit 3: Executable (E)  - 1 = code, 0 = data
      Bit 2: DC              - Direction/Conforming
      Bit 1: RW              - Readable/Writable
      Bit 0: Accessed (A)    - Set by CPU when accessed
      
    |
  }
  
  example_entry: {
    label: "Example: Kernel Code Segment (0x00CF9A000000FFFF)"
    style.fill: "white"
    style.stroke: "${colors.safe}"
    
    breakdown: |md
      
      Base:  0x00000000 (all 0)
      Limit: 0xFFFFF    (20-bit)
      Flags: G=1 (4KB granularity), D=1 (32-bit), L=0 (not 64-bit)
      Access: P=1, DPL=0, S=1, E=1, RW=1
      
      Effective limit = 0xFFFFF × 4096 = 4GB (flat addressing)
      
    |
  }
}

# ==================== COMPARISON TABLE ====================

comparison: {
  label: "Side-by-Side Comparison"
  style.fill: "${colors.header_bg}"
  
  comp_grid: {
    grid-columns: 3
    grid-gap: 0
    
    aspect: {
      label: "Aspect"
      style: {
        fill: "${colors.gray}"
        font-color: white
        bold: true
      }
    }
    real: {
      label: "Real Mode"
      style: {
        fill: "${colors.danger}"
        font-color: white
        bold: true
      }
    }
    protected: {
      label: "Protected Mode"
      style: {
        fill: "${colors.safe}"
        font-color: white
        bold: true
      }
    }
    
    addr_bits: "Address Width"
    addr_real: "20-bit (1MB)"
    addr_prot: "32-bit (4GB)"
    
    seg_meaning: "Segment Meaning"
    seg_real: "Shift value (×16)"
    seg_prot: "Selector (GDT index)"
    
    translation: "Translation"
    trans_real: "seg << 4 + offset"
    trans_prot: "GDT[sel].base + offset"
    
    protection: "Memory Protection"
    prot_real: "None"
    prot_prot: "Limit check, R/W, DPL"
    
    privilege: "Privilege Levels"
    priv_real: "None (always ring 0)"
    priv_prot: "4 rings (0-3)"
    
    paging: "Paging"
    page_real: "Not available"
    page_prot: "Available (CR0.PG)"
  }
}

# ==================== FAR JUMP EXPLANATION ====================

far_jump_box: {
  label: "Why the Far Jump is Mandatory"
  style: {
    fill: "#FEF2F2"
    stroke: "${colors.danger}"
    stroke-width: 2
  }
  
  problem: {
    label: "The Pipeline Problem"
    style.fill: "white"
    
    prob_desc: |md
      After `mov cr0, eax` sets PE=1:
      
      1. CPU is **technically** in protected mode
      2. **BUT** the prefetch queue still contains:
         - 16-bit real-mode instructions
         - Old CS interpretation (shift, not selector)
      3. Next instruction fetch uses **corrupted** state
      4. Result: **Triple fault** (CPU resets)
    |
  }
  
  solution: {
    label: "The Far Jump Solution"
    style: {
      fill: "#DCFCE7"
      stroke: "${colors.safe}"
    }
    
    sol_desc: |md
      `jmp 0x08:protected_mode_entry` does:
      
      1. **Flushes** the 16-bit prefetch queue
      2. **Loads CS** with selector 0x08:
         - GDT index 1 (kernel code segment)
         - RPL = 0 (kernel privilege)
         - TI = 0 (use GDT, not LDT)
      3. **Fetches** new instruction from:
         - Linear address = GDT[1].base + offset
         - With 32-bit code segment attributes
      4. CPU now executes **clean** 32-bit code
    |
  }
  
  problem -> solution: "Fixed by\nfar jump" {
    style: {
      stroke: "${colors.safe}"
      animated: true
      bold: true
    }
  }
}

# ==================== VISUAL FLOW ====================

flow_visual: {
  label: "Address Translation Flow"
  
  real_flow: {
    label: "Real Mode"
    style.fill: "#FEF2F2"
    
    rm_seg: {
      label: "CS=0xF000"
      shape: rectangle
    }
    rm_shift: {
      label: "× 16"
      shape: circle
      style.fill: "${colors.danger}"
      style.font-color: white
    }
    rm_base: {
      label: "0xF0000"
      shape: rectangle
    }
    rm_ip: {
      label: "IP=0xFFF0"
      shape: rectangle
    }
    rm_add: {
      label: "+"
      shape: circle
    }
    rm_result: {
      label: "0xFFFF0\n(1MB-16)"
      shape: rectangle
      style: {
        fill: "${colors.caution}"
        font-color: white
        bold: true
      }
    }
    
    rm_seg -> rm_shift -> rm_base -> rm_add
    rm_ip -> rm_add -> rm_result
  }
  
  protected_flow: {
    label: "Protected Mode"
    style.fill: "#ECFDF5"
    
    pm_cs: {
      label: "CS=0x08"
      shape: rectangle
    }
    pm_idx: {
      label: "Index=1"
      shape: circle
      style.fill: "${colors.meta_purple}"
      style.font-color: white
    }
    pm_gdt: {
      label: "GDT[1]\nBase=0x0\nLimit=4GB"
      shape: cylinder
      style.fill: "${colors.meta_purple}"
      style.font-color: white
    }
    pm_eip: {
      label: "EIP=offset"
      shape: rectangle
    }
    pm_add2: {
      label: "+"
      shape: circle
    }
    pm_result: {
      label: "Linear Addr\n(0 to 4GB)"
      shape: rectangle
      style: {
        fill: "${colors.safe}"
        font-color: white
        bold: true
      }
    }
    
    pm_cs -> pm_idx -> pm_gdt -> pm_add2
    pm_eip -> pm_add2 -> pm_result
  }
}

# Connect the containers
before_container -> transition_container: "Boot sequence" {
  style: {
    stroke-dash: 5
    stroke: "${colors.gray}"
  }
}
transition_container -> after_container: "Mode switch\ncomplete" {
  style: {
    stroke: "${colors.safe}"
    stroke-width: 3
    animated: true
  }
}