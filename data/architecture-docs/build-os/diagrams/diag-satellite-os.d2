vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    boot: "#E8F5E9"
    interrupts: "#E3F2FD"
    memory: "#FFF3E0"
    scheduler: "#F3E5F5"
    hardware: "#FAFAFA"
    userspace: "#FFEBEE"
    flow-data: "#1976D2"
    flow-control: "#388E3C"
    flow-fault: "#D32F2F"
  }
}

title: |md
  # OS Kernel Architecture: Satellite View
  **Complete System Map — All Milestones Interconnected**
| {near: top-center}

direction: down

# ==================== HARDWARE LAYER ====================
hardware: {
  label: Hardware Layer
  style.fill: ${colors.hardware}
  style.stroke: "#424242"
  style.stroke-width: 3

  cpu: CPU {
    style.fill: "#E0E0E0"
    
    registers: Register Set {
      shape: class
      EAX: "uint32 (accumulator)"
      EBX: "uint32 (base)"
      ECX: "uint32 (count)"
      EDX: "uint32 (data)"
      ESI: "uint32 (source index)"
      EDI: "uint32 (dest index)"
      EBP: "uint32 (base pointer)"
      ESP: "uint32 (stack pointer)"
      EIP: "uint32 (instruction pointer)"
      EFLAGS: "uint32 (flags)"
      CS: "uint16 (code segment)"
      DS: "uint16 (data segment)"
      SS: "uint16 (stack segment)"
      CR0: "uint32 (control)"
      CR2: "uint32 (page fault addr)"
      CR3: "uint32 (page directory)"
    }

    tss_unit: Task State Segment {
      shape: class
      ESP0: "uint32 (ring 0 stack)"
      SS0: "uint16 (ring 0 segment)"
      iomap_base: "uint16 (IO bitmap)"
    }

    mmu: MMU {
      style.fill: "#B0BEC5"
      tlb: TLB Cache {
        shape: class
        entries: "32-64 page translations"
      }
      walker: Page Table Walker
    }

    pipeline: Pipeline {
      style.fill: "#B0BEC5"
      fetch: Fetch Unit
      decode: Decode Unit
      execute: Execute Unit
    }
  }

  memory_bus: Memory Bus {
    style.fill: "#E0E0E0"
    ram: Physical RAM {
      shape: cylinder
      style.fill: "#CFD8DC"
    }
    vga_mem: VGA Memory (0xB8000) {
      style.fill: "#CFD8DC"
    }
  }

  io_ports: I/O Ports {
    style.fill: "#E0E0E0"
    pic: PIC 8259 {
      style.fill: "#CFD8DC"
      master: Master (IRQ0-7)
      slave: Slave (IRQ8-15)
    }
    pit: PIT Channel 0 {
      style.fill: "#CFD8DC"
    }
    keyboard_ctrl: Keyboard Controller (0x60) {
      style.fill: "#CFD8DC"
    }
    serial: Serial COM1 (0x3F8) {
      style.fill: "#CFD8DC"
    }
  }
}

# ==================== MILESTONE 1: BOOT LAYER ====================
m1_boot: {
  label: "M1: Bootloader & GDT"
  link: "#build-os-m1"
  style.fill: ${colors.boot}
  style.stroke: "#2E7D32"
  style.stroke-width: 2

  boot_sequence: Boot Sequence {
    mbr: MBR (512 bytes) {
      style.fill: "#C8E6C9"
    }
    bios_handoff: BIOS Handoff (0x7C00) {
      style.fill: "#C8E6C9"
    }
    a20_enable: A20 Line Enable {
      style.fill: "#C8E6C9"
    }
    kernel_load: Kernel Load (0x100000) {
      style.fill: "#C8E6C9"
    }
  }

  gdt: Global Descriptor Table {
    style.fill: "#A5D6A7"
    
    null_desc: Null Descriptor {
      style.fill: "#81C784"
    }
    kernel_code: Kernel Code (0x08) {
      shape: class
      base: "0x00000000"
      limit: "0xFFFFF (4GB)"
      access: "Present | Ring 0 | Exec | Read"
      style.fill: "#81C784"
    }
    kernel_data: Kernel Data (0x10) {
      shape: class
      base: "0x00000000"
      limit: "0xFFFFF (4GB)"
      access: "Present | Ring 0 | Write"
      style.fill: "#81C784"
    }
    user_code: User Code (0x1B) {
      shape: class
      base: "0x00000000"
      limit: "0xFFFFF (4GB)"
      access: "Present | Ring 3 | Exec | Read"
      style.fill: "#81C784"
    }
    user_data: User Data (0x23) {
      shape: class
      base: "0x00000000"
      limit: "0xFFFFF (4GB)"
      access: "Present | Ring 3 | Write"
      style.fill: "#81C784"
    }
    tss_desc: TSS Descriptor (0x30) {
      style.fill: "#81C784"
    }
  }

  kernel_entry: Kernel Entry {
    style.fill: "#A5D6A7"
    bss_zero: Zero BSS Section
    call_main: Call kernel_main()
  }

  mbr -> bios_handoff: "BIOS loads\nat 0x7C00"
  bios_handoff -> a20_enable: "Enable A20\nfor >1MB access"
  a20_enable -> kernel_load: "Load kernel\nto 0x100000"
  kernel_load -> gdt: "Load GDTR\nlgdt [gdt_desc]"
  gdt -> kernel_entry: "Far jump\njmp 0x08:entry"
}

# ==================== MILESTONE 2: INTERRUPT LAYER ====================
m2_interrupts: {
  label: "M2: Interrupts & Exceptions"
  link: "#build-os-m2"
  style.fill: ${colors.interrupts}
  style.stroke: "#1565C0"
  style.stroke-width: 2

  idt: Interrupt Descriptor Table {
    style.fill: "#BBDEFB"
    
    exceptions: CPU Exceptions (0-31) {
      style.fill: "#90CAF9"
      div_zero: "#0: Divide Error"
      invalid_op: "#6: Invalid Opcode"
      double_fault: "#8: Double Fault"
      gpf: "#13: General Protection"
      page_fault: "#14: Page Fault"
    }

    irq_handlers: Hardware IRQs (32-47) {
      style.fill: "#90CAF9"
      timer_irq: "#32: Timer (IRQ0)"
      kb_irq: "#33: Keyboard (IRQ1)"
      cascade: "#34: Cascade (IRQ2)"
      rtc_irq: "#40: RTC (IRQ8)"
    }

    syscall_gate: System Call (0x80) {
      style.fill: "#64B5F6"
      dpl: "DPL=3 (user callable)"
    }
  }

  pic_config: PIC Configuration {
    style.fill: "#BBDEFB"
    remap: Remap IRQs {
      master_offset: "IRQ0-7 → Vectors 32-39"
      slave_offset: "IRQ8-15 → Vectors 40-47"
    }
    eoi: End of Interrupt {
      master_eoi: "outb(0x20, 0x20)"
      slave_eoi: "outb(0xA0, 0x20)\noutb(0x20, 0x20)"
    }
  }

  interrupt_flow: Interrupt Flow {
    style.fill: "#BBDEFB"
    
    stub: Assembly Stub {
      pusha: "pusha (save registers)"
      push_segments: "push ds, es, fs, gs"
      load_kernel_ds: "mov ax, 0x10"
      call_handler: "call c_handler"
      restore: "pop segments, popa"
      iret: "iret (restore EIP, CS, EFLAGS)"
    }

    c_handler: C Handler {
      check_vector: "if (int_no < 32) exception"
      call_specific: "Call specific handler"
      send_eoi: "pic_send_eoi(irq)"
    }
  }

  keyboard: Keyboard Driver {
    style.fill: "#BBDEFB"
    read_scancode: "inb(0x60)"
    scancode_table: Scancode → ASCII Table
    circular_buffer: Circular Buffer (256 chars)
    shift_state: Shift Key State
  }

  timer: Timer Driver {
    style.fill: "#BBDEFB"
    pit_config: "PIT Channel 0 @ 100Hz"
    tick_counter: "volatile uint64_t timer_ticks"
    scheduler_trigger: "Triggers scheduler"
  }

  idt -> interrupt_flow.stub: "CPU loads\nCS:EIP from IDT"
  interrupt_flow.stub -> interrupt_flow.c_handler: "Push stack\npointer"
  interrupt_flow.c_handler -> pic_config.eoi: "Send EOI\nbefore return"
  hardware.io_ports.keyboard_ctrl -> keyboard.read_scancode: "Scancode\nready"
  keyboard.read_scancode -> keyboard.circular_buffer: "Store\ncharacter"
}

# ==================== MILESTONE 3: MEMORY LAYER ====================
m3_memory: {
  label: "M3: Memory Management"
  link: "#build-os-m3"
  style.fill: ${colors.memory}
  style.stroke: "#E65100"
  style.stroke-width: 2

  physical_memory: Physical Memory Map {
    style.fill: "#FFE0B2"
    
    low_mem: "0x00000000-0x000FFFFF: Reserved (BIOS, VGA)"
    kernel_region: "0x00100000-0x003FFFFF: Kernel Binary"
    available: "0x00400000+: Available RAM"
    
    low_mem.style.fill: "#FFCC80"
    kernel_region.style.fill: "#FFCC80"
    available.style.fill: "#A5D6A7"
  }

  pmm: Physical Frame Allocator {
    style.fill: "#FFCC80"
    
    bitmap: Bitmap Allocator {
      shape: class
      storage: "uint32_t bitmap[32768]"
      frame_size: "4096 bytes (4KB)"
      max_frames: "1M frames = 4GB"
      overhead: "128KB metadata"
    }
    
    operations: Operations {
      alloc: "pmm_alloc_frame() → frame_addr"
      free: "pmm_free_frame(addr)"
      mark_used: "pmm_mark_used(addr)"
    }
  }

  vmm: Virtual Memory Manager {
    style.fill: "#FFCC80"
    
    page_tables: Two-Level Page Tables {
      style.fill: "#FFB74D"
      
      page_directory: Page Directory (4KB) {
        entries: "1024 PDEs"
        coverage: "Each PDE covers 4MB"
      }
      
      page_table: Page Table (4KB) {
        entries: "1024 PTEs"
        coverage: "Each PTE covers 4KB"
      }
    }

    mappings: Address Space Layout {
      style.fill: "#FFB74D"
      
      identity: Identity Map {
        range: "0x00000000 - 0x003FFFFF"
        purpose: "Kernel + VGA + Boot"
      }
      
      higher_half: Higher Half Kernel {
        range: "0xC0000000 - 0xC03FFFFF"
        maps_to: "0x00000000 - 0x003FFFFF"
      }
      
      kernel_heap: Kernel Heap {
        range: "0xD0000000 - 0xDFFFFFFF"
        size: "256MB virtual"
      }
      
      user_space: User Space {
        range: "0x00000000 - 0xBFFFFFFF"
        per_process: "Unique per process"
      }
    }

    tlb_mgmt: TLB Management {
      invlpg: "invlpg (addr) - single entry"
      cr3_reload: "mov cr3, eax - full flush"
      global_pages: "PAGE_GLOBAL flag"
    }
  }

  kmalloc: Kernel Heap {
    style.fill: "#FFCC80"
    
    block_header: Block Header {
      shape: class
      size: "uint32_t"
      free: "uint32_t"
      next: "block_header*"
    }
    
    operations: Operations {
      alloc: "kmalloc(size) → ptr"
      free: "kfree(ptr)"
    }
    
    strategy: "First-fit with splitting"
  }

  page_fault_handler: Page Fault Handler {
    style.fill: "#FFAB91"
    
    read_cr2: "mov %cr2, %eax"
    decode_error: Decode Error Code {
      present_bit: "Bit 0: Not present vs protection"
      write_bit: "Bit 1: Read vs write"
      user_bit: "Bit 2: Kernel vs user"
    }
    action: "Panic (for now)\nFuture: demand paging, COW"
  }

  physical_memory -> pmm.bitmap: "E820/multiboot\nprovides map"
  pmm.operations.alloc -> vmm.page_tables: "Allocate frames\nfor page tables"
  vmm.mappings -> hardware.cpu.mmu: "CR3 points to\npage directory"
  hardware.cpu.mmu.tlb -> vmm.tlb_mgmt: "Must flush on\nmodification"
}

# ==================== MILESTONE 4: SCHEDULER LAYER ====================
m4_scheduler: {
  label: "M4: Processes & Scheduling"
  link: "#build-os-m4"
  style.fill: ${colors.scheduler}
  style.stroke: "#7B1FA2"
  style.stroke-width: 2

  pcb: Process Control Block {
    style.fill: "#E1BEE7"
    
    cpu_state: CPU State {
      shape: class
      eax: "uint32_t"
      ebx: "uint32_t"
      ecx: "uint32_t"
      edx: "uint32_t"
      esi: "uint32_t"
      edi: "uint32_t"
      ebp: "uint32_t"
      esp: "uint32_t"
      eip: "uint32_t"
      eflags: "uint32_t (0x202 = IF set)"
      cs: "uint32_t"
      ds: "uint32_t"
      es: "uint32_t"
      fs: "uint32_t"
      gs: "uint32_t"
      ss: "uint32_t"
      cr3: "uint32_t (page directory)"
    }
    
    process_info: Process Info {
      shape: class
      pid: "uint32_t"
      state: "READY | RUNNING | BLOCKED | ZOMBIE"
      kernel_stack: "uint32_t (top address)"
      user_stack: "uint32_t (if user mode)"
      is_user: "int (ring 3 vs ring 0)"
    }
  }

  scheduler: Round-Robin Scheduler {
    style.fill: "#CE93D8"
    
    ready_queue: Ready Queue {
      structure: "Linked list of PCBs"
      quantum: "10ms (100Hz timer)"
    }
    
    algorithm: Schedule Algorithm {
      pick_next: "Rotate through ready processes"
      mark_ready: "old->state = READY"
      mark_running: "new->state = RUNNING"
    }
  }

  context_switch: Context Switch {
    style.fill: "#BA68C8"
    style.font-color: white
    
    save_old: Save Old Process {
      save_registers: "Save GP registers to PCB"
      save_esp: "Save ESP to PCB"
      save_eip: "Return addr → PCB.eip"
      save_cr3: "Save CR3 to PCB"
    }
    
    load_new: Load New Process {
      update_tss: "tss.esp0 = new->kernel_stack"
      load_cr3: "mov new->cr3, %cr3"
      load_segments: "Load DS, ES, FS, GS"
      load_esp: "mov new->esp, %esp"
    }
    
    iret_resume: Resume via IRET {
      push_eflags: "Push EFLAGS"
      push_cs: "Push CS"
      push_eip: "Push EIP"
      push_user_stack: "If user: push SS, ESP"
      execute_iret: "iret"
    }
  }

  user_kernel_boundary: User/Kernel Boundary {
    style.fill: "#AB47BC"
    style.font-color: white
    
    user_to_kernel: User → Kernel {
      trigger: "INT 0x80 or exception"
      cpu_action: "Load SS0:ESP0 from TSS"
      stack_switch: "Switch to kernel stack"
      push_state: "Push SS, ESP, EFLAGS, CS, EIP"
      jump_handler: "Jump to IDT handler"
    }
    
    kernel_to_user: Kernel → User {
      via_iret: "iret instruction"
      restore_stack: "Pop SS, ESP if RPL=3"
      restore_state: "Pop EFLAGS, CS, EIP"
      privilege_drop: "CPU switches to ring 3"
    }
  }

  syscalls: System Calls {
    style.fill: "#CE93D8"
    
    syscall_table: Syscall Table {
      "0": "sys_exit(status)"
      "1": "sys_write(fd, buf, len)"
      "2": "sys_read(fd, buf, len)"
    }
    
    convention: Calling Convention {
      number: "EAX = syscall number"
      args: "EBX, ECX, EDX = arguments"
      return: "EAX = return value"
      trigger: "INT 0x80"
    }
  }

  pcb -> scheduler.ready_queue: "PCBs linked\nin queue"
  scheduler.algorithm -> context_switch: "Pick next\nprocess"
  context_switch.update_tss -> hardware.cpu.tss_unit: "Update TSS\nESP0"
  context_switch.load_cr3 -> hardware.cpu.registers.CR3: "Load new\npage directory"
  user_kernel_boundary.user_to_kernel -> hardware.cpu.tss_unit: "CPU reads\nTSS on ring transition"
}

# ==================== USERSPACE LAYER ====================
userspace: {
  label: Userspace (Ring 3)
  style.fill: ${colors.userspace}
  style.stroke: "#C62828"
  style.stroke-dash: 5

  user_process: User Process {
    style.fill: "#FFCDD2"
    
    code: User Code {
      virtual_range: "0x00001000+"
      permissions: "User | Executable"
    }
    
    data: User Data {
      virtual_range: "0x00400000+"
      permissions: "User | Writable"
    }
    
    stack: User Stack {
      virtual_range: "0xBFFFF000-0xBFFFFFFF"
      permissions: "User | Writable"
      grows: "Downward"
    }
  }

  user_libc: Minimal Libc {
    style.fill: "#FFCDD2"
    syscall_wrappers: "sys_exit(), sys_write(), sys_read()"
  }

  user_process.code -> user_libc.syscall_wrappers: "Call\nwrapper"
  user_libc.syscall_wrappers -> m4_scheduler.syscalls: "INT 0x80\nwith args"
}

# ==================== DATA FLOW ARROWS ====================

# Keyboard data flow
hardware.io_ports.keyboard_ctrl -> m2_interrupts.keyboard: "1. IRQ1 fires\n(scancode ready)" {
  style.stroke: ${colors.flow-data}
  style.stroke-width: 3
  style.animated: true
}
m2_interrupts.keyboard -> m2_interrupts.keyboard.circular_buffer: "2. Convert to ASCII\nstore in buffer" {
  style.stroke: ${colors.flow-data}
  style.stroke-width: 3
}
m2_interrupts.keyboard.circular_buffer -> userspace.user_process: "3. sys_read() returns\nto user process" {
  style.stroke: ${colors.flow-data}
  style.stroke-width: 3
  style.stroke-dash: 5
}

# Timer → Scheduler → Context Switch flow
hardware.io_ports.pit -> m2_interrupts.timer: "1. IRQ0 fires\n(100Hz tick)" {
  style.stroke: ${colors.flow-control}
  style.stroke-width: 3
  style.animated: true
}
m2_interrupts.timer -> m4_scheduler.scheduler: "2. Call schedule()\non tick" {
  style.stroke: ${colors.flow-control}
  style.stroke-width: 3
}
m4_scheduler.scheduler -> m4_scheduler.context_switch: "3. Pick next PCB\nperform switch" {
  style.stroke: ${colors.flow-control}
  style.stroke-width: 3
}
m4_scheduler.context_switch -> m4_scheduler.pcb: "4. Save/restore\nregister state" {
  style.stroke: ${colors.flow-control}
  style.stroke-width: 3
}

# Page fault flow
hardware.cpu.registers.CR2 -> m3_memory.page_fault_handler: "1. CR2 contains\nfaulting address" {
  style.stroke: ${colors.flow-fault}
  style.stroke-width: 3
  style.animated: true
}
m3_memory.page_fault_handler -> m3_memory.pmm: "2. May allocate\nnew frame" {
  style.stroke: ${colors.flow-fault}
  style.stroke-width: 3
}
m3_memory.pmm -> m3_memory.vmm.page_tables: "3. Map frame\nin page table" {
  style.stroke: ${colors.flow-fault}
  style.stroke-width: 3
}

# ==================== LAYER DEPENDENCIES ====================
m1_boot -> hardware: "Depends on:\nCPU, Memory Bus, I/O" {
  style.stroke: "#616161"
  style.stroke-dash: 3
}

m2_interrupts -> m1_boot: "Depends on:\nGDT, Kernel Entry" {
  style.stroke: "#616161"
  style.stroke-dash: 3
}

m3_memory -> m2_interrupts: "Depends on:\nException Handlers" {
  style.stroke: "#616161"
  style.stroke-dash: 3
}

m4_scheduler -> m3_memory: "Depends on:\nPage Tables, kmalloc" {
  style.stroke: "#616161"
  style.stroke-dash: 3
}

userspace -> m4_scheduler: "Depends on:\nScheduler, Syscalls" {
  style.stroke: "#616161"
  style.stroke-dash: 3
}

# ==================== LEGEND ====================
legend: {
  near: bottom-right
  style.fill: white
  style.stroke: "#616161"
  
  title: Legend
  
  data_flow: "Blue animated = Data flow (keyboard)" {
    shape: text
    style.font-color: ${colors.flow-data}
  }
  
  control_flow: "Green animated = Control flow (timer)" {
    shape: text
    style.font-color: ${colors.flow-control}
  }
  
  fault_flow: "Red animated = Fault flow (page fault)" {
    shape: text
    style.font-color: ${colors.flow-fault}
  }
  
  dependency: "Gray dashed = Layer dependency" {
    shape: text
    style.font-color: "#616161"
  }
  
  privilege: Ring Boundaries {
    ring0: "Ring 0 (Kernel): Full hardware access"
    ring3: "Ring 3 (User): Restricted, uses TSS for stack switch"
  }
}

# ==================== KEY METRICS ====================
metrics: {
  near: bottom-left
  style.fill: white
  style.stroke: "#616161"
  
  title: "Key Metrics & Constants"
  
  timing: Timing {
    timer_freq: "Timer: 100Hz (10ms quantum)"
    context_switch: "Context switch: ~1-5 µs"
    tlb_flush: "TLB flush (CR3 reload): ~100-500 cycles"
    interrupt_latency: "Interrupt latency: ~1-2 µs"
  }
  
  memory: Memory Sizes {
    page_size: "Page size: 4KB (4096 bytes)"
    page_table: "Page table: 4KB (1024 entries)"
    page_directory: "Page directory: 4KB (1024 entries)"
    kernel_stack: "Kernel stack: 4KB per process"
    pcb_size: "PCB: ~256 bytes"
  }
  
  limits: Limits {
    max_processes: "Max processes: 16"
    kernel_heap: "Kernel heap: 256MB virtual"
    user_space: "User space: ~3GB per process"
  }
}