vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # OS Kernel Architecture: Satellite View
  **Preemptive Multitasking x86 Kernel**
| {near: top-center}

back_to_docs: ğŸ“š Back to Docs {
  link: "#satellite-map"
  near: top-right
  shape: text
  style.font-size: 16
}

direction: down

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LAYER 1: BOOT SEQUENCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

boot_layer: Boot Sequence {
  link: "#boot-process"
  style.fill: "#E8F5E9"
  style.stroke: "#4CAF50"
  style.stroke-width: 3

  bios: BIOS/UEFI {
    shape: rectangle
    style.fill: "#C8E6C9"
    tooltip: "Power-on self-test, loads MBR from disk"
  }

  mbr: Master Boot Record {
    shape: cylinder
    style.fill: "#A5D6A7"
    tooltip: "First 512 bytes on disk, contains bootloader"
  }

  bootloader: Bootloader (Stage 2) {
    shape: rectangle
    style.fill: "#81C784"
    tooltip: "Loads kernel, sets up GDT, enters protected mode"
  }

  bios -> mbr: "Read sector 0\n(LBA 0)" {
    style.stroke: "#2E7D32"
    style.stroke-width: 2
  }

  mbr -> bootloader: "Jump to 0x7C00\n(16-bit real mode)" {
    style.stroke: "#2E7D32"
    style.stroke-width: 2
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LAYER 2: CPU CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cpu_layer: CPU Configuration {
  link: "#gdt-setup"
  style.fill: "#E3F2FD"
  style.stroke: "#2196F3"
  style.stroke-width: 3

  gdt: Global Descriptor Table {
    link: "#gdt-structure"
    style.fill: "#BBDEFB"
    tooltip: "Segment descriptors for code/data, TSS"
    
    null_desc: Null Descriptor {
      style.fill: "#90CAF9"
      tooltip: "Required, all zeros"
    }
    kernel_code: Kernel Code {
      style.fill: "#64B5F6"
      tooltip: "Base=0, Limit=4GB, DPL=0, Executable"
    }
    kernel_data: Kernel Data {
      style.fill: "#64B5F6"
      tooltip: "Base=0, Limit=4GB, DPL=0, Read/Write"
    }
    user_code: User Code {
      style.fill: "#42A5F5"
      tooltip: "Base=0, Limit=4GB, DPL=3, Executable"
    }
    user_data: User Data {
      style.fill: "#42A5F5"
      tooltip: "Base=0, Limit=4GB, DPL=3, Read/Write"
    }
    tss_entry: TSS Descriptor {
      style.fill: "#2196F3"
      tooltip: "Task State Segment for ring transitions"
    }
  }

  gdtr: GDTR Register {
    shape: diamond
    style.fill: "#1E88E5"
    tooltip: "LGDT loads base address and limit"
  }

  gdtr -> gdt: "Points to GDT\n(6 bytes: limit + base)" {
    style.stroke: "#0D47A1"
    style.stroke-width: 2
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LAYER 3: INTERRUPT HANDLING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interrupt_layer: Interrupt Handling {
  link: "#idt-setup"
  style.fill: "#FFF3E0"
  style.stroke: "#FF9800"
  style.stroke-width: 3

  hardware_ints: Hardware Interrupts {
    style.fill: "#FFE0B2"
    tooltip: "IRQ 0-15 via PIC"
    
    timer: Timer (IRQ0) {
      style.fill: "#FFCC80"
      tooltip: "100Hz tick, triggers scheduler"
    }
    keyboard: Keyboard (IRQ1) {
      style.fill: "#FFB74D"
      tooltip: "User input"
    }
    cascade: Cascade (IRQ2) {
      style.fill: "#FFA726"
      tooltip: "PIC chaining"
    }
  }

  exceptions: CPU Exceptions {
    style.fill: "#FFE0B2"
    tooltip: "Faults, traps, aborts"
    
    divide: "#DE Divide" {
      style.fill: "#FFCC80"
    }
    pagefault: "#PF Page Fault" {
      style.fill: "#FF8A65"
      tooltip: "CR2 contains faulting address"
    }
    gpf: "#GP General Protection" {
      style.fill: "#FF7043"
      tooltip: "Segment/privilege violation"
    }
    doubleflt: "#DF Double Fault" {
      style.fill: "#E53935"
      tooltip: "Exception during exception handler"
    }
  }

  software_ints: Software Interrupts {
    style.fill: "#FFE0B2"
    
    syscall: "INT 0x80" {
      style.fill: "#81C784"
      tooltip: "System call gate (DPL=3)"
    }
  }

  idt: Interrupt Descriptor Table {
    link: "#idt-structure"
    style.fill: "#FFB74D"
    tooltip: "256 interrupt gates"
    
    idt_entry: Gate Entry {
      style.fill: "#FFA726"
      tooltip: "Offset low/high, selector, flags"
    }
  }

  idtr: IDTR Register {
    shape: diamond
    style.fill: "#FF9800"
    tooltip: "LIDT loads base and limit"
  }

  isr_table: ISR Handlers {
    style.fill: "#FF9800"
    tooltip: "Assembly stubs push error code, call C handler"
  }

  hardware_ints.timer -> idt: "Vector 32" {style.stroke: "#E65100"}
  hardware_ints.keyboard -> idt: "Vector 33" {style.stroke: "#E65100"}
  exceptions.pagefault -> idt: "Vector 14" {style.stroke: "#E65100"}
  software_ints.syscall -> idt: "Vector 128" {style.stroke: "#4CAF50"}
  
  idtr -> idt: "Points to IDT" {style.stroke: "#E65100"}
  idt -> isr_table: "Jump to handler" {style.stroke: "#E65100"}
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LAYER 4: MEMORY MANAGEMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

memory_layer: Memory Management {
  link: "#paging-setup"
  style.fill: "#F3E5F5"
  style.stroke: "#9C27B0"
  style.stroke-width: 3

  physical_mem: Physical Memory {
    style.fill: "#E1BEE7"
    
    low_mem: Low Memory (0-1MB) {
      style.fill: "#CE93D8"
      tooltip: "BIOS, bootloader, reserved"
    }
    kernel_space: Kernel Space (1MB+) {
      style.fill: "#BA68C8"
      tooltip: "Kernel code, data, heap"
    }
    page_frames: Page Frames {
      style.fill: "#AB47BC"
      tooltip: "4KB blocks, bitmap allocator"
    }
  }

  paging: Paging Structures {
    link: "#page-tables"
    style.fill: "#E1BEE7"
    
    cr3: CR3 (PDBR) {
      shape: diamond
      style.fill: "#9C27B0"
      tooltip: "Current page directory physical addr"
    }
    
    page_dir: Page Directory {
      style.fill: "#BA68C8"
      tooltip: "1024 entries, each covers 4MB"
      
      pd_entry: PDE {
        style.fill: "#AB47BC"
        tooltip: "Present, R/W, User, PS flags"
      }
    }
    
    page_table: Page Table {
      style.fill: "#9C27B0"
      tooltip: "1024 entries, each covers 4KB"
      
      pt_entry: PTE {
        style.fill: "#8E24AA"
        tooltip: "Present, R/W, User, Accessed, Dirty"
      }
    }
    
    cr3 -> page_dir: "Points to PD\n(4KB aligned)" {
      style.stroke: "#4A148C"
    }
    page_dir -> page_table: "Points to PT" {
      style.stroke: "#4A148C"
    }
    page_table -> physical_mem: "Maps to frame" {
      style.stroke: "#4A148C"
    }
  }

  virtual_spaces: Virtual Address Spaces {
    style.fill: "#E1BEE7"
    
    kernel_vspace: Kernel Space (0xC0000000+) {
      style.fill: "#7E57C2"
      tooltip: "Identity mapped, supervisor-only"
    }
    user_vspace: User Space (0x00000000-0xBFFFFFFF) {
      style.fill: "#9575CD"
      tooltip: "Per-process, user-accessible"
    }
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LAYER 5: PROCESS SCHEDULER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

scheduler_layer: Process Scheduler {
  link: "#preemptive-scheduling"
  style.fill: "#FFEBEE"
  style.stroke: "#F44336"
  style.stroke-width: 3

  pcb_pool: Process Control Blocks {
    style.fill: "#FFCDD2"
    
    pcb: PCB {
      link: "#pcb-structure"
      style.fill: "#EF9A9A"
      tooltip: "Process state container"
      
      pid: PID {
        style.fill: "#E57373"
      }
      registers: Registers {
        style.fill: "#EF5350"
        tooltip: "EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, EIP, EFLAGS"
      }
      segments: Segments {
        style.fill: "#E53935"
        tooltip: "CS, DS, ES, FS, GS, SS"
      }
      cr3_field: CR3 {
        style.fill: "#D32F2F"
        tooltip: "Page directory physical address"
      }
      kstack: Kernel Stack {
        style.fill: "#C62828"
        tooltip: "ESP0 for ring 3â†’0 transitions"
      }
      state: State {
        style.fill: "#B71C1C"
        tooltip: "READY, RUNNING, BLOCKED, ZOMBIE"
      }
    }
  }

  runqueue: Run Queue {
    style.fill: "#FFCDD2"
    tooltip: "Circular queue of READY processes"
    
    proc_a: Process A {
      style.fill: "#81C784"
      tooltip: "RUNNING (current)"
    }
    proc_b: Process B {
      style.fill: "#FFB74D"
      tooltip: "READY"
    }
    proc_c: Process C {
      style.fill: "#FFB74D"
      tooltip: "READY"
    }
    
    proc_a -> proc_b -> proc_c -> proc_a: "Round-robin" {
      style.stroke: "#B71C1C"
      style.stroke-dash: 3
    }
  }

  context_switch: Context Switch {
    link: "#context-switch"
    style.fill: "#EF5350"
    tooltip: "Assembly routine: save old, load new"
    
    save_state: Save State {
      style.fill: "#E53935"
      tooltip: "Push registers to old PCB"
    }
    load_state: Load State {
      style.fill: "#E53935"
      tooltip: "Pop registers from new PCB"
    }
    switch_cr3: Switch CR3 {
      style.fill: "#D32F2F"
      tooltip: "Load new page directory"
    }
    update_tss: Update TSS {
      style.fill: "#C62828"
      tooltip: "Set ESP0 for new process"
    }
    
    save_state -> load_state -> switch_cr3 -> update_tss: "" {
      style.stroke: "#B71C1C"
    }
  }

  tss: Task State Segment {
    link: "#tss-setup"
    style.fill: "#FFCDD2"
    tooltip: "Hardware task switching metadata"
    
    esp0: ESP0 {
      style.fill: "#E57373"
      tooltip: "Kernel stack pointer for ring 0"
    }
    ss0: SS0 {
      style.fill: "#E57373"
      tooltip: "Kernel stack segment (0x10)"
    }
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CROSS-LAYER CONNECTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

boot_layer.bootloader -> cpu_layer.gdt: "1. Load GDT\n(LGDT instruction)" {
  style.stroke: "#4CAF50"
  style.stroke-width: 3
  style.animated: true
}

cpu_layer.gdt -> interrupt_layer.idt: "2. Selector in IDT gates\nreferences GDT" {
  style.stroke: "#2196F3"
  style.stroke-width: 2
}

boot_layer.bootloader -> memory_layer.paging: "3. Enable paging\n(Set CR0.PG)" {
  style.stroke: "#9C27B0"
  style.stroke-width: 3
  style.animated: true
}

interrupt_layer.hardware_ints.timer -> scheduler_layer.runqueue: "4. Timer IRQ triggers\nschedule()" {
  style.stroke: "#FF9800"
  style.stroke-width: 3
  style.animated: true
  label: "Every 10ms\n(100Hz)"
}

scheduler_layer.context_switch -> memory_layer.cr3: "5. Load new CR3\n(TLB flush)" {
  style.stroke: "#F44336"
  style.stroke-width: 3
  style.animated: true
}

scheduler_layer.context_switch -> cpu_layer.gdt.tss_entry: "6. Update TSS.ESP0\n(for ring transitions)" {
  style.stroke: "#F44336"
  style.stroke-width: 2
}

memory_layer.virtual_spaces.user_vspace -> scheduler_layer.pcb_pool: "7. Each PCB has\nits own CR3" {
  style.stroke: "#9C27B0"
  style.stroke-width: 2
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LEGEND
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

legend: {
  near: bottom-right
  style.fill: "#FAFAFA"
  style.stroke: "#BDBDBD"
  
  title: Legend
  
  boot: Boot Phase {
    shape: rectangle
    style.fill: "#E8F5E9"
  }
  cpu: CPU Config {
    shape: rectangle
    style.fill: "#E3F2FD"
  }
  interrupt: Interrupts {
    shape: rectangle
    style.fill: "#FFF3E0"
  }
  memory: Memory {
    shape: rectangle
    style.fill: "#F3E5F5"
  }
  scheduler: Scheduler {
    shape: rectangle
    style.fill: "#FFEBEE"
  }
  
  data_flow: Data Flow {
    shape: text
    style.font-color: "#4CAF50"
  }
  control_flow: Control Flow {
    shape: text
    style.font-color: "#F44336"
  }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# KEY METRICS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

metrics: {
  near: bottom-left
  style.fill: "#ECEFF1"
  
  title: Key Metrics
  
  context_sw: "Context Switch: ~40 cycles" {
    style.font: mono
  }
  tlb_flush: "TLB Flush: Full on CR3 reload" {
    style.font: mono
  }
  timer_freq: "Timer: 100Hz (10ms quantum)" {
    style.font: mono
  }
  addr_space: "Address Space: 4GB per process" {
    style.font: mono
  }
  page_size: "Page Size: 4KB" {
    style.font: mono
  }
}