vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    running: "#4CAF50"
    ready: "#2196F3"
    waiting: "#9E9E9E"
    arrow: "#FF5722"
  }
}

title: Round-Robin Scheduler: Ready Queue Rotation {
  near: top-center
  shape: text
  style: {
    font-size: 32
    bold: true
    underline: true
  }
}

t0: "Time T0: Initial State" {
  style.fill: "#E3F2FD"
  
  label_t0: |md
    **Ready Queue:** [P1, P2, P3]
    **Running:** Idle
  |
  
  queue_t0: {
    grid-columns: 3
    grid-gap: 0
    
    p1_t0: P1 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
    p2_t0: P2 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
    p3_t0: P3 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
  }
  
  cpu_t0: CPU {
    style.fill: ${colors.waiting}
    state_t0: "Idle"
  }
  
  queue_t0.p1_t0 -> cpu_t0: "schedule_next()\npicks P1" {
    style.stroke: ${colors.arrow}
    style.stroke-width: 3
    style.animated: true
  }
}

t1: "Time T1: P1 Running (Quantum Start)" {
  style.fill: "#E8F5E9"
  
  label_t1: |md
    **Ready Queue:** [P2, P3]
    **Running:** P1
    **Quantum:** 10ms remaining
  |
  
  queue_t1: {
    grid-columns: 2
    grid-gap: 0
    
    p2_t1: P2 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
    p3_t1: P3 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
  }
  
  cpu_t1: CPU {
    style.fill: ${colors.running}
    state_t1: "Executing P1\nEIP=0x1000\nESP=0x9000"
    state_t1.style.font-color: white
  }
  
  pcb_t1: "P1 PCB" {
    shape: class
    pid: uint32_t = 1
    state: READY -> RUNNING
    eip: 0x00001000
    esp: 0x00009000
    time_slice: 10
  }
}

t2: "Time T2: Timer Interrupt (Quantum Expired)" {
  style.fill: "#FFF3E0"
  
  label_t2: |md
    **Trigger:** IRQ0 (Timer)
    **Action:** Save P1 state -> Move to queue tail -> Load P2
  |
  
  interrupt_t2: "IRQ0 Timer" {
    shape: diamond
    style.fill: ${colors.arrow}
    style.font-color: white
  }
  
  save_t2: "Save P1 State" {
    pcb_save: |md
      PCB[1].eax = current_eax
      PCB[1].eip = return_addr
      PCB[1].state = READY
    |
  }
  
  rotate_t2: "Rotate Queue" {
    code_rotate: |md
      queue.remove(P1)
      queue.append(P1)
      // Queue now: [P2, P3, P1]
    |
  }
  
  interrupt_t2 -> save_t2: "timer_handler()"
  save_t2 -> rotate_t2: "schedule()"
}

t3: "Time T3: P2 Running (After Context Switch)" {
  style.fill: "#E8F5E9"
  
  label_t3: |md
    **Ready Queue:** [P3, P1]
    **Running:** P2
    **Context Switch Cost:** ~1-5 us
  |
  
  queue_t3: {
    grid-columns: 2
    grid-gap: 0
    
    p3_t3: P3 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
    p1_t3: P1 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
  }
  
  cpu_t3: CPU {
    style.fill: ${colors.running}
    state_t3: "Executing P2\nEIP=0x2000\nESP=0xA000"
    state_t3.style.font-color: white
  }
  
  pcb_t3: "P2 PCB" {
    shape: class
    pid: uint32_t = 2
    state: READY -> RUNNING
    eip: 0x00002000
    esp: 0x0000A000
    time_slice: 10
  }
}

t4: "Time T4: P3 Running (Second Rotation)" {
  style.fill: "#E8F5E9"
  
  label_t4: |md
    **Ready Queue:** [P1, P2]
    **Running:** P3
  |
  
  queue_t4: {
    grid-columns: 2
    grid-gap: 0
    
    p1_t4: P1 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
    p2_t4: P2 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
  }
  
  cpu_t4: CPU {
    style.fill: ${colors.running}
    state_t4: "Executing P3"
    state_t4.style.font-color: white
  }
}

t5: "Time T5: Cycle Repeats (P1 Again)" {
  style.fill: "#E8F5E9"
  
  label_t5: |md
    **Ready Queue:** [P2, P3]
    **Running:** P1 (Round Complete!)
  |
  
  queue_t5: {
    grid-columns: 2
    grid-gap: 0
    
    p2_t5: P2 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
    p3_t5: P3 {
      class: ready_proc
      style.fill: ${colors.ready}
      style.font-color: white
    }
  }
  
  cpu_t5: CPU {
    style.fill: ${colors.running}
    state_t5: "Executing P1\n(Resumed)"
    state_t5.style.font-color: white
  }
}

fairness: "Fairness Guarantee" {
  style.fill: "#F3E5F5"
  
  guarantee: ||md
    ### Equal CPU Time Distribution
    
    With quantum = 10ms and 3 processes:
    
    | Process | Time per Round | % CPU |
    |---------|---------------|-------|
    | P1      | 10ms          | 33.3% |
    | P2      | 10ms          | 33.3% |
    | P3      | 10ms          | 33.3% |
    
    **No starvation:** Every process runs once per cycle.
  ||
}

flow: "State Evolution Flow" {
  t0 -> t1: "schedule_next()" {
    style.stroke: ${colors.arrow}
    style.stroke-width: 2
  }
  t1 -> t2: "timer (10ms)" {
    style.stroke: ${colors.arrow}
    style.stroke-width: 2
  }
  t2 -> t3: "context_switch()" {
    style.stroke: ${colors.arrow}
    style.stroke-width: 2
  }
  t3 -> t4: "timer (10ms)" {
    style.stroke: ${colors.arrow}
    style.stroke-width: 2
  }
  t4 -> t5: "timer (10ms)" {
    style.stroke: ${colors.arrow}
    style.stroke-width: 2
  }
}

code_impl: "Queue Implementation" {
  style.fill: "#ECEFF1"
  
  code: ||c
    void schedule_next(void) {
        // Save current to ready queue tail
        if (current_process != NULL) {
            current_process->state = READY;
            queue_append(ready_queue, current_process);
        }
        
        // Pick next from head
        process_t *next = queue_pop(ready_queue);
        next->state = RUNNING;
        current_process = next;
        
        // Update TSS for user-mode safety
        tss_update_esp0(next->kernel_stack_top);
    }
  ||
}

classes: {
  ready_proc: {
    shape: rectangle
    width: 60
    height: 40
    style: {
      stroke-width: 2
      border-radius: 4
    }
  }
}