vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Round-Robin Scheduler: Process Queue
| {near: top-center}
classes: {
  pcb: {
    shape: rectangle
    style: {
      fill: "#E8F4E8"
      stroke: "#2D5A2D"
      stroke-width: 2
      border-radius: 4
    }
  }
  pcb_running: {
    shape: rectangle
    style: {
      fill: "#FFE4B5"
      stroke: "#FF8C00"
      stroke-width: 3
      border-radius: 4
      bold: true
    }
  }
  timer: {
    shape: diamond
    style: {
      fill: "#FFE6E6"
      stroke: "#CC0000"
      stroke-width: 2
    }
  }
  queue_arrow: {
    style: {
      stroke: "#4A90D9"
      stroke-width: 3
      animated: true
    }
  }
  step: {
    shape: rectangle
    style: {
      fill: "#F0F4F8"
      stroke: "#5A7A9A"
      stroke-dash: 3
      border-radius: 8
    }
  }
}
direction: right
timer_block: Timer Interrupt (IRQ0) {
  class: timer
  width: 180
  pit: PIT 100Hz {
    shape: rectangle
    style.fill: "#FFF0F0"
  }
  trigger: "Every 10ms\n→ scheduler_tick()" {
    shape: text
    style.font-size: 14
    style.italic: true
  }
}
timer_block -> run_queue_block: triggers {
  class: queue_arrow
  label: "save current\ncontext"
}
run_queue_block: Run Queue (Circular) {
  direction: right
  style.fill: "#FAFAFA"
  pcb_a: Process A (PID 1) {
    class: pcb_running
    link: "#process-a-details"
    state: "state: RUNNING\nEIP: 0x08048100\nESP: 0xBFFFF800"
    vga_output: {
      shape: rectangle
      label: "VGA Line 0:\n'A B C D...'"
      style: {
        fill: "#E6F3FF"
        stroke: "#4A90D9"
        font: mono
      }
    }
  }
  pcb_b: Process B (PID 2) {
    class: pcb
    link: "#process-b-details"
    state_b: "state: READY\nEIP: 0x08048200\nESP: 0xBFFFF700"
    vga_output_b: {
      shape: rectangle
      label: "VGA Line 1:\n'0 1 2 3...'"
      style: {
        fill: "#E6FFE6"
        stroke: "#4A90D9"
        font: mono
      }
    }
  }
  pcb_c: Process C (PID 3) {
    class: pcb
    link: "#process-c-details"
    state_c: "state: READY\nEIP: 0x08048300\nESP: 0xBFFFF600"
    vga_output_c: {
      shape: rectangle
      label: "VGA Line 2:\n'a b c d...'"
      style: {
        fill: "#FFF0E6"
        stroke: "#4A90D9"
        font: mono
      }
    }
  }
  pcb_a -> pcb_b: "next" {class: queue_arrow}
  pcb_b -> pcb_c: "next" {class: queue_arrow}
  pcb_c -> pcb_a: "next" {class: queue_arrow}
}
steps_block: Context Switch Steps {
  direction: down
  step1: "1. SAVE current" {
    class: step
    label: |md
      **SAVE current process**
      - Push registers to kernel stack
      - Copy ESP → PCB.kernel_stack
      - Mark state = READY
    |
  }
  step2: "2. PICK next" {
    class: step
    label: |md
      **PICK next process**
      - Dequeue from run_queue head
      - Mark state = RUNNING
      - Update current_process pointer
    |
  }
  step3: "3. RESTORE next" {
    class: step
    label: |md
      **RESTORE next process**
      - Update TSS.ESP0
      - Switch CR3 if different PD
      - Load ESP from PCB.kernel_stack
    |
  }
  step4: "4. RESUME via iret" {
    class: step
    label: |md
      **RESUME via iret**
      - Pop segment registers
      - Pop general registers
      - iret loads EIP, CS, EFLAGS
    |
  }
  step1 -> step2 -> step3 -> step4 {
    style: {
      stroke: "#5A7A9A"
      stroke-width: 2
    }
  }
}
run_queue_block -> steps_block: "context switch" {
  style: {
    stroke: "#5A7A9A"
    stroke-dash: 5
  }
}
vga_display: VGA Memory (0xB8000) {
  direction: down
  style.fill: "#1A1A2E"
  line0: {
    grid-columns: 80
    grid-gap: 0
    c0: "A" {
      style: {
        fill: "#1F4A1F"
        font-color: white
        font: mono
      }
    }
    c1: " " {
      style: {
        fill: "#1F4A1F"
        font-color: white
        font: mono
      }
    }
    c2: "B" {
      style: {
        fill: "#1F4A1F"
        font-color: white
        font: mono
      }
    }
    c3: " " {
      style: {
        fill: "#1F4A1F"
        font-color: white
        font: mono
      }
    }
    c4: "C" {
      style: {
        fill: "#1F4A1F"
        font-color: white
        font: mono
      }
    }
    dots0: "..." {
      style: {
        fill: "#1F4A1F"
        font-color: white
        font: mono
      }
    }
  }
  line1: {
    grid-columns: 80
    grid-gap: 0
    d0: "0" {
      style: {
        fill: "#1A3A1A"
        font-color: "#00FF00"
        font: mono
      }
    }
    d1: " " {
      style: {
        fill: "#1A3A1A"
        font-color: "#00FF00"
        font: mono
      }
    }
    d2: "1" {
      style: {
        fill: "#1A3A1A"
        font-color: "#00FF00"
        font: mono
      }
    }
    d3: " " {
      style: {
        fill: "#1A3A1A"
        font-color: "#00FF00"
        font: mono
      }
    }
    d4: "2" {
      style: {
        fill: "#1A3A1A"
        font-color: "#00FF00"
        font: mono
      }
    }
    dots1: "..." {
      style: {
        fill: "#1A3A1A"
        font-color: "#00FF00"
        font: mono
      }
    }
  }
  line2: {
    grid-columns: 80
    grid-gap: 0
    e0: "a" {
      style: {
        fill: "#2A1A1A"
        font-color: "#FF6B6B"
        font: mono
      }
    }
    e1: " " {
      style: {
        fill: "#2A1A1A"
        font-color: "#FF6B6B"
        font: mono
      }
    }
    e2: "b" {
      style: {
        fill: "#2A1A1A"
        font-color: "#FF6B6B"
        font: mono
      }
    }
    e3: " " {
      style: {
        fill: "#2A1A1A"
        font-color: "#FF6B6B"
        font: mono
      }
    }
    e4: "c" {
      style: {
        fill: "#2A1A1A"
        font-color: "#FF6B6B"
        font: mono
      }
    }
    dots2: "..." {
      style: {
        fill: "#2A1A1A"
        font-color: "#FF6B6B"
        font: mono
      }
    }
  }
  legend: |md
    **Process A** (white) → Line 0 at 0xB8000  
    **Process B** (green) → Line 1 at 0xB80A0  
    **Process C** (red)   → Line 2 at 0xB8140
  | {
    shape: text
    style: {
      font-color: "#AAAAAA"
      font-size: 12
    }
  }
}
run_queue_block.pcb_a.vga_output -> vga_display.line0: "writes" {
  style: {
    stroke: "#4A90D9"
    stroke-dash: 3
  }
}
run_queue_block.pcb_b.vga_output_b -> vga_display.line1: "writes" {
  style: {
    stroke: "#4A90D9"
    stroke-dash: 3
  }
}
run_queue_block.pcb_c.vga_output_c -> vga_display.line2: "writes" {
  style: {
    stroke: "#4A90D9"
    stroke-dash: 3
  }
}
time_slice: Time Slice Allocation {
  direction: right
  ts_label: "100ms per process:" {
    shape: text
    style.bold: true
  }
  proc_a_time: {
    shape: rectangle
    width: 100
    label: "A runs"
    style: {
      fill: "#FFE4B5"
      stroke: "#FF8C00"
    }
  }
  proc_b_time: {
    shape: rectangle
    width: 100
    label: "B runs"
    style: {
      fill: "#E8F4E8"
      stroke: "#2D5A2D"
    }
  }
  proc_c_time: {
    shape: rectangle
    width: 100
    label: "C runs"
    style: {
      fill: "#E8F4E8"
      stroke: "#2D5A2D"
    }
  }
  repeat: {
    shape: rectangle
    width: 60
    label: "..."
    style: {
      fill: "#E0E0E0"
      stroke: "#888888"
    }
  }
  ts_label -> proc_a_time -> proc_b_time -> proc_c_time -> repeat {
    style: {
      stroke: "#666666"
      stroke-width: 2
    }
  }
}
vga_display -> time_slice: "visual proof" {
  style: {
    stroke: "#666666"
    stroke-dash: 3
  }
  label: "concurrent output"
}
pcb_detail: PCB Structure Detail {
  direction: right
  pcb_struct: |c
    struct process {
      uint32_t pid;           // 1, 2, 3
      char name[32];          // "process_a"
      process_state_t state;  // READY/RUNNING
      struct cpu_state *kernel_stack;
      struct page_directory *page_directory;
      uint32_t kernel_stack_top;  // for TSS.ESP0
      int priority;           // 1 (equal)
      uint64_t cpu_time;      // accumulated ticks
      struct process *next;   // queue link
    };
  | {
    shape: code
    style: {
      fill: "#2D2D2D"
      font-color: "#A9B7C6"
      font: mono
      font-size: 11
    }
  }
  cpu_state_struct: |c
    struct cpu_state {
      // Pushed by our stub
      uint32_t gs, fs, es, ds;
      uint32_t edi, esi, ebp;
      uint32_t esp, ebx, edx;
      uint32_t ecx, eax;
      uint32_t int_no, err_code;
      // Pushed by CPU
      uint32_t eip, cs, eflags;
      // If ring3→ring0:
      uint32_t useresp, ss;
    };
  | {
    shape: code
    style: {
      fill: "#2D2D2D"
      font-color: "#A9B7C6"
      font: mono
      font-size: 11
    }
  }
}
steps_block -> pcb_detail: "saves/restores" {
  style: {
    stroke: "#5A7A9A"
    stroke-dash: 2
  }
}
back_to_map: Back to Satellite Map {
  link: "#satellite-overview"
  shape: text
  near: bottom-right
  style: {
    font-color: "#4A90D9"
    italic: true
  }
}