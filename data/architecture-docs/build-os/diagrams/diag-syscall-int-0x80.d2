vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # System Call: INT 0x80 Entry and Exit
  Complete trace from user mode → kernel → user mode
| {near: top-center}

# Legend
legend: {
  near: bottom-right
  label: ""
  shape: rectangle
  style.fill: transparent

  ring3: "Ring 3 (User Mode)" {
    shape: rectangle
    style.fill: "#E8F5E9"
    style.stroke: "#4CAF50"
  }
  ring0: "Ring 0 (Kernel Mode)" {
    shape: rectangle
    style.fill: "#E3F2FD"
    style.stroke: "#2196F3"
  }
  hardware: "Hardware/CPU" {
    shape: rectangle
    style.fill: "#FFF3E0"
    style.stroke: "#FF9800"
  }
}

classes: {
  user_code: {
    style: {
      fill: "#E8F5E9"
      stroke: "#4CAF50"
      stroke-width: 2
    }
  }
  kernel_code: {
    style: {
      fill: "#E3F2FD"
      stroke: "#2196F3"
      stroke-width: 2
    }
  }
  hardware_op: {
    style: {
      fill: "#FFF3E0"
      stroke: "#FF9800"
      stroke-width: 2
    }
  }
  register: {
    shape: hexagon
    style: {
      fill: "#F3E5F5"
      stroke: "#9C27B0"
    }
  }
  memory: {
    shape: cylinder
    style: {
      fill: "#ECEFF1"
      stroke: "#607D8B"
    }
  }
}

# Phase 1: User Mode Preparation
phase1: "Phase 1: User Mode Setup" {
  user_code: {
    class: user_code

    user_program: |md
      c
      // User program
      const char *msg = "Hello";
      sys_write(0, msg, 5);
      
    |

    setup_regs: "Setup Registers" {
      eax: {
        class: register
        label: "EAX = 1\n(SYS_WRITE)"
      }
      ebx: {
        class: register
        label: "EBX = 0\n(fd)"
      }
      ecx: {
        class: register
        label: "ECX = buf\n(pointer)"
      }
      edx: {
        class: register
        label: "EDX = 5\n(length)"
      }
    }

    int_instruction: |md
      asm
      ; Execute system call
      int 0x80
      
    |
  }
}

# Phase 2: CPU Hardware Transition
phase2: "Phase 2: CPU Hardware Transition" {
  direction: right
  hardware_op: {
    class: hardware_op

    cpu_actions: {
      label: "CPU Automatic Actions"
      direction: down

      step1: "1. Read IDT entry 0x80" {
        style.fill: "#FFE0B2"
      }
      step2: "2. Read TSS ESP0 (kernel stack)" {
        style.fill: "#FFE0B2"
      }
      step3: "3. Switch SS:ESP to kernel stack" {
        style.fill: "#FFCC80"
        style.stroke: "#E65100"
      }
    }

    tss: {
      class: memory
      label: "TSS\n(Task State Segment)"
      ss0: "SS0 = 0x10"
      esp0: "ESP0 = 0x90000\n(current process\nkernel stack top)"
    }

    stack_push: "CPU Pushes to Kernel Stack" {
      class: memory
      direction: down

      stack_frame: {
        label: ""
        shape: rectangle
        style.fill: "#ECEFF1"

        entry_ss: "SS = 0x23 (user)"
        entry_esp: "ESP = 0xBFFFF000"
        entry_eflags: "EFLAGS (with IF=1)"
        entry_cs: "CS = 0x1B (user code)"
        entry_eip: "EIP = (after int 0x80)"
      }

      note: |md
        5 values pushed automatically
        by CPU on privilege transition
      |
    }
  }
}

# Phase 3: Kernel Handler
phase3: "Phase 3: Kernel Syscall Handler" {
  kernel_code: {
    class: kernel_code

    handler_entry: |md
      asm
      ; isr128 - INT 0x80 handler
      isr128:
          pusha           ; Save all GP regs
          push ds, es     ; Save segments
          mov ax, 0x10    ; Load kernel DS
          mov ds, ax
          call syscall_handler
          ...
      
    |

    dispatcher: "syscall_handler() Dispatcher" {
      read_args: {
        label: "Read Arguments from Stack"
        eax_val: "EAX → syscall number (1)"
        ebx_val: "EBX → fd (0)"
        ecx_val: "ECX → buffer pointer"
        edx_val: "EDX → length (5)"
      }

      dispatch_table: |md
        c
        switch (regs->eax) {
          case SYS_WRITE:  // 1
            return sys_write(
              regs->ebx,   // fd
              regs->ecx,   // buf
              regs->edx    // len
            );
          case SYS_EXIT:   // 0
            return sys_exit(regs->ebx);
          ...
        }
        
      |

      sys_write_impl: |md
        c
        int sys_write(int fd, const char *buf, int len) {
          for (int i = 0; i < len; i++) {
            vga_putchar(buf[i]); // Write to VGA
          }
          return len; // Bytes written
        }
        
      |
    }

    set_return: "Set Return Value" {
      class: register
      label: "EAX = 5\n(return value)"
      note: "Store in saved register\non stack"
    }
  }
}

# Phase 4: Return to User Mode
phase4: "Phase 4: Return to User Mode" {
  kernel_code: {
    class: kernel_code

    restore_and_iret: |md
      asm
      ; Restore and return
      pop es, ds        ; Restore segments
      popa              ; Restore GP regs
                         ; EAX now has return value
      add esp, 8        ; Skip error code, int num
      iret              ; Return to user mode!
      
    |
  }

  hardware_op: {
    class: hardware_op

    iret_actions: {
      label: "IRET Actions (CPU)"
      direction: down

      pop_eip: "Pop EIP → resume user code"
      pop_cs: "Pop CS → 0x1B (ring 3)"
      pop_eflags: "Pop EFLAGS → restore IF"
      pop_esp: "Pop ESP → user stack"
      pop_ss: "Pop SS → 0x23 (user data)"
      switch_ring: "Switch to Ring 3" {
        style.fill: "#C8E6C9"
        style.stroke: "#388E3C"
      }
    }
  }

  user_code: {
    class: user_code

    resumed: |md
      c
      // User program continues
      int bytes_written = sys_write(...);
      // bytes_written = 5 (in EAX)
      printf("Wrote %d bytes\n", bytes_written);
      
    |
  }
}

# Flow arrows
phase1.user_code.int_instruction -> phase2.hardware_op.cpu_actions.step1: "1. Execute INT 0x80" {
  style.stroke: "#4CAF50"
  style.stroke-width: 3
  style.animated: true
}

phase2.hardware_op.cpu_actions.step3 -> phase2.hardware_op.stack_push: "2. CPU pushes state" {
  style.stroke: "#FF9800"
  style.stroke-width: 2
}

phase2.hardware_op.tss -> phase2.hardware_op.cpu_actions.step2: "TSS provides\nkernel stack" {
  style.stroke: "#9E9E9E"
  style.stroke-dash: 3
}

phase2.hardware_op.stack_push -> phase3.kernel_code.handler_entry: "3. Jump to handler\nat IDT[0x80]" {
  style.stroke: "#2196F3"
  style.stroke-width: 3
  style.animated: true
}

phase3.kernel_code.dispatcher.read_args -> phase3.kernel_code.dispatcher.dispatch_table: "4. Dispatch" {
  style.stroke: "#2196F3"
}

phase3.kernel_code.dispatcher.dispatch_table -> phase3.kernel_code.dispatcher.sys_write_impl: {
  style.stroke: "#2196F3"
}

phase3.kernel_code.dispatcher.sys_write_impl -> phase3.kernel_code.set_return: "5. Set return" {
  style.stroke: "#9C27B0"
}

phase3.kernel_code.set_return -> phase4.kernel_code.restore_and_iret: "6. Restore regs" {
  style.stroke: "#2196F3"
}

phase4.kernel_code.restore_and_iret -> phase4.hardware_op.iret_actions.pop_eip: "7. IRET executes" {
  style.stroke: "#FF9800"
  style.stroke-width: 3
  style.animated: true
}

phase4.hardware_op.iret_actions.switch_ring -> phase4.user_code.resumed: "8. Resume in Ring 3" {
  style.stroke: "#4CAF50"
  style.stroke-width: 3
  style.animated: true
}

# Timing annotation
timing: {
  near: bottom-center
  label: ""
  shape: rectangle
  style.fill: transparent

  timing_info: |md
    **Latency Breakdown:**
    - INT 0x80 entry: ~50-100 cycles (stack switch + push)
    - Handler dispatch: ~20-50 cycles
    - sys_write execution: variable (depends on I/O)
    - IRET return: ~30-50 cycles (pop + ring transition)
    - **Total: ~100-200 cycles + I/O time**
  |
}