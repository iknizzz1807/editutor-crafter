vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # System Call Interface: INT 0x80
  User-Kernel Transition via Software Interrupt
| {near: top-center}
direction: right
user_space: User Space (Ring 3) {
  style: {
    fill: "#E8F5E9"
    stroke: "#2E7D32"
    stroke-width: 2
  }
  user_process: User Process {
    style.fill: "#C8E6C9"
    user_code: |md
      
      ; sys_write("Hello", 5)
      mov eax, 2        ; SYS_WRITE
      mov ebx, 1        ; fd = stdout
      mov ecx, msg      ; buffer
      mov edx, 5        ; count
      int 0x80          ; TRAP!
      ; EAX = return value
      
    |
  }
  registers_before: Register State (Before INT) {
    shape: sql_table
    width: 280
    EAX: 0x00000002 {constraint: primary_key}
    EBX: 0x00000001
    ECX: 0x08049ABC
    EDX: 0x00000005
    EIP: "0x08048123 (after int)"
    CS: 0x1B
    CPL: "3 (Ring 3)"
  }
}
transition: {
  style.fill: transparent
  style.stroke: "#FF6F00"
  style.stroke-width: 3
  style.stroke-dash: 5
  int_instruction: int 0x80 {
    shape: diamond
    style.fill: "#FFF3E0"
    style.stroke: "#FF6F00"
    style.font: mono
    style.bold: true
  }
  cpu_actions: CPU Hardware Actions {
    style.fill: "#FFF8E1"
    action1: "1. Read IDT entry 0x80"
    action2: "2. Load TSS.ESP0 â†’ kernel stack"
    action3: "3. Push: SS, ESP, EFLAGS, CS, EIP"
    action4: "4. Load CS:EIP from IDT gate"
    action5: "5. Switch to Ring 0"
    action1.style.font: mono
    action2.style.font: mono
    action3.style.font: mono
    action4.style.font: mono
    action5.style.font: mono
  }
  int_instruction -> cpu_actions: "Triggers" {
    style.stroke: "#FF6F00"
    style.animated: true
  }
}
kernel_space: Kernel Space (Ring 0) {
  style: {
    fill: "#E3F2FD"
    stroke: "#1565C0"
    stroke-width: 2
  }
  syscall_entry: syscall_entry (Assembly) {
    style.fill: "#BBDEFB"
    style.font: mono
    entry_code: |md
      asm
      syscall_entry:
          push ds, es, fs, gs    ; save segments
          mov ax, 0x10           ; kernel DS
          mov ds, ax, es, ax
          pusha                  ; save GP regs
          push edx, ecx, ebx, eax
          call syscall_handler   ; C function
          add esp, 16
          ; EAX = return value
          popa
          pop gs, fs, es, ds
          iret                   ; return to user
      
    |
  }
  syscall_handler: syscall_handler (C) {
    style.fill: "#90CAF9"
    handler_code: |md
      c
      int32_t syscall_handler(
          uint32_t num,  // EAX
          uint32_t arg1, // EBX
          uint32_t arg2, // ECX
          uint32_t arg3) // EDX
      {
        switch (num) {
          case SYS_EXIT:  return sys_exit(arg1);
          case SYS_READ:  return sys_read(arg1,arg2,arg3);
          case SYS_WRITE: return sys_write(arg1,arg2,arg3);
          case SYS_GETPID: return current->pid;
          default: return -1;
        }
      }
      
    |
  }
}
syscall_table: System Call Table {
  style.fill: "#E1F5FE"
  sys_exit_impl: sys_exit (0) {
    style.fill: "#FFCDD2"
    style.stroke: "#C62828"
    exit_code: |md
      c
      void sys_exit(int code) {
        current->state = ZOMBIE;
        current->exit_code = code;
        run_queue_remove(current);
        schedule(); // never returns
      }
      
    |
  }
  sys_write_impl: sys_write (2) {
    style.fill: "#C8E6C9"
    style.stroke: "#2E7D32"
    write_code: |md
      c
      int sys_write(int fd, const void *buf, 
                    int count) {
        if (fd != 1) return -1;
        const char *s = buf;
        for (int i = 0; i < count; i++)
          vga_putchar(s[i]);
        return count;
      }
      
    |
  }
  sys_read_impl: sys_read (1) {
    style.fill: "#B3E5FC"
    style.stroke: "#0277BD"
    read_code: |md
      c
      int sys_read(int fd, void *buf, 
                   int count) {
        if (fd != 0) return -1;
        char *b = buf;
        int n = 0;
        while (n < count && kb_has_char())
          b[n++] = kb_getchar();
        return n;
      }
      
    |
  }
  sys_getpid_impl: sys_getpid (3) {
    style.fill: "#F3E5F5"
    style.stroke: "#7B1FA2"
    getpid_code: |md
      c
      int sys_getpid(void) {
        return current_process->pid;
      }
      
    |
  }
}
idt_entry: IDT Entry 0x80 {
  style.fill: "#FFF3E0"
  style.stroke: "#E65100"
  idt_layout: |md
    
    Offset [15:0]:  0x???? (syscall_entry)
    Selector:       0x0008 (kernel CS)
    Reserved:       0x00
    Type/Attr:      0xEF
      Present=1, DPL=3, Type=1111 (trap gate)
    Offset [31:16]: 0x????
    
  |
  attr_decode: Gate Attributes {
    shape: sql_table
    P: 1 {constraint: primary_key}
    DPL: "11 (Ring 3 callable)"
    S: 0 {constraint: ""}
    Type: "1111 (32-bit trap)"
  }
}
return_path: Return to User {
  style.fill: "#F3E5F5"
  style.stroke: "#7B1FA2"
  style.stroke-dash: 3
  iret_action: iret Instruction {
    shape: diamond
    style.fill: "#E1BEE7"
    iret_ops: |md
      
      iret:
        Pop EIP, CS, EFLAGS
        If CPL changes: pop ESP, SS
        Resume at EIP (Ring 3)
        EAX contains return value
      
    |
  }
  registers_after: Register State (After iret) {
    shape: sql_table
    width: 280
    EAX: "0x00000005 (bytes written)"
    EBX: 0x00000001
    ECX: 0x08049ABC
    EDX: 0x00000005
    EIP: "0x08048125 (after int 0x80)"
    CS: 0x1B
    CPL: "3 (Ring 3)"
  }
}
legend: {
  near: bottom-center
  flow_legend: Register Flow {
    grid-columns: 2
    grid-gap: 0
    user_in: "User sets EAX=2, EBX=1, ECX=buf, EDX=5"
    user_in.style.fill: "#C8E6C9"
    user_in.style.font-size: 14
    kernel_out: "Kernel returns EAX=5 (bytes written)"
    kernel_out.style.fill: "#BBDEFB"
    kernel_out.style.font-size: 14
  }
}
connections: {
  user_space.user_process -> transition.int_instruction: "executes" {
    style.stroke: "#2E7D32"
    style.stroke-width: 2
  }
  transition.cpu_actions -> kernel_space.syscall_entry: "jumps to Ring 0" {
    style.stroke: "#FF6F00"
    style.stroke-width: 2
    label: "CS:EIP from IDT"
  }
  kernel_space.syscall_entry -> kernel_space.syscall_handler: "calls" {
    style.stroke: "#1565C0"
  }
  kernel_space.syscall_handler -> syscall_table.sys_exit_impl: "case 0"
  kernel_space.syscall_handler -> syscall_table.sys_write_impl: "case 2" {
    style.stroke: "#2E7D32"
    style.stroke-width: 2
    label: "EAX=2"
  }
  kernel_space.syscall_handler -> syscall_table.sys_read_impl: "case 1"
  kernel_space.syscall_handler -> syscall_table.sys_getpid_impl: "case 3"
  syscall_table.sys_write_impl -> kernel_space.syscall_handler: "return count" {
    style.stroke: "#2E7D32"
    label: "EAX = 5"
  }
  kernel_space.syscall_handler -> kernel_space.syscall_entry: "return EAX" {
    style.stroke-dash: 3
  }
  kernel_space.syscall_entry -> return_path.iret_action: "iret" {
    style.stroke: "#7B1FA2"
    style.stroke-width: 2
  }
  return_path.iret_action -> user_space.user_process: "resume Ring 3" {
    style.stroke: "#7B1FA2"
    style.stroke-dash: 3
    label: "EAX preserved"
  }
  idt_entry -> transition.cpu_actions: "CPU reads" {
    style.stroke: "#E65100"
    style.stroke-dash: 3
  }
}