vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # TLB Coherency: Why Page Table Modifications Require Flushing
| {near: top-center}

direction: right

before: {
  label: "BEFORE: Stale TLB Entry"

  tlb_before: TLB Cache {
    style.fill: "#FFE4B5"
    style.stroke: "#D2691E"

    entry_0xc000: |md
      **Entry 0xC0001000**
      
      Frame: 0x00123000
      Flags: P=1, W=1, U=0
      
    |
  }

  page_table_before: Page Table Entry {
    style.fill: "#90EE90"
    style.stroke: "#228B22"

    pte_content: |md
      **PTE at 0xC0001000**
      
      Frame: 0x00123000
      Flags: P=0, W=0, U=0
      ← JUST MODIFIED!
      
    |
  }

  problem: "⚠️ MISMATCH!" {
    style.fill: "#FF6B6B"
    style.stroke: "#8B0000"
    style.font-color: white
    shape: diamond
  }

  cpu_access: CPU Access {
    style.fill: "#87CEEB"
    
    read_attempt: |md
      
      mov eax, [0xC0001000]
      
      TLB says: ✓ Present, ✓ Writable
      PTE says: ✗ Not Present!
    |
  }

  tlb_before -> problem: "Entry still cached"
  page_table_before -> problem: "Entry modified"
  problem -> cpu_access: "Uses stale data!"
}

before -> after: " " {
  style.stroke: "#333"
  style.stroke-width: 3
  
  source-arrowhead: {
    shape: arrow
  }
}

after: {
  label: "AFTER: TLB Flushed"

  strategies: {
    style.fill: "#E8E8E8"
    style.stroke-dash: 3

    invlpg: Strategy 1: invlpg {
      style.fill: "#98FB98"
      
      code: |md
        asm
        ; Flush single entry
        invlpg [0xC0001000]
        
        
        **Cost:** ~24 cycles
        **Scope:** One page only
      |
    }

    cr3_reload: Strategy 2: CR3 Reload {
      style.fill: "#98FB98"
      
      code: |md
        asm
        ; Flush all non-global
        mov eax, cr3
        mov cr3, eax
        
        
        **Cost:** ~400+ cycles
        **Scope:** Entire TLB
      |
    }
  }

  tlb_after: TLB Cache {
    style.fill: "#FFE4B5"
    style.stroke: "#228B22"

    entry_flushed: |md
      **Entry 0xC0001000**
      
      \[INVALIDATED\]
      
      Next access → Page table walk
    |
  }

  page_table_after: Page Table Entry {
    style.fill: "#90EE90"
    style.stroke: "#228B22"

    pte_new: |md
      **PTE at 0xC0001000**
      
      Frame: 0x00123000
      Flags: P=0, W=0, U=0
      
    |
  }

  cpu_result: CPU Access {
    style.fill: "#87CEEB"
    
    result: |md
      
      mov eax, [0xC0001000]
      
      TLB miss → Page table walk
      PTE: ✗ Not Present
      → **Page Fault!** (expected)
    |
  }

  strategies.invlpg -> tlb_after: "Flushes entry"
  strategies.cr3_reload -> tlb_after: "Flushes ALL"
  page_table_after -> cpu_result: "Correct behavior"
  tlb_after -> cpu_result: "Fresh lookup"
}

legend: {
  near: bottom-center

  why_required: |md
  ## Why TLB Flush Is Mandatory
    
  The TLB is a **cache**—it doesn't auto-update when page tables change.
    
  **Without flush:**
  - CPU uses cached (stale) permissions
  - Write to read-only page succeeds (!)
  - User accesses kernel memory (!)
  - Security bypass, data corruption
    
  **With flush:**
  - Next access triggers page table walk
  - Fresh PDE/PTE values loaded
  - Correct permissions enforced
    
  **When to flush:**
  1. After `vmm_map_page()` → `invlpg`
  2. After `vmm_unmap_page()` → `invlpg`
  3. After changing PTE flags → `invlpg`
  4. Context switch (CR3 change) → automatic
  |
}

timing_comparison: {
  near: bottom-right
  label: "Performance Impact"

  grid-columns: 2
  grid-gap: 0

  header_op: "Operation" {
    class: header
  }
  header_cycles: "Cycles" {
    class: header
  }

  op_invlpg: "invlpg [addr]"
  cycles_invlpg: "~24" {
    style.fill: "#90EE90"
  }

  op_cr3: "mov cr3, eax"
  cycles_cr3: "~400+" {
    style.fill: "#FFB6C1"
  }

  op_tlb_miss: "TLB miss (page walk)"
  cycles_tlb_miss: "~100-300" {
    style.fill: "#FFE4B5"
  }
}

classes: {
  header: {
    style.underline: true
    style.bold: true
  }
}