vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Fault Cascade: Triple Fault Cause Chain
  **"When the exception handler becomes the exception"**
| {near: top-center}

classes: {
  normal: {
    style: {
      fill: "#E8F5E9"
      stroke: "#4CAF50"
      stroke-width: 2
    }
  }
  fault: {
    style: {
      fill: "#FFEBEE"
      stroke: "#F44336"
      stroke-width: 3
    }
  }
  double: {
    style: {
      fill: "#FCE4EC"
      stroke: "#E91E63"
      stroke-width: 4
    }
  }
  triple: {
    style: {
      fill: "#4A1A2C"
      stroke: "#880E4F"
      stroke-width: 5
      font-color: white
    }
  }
  handler: {
    style: {
      fill: "#E3F2FD"
      stroke: "#2196F3"
      stroke-dash: 4
    }
  }
  rootcause: {
    style: {
      fill: "#FFF3E0"
      stroke: "#FF9800"
    }
  }
}

Normal_Execution: "Normal Execution\n(process running)" {
  class: normal
  link: "#normal-exec"
}

Normal_Execution -> Fault_Trigger: "Exception occurs\n(divide by zero, page fault, etc.)"

Fault_Trigger: "EXCEPTION\n(CPU pushes error code,\nloads IDT gate)" {
  class: fault
  link: "#exception-handling"
}

Fault_Trigger -> Handler_Invoke: "CPU reads IDT entry\ncs:eip = handler address"

Handler_Invoke: "Handler Invocation" {
  class: handler

  Stack_Frame: {
    label: |md
      **Stack after CPU push:**
      
      SS      (if CPL change)
      ESP     (if CPL change)
      EFLAGS
      CS
      EIP
      Error Code (optional)
      
    |
    style.fill: "#F5F5F5"
  }
}

Handler_Invoke -> Handler_Fail: "Handler code has bug\nor invalid state"

Handler_Fail: "HANDLER FAILURE\n(tries to access bad IDT,\ncorrupt TSS, wrong ESP0)" {
  class: fault
  style.stroke-dash: 5
}

Handler_Fail -> Double_Fault: "Exception while\nhandling exception!"

Double_Fault: "DOUBLE FAULT (#DF)\nVector 8\n(CPU loads IDT[8])" {
  class: double
  link: "#double-fault-section"
}

Double_Fault -> Double_Handler: "Attempt to run\ndouble fault handler"

Double_Handler: "Double Fault Handler\n(Last chance!)" {
  class: handler
  style.stroke-width: 3
}

Double_Handler -> Double_Fail: "Handler corrupt or\nstack exhausted"

Double_Fail: "DOUBLE FAULT\nHANDLER FAILS\n(Another exception!)" {
  class: double
  style.stroke-dash: 5
}

Double_Fail -> Triple_Fault: "Exception during\ndouble fault!"

Triple_Fault: "TRIPLE FAULT\n(No handler left!)" {
  class: triple
  link: "#triple-fault-section"
}

Triple_Fault -> CPU_Reset: "CPU enters shutdown\nstate (0x80 port write)"

CPU_Reset: "CPU RESET\n(System reboot or\nBOCHS triple-fault dump)" {
  shape: diamond
  style: {
    fill: "#1A1A2E"
    font-color: "#FF0000"
    stroke: "#FF0000"
    stroke-width: 4
    bold: true
    font-size: 20
  }
}

Root_Causes: "Common Root Causes" {
  class: rootcause
  near: top-right

  bad_idt: "Bad IDT Entry" {
    style.fill: "#FFCDD2"
    tooltip: "IDT gate points to unmapped memory or ring 0 code with DPL=0"
  }
  corrupt_tss: "Corrupt TSS" {
    style.fill: "#FFCDD2"
    tooltip: "TSS.ESP0 is garbage or TSS segment selector invalid"
  }
  wrong_esp0: "Wrong ESP0" {
    style.fill: "#FFCDD2"
    tooltip: "TSS.ESP0 not updated on context switch"
  }
  stack_overflow: "Kernel Stack Overflow" {
    style.fill: "#FFCDD2"
    tooltip: "Stack grows into unmapped memory, causing page fault in handler"
  }
  unmap_idt: "IDT Not Mapped" {
    style.fill: "#FFCDD2"
    tooltip: "Page tables don't map IDT address"
  }

  bad_idt -> corrupt_tss -> wrong_esp0 -> stack_overflow -> unmap_idt {style.opacity: 0}
}

Root_Causes -> Fault_Trigger: "Causes" {
  style: {
    stroke: "#FF9800"
    stroke-dash: 3
    animated: true
  }
}

State_Diagram: "Fault State Machine" {
  near: bottom-left
  
  S0: "S0: Running" {
    class: normal
  }
  S1: "S1: Fault" {
    class: fault
  }
  S2: "S2: Double Fault" {
    class: double
  }
  S3: "S3: Triple Fault" {
    class: triple
  }

  S0 -> S1: "Exception\n(push frame)"
  S1 -> S0: "Handler\nreturns (IRET)"
  S1 -> S2: "Handler faults\nbefore IRET"
  S2 -> S0: "Double fault\nhandler succeeds"
  S2 -> S3: "Double fault\nhandler faults"
  S3 -> S0: "RESET"
}

Register_State: "What's Preserved?" {
  near: bottom-right
  style.fill: "#ECEFF1"

  regs: |md
    c
    // Pushed by CPU on exception:
    SS, ESP, EFLAGS, CS, EIP
    [Error Code if applicable]
    
    // Must be preserved by handler:
    EAX, EBX, ECX, EDX,
    ESI, EDI, EBP,
    DS, ES, FS, GS
    
    // If handler corrupts these:
    // → Another exception!
    
  |
}

Legend: {
  near: bottom-center
  grid-columns: 4
  grid-gap: 10

  l1: "Normal" {class: normal; width: 80}
  l2: "Fault" {class: fault; width: 80}
  l3: "Double" {class: double; width: 80}
  l4: "Triple" {class: triple; width: 80}
}

layers: {
  normal-exec: {
    title: |md
      # Normal Execution State
    | {near: top-center}
    
    desc: |md
      Before any exception, the CPU is executing code normally.
      The IDT is loaded, TSS is configured, and kernel stack is valid.
    |
  }
  
  exception-handling: {
    title: |md
      # Exception Handling Mechanics
    | {near: top-center}
    
    desc: |md
      When an exception occurs:
      1. CPU saves current state (SS, ESP, EFLAGS, CS, EIP, Error Code)
      2. CPU loads new SS:ESP from TSS (if privilege change)
      3. CPU loads CS:EIP from IDT gate
      4. CPU jumps to handler
      
      **Critical**: If any of these fail, you get another exception!
    |
  }
  
  double-fault-section: {
    title: |md
      # Double Fault (#DF)
    | {near: top-center}
    
    desc: |md
      A double fault occurs when:
      - An exception happens while handling another exception
      - The first exception's handler hasn't executed IRET yet
      
      **Not** for sequential exceptions—only nested ones!
      
      Common causes:
      - Page fault in page fault handler (stack not mapped)
      - Invalid IDT entry (handler code not mapped)
      - Corrupt TSS (ESP0 invalid)
    |
  }
  
  triple-fault-section: {
    title: |md
      # Triple Fault = CPU Shutdown
    | {near: top-center}
    
    desc: |md
      A triple fault is NOT a CPU exception type.
      It's the result of: exception → double fault → another exception
      
      When this happens:
      1. CPU writes 0x80 to port 0x80 (shutdown)
      2. Most systems: hardware triggers reset
      3. BOCHS: dumps CPU state and stops
      
      **This is unrecoverable**—you must debug the root cause.
      
      ### Debug Tips:
      bash
      # In BOCHS, triple fault shows full state
      (cpu) r  # Show registers
      (cpu) sreg  # Show segment registers
      (cpu) creg  # Show control registers
      (cpu) print_stack
      
      # Check TSS
      (cpu) info tss
      
      # Check IDT entry for faulting vector
      (cpu) info idt
      
    |
  }
}