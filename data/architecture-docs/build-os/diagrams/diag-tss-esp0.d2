vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: TSS and ESP0: Ring 3 → Ring 0 Stack Switch {
  near: top-center
  shape: text
  style: {
    font-size: 32
    bold: true
    underline: true
  }
}

explanation: |md
  **Why TSS ESP0 Must Be Updated Every Context Switch**

  Each process has its own kernel stack. When a userspace process
  triggers an interrupt or syscall, the CPU **automatically** loads
  SS0:ESP0 from the TSS and switches to that stack.

  If ESP0 points to Process A's kernel stack but Process B is running,
  the interrupt will corrupt A's stack → system crash.
| {
  near: bottom-center
  style.font-size: 18
}

before_after: {
  grid-columns: 2
  grid-gap: 80

  before: "BEFORE: Process B running in Ring 3" {
    style: {
      fill: "#1a1a2e"
      stroke: "#4a4a6a"
      stroke-width: 3
    }

    cpu_state: "CPU State" {
      style.fill: "#2d2d44"
      
      cs_reg: "CS = 0x1B (Ring 3)"
      ss_reg: "SS = 0x23 (Ring 3)"
      esp_reg: "ESP = 0xBFFFF000"
      tr_reg: "TR = TSS Selector"
      cr3_reg: "CR3 = Process B PD"
      
      cs_reg.style.font-color: "#88ff88"
      ss_reg.style.font-color: "#88ff88"
      esp_reg.style.font-color: "#88ff88"
    }

    tss_state: "TSS (Global)" {
      style: {
        fill: "#3d2d2d"
        stroke: "#ff6666"
        stroke-width: 2
      }

      ss0: "SS0 = 0x10 (Kernel Data)"
      esp0_label: "**ESP0 = Process A Stack**"
      
      esp0_label.style: {
        font-color: "#ff4444"
        bold: true
      }
      
      warning: "⚠️ STALE VALUE!" {
        style: {
          fill: "#4a2020"
          font-color: "#ff6666"
          stroke: "#ff4444"
        }
      }
    }

    process_b_stack: "Process B User Stack\n(Ring 3)" {
      shape: cylinder
      style: {
        fill: "#2a4a2a"
        stroke: "#66aa66"
      }
      
      stack_top: "← ESP (0xBFFFF000)"
      stack_content: "User data\nLocal vars\nReturn addrs"
      
      stack_top.style.font-color: "#88ff88"
    }

    process_a_stack: "Process A Kernel Stack\n(Ring 0)" {
      shape: cylinder
      style: {
        fill: "#4a2a2a"
        stroke: "#aa6666"
        stroke-dash: 3
      }
      
      stack_note: "← ESP0 points here\n(WRONG PROCESS!)"
      stack_content_a: "A's saved state\nA's call frames"
      
      stack_note.style.font-color: "#ff6666"
    }

    process_b_stack_link: {
      shape: text
      label: "Active Stack"
      style.font-color: "#66ff66"
    }

    tss_state.warning -> process_a_stack: "ESP0 targets\nwrong stack" {
      style: {
        stroke: "#ff4444"
        stroke-dash: 4
        animated: true
      }
    }
  }

  after: "AFTER: INT 0x80 Triggers Stack Switch" {
    style: {
      fill: "#1a2e1a"
      stroke: "#4a6a4a"
      stroke-width: 3
    }

    trigger: "User executes: INT 0x80" {
      style: {
        fill: "#3a3a1a"
        stroke: "#aaaa44"
        stroke-width: 2
      }
    }

    cpu_action: "CPU Hardware Sequence" {
      style.fill: "#2d3d2d"

      step1: "1. Read TSS → Load SS0:ESP0"
      step2: "2. Switch to kernel stack"
      step3: "3. Push user SS, ESP"
      step4: "4. Push EFLAGS, CS, EIP"
      step5: "5. Load CS:EIP from IDT"
      step6: "6. Jump to handler (Ring 0)"
      
      step1.style.font-color: "#aaffaa"
      step2.style.font-color: "#aaffaa"
      step3.style.font-color: "#88ccff"
      step4.style.font-color: "#88ccff"
      step5.style.font-color: "#ffcc88"
      step6.style.font-color: "#ffcc88"
    }

    kernel_stack: "Kernel Stack (from TSS ESP0)" {
      shape: cylinder
      style: {
        fill: "#2a4a4a"
        stroke: "#66aaaa"
      }
      
      stack_layout: |md
        ┌─────────────────────┐ ← ESP (after push)
        │  User SS (0x23)     │
        ├─────────────────────┤
        │  User ESP (0xBFF…)  │
        ├─────────────────────┤
        │  EFLAGS (0x202)     │
        ├─────────────────────┤
        │  User CS (0x1B)     │
        ├─────────────────────┤
        │  User EIP (return)  │
        ├─────────────────────┤
        │  (handler pushes    │
        │   more registers)   │
        └─────────────────────┘
      |
      
      stack_layout.style: {
        font: mono
        font-size: 14
      }
    }

    user_stack_frozen: "User Stack (Frozen)" {
      shape: cylinder
      style: {
        fill: "#3a3a3a"
        stroke: "#666666"
        stroke-dash: 3
      }
      
      frozen_note: "← Not modified\nPreserved for iret"
      frozen_note.style.font-color: "#888888"
    }

    trigger -> cpu_action: "CPU takes over" {
      style.stroke: "#aaaa44"
    }
    
    cpu_action.step2 -> kernel_stack: "Switch ESP\nto kernel" {
      style: {
        stroke: "#66aaaa"
        stroke-width: 2
      }
    }
  }
}

tss_structure: "TSS Structure (bytes 4-7 contain ESP0)" {
  near: center-left
  style: {
    fill: "#2a2a3a"
    stroke: "#6a6a8a"
  }
  
  offset4: "+0x04: ESP0 (Stack Pointer)"
  offset8: "+0x08: SS0 (Stack Segment)"
  
  offset4.style: {
    font-color: "#ff8888"
    bold: true
  }
  
  note: "Must update ESP0 on\nevery context switch!" {
    style: {
      fill: "#4a2a2a"
      font-color: "#ffaaaa"
      stroke: "#aa4444"
    }
  }
}

context_switch_flow: "Context Switch Protocol" {
  near: center-right
  style.fill: "#2a3a2a"
  
  step1: "1. Save current process state"
  step2: "2. Select next process"
  step3: "3. **Update TSS ESP0** ← Critical!"
  step4: "4. Load CR3 (page directory)"
  step5: "5. Restore next process state"
  step6: "6. iret (resume execution)"
  
  step3.style: {
    fill: "#4a2a2a"
    font-color: "#ffaaaa"
    bold: true
    stroke: "#ff4444"
  }
}

code_example: |c
  // In context_switch():
  void schedule_next(void) {
      process_t *next = pick_next_process();
      
      // CRITICAL: Update TSS before switching!
      // Each process has its own kernel stack
      tss.esp0 = next->kernel_stack_top;
      
      // Now safe to switch CR3 and resume
      set_cr3(next->cr3);
      restore_context(&next->cpu);
  }
| {
  near: bottom-right
  style: {
    fill: "#1a1a1a"
    font: mono
    font-size: 14
  }
}

failure_scenario: "Failure Mode: ESP0 Not Updated" {
  near: bottom-left
  style: {
    fill: "#3a1a1a"
    stroke: "#aa4444"
  }
  
  scenario: |md
    1. Process A runs, makes syscall → uses A's kernel stack
    2. Context switch to Process B (user mode)
    3. **TSS ESP0 still points to A's stack**
    4. Process B makes syscall → CPU pushes to A's stack
    5. **A's saved state corrupted!**
    6. Switch back to A → garbage state → triple fault
  |
  
  scenario.style.font-color: "#ffaaaa"
}

before_after.before.tss_state -> tss_structure: "ESP0 at offset 4" {
  style: {
    stroke: "#6a6a8a"
    stroke-dash: 3
  }
}

context_switch_flow.step3 -> before_after.before.tss_state: "Must update\nbefore switch" {
  style: {
    stroke: "#ff4444"
    stroke-dash: 4
    animated: true
  }
}