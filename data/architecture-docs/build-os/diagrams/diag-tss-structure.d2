vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Task State Segment (TSS) Structure
  x86 32-bit Protected Mode
| {near: top-center}

direction: right

tss_memory: TSS in Memory (104 bytes) {
  tss_layout: |md
    **Offset | Field | Size | Purpose**
    0x00 | link (old TSS) | 16-bit | Task back-link
    0x02 | reserved0 | 16-bit | 
    0x04 | ESP0 | 32-bit | **Ring 0 Stack Pointer**
    0x08 | SS0 | 16-bit | **Ring 0 Stack Segment**
    0x0A | reserved1 | 16-bit | 
    0x0C | ESP1 | 32-bit | Ring 1 Stack Pointer
    0x10 | SS1 | 16-bit | Ring 1 Stack Segment
    0x12 | reserved2 | 16-bit | 
    0x14 | ESP2 | 32-bit | Ring 2 Stack Pointer
    0x18 | SS2 | 16-bit | Ring 2 Stack Segment
    0x1C | CR3 | 32-bit | Page Directory Base
    0x20 | EIP | 32-bit | Instruction Pointer
  |
  tss_layout.shape: text
  tss_layout.style.font: mono
  tss_layout.style.font-size: 12
  
  tss_layout2: |md
    **Offset | Field | Size | Purpose**
    0x24 | EFLAGS | 32-bit | CPU Flags
    0x28-0x44 | GPRs | 32-bit each | EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
    0x48-0x5C | Segments | 16-bit each | ES,CS,SS,DS,FS,GS
    0x60 | LDT | 16-bit | Local Descriptor Table
    0x64 | trap | 16-bit | Trap flag
    0x66 | IOPB | 16-bit | I/O Permission Bitmap
  |
  tss_layout2.shape: text
  tss_layout2.style.font: mono
  tss_layout2.style.font-size: 12
}

privilege_transition: Ring 3 to 0 Stack Switch {
  direction: down
  
  before: Before Ring 3 {
    shape: rectangle
    style.fill: "#E8F5E9"
    style.stroke: "#4CAF50"
    
    user_stack: User Stack {
      shape: rectangle
      style.fill: "#C8E6C9"
      esp_val: "ESP = 0x7FFFF000"
      ss_val: "SS = 0x23 user data"
    }
    
    user_code: Running User Code {
      style.fill: "#A5D6A7"
      cs_val: "CS = 0x1B user code DPL=3"
      cpl: "CPL = 3"
    }
  }
  
  trigger: Trigger INT 0x80 {
    shape: diamond
    style.fill: "#FFF3E0"
    style.stroke: "#FF9800"
  }
  
  cpu_action: CPU Hardware Action {
    style.fill: "#FFEBEE"
    style.stroke: "#F44336"
    check: |md
      1. Read new CS from IDT gate
      2. Detect privilege change (DPL=0)
      3. Read TSS.ESP0 and TSS.SS0
      4. Load new stack pointer
    |
    check.shape: text
  }
  
  stack_switch: Stack Switch Mechanics {
    style.fill: "#E3F2FD"
    style.stroke: "#2196F3"
    
    old_stack: |md
      **Old Stack (Ring 3):**
      - SS = 0x23
      - ESP = 0x7FFFF000
    |
    old_stack.shape: text
    
    new_stack: Kernel Stack from TSS {
      shape: rectangle
      style.fill: "#BBDEFB"
      esp0_label: "ESP = TSS.ESP0 (e.g. 0xC0100F00)"
      ss0_label: "SS = TSS.SS0 (e.g. 0x10)"
      pushed: |md
        **CPU pushes onto new stack:**
        - SS (old), ESP (old)
        - EFLAGS, CS (old), EIP (old)
        - Error code (if applicable)
      |
      pushed.shape: text
      pushed.style.font: mono
    }
  }
  
  before -> trigger -> cpu_action -> stack_switch
}

tss_memory <- privilege_transition: CPU reads SS0 ESP0 {
  style.stroke: red
  style.stroke-width: 3
  style.animated: true
}

per_process: Per-Process TSS Management {
  direction: down
  
  pcb_struct: PCB Structure {
    shape: rectangle
    style.fill: "#F3E5F5"
    fields: |md
      struct task_struct {
        void *stack;
        struct tss_struct *tss;
        uint32_t esp0;
        uint32_t ss0;
      }
    |
    fields.shape: text
    fields.style.font: mono
  }
  
  update_flow: Context Switch Sequence {
    shape: rectangle
    style.fill: "#FFF8E1"
    steps: |md
      1. save current ESP0 in prev->esp0
      2. load next->esp0 into TSS.ESP0
      3. update page tables if needed
      4. switch kernel stacks
    |
    steps.shape: text
    steps.style.font: mono
  }
  
  why_update: Why Update ESP0 Every Switch {
    style.fill: "#FFEBEE"
    style.stroke: "#F44336"
    reason: |md
      Each process needs its own kernel stack!
      TSS.ESP0 determines where the kernel
      stack starts for syscalls/interrupts.
    |
    reason.shape: text
  }
  
  pcb_struct -> update_flow -> why_update
}

tss_setup: TSS Initialization {
  style.fill: "#E0F2F1"
  
  gdt_entry: GDT Entry for TSS {
    fields: |md
      Base 0-15  | 0x68
      Base 16-23 | 0x00
      Type       | 0x89 (32-bit TSS)
      Limit 0-15 | 0x67 (104 bytes - 1)
      Base 24-31 | 0xC0
    |
    fields.shape: text
    fields.style.font: mono
  }
  
  single_tss: |md
    **Single TSS Design:**
    - One TSS per CPU (not per process)
    - TR loaded once at boot
    - Only ESP0 changes during context switch
  |
  single_tss.shape: text
  single_tss.style.fill: "#FFF9C4"
}

critical_fields: Critical Fields Summary {
  near: bottom-center
  style.fill: "#FAFAFA"
  style.stroke: "#9E9E9E"
  table: |md
    | Field | Value | Set When |
    |-------|-------|----------|
    | SS0   | 0x10  | Boot     |
    | ESP0  | varies| Ctx sw   |
    | CR3   | varies| Ctx sw   |
  |
  table.shape: text
}

legend: Legend {
  near: bottom-right
  style.fill: "#FAFAFA"
  colors: |md
    Red: Hot path / data flow
    Green: User mode (Ring 3)
    Blue: Kernel mode (Ring 0)
    Yellow: Hardware action
  |
  colors.shape: text
}