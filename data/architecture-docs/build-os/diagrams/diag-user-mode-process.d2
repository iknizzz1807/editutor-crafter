vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # User-Mode Process: Isolated Address Space
  Protection Boundary Between Ring 3 and Ring 0
| {near: top-center}
direction: right
classes: {
  kernel-memory: {
    style: {
      fill: "#2D1B4E"
      stroke: "#6B4C9A"
      stroke-width: 2
      font-color: "#E0D4F7"
    }
  }
  user-memory: {
    style: {
      fill: "#1B3D4E"
      stroke: "#4C8A9A"
      stroke-width: 2
      font-color: "#D4E8F7"
    }
  }
  shared-memory: {
    style: {
      fill: "#3D3D1B"
      stroke: "#8A8A4C"
      stroke-width: 2
      font-color: "#F7F7D4"
    }
  }
  page-table: {
    style: {
      fill: "#1A1A2E"
      stroke: "#4A4A6E"
      stroke-width: 1
      font-color: "#B0B0D0"
      font: mono
    }
  }
  forbidden: {
    style: {
      fill: "#4A1B1B"
      stroke: "#9A4C4C"
      stroke-width: 2
      font-color: "#F7D4D4"
    }
  }
  hardware: {
    style: {
      fill: "#0D1117"
      stroke: "#30363D"
      stroke-width: 2
      font-color: "#C9D1D9"
    }
  }
  fault-box: {
    style: {
      fill: "#4A1B1B"
      stroke: "#FF6B6B"
      stroke-width: 3
      font-color: "#FFB4B4"
    }
  }
}
user_process: User Process (Ring 3) {
  class: user-memory
  user_code: |md
    **User Code**
    `0x08048000`
    c
    int *kernel_ptr = 
      (int*)0xC0100000;
    *kernel_ptr = 42;
    // TRAP!
    
  |
  user_data: |md
    **User Data**
    `0x08049000`
    Valid user memory
    Read/Write access ✓
  |
  user_stack: |md
    **User Stack**
    `0xBFFFF000`
    Grows downward
    PTE_USER | PTE_WRITABLE
  |
  user_code -> user_data: "accesses"
  user_data -> user_stack: "uses"
}
page_directory: Process Page Directory {
  class: page-table
  pd_entries: |md
    **Page Directory Entries**
    | Index | Address Range | PDE | Flags |
    |-------|---------------|-----|-------|
    | 0-191 | 0x00000000-0xBFFFFFFF | User PTs | PTE_USER |
    | 192-255 | 0xC0000000-0xFFFFFFFF | Kernel PTs | **Supervisor Only** |
    `PDE[192+] & PTE_USER == 0`
  |
  user_pt: User Page Table {
    class: user-memory
    entries: |md
      PTE[0]: 0x08048000 → Frame 0x12345000
      Flags: P | RW | U (0x007)
      PTE[1]: 0x08049000 → Frame 0x12346000
      Flags: P | RW | U (0x007)
      PTE[KSTACK]: 0xBFFFF000 → Frame 0xABCDD000
      Flags: P | RW | U (0x007)
    |
  }
  kernel_pt: Kernel Page Table {
    class: kernel-memory
    entries: |md
      PTE[0]: 0xC0000000 → Frame 0x00100000
      Flags: P | RW | **~U** (0x003)
      ↑ SUPERVISOR ONLY
      PTE[1]: 0xC0100000 → Frame 0x00110000
      Flags: P | RW | **~U** (0x003)
      ↑ SUPERVISOR ONLY
    |
  }
  pd_entries -> user_pt: "entries 0-191"
  pd_entries -> kernel_pt: "entries 192-255\n(supervisor only)"
}
cpu_check: CPU Access Check {
  class: hardware
  check_logic: |md
    **Memory Access Logic**
    
    virtual_addr = 0xC0100000
    1. Extract PDE index: [31:22] = 768
    2. Read PDE[768]
    3. Check Present bit: P=1 ✓
    4. Check User/Supervisor: U=0
    5. Current CPL = 3 (user mode)
    6. CPL > U-bit → ACCESS DENIED
    
  |
  privilege_check: Privilege Check {
    class: forbidden
    comparison: |md
      **CPL vs PTE.U**
      | CPL | PTE.U | Result |
      |-----|-------|--------|
      | 0 (kernel) | 0 | ✓ Allowed |
      | 0 (kernel) | 1 | ✓ Allowed |
      | 3 (user) | 0 | ✗ **FAULT** |
      | 3 (user) | 1 | ✓ Allowed |
    |
  }
  check_logic -> privilege_check: "evaluates"
}
fault_result: Page Fault Exception {
  class: fault-box
  exception_14: |md
    **Exception 14: Page Fault (#PF)**
    CR2 = 0xC0100000 (faulting address)
    Error Code:
    ┌─────┬─────┬─────┬─────┬─────┐
    │  0  │  1  │  1  │  0  │ ... │
    └─────┴─────┴─────┴─────┴─────┘
      │     │     │
      │     │     └── U=1: User mode access
      │     └──────── W=1: Write attempt
      └────────────── P=0: Protection violation
                     (not "not present")
  |
  handler_action: Handler Response {
    class: forbidden
    action: |md
      **Kernel Page Fault Handler**
      c
      void page_fault_handler(regs) {
        uint32_t cr2 = read_cr2();
        uint32_t err = regs->err_code;
        if (cr2 >= 0xC0000000 && 
            (err & 0x04)) {  // User mode
          // User tried to access kernel
          kprintf("SEGFAULT: pid=%d addr=0x%x\n",
                  current->pid, cr2);
          sys_exit(SIGSEGV);  // Kill process
        }
      }
      
    |
  }
  exception_14 -> handler_action: "triggers"
}
user_process.user_code -> cpu_check.check_logic: "mov [0xC0100000], eax" {
  style: {
    stroke: "#FF6B6B"
    stroke-width: 3
    stroke-dash: 5
    animated: true
  }
  label: "Attempted\nkernel access"
}
page_directory -> cpu_check.check_logic: "PDE/PTE lookup" {
  style: {
    stroke: "#4C8A9A"
    stroke-width: 2
  }
}
cpu_check.privilege_check -> fault_result.exception_14: "CPL=3 > PTE.U=0" {
  style: {
    stroke: "#FF6B6B"
    stroke-width: 3
    animated: true
  }
  label: "ACCESS\nDENIED"
}
legend: {
  near: bottom-left
  class: hardware
  key: |md
    **Protection Boundary**
    • Kernel pages: `PTE_USER = 0` (supervisor only)
    • User pages: `PTE_USER = 1` (accessible from ring 3)
    • CPL (Current Privilege Level) = lower 2 bits of CS
    • CPU checks: `if (CPL > PTE.U) then #PF`
    **Key Insight**: The page table flags, not the address 
    itself, determine access rights. Kernel is mapped in 
    every process but protected by the U-bit.
  |
}
isolation_note: {
  near: bottom-right
  class: shared-memory
  note: |md
    **Why This Matters**
    1. **Isolation**: Each process has its own page directory
    2. **Shared Kernel**: Kernel is mapped at same VA in all processes
    3. **Protection**: U-bit prevents user code from corrupting kernel
    4. **Efficiency**: No TLB flush on syscall (same kernel mapping)
    This is how every modern OS (Linux, Windows, macOS) 
    implements process isolation on x86.
  |
}