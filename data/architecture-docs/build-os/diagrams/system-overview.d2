direction: right
title: |md
  # x86 Operating System Architecture
  From BIOS Handoff to Preemptive Multitasking
| {near: top-center}

Boot: Boot Process {
  style.fill: "#E8F4FD"
  style.stroke: "#2196F3"
  
  BIOS: {
    shape: hexagon
    style.fill: "#BBDEFB"
    label: "BIOS\nPOST & Handoff"
  }
  
  MBR: {
    label: "Stage 1\nMBR Bootloader\n(512 bytes @ 0x7C00)"
    style.fill: "#90CAF9"
  }
  
  Stage2: {
    label: "Stage 2\nBootloader"
    style.fill: "#90CAF9"
  }
  
  BIOS -> MBR: "Loads sector 0"
  MBR -> Stage2: "Loads from disk"
}

CPU_Init: CPU Initialization {
  style.fill: "#FFF3E0"
  style.stroke: "#FF9800"
  
  A20: {
    label: "A20 Line Enable\n(Methods: BIOS INT 15h,\nPort 0x92, Keyboard Ctrl)"
    style.fill: "#FFE0B2"
  }
  
  GDT: Global Descriptor Table {
    label: "GDT Configuration\n(5 descriptors @ 40 bytes)"
    style.fill: "#FFCC80"
    
    Null: "Null (0x00) - Required"
    KCode: "Kernel Code (0x08)\nRing 0, Exec, Read"
    KData: "Kernel Data (0x10)\nRing 0, Write"
    UCode: "User Code (0x18)\nRing 3, Exec, Read"
    UData: "User Data (0x20)\nRing 3, Write"
  }
  
  PM: {
    label: "Protected Mode\n(CR0.PE = 1)"
    shape: diamond
    style.fill: "#FFB74D"
  }
  
  A20 -> GDT
  GDT -> PM: "lgdt + far jump"
}

Boot.MBR -> CPU_Init.A20
Boot.Stage2 -> CPU_Init.A20

Kernel: Kernel Core {
  style.fill: "#E8F5E9"
  style.stroke: "#4CAF50"
  
  Entry: {
    label: "kernel_entry.asm\n@ 0x100000"
    style.fill: "#C8E6C9"
    
    Stack: "Stack Setup\n(ESP = 0x200000)"
    BSS: "BSS Zeroing\n(__bss_start → __bss_end)"
    Main: "kernel_main()"
    
    Stack -> BSS -> Main
  }
  
  Console: Console Output {
    style.fill: "#A5D6A7"
    
    VGA: {
      label: "VGA Text Mode\n@ 0xB8000\n80×25 characters"
      shape: page
    }
    
    Serial: {
      label: "Serial Port\nCOM1 @ 0x3F8\n115200 baud 8N1"
      shape: page
    }
    
    kprintf: "kprintf()\n%c %s %d %x %p"
    kprintf -> VGA
    kprintf -> Serial
  }
  
  Entry.Main -> Console.kprintf
}

CPU_Init.PM -> Kernel.Entry: "jmp 0x100000"

Interrupts: Interrupt Subsystem {
  style.fill: "#FCE4EC"
  style.stroke: "#E91E63"
  
  IDT: {
    label: "IDT (256 entries)\nVectors 0-255"
    style.fill: "#F8BBD9"
    
    Exceptions: {
      label: "Exceptions (0-31)\n#DE #GP #PF #DF..."
      style.fill: "#F48FB1"
    }
    
    IRQs: {
      label: "Hardware IRQs (32-47)\nRemapped via PIC"
      style.fill: "#F48FB1"
    }
    
    Software: {
      label: "Software (48-255)\nSystem calls (0x80)"
      style.fill: "#F48FB1"
    }
  }
  
  PIC: {
    label: "8259 PIC\nMaster: 0x20-0x21\nSlave: 0xA0-0xA1"
    style.fill: "#F8BBD9"
  }
  
  Handlers: Interrupt Handlers {
    style.fill: "#F8BBD9"
    
    ISR: "ISR Stubs\n(Assembly)"
    IRQ: "IRQ Handlers\n(C dispatcher)"
    
    ISR -> IRQ
  }
  
  IDT.Exceptions -> Handlers.ISR
  IDT.IRQs -> Handlers.IRQ
  PIC -> IDT.IRQs: "IRQ → Vector\n+32 offset"
}

Kernel.Console -> Interrupts.IDT: "idt_flush()"

Drivers: Device Drivers {
  style.fill: "#F3E5F5"
  style.stroke: "#9C27B0"
  
  Timer: {
    label: "PIT Timer\nChannel 0 @ 0x40\n100 Hz tick (IRQ0)"
    style.fill: "#E1BEE7"
  }
  
  Keyboard: {
    label: "PS/2 Keyboard\nData @ 0x60 (IRQ1)\nStatus @ 0x64"
    style.fill: "#E1BEE7"
    
    Scancodes: "Set 1 Scancodes\nMake/Break codes"
    Buffer: "Circular Buffer\n256 chars"
    
    Scancodes -> Buffer
  }
}

Interrupts.IDT.IRQs -> Drivers.Timer: "IRQ0 (Vector 32)"
Interrupts.IDT.IRQs -> Drivers.Keyboard: "IRQ1 (Vector 33)"

Memory: Memory Layout {
  style.fill: "#FFF8E1"
  style.stroke: "#FFC107"
  
  Low: {
    label: "Low Memory (0-1MB)"
    style.fill: "#FFECB3"
    
    IVT: "IVT: 0x000-0x3FF"
    BDA: "BIOS Data: 0x400-0x4FF"
    Free: "Free: 0x500-0x7BFF"
    MBR_Layout: "MBR: 0x7C00-0x7DFF"
    Stage2_Layout: "Stage2: 0x7E00+"
    VGA_Mem: "VGA: 0xA0000-0xBFFFF"
    ROM: "BIOS ROM: 0xC0000+"
  }
  
  High: {
    label: "Extended Memory (>1MB)"
    style.fill: "#FFE082"
    
    Kernel_Load: "Kernel: 0x100000+"
    Stack_High: "Stack: 0x200000"
  }
}

Boot.MBR -> Memory.Low.MBR_Layout
Kernel.Entry -> Memory.High.Kernel_Load

DataStructures: Key Data Structures {
  style.fill: "#E0F2F1"
  style.stroke: "#009688"
  
  GDT_Entry: {
    shape: class
    +offset_low: uint16
    +selector: uint16
    +zero: uint8
    +type_attr: uint8
    +offset_high: uint16
  }
  
  IDT_Entry: {
    shape: class
    +offset_low: uint16
    +selector: uint16
    +zero: uint8
    +type_attr: uint8
    +offset_high: uint16
  }
  
  Registers: {
    shape: class
    "+gs..ds": uint32
    "+edi..eax": uint32
    +int_no: uint32
    +err_code: uint32
    "+eip..ss": uint32
  }
  
  GDTR: {
    shape: class
    +limit: uint16
    +base: uint32
  }
}

CPU_Init.GDT -> DataStructures.GDT_Entry
Interrupts.IDT -> DataStructures.IDT_Entry
Interrupts.Handlers -> DataStructures.Registers

Linker: Linker Script {
  style.fill: "#ECEFF1"
  style.stroke: "#607D8B"
  
  Sections: {
    label: "Sections @ 0x100000"
    style.fill: "#CFD8DC"
    
    Text: ".text (code)"
    Rodata: ".rodata (const)"
    Data: ".data (initialized)"
    BSS_Section: ".bss (uninitialized)"
    
    Text -> Rodata -> Data -> BSS_Section
  }
  
  Symbols: {
    label: "Exported Symbols"
    style.fill: "#B0BEC5"
    
    BSS_Start: "__bss_start"
    BSS_End: "__bss_end"
    Kernel_End: "_kernel_end"
  }
}

Linker.Sections -> Kernel.Entry
Linker.Symbols -> Kernel.Entry.BSS

Flow: Interrupt Flow {
  style.fill: "#FFEBEE"
  style.stroke: "#F44336"
  style.stroke-dash: 3
  
  Hardware: "Hardware Event"
  CPU_Push: "CPU Push:\nEFLAGS, CS, EIP\n(+ SS, ESP if ring change)"
  Stub: "ASM Stub:\nPush registers\nCall C handler"
  C_Handler: "C Handler:\nProcess interrupt"
  EOI: "Send EOI to PIC"
  Restore: "Restore registers\niret"
  
  Hardware -> CPU_Push -> Stub -> C_Handler -> EOI -> Restore
}

Flow.Hardware -> Interrupts.PIC
Flow.Stub -> Interrupts.Handlers

Build: Build System {
  style.fill: "#E3F2FD"
  style.stroke: "#1976D2"
  
  Files: {
    label: "Source Files"
    style.fill: "#BBDEFB"
    
    Boot: "01-boot/*.asm"
    Kernel_C: "02-kernel/*.c"
    Kernel_Asm: "02-kernel/*.asm"
    Linker_Script: "03-linker/linker.ld"
    Interrupts_Src: "05-interrupts/*.c\n05-interrupts/*.asm"
  }
  
  Tools: {
    label: "Toolchain"
    style.fill: "#90CAF9"
    
    NASM: "nasm -f elf32"
    GCC: "gcc -m32 -ffreestanding"
    LD: "ld -m elf_i386"
  }
  
  Output: {
    label: "Output"
    style.fill: "#64B5F6"
    
    IMG: "myos.img\n(10MB disk image)"
  }
  
  Files -> Tools -> Output
}

GDT_Desc: GDT Descriptor Layout {
  style.fill: "#E1F5FE"
  style.stroke: "#03A9F4"
  
  Descriptor: {
    label: "Segment Descriptor (8 bytes)"
    style.fill: "#B3E5FC"
    
    Limit_Low: "Limit[15:0]: 2 bytes"
    Base_Low: "Base[23:0]: 3 bytes"
    Access: "Access Byte: 1 byte\nP DPL S E DC RW A"
    Flags_Limit: "Flags + Limit[19:16]: 1 byte\nG D/B L AVL"
    Base_High: "Base[31:24]: 1 byte"
    
    Limit_Low -> Base_Low -> Access -> Flags_Limit -> Base_High
  }
  
  Selectors: {
    label: "Segment Selectors (16-bit)"
    style.fill: "#B3E5FC"
    
    Index: "Index[15:3]: GDT entry"
    TI: "TI[2]: Table (0=GDT)"
    RPL: "RPL[1:0]: Privilege"
    
    Index -> TI -> RPL
  }
}

CPU_Init.GDT -> GDT_Desc.Descriptor

IDT_Desc: IDT Entry Layout {
  style.fill: "#F3E5F5"
  style.stroke: "#9C27B0"
  
  Entry: {
    label: "IDT Gate Descriptor (8 bytes)"
    style.fill: "#E1BEE7"
    
    Offset_Low: "Offset[15:0]: 2 bytes"
    Seg_Selector: "Segment Selector: 2 bytes\n(0x08 for kernel)"
    Zero: "Reserved: 1 byte (0)"
    Type_Attr: "Type/Attributes: 1 byte\nP DPL 0 Type"
    Offset_High: "Offset[31:16]: 2 bytes"
    
    Offset_Low -> Seg_Selector -> Zero -> Type_Attr -> Offset_High
  }
  
  Types: {
    label: "Gate Types"
    style.fill: "#E1BEE7"
    
    Int: "Interrupt: 0x8E\n(DPL=0, Type=E)"
    Trap: "Trap: 0x8F\n(DPL=0, Type=F)"
    User: "User Trap: 0xEF\n(DPL=3, Type=F)"
  }
}

Interrupts.IDT -> IDT_Desc.Entry

StackFrame: Interrupt Stack Frame {
  style.fill: "#FFF3E0"
  style.stroke: "#FF9800"
  
  Frame: {
    label: "CPU Pushed Frame"
    style.fill: "#FFE0B2"
    
    No_Error: {
      label: "Without Error Code"
      style.fill: "#FFCC80"
      EFLAGS_NoErr: "EFLAGS"
      CS_NoErr: "CS"
      EIP_NoErr: "EIP"
      EFLAGS_NoErr -> CS_NoErr -> EIP_NoErr
    }
    
    With_Error: {
      label: "With Error Code (8,10-14)"
      style.fill: "#FFCC80"
      EFLAGS_Err: "EFLAGS"
      CS_Err: "CS"
      EIP_Err: "EIP"
      ErrCode: "Error Code"
      EFLAGS_Err -> CS_Err -> EIP_Err -> ErrCode
    }
  }
  
  Handler: {
    label: "Handler Pushes"
    style.fill: "#FFE0B2"
    GS: "GS, FS, ES, DS"
    EDI: "EDI, ESI, EBP, ESP"
    EBX: "EBX, EDX, ECX, EAX"
    IntNo: "int_no, err_code"
    GS -> EDI -> EBX -> IntNo
  }
}

Flow.CPU_Push -> StackFrame.Frame
Flow.Stub -> StackFrame.Handler

A20_Detail: A20 Line Methods {
  style.fill: "#FFF8E1"
  style.stroke: "#FFC107"
  
  Methods: {
    label: "A20 Enable Methods"
    style.fill: "#FFECB3"
    
    Method1: {
      label: "1. BIOS INT 15h\nAX=2401"
      style.fill: "#FFE082"
    }
    Method2: {
      label: "2. Fast A20\nPort 0x92"
      style.fill: "#FFE082"
    }
    Method3: {
      label: "3. Keyboard Ctrl\nPort 0x64/0x60"
      style.fill: "#FFE082"
    }
  }
  
  Check: {
    label: "Verification: Wraparound Test\n0x0000:0x0500 vs 0xFFFF:0x0510"
    style.fill: "#FFCC80"
  }
  
  Methods.Method1 -> Methods.Method2: fallback
  Methods.Method2 -> Methods.Method3: fallback
  Methods.Method3 -> Check
}

CPU_Init.A20 -> A20_Detail.Methods

PIC_Config: PIC Remapping {
  style.fill: "#FCE4EC"
  style.stroke: "#E91E63"
  
  Remap: {
    label: "PIC Initialization\nICW1-ICW4"
    style.fill: "#F8BBD9"
    
    Master: "Master PIC\nVectors 32-39\nPorts 0x20-0x21"
    Slave: "Slave PIC\nVectors 40-47\nPorts 0xA0-0xA1"
    
    Master -> Slave: "IRQ2 cascade"
  }
  
  EOI: {
    label: "End of Interrupt\noutb(0x20, 0x20)\noutb(0xA0, 0x20) for slave"
    style.fill: "#F48FB1"
  }
  
  Remap -> EOI
}

Interrupts.PIC -> PIC_Config.Remap

PM_Transition: Protected Mode Transition {
  style.fill: "#E8F5E9"
  style.stroke: "#4CAF50"

  Seq: {
    label: "Transition Sequence"
    style.fill: "#C8E6C9"

    Step1: "1. cli (disable interrupts)"
    Step2: "2. lgdt [gdt_descriptor]"
    Step3: "3. mov eax, cr0"
    Step4: "4. or eax, 1 (set PE)"
    Step5: "5. mov cr0, eax"
    Step6: "6. jmp 0x08:protected_mode_entry"
    Step7: "7. Reload DS, ES, FS, GS, SS with 0x10"
    Step8: "8. mov esp, 0x90000"

    Step1 -> Step2 -> Step3 -> Step4 -> Step5 -> Step6 -> Step7 -> Step8
  }

  Critical: {
    label: "CRITICAL: Steps 5-6 must be adjacent\nAny instruction between causes undefined state"
    style.fill: "#FFCDD2"
    style.stroke: "#F44336"
  }

  Seq.Step5 -> Critical
}

CPU_Init.PM -> PM_Transition.Seq

legend: {
  near: bottom-center
  style.fill: white
  style.stroke: gray
  
  Boot_Legend: "Blue = Boot Process"
  CPU_Legend: "Orange = CPU Init"
  Kernel_Legend: "Green = Kernel"
  Int_Legend: "Pink = Interrupts"
  Driver_Legend: "Purple = Drivers"
  Mem_Legend: "Yellow = Memory"
}