layout-engine: elk
theme-id: 200

title: |md
  # CPU Exception Flow: Divide Error to Handler
  Step-by-step from division instruction through exception trigger, stack frame construction, handler invocation, and iret return
| {near: top-center}

vars: {
  d2-config: {
    layout-engine: elk
  }
}

classes: {
  step_box: {
    style: {
      fill: "#E8F4FD"
      stroke: "#2563EB"
      stroke-width: 2
      border-radius: 8
    }
  }
  code_box: {
    style: {
      fill: "#1E293B"
      font-color: "#E2E8F0"
      font: mono
      border-radius: 4
    }
  }
  register_box: {
    style: {
      fill: "#FEF3C7"
      stroke: "#D97706"
      border-radius: 4
    }
  }
  stack_box: {
    style: {
      fill: "#DCFCE7"
      stroke: "#16A34A"
      border-radius: 4
    }
  }
  changed: {
    style: {
      fill: "#FEE2E2"
      stroke: "#DC2626"
      stroke-width: 3
      bold: true
    }
  }
  arrow_label: {
    style: {
      font-size: 14
      fill: "#475569"
    }
  }
}

direction: right

step0: {
  class: step_box
  label: "Step 0: Normal Execution"
  
  code: {
    class: code_box
    label: |go
      ; Process running normally
      mov eax, 42
      mov ebx, 0
      div ebx      ; â† EIP here
    |
  }
  
  registers: {
    class: register_box
    label: |md
      **Registers Before:**
      - EIP = 0x00101234
      - EAX = 0x0000002A
      - EBX = 0x00000000
      - EFLAGS = 0x00000202
      - CS = 0x08
      - SS:ESP = 0x10:0x0000FFF0
    |
  }
}

step1: {
  class: step_box
  label: "Step 1: Division by Zero Triggered"
  
  trigger: {
    class: changed
    label: |md
      **CPU Detects Error:**
      - Division by zero
      - Exception vector 0
      - **Push to stack:**
        - EFLAGS
        - CS
        - EIP
    |
  }
  
  cpu_action: {
    label: |md
      CPU Internal Actions:
      1. Reads IDT entry 0
      2. Validates gate (P=1, DPL)
      3. Loads new CS:EIP
      4. Clears IF (interrupt gate)
    |
  }
}

step2: {
  class: step_box
  label: "Step 2: CPU-Pushed Stack Frame"
  
  stack_before: {
    class: stack_box
    label: |md
      **Stack (grows down)**
      
      
      0xFFF0: [old data]
      0xFFEC: [old data]
      0xFFE8: [old data]
      
    |
  }
  
  stack_after: {
    class: changed
    label: |md
      **Stack After CPU Push**
      
      
      0xFFF0: [old data]
      0xFFEC: [old data]
      0xFFE8: [old data]
      0xFFE4: EIP=0x00101234  â† NEW
      0xFFE0: CS  =0x00000008  â† NEW
      0xFFDC: EFLAGS=0x00000202â† NEW
              ESP now here
      
    |
  }
}

step3: {
  class: step_box
  label: "Step 3: ISR Stub Entry (isr0)"
  
  stub_code: {
    class: code_box
    label: |go
      isr0:
        cli              ; Ensure ints disabled
        push byte 0      ; Dummy error code
        push byte 0      ; Exception number
        jmp isr_common_stub
    |
  }
  
  stack_stub: {
    class: changed
    label: |md
      **Stack After Stub Pushes**
      
      
      0xFFD8: err=0x00000000 â† NEW
      0xFFD4: int=0x00000000 â† NEW
      0xFFD0: EIP=0x00101234
      0xFFCC: CS  =0x00000008
      0xFFC8: EFLAGS=0x00000202
              ESP now here
      
    |
  }
}

step4: {
  class: step_box
  label: "Step 4: Common Stub Saves Context"
  
  common_code: {
    class: code_box
    label: |go
      isr_common_stub:
        pusha            ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
        push ds
        push es
        push fs
        push gs
        mov ax, 0x10     ; Kernel data seg
        mov ds, ax
        mov es, ax
        push esp         ; Pass stack ptr
        call c_interrupt_handler
    |
  }
  
  stack_full: {
    class: changed
    label: |md
      **Complete Stack Frame**
      
      
      0xFFC4: GS   â† NEW
      0xFFC0: FS   â† NEW
      0xFFBC: ES   â† NEW
      0xFFB8: DS   â† NEW
      0xFFB4: EDI  â† NEW (pusha)
      0xFFB0: ESI  â† NEW
      0xFFAC: EBP  â† NEW
      0xFFA8: ESP  â† NEW (before pusha)
      0xFFA4: EBX  â† NEW
      0xFFA0: EDX  â† NEW
      0xFF9C: ECX  â† NEW
      0xFF98: EAX  â† NEW
      0xFF94: int_no=0
      0xFF90: err_code=0
      0xFF8C: EIP=0x00101234
      0xFF88: CS  =0x00000008
      0xFF84: EFLAGS=0x00000202
      0xFF80: &regs (arg) â† NEW
              ESP now here
      
    |
  }
}

step5: {
  class: step_box
  label: "Step 5: C Handler Execution"
  
  c_handler: {
    class: code_box
    label: |go
      void c_interrupt_handler(registers_t *regs) {
        if (regs->int_no < 32) {
          exception_handler(regs);
        }
      }
      
      void exception_handler(registers_t *regs) {
        kprintf("EXCEPTION: %s\n",
                exception_messages[regs->int_no]);
        // "Division by zero"
        kprintf("EIP: 0x%x\n", regs->eip);
        // Halt system
        cli; hlt;
      }
    |
  }
  
  dispatch: {
    label: |md
      **Handler Actions:**
      1. Check int_no < 32 (exception)
      2. Look up message in table
      3. Print diagnostic
      4. Halt system (for fatal)
    |
  }
}

step6: {
  class: step_box
  label: "Step 6: Restore and iret (if resumable)"
  
  restore_code: {
    class: code_box
    label: |go
      ; After C handler returns
      add esp, 4        ; Remove arg
      pop gs
      pop fs
      pop es
      pop ds
      popa              ; Restore GP regs
      add esp, 8        ; Remove int_no, err_code
      iret              ; Restore EIP, CS, EFLAGS
    |
  }
  
  stack_restore: {
    class: stack_box
    label: |md
      **iret Pops:**
      
      
      EIP  â† 0x00101234
      CS   â† 0x00000008
      EFLAGS â† 0x00000202
      [SS:ESP if CPL changed]
      
      
      **Execution resumes** at faulting instruction
    |
  }
}

step7: {
  class: step_box
  label: "Step 7: Post-iret State"
  
  final_state: {
    class: register_box
    label: |md
      **Registers After iret:**
      - EIP = 0x00101234 (faulting instr)
      - CS = 0x08
      - EFLAGS = 0x00000202 (IF restored)
      - All GP registers preserved
      
      **Note:** Division would fault again!
      (Real OS would terminate process)
    |
  }
}

step0 -> step1: "Division executes\n divisor=0" {class: arrow_label}
step1 -> step2: "CPU triggers\nexception 0" {class: arrow_label}
step2 -> step3: "CPU pushes\nEIP/CS/EFLAGS" {class: arrow_label}
step3 -> step4: "Stub pushes\ndummy err + int_no" {class: arrow_label}
step4 -> step5: "Stub saves\nall registers" {class: arrow_label}
step5 -> step6: "C handler\nprocesses" {class: arrow_label}
step6 -> step7: "iret restores\nEIP/CS/EFLAGS" {class: arrow_label}

legend: {
  near: bottom-center
  label: |md
    **Legend:**
    - ðŸ”´ Red border = Changed/Modified state
    - ðŸŸ¡ Yellow = Register values
    - ðŸŸ¢ Green = Stack memory
    - â¬› Dark = Code snippets
    
    **Key Points:**
    1. CPU pushes minimal state (EIP, CS, EFLAGS)
    2. Stub adds dummy error code for uniform frame
    3. pusha saves all 8 GP registers
    4. Segment registers saved separately
    5. iret restores CPU-pushed state only
  |
}