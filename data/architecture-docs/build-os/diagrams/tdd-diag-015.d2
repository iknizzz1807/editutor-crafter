vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Circular Keyboard Buffer State Machine
  Buffer states (empty, partial, full), read/write pointer updates, wraparound handling
| {near: top-center}

classes: {
  state: {
    shape: circle
    style: {
      stroke-width: 3
      font-size: 20
      bold: true
    }
  }
  empty: {
    shape: circle
    style.fill: "#E8F5E9"
    style.stroke: "#4CAF50"
    style.stroke-width: 3
    style.font-size: 20
    style.bold: true
  }
  partial: {
    shape: circle
    style.fill: "#FFF3E0"
    style.stroke: "#FF9800"
    style.stroke-width: 3
    style.font-size: 20
    style.bold: true
  }
  full: {
    shape: circle
    style.fill: "#FFEBEE"
    style.stroke: "#F44336"
    style.stroke-width: 3
    style.font-size: 20
    style.bold: true
  }
  error: {
    shape: circle
    style.fill: "#FFCDD2"
    style.stroke: "#D32F2F"
    style.stroke-dash: 4
    style.stroke-width: 3
    style.font-size: 20
    style.bold: true
  }
  transition: {
    style: {
      stroke-width: 2
      font-size: 14
    }
  }
  write: {
    style.stroke: "#2196F3"
    style.font-color: "#1565C0"
    style.stroke-width: 2
    style.font-size: 14
  }
  read: {
    style.stroke: "#4CAF50"
    style.font-color: "#2E7D32"
    style.stroke-width: 2
    style.font-size: 14
  }
  overflow: {
    style.stroke: "#F44336"
    style.stroke-dash: 4
    style.font-color: "#C62828"
    style.stroke-width: 2
    style.font-size: 14
  }
}

EMPTY: Empty {
  class: empty
  tooltip: |md
    **Invariant:** read_pos == write_pos
    
    Buffer contains 0 characters.
    Keyboard handler can write.
    getchar() will block.
  |
}

PARTIAL: Partial {
  class: partial
  tooltip: |md
    **Invariant:** (write_pos - read_pos) % SIZE != 0
    AND not full
    
    Buffer contains N characters (0 < N < SIZE-1).
    Both read and write operations valid.
  |
}

FULL: Full {
  class: full
  tooltip: |md
    **Invariant:** (write_pos + 1) % SIZE == read_pos
    
    Buffer contains SIZE-1 characters.
    Keyboard handler cannot write (would overflow).
    getchar() can read.
  |
}

OVERFLOW_DROP: Overflow\n(Drop Oldest) {
  class: error
  tooltip: |md
    **Error State:** Buffer overflow detected
    
    Recovery: Drop oldest character
    (advance read_pos, then write)
  |
}

OVERFLOW_IGNORE: Overflow\n(Ignore New) {
  class: error
  tooltip: |md
    **Error State:** Buffer overflow detected
    
    Recovery: Ignore new character
    (do not advance write_pos)
  |
}

# Transitions from EMPTY
EMPTY -> PARTIAL: IRQ: write_pos++\nwrap: (w+1)%SIZE {
  class: write
  label: |md
    **Write on Empty**
    
    buffer[write_pos] = char
    write_pos = (write_pos + 1) % SIZE
    
  |
}

# Transitions from PARTIAL
PARTIAL -> PARTIAL: IRQ: write_pos++\n(if not full) {
  class: write
  label: |md
    **Write (not full)**
    
    buffer[write_pos] = char
    write_pos = (write_pos + 1) % SIZE
    
  |
}

PARTIAL -> PARTIAL: getchar(): read_pos++\n(if not empty) {
  class: read
  label: |md
    **Read (not empty)**
    
    char = buffer[read_pos]
    read_pos = (read_pos + 1) % SIZE
    
  |
}

PARTIAL -> FULL: IRQ: write\nmakes full {
  class: write
  label: |md
    **Write fills buffer**
    
    if ((write_pos + 1) % SIZE == read_pos)
      → FULL
    
  |
}

PARTIAL -> EMPTY: getchar():\nlast char read {
  class: read
  label: |md
    **Read last character**
    
    read_pos = (read_pos + 1) % SIZE
    // Now read_pos == write_pos
    
  |
}

# Transitions from FULL
FULL -> PARTIAL: getchar(): read_pos++ {
  class: read
  label: |md
    **Read from full**
    
    char = buffer[read_pos]
    read_pos = (read_pos + 1) % SIZE
    // Space now available
    
  |
}

FULL -> OVERFLOW_DROP: IRQ: write\nattempt {
  class: overflow
  label: |md
    **Write attempt on full**
    (drop oldest policy)
  |
}

FULL -> OVERFLOW_IGNORE: IRQ: write\nattempt {
  class: overflow
  label: |md
    **Write attempt on full**
    (ignore new policy)
  |
}

# Overflow recovery transitions
OVERFLOW_DROP -> FULL: Drop oldest\nthen write {
  style.stroke: "#9C27B0"
  style.stroke-width: 2
  style.font-size: 14
  label: |md
    **Recovery:**
    
    read_pos = (read_pos + 1) % SIZE
    buffer[write_pos] = char
    write_pos = (write_pos + 1) % SIZE
    
  |
}

OVERFLOW_IGNORE -> FULL: Ignore\nnew char {
  style.stroke: "#9C27B0"
  style.stroke-width: 2
  style.font-size: 14
  label: |md
    **Recovery:**
    
    // Do nothing
    // Character lost
    
  |
}

# Initial state indicator
INIT: ● {
  shape: circle
  style.fill: "#4CAF50"
  width: 20
  height: 20
}

INIT -> EMPTY: Initialize {
  style.stroke: "#4CAF50"
  style.stroke-width: 3
  label: |md
    
    read_pos = 0
    write_pos = 0
    
  |
}

# Buffer visualization
buffer_vis: {
  label: "Circular Buffer Visualization (SIZE=8)"
  
  slots: {
    shape: sequence_diagram
    width: 600
    
    slot0: "[0]"
    slot1: "[1]"
    slot2: "[2]"
    slot3: "[3]"
    slot4: "[4]"
    slot5: "[5]"
    slot6: "[6]"
    slot7: "[7]"
    
    slot0 -> slot1
    slot1 -> slot2
    slot2 -> slot3
    slot3 -> slot4
    slot4 -> slot5
    slot5 -> slot6
    slot6 -> slot7
    slot7 -> slot0: wrap
  }
  
  pointers: |md
    
    read_pos  → consumer index
    write_pos → producer index
    
    Full condition: (write_pos + 1) % SIZE == read_pos
    Empty condition: read_pos == write_pos
    Available: (write_pos - read_pos + SIZE) % SIZE
    
  |
  
  example_partial: |md
    **Example: Partial buffer (3 chars)**
    
       read_pos=2, write_pos=5
    
       [0] [1] [2] [3] [4] [5] [6] [7]
           R   A   B   C   W
               ↑       ↑
           read    write
    
  |
  
  example_full: |md
    **Example: Full buffer (7 chars, SIZE=8)**
    
       read_pos=0, write_pos=7
    
       [0] [1] [2] [3] [4] [5] [6] [7]
        A   B   C   D   E   F   G   W
        R                       ↑
                            (W+1)%8=0=R
    
  |
}

# Legend
legend: {
  near: bottom-right
  
  states_legend: {
    label: "States"
    
    empty_legend: Empty {
      class: empty
      width: 60
      height: 60
    }
    partial_legend: Partial {
      class: partial
      width: 60
      height: 60
    }
    full_legend: Full {
      class: full
      width: 60
      height: 60
    }
    
    empty_legend -> partial_legend -> full_legend
  }
  
  transitions_legend: {
    label: "Transitions"
    
    write_leg: Write (IRQ) {
      class: write
      shape: rectangle
      style.fill: "#E3F2FD"
    }
    read_leg: Read (getchar) {
      class: read
      shape: rectangle
      style.fill: "#E8F5E9"
    }
    overflow_leg: Overflow {
      class: overflow
      shape: rectangle
      style.fill: "#FFEBEE"
    }
    
    write_leg -> read_leg -> overflow_leg
  }
  
  invariants: |md
    **Key Invariants:**
    
    1. Buffer never truly full (SIZE-1 max)
       - Always one empty slot for distinction
    
    2. Single producer (IRQ context)
       - Only keyboard handler writes
    
    3. Single consumer (main context)
       - Only getchar() reads
    
    4. Volatile indices prevent race
       - `volatile uint32_t read_pos, write_pos`
    
    5. Wraparound: `% SIZE` on all increments
  |
}