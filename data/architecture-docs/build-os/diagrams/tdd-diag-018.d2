vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Frame Allocator Bitmap Layout
  Physical memory management via bitmap (1 bit per 4KB frame)
| {near: top-center}

scale: {
  label: "Memory Scale"
  4GB_Physical: {
    shape: rectangle
    label: "4GB Physical RAM\n(0x00000000 - 0xFFFFFFFF)"
    style.fill: "#E8E8E8"
    style.stroke: "#666666"
  }
  
  frame_division: {
    label: "รท 4KB frames"
    shape: text
  }
  
  total_frames: {
    shape: rectangle
    label: "= 1,048,576 frames\n(2^20 frames)"
    style.fill: "#D4EDDA"
    style.stroke: "#28A745"
  }
  
  bitmap_division: {
    label: "รท 8 bits/byte"
    shape: text
  }
  
  bitmap_size: {
    shape: rectangle
    label: "= 131,072 bytes\n(128 KB bitmap)"
    style.fill: "#FFF3CD"
    style.stroke: "#FFC107"
  }
  
  4GB_Physical -> frame_division -> total_frames -> bitmap_division -> bitmap_size
}

bitmap_array: {
  label: "frame_bitmap[32768]  // uint32_t array"
  style.fill: "#F8F9FA"
  style.stroke: "#DEE2E6"
  
  header: |md
    **Bitmap Array Layout**
    Each uint32_t word tracks 32 frames
  | {near: top-center}
  
  word_0: {
    label: |md
      `bitmap[0]`
      Frames 0-31
      Physical: 0x00000000-0x0001FFFF
    |
    style.fill: "#CCE5FF"
    
    bit_visual: {
      label: "bits: 31 30 29 ... 2 1 0"
      shape: text
      style.font: mono
    }
    
    example_value: {
      label: "0xFFFFFFFD = 1111...1101\n(Frame 1 used, others free)"
      shape: text
      style.font: mono
      style.fill: "#E8E8E8"
    }
  }
  
  word_1: {
    label: |md
      `bitmap[1]`
      Frames 32-63
      Physical: 0x00020000-0x0003FFFF
    |
    style.fill: "#D4EDDA"
  }
  
  ellipsis: {
    label: "..."
    shape: text
  }
  
  word_n: {
    label: |md
      `bitmap[n]`
      Frames 32n to 32n+31
    |
    style.fill: "#FFF3CD"
  }
  
  ellipsis_2: {
    label: "..."
    shape: text
  }
  
  word_last: {
    label: |md
      `bitmap[32767]`
      Frames 1048544-1048575
      Physical: 0xFFF80000-0xFFFFFFFF
    |
    style.fill: "#F8D7DA"
  }
}

operations: {
  label: "Bit Manipulation Macros"
  
  macros: |md
    c
    #define FRAME_INDEX(addr)    ((addr) >> 12)
    #define WORD_INDEX(frame)    ((frame) >> 5)
    #define BIT_INDEX(frame)     ((frame) & 0x1F)

    #define SET_BIT(frame)  \
      (bitmap[WORD_INDEX(frame)] |= (1U << BIT_INDEX(frame)))

    #define CLEAR_BIT(frame) \
      (bitmap[WORD_INDEX(frame)] &= ~(1U << BIT_INDEX(frame)))

    #define TEST_BIT(frame)  \
      (bitmap[WORD_INDEX(frame)] & (1U << BIT_INDEX(frame)))
    
  |
}

set_bit_op: {
  label: "SET_BIT(frame) - Mark Frame Used"
  
  before: {
    label: "Before"
    word_before: {
      label: "bitmap[word_idx] = 0xFFFFFFF8"
      style.fill: "#E8E8E8"
    }
    bits_before: {
      label: "1111 1111 1111 1111 1111 1111 1111 1000"
      shape: text
      style.font: mono
    }
    status_before: {
      label: "Frame 2 is FREE (bit=0)"
      shape: text
    }
  }
  
  arrow_set: {
    label: "OR with (1 << 2)"
    shape: text
  }
  
  after: {
    label: "After"
    word_after: {
      label: "bitmap[word_idx] = 0xFFFFFFFC"
      style.fill: "#CCE5FF"
    }
    bits_after: {
      label: "1111 1111 1111 1111 1111 1111 1111 1100"
      shape: text
      style.font: mono
      style.bold: true
      style.fill: "#FFCCCC"
    }
    status_after: {
      label: "Frame 2 is USED (bit=1)"
      shape: text
      style.bold: true
    }
  }
  
  before -> arrow_set -> after
}

clear_bit_op: {
  label: "CLEAR_BIT(frame) - Mark Frame Free"
  
  before_clear: {
    label: "Before: bit 5 = 1 (used)"
    shape: text
  }
  
  op_clear: {
    label: "AND with ~(1 << 5) = 0xFFFFFFDF"
    shape: text
  }
  
  after_clear: {
    label: "After: bit 5 = 0 (free)"
    shape: text
    style.fill: "#D4EDDA"
  }
  
  before_clear -> op_clear -> after_clear
}

linear_scan: {
  label: "Linear Scan for Free Frame"
  style.fill: "#F0F0F0"
  
  algo: |md
    c
    uint32_t pmm_alloc_frame(void) {
      for (uint32_t i = 0; i < 32768; i++) {
        if (bitmap[i] != 0xFFFFFFFF) {
          uint32_t word = bitmap[i];
          uint32_t bit_idx;
          __asm__("bsf %1, %0" : "=r"(bit_idx) : "r"(~word));
          uint32_t frame = (i << 5) | bit_idx;
          SET_BIT(frame);
          return frame << 12;
        }
      }
      return 0;
    }
    
  |
  
  scan_visual: {
    label: "Scan Visualization"
    
    word_check_1: {
      label: "bitmap[0] = 0xFFFFFFFF\nAll used, skip"
      style.fill: "#F8D7DA"
    }
    
    word_check_2: {
      label: "bitmap[1] = 0xFFFFFFFF\nAll used, skip"
      style.fill: "#F8D7DA"
    }
    
    word_check_3: {
      label: "bitmap[2] = 0xFFFFFFF7\nFree bit found!"
      style.fill: "#D4EDDA"
      style.bold: true
    }
    
    result: {
      label: "BSF finds bit 3\nFrame = 2*32 + 3 = 67\nReturn 0x43000"
      shape: text
      style.fill: "#CCE5FF"
    }
    
    word_check_1 -> word_check_2 -> word_check_3 -> result
  }
}

mapping: {
  label: "Frame <-> Physical Address Mapping"
  
  frame_to_addr: {
    label: |md
      **Frame Index to Physical Address**
      
      frame = 0x00042
      physical = frame * 4096 = 0x42000
    |
    style.fill: "#E8F4FD"
  }
  
  addr_to_frame: {
    label: |md
      **Physical Address to Frame Index**
      
      physical = 0x12345000
      frame = physical / 4096 = 0x12345
      bit = frame % 32 = 5
      word = frame / 32 = 3724
    |
    style.fill: "#FDF8E8"
  }
  
  frame_to_addr -> addr_to_frame
}

legend: {
  label: "Legend"
  near: bottom-right
  
  used: {
    label: "bit = 1: Frame USED"
    style.fill: "#F8D7DA"
  }
  free: {
    label: "bit = 0: Frame FREE"
    style.fill: "#D4EDDA"
  }
  scanning: {
    label: "Currently scanning"
    style.fill: "#FFF3CD"
  }
}

scale.bitmap_size -> bitmap_array
bitmap_array -> operations
operations -> set_bit_op
operations -> clear_bit_op
bitmap_array -> linear_scan