vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Paging Enable Transition Sequence
| {near: top-center}

shape: sequence_diagram

Pre_Paging_State
CR3_Load
CR0_PG_Set
Identity_Map_Active
Higher_Half_Jump
Post_Paging_State

Phase_1_Preparation: {
  Pre_Paging_State -> CR3_Load: "1. Load page directory\nphysical address into CR3"
  Pre_Paging_State.note: |md
    **Pre-Paging State**
    
    - CPU in protected mode (32-bit)
    - CR0.PG = 0 (paging disabled)
    - All addresses are physical
    - GDT configured with flat segments
    - Page tables already built in memory
  |
}

Phase_2_Enable: {
  CR3_Load -> CR0_PG_Set: "2. Set CR0.PG bit (bit 31)"
  CR0_PG_Set.note: "mov eax, cr0\nor eax, (1 << 31)\nmov cr0, eax"
}

Phase_3_Critical_Window: {
  CR0_PG_Set -> Identity_Map_Active: "3. CRITICAL: CPU now translates\nALL addresses through page tables"
  Identity_Map_Active.note: |md
    **Identity map MUST be active here!**
    
    - EIP still at physical address
    - Page tables must map this address
    - First 4MB identity-mapped:
      - Virtual 0x0 â†’ Physical 0x0
      - Covers kernel code, VGA, boot data
    - Without this: instant page fault
  |
}

Phase_4_Transition: {
  Identity_Map_Active -> Higher_Half_Jump: "4. Far jump to higher-half\nvirtual address"
  Higher_Half_Jump.note: "jmp 0xC0100000"
}

Phase_5_Complete: {
  Higher_Half_Jump -> Post_Paging_State: "5. Running at virtual address\n0xC0000000+"
  Post_Paging_State.note: |md
    **Paging fully enabled**
    
    - All kernel code at higher-half
    - Identity map can be removed
    - User processes get own PDs
    - Isolation boundaries in place
  |
}

Critical_Timing: {
  Identity_Map_Active -> Identity_Map_Active: "CPU fetches next instruction\nusing page tables\nfor the FIRST time"
}