vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    cpu: "#E8D5B7"
    memory: "#B5D8EB"
    handler: "#C8E6C9"
    decision: "#FFE0B2"
    error: "#FFCDD2"
    text: "#F3E5F5"
  }
}

title: |md
  # Page Fault Handling: CR2 and Error Code
| {near: top-center}

direction: right

classes: {
  cpu_state: {
    shape: rectangle
    style: {
      fill: "${colors.cpu}"
      stroke: "#8B7355"
      stroke-width: 2
      font: mono
    }
  }
  memory_op: {
    shape: rectangle
    style: {
      fill: "${colors.memory}"
      stroke: "#4A90A4"
      stroke-width: 2
    }
  }
  handler_step: {
    shape: rectangle
    style: {
      fill: "${colors.handler}"
      stroke: "#4CAF50"
      stroke-width: 2
    }
  }
  decision_node: {
    shape: diamond
    style: {
      fill: "${colors.decision}"
      stroke: "#FF9800"
      stroke-width: 2
    }
  }
  error_state: {
    shape: rectangle
    style: {
      fill: "${colors.error}"
      stroke: "#D32F2F"
      stroke-width: 2
      font-color: "#B71C1C"
    }
  }
  text_output: {
    shape: parallelogram
    style: {
      fill: "${colors.text}"
      stroke: "#7B1FA2"
      stroke-width: 2
    }
  }
}

step1: "Step 1: Page Fault Entry" {
  class: cpu_state
  
  trigger: "Memory Access" {
    shape: oval
    style.fill: "${colors.memory}"
  }
  
  cpu_action: "CPU Pushes to Stack" {
    shape: rectangle
    style.fill: "${colors.cpu}"
    
    stack_frame: |md
      
      SS (if CPL change)
      ESP (if CPL change)
      EFLAGS
      CS
      EIP
      Error Code ← pushed by CPU
      
    |
  }
  
  trigger -> cpu_action: "Invalid page access"
}

step2: "Step 2: Read CR2" {
  class: handler_step
  
  cr2_read: "mov %cr2, %eax" {
    shape: rectangle
    style: {
      fill: "${colors.handler}"
      font: mono
    }
  }
  
  cr2_value: "CR2 = Faulting Address" {
    shape: cylinder
    style.fill: "${colors.memory}"
  }
  
  cr2_read -> cr2_value: "Read"
}

step3: "Step 3: Decode Error Code" {
  class: handler_step
  
  error_code: "Error Code (from stack)" {
    shape: rectangle
    style.fill: "${colors.memory}"
  }
  
  bit_layout: |md
    
    Error Code Bits:
    ┌───┬───┬───┬───┬───┐
    │ I │ R │ U │ W │ P │
    └───┴───┴───┴───┴───┘
      │   │   │   │   └─ Present (0=not present)
      │   │   │   └───── Write (1=write access)
      │   │   └───────── User (1=user mode)
      │   └───────────── Reserved bit set
      └───────────────── Instruction fetch (NX)
    
  | {shape: text}
  
  error_code -> bit_layout
}

step4: "Step 4: Determine Cause" {
  class: decision_node
  
  check_present: "P bit?" {
    class: decision_node
  }
  
  not_present: "Page Not Present" {
    class: error_state
  }
  
  protection: "Protection Violation" {
    class: error_state
  }
  
  check_present -> not_present: "P=0"
  check_present -> protection: "P=1"
  
  check_write: "W bit?" {
    class: decision_node
  }
  
  write_fault: "Write to\nRead-Only" {
    class: error_state
  }
  
  check_user: "U bit?" {
    class: decision_node
  }
  
  user_fault: "User Access\nto Kernel Page" {
    class: error_state
  }
  
  protection -> check_write
  check_write -> write_fault: "W=1"
  check_write -> check_user: "W=0"
  check_user -> user_fault: "U=1"
}

step5: "Step 5: Diagnostic Output" {
  class: text_output
  
  output: "kprintf Output" {
    shape: parallelogram
    style.fill: "${colors.text}"
    
    message: |md
      
      ===== PAGE FAULT =====
      Faulting address: 0xDEADBEEF
      Error code: 0x07
      
      Cause: Page not present
      Access type: Write
      Mode: User
      
      EIP at fault: 0x00101234
      CR3: 0x00023000
      
    |
  }
}

step6: "Step 6: Recovery Decision" {
  class: decision_node
  
  can_recover: "Recoverable?" {
    class: decision_node
  }
  
  demand_load: "Demand Paging\n(Not Implemented)" {
    shape: rectangle
    style: {
      fill: "${colors.decision}"
      stroke-dash: 3
    }
  }
  
  halt: "System Halt" {
    class: error_state
    
    halt_code: |md
      asm
      cli
      hlt
      jmp .
      
    |
  }
  
  can_recover -> demand_load: "Yes\n(future)"
  can_recover -> halt: "No\n(current)"
}

step1 -> step2: "Handler entry"
step2 -> step3: "CR2 saved"
step3 -> step4: "Bits decoded"
step4 -> step5: "Cause determined"
step5 -> step6: "Diagnostics printed"

legend: "Legend" {
  legend_items: {
    cpu: "CPU State" {class: cpu_state}
    memory: "Memory/Register" {class: memory_op}
    handler: "Handler Step" {class: handler_step}
    decision: "Decision" {class: decision_node}
    error: "Error State" {class: error_state}
    output: "Output" {class: text_output}
  }
}

legend.style.fill: "#FAFAFA"
legend.style.stroke: "#E0E0E0"