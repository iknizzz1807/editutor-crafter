vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

Timer Interrupt to Context Switch Sequence: {
  shape: sequence_diagram
  
  Hardware
  TimerIRQ: Timer IRQ (IRQ0)
  IDT: IDT Gate 32
  Handler: Timer Handler
  Scheduler: scheduler_pick_next()
  ContextSwitch: context_switch()
  OldProcess: Old Process PCB
  NewProcess: New Process PCB
  CPU: CPU State
  
  Hardware."① Timer fires"
  
  Hardware.t1 -> TimerIRQ.t1: IRQ0 asserted
  TimerIRQ.t1 -> IDT.t1: Lookup vector 32
  
  Interrupt Context: {
    IDT.t1 -> Handler.t1: Jump to handler (IF cleared)
    Handler.t1 -> Handler.t1: pusha (save registers)
    Handler.t1 -> Handler.t1: push ds/es/fs/gs
    Handler.t1.a -> Handler.t1.a: cli (atomicity)
    Handler.t1.a -> Scheduler.t1: scheduler_timer_tick()
    Scheduler.t1 -> Scheduler.t1: time_slice-- → 0
    Scheduler.t1 -> Scheduler.t1: pick_next_ready()
  }
  
  Context Switch Phase: {
    Scheduler.t2 -> ContextSwitch.t2: context_switch(old, new)
    
    ContextSwitch.t2 -> OldProcess.t2: Save segment regs
    ContextSwitch.t2 -> OldProcess.t2: Save general regs
    ContextSwitch.t2 -> OldProcess.t2: Save ESP → pcb.esp
    ContextSwitch.t2 -> OldProcess.t2: Save EIP (return addr)
    ContextSwitch.t2 -> OldProcess.t2: Save CR3 → pcb.cr3
    
    ContextSwitch.t2 -> NewProcess.t3: Load CR3 (TLB flush!)
    ContextSwitch.t2 -> NewProcess.t3: Update TSS ESP0
    ContextSwitch.t2 -> NewProcess.t3: Load segment regs
    ContextSwitch.t2 -> NewProcess.t3: Load general regs
    ContextSwitch.t2 -> NewProcess.t3: Load ESP
  }
  
  Return to New Process: {
    ContextSwitch.t3 -> CPU.t3: Restore EFLAGS (IF restored)
    ContextSwitch.t3 -> CPU.t3: iret
    CPU.t3 -> CPU.t3: Pop EIP, CS, EFLAGS
    CPU.t3 -> CPU.t3: Resume at new EIP
  }
  
  NewProcess."② Execution resumes"
}

Atomicity Requirements: {
  note: |md
    **CRITICAL: Interrupts Disabled During Switch**
    
    1. `cli` before context_switch — prevents reentrancy
    2. All register saves must complete atomically
    3. CR3 reload flushes TLB (100-500 cycles)
    4. `iret` restores IF from new process EFLAGS
    
    **Why Atomicity Matters:**
    - If IRQ fires mid-switch → corrupted state
    - If page fault during switch → double fault
    - Stack must be valid throughout
  |
}