vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  ## Exception Cascade: Fault → Double Fault → Triple Fault
  x86 Exception Delivery State Machine
| {near: top-center}
NORMAL_EXECUTION: "NORMAL_EXECUTION" {
  shape: circle
  style.fill: "#2D6A4F"
  style.font-color: white
  style.stroke: "#1B4332"
  style.stroke-width: 3
  label: |md
    **NORMAL EXECUTION**
    Invariant: IDT loaded,
    valid stack, IF=1 or IF=0
  |
}
initial: "" {
  shape: circle
  style.fill: black
  style.stroke: black
  width: 24
  height: 24
  label: ""
}
initial -> NORMAL_EXECUTION: ""
HANDLING_EXCEPTION: "HANDLING_EXCEPTION" {
  shape: rectangle
  style.fill: "#E9C46A"
  style.font-color: "#1a1a1a"
  style.stroke: "#F4A261"
  style.stroke-width: 3
  style.border-radius: 8
  label: |md
    **HANDLING_EXCEPTION**
    (First Fault — #n)
    CPU pushed: SS, ESP, EFLAGS,
    CS, EIP [+ err_code if applicable]
    onto kernel stack.
    IDT[n] handler invoked.
    Invariant: IDT[n].present=1,
    valid stack available,
    handler address reachable
  |
}
DOUBLE_FAULT: "DOUBLE_FAULT" {
  shape: rectangle
  style.fill: "#E76F51"
  style.font-color: white
  style.stroke: "#C1440E"
  style.stroke-width: 3
  style.border-radius: 8
  label: |md
    **DOUBLE FAULT (#DF)**
    Vector 8
    Fault occurred *during* exception
    delivery or handler execution.
    CPU invokes IDT[8].
    error_code = 0 (always).
    Requires: #DF handler must have
    its own dedicated stack via
    Task Gate (TSS) — otherwise a
    corrupt stack causes Triple Fault
    before #DF handler can run.
  |
}
TRIPLE_FAULT: "TRIPLE_FAULT" {
  shape: rectangle
  style.fill: "#9B2226"
  style.font-color: white
  style.stroke: "#641220"
  style.stroke-width: 4
  style.border-radius: 8
  label: |md
    **TRIPLE FAULT**
    Fault during #DF handler.
    CPU has no further escalation.
    Issues hardware RESET signal.
    Machine reboots silently —
    no error message, no recovery.
    Observed as: QEMU "CPU Reset"
    in  -d int  output.
  |
}
CPU_RESET: "CPU_RESET" {
  shape: oval
  style.fill: "#6A0572"
  style.font-color: white
  style.stroke: "#4A0354"
  style.stroke-width: 3
  label: |md
    **CPU RESET**
    Power-on equivalent.
    BIOS executes from 0xFFFFFFF0.
    All kernel state lost.
  |
}
NORMAL_EXECUTION -> HANDLING_EXCEPTION: |md
  **trigger:** hardware interrupt or
  software exception fires.
  guard: IDT[n].present=1 AND
  valid stack AND handler reachable.
  action: CPU pushes frame,
  loads CS:EIP from IDT[n],
  switches to kernel stack via TSS
  if privilege change.
|
HANDLING_EXCEPTION -> NORMAL_EXECUTION: |md
  **trigger:** handler executes  iretd
  guard: no fault during handler
  action: CPU pops EIP, CS, EFLAGS
  (+ ESP, SS on privilege change);
  resumes interrupted code.
|
HANDLING_EXCEPTION -> DOUBLE_FAULT: |md
  **trigger:** second exception occurs
  during handler delivery or execution.
  guard: IDT[8].present=1 AND
  stack NOT corrupted AND
  #DF handler reachable.
  action: CPU discards first exception
  context; pushes frame + err_code=0
  onto *same* kernel stack (danger!);
  invokes IDT[8] via interrupt gate
  or Task Gate.
| {
  style.stroke: "#E76F51"
  style.stroke-width: 2
}
DOUBLE_FAULT -> NORMAL_EXECUTION: |md
  **trigger:** #DF handler executes iretd
  guard: #DF handler ran successfully,
  system state recoverable (rare).
  action: system resumes; kernel
  should log the cascade and consider
  killing the offending process.
| {
  style.stroke-dash: 4
  style.stroke: "#2D6A4F"
}
DOUBLE_FAULT -> TRIPLE_FAULT: |md
  **trigger:** any exception occurs
  during #DF handler delivery
  or execution.
  guard: (always — no further
  escalation exists).
  action: CPU asserts RESET signal.
| {
  style.stroke: "#9B2226"
  style.stroke-width: 3
}
TRIPLE_FAULT -> CPU_RESET: |md
  **trigger:** CPU RESET signal asserted
  action: system reboots from firmware
| {
  style.stroke: "#6A0572"
  style.stroke-width: 3
}
ILLEGAL_PATH: "ILLEGAL SHORTCUT\n(Stack Corrupt at First Fault)" {
  shape: rectangle
  style.fill: "#1a1a1a"
  style.font-color: "#FF6B6B"
  style.stroke: "#FF0000"
  style.stroke-width: 2
  style.stroke-dash: 5
  style.border-radius: 4
  label: |md
    **ILLEGAL SHORTCUT**
    Stack Corrupt at First Fault
    If ESP is invalid when the first
    exception fires, the CPU cannot
    push the exception frame.
    This itself is a fault during
    exception delivery → triggers #DF.
    But if IDT[8] also cannot deliver
    (e.g., Task Gate absent, #DF stack
    also corrupt), CPU goes directly to
    Triple Fault, skipping #DF handler.
  |
}
HANDLING_EXCEPTION -> ILLEGAL_PATH: "stack corrupt\nbefore #DF can run" {
  style.stroke: "#FF0000"
  style.stroke-dash: 5
  style.stroke-width: 2
  style.font-color: "#FF0000"
}
ILLEGAL_PATH -> TRIPLE_FAULT: "bypasses #DF handler\n→ immediate RESET" {
  style.stroke: "#FF0000"
  style.stroke-dash: 5
  style.stroke-width: 3
  style.font-color: "#FF0000"
}
robustness_note: |md
  **Robustness Note — Task Gate for #DF**
  IDT[8] should use a **Task Gate** descriptor (not an interrupt gate)
  pointing to a dedicated TSS with its own pre-allocated stack.
  This guarantees the CPU can always deliver the Double Fault
  even when the main kernel stack is completely corrupted.
  Without this, any kernel stack overflow or wild-pointer write
  to the stack will cause a silent Triple Fault and machine reset
  instead of a diagnosable #DF with register dump.
| {
  near: bottom-center
  style.font-size: 13
  style.fill: "#0d1117"
  style.font-color: "#8B949E"
  style.stroke: "#30363D"
  style.border-radius: 6
}