vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "PIT 8254 Channel 0: Divisor Calculation and 100Hz Configuration" {
  shape: text
  near: top-center
  style: {
    font-size: 20
    bold: true
  }
}

ports: "PIT I/O Port Map" {
  style: {
    fill: "#2D1B69"
    font-color: white
    bold: true
  }
  grid-columns: 4
  grid-gap: 0

  h_port: "Port" {
    style.fill: "#4A3080"
    style.font-color: white
    style.bold: true
  }
  h_dir: "Dir" {
    style.fill: "#4A3080"
    style.font-color: white
    style.bold: true
  }
  h_reg: "Register" {
    style.fill: "#4A3080"
    style.font-color: white
    style.bold: true
  }
  h_note: "Notes" {
    style.fill: "#4A3080"
    style.font-color: white
    style.bold: true
  }

  p40: "0x40" { style.fill: "#1a1a2e"; style.font-color: "#88DCF7" }
  d40: "W" { style.fill: "#1a1a2e"; style.font-color: white }
  r40: "Channel 0 Data" { style.fill: "#1a1a2e"; style.font-color: white }
  n40: "Lo byte, then Hi byte" { style.fill: "#1a1a2e"; style.font-color: "#aaa" }

  p41: "0x41" { style.fill: "#1a1a2e"; style.font-color: "#88DCF7" }
  d41: "W" { style.fill: "#1a1a2e"; style.font-color: white }
  r41: "Channel 1 Data" { style.fill: "#1a1a2e"; style.font-color: "#666" }
  n41: "DRAM refresh — DO NOT USE" { style.fill: "#1a1a2e"; style.font-color: "#666" }

  p42: "0x42" { style.fill: "#1a1a2e"; style.font-color: "#88DCF7" }
  d42: "W" { style.fill: "#1a1a2e"; style.font-color: white }
  r42: "Channel 2 Data" { style.fill: "#1a1a2e"; style.font-color: "#aaa" }
  n42: "PC speaker" { style.fill: "#1a1a2e"; style.font-color: "#aaa" }

  p43: "0x43" { style.fill: "#1a1a2e"; style.font-color: "#E8A838" }
  d43: "W" { style.fill: "#1a1a2e"; style.font-color: white }
  r43: "Mode/Command" { style.fill: "#1a1a2e"; style.font-color: "#E8A838" }
  n43: "Write only; read back via latch" { style.fill: "#1a1a2e"; style.font-color: "#aaa" }
}

cmd_byte: "Command Byte 0x36 Decoded" {
  style: {
    fill: "#1A3A1A"
    font-color: white
    bold: true
  }
  grid-columns: 3
  grid-gap: 0

  hb: "Bits" { style.fill: "#2A5A2A"; style.font-color: white; style.bold: true }
  hf: "Field" { style.fill: "#2A5A2A"; style.font-color: white; style.bold: true }
  hv: "Value / Meaning" { style.fill: "#2A5A2A"; style.font-color: white; style.bold: true }

  b76: "[7:6]" { style.fill: "#0d2b0d"; style.font-color: "#88DCF7" }
  f76: "Channel Select" { style.fill: "#0d2b0d"; style.font-color: white }
  v76: "00 = Channel 0 (timer, IRQ0)" { style.fill: "#0d2b0d"; style.font-color: "#7FD97F" }

  b54: "[5:4]" { style.fill: "#0d2b0d"; style.font-color: "#88DCF7" }
  f54: "Access Mode" { style.fill: "#0d2b0d"; style.font-color: white }
  v54: "11 = Lo/Hi byte (2-byte write)" { style.fill: "#0d2b0d"; style.font-color: "#7FD97F" }

  b31: "[3:1]" { style.fill: "#0d2b0d"; style.font-color: "#88DCF7" }
  f31: "Operating Mode" { style.fill: "#0d2b0d"; style.font-color: white }
  v31: "011 = Mode 2 (rate generator)" { style.fill: "#0d2b0d"; style.font-color: "#7FD97F" }

  b0: "[0]" { style.fill: "#0d2b0d"; style.font-color: "#88DCF7" }
  f0: "BCD/Binary" { style.fill: "#0d2b0d"; style.font-color: white }
  v0: "0 = Binary counting" { style.fill: "#0d2b0d"; style.font-color: "#7FD97F" }

  bfull: "Full byte" { style.fill: "#1A3A1A"; style.font-color: "#E8A838"; style.bold: true }
  ffull: "0x36 = 0b00_11_011_0" { style.fill: "#1A3A1A"; style.font-color: "#E8A838"; style.bold: true }
  vfull: "CH0, Lo/Hi, Mode 2, Binary" { style.fill: "#1A3A1A"; style.font-color: "#E8A838"; style.bold: true }
}

freq: "Clock Source and Divisor Calculation" {
  style: {
    fill: "#1A1A3A"
    font-color: white
    bold: true
  }

  clk: "PIT Input Clock" {
    style: {
      fill: "#2A2A5A"
      font-color: "#88DCF7"
      bold: true
    }
    label: |md
      **PIT Input Clock**
      1,193,182 Hz
      (≈ 1.193 MHz)

      Origin: NTSC color burst ÷ 12
      = 3,579,545 / 3 = 1,193,182
    |
  }

  formula: "Frequency Formula" {
    style: {
      fill: "#2A2A5A"
      font-color: white
      bold: true
    }
    label: |md
      **IRQ0 Frequency = Clock ÷ Divisor**

      For 100 Hz target:
      Divisor = 1,193,182 ÷ 100
              = 11,931.82
              → round to **11,932**

      Actual freq = 1,193,182 ÷ 11,932
                  = **99.9987 Hz**
      Error < 0.002%
    |
  }

  divisor: "Divisor Encoding (16-bit)" {
    style: {
      fill: "#2A2A5A"
      font-color: white
      bold: true
    }
    label: |md
      **11,932 = 0x2EDC**

      Low byte  (0xDC = 220):
        outb(0x40, 0xDC)  ← FIRST

      High byte (0x2E = 46):
        outb(0x40, 0x2E)  ← SECOND

      Order MATTERS: lo before hi
      (mode 11 = lo/hi access)
    |
  }

  clk -> formula: "÷ divisor"
  formula -> divisor: "encode"
}

init_seq: "Initialization Sequence (4 port writes)" {
  style: {
    fill: "#2A1A1A"
    font-color: white
    bold: true
  }

  s1: "Step 1" {
    style: { fill: "#4A1A1A"; font-color: "#E8A838"; bold: true }
    label: |md
      **outb(0x43, 0x36)**

      Port:  0x43 (Command)
      Value: 0x36
      Sets: Ch0, lo/hi, Mode 2, binary
      Must be FIRST
    |
  }

  s2: "Step 2" {
    style: { fill: "#3A1A1A"; font-color: white }
    label: |md
      **outb(0x40, 0xDC)**

      Port:  0x40 (Ch0 data)
      Value: 0xDC (low byte of 11932)
      Divisor bits [7:0]
    |
  }

  s3: "Step 3" {
    style: { fill: "#3A1A1A"; font-color: white }
    label: |md
      **outb(0x40, 0x2E)**

      Port:  0x40 (Ch0 data)
      Value: 0x2E (high byte of 11932)
      Divisor bits [15:8]
      Loads divisor → counter starts
    |
  }

  s4: "Step 4 (implicit)" {
    style: { fill: "#3A1A1A"; font-color: "#7FD97F" }
    label: |md
      **irq_install_handler(0, timer_handler)**

      Register C handler for IRQ0
      IRQ0 fires at ≈100 Hz
      timer_handler increments
      pit_tick_count++
    |
  }

  s1 -> s2: "then"
  s2 -> s3: "then"
  s3 -> s4: "then"
}

mode2: "Mode 2: Rate Generator Behavior" {
  style: {
    fill: "#1A2A2A"
    font-color: white
    bold: true
  }
  label: |md
    **Mode 2 — Rate Generator (Periodic)**

    Counter loads divisor N on write (or on reload).
    Counts DOWN: N, N-1, N-2, ..., 2, 1
    When counter reaches 1: OUT pin goes LOW for 1 cycle
    Counter reloads N automatically → repeats forever

    **Key property:** self-reloading — no software intervention needed.
    Generates periodic IRQ0 at exactly Clock/N Hz.

    Compare with Mode 0 (one-shot): fires once, stops.
    Mode 2 is the correct choice for a system timer.

    OUT wired to 8259 PIC IRQ0 input.
    Each falling edge of OUT → PIC delivers vector 32 to CPU.
  |
}

timing: "Timing Budget at 100Hz" {
  style: {
    fill: "#1A1A2E"
    font-color: white
    bold: true
  }
  grid-columns: 3
  grid-gap: 0

  ht: "Metric" { style.fill: "#2A2A4A"; style.font-color: white; style.bold: true }
  hv2: "Value" { style.fill: "#2A2A4A"; style.font-color: white; style.bold: true }
  hn: "Notes" { style.fill: "#2A2A4A"; style.font-color: white; style.bold: true }

  t1: "Period" { style.fill: "#0d0d1f"; style.font-color: "#88DCF7" }
  v1: "10 ms" { style.fill: "#0d0d1f"; style.font-color: "#7FD97F" }
  n1: "1 / 99.9987 Hz ≈ 10.0001 ms" { style.fill: "#0d0d1f"; style.font-color: "#aaa" }

  t2: "CPU cycles per tick" { style.fill: "#0d0d1f"; style.font-color: "#88DCF7" }
  v2: "20,000,000" { style.fill: "#0d0d1f"; style.font-color: white }
  n2: "at 2 GHz host" { style.fill: "#0d0d1f"; style.font-color: "#aaa" }

  t3: "IRQ overhead" { style.fill: "#0d0d1f"; style.font-color: "#88DCF7" }
  v3: "~150 cycles" { style.fill: "#0d0d1f"; style.font-color: white }
  n3: "pusha + dispatch + EOI + popa + iret" { style.fill: "#0d0d1f"; style.font-color: "#aaa" }

  t4: "Overhead %" { style.fill: "#0d0d1f"; style.font-color: "#88DCF7" }
  v4: "0.00075%" { style.fill: "#0d0d1f"; style.font-color: "#7FD97F" }
  n4: "150 / 20,000,000" { style.fill: "#0d0d1f"; style.font-color: "#aaa" }

  t5: "pit_tick_count after 1s" { style.fill: "#0d0d1f"; style.font-color: "#88DCF7" }
  v5: "~100" { style.fill: "#0d0d1f"; style.font-color: "#7FD97F" }
  n5: "±1 tick from QEMU scheduling" { style.fill: "#0d0d1f"; style.font-color: "#aaa" }
}

code: "C Implementation" {
  style: {
    fill: "#0D0D0D"
    font-color: white
    bold: true
  }
  label: |go
    #define PIT_CMD      0x43
    #define PIT_CH0      0x40
    #define PIT_FREQ     1193182

    volatile uint64_t pit_tick_count = 0;

    void pit_set_frequency(uint32_t hz) {
        uint32_t divisor = PIT_FREQ / hz;  // 11932
        outb(PIT_CMD, 0x36);               // Step 1
        outb(PIT_CH0, divisor & 0xFF);     // Step 2: 0xDC
        outb(PIT_CH0, (divisor>>8)&0xFF);  // Step 3: 0x2E
    }

    void timer_handler(interrupt_frame_t *f) {
        (void)f;
        pit_tick_count++;  // volatile: no cache
        // mod-4: sched_tick() called here
    }

    void pit_init(uint32_t hz) {
        pit_set_frequency(hz);             // Configure hardware
        irq_install_handler(0, timer_handler);
    }
  |
}

ports -> cmd_byte: "0x43 write\nconfigures"
cmd_byte -> freq: "determines"
freq -> init_seq: "drives"
init_seq -> mode2: "activates"
mode2 -> timing: "produces"
init_seq -> code: "implements"