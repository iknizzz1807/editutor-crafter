vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Circular Ring Buffer — Memory Layout & Head/Tail Invariants
  `ring_buffer_t` · 256-byte array · `uint8_t head, tail` (natural mod-256 arithmetic)
| {near: top-center}
# ─── STRUCT DEFINITION ───────────────────────────────────────────────────────
struct_def: "ring_buffer_t (sizeof = 258 B)" {
  style.fill: "#2D1B69"
  style.font-color: white
  style.bold: true
  style.border-radius: 6
  field_buf: |md
    **Offset 0 — buf[256]** · 256 bytes · char array · circular storage
    `style.fill: "#4A3080"`
  |
  field_head: |md
    **Offset 256 — head** · 1 byte · uint8_t · next WRITE position (producer)
    Wraps at 256 via natural uint8_t overflow → free modulo operation
  |
  field_tail: |md
    **Offset 257 — tail** · 1 byte · uint8_t · next READ position (consumer)
    Wraps at 256 via natural uint8_t overflow → free modulo operation
  |
}
# ─── STATE 1: EMPTY ──────────────────────────────────────────────────────────
state_empty: "STATE 1 — EMPTY (head == tail)" {
  style.fill: "#1A3A1A"
  style.border-radius: 6
  ring_e: "buf[0..255]" {
    style.fill: "#2A5A2A"
    style.border-radius: 4
    grid-columns: 16
    grid-gap: 0
    e0:  "0"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e1:  "1"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e2:  "2"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e3:  "3"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e4:  "4"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e5:  "5"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e6:  "6"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e7:  "7"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e8:  "8"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e9:  "9"  { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e10: "10" { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e11: "11" { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e12: "12" { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e13: "13" { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e14: "..." { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
    e15: "255" { style.fill: "#3A7A3A"; style.font-color: white; style.font-size: 9 }
  }
  empty_ptr: |md
    head = **0** ▲ · tail = **0** ▲  
    **Invariant:** `head == tail` → EMPTY  
    **Capacity used:** 0 / 255 slots  
    `ring_empty() → true`  
    `ring_full()  → false`
  |
  empty_ptr.style.fill: "#1E4A1E"
  empty_ptr.style.font-color: "#90EE90"
}
# ─── STATE 2: PARTIAL (normal, no wrap) ──────────────────────────────────────
state_partial: "STATE 2 — PARTIAL (tail < head, no wrap)" {
  style.fill: "#1A2A3A"
  style.border-radius: 6
  ring_p: "buf[0..255]" {
    style.fill: "#1E3A5A"
    style.border-radius: 4
    grid-columns: 16
    grid-gap: 0
    p0:  "0\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    p1:  "1\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    p2:  "2\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    p3:  "3\n◀T" { style.fill: "#FF8C00"; style.font-color: white; style.font-size: 9 }
    p4:  "4\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    p5:  "5\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    p6:  "6\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    p7:  "7\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    p8:  "8\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    p9:  "9\n▶H" { style.fill: "#9B59B6"; style.font-color: white; style.font-size: 9 }
    p10: "10\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    p11: "11\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    p12: "12\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    p13: "13\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    p14: "...\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    p15: "255\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
  }
  partial_ptr: |md
    tail = **3** ◀ (next READ)  · head = **9** ▶ (next WRITE)  
    **Data occupies:** buf[3..8] = 6 bytes (blue ██)  
    **Free slots:** buf[9..2] = 249 slots (green —)  
    **Invariant:** `tail < head` → used = `head - tail` = 6  
    `ring_push(c)`: buf[head]=c; head++ (=10)  
    `ring_pop()` : c=buf[tail]; tail++ (=4); return c
  |
  partial_ptr.style.fill: "#1A2D4A"
  partial_ptr.style.font-color: "#87CEEB"
}
# ─── STATE 3: WRAPPED ────────────────────────────────────────────────────────
state_wrapped: "STATE 3 — WRAPPED (head < tail, head wrapped past 255)" {
  style.fill: "#3A1A1A"
  style.border-radius: 6
  ring_w: "buf[0..255]" {
    style.fill: "#5A1E1E"
    style.border-radius: 4
    grid-columns: 16
    grid-gap: 0
    w0:  "0\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    w1:  "1\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    w2:  "2\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    w3:  "3\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    w4:  "4\n▶H" { style.fill: "#9B59B6"; style.font-color: white; style.font-size: 9 }
    w5:  "5\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    w6:  "6\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    w7:  "7\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    w8:  "8\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    w9:  "9\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    w10: "10\n—" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 9 }
    w11: "11\n◀T" { style.fill: "#FF8C00"; style.font-color: white; style.font-size: 9 }
    w12: "12\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    w13: "13\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    w14: "...\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    w15: "255\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
  }
  wrapped_ptr: |md
    head = **4** ▶ · tail = **11** ◀  
    **Data occupies:** buf[11..255] + buf[0..3] (blue ██, wrap around)  
    **Free slots:** buf[4..10] = 7 slots (green —)  
    **Invariant:** `head < tail` → used = `(256 - tail) + head` = 249  
    head wrapped: 255 → 0 via `uint8_t` overflow  
    `ring_push(c)`: buf[4]=c; head becomes 5  
    `ring_pop()` : c=buf[11]; tail becomes 12
  |
  wrapped_ptr.style.fill: "#4A1E1E"
  wrapped_ptr.style.font-color: "#FFB6C1"
}
# ─── STATE 4: FULL ───────────────────────────────────────────────────────────
state_full: "STATE 4 — FULL  ·  (uint8_t)(head+1) == tail  ·  ONE SLOT WASTED" {
  style.fill: "#3A2A00"
  style.border-radius: 6
  ring_f: "buf[0..255]" {
    style.fill: "#5A4000"
    style.border-radius: 4
    grid-columns: 16
    grid-gap: 0
    f0:  "0\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f1:  "1\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f2:  "2\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f3:  "3\n◀T" { style.fill: "#FF8C00"; style.font-color: white; style.font-size: 9 }
    f4:  "4\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f5:  "5\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f6:  "6\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f7:  "7\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f8:  "8\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f9:  "9\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f10: "10\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f11: "11\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f12: "12\n▶H" { style.fill: "#9B59B6"; style.font-color: white; style.font-size: 9 }
    f13: "13\n░" { style.fill: "#7A5A00"; style.font-color: "#FFD700"; style.font-size: 9 }
    f14: "...\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
    f15: "255\n█" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 9 }
  }
  full_ptr: |md
    head = **12** ▶ · tail = **3** ◀  
    **Wasted slot:** buf[2] ░ — head cannot advance to tail's position  
    **Why waste one slot?** If head==tail meant full, it would alias EMPTY.  
    `(uint8_t)(12+1)=13 ≠ 3` → actually buf[13] wasted here (░)  
    **Capacity:** SIZE-1 = **255** chars max (not 256)  
    `ring_full() → true`; `ring_push()` DROPS silently
  |
  full_ptr.style.fill: "#4A3800"
  full_ptr.style.font-color: "#FFD700"
}
# ─── OPERATIONS REFERENCE ────────────────────────────────────────────────────
ops: "ring_push / ring_pop — Complete C Implementation" {
  style.fill: "#1A1A2E"
  style.border-radius: 6
  push_code: |go
    // PRODUCER (IRQ handler — keyboard_handler)
    // Called: keyboard_handler() inside IRQ1, IF=0
    void ring_push(ring_buffer_t *rb, char c) {
        uint8_t next_head = (uint8_t)(rb->head + 1);
        // Full check: if next_head would equal tail → buffer full
        if (next_head != rb->tail) {      // NOT full
            rb->buf[rb->head] = c;        // Write to current head slot
            rb->head = next_head;         // Advance head (producer only modifies head)
        }
        // else: FULL — silently drop. No error. No EOI delay.
        // Always returns; never blocks. IRQ handlers MUST NOT block.
    }
    // CONSUMER (non-IRQ — keyboard_getchar, called from kernel/user context)
    char ring_pop(ring_buffer_t *rb) {
        // Assumes ring_empty() already checked by caller
        char c   = rb->buf[rb->tail];     // Read from current tail slot
        rb->tail = (uint8_t)(rb->tail+1); // Advance tail (consumer only modifies tail)
        return c;
    }
    // Empty check — consumer calls this before ring_pop
    int ring_empty(ring_buffer_t *rb) { return rb->head == rb->tail; }
    // Full check — producer calls this before ring_push
    int ring_full(ring_buffer_t *rb)  { return (uint8_t)(rb->head+1) == rb->tail; }
  |
  push_code.style.fill: "#0D1117"
  push_code.style.font-color: "#E6EDF3"
}
# ─── CONCURRENCY SAFETY ANALYSIS ─────────────────────────────────────────────
concurrency: "Single-Core Race-Condition-Free Analysis" {
  style.fill: "#1A1A1A"
  style.border-radius: 6
  invariants: |md
    ## Why This Is Safe Without Atomics (Single-Core Only)
    **Ownership rule:**
    - `head` is written ONLY by the IRQ handler (producer). Consumer reads head.
    - `tail` is written ONLY by non-IRQ code (consumer). Producer reads tail.
    **Interrupt scenario — producer interrupts consumer mid-pop:**
    
    Consumer:  1. ring_empty() → reads head(=5), tail(=3) → not empty ✓
    [IRQ fires here — keyboard_handler runs]
    Producer:  2. ring_push('X') → buf[5]='X'; head becomes 6
    [IRQ returns — consumer resumes]
    Consumer:  3. c = buf[tail=3] → reads buf[3] (correct — unchanged by IRQ)
    Consumer:  4. tail = 4        → tail advanced correctly
    
    **No corruption:** IRQ modified head (3→6, added one char). Consumer read
    buf[3] before IRQ touched anything in the tail region. The char 'X' remains
    in buf[5] for the next pop. Invariants preserved.
    **Consumer interrupts producer scenario:** IMPOSSIBLE on single-core.
    `ring_push` runs inside IRQ handler with IF=0 (interrupt gate cleared IF).
    No interrupt can preempt the IRQ handler.
    **`volatile` requirement:**
    `head` and `tail` must be `volatile uint8_t`. Without volatile, the compiler
    may cache head in a register inside `ring_empty()`'s polling loop, never
    re-reading from memory → infinite loop even when IRQ handler writes new data.
  |
  invariants.style.fill: "#111111"
  invariants.style.font-color: "#CCCCCC"
  failure_note: |md
    ## ⚠ Failure Mode: SIZE Not a Power of 2
    If `KEYBOARD_BUF_SIZE = 100` (not power of 2):
    - `uint8_t` wraps at **256**, not 100
    - `head = 99` → push → `head = 100` (correct mod needed)
    - But head continues to 100, 101 ... 255, 0 — accessing buf[100..255] = **OUT OF BOUNDS**
    - Fix: change `uint8_t head, tail` to `uint16_t` and use explicit `% SIZE`
    - OR: keep `uint8_t` and SIZE=256 (natural wrap = free modulo)
    **This implementation uses SIZE=256 intentionally** so `uint8_t` overflow
    IS the modulo operation. Zero extra instructions. Zero branches.
  |
  failure_note.style.fill: "#2A0000"
  failure_note.style.font-color: "#FF6666"
}
# ─── LEGEND ──────────────────────────────────────────────────────────────────
legend: "Legend" {
  style.fill: "#1A1A2E"
  style.border-radius: 4
  grid-columns: 5
  grid-gap: 8
  l1: "██ DATA" { style.fill: "#1E5A8A"; style.font-color: white; style.font-size: 11 }
  l2: "— FREE" { style.fill: "#3A7A3A"; style.font-color: "#90EE90"; style.font-size: 11 }
  l3: "▶H head (write)" { style.fill: "#9B59B6"; style.font-color: white; style.font-size: 11 }
  l4: "◀T tail (read)" { style.fill: "#FF8C00"; style.font-color: white; style.font-size: 11 }
  l5: "░ WASTED slot" { style.fill: "#7A5A00"; style.font-color: "#FFD700"; style.font-size: 11 }
}
# ─── CONNECTIONS ─────────────────────────────────────────────────────────────
state_empty -> state_partial: "ring_push advances head" {
  style.stroke: "#9B59B6"
  style.font-color: "#9B59B6"
}
state_partial -> state_wrapped: "head reaches 255 → wraps to 0" {
  style.stroke: "#E74C3C"
  style.font-color: "#E74C3C"
}
state_partial -> state_full: "head+1 == tail" {
  style.stroke: "#F39C12"
  style.font-color: "#F39C12"
}
state_wrapped -> state_empty: "ring_pop until head == tail" {
  style.stroke: "#27AE60"
  style.stroke-dash: 4
  style.font-color: "#27AE60"
}
state_full -> state_partial: "ring_pop advances tail" {
  style.stroke: "#3498DB"
  style.stroke-dash: 4
  style.font-color: "#3498DB"
}