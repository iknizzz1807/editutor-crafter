vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: right

title: |md
  ## Module Architecture: IDT, PIC, PIT, Keyboard, and IRQ Dispatch
  **mod-2** · Interrupt Infrastructure · 256-gate IDT · 8259 PIC Cascade · 100Hz Timer · PS/2 Keyboard
| {near: top-center}

# ─── Hardware Layer ───────────────────────────────────────────────
hw: Hardware {
  style.fill: "#1a1a2e"
  style.stroke: "#e94560"
  style.font-color: white
  style.border-radius: 8

  cpu: x86 CPU {
    style.fill: "#16213e"
    style.stroke: "#e94560"
    style.font-color: white
    style.border-radius: 6

    idtr_reg: "IDTR Register\n6 bytes: limit=2047, base=&idt[]" {
      style.fill: "#0f3460"
      style.stroke: "#e94560"
      style.font-color: white
      style.border-radius: 4
    }
    tr_reg: "TR Register\nselector=0x28 (mod-4 TSS)" {
      style.fill: "#0f3460"
      style.stroke: "#533483"
      style.font-color: "#aaaaaa"
      style.border-radius: 4
    }
    cr2_reg: "CR2 Register\nFaulting virtual address\n(vector 14 page fault)" {
      style.fill: "#0f3460"
      style.stroke: "#e94560"
      style.font-color: white
      style.border-radius: 4
    }
    pipeline: "Interrupt Recognition\nAt instruction boundary:\nIF=1 → accept INTR\nSave EFLAGS/CS/EIP\nLook up IDT[vector]" {
      style.fill: "#0f3460"
      style.stroke: "#e94560"
      style.font-color: white
      style.border-radius: 4
    }
  }

  pic_master: "8259A Master PIC\nPorts: CMD=0x20, DATA=0x21\nIRQ0–7 → vectors 32–39\nIMR: mask register\nISR: in-service register" {
    style.fill: "#16213e"
    style.stroke: "#f5a623"
    style.font-color: white
    style.border-radius: 6
  }

  pic_slave: "8259A Slave PIC\nPorts: CMD=0xA0, DATA=0xA1\nIRQ8–15 → vectors 40–47\nCascade on master IRQ2" {
    style.fill: "#16213e"
    style.stroke: "#f5a623"
    style.font-color: white
    style.border-radius: 6
  }

  pit_chip: "Intel 8253/8254 PIT\nPort 0x40: Channel 0 data\nPort 0x43: Command\nClock: 1,193,182 Hz\nDivisor 11932 → 100 Hz\nMode 2: rate generator" {
    style.fill: "#16213e"
    style.stroke: "#7bed9f"
    style.font-color: white
    style.border-radius: 6
  }

  ps2_kb: "PS/2 Keyboard Controller\nPort 0x60: data (scancode)\nPort 0x64: status\nSet 1 scancodes\nMake/Break per key" {
    style.fill: "#16213e"
    style.stroke: "#70a1ff"
    style.font-color: white
    style.border-radius: 6
  }

  pic_master -> cpu.pipeline: "INTR line\nassertion" {
    style.stroke: "#f5a623"
    style.bold: true
  }
  pic_slave -> pic_master: "IRQ2 cascade\nIRQ8–15 signal" {
    style.stroke: "#f5a623"
  }
  pit_chip -> pic_master: "IRQ0\n(100 Hz)" {
    style.stroke: "#7bed9f"
    style.bold: true
  }
  ps2_kb -> pic_master: "IRQ1\n(keypress)" {
    style.stroke: "#70a1ff"
    style.bold: true
  }
  cpu.pipeline -> pic_master: "INTA\n(acknowledge)" {
    style.stroke: "#f5a623"
    style.stroke-dash: 4
  }
}

# ─── IDT Data Structure ───────────────────────────────────────────
idt_struct: IDT Data Structure {
  style.fill: "#1e1e3f"
  style.stroke: "#9b59b6"
  style.font-color: white
  style.border-radius: 8

  idt_array: "idt[256]: 2048 bytes\n__attribute__((aligned(8)))\nstatic in .bss\nIDTR.limit = 2047\nIDTR.base  = &idt[0]" {
    style.fill: "#2d2d5e"
    style.stroke: "#9b59b6"
    style.font-color: white
    style.border-radius: 4
  }

  gate_format: "Each Gate: 8 bytes\n[1:0] offset_low  (handler[15:0])\n[3:2] selector    (0x0008 always)\n[ 4 ] zero        (0x00)\n[ 5 ] type_attr   (P|DPL|type)\n[7:6] offset_high (handler[31:16])\n\ntype_attr values:\n0x8E = IDT_INTERRUPT_GATE (DPL=0, IF cleared)\n0x8F = IDT_TRAP_GATE      (DPL=0, IF preserved)\n0xEF = IDT_SYSCALL_GATE   (DPL=3, user-callable)" {
    style.fill: "#2d2d5e"
    style.stroke: "#9b59b6"
    style.font-color: white
    style.border-radius: 4
  }

  vec_ranges: "Vector Assignment:\n[0x00–0x1F] CPU Exceptions  → IDT_TRAP_GATE\n[0x20–0x27] IRQ0–7 (PIT,KB…) → IDT_INTERRUPT_GATE\n[0x28–0x2F] IRQ8–15          → IDT_INTERRUPT_GATE\n[0x30–0x7F] unused           → default_isr stub\n[0x80]      INT 0x80 syscall → IDT_SYSCALL_GATE (mod-4)\n[0x81–0xFF] unused           → default_isr stub" {
    style.fill: "#2d2d5e"
    style.stroke: "#9b59b6"
    style.font-color: white
    style.border-radius: 4
  }
}

# ─── Assembly Stubs ───────────────────────────────────────────────
stubs: Assembly Stubs {
  style.fill: "#1e2e1e"
  style.stroke: "#27ae60"
  style.font-color: white
  style.border-radius: 8

  isr_noerr: "ISR_NOERR macro (vectors 0,1,2,3,4,5,6,7,9,15,16,18–31)\npush dword 0      ; dummy error code\npush dword N      ; vector number\njmp  isr_common_stub" {
    style.fill: "#1e3a1e"
    style.stroke: "#27ae60"
    style.font-color: white
    style.border-radius: 4
  }

  isr_err: "ISR_ERR macro (vectors 8,10,11,12,13,14,17)\n; CPU already pushed error code\npush dword N      ; vector number\njmp  isr_common_stub" {
    style.fill: "#1e3a1e"
    style.stroke: "#27ae60"
    style.font-color: white
    style.border-radius: 4
  }

  isr_common: "isr_common_stub:\npusha                    ; save EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX\npush gs/fs/es/ds         ; save segment regs\nmov ax,0x10 → ds/es/fs/gs ; load kernel data seg\npush esp                 ; arg: &interrupt_frame_t\ncall exception_handler\nadd  esp, 4\npop  ds/es/fs/gs          ; restore segment regs\npopa\nadd  esp, 8              ; discard vector + error_code\niret                     ; restore EIP,CS,EFLAGS[,ESP,SS]" {
    style.fill: "#1e3a1e"
    style.stroke: "#2ecc71"
    style.font-color: white
    style.border-radius: 4
    style.bold: true
  }

  irq_stub: "IRQ_STUB macro (IRQ0–15 → vectors 32–47)\npush dword 0             ; no error code\npush dword (N+32)        ; vector number\njmp  irq_common_stub" {
    style.fill: "#1e3a1e"
    style.stroke: "#27ae60"
    style.font-color: white
    style.border-radius: 4
  }

  irq_common: "irq_common_stub:\npusha; push gs/fs/es/ds\nmov 0x10 → ds/es/fs/gs\npush esp                 ; arg: &interrupt_frame_t\ncall irq_dispatcher      ; → C handler + EOI\nadd  esp, 4\npop  ds/es/fs/gs; popa\nadd  esp, 8\niret" {
    style.fill: "#1e3a1e"
    style.stroke: "#2ecc71"
    style.font-color: white
    style.border-radius: 4
    style.bold: true
  }

  default_isr_stub: "default_isr:\npush dword 0\npush dword 0xFF          ; sentinel\njmp  isr_common_stub     ; prints 'unexpected interrupt'" {
    style.fill: "#1e3a1e"
    style.stroke: "#27ae60"
    style.font-color: white
    style.border-radius: 4
  }
}

# ─── interrupt_frame_t Stack Layout ──────────────────────────────
frame: interrupt_frame_t Stack Layout {
  style.fill: "#2e1e1e"
  style.stroke: "#e74c3c"
  style.font-color: white
  style.border-radius: 8

  frame_layout: "Stack (low addr at top, frame pointer = ESP when C called):\n[+00] gs          (uint32_t) — saved GS\n[+04] fs          (uint32_t) — saved FS\n[+08] es          (uint32_t) — saved ES\n[+12] ds          (uint32_t) — saved DS\n[+16] edi         (uint32_t) — pusha\n[+20] esi         (uint32_t) — pusha\n[+24] ebp         (uint32_t) — pusha\n[+28] esp_pusha   (uint32_t) — pusha (ignored by popa)\n[+32] ebx         (uint32_t) — pusha\n[+36] edx         (uint32_t) — pusha\n[+40] ecx         (uint32_t) — pusha\n[+44] eax         (uint32_t) — pusha\n[+48] vector      (uint32_t) — stub-pushed\n[+52] error_code  (uint32_t) — CPU or dummy\n[+56] eip         (uint32_t) — CPU-pushed (return addr)\n[+60] cs          (uint32_t) — CPU-pushed\n[+64] eflags      (uint32_t) — CPU-pushed\n──── ring-3 only ────\n[+68] user_esp    (uint32_t) — CPU-pushed (ring 3→0)\n[+72] user_ss     (uint32_t) — CPU-pushed (ring 3→0)" {
    style.fill: "#3a1e1e"
    style.stroke: "#e74c3c"
    style.font-color: white
    style.border-radius: 4
  }

  frame_ring3_note: |md
    **Ring-3 detection:**
    `(frame->cs & 0x3) == 3`
    triggers extra user_esp/user_ss pop by iret
  | {
    style.fill: "#3a1e1e"
    style.stroke: "#e74c3c"
    style.font-color: white
    style.border-radius: 4
  }
}

# ─── C Handler Layer ──────────────────────────────────────────────
c_handlers: C Handler Layer {
  style.fill: "#1e1e1e"
  style.stroke: "#3498db"
  style.font-color: white
  style.border-radius: 8

  exception_handler: "exception_handler(frame):\nvector 0–31: print name, EIP,\n  registers, error code;\n  vector 14: read CR2;\n  halt with cli;hlt\nvector 128:  syscall_dispatch(frame)\nvector 0xFF: unknown interrupt halt" {
    style.fill: "#1e2a3a"
    style.stroke: "#3498db"
    style.font-color: white
    style.border-radius: 4
  }

  irq_dispatcher: "irq_dispatcher(frame):\nirq = frame->vector - 32\npic_suppress_eoi = 0\nif irq_handlers[irq]:\n    irq_handlers[irq](frame)\nif !pic_suppress_eoi:\n    pic_send_eoi(irq)\n\nirq_handlers[16]: table of\nvoid (*)(interrupt_frame_t*)" {
    style.fill: "#1e2a3a"
    style.stroke: "#3498db"
    style.font-color: white
    style.border-radius: 4
  }

  exc_table: "exception_names[32]:\n[0]  Divide Error\n[1]  Debug\n[2]  NMI\n[3]  Breakpoint\n[4]  Overflow\n[5]  Bound Range\n[6]  Invalid Opcode\n[7]  Device Not Avail\n[8]  Double Fault\n[13] General Protection\n[14] Page Fault\n…" {
    style.fill: "#1e2a3a"
    style.stroke: "#3498db"
    style.font-color: white
    style.border-radius: 4
  }
}

# ─── PIC Driver ───────────────────────────────────────────────────
pic_driver: PIC Driver (pic.c) {
  style.fill: "#2e2200"
  style.stroke: "#f5a623"
  style.font-color: white
  style.border-radius: 8

  pic_remap: "pic_remap(0x20, 0x28):\n1. Save master/slave IMR\n2. ICW1=0x11 → 0x20, 0xA0\n3. ICW2: 0x20→0x21, 0x28→0xA1\n4. ICW3: 0x04→0x21, 0x02→0xA1\n5. ICW4: 0x01 → both PICs\n6. Restore saved IMR\nio_wait() between each write" {
    style.fill: "#3a2a00"
    style.stroke: "#f5a623"
    style.font-color: white
    style.border-radius: 4
  }

  pic_eoi: "pic_send_eoi(irq):\nif irq >= 8:\n    outb(0xA0, 0x20)  ; slave EOI first\noutb(0x20, 0x20)      ; master EOI always\n\npic_get_isr(0/1):\noutb(CMD, 0x0B)\nreturn inb(CMD)\n\npic_set/clear_mask(irq):\nread IMR; set/clear bit; write" {
    style.fill: "#3a2a00"
    style.stroke: "#f5a623"
    style.font-color: white
    style.border-radius: 4
  }

  spurious: "Spurious IRQ handling:\nIRQ7 (vec 39): check ISR bit 7\n  → if clear: set suppress_eoi=1\nIRQ15 (vec 47): check slave ISR bit 7\n  → if clear: send master EOI only,\n    set suppress_eoi=1" {
    style.fill: "#3a2a00"
    style.stroke: "#e67e22"
    style.font-color: white
    style.border-radius: 4
  }
}

# ─── PIT Driver ───────────────────────────────────────────────────
pit_driver: PIT Driver (pit.c) {
  style.fill: "#001e0e"
  style.stroke: "#7bed9f"
  style.font-color: white
  style.border-radius: 8

  pit_init_seq: "pit_init(100):\n1. divisor = 1193182 / 100 = 11932\n2. outb(0x43, 0x36)  ; CH0, lo/hi, mode2\n3. outb(0x40, 0xDC)  ; divisor low  byte\n4. outb(0x40, 0x2E)  ; divisor high byte\n5. irq_install_handler(0, timer_handler)" {
    style.fill: "#002a14"
    style.stroke: "#7bed9f"
    style.font-color: white
    style.border-radius: 4
  }

  timer_handler: "timer_handler(frame):\npit_tick_count++\n; (mod-4 replaces with sched_tick)\n\nvolatile uint64_t pit_tick_count\n; volatile: prevents compiler caching\n; 100 ticks/sec → 10ms resolution" {
    style.fill: "#002a14"
    style.stroke: "#7bed9f"
    style.font-color: white
    style.border-radius: 4
  }
}

# ─── Keyboard Driver ─────────────────────────────────────────────
kb_driver: Keyboard Driver (keyboard.c) {
  style.fill: "#00001e"
  style.stroke: "#70a1ff"
  style.font-color: white
  style.border-radius: 8

  kb_handler_algo: "keyboard_handler(frame):\nscancode = inb(0x60)\nif 0xE0: set expect_extended=1; return\nif expect_extended: clear flag; return\nis_break = scancode & 0x80\nmake = scancode & 0x7F\nif make ∈ {0x2A,0x36}: shift toggle\nif make ∈ {0x1D,0x38,0x3A}: ignore\nif is_break: return\nif make >= 128: return\nc = shift ? upper[make] : lower[make]\nif c == 0: return\nnext_head = head + 1 (uint8_t wraps)\nif next_head != tail: buf[head]=c; head++" {
    style.fill: "#00002a"
    style.stroke: "#70a1ff"
    style.font-color: white
    style.border-radius: 4
  }

  kb_buffer: "kb_ring_t circular buffer:\nbuf[256]: char storage\nhead: uint8_t (write pos, IRQ1)\ntail: uint8_t (read pos, getchar)\nfull:  (head+1)==tail → drop char\nempty: head==tail → return 0\n\nkeyboard_getchar():\nif head==tail: return 0\nc=buf[tail]; tail++; return c" {
    style.fill: "#00002a"
    style.stroke: "#70a1ff"
    style.font-color: white
    style.border-radius: 4
  }

  scancode_tables: "scancode_ascii_lower[128]\nscancode_ascii_upper[128]\n[0x01]=ESC [0x1C]=Enter\n[0x1E]='a' [0x30]='b' …\n[0x2A]=LShift [0x36]=RShift\n[0x1D]=LCtrl [0x38]=LAlt\n[0x39]=Space [0x0E]=Backspace" {
    style.fill: "#00002a"
    style.stroke: "#70a1ff"
    style.font-color: white
    style.border-radius: 4
  }
}

# ─── Initialization Sequence ─────────────────────────────────────
init_seq: Initialization Sequence (kmain) {
  style.fill: "#1a1a1a"
  style.stroke: "#ecf0f1"
  style.font-color: white
  style.border-radius: 8

  seq: "1. idt_setup_all()    → populate 256 gates, lidt\n2. pic_remap(0x20,0x28) → BEFORE sti (prevents double-fault on IRQ0)\n3. pit_init(100)       → 100Hz timer, install IRQ0 handler\n4. keyboard_init()    → install IRQ1 handler, zero buffer\n5. sti                 → enable interrupts (LAST step)\n\nORDER IS MANDATORY:\n• IDT before PIC: guards against IRQ with no handler\n• PIC remap before sti: IRQ0 must NOT hit vector 8 (double fault)\n• sti last: nothing fires until all structures ready" {
    style.fill: "#2a2a2a"
    style.stroke: "#ecf0f1"
    style.font-color: white
    style.border-radius: 4
  }
}

# ─── Connections ─────────────────────────────────────────────────

# Hardware → CPU
hw.pit_chip -> hw.cpu.pipeline: "IRQ0 signal\n100 Hz" {
  style.stroke: "#7bed9f"
  style.bold: true
}
hw.ps2_kb -> hw.cpu.pipeline: "IRQ1 signal\nper keypress" {
  style.stroke: "#70a1ff"
  style.bold: true
}

# IDT loaded into IDTR
idt_struct.idt_array -> hw.cpu.idtr_reg: "lgdt instruction\nlidt [idtr_descriptor]" {
  style.stroke: "#9b59b6"
  style.bold: true
}

# CPU dispatch through IDT
hw.cpu.pipeline -> stubs.isr_noerr: "vector 0–7,9,15–31\n(no CPU error code)" {
  style.stroke: "#e74c3c"
}
hw.cpu.pipeline -> stubs.isr_err: "vector 8,10–14,17\n(CPU pushes error code)" {
  style.stroke: "#e74c3c"
}
hw.cpu.pipeline -> stubs.irq_stub: "vector 32–47\n(hardware IRQ0–15)" {
  style.stroke: "#f5a623"
}

# Stub → common stub
stubs.isr_noerr -> stubs.isr_common: "jmp" {
  style.stroke: "#27ae60"
}
stubs.isr_err -> stubs.isr_common: "jmp" {
  style.stroke: "#27ae60"
}
stubs.irq_stub -> stubs.irq_common: "jmp" {
  style.stroke: "#27ae60"
}

# Common stubs → C handlers
stubs.isr_common -> c_handlers.exception_handler: "call exception_handler\n(frame pointer arg)" {
  style.stroke: "#3498db"
  style.bold: true
}
stubs.irq_common -> c_handlers.irq_dispatcher: "call irq_dispatcher\n(frame pointer arg)" {
  style.stroke: "#3498db"
  style.bold: true
}

# Exception handler uses exception table
c_handlers.exception_handler -> c_handlers.exc_table: "lookup\nexception_names[vector]" {
  style.stroke: "#3498db"
  style.stroke-dash: 4
}

# IRQ dispatcher calls registered handlers
c_handlers.irq_dispatcher -> pit_driver.timer_handler: "irq_handlers[0]\nIRQ0 → timer" {
  style.stroke: "#7bed9f"
}
c_handlers.irq_dispatcher -> kb_driver.kb_handler_algo: "irq_handlers[1]\nIRQ1 → keyboard" {
  style.stroke: "#70a1ff"
}
c_handlers.irq_dispatcher -> pic_driver.pic_eoi: "pic_send_eoi(irq)\nalways after handler" {
  style.stroke: "#f5a623"
  style.bold: true
}

# PIC remap called during init
init_seq.seq -> pic_driver.pic_remap: "pic_remap(0x20, 0x28)\ncall at boot" {
  style.stroke: "#f5a623"
  style.stroke-dash: 4
}
init_seq.seq -> pit_driver.pit_init_seq: "pit_init(100)\ncall at boot" {
  style.stroke: "#7bed9f"
  style.stroke-dash: 4
}
init_seq.seq -> kb_driver.kb_buffer: "keyboard_init()\ncall at boot" {
  style.stroke: "#70a1ff"
  style.stroke-dash: 4
}
init_seq.seq -> idt_struct.idt_array: "idt_setup_all()\ncall at boot" {
  style.stroke: "#9b59b6"
  style.stroke-dash: 4
}

# CR2 used by page fault handler
hw.cpu.cr2_reg -> c_handlers.exception_handler: "mov %%cr2, %0\nread FIRST in vector 14" {
  style.stroke: "#e74c3c"
  style.stroke-dash: 3
}

# Frame layout reference
frame.frame_layout -> stubs.isr_common: "layout matches\npush order" {
  style.stroke: "#e74c3c"
  style.stroke-dash: 6
}
frame.frame_layout -> c_handlers.exception_handler: "frame pointer\n(interrupt_frame_t*)" {
  style.stroke: "#e74c3c"
  style.stroke-dash: 6
}

# Keyboard buffer → kernel consumer
kb_driver.kb_buffer -> kb_driver.kb_handler_algo: "write on IRQ1" {
  style.stroke: "#70a1ff"
}

# Spurious IRQ detection
c_handlers.irq_dispatcher -> pic_driver.spurious: "IRQ7/IRQ15:\ncheck ISR register" {
  style.stroke: "#e67e22"
  style.stroke-dash: 4
}