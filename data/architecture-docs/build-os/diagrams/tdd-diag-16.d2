layout-engine: elk
theme-id: 200

# 1. PHYSICAL MEMORY LAYOUT (128 MB)
# Exact byte offsets left margin, field sizes right margin.
# Header=Purple, Data=Blue, Free=Green, Padding=Gray, Pointers=Orange.
mem_map: {
  shape: sql_table
  style.stroke-width: 4
  
  "0x00000000": "Frame 0: [RESERVED] BIOS/IVT/BDA" {
    constraint: "4 KB"
    style.fill: "#6a0dad"
    style.font-color: white
  }
  "0x00001000": "Frames 1â€“159: [DATA] Conventional RAM" {
    constraint: "636 KB"
    style.fill: "#1a5276"
    style.font-color: white
  }
  "0x000A0000": "[PADDING] VGA/ROM Hole" {
    constraint: "384 KB"
    style: {
      fill: "#4a4a4a"
      font-color: white
      stroke-dash: 3
    }
  }
  "0x00100000": "[HEADER] Kernel Binary Section" {
    constraint: "~1 MB"
    style.fill: "#6a0dad"
    style.font-color: white
  }
  "0x00200000": "[HEADER] frame_bitmap[] (1 Page)" {
    constraint: "4 KB"
    style.fill: "#6a0dad"
    style.font-color: white
  }
  "0x00201000": "[FREE] High Memory Area" {
    constraint: "125 MB"
    style.fill: "#27ae60"
    style.font-color: white
  }
}

# 2. ARCHITECTURE: BITMAP STRUCTURE
# fields: name, type, size. 4096B = bold boundary.
bitmap_t: {
  shape: class
  label: "sizeof=4096 bytes (one page alignment)"
  style.stroke-width: 4
  
  words: "uint32_t[1024]"
  free_frames: "uint32_t"
  total_frames: "uint32_t"
  
  + pmm_init(mmap_t*): void
  + pmm_alloc_frame(): void*
  + pmm_free_frame(void*): void
}

# 3. ALGORITHM: WORD-SKIP ALLOCATOR
# COMPLETE state each step. Changed elements RED + bold.
word_skip_algorithm: {
  direction: right

  step1: "1. Skip Full Words" {
    label: |'md
      **Scan words[i]**
      If `words[i] == 0xFFFFFFFF`
      **CONTINUE** (Skip 32 bits)
    '|
    style.fill: "#4a4a4a"
    style.font-color: white
  }

  step2: "2. Locate Bit" {
    label: |'md
      **Scan bits in words[i]**
      `target = ~words[i]`
      `bit = __builtin_ctz(target)`
    '|
    style.fill: "#1a5276"
    style.font-color: white
  }

  step3: "3. Commit Allocation" {
    label: |'md
      **words[i] |= (1 << bit)**
      **bitmap[i] = UPDATED**
      **free_frames--**
    '|
    style: {
      fill: "#6a0dad"
      font-color: "#ff4d4d"
      bold: true
      stroke-width: 4
    }
  }

  step1 -> step2: "words[i] < 0xFFFFFFFF"
  step2 -> step3: "Find zero bit"
}

# 4. BIT MANIPULATION REFERENCE
# Uses block strings to handle symbols like |= and &=
bit_ops: {
  style.fill: "#0d1b2a"
  style.stroke: orange
  
  micro_ref: |`md
    ### Operation Primitives
    - **SET**: `bitmap[f/32] |= (1u << (f%32))`
    - **CLR**: `bitmap[f/32] &= ~(1u << (f%32))`
    - **TEST**: `(bitmap[f/32] >> (f%32)) & 1`

    ### CTZ Logic
    `__builtin_ctz(~word)` finds the first 0-bit.
    Compiles to Intel `BSF` (Bit Scan Forward).
    *Invariant: Guard against 0xFFFFFFFF before CTZ.*
  `|
  micro_ref.style.font-color: "#ccaaff"
}

# 5. STATE MACHINE
# States with invariants. Transitions: trigger + guard + action.
pmm_fsm: {
  start: "" {
    shape: circle
    style.fill: black
  }
  
  uninit: "UNINITIALIZED" {
    tooltip: "Bitmap state undefined"
  }

  running: "RUNNING" {
    tooltip: "Frame 0 Reserved | free_count matches bits"
  }

  panic: "PANIC (OOM)" {
    style.fill: red
    style.font-color: white
  }

  start -> uninit
  uninit -> running: "pmm_init() / Parse GRUB mmap"
  running -> panic: "pmm_alloc() / [free_frames == 0]"
  
  panic -> running: "RESET" {
    style.stroke: red
    style.stroke-dash: 3
    target-arrowhead.label: "ILLEGAL"
  }
}

# Layout Connections
mem_map -> bitmap_t: "defines layout"
bitmap_t -> word_skip_algorithm: "logic container"
word_skip_algorithm -> bit_ops: "references primitives"
pmm_fsm -> word_skip_algorithm: "executes"

# Annotations
total_size: "Total Managed: 128 MB (32768 Frames)" {
  near: top-right
  shape: text
  style.bold: true
}