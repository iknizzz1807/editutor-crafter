vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  ## TLB Flush Decision Tree â€” invlpg vs Full CR3 Reload
  Start: a page table entry has been modified
| {
  near: top-center
  style.font-size: 14
}
start: "Page Table Entry Modified" {
  shape: circle
  style.fill: "#1a1a2e"
  style.font-color: white
  style.stroke: "#4a4a8a"
  style.stroke-width: 3
}
q1: "Was a previously-UNMAPPED page\nnow mapped (not-present â†’ present)?" {
  shape: diamond
  style.fill: "#2d2d4e"
  style.font-color: "#e0e0ff"
  style.stroke: "#6a6aaa"
  style.stroke-width: 2
}
safe_no_flush: "NO FLUSH REQUIRED" {
  shape: rectangle
  style.fill: "#1a3a1a"
  style.font-color: "#88ff88"
  style.stroke: "#44aa44"
  style.stroke-width: 2
  style.border-radius: 6
}
safe_note: |md
  **Reason:** No stale TLB entry exists
  for this virtual address â€” it was
  never cached (present=0 previously).
  Cost: **0 cycles** (skip flush entirely)
| {
  shape: text
  style.font-size: 11
}
q2: "How many PTEs were modified?" {
  shape: diamond
  style.fill: "#2d2d4e"
  style.font-color: "#e0e0ff"
  style.stroke: "#6a6aaa"
  style.stroke-width: 2
}
q3: "Are we switching address spaces\n(loading a new page directory into CR3)?" {
  shape: diamond
  style.fill: "#2d2d4e"
  style.font-color: "#e0e0ff"
  style.stroke: "#6a6aaa"
  style.stroke-width: 2
}
single_invlpg: "invlpg(virt_addr)" {
  shape: rectangle
  style.fill: "#1a2a3a"
  style.font-color: "#88ccff"
  style.stroke: "#3388cc"
  style.stroke-width: 2
  style.border-radius: 6
}
single_invlpg_note: |md
  **x86 instruction:** `INVLPG m`
  Evicts exactly **one** TLB entry
  for the given virtual address.
  Cost: **~20â€“50 cycles** (~10 ns @ 3 GHz)
  Effect: O(1) â€” constant time regardless
  of TLB size or occupancy.
  **When:** Permission change, frame remap,
  or presentâ†’not-present for a single page.
| {
  shape: text
  style.font-size: 11
}
multi_loop: "Loop: invlpg(virt_addr_i)\nfor each modified page i" {
  shape: rectangle
  style.fill: "#1a2a3a"
  style.font-color: "#88ccff"
  style.stroke: "#3388cc"
  style.stroke-width: 2
  style.border-radius: 6
}
multi_loop_note: |md
  Cost: **N Ã— ~20â€“50 cycles**
  where N = number of modified PTEs.
  Preferred over full CR3 reload when
  N < ~32 (avoids thrashing hot kernel
  TLB entries shared by all processes).
  If N is large (e.g., unmapping a 1 GB
  region), full CR3 reload becomes cheaper.
| {
  shape: text
  style.font-size: 11
}
cr3_reload_switch: "Full CR3 Reload\n(write new PD physical addr to CR3)" {
  shape: rectangle
  style.fill: "#3a1a1a"
  style.font-color: "#ffaaaa"
  style.stroke: "#cc3333"
  style.stroke-width: 2
  style.border-radius: 6
}
cr3_reload_switch_note: |md
  **Assembly:** `mov cr3, <new_pd_phys>`
  Flushes ALL non-global TLB entries.
  Global entries (PTE_GLOBAL set) survive.
  Cost: **~200â€“500 cycles** (~100 ns)
  + burst of TLB cold-misses afterward
  for kernel pages not marked GLOBAL.
  **When:** Context switch between processes
  with different page directories.
| {
  shape: text
  style.font-size: 11
}
q4: "Is the modified kernel mapping shared\nacross ALL process page directories?" {
  shape: diamond
  style.fill: "#2d2d4e"
  style.font-color: "#e0e0ff"
  style.stroke: "#6a6aaa"
  style.stroke-width: 2
}
cr3_reload_kernel: "Full CR3 Reload in current process\n(reload same CR3 value)" {
  shape: rectangle
  style.fill: "#3a1a1a"
  style.font-color: "#ffaaaa"
  style.stroke: "#cc3333"
  style.stroke-width: 2
  style.border-radius: 6
}
cr3_reload_kernel_note: |md
  **Assembly:** `mov eax, cr3; mov cr3, eax`
  Reloads same physical PD address â€”
  flushes all non-global entries in
  the CURRENT CPU's TLB.
  Cost: **~200â€“500 cycles**
  **When:** Kernel page table changed
  (e.g., kmalloc heap extends, new
  kernel mapping added/removed).
| {
  shape: text
  style.font-size: 11
}
ipi_note: |md
  ## âš  SMP Future: TLB Shootdown
  On multicore systems, each CPU has its
  **own private TLB**. Modifying a shared
  kernel PTE on CPU 0 leaves stale entries
  on CPU 1, 2, â€¦ N.
  **Required action:**
  Send an **Inter-Processor Interrupt (IPI)**
  to all other CPUs, instructing them to
  execute `invlpg` or CR3 reload.
  Must wait for all CPUs to ACK before
  the modifying CPU can proceed.
  Cost: **microseconds** (IPI round-trip)
  This is why `munmap` is expensive
  in production Linux on many-core systems.
  **M1â€“M4 kernel: single-core only.**
  No IPI implementation required.
| {
  shape: rectangle
  style.fill: "#2a1a2a"
  style.font-color: "#ddaadd"
  style.stroke: "#884488"
  style.stroke-width: 2
  style.border-radius: 6
}
legend: |md
  **Legend**
  ðŸŸ¢ No action needed
  ðŸ”µ invlpg â€” targeted, cheap
  ðŸ”´ CR3 reload â€” full flush, costly
  ðŸŸ£ SMP future â€” IPI required
| {
  shape: rectangle
  style.fill: "#1a1a2a"
  style.font-color: "#ccccee"
  style.stroke: "#4a4a6a"
  style.border-radius: 4
  near: bottom-right
}
# â”€â”€ Primary flow connections â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
start -> q1: "" {
  style.stroke: "#888888"
  style.stroke-width: 2
}
q1 -> safe_no_flush: "YES\n(not-present â†’ present)" {
  style.stroke: "#44aa44"
  style.stroke-width: 2
  style.font-color: "#44aa44"
}
q1 -> q2: "NO\n(permission/frame/unmap change)" {
  style.stroke: "#888888"
  style.stroke-width: 2
}
safe_no_flush -> safe_note: "" {
  style.stroke: "#44aa44"
  style.stroke-dash: 4
  style.stroke-width: 1
}
q2 -> single_invlpg: "Single page\nmodified" {
  style.stroke: "#3388cc"
  style.stroke-width: 2
  style.font-color: "#3388cc"
}
q2 -> multi_loop: "Multiple pages\nmodified (same PT\nor different PTs)" {
  style.stroke: "#3388cc"
  style.stroke-width: 2
  style.font-color: "#3388cc"
}
q2 -> q3: "Entire address space\nbeing replaced" {
  style.stroke: "#888888"
  style.stroke-width: 2
}
single_invlpg -> single_invlpg_note: "" {
  style.stroke: "#3388cc"
  style.stroke-dash: 4
  style.stroke-width: 1
}
multi_loop -> multi_loop_note: "" {
  style.stroke: "#3388cc"
  style.stroke-dash: 4
  style.stroke-width: 1
}
q3 -> cr3_reload_switch: "YES\n(context switch to\ndifferent process)" {
  style.stroke: "#cc3333"
  style.stroke-width: 2
  style.font-color: "#cc3333"
}
q3 -> q4: "NO\n(kernel PTE changed;\nsame address space)" {
  style.stroke: "#888888"
  style.stroke-width: 2
}
cr3_reload_switch -> cr3_reload_switch_note: "" {
  style.stroke: "#cc3333"
  style.stroke-dash: 4
  style.stroke-width: 1
}
q4 -> cr3_reload_kernel: "YES\n(shared kernel PT\nentry modified)" {
  style.stroke: "#cc3333"
  style.stroke-width: 2
  style.font-color: "#cc3333"
}
q4 -> single_invlpg: "NO\n(private mapping;\nuse invlpg)" {
  style.stroke: "#3388cc"
  style.stroke-width: 2
  style.font-color: "#3388cc"
}
cr3_reload_kernel -> cr3_reload_kernel_note: "" {
  style.stroke: "#cc3333"
  style.stroke-dash: 4
  style.stroke-width: 1
}
cr3_reload_kernel -> ipi_note: "SMP: also send IPI\nto all other CPUs" {
  style.stroke: "#884488"
  style.stroke-width: 2
  style.stroke-dash: 5
  style.font-color: "#884488"
}