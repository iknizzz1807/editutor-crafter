vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Kernel Heap Block Layout and Free-List Coalescing
  Virtual heap arena: 0xC0400000 – 0xCFFF0000 (252 MB virtual)
| {near: top-center}
# ─── LEGEND ──────────────────────────────────────────────────────────────────
legend: {
  near: bottom-center
  style.fill: "#F5F5F5"
  style.stroke: "#999999"
  style.border-radius: 6
  l_header: "heap_block_t header (20 B)" {
    style.fill: "#9C27B0"
    style.font-color: white
    style.border-radius: 4
  }
  l_data_used: "User data (used)" {
    style.fill: "#1565C0"
    style.font-color: white
    style.border-radius: 4
  }
  l_data_free: "User data (free)" {
    style.fill: "#2E7D32"
    style.font-color: white
    style.border-radius: 4
  }
  l_padding: "Padding / alignment" {
    style.fill: "#757575"
    style.font-color: white
    style.border-radius: 4
  }
  l_magic: "HEAP_MAGIC = 0xDEADBEEF" {
    style.fill: "#E65100"
    style.font-color: white
    style.border-radius: 4
  }
}
# ═══════════════════════════════════════════════════════════════════════════════
# SECTION 1: heap_block_t STRUCT — BYTE-LEVEL LAYOUT
# ═══════════════════════════════════════════════════════════════════════════════
struct_section: "heap_block_t Byte-Level Structure  ·  sizeof = 20 bytes" {
  style.fill: "#F3E5F5"
  style.stroke: "#7B1FA2"
  style.border-radius: 8
  style.font-color: "#4A148C"
  offset_col: |md
    **Offset**
    +0
    +4
    +8
    +9
    +12
    +16
  | {
    style.fill: "#EDE7F6"
    style.stroke: "#7B1FA2"
    style.font: mono
  }
  f_size: "+0  size  [uint32_t · 4 B]" {
    style.fill: "#9C27B0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "Byte count of data region (NOT including header). Multiple of HEAP_ALIGN=8."
  }
  f_magic: "+4  magic [uint32_t · 4 B]  =  0xDEADBEEF" {
    style.fill: "#E65100"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "Corruption sentinel. Checked on every kmalloc/kfree traversal. If wrong → halt."
  }
  f_used: "+8  used  [uint8_t  · 1 B]  =  0|1" {
    style.fill: "#9C27B0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "0 = free, 1 = allocated. Double-free detected when kfree sees used==0."
  }
  f_pad: "+9  _pad  [uint8_t[3] · 3 B] = 0x00 00 00" {
    style.fill: "#757575"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "Compiler alignment padding to reach 4-byte boundary for next pointer."
  }
  f_next: "+12 next  [heap_block_t* · 4 B]" {
    style.fill: "#E65100"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "Virtual pointer to next block in doubly-linked free list. NULL if last."
  }
  f_prev: "+16 prev  [heap_block_t* · 4 B]" {
    style.fill: "#E65100"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "Virtual pointer to previous block. NULL if first."
  }
  f_data: "+20 [ user data region — size bytes, 8-byte aligned ]" {
    style.fill: "#1565C0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "Pointer returned to caller = (heap_block_t*)block + 1 = base + 20."
  }
  f_size -> f_magic -> f_used -> f_pad -> f_next -> f_prev -> f_data: {
    style.stroke-width: 0
    style.opacity: 0
  }
  note: |md
    **Pointer arithmetic:**
    `kmalloc` returns `(void*)(block + 1)` = block_base + 20
    `kfree(ptr)`: `block = (heap_block_t*)ptr - 1` = ptr - 20
    **HEAP_ALIGN = 8**: all `size` values rounded up to multiple of 8
  | {
    style.fill: "#EDE7F6"
    style.stroke: "#9C27B0"
    style.font-color: "#4A148C"
  }
}
# ═══════════════════════════════════════════════════════════════════════════════
# SECTION 2: ARENA OVERVIEW — VIRTUAL ADDRESS SEQUENCE
# ═══════════════════════════════════════════════════════════════════════════════
arena_section: "Heap Arena  ·  0xC0400000 – 0xCFFF0000  (252 MB virtual, demand-committed)" {
  style.fill: "#E8F5E9"
  style.stroke: "#2E7D32"
  style.border-radius: 8
  brk_note: "heap_brk → committed boundary; pages beyond are not mapped until heap_extend()" {
    style.fill: "#C8E6C9"
    style.stroke: "#388E3C"
    style.font-color: "#1B5E20"
    style.font: mono
  }
  a_start: "0xC0400000\nHEAP_START" {
    style.fill: "#2E7D32"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  blk_A_hdr: "Block A\nheader\n+0..+19\n[20 B]" {
    style.fill: "#9C27B0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "magic=0xDEADBEEF, used=1, size=64, next→Block B, prev=NULL"
  }
  blk_A_data: "Block A\ndata\n+20..+83\n[64 B]\nused=1" {
    style.fill: "#1565C0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  blk_B_hdr: "Block B\nheader\n+84..+103\n[20 B]" {
    style.fill: "#9C27B0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "magic=0xDEADBEEF, used=0 (free), size=128, next→Block C, prev→Block A"
  }
  blk_B_data: "Block B\ndata\n+104..+231\n[128 B]\nfree=0" {
    style.fill: "#2E7D32"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  blk_C_hdr: "Block C\nheader\n+232..+251\n[20 B]" {
    style.fill: "#9C27B0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "magic=0xDEADBEEF, used=1, size=256, next→Block D, prev→Block B"
  }
  blk_C_data: "Block C\ndata\n+252..+507\n[256 B]\nused=1" {
    style.fill: "#1565C0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  blk_D_hdr: "Block D\nheader\n+508..+527\n[20 B]" {
    style.fill: "#9C27B0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "magic=0xDEADBEEF, used=0 (free), size=4076, next=NULL, prev→Block C"
  }
  blk_D_data: "Block D\ndata\n+528..+4603\n[4076 B]\nfree=0" {
    style.fill: "#2E7D32"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  a_brk: "heap_brk =\n0xC0401000\n(one page\ncommitted)" {
    style.fill: "#F57F17"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  a_uncommitted: "0xC0401000 …\nNOT MAPPED\n(triggers\nheap_extend)" {
    style.fill: "#ECEFF1"
    style.stroke: "#90A4AE"
    style.font-color: "#546E7A"
    style.stroke-dash: 6
    style.font: mono
    style.border-radius: 4
  }
  a_end: "0xCFFF0000\nHEAP_END" {
    style.fill: "#B71C1C"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  a_start -> blk_A_hdr -> blk_A_data -> blk_B_hdr -> blk_B_data -> blk_C_hdr -> blk_C_data -> blk_D_hdr -> blk_D_data -> a_brk -> a_uncommitted -> a_end: {
    style.stroke-width: 2
    style.stroke: "#2E7D32"
  }
  ptr_next_AB: "next →" {style.fill: "#FFF9C4"; style.font: mono; style.font-color: "#E65100"}
  ptr_next_BC: "next →" {style.fill: "#FFF9C4"; style.font: mono; style.font-color: "#E65100"}
  ptr_prev_BA: "← prev" {style.fill: "#FFF9C4"; style.font: mono; style.font-color: "#E65100"}
  ptr_prev_CB: "← prev" {style.fill: "#FFF9C4"; style.font: mono; style.font-color: "#E65100"}
  blk_A_hdr -> ptr_next_AB -> blk_B_hdr: {style.stroke: "#E65100"; style.stroke-dash: 3}
  blk_B_hdr -> ptr_next_BC -> blk_C_hdr: {style.stroke: "#E65100"; style.stroke-dash: 3}
  blk_B_hdr -> ptr_prev_BA -> blk_A_hdr: {style.stroke: "#FF7043"; style.stroke-dash: 3}
  blk_C_hdr -> ptr_prev_CB -> blk_B_hdr: {style.stroke: "#FF7043"; style.stroke-dash: 3}
}
# ═══════════════════════════════════════════════════════════════════════════════
# SECTION 3: SCENARIO 1 — SPLIT ON kmalloc
# ═══════════════════════════════════════════════════════════════════════════════
split_section: "Scenario 1: kmalloc(32) — Split a 128-byte free block" {
  style.fill: "#E3F2FD"
  style.stroke: "#1565C0"
  style.border-radius: 8
  split_before: "BEFORE  kmalloc(32)" {
    style.fill: "#BBDEFB"
    style.stroke: "#1976D2"
    style.border-radius: 6
    sb_hdr: "Free Block X\nheader [20 B]\nmagic=0xDEADBEEF\nused=0\nsize=128" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    sb_data: "Free region\n[128 B]\n← entire span\nis unused" {
      style.fill: "#2E7D32"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    sb_hdr -> sb_data: {style.stroke: "#2E7D32"; style.stroke-width: 2}
  }
  split_arrow: "kmalloc(32)\n→ align→32\n→ split if\n remainder ≥\n 20+8=28 B" {
    shape: parallelogram
    style.fill: "#FFF176"
    style.stroke: "#F9A825"
    style.font-color: "#E65100"
    style.font: mono
  }
  split_after: "AFTER  kmalloc(32) — Block X split into X1 (allocated) + X2 (free)" {
    style.fill: "#BBDEFB"
    style.stroke: "#1976D2"
    style.border-radius: 6
    sa_x1_hdr: "Block X1\nheader [20 B]\nused=1\nsize=32\nnext→X2" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    sa_x1_data: "X1 data\n[32 B]\n← returned\nto caller" {
      style.fill: "#1565C0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    sa_x2_hdr: "Block X2\nheader [20 B]\nused=0\nsize=76\nnext→…" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    sa_x2_data: "X2 free\n[76 B]\n= 128-32-20\nremaining" {
      style.fill: "#2E7D32"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    sa_size_check: |md
      **Split condition:**
      `remainder = block->size - size - sizeof(header)`
      `= 128 - 32 - 20 = 76 ≥ HEAP_ALIGN(8)` → **split**
      If remainder < 8: give entire block (no split)
    | {
      style.fill: "#E3F2FD"
      style.stroke: "#1976D2"
      style.font-color: "#0D47A1"
    }
    sa_x1_hdr -> sa_x1_data: {style.stroke: "#1565C0"; style.stroke-width: 2}
    sa_x1_hdr -> sa_x2_hdr: {style.stroke: "#E65100"; style.stroke-dash: 3; label: "next →"}
    sa_x2_hdr -> sa_x2_data: {style.stroke: "#2E7D32"; style.stroke-width: 2}
    sa_x2_hdr -> sa_x1_hdr: {style.stroke: "#FF7043"; style.stroke-dash: 3; label: "← prev"}
  }
  split_before -> split_arrow -> split_after: {style.stroke: "#1565C0"; style.stroke-width: 2}
  caller_ptr: "Caller receives:\n0xC04xxxxx+20\n(points into\nX1 data)" {
    style.fill: "#C8E6C9"
    style.stroke: "#388E3C"
    style.font-color: "#1B5E20"
    style.font: mono
    style.border-radius: 4
  }
  split_after.sa_x1_data -> caller_ptr: {style.stroke: "#388E3C"; style.stroke-dash: 4}
}
# ═══════════════════════════════════════════════════════════════════════════════
# SECTION 4: SCENARIO 2 — COALESCE FORWARD on kfree
# ═══════════════════════════════════════════════════════════════════════════════
coalesce_fwd_section: "Scenario 2: kfree(ptr_to_B) — Coalesce-Forward  [B used, C free → merge B+C]" {
  style.fill: "#FFF8E1"
  style.stroke: "#F57F17"
  style.border-radius: 8
  cf_before: "BEFORE  kfree" {
    style.fill: "#FFE082"
    style.stroke: "#F9A825"
    style.border-radius: 6
    cfb_B_hdr: "Block B\nheader [20 B]\nused=1  size=64\nnext→C  prev→A" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cfb_B_data: "Block B data\n[64 B]\nused=1\n← being freed" {
      style.fill: "#1565C0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cfb_C_hdr: "Block C\nheader [20 B]\nused=0  size=128\nnext→D  prev→B" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cfb_C_data: "Block C data\n[128 B]\nfree" {
      style.fill: "#2E7D32"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cfb_B_hdr -> cfb_B_data: {style.stroke: "#1565C0"}
    cfb_C_hdr -> cfb_C_data: {style.stroke: "#2E7D32"}
    cfb_B_hdr -> cfb_C_hdr: {style.stroke: "#E65100"; style.stroke-dash: 3; label: "next →"}
    cfb_C_hdr -> cfb_B_hdr: {style.stroke: "#FF7043"; style.stroke-dash: 3; label: "← prev"}
  }
  cf_steps: |md
    **kfree algorithm:**
    1. `block = ptr - 1`  (back to header)
    2. Verify `magic == 0xDEADBEEF`
    3. Verify `used == 1`  (else: DOUBLE FREE → halt)
    4. Set `used = 0`
    5. **Coalesce forward:** if `next != NULL && next->used == 0`:
       `block->size += sizeof(header) + next->size`  `= 64 + 20 + 128 = 212`
       `block->next = next->next`
       `next->next->prev = block`
       `next->magic = 0`  ← invalidate merged header
    6. **Coalesce backward:** if `prev != NULL && prev->used == 0`: merge prev←block
  | {
    style.fill: "#FFF9C4"
    style.stroke: "#F9A825"
    style.font-color: "#E65100"
  }
  cf_after: "AFTER  kfree  — B and C merged into single free block BC" {
    style.fill: "#FFE082"
    style.stroke: "#F9A825"
    style.border-radius: 6
    cfa_BC_hdr: "Block BC\nheader [20 B]\nused=0  size=212\nnext→D  prev→A" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cfa_BC_data: "Block BC data\n[212 B]\nfree\n= 64+20+128\n(B data + C header + C data)" {
      style.fill: "#2E7D32"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cfa_old_C: "Old C header\n[invalidated]\nmagic = 0\n(no longer a valid block)" {
      style.fill: "#757575"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
      style.stroke-dash: 5
    }
    cfa_BC_hdr -> cfa_BC_data: {style.stroke: "#2E7D32"; style.stroke-width: 2}
    cfa_BC_data -> cfa_old_C: {style.stroke: "#757575"; style.stroke-dash: 4; label: "overlaps\n(absorbed)"}
  }
  cf_before -> cf_steps -> cf_after: {style.stroke: "#F57F17"; style.stroke-width: 2}
}
# ═══════════════════════════════════════════════════════════════════════════════
# SECTION 5: SCENARIO 3 — COALESCE BACKWARD on kfree
# ═══════════════════════════════════════════════════════════════════════════════
coalesce_bwd_section: "Scenario 3: kfree(ptr_to_C) — Coalesce-Backward  [B free, C used → merge B+C]" {
  style.fill: "#FCE4EC"
  style.stroke: "#C62828"
  style.border-radius: 8
  cb_before: "BEFORE  kfree(C)" {
    style.fill: "#FFCDD2"
    style.stroke: "#E53935"
    style.border-radius: 6
    cbb_B_hdr: "Block B\nheader [20 B]\nused=0  size=64\nnext→C  prev→A" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cbb_B_data: "Block B data\n[64 B]\nfree" {
      style.fill: "#2E7D32"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cbb_C_hdr: "Block C\nheader [20 B]\nused=1  size=128\nnext→D  prev→B" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cbb_C_data: "Block C data\n[128 B]\nused=1\n← being freed" {
      style.fill: "#1565C0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cbb_B_hdr -> cbb_B_data: {style.stroke: "#2E7D32"}
    cbb_C_hdr -> cbb_C_data: {style.stroke: "#1565C0"}
    cbb_B_hdr -> cbb_C_hdr: {style.stroke: "#E65100"; style.stroke-dash: 3; label: "next →"}
    cbb_C_hdr -> cbb_B_hdr: {style.stroke: "#FF7043"; style.stroke-dash: 3; label: "← prev"}
  }
  cb_steps: |md
    **kfree(C) backward coalesce:**
    1–4. Verify magic, used; set `C->used = 0`
    5. Forward coalesce: `C->next` (D) is used → no merge
    6. **Backward coalesce:** `C->prev` (B) is **free**:
       `prev->size += sizeof(header) + C->size`  `= 64 + 20 + 128 = 212`
       `prev->next = C->next`  (B.next → D)
       `C->next->prev = prev`  (D.prev → B)
       `C->magic = 0`  ← invalidate C header
    **Order matters:** always coalesce forward FIRST, then backward.
    Reason: if both neighbors are free, forward merge expands the block first
    so backward merge correctly absorbs the full expanded size.
  | {
    style.fill: "#FFEBEE"
    style.stroke: "#E53935"
    style.font-color: "#B71C1C"
  }
  cb_after: "AFTER  kfree(C)  — B and C merged into single free block BC" {
    style.fill: "#FFCDD2"
    style.stroke: "#E53935"
    style.border-radius: 6
    cba_BC_hdr: "Block BC\nheader [20 B]\nused=0  size=212\nnext→D  prev→A" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cba_BC_data: "Block BC data\n[212 B]\nfree\n= 64+20+128" {
      style.fill: "#2E7D32"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    cba_old_C: "Old C header\n[invalidated]\nmagic = 0" {
      style.fill: "#757575"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
      style.stroke-dash: 5
    }
    cba_BC_hdr -> cba_BC_data: {style.stroke: "#2E7D32"; style.stroke-width: 2}
    cba_BC_data -> cba_old_C: {style.stroke: "#757575"; style.stroke-dash: 4; label: "absorbed"}
  }
  cb_before -> cb_steps -> cb_after: {style.stroke: "#C62828"; style.stroke-width: 2}
}
# ═══════════════════════════════════════════════════════════════════════════════
# SECTION 6: heap_extend() — COMMITTING NEW PAGES
# ═══════════════════════════════════════════════════════════════════════════════
extend_section: "heap_extend(size): No free block satisfies request → commit new page(s)" {
  style.fill: "#E8EAF6"
  style.stroke: "#283593"
  style.border-radius: 8
  ext_trigger: "kmalloc scan:\nno free block\nwith size ≥ N" {
    shape: diamond
    style.fill: "#FFF176"
    style.stroke: "#F9A825"
    style.font-color: "#E65100"
    style.font: mono
  }
  ext_pmm: "pmm_alloc_frame()\n→ physical frame F\n(marks bit in bitmap)" {
    style.fill: "#4CAF50"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "Returns 4KB-aligned physical address. Halts if OOM."
  }
  ext_map: "paging_map(boot_pd,\n  heap_brk,\n  F,\n  PTE_PRESENT|PTE_WRITABLE)" {
    style.fill: "#1565C0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
    tooltip: "Maps virtual heap_brk → physical F. Calls invlpg(heap_brk) to flush TLB."
  }
  ext_advance: "heap_brk += PAGE_SIZE\n(= heap_brk + 4096)" {
    style.fill: "#F57F17"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  ext_init: "Create new heap_block_t at new_virt:\n  magic = 0xDEADBEEF\n  size  = pages*4096 - 20\n  used  = 0\n  next  = NULL\n  prev  = list_tail" {
    style.fill: "#9C27B0"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  ext_append: "Append to free list:\n  list_tail->next = new_block\n  new_block->prev = list_tail" {
    style.fill: "#E65100"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  ext_retry: "Retry kmalloc:\nnew block is\nguaranteed\nto satisfy N" {
    style.fill: "#2E7D32"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  ext_guard: "heap_brk + pages*4096\n> HEAP_END ?" {
    shape: diamond
    style.fill: "#FFCDD2"
    style.stroke: "#C62828"
    style.font-color: "#B71C1C"
    style.font: mono
  }
  ext_halt: "kprintf HEAP EXHAUSTED\ncli; hlt" {
    style.fill: "#B71C1C"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  ext_trigger -> ext_guard: {style.stroke: "#283593"; style.stroke-width: 2; label: "need pages"}
  ext_guard -> ext_halt: {style.stroke: "#B71C1C"; style.stroke-width: 2; label: "YES\n(0xCFFF0000 exceeded)"}
  ext_guard -> ext_pmm: {style.stroke: "#388E3C"; style.stroke-width: 2; label: "NO — safe to extend"}
  ext_pmm -> ext_map: {style.stroke: "#283593"; style.stroke-width: 2}
  ext_map -> ext_advance: {style.stroke: "#283593"; style.stroke-width: 2}
  ext_advance -> ext_init: {style.stroke: "#283593"; style.stroke-width: 2}
  ext_init -> ext_append: {style.stroke: "#283593"; style.stroke-width: 2}
  ext_append -> ext_retry: {style.stroke: "#283593"; style.stroke-width: 2}
  ext_mem_layout: "New committed page layout after extend:" {
    style.fill: "#C5CAE9"
    style.stroke: "#3949AB"
    style.border-radius: 6
    eml_hdr: "heap_brk_old:\nnew block header\n[20 B]\nused=0, size=4076" {
      style.fill: "#9C27B0"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    eml_data: "heap_brk_old+20:\nfree data region\n[4076 B]\n= PAGE_SIZE-20" {
      style.fill: "#2E7D32"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    eml_newbrk: "heap_brk_new =\nheap_brk_old + 4096\n(next uncommitted)" {
      style.fill: "#F57F17"
      style.font-color: white
      style.font: mono
      style.border-radius: 4
    }
    eml_hdr -> eml_data -> eml_newbrk: {style.stroke: "#3949AB"; style.stroke-width: 2}
  }
  ext_retry -> ext_mem_layout: {style.stroke: "#3949AB"; style.stroke-dash: 4; label: "resulting\nlayout"}
}
# ═══════════════════════════════════════════════════════════════════════════════
# SECTION 7: CORRUPTION DETECTION SUMMARY
# ═══════════════════════════════════════════════════════════════════════════════
corruption_section: "Corruption Detection — Invariant Checks on Every kmalloc/kfree" {
  style.fill: "#EFEBE9"
  style.stroke: "#4E342E"
  style.border-radius: 8
  c1: "CHECK 1  kmalloc scan:\nif block->magic ≠ 0xDEADBEEF\n→ kprintf CORRUPTION + cli;hlt\nCatch: buffer overrun into neighbor header" {
    style.fill: "#BF360C"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  c2: "CHECK 2  kfree entry:\nif block->magic ≠ 0xDEADBEEF\n→ kprintf CORRUPTION + cli;hlt\nCatch: free of non-heap pointer or wild ptr" {
    style.fill: "#BF360C"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  c3: "CHECK 3  kfree entry:\nif block->used == 0\n→ kprintf DOUBLE FREE + cli;hlt\nCatch: use-after-free (freed twice)" {
    style.fill: "#4E342E"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  c4: "CHECK 4  coalesce neighbors:\nif neighbor->magic ≠ 0xDEADBEEF\n→ kprintf CORRUPTION + cli;hlt\nCatch: corruption propagated to adjacent block" {
    style.fill: "#BF360C"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
  c5: "CHECK 5  kfree(NULL):\nif ptr == NULL → return (no-op)\nMatches C standard free(NULL) behavior" {
    style.fill: "#33691E"
    style.font-color: white
    style.font: mono
    style.border-radius: 4
  }
}
# ─── TOP-LEVEL FLOW ──────────────────────────────────────────────────────────
struct_section -> arena_section: {
  style.stroke: "#7B1FA2"
  style.stroke-width: 2
  label: "struct instances\nat HEAP_START+"
}
arena_section -> split_section: {
  style.stroke: "#1565C0"
  style.stroke-width: 2
  label: "kmalloc\nscenarios"
}
arena_section -> coalesce_fwd_section: {
  style.stroke: "#F57F17"
  style.stroke-width: 2
  label: "kfree\nforward"
}
arena_section -> coalesce_bwd_section: {
  style.stroke: "#C62828"
  style.stroke-width: 2
  label: "kfree\nbackward"
}
arena_section -> extend_section: {
  style.stroke: "#283593"
  style.stroke-width: 2
  label: "no free block\n→ extend"
}
split_section -> corruption_section: {
  style.stroke: "#4E342E"
  style.stroke-dash: 4
  label: "guards active\nduring all ops"
}
coalesce_fwd_section -> corruption_section: {
  style.stroke: "#4E342E"
  style.stroke-dash: 4
}
coalesce_bwd_section -> corruption_section: {
  style.stroke: "#4E342E"
  style.stroke-dash: 4
}
extend_section -> corruption_section: {
  style.stroke: "#4E342E"
  style.stroke-dash: 4
}