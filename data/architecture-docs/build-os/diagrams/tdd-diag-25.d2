vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: right

title: "Module Architecture: PMM, VMM, and Heap Subsystems" {
  shape: text
  near: top-center
  style: {
    font-size: 24
    bold: true
  }
}

# ── PHYSICAL MEMORY MANAGER ──────────────────────────────────────────────────

pmm_module: "Physical Memory Manager (pmm.c)" {
  style.fill: "#E8D5F5"
  style.stroke: "#7B2D8B"
  style.border-radius: 8

  bitmap: "frame_bitmap[32768]\n(128 KB in .bss)\n\n• 1 bit per 4KB frame\n• 0 = FREE, 1 = USED\n• Covers 4GB / 4KB = 1M frames\n• 512 frames per 64-byte cache line" {
    shape: rectangle
    style.fill: "#D4A8E8"
    style.stroke: "#7B2D8B"
  }

  counters: "Counters\n\n• pmm_total_frames\n• pmm_used_frames\n• pmm_search_hint\n  (next-fit position)" {
    shape: rectangle
    style.fill: "#D4A8E8"
    style.stroke: "#7B2D8B"
  }

  api: "Public API" {
    shape: class
    style.fill: "#C896DC"
    style.stroke: "#7B2D8B"

    pmm_parse_memory_map: "pmm_parse_memory_map(mbi: *multiboot_info_t): void"
    pmm_init: "pmm_init(mbi: *multiboot_info_t): void"
    pmm_mark_used: "pmm_mark_used(addr: uint64_t, len: uint64_t): void"
    pmm_mark_free: "pmm_mark_free(addr: uint64_t, len: uint64_t): void"
    pmm_alloc_frame: "pmm_alloc_frame(): void*  [4KB-aligned phys addr]"
    pmm_free_frame: "pmm_free_frame(addr: void*): void"
    pmm_frames_free: "pmm_frames_free(): uint32_t"
    pmm_frames_total: "pmm_frames_total(): uint32_t"
  }
}

# ── MULTIBOOT INPUT ──────────────────────────────────────────────────────────

mbi: "multiboot_info_t\n(from GRUB / EBX)\n\nflags [bit 6]\nmmap_addr\nmmap_length" {
  shape: rectangle
  style.fill: "#FFF3CC"
  style.stroke: "#CC8800"
}

mmap: "mmap_entry_t[]\n(E820 memory map)\n\n• size (uint32, +4 to next)\n• addr (uint64)\n• len  (uint64)\n• type (1=Usable, 2=Reserved\n        3=ACPI, 4=NVS, 5=Bad)" {
  shape: rectangle
  style.fill: "#FFF3CC"
  style.stroke: "#CC8800"
}

mbi -> mmap: "mmap_addr\npoints to"
mbi -> pmm_module.api: "passed to\npmm_parse_memory_map()\npmm_init()"

# ── VIRTUAL MEMORY MANAGER ───────────────────────────────────────────────────

vmm_module: "Virtual Memory Manager (vmm.c)" {
  style.fill: "#D5E8F5"
  style.stroke: "#1565C0"
  style.border-radius: 8

  pd: "boot_page_directory[1024]\n(4KB, aligned(PAGE_SIZE))\nin .bss\n\n• Index   0 → identity_page_table\n• Index 768 → kernel_page_table\n• All others = 0 (not present)" {
    shape: rectangle
    style.fill: "#A8C8E8"
    style.stroke: "#1565C0"
  }

  ipt: "identity_page_table[1024]\n(4KB, aligned)\n\nMaps virtual 0x000000–0x3FFFFF\n→ physical 0x000000–0x3FFFFF\n\nEntry i = (i × 4096) | P | W" {
    shape: rectangle
    style.fill: "#A8C8E8"
    style.stroke: "#1565C0"
  }

  kpt: "kernel_page_table[1024]\n(4KB, aligned)\n\nMaps virtual 0xC0000000–0xC03FFFFF\n→ physical 0x000000–0x3FFFFF\n\nEntry i = (i × 4096) | P | W" {
    shape: rectangle
    style.fill: "#A8C8E8"
    style.stroke: "#1565C0"
  }

  flags: "PTE / PDE Flag Bits [11:0]\n\nBit 0: P  = Present\nBit 1: W  = Writable\nBit 2: U  = User-accessible\nBit 3: PWT = Write-Through\nBit 4: PCD = Cache Disable\nBit 5: A  = Accessed\nBit 6: D  = Dirty (PTE)\nBit 7: PS = Large Page (PDE)\nBit 8: G  = Global (TLB survives CR3)" {
    shape: rectangle
    style.fill: "#BBDDEE"
    style.stroke: "#1565C0"
  }

  api2: "Public API" {
    shape: class
    style.fill: "#7AAFCF"
    style.stroke: "#1565C0"

    vmm_init: "vmm_init(): void  [builds page tables, calls pmm_mark_used×3]"
    vmm_enable_paging: "vmm_enable_paging(): void  [CR3←pd_phys; CR0.PG←1; CR0.WP←1]"
    vmm_map_page: "vmm_map_page(pd, virt, phys, flags): void  [+invlpg]"
    vmm_unmap_page: "vmm_unmap_page(pd, virt): void  [PTE←0; +invlpg]"
    tlb_flush_page: "tlb_flush_page(virt: uint32_t): void  [invlpg; ~20 cycles]"
    tlb_flush_all: "tlb_flush_all(): void  [CR3 reload; all non-global evicted]"
  }
}

# ── ADDRESS TRANSLATION FLOW ─────────────────────────────────────────────────

addr_xlate: "Two-Level Address Translation\n\nVirtual addr (32-bit):\n┌─bits[31:22]─┬─bits[21:12]─┬─bits[11:0]─┐\n│  Dir Index  │  Tbl Index  │   Offset   │\n│  (0–1023)   │  (0–1023)   │  (0–4095)  │\n└─────────────┴─────────────┴────────────┘\n\nCR3 → boot_page_directory[dir_idx]\n         → page_table[tbl_idx]\n                  → physical frame + offset\n\nTLB caches (virt_page → phys_frame):\n  L1 dTLB: ~64 entries  (1 cycle hit)\n  L2  TLB: ~1024 entries (5 cycle hit)\n  Miss → 2 memory reads → ~30–50 cycles" {
  shape: rectangle
  style.fill: "#E0EFF8"
  style.stroke: "#1565C0"
}

# ── HEAP ALLOCATOR ───────────────────────────────────────────────────────────

heap_module: "Kernel Heap Allocator (heap.c)" {
  style.fill: "#D5F5E3"
  style.stroke: "#1B5E20"
  style.border-radius: 8

  header: "heap_block_t Header (20 bytes each)\n\nOffset  0: magic  = 0xDEADBEEF  (corruption canary)\nOffset  4: size   = usable bytes after header\nOffset  8: free   = 1(free) / 0(allocated)\nOffset  9: _pad   = 3 bytes (alignment)\nOffset 12: *next  = next block in list\nOffset 16: *prev  = prev block in list\nOffset 20: [user data starts here]" {
    shape: rectangle
    style.fill: "#A8DFB8"
    style.stroke: "#1B5E20"
  }

  state: "Heap State\n\n• heap_start  = 0xD0000000 (HEAP_START)\n• heap_end    = current mapped boundary\n• HEAP_MAX    = 0xDFFFFFFF\n• HEAP_ALIGN  = 8 bytes (all allocs)\n• heap_head   = first heap_block_t*\n\nGrowth: heap_expand() maps 1 frame\n  pmm_alloc_frame() → vmm_map_page()\n  heap_end += PAGE_SIZE" {
    shape: rectangle
    style.fill: "#A8DFB8"
    style.stroke: "#1B5E20"
  }

  api3: "Public API" {
    shape: class
    style.fill: "#5CB87A"
    style.stroke: "#1B5E20"

    heap_init: "heap_init(): void  [maps first page, creates first free block]"
    kmalloc: "kmalloc(size: size_t): void*  [first-fit + split; NULL on OOM]"
    kfree: "kfree(ptr: void*): void  [mark free, coalesce next+prev]"
    kheap_used: "kheap_used(): size_t  [sum of allocated block sizes]"
  }

  algo: "kmalloc Algorithm\n\n1. Align size to 8 bytes\n2. Walk list: find first free block ≥ size\n3. Validate magic (halt if corrupt)\n4. Split if remainder ≥ hdr + 8 bytes\n5. Mark allocated; return ptr\n6. If no fit: heap_expand() then retry\n\nkfree Algorithm\n\n1. Recover header: ptr - sizeof(hdr)\n2. Validate magic; detect double-free\n3. Mark free=1\n4. Coalesce next (if free)\n5. Coalesce prev  (if free)" {
    shape: rectangle
    style.fill: "#C8EED4"
    style.stroke: "#1B5E20"
  }
}

# ── PAGE FAULT HANDLER ───────────────────────────────────────────────────────

pf_handler: "Page Fault Handler (vector 14)\nIn interrupt.c / exception_handler()\n\n1. Read CR2 IMMEDIATELY (faulting virt addr)\n2. Decode error_code:\n   Bit 0: P  (0=not-present, 1=protection)\n   Bit 1: W  (0=read, 1=write)\n   Bit 2: U  (0=kernel, 1=user)\n3. Print: CR2, error bits, EIP\n4. Classify:\n   CR2 < PAGE_SIZE   → null deref\n   U=1, CR2≥0xC0000000 → security viol.\n   W=1, present page → write-protect\n5. Halt: cli; hlt" {
  shape: rectangle
  style.fill: "#FADBD8"
  style.stroke: "#C0392B"
  style.border-radius: 8
}

# ── PHYSICAL MEMORY LAYOUT ANNOTATION ───────────────────────────────────────

phys_layout: |'md
  **Physical Address Space (typical 128MB)**

  | Range | Region | PMM State |
  |---|---|---|
  | `0x00000000–0x000FFFFF` | First 1MB (IVT, BIOS, VGA) | USED |
  | `0x00100000–kernel_end` | Kernel .text/.data/.bss | USED |
  | kernel\_end – bitmap\_end | frame\_bitmap (128KB) | USED |
  | bitmap\_end – page\_tables | 3 × 4KB page tables | USED |
  | page\_tables – top | **Free RAM** (allocatable) | FREE |
  | `0xFFFC0000–0xFFFFFFFF` | BIOS ROM / Reserved | USED |
'| {
  near: bottom-center
  style.fill: "#FFFFF0"
  style.stroke: "#888800"
}

# ── VIRTUAL ADDRESS SPACE LAYOUT ─────────────────────────────────────────────

virt_layout: |'md
  **Virtual Address Space After Paging Enabled**

  | Virtual Range | Maps To | Flags |
  |---|---|---|
  | `0x00000000–0x003FFFFF` | Phys `0x0–0x3FFFFF` | P\|W (identity) |
  | `0x00400000–0xBFFFFFFF` | (unmapped) | — |
  | `0xC0000000–0xC03FFFFF` | Phys `0x0–0x3FFFFF` | P\|W (kernel) |
  | `0xD0000000–0xDFFFFFFF` | Heap (on-demand) | P\|W |
  | `0xE0000000–0xFFFFFFFF` | (unmapped) | — |
'| {
  near: bottom-center
  style.fill: "#F0FFFF"
  style.stroke: "#006688"
}

# ── CONNECTIONS ───────────────────────────────────────────────────────────────

pmm_module -> vmm_module: "vmm_init() calls\npmm_mark_used(×3)\nfor page tables" {
  style.stroke: "#7B2D8B"
  style.stroke-dash: 3
}

vmm_module.api2 -> pmm_module.api: "vmm_map_page() calls\npmm_alloc_frame()\nfor new page tables" {
  style.stroke: "#1565C0"
  style.stroke-dash: 3
}

heap_module.api3 -> vmm_module.api2: "heap_expand() calls\nvmm_map_page(boot_pd,\n  heap_end, phys, P|W)" {
  style.stroke: "#1B5E20"
  style.stroke-dash: 3
}

heap_module.api3 -> pmm_module.api: "heap_expand() calls\npmm_alloc_frame()\nfor backing frame" {
  style.stroke: "#1B5E20"
  style.stroke-dash: 3
}

vmm_module -> pf_handler: "IDT vector 14\nexception_handler()\ndispatches here" {
  style.stroke: "#C0392B"
}

vmm_module.pd -> vmm_module.ipt: "PD[0] = MAKE_PDE(\n  identity_page_table,\n  P|W)" {
  style.stroke: "#1565C0"
}

vmm_module.pd -> vmm_module.kpt: "PD[768] = MAKE_PDE(\n  kernel_page_table,\n  P|W)" {
  style.stroke: "#1565C0"
}

vmm_module.api2 -> addr_xlate: "enables via\nCR3 + CR0.PG" {
  style.stroke: "#1565C0"
  style.stroke-dash: 5
}

vmm_module.api2 -> vmm_module.flags: "flag constants\nused in all\nPTE/PDE writes"

heap_module.state -> heap_module.header: "linked list:\nheap_head →\nblock₀ → block₁ → …"

heap_module.algo -> heap_module.header: "first-fit walk;\nsplit/coalesce\nvia next/prev ptrs"