vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Context Switch Assembly: ESP Pivot Sequence
  `context_switch_asm(old_esp_ptr, new_esp, new_cr3)` â€” called with IF=0 from `sched_schedule()`
| {near: top-center}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# BEFORE THE PIVOT â€” current process stack
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
before_stack: "Current Process Kernel Stack (BEFORE pivot)" {
  style.fill: "#E8F4FD"
  style.stroke: "#2196F3"
  style.stroke-width: 2

  ret_addr: "return addr to sched_schedule()\n[ESP+0]  â† ESP points here" {
    style.fill: "#FF9800"
    style.font-color: "#FFFFFF"
    style.bold: true
  }
  gs_field: "GS = 0x10\n[ESP+4]" {style.fill: "#BBDEFB"}
  fs_field: "FS = 0x10\n[ESP+8]" {style.fill: "#BBDEFB"}
  es_field: "ES = 0x10\n[ESP+12]" {style.fill: "#BBDEFB"}
  ds_field: "DS = 0x10\n[ESP+16]" {style.fill: "#BBDEFB"}
  edi_f: "EDI\n[ESP+20]" {style.fill: "#C8E6C9"}
  esi_f: "ESI\n[ESP+24]" {style.fill: "#C8E6C9"}
  ebp_f: "EBP\n[ESP+28]" {style.fill: "#C8E6C9"}
  esp_p: "ESP_pusha (ignored)\n[ESP+32]" {style.fill: "#F5F5F5"; style.stroke-dash: 4}
  ebx_f: "EBX\n[ESP+36]" {style.fill: "#C8E6C9"}
  edx_f: "EDX\n[ESP+40]" {style.fill: "#C8E6C9"}
  ecx_f: "ECX\n[ESP+44]" {style.fill: "#C8E6C9"}
  eax_f: "EAX\n[ESP+48]" {style.fill: "#C8E6C9"}
  vec_f: "vector (IRQ#)\n[ESP+52]" {style.fill: "#FFF9C4"}
  err_f: "error_code = 0\n[ESP+56]" {style.fill: "#FFF9C4"}
  eip_f: "EIP (resume addr)\n[ESP+60]" {style.fill: "#E1BEE7"}
  cs_f:  "CS = 0x08\n[ESP+64]" {style.fill: "#E1BEE7"}
  efl_f: "EFLAGS (IF=1)\n[ESP+68]" {style.fill: "#E1BEE7"}
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# INSTRUCTION SEQUENCE (numbered steps)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
instructions: "context_switch_asm â€” Instruction Sequence" {
  style.fill: "#FFF8E1"
  style.stroke: "#F57F17"
  style.stroke-width: 2

  step1: "â‘  Load args FIRST (before ESP changes)\nmov eax, [esp+4]  ; EAX = old_esp_ptr\nmov ecx, [esp+8]  ; ECX = new_esp\nmov edx, [esp+12] ; EDX = new_cr3" {
    style.fill: "#FFF3E0"
    style.font: mono
    style.stroke: "#F57F17"
  }

  step2: "â‘¡ Save current process ESP\nmov [eax], esp\n; *old_esp_ptr = current ESP\n; Records where saved frame lives" {
    style.fill: "#FFF3E0"
    style.font: mono
    style.stroke: "#F57F17"
  }

  step3: "â‘¢ PIVOT â€” switch kernel stacks\nmov esp, ecx\n; ESP now points into NEXT process stack\n; â† THE atomic boundary" {
    style.fill: "#FFCCBC"
    style.font: mono
    style.stroke: "#E64A19"
    style.stroke-width: 3
    style.bold: true
  }

  step4: "â‘£ Conditional CR3 reload\nmov eax, cr3\ncmp eax, edx\nje  .same_cr3\nmov cr3, edx   ; flush non-global TLB\n.same_cr3:" {
    style.fill: "#FFF3E0"
    style.font: mono
    style.stroke: "#F57F17"
  }

  step5: "â‘¤ Return to next process continuation\nret\n; pops return addr from NEXT process stack\n; â†’ irq_return_trampoline (new process)\n; â†’ sched_schedule+N (old process resuming)" {
    style.fill: "#DCEDC8"
    style.font: mono
    style.stroke: "#558B2F"
    style.stroke-width: 2
  }

  step1 -> step2: "sequential"
  step2 -> step3: "sequential"
  step3 -> step4: "sequential"
  step4 -> step5: "sequential"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# AFTER THE PIVOT â€” next process stack
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
after_stack: "Next Process Kernel Stack (AFTER pivot)" {
  style.fill: "#F3E5F5"
  style.stroke: "#9C27B0"
  style.stroke-width: 2

  tramp_addr: "irq_return_trampoline addr\n[ESP+0]  â† ESP points here after pivot\nret pops this â†’ jumps to trampoline" {
    style.fill: "#FF9800"
    style.font-color: "#FFFFFF"
    style.bold: true
  }
  gs2: "GS = 0x10\n[ESP+4]\ntrampoline: pop eax; mov gs, ax" {style.fill: "#E1BEE7"}
  fs2: "FS = 0x10\n[ESP+8]" {style.fill: "#E1BEE7"}
  es2: "ES = 0x10\n[ESP+12]" {style.fill: "#E1BEE7"}
  ds2: "DS = 0x10\n[ESP+16]\ntrampoline: pop eax; mov ds, ax (last)" {style.fill: "#E1BEE7"}
  pusha_area: "EDI..EAX = 0\n[ESP+20..52]\npopa restores these (esp_pusha ignored)" {style.fill: "#C8E6C9"}
  vec2: "vector = 0\n[ESP+56]\nadd esp,8 discards these two" {style.fill: "#FFF9C4"}
  err2: "error_code = 0\n[ESP+60]" {style.fill: "#FFF9C4"}
  eip2: "EIP = entry_point\n[ESP+64]\niret jumps here" {
    style.fill: "#CE93D8"
    style.bold: true
  }
  cs2:  "CS = 0x08 (ring-0) or 0x1B (ring-3)\n[ESP+68]\niret loads CS" {
    style.fill: "#CE93D8"
    style.bold: true
  }
  efl2: "EFLAGS = 0x00000202\n[ESP+72]  IF=1 MANDATORY\niret restores EFLAGS" {
    style.fill: "#CE93D8"
    style.bold: true
  }
  ring3_note: "RING-3 ONLY (pushed above eflags):\nuser_esp = 0x00C00000\nuser_ss  = 0x23\niret pops these extra 2 words\nand switches back to user stack" {
    style.fill: "#F8BBD9"
    style.stroke-dash: 4
  }
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# irq_return_trampoline execution
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
trampoline: "irq_return_trampoline â€” Exit Sequence" {
  style.fill: "#E8F5E9"
  style.stroke: "#2E7D32"
  style.stroke-width: 2

  t1: "pop eax; mov gs, ax   ; restore GS" {style.fill: "#C8E6C9"; style.font: mono}
  t2: "pop eax; mov fs, ax   ; restore FS" {style.fill: "#C8E6C9"; style.font: mono}
  t3: "pop eax; mov es, ax   ; restore ES" {style.fill: "#C8E6C9"; style.font: mono}
  t4: "pop eax; mov ds, ax   ; restore DS" {style.fill: "#C8E6C9"; style.font: mono}
  t5: "popa                   ; restore EDI,ESI,EBP,(skip ESP),EBX,EDX,ECX,EAX" {style.fill: "#A5D6A7"; style.font: mono}
  t6: "add esp, 8             ; discard vector + error_code" {style.fill: "#A5D6A7"; style.font: mono}
  t7: "iret                   ; restore EIP, CS, EFLAGS\n                       ; [+ user_esp, user_ss if ring-3]\n                       ; PROCESS NOW RUNNING" {
    style.fill: "#4CAF50"
    style.font-color: "#FFFFFF"
    style.font: mono
    style.bold: true
    style.stroke: "#2E7D32"
    style.stroke-width: 3
  }

  t1 -> t2; t2 -> t3; t3 -> t4; t4 -> t5; t5 -> t6; t6 -> t7
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# PCB fields updated
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pcb_old: "Old PCB (process_table[i])\nsaved_esp â† recorded in step â‘¡" {
  style.fill: "#ECEFF1"
  style.stroke: "#607D8B"
  saved_esp_field: "saved_esp = current ESP value\n(points to return addr in step â‘ )" {
    style.fill: "#B0BEC5"
  }
}

pcb_new: "New PCB (process_table[j])\nnext->saved_esp â†’ loaded in step â‘¢" {
  style.fill: "#ECEFF1"
  style.stroke: "#607D8B"
  new_esp_field: "saved_esp was set by previous\npreemption (or fake frame init)" {
    style.fill: "#B0BEC5"
  }
}

tss_update: "TSS.ESP0 Update\n(MUST occur BEFORE step â‘¢)" {
  style.fill: "#FCE4EC"
  style.stroke: "#C62828"
  style.stroke-width: 2
  detail: "tss_set_kernel_stack(next->kernel_stack_top)\nkernal_tss.esp0 = next->kernel_stack_top\nCPU reads esp0 on next ring-3 interrupt\nâ†’ uses correct kernel stack for new process" {
    style.fill: "#FFCDD2"
    style.font: mono
  }
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CONNECTIONS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Before â†’ instructions
before_stack -> instructions.step1: "irq_common_stub already\npushed full frame here" {
  style.stroke: "#2196F3"
  style.stroke-width: 2
}

# Step 2 saves to PCB
instructions.step2 -> pcb_old.saved_esp_field: "stores ESP into\nold_esp_ptr" {
  style.stroke: "#F57F17"
  style.stroke-width: 2
}

# TSS must happen before pivot
tss_update -> instructions.step3: "MUST precede pivot\ncalled by sched_schedule()\nbefore context_switch_asm()" {
  style.stroke: "#C62828"
  style.stroke-width: 2
  style.stroke-dash: 3
}

# PCB new provides the new_esp argument
pcb_new.new_esp_field -> instructions.step1: "new_esp argument\n= next->saved_esp" {
  style.stroke: "#9C27B0"
  style.stroke-width: 2
}

# Pivot transitions to next stack
instructions.step3 -> after_stack: "ESP now points\ninto next process stack" {
  style.stroke: "#E64A19"
  style.stroke-width: 3
  style.bold: true
}

# ret goes to trampoline
instructions.step5 -> trampoline: "ret pops irq_return_trampoline\nfrom next process stack" {
  style.stroke: "#558B2F"
  style.stroke-width: 2
  style.animated: true
}

# trampoline iret activates process
trampoline.t7 -> after_stack.eip2: "iret jumps to\nprocess entry point" {
  style.stroke: "#2E7D32"
  style.stroke-width: 2
  style.stroke-dash: 5
}

# Legend
legend: |md
  **Color Legend**
  - ðŸŸ  Orange: Stack pointer (ESP) locations
  - ðŸ”µ Blue: Current process saved frame
  - ðŸŸ£ Purple: Next process saved frame / iret fields
  - ðŸŸ¢ Green: irq_return_trampoline exit sequence
  - ðŸ”´ Red: TSS update (ring-3 safety critical)
  - ðŸŸ¡ Yellow: stub-pushed vector/error_code fields
| {near: bottom-right}

timing_note: |md
  **Critical Ordering (all with IF=0):**
  1. `tss_set_kernel_stack(next->kernel_stack_top)` â€” before switch
  2. `current_process = next` â€” before switch  
  3. `context_switch_asm(...)` â€” performs pivot
  4. `current_process = old` â€” after switch returns
  
  **The pivot is NOT atomic** in the OS sense â€” but IF=0
  guarantees no interrupt fires between steps â‘¡ and â‘¢.
| {near: bottom-left}