vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
scheduler_seq: {
  shape: sequence_diagram
  # Participants
  hw: "PIT Hardware\n(IRQ0)"
  pic: "8259A PIC\n(Master)"
  cpu: "x86 CPU\n(Ring 0)"
  isr: "isr_common_stub\n(Vector 32)"
  dispatch: "irq_dispatch\n/ timer_handler"
  sched: "scheduler_tick()"
  ctx: "context_switch()\ncontext_switch_asm"
  tss_reg: "TSS\nkernal_tss.esp0"
  cr3_reg: "CR3 Register"
  proc_a: "process_a\n(pid=1 RUNNING)"
  proc_b: "process_b\n(pid=2 READY)"
  # Step 1 — process_a is executing in user mode
  proc_a."① process_a executing (Ring 3, tick_counter=N)"
  # Step 2 — PIT fires IRQ0
  hw -> pic: "PIT channel-0 counter→0\nAssert IRQ0 line"
  pic -> cpu: "INTR pin asserted\nvector=32 (after remap)"
  # Step 3 — CPU privilege transition, saves process_a regs
  cpu -> isr: "Ring 3→Ring 0 transition\nRead TSS.ESP0 → kernel stack\nPush SS_user, ESP_user, EFLAGS, CS_user, EIP_user" {
    style.stroke: "#C62828"
    style.bold: true
  }
  isr -> isr: "③ pusha (EAX…EDI)\npush DS,ES,FS,GS\npush int_no=32, err_code=0\npush esp → interrupt_frame_t*"
  # Step 4 — dispatch to timer handler and scheduler
  isr -> dispatch: "call interrupt_dispatch(frame)"
  dispatch -> dispatch: "tick_counter++\nproc_a.total_ticks++"
  dispatch -> sched: "scheduler_tick(frame)"
  # Step 5 — scheduler selects next READY process
  sched -> sched: "④ next = current_process->next\n   = process_b (state=READY)\ncurrent_process->state = PROCESS_READY\nnext->state = PROCESS_RUNNING"
  # Step 6 — context_switch C wrapper: TSS update first
  sched -> ctx: "context_switch(proc_a, proc_b)"
  ctx -> tss_reg: "⑤ tss_set_kernel_stack(\n   proc_b->kernel_stack_top)" {
    style.stroke: "#6A1B9A"
    style.bold: true
  }
  tss_reg -> tss_reg: "kernel_tss.esp0 =\n0xC0418000\n(proc_b kernel stack top)"
  # Step 7 — CR3 switch (different page directories)
  ctx -> cr3_reg: "⑥ mov cr3, proc_b->page_directory\n   (phys addr: 0x00204000)" {
    style.stroke: "#1565C0"
    style.bold: true
  }
  cr3_reg -> cr3_reg: "Full TLB flush\n(address space switched)"
  # Step 8 — current_process updated before stack swap
  ctx -> sched: "current_process = proc_b"
  # Step 9 — assembly stack swap
  ctx -> ctx: "⑦ context_switch_asm(\n   &proc_a->context,\n   &proc_b->context)" {
    style.stroke: "#E65100"
    style.bold: true
  }
  ctx -> ctx: "SAVE proc_a stack:\n  push ebx,esi,edi,ebp\n  pushfd\n  proc_a.context.esp = ESP\n  ← proc_a SUSPENDED HERE"
  ctx -> ctx: "LOAD proc_b stack:\n  mov ESP, proc_b.context.esp\n  popfd  (IF=1 → interrupts re-enabled)\n  pop ebp,edi,esi,ebx\n  ret    → proc_b's saved EIP\n  ← proc_b RESUMED HERE"
  # Step 10 — EOI and return path
  ctx -> dispatch: "(proc_b context now active)\nreturn from context_switch_asm"
  dispatch -> pic: "pic_send_eoi(0)\nwrite 0x20 → port 0x20"
  pic -> pic: "Master ISR bit 0 cleared\nIRQ0 unblocked for next tick"
  # Step 11 — iretd restores process_b user regs
  dispatch -> isr: "return through irq_dispatch"
  isr -> isr: "⑧ pop gs,fs,es,ds\n   popa (restore EAX…EDI)\n   add esp, 8\n   iretd"
  isr -> proc_b: "⑨ Pop EIP_b, CS_b=0x1B, EFLAGS_b\n   Pop ESP_b (user stack), SS_b=0x23\n   Ring 0→Ring 3 transition\n   process_b resumes user execution" {
    style.stroke: "#2E7D32"
    style.bold: true
  }
  proc_b."process_b executing (Ring 3)\ntick_counter=N+1\nproc_b.total_ticks++"
}
# ─── Circular Run Queue State ──────────────────────────────────────────────────
runqueue: "Run Queue State (Circular Linked List)" {
  style.fill: "#1A1A2E"
  style.stroke: "#90CAF9"
  style.border-radius: 8
  style.font-color: white
  style.bold: true
  before: "BEFORE tick N" {
    style.fill: "#0D1B2A"
    style.stroke: "#546E7A"
    style.border-radius: 6
    cur_ptr_a: "current_process ▶" {
      style.fill: "#B71C1C"
      style.font-color: white
      style.border-radius: 4
    }
    pa: "process_a\npid=1  RUNNING\ntotal_ticks=42\nkstack_top=0xC0410000\npd_phys=0x00200000" {
      style.fill: "#6A1B9A"
      style.font-color: white
      style.border-radius: 4
    }
    pb: "process_b\npid=2  READY\ntotal_ticks=41\nkstack_top=0xC0418000\npd_phys=0x00204000" {
      style.fill: "#1565C0"
      style.font-color: white
      style.border-radius: 4
    }
    pc: "process_c\npid=3  READY\ntotal_ticks=41\nkstack_top=0xC0420000\npd_phys=0x00208000" {
      style.fill: "#1565C0"
      style.font-color: white
      style.border-radius: 4
    }
    idle: "idle\npid=4  READY\ntotal_ticks=3\nkstack_top=0xC0428000\npd_phys=0x00200000" {
      style.fill: "#37474F"
      style.font-color: white
      style.border-radius: 4
    }
    cur_ptr_a -> pa: "points to" { style.stroke: "#EF9A9A" }
    pa -> pb: "→ next" { style.stroke: "#CE93D8" }
    pb -> pc: "→ next" { style.stroke: "#90CAF9" }
    pc -> idle: "→ next" { style.stroke: "#90CAF9" }
    idle -> pa: "→ next (wrap)" { style.stroke: "#CE93D8"; style.stroke-dash: 4 }
  }
  after: "AFTER tick N (process_b selected)" {
    style.fill: "#0D1B2A"
    style.stroke: "#546E7A"
    style.border-radius: 6
    cur_ptr_b: "current_process ▶" {
      style.fill: "#B71C1C"
      style.font-color: white
      style.border-radius: 4
    }
    pa2: "process_a\npid=1  READY\ntotal_ticks=43\ncontext.esp saved\n← SUSPENDED" {
      style.fill: "#37474F"
      style.font-color: white
      style.border-radius: 4
    }
    pb2: "process_b\npid=2  RUNNING\ntotal_ticks=42\nTSS.ESP0 updated\nCR3 loaded" {
      style.fill: "#6A1B9A"
      style.font-color: white
      style.border-radius: 4
    }
    pc2: "process_c\npid=3  READY\ntotal_ticks=41" {
      style.fill: "#1565C0"
      style.font-color: white
      style.border-radius: 4
    }
    idle2: "idle\npid=4  READY\ntotal_ticks=3" {
      style.fill: "#37474F"
      style.font-color: white
      style.border-radius: 4
    }
    cur_ptr_b -> pb2: "points to" { style.stroke: "#EF9A9A" }
    pa2 -> pb2: "→ next" { style.stroke: "#CE93D8" }
    pb2 -> pc2: "→ next" { style.stroke: "#90CAF9" }
    pc2 -> idle2: "→ next" { style.stroke: "#90CAF9" }
    idle2 -> pa2: "→ next (wrap)" { style.stroke: "#CE93D8"; style.stroke-dash: 4 }
  }
}
# ─── Kernel Stack Layout During Switch ────────────────────────────────────────
stacks: "Kernel Stack Layout During context_switch_asm" {
  style.fill: "#1A1A2E"
  style.stroke: "#90CAF9"
  style.border-radius: 8
  style.font-color: white
  style.bold: true
  proc_a_stack: "process_a Kernel Stack\n(SUSPENDED)" {
    style.fill: "#0D1B2A"
    style.stroke: "#6A1B9A"
    style.border-radius: 6
    a_esp_saved: "← proc_a.context.esp" {
      style.fill: "#B71C1C"
      style.font-color: white
      style.border-radius: 3
    }
    a_eflags: "[ESP+0 ]  EFLAGS = 0x00000202\n           (IF=1, bit1=1)" {
      style.fill: "#4A148C"
      style.font-color: white
      style.border-radius: 3
    }
    a_ebp: "[ESP+4 ]  EBP" {
      style.fill: "#311B92"
      style.font-color: white
      style.border-radius: 3
    }
    a_edi: "[ESP+8 ]  EDI" {
      style.fill: "#311B92"
      style.font-color: white
      style.border-radius: 3
    }
    a_esi: "[ESP+12]  ESI" {
      style.fill: "#311B92"
      style.font-color: white
      style.border-radius: 3
    }
    a_ebx: "[ESP+16]  EBX" {
      style.fill: "#311B92"
      style.font-color: white
      style.border-radius: 3
    }
    a_eip: "[ESP+20]  return EIP\n           (in context_switch C wrapper)" {
      style.fill: "#1A237E"
      style.font-color: white
      style.border-radius: 3
    }
    a_frame: "[ESP+24…] interrupt_frame_t\n           (EAX…EDI, segs, int_no,\n            err_code, EIP_user,\n            CS_user, EFLAGS_user,\n            ESP_user, SS_user)" {
      style.fill: "#0D47A1"
      style.font-color: white
      style.border-radius: 3
    }
    a_esp_saved -> a_eflags
    a_eflags -> a_ebp
    a_ebp -> a_edi
    a_edi -> a_esi
    a_esi -> a_ebx
    a_ebx -> a_eip
    a_eip -> a_frame
  }
  proc_b_stack: "process_b Kernel Stack\n(RESUMED)" {
    style.fill: "#0D1B2A"
    style.stroke: "#1565C0"
    style.border-radius: 6
    b_esp_loaded: "← proc_b.context.esp\n   (loaded into CPU ESP)" {
      style.fill: "#B71C1C"
      style.font-color: white
      style.border-radius: 3
    }
    b_eflags: "[ESP+0 ]  EFLAGS = 0x00000202\n           popfd → IF=1 re-enabled" {
      style.fill: "#4A148C"
      style.font-color: white
      style.border-radius: 3
    }
    b_ebp: "[ESP+4 ]  EBP  (restored)" {
      style.fill: "#311B92"
      style.font-color: white
      style.border-radius: 3
    }
    b_edi: "[ESP+8 ]  EDI  (restored)" {
      style.fill: "#311B92"
      style.font-color: white
      style.border-radius: 3
    }
    b_esi: "[ESP+12]  ESI  (restored)" {
      style.fill: "#311B92"
      style.font-color: white
      style.border-radius: 3
    }
    b_ebx: "[ESP+16]  EBX  (restored)" {
      style.fill: "#311B92"
      style.font-color: white
      style.border-radius: 3
    }
    b_eip: "[ESP+20]  EIP → ret jumps here\n           (back in context_switch C\n            wrapper, or entry_fn if\n            first scheduling)" {
      style.fill: "#1A237E"
      style.font-color: white
      style.border-radius: 3
    }
    b_frame: "[ESP+24…] interrupt_frame_t\n           (process_b user regs:\n            EIP_b, CS=0x1B,\n            EFLAGS_b, ESP_b,\n            SS=0x23)" {
      style.fill: "#0D47A1"
      style.font-color: white
      style.border-radius: 3
    }
    b_esp_loaded -> b_eflags
    b_eflags -> b_ebp
    b_ebp -> b_edi
    b_edi -> b_esi
    b_esi -> b_ebx
    b_ebx -> b_eip
    b_eip -> b_frame
  }
}
# ─── Tick Counter / Accounting ────────────────────────────────────────────────
accounting: "Scheduler Accounting (100 Hz, 3 processes + idle)" {
  style.fill: "#1A1A2E"
  style.stroke: "#80CBC4"
  style.border-radius: 8
  style.font-color: white
  style.bold: true
  table: ||md
  | Metric              | process_a | process_b | process_c | idle  |
  |---------------------|-----------|-----------|-----------|-------|
  | PID                 | 1         | 2         | 3         | 4     |
  | total_ticks (after) | 43        | 42        | 41        | 3     |
  | CPU share (%)       | ~33%      | ~33%      | ~33%      | ~3%   |
  | kernel_stack_top    | 0xC0410000| 0xC0418000| 0xC0420000|0xC0428000|
  | pd_phys             | 0x200000  | 0x204000  | 0x208000  |0x200000|
  | TSS.ESP0 active for | —         | ✓ NOW     | —         | —     |
  | CR3 loaded          | —         | ✓ NOW     | —         | —     |
  ||
}