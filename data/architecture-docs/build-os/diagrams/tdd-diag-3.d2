vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: {
  shape: text
  label: |md
    # GDT Entry — 64-bit Segment Descriptor (8 Bytes)
    Access byte bit-field and concrete hex values for Global Descriptor Table
  |
  near: top-center
}

# ── Byte strip (Memory Layout) ──────────────────────────────────────────────
bytes: {
  label: "GDT Entry Byte Layout (sizeof = 8 bytes)"
  style: {
    fill: "#1a1a2e"
    stroke: "#444466"
    border-radius: 6
    font-color: white
    bold: true
  }

  b01: "Bytes 0–1\nlimit[15:0]" {
    style: { fill: "#7B2D8B"; font-color: white; border-radius: 4; bold: true }
  }
  b23: "Bytes 2–3\nbase[15:0]" {
    style: { fill: "#1565C0"; font-color: white; border-radius: 4; bold: true }
  }
  b4: "Byte 4\nbase[23:16]" {
    style: { fill: "#1565C0"; font-color: white; border-radius: 4; bold: true }
  }
  b5: "Byte 5\nACCESS" {
    style: { fill: "#B71C1C"; font-color: white; border-radius: 4; bold: true }
  }
  b6: "Byte 6\nFLAGS+limit[19:16]" {
    style: { fill: "#1B5E20"; font-color: white; border-radius: 4; bold: true }
  }
  b7: "Byte 7\nbase[31:24]" {
    style: { fill: "#1565C0"; font-color: white; border-radius: 4; bold: true }
  }

  b01 -> b23 -> b4 -> b5 -> b6 -> b7: {
    style: { stroke: "#666688"; stroke-width: 2 }
  }
}

# ── Byte 5 — Access byte bit breakdown ────────────────────────────────────────
access_detail: {
  label: "Byte 5 — Access Byte Bit-Field"
  style: {
    fill: "#1a1a2e"
    stroke: "#B71C1C"
    border-radius: 6
    font-color: white
    bold: true
  }

  bit7: "Bit 7 — P (Present)\n1 = valid descriptor" {
    style: { fill: "#B71C1C"; font-color: white; border-radius: 4 }
  }
  bit65: "Bits 6:5 — DPL (Privilege)\n00=Ring 0, 11=Ring 3" {
    style: { fill: "#E65100"; font-color: white; border-radius: 4 }
  }
  bit4: "Bit 4 — S (Descriptor Type)\n1=Code/Data, 0=System" {
    style: { fill: "#F57F17"; font-color: "#111"; border-radius: 4 }
  }
  bit3: "Bit 3 — E (Executable)\n1=Code, 0=Data" {
    style: { fill: "#558B2F"; font-color: white; border-radius: 4 }
  }
  bit2: "Bit 2 — DC (Direction)\n0=Grows up / Non-conf" {
    style: { fill: "#00695C"; font-color: white; border-radius: 4 }
  }
  bit1: "Bit 1 — RW (Read/Write)\n1=Readable/Writable" {
    style: { fill: "#1565C0"; font-color: white; border-radius: 4 }
  }
  bit0: "Bit 0 — A (Accessed)\nInitialise to 0" {
    style: { fill: "#4527A0"; font-color: white; border-radius: 4 }
  }
}

# ── Byte 6 — Flags nibble breakdown ───────────────────────────────────────────
flags_detail: {
  label: "Byte 6 — Flags Nibble (7:4) + limit (3:0)"
  style: {
    fill: "#1a1a2e"
    stroke: "#1B5E20"
    border-radius: 6
    font-color: white
    bold: true
  }

  g: "Bit 7 — G (Granularity)\n1=4KB units" {
    style: { fill: "#1B5E20"; font-color: white; border-radius: 4 }
  }
  db: "Bit 6 — D/B (Size)\n1=32-bit segment" {
    style: { fill: "#33691E"; font-color: white; border-radius: 4 }
  }
  l: "Bit 5 — L (64-bit)\n0 for 32-bit segments" {
    style: { fill: "#558B2F"; font-color: white; border-radius: 4 }
  }
  avl: "Bit 4 — AVL\nAvailable for OS" {
    style: { fill: "#689F38"; font-color: "#111"; border-radius: 4 }
  }
  lim_hi: "Bits 3:0 — limit[19:16]\nHigh nibble of limit" {
    style: { fill: "#7B2D8B"; font-color: white; border-radius: 4 }
  }

  g -> db -> l -> avl -> lim_hi: { style.stroke-width: 2 }
}

# ── Context and Notes ─────────────────────────────────────────────────────────
flat_note: {
  label: |'md
    **Flat Memory Model:** All code/data segments use Base = 0x00000000 and Limit = 0xFFFFFFFF
    so that logical address = linear address. Isolation is enforced via paging (CR3),
    not via segment base/limit.
  '|
  style: {
    fill: "#0d1b2a"
    font-color: "#aabbcc"
    stroke: "#334455"
    border-radius: 6
  }
}

value_table: {
  label: "Concrete Values — All Five GDT Entries"
  style: {
    fill: "#0d1b2a"
    stroke: "#556677"
    border-radius: 6
    font-color: white
    bold: true
  }

  null_entry: "Index 0 — Null Descriptor (0x00)\n00 00 00 00 00 00 00 00" {
    style: { fill: "#37474F"; font-color: "#ccc" }
  }
  kcode: "Index 1 — Kernel Code (0x08)\nAccess: 0x9A | Flags: 0xCF" {
    style: { fill: "#7B2D8B"; font-color: white }
  }
  kdata: "Index 2 — Kernel Data (0x10)\nAccess: 0x92 | Flags: 0xCF" {
    style: { fill: "#1565C0"; font-color: white }
  }
  ucode: "Index 3 — User Code (0x1B)\nAccess: 0xFA | Flags: 0xCF" {
    style: { fill: "#B71C1C"; font-color: white }
  }
  udata: "Index 4 — User Data (0x23)\nAccess: 0xF2 | Flags: 0xCF" {
    style: { fill: "#E65100"; font-color: white }
  }

  null_entry -> kcode -> kdata -> ucode -> udata: {
    style: { stroke: "#556677"; stroke-width: 2 }
  }
}

selector_note: {
  label: |'md
    **Segment Selector = (GDT index << 3) | TI | RPL**
    - TI=0 (GDT table)
    - RPL=0 (Kernel), RPL=3 (User)
    - 0x08 (K-Code), 0x10 (K-Data), 0x1B (U-Code), 0x23 (U-Data)
  '|
  style: {
    fill: "#0d1b2a"
    font-color: "#aabbcc"
    stroke: "#334455"
    border-radius: 6
  }
}

gdtr_box: {
  label: "GDTR Pseudo-Descriptor (6 bytes, loaded via LGDT)"
  style: {
    fill: "#263238"
    stroke: "#90A4AE"
    border-radius: 6
    font-color: white
    bold: true
  }

  limit_field: "Bytes 0-1: Limit\n(5 * 8) - 1 = 39 (0x0027)" {
    style: { fill: "#37474F"; font-color: "#cfd8dc" }
  }
  base_field: "Bytes 2-5: Base\nLinear address of gdt[0]" {
    style: { fill: "#37474F"; font-color: "#cfd8dc" }
  }

  limit_field -> base_field: { style.stroke-width: 2 }
}

# ── Cross-Section Routing ────────────────────────────────────────────────────
bytes.b5 -> access_detail: "bit-field detail" {
  style: { stroke-dash: 4; stroke: "#B71C1C"; font-color: "#B71C1C"; bold: true }
}
bytes.b6 -> flags_detail: "bit-field detail" {
  style: { stroke-dash: 4; stroke: "#1B5E20"; font-color: "#1B5E20"; bold: true }
}
gdtr_box -> bytes: "LGDT target" {
  style: { stroke-dash: 4; stroke: "#90A4AE" }
}
value_table -> selector_note: "selector logic" {
  style: { stroke-dash: 3; stroke: "#445566" }
}