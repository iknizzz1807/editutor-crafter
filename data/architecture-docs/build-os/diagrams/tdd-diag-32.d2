vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
syscall_seq: {
  shape: sequence_diagram
  user_proc: "User Process\n(ring 3, CPL=3)"
  cpu: "CPU / MMU\n(hardware)"
  isr128: "isr_128\n(ISR_NOERR stub)"
  common: "isr_common_stub\n(assembly)"
  dispatch: "interrupt_dispatch()\n(interrupt.c)"
  syscall_d: "syscall_dispatch()\n(syscall.c)"
  sys_w: "sys_write()\n(syscall.c)"
  vga_ser: "vga_putchar()\nserial_putchar()\n(drivers)"
  # ── Phase 1: User invokes INT 0x80 ─────────────────────────────────────
  user_proc -> cpu: |md
    **mov eax, 4** *(SYS_WRITE)*
    **mov ebx, 1** *(fd = stdout)*
    **mov ecx, buf** *(user buffer ptr)*
    **mov edx, len** *(byte count)*
    **int 0x80**
  |
  # ── Phase 2: CPU hardware trap dispatch ─────────────────────────────────
  cpu -> cpu: |md
    **1. Read IDT[128]**
    selector=0x08, flags=0xEF
    DPL=3 → user may invoke ✓
    Type=trap gate → IF **not** cleared
    CPL=3 → DPL=3 → privilege change triggered
  |
  cpu -> cpu: |md
    **2. Privilege-change stack switch**
    Read TSS.SS0=0x10, TSS.ESP0=kernel_stack_top
    Switch ESP → kernel stack
  |
  cpu -> cpu: |md
    **3. Push onto kernel stack (high→low)**
    [+20] user_ss   = 0x23
    [+16] user_esp  = saved ring-3 ESP
    [+12] eflags    = user EFLAGS (IF=1 preserved — trap gate)
    [+8]  cs        = 0x1B  *(ring-3 code)*
    [+4]  eip       = next user instruction
    [+0]  ← ESP now here
  |
  cpu -> cpu: |md
    **4. Load kernel code selector**
    CS ← 0x08 (ring-0 code)
    EIP ← isr_128 handler address
    CPL is now 0
  |
  # ── Phase 3: ISR stub ───────────────────────────────────────────────────
  cpu -> isr128: "fetch & execute isr_128"
  isr128 -> isr128: |md
    **push dword 0**   ← fake error code
    **push dword 128** ← interrupt number
    **jmp isr_common_stub**
  |
  isr128 -> common: "jmp isr_common_stub"
  # ── Phase 4: Common stub saves state ───────────────────────────────────
  common -> common: |md
    **pusha**
    push gs / fs / es / ds
    **mov ax, 0x10** (kernel data)
    mov ds,ax; mov es,ax; mov fs,ax; mov gs,ax
    **push esp** ← pointer to interrupt_frame_t
  |
  # ── Stack layout note (Sequence Diagram Note) ──────────────────────────
  common.stack_note: |md
    **interrupt_frame_t offsets (from frame ptr):**
    +0  gs    +4  fs    +8  es   +12 ds
    +16 edi  +20 esi   +24 ebp  +28 esp_dummy
    +32 ebx  +36 edx   +40 ecx  +44 eax ← frame->eax written here
    +48 int_no=128   +52 err_code=0
    +56 eip  +60 cs   +64 eflags
    +68 user_esp     +72 user_ss
  |
  common -> dispatch: "call interrupt_dispatch(frame*)"
  # ── Phase 5: Dispatch routes to syscall handler ─────────────────────────
  dispatch -> dispatch: |md
    frame->int_no == 0x80
    → route to syscall_dispatch
    (no EOI — software interrupt)
  |
  dispatch -> syscall_d: "syscall_dispatch(frame)"
  syscall_d -> syscall_d: |md
    n = frame->eax = **4** (SYS_WRITE)
    arg1 = frame->ebx = **1** (fd)
    arg2 = frame->ecx = **buf_virt**
    arg3 = frame->edx = **len**
    syscall_table[4] → sys_write ✓
  |
  syscall_d -> sys_w: "sys_write(fd=1, buf_virt, len)"
  # ── Phase 6: sys_write validates and outputs ────────────────────────────
  sys_w -> sys_w: |md
    fd == 1 ✓ (stdout)
    buf_virt < 0xC0000000 ✓ (user range)
    len clamped to 4096 if > 4096
  |
  # ── Error path note (Sequence Diagram Note) ─────────────────────────────
  sys_w.err_note: |md
    **Error cases handled by sys_write:**
    • fd ≠ 1 → return −1 (EBADF)
    • buf_virt ≥ 0xC0000000 → return −1 (EFAULT)
    • buf_virt unmapped → kernel #PF → halt
    • unknown syscall n → return −1 (ENOSYS)
  |
  sys_w -> vga_ser: "write each byte: vga_putchar(c) + serial_putchar(c)"
  vga_ser -> vga_ser: |md
    VGA MMIO write → 0xC00B8000
    *(volatile uint16_t*)(buf) = entry
    serial: spin on THRE, outb(COM1, c)
  |
  vga_ser -> sys_w: "return (chars written)"
  sys_w -> syscall_d: "return written_count"
  # ── Phase 7: Return value propagated back ───────────────────────────────
  syscall_d -> syscall_d: |md
    frame->eax ← written_count
    (iretd will restore this to user EAX)
  |
  syscall_d -> dispatch: "return"
  dispatch -> common: "return (from interrupt_dispatch)"
  # ── Phase 8: Common stub restores state ────────────────────────────────
  common -> common: |md
    add esp, 4     ← pop frame* arg
    pop gs/fs/es/ds
    **popa**       ← restore all GP regs
    add esp, 8     ← discard int_no + err_code
    **iretd**
  |
  common -> cpu: "iretd execution"
  # ── Phase 9: CPU restores user context ─────────────────────────────────
  cpu -> cpu: |md
    **iretd pops (privilege change path):**
    EIP    ← saved user return address
    CS     ← 0x1B (ring-3, CPL→3)
    EFLAGS ← saved (IF=1 preserved)
    ESP    ← saved user_esp
    SS     ← 0x23 (user stack)
    Stack switches back to user stack
  |
  cpu -> user_proc: "resume at instruction after int 0x80"
  # ── Phase 10: User receives return value ───────────────────────────────
  user_proc -> user_proc: |md
    EAX = written_count  *(return value)*
    EBX, ECX, EDX = unchanged
    *(callee-saved by isr_common_stub)*
  |
}