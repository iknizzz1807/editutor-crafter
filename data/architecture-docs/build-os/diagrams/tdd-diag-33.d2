vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: ||md
  ## Interrupt Enable/Disable Windows — Context Switch Critical Path
  **IF = EFLAGS bit 9 (Interrupt Flag): 1 = interrupts enabled, 0 = disabled**
|| {near: top-center}

# ─── Timeline Zones ──────────────────────────────────────────────────────────
z1: Zone 1 — Timer ISR Entry {
  style.fill: "#3B1F5E"
  style.stroke: "#9B59B6"
  style.border-radius: 6
  flag: "IF = 0" {
    style.fill: "#C0392B"
    style.font-color: white
    style.bold: true
    style.border-radius: 4
  }
  desc: ||md
    **Interrupt Gate** clears IF atomically
    on CPU entry to IDT vector 32 (IRQ0)
    CPU pushes: SS, ESP, EFLAGS, CS, EIP
    → kernel stack (TSS.ESP0)
  ||
}

z2: Zone 2 — scheduler_tick() {
  style.fill: "#1A3A5C"
  style.stroke: "#2980B9"
  style.border-radius: 6
  flag: "IF = 0" {
    style.fill: "#C0392B"
    style.font-color: white
    style.bold: true
    style.border-radius: 4
  }
  desc: ||md
    `tick_counter++`
    Find next READY process
    `old->state = READY`
    `next->state = RUNNING`
    Call `context_switch(old, next)`
  ||
}

z3: Zone 3 — context_switch() C Wrapper ⚠ ATOMIC WINDOW {
  style.fill: "#4A1010"
  style.stroke: "#E74C3C"
  style.stroke-width: 3
  style.border-radius: 6
  flag: "IF = 0  ← MUST STAY 0" {
    style.fill: "#C0392B"
    style.font-color: white
    style.bold: true
    style.border-radius: 4
  }
  ops: ||md
    ① `tss_set_kernel_stack(new->kernel_stack_top)`
    ② `mov cr3, new->page_directory`  (if PDs differ)
    ③ `current_process = new`
    ④ call `context_switch_asm(&old->ctx, &new->ctx)`
  ||
  warn: {
    label: ||md
      **VIOLATION CONSEQUENCE**
      If interrupt fires between ① and ④:
      • TSS.ESP0 = new stack, but CR3/registers = old
      • Hardware pushes interrupt frame to wrong stack
      • Silent stack corruption → eventual triple-fault
    ||
    style.fill: "#7B2D00"
    style.font-color: "#FFD7BE"
    style.border-radius: 4
  }
}

z4: Zone 4 — context_switch_asm ESP Swap {
  style.fill: "#0D3320"
  style.stroke: "#27AE60"
  style.border-radius: 6
  flag: "IF = 0  (inherited from caller)" {
    style.fill: "#C0392B"
    style.font-color: white
    style.bold: true
    style.border-radius: 4
  }
  save: "SAVE old process" {
    style.fill: "#0A2218"
    style.stroke: "#1E8449"
    style.border-radius: 4
    body: ||md
      `push ebx`        ← EBX to old stack
      `push esi`        ← ESI
      `push edi`        ← EDI
      `push ebp`        ← EBP
      `pushfd`          ← EFLAGS (IF=0)
      `mov [old_ctx->esp], esp`
    ||
  }
  pivot: "⟵ ESP SWAP ⟶  Identity changes here" {
    style.fill: "#4A0E8F"
    style.stroke: "#8E44AD"
    style.stroke-width: 3
    style.font-color: white
    style.bold: true
    style.border-radius: 4
  }
  load: "RESTORE new process" {
    style.fill: "#0A2218"
    style.stroke: "#1E8449"
    style.border-radius: 4
    body: ||md
      `mov esp, [new_ctx->esp]`  ← new stack
      (now on NEW process's kernel stack)
    ||
  }
  save -> pivot
  pivot -> load
}

z5: Zone 5 — popfd Restores EFLAGS {
  style.fill: "#1A3A1A"
  style.stroke: "#2ECC71"
  style.border-radius: 6
  flag: "IF = 0 → 1  (transition point)" {
    style.fill: "#D4AC0D"
    style.font-color: "#1A1A00"
    style.bold: true
    style.border-radius: 4
  }
  desc: ||md
    `popfd`  ← loads EFLAGS = **0x00000202** from new stack
    Bit 9 (IF) = **1** → interrupts re-enabled HERE
    New process's fabricated/saved EFLAGS:
    `0x00000202` = IF=1, bit-1=1 (always set)
    `pop ebp` / `pop edi` / `pop esi` / `pop ebx`
  ||
  note: {
    label: ||md
      ⚠ After `popfd`, IF=1 — timer CAN fire before `ret`.
      This is safe: TSS, CR3, current_process are all
      already consistent for the new process (set in Zone 3).
    ||
    style.fill: "#0D3320"
    style.font-color: "#ABEBC6"
    style.border-radius: 4
  }
}

z6: Zone 6 — ret to New Process's ISR Return Path {
  style.fill: "#0A2030"
  style.stroke: "#5DADE2"
  style.border-radius: 6
  flag: "IF = 1" {
    style.fill: "#1E8449"
    style.font-color: white
    style.bold: true
    style.border-radius: 4
  }
  desc: ||md
    `ret` → pops saved EIP from new process's stack
    **For a previously-suspended process:**
    Returns into `isr_common_stub` return path
    → `popa` → restore segment regs → `add esp, 8` → `iretd`
    **For a first-time kernel process:**
    Returns directly to `entry_fn()` (fabricated EIP)
    Process begins executing at ring 0
  ||
}

z7: Zone 7 — iretd to User Mode (ring-3 process only) {
  style.fill: "#1A1A3A"
  style.stroke: "#8E44AD"
  style.border-radius: 6
  flag: "IF = 1  (from EFLAGS on stack)" {
    style.fill: "#1E8449"
    style.font-color: white
    style.bold: true
    style.border-radius: 4
  }
  desc: ||md
    `iretd` pops: EIP, CS=0x1B (→ CPL=3), EFLAGS (IF=1)
    Privilege change detected (CS.RPL=3 > CPL=0):
    also pops ESP, SS=0x23 → switches to user stack
    User process resumes at its interrupted instruction
    with all general registers restored
  ||
}

# ─── Atomic Window Annotation ─────────────────────────────────────────────────
atomic_box: ATOMIC WINDOW — Zones 3+4 must be uninterrupted {
  style.fill: "#2D0000"
  style.stroke: "#E74C3C"
  style.stroke-width: 4
  style.stroke-dash: 4
  style.border-radius: 8
  requirement: ||md
    **Three operations must complete atomically (IF=0 throughout):**
    | # | Operation | If interrupted before completion |
    |---|-----------|----------------------------------|
    | ① | `TSS.ESP0 = new->kernel_stack_top` | Next interrupt pushes to wrong process's stack |
    | ② | `CR3 = new->page_directory` | Code/data from wrong address space accessed |
    | ③ | `current_process = new` | Syscall handlers see stale process identity |
    **Guarantee:** Interrupt gate on IDT[32] clears IF on entry.
    `context_switch` runs entirely inside IRQ0 handler → IF=0 throughout.
    No explicit `cli` needed (already off). No `sti` until `popfd` in Zone 5.
  ||
}

# ─── Stack Diagram ─────────────────────────────────────────────────────────────
stack_diag: Kernel Stack State at Each Zone Boundary {
  style.fill: "#0D0D1A"
  style.stroke: "#5D6D7E"
  style.border-radius: 6
  entry_stack: "Stack at ISR Entry (Zone 1)" {
    style.fill: "#1A1A2E"
    style.stroke: "#5D6D7E"
    style.border-radius: 4
    style.font: mono
    body: ||md
      [ESP+16] EFLAGS  (user/kernel, IF=1 before)
      [ESP+12] CS
      [ESP+8]  EIP
      [ESP+4]  err_code (0 for IRQ0)
      [ESP+0]  int_no  (32)
    ||
  }
  after_save: "Stack after Zone 4 SAVE (old process)" {
    style.fill: "#1A1A2E"
    style.stroke: "#5D6D7E"
    style.border-radius: 4
    style.font: mono
    body: ||md
      [ESP+44] EFLAGS  (CPU-pushed)
      [ESP+40] CS
      [ESP+36] EIP
      [ESP+32] err_code
      [ESP+28] int_no
      ...segment regs / pusha block...
      [ESP+20] return EIP (from call context_switch_asm)
      [ESP+16] EBX
      [ESP+12] ESI
      [ESP+8]  EDI
      [ESP+4]  EBP
      [ESP+0]  EFLAGS (IF=0) ← old_ctx->esp points here
    ||
  }
  after_swap: "Stack after ESP SWAP (new process, Zone 4)" {
    style.fill: "#1A1A2E"
    style.stroke: "#8E44AD"
    style.border-radius: 4
    style.font: mono
    body: ||md
      [new_esp+20] return EIP (new process's)
      [new_esp+16] EBX
      [new_esp+12] ESI
      [new_esp+8]  EDI
      [new_esp+4]  EBP
      [new_esp+0]  EFLAGS = 0x202 (IF=1) ← new_ctx->esp
    ||
  }
  entry_stack -> after_save: "pusha + seg pushes\n+ context_switch_asm saves"
  after_save -> after_swap: "mov esp, [new_ctx->esp]"
}

# ─── IF Timeline Strip ─────────────────────────────────────────────────────────
if_timeline: IF Flag Timeline (horizontal) {
  style.fill: "#0A0A0A"
  style.stroke: "#5D6D7E"
  style.border-radius: 4
  body: ||md
    Time ──────────────────────────────────────────────────────────────────────►
    IF:  1  │ 0 │  0  │         0         │      0→1      │  1  │  1
             │   │     │                   │               │     │
         ────┼───┼─────┼───────────────────┼───────────────┼─────┼────────────
    Zone:  ─ │ 1 │  2  │       3 + 4       │       5       │  6  │  7
             │   │     │                   │               │     │
           IRQ  tick  C wrapper +        popfd          ret/   iretd
           gate  fn   asm (ATOMIC)       (IF→1)        isr   (user)
                       ◄─── MUST NOT ───►
                           be interrupted
  ||
}

# ─── Flow Connections ──────────────────────────────────────────────────────────
z1 -> z2: "IRQ0 handler body begins"
z2 -> z3: "call context_switch()"
z3 -> z4: "call context_switch_asm()\n[IF=0 inherited]"
z4 -> z5: "new process stack loaded\npopfd executes"
z5 -> z6: "ret → new EIP"
z6 -> z7: "iretd (ring-3 only)" {
  style.stroke-dash: 4
}
z3 -> atomic_box: "annotates" {
  style.stroke: "#E74C3C"
  style.stroke-dash: 3
}
z4 -> atomic_box: "annotates" {
  style.stroke: "#E74C3C"
  style.stroke-dash: 3
}
z4.save -> stack_diag.after_save: "stack state" {
  style.stroke-dash: 3
  style.stroke: "#27AE60"
}
z4.load -> stack_diag.after_swap: "stack state" {
  style.stroke-dash: 3
  style.stroke: "#8E44AD"
}