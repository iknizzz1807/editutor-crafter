vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Multi-Process VGA Demo: Concurrent Output Without Cooperation" {
  shape: text
  near: top-center
  style: {
    font-size: 20
    bold: true
  }
}

legend: |md
  **Legend**
  - ðŸŸ© Process A (Green, Row 2)
  - ðŸŸ¥ Process B (Red, Row 12)
  - ðŸŸ¨ Process C (Yellow, Row 22)
  - ðŸ”µ Timer IRQ (100Hz, Kernel)
  - âš« Idle (PID 0, Kernel)
| {
  near: bottom-right
  style.font-size: 14
}

# â”€â”€ VGA BUFFER (0xB8000) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

vga_buffer: "VGA Text Buffer  0xB8000â€“0xB8F9F" {
  style.fill: "#1a1a2e"
  style.font-color: white
  style.stroke: "#4a4a8a"
  style.border-radius: 6

  row0: "Row  0: [Kernel boot messagesâ€¦                          ]" {
    style.fill: "#16213e"
    style.font-color: "#aaaaaa"
    style.font-size: 12
    style.border-radius: 3
  }
  row1: "Row  1: [Interrupt / PIC / PIT / KBD init linesâ€¦       ]" {
    style.fill: "#16213e"
    style.font-color: "#aaaaaa"
    style.font-size: 12
    style.border-radius: 3
  }
  row2: "Row  2: [ProcA: 00847                                   ]" {
    style.fill: "#0d3b1e"
    style.font-color: "#00ff88"
    style.font-size: 12
    style.stroke: "#00ff88"
    style.border-radius: 3
  }
  row_dots1: "Rows  3â€“11: (idle / blank)                          " {
    style.fill: "#16213e"
    style.font-color: "#555555"
    style.font-size: 11
    style.border-radius: 3
  }
  row12: "Row 12: [ProcB: 00612                                  ]" {
    style.fill: "#3b0d0d"
    style.font-color: "#ff4444"
    style.font-size: 12
    style.stroke: "#ff4444"
    style.border-radius: 3
  }
  row_dots2: "Rows 13â€“21: (idle / blank)                          " {
    style.fill: "#16213e"
    style.font-color: "#555555"
    style.font-size: 11
    style.border-radius: 3
  }
  row22: "Row 22: [ProcC: 00391                                  ]" {
    style.fill: "#3b3b0d"
    style.font-color: "#ffff00"
    style.font-size: 12
    style.stroke: "#ffff00"
    style.border-radius: 3
  }
  row_dots3: "Rows 23â€“24: (idle / blank)                          " {
    style.fill: "#16213e"
    style.font-color: "#555555"
    style.font-size: 11
    style.border-radius: 3
  }
}

# â”€â”€ CPU SCHEDULING TIMELINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

timeline: "CPU Scheduling Timeline  (100 Hz timer, 50 ms slice)" {
  style.fill: "#0f0f1a"
  style.stroke: "#6666aa"
  style.border-radius: 6

  t_idle1: "Idle (PID 0)  0â€“50 ms" {
    style.fill: "#2a2a3a"
    style.font-color: "#888888"
    style.border-radius: 3
  }
  t_a: "Proc A        50â€“100 ms  â† writes row 2" {
    style.fill: "#0d3b1e"
    style.font-color: "#00ff88"
    style.stroke: "#00ff88"
    style.border-radius: 3
  }
  t_b: "Proc B       100â€“150 ms  â† writes row 12" {
    style.fill: "#3b0d0d"
    style.font-color: "#ff4444"
    style.stroke: "#ff4444"
    style.border-radius: 3
  }
  t_c: "Proc C       150â€“200 ms  â† writes row 22" {
    style.fill: "#3b3b0d"
    style.font-color: "#ffff00"
    style.stroke: "#ffff00"
    style.border-radius: 3
  }
  t_idle2: "Idle (PID 0) 200â€“250 ms  (hlt loop)" {
    style.fill: "#2a2a3a"
    style.font-color: "#888888"
    style.border-radius: 3
  }
  t_repeat: "â†»  pattern repeats every 200 ms" {
    style.fill: "#16161e"
    style.font-color: "#5555aa"
    style.font-size: 12
    style.border-radius: 3
  }
}

# â”€â”€ PROCESS PCBs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

pcb_idle: "PCB: idle (PID 0)" {
  style.fill: "#2a2a3a"
  style.stroke: "#888888"
  style.border-radius: 6
  style.font-color: "#cccccc"

  idle_st: "state = RUNNING / READY" { style.fill: "#3a3a4a"; style.font-size: 12 }
  idle_sk: "kernel_stack_top = 0xXXXXXXXX" { style.fill: "#3a3a4a"; style.font-size: 12 }
  idle_pd: "page_directory  = boot_pd" { style.fill: "#3a3a4a"; style.font-size: 12 }
}

pcb_a: "PCB: proc_a (PID 1)" {
  style.fill: "#0d3b1e"
  style.stroke: "#00ff88"
  style.border-radius: 6

  a_st: "state = READY / RUNNING" { style.fill: "#0d4b2e"; style.font-size: 12 }
  a_sk: "kernel_stack_top = 0xXXXXXXXX" { style.fill: "#0d4b2e"; style.font-size: 12 }
  a_pd: "page_directory  = boot_pd" { style.fill: "#0d4b2e"; style.font-size: 12 }
  a_fn: "entry â†’ proc_a_entry()" { style.fill: "#0d4b2e"; style.font-size: 12 }
}

pcb_b: "PCB: proc_b (PID 2)" {
  style.fill: "#3b0d0d"
  style.stroke: "#ff4444"
  style.border-radius: 6

  b_st: "state = READY / RUNNING" { style.fill: "#4b0d0d"; style.font-size: 12 }
  b_sk: "kernel_stack_top = 0xXXXXXXXX" { style.fill: "#4b0d0d"; style.font-size: 12 }
  b_pd: "page_directory  = boot_pd" { style.fill: "#4b0d0d"; style.font-size: 12 }
  b_fn: "entry â†’ proc_b_entry()" { style.fill: "#4b0d0d"; style.font-size: 12 }
}

pcb_c: "PCB: proc_c (PID 3)" {
  style.fill: "#3b3b0d"
  style.stroke: "#ffff00"
  style.border-radius: 6

  c_st: "state = READY / RUNNING" { style.fill: "#4b4b0d"; style.font-size: 12 }
  c_sk: "kernel_stack_top = 0xXXXXXXXX" { style.fill: "#4b4b0d"; style.font-size: 12 }
  c_pd: "page_directory  = boot_pd" { style.fill: "#4b4b0d"; style.font-size: 12 }
  c_fn: "entry â†’ proc_c_entry()" { style.fill: "#4b4b0d"; style.font-size: 12 }
}

# â”€â”€ SCHEDULER / TIMER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

scheduler: "Round-Robin Scheduler" {
  style.fill: "#16213e"
  style.stroke: "#4477cc"
  style.border-radius: 6

  timer_irq: "Timer IRQ0  (100 Hz)" {
    style.fill: "#1e2e4e"
    style.font-color: "#88aaff"
    style.border-radius: 3
  }
  sched_tick: "sched_tick()\nticks_remaining--\nif 0 â†’ sched_schedule()" {
    style.fill: "#1e2e4e"
    style.font-color: "#88aaff"
    style.font-size: 12
    style.border-radius: 3
  }
  tss_update: "tss_set_kernel_stack(next->kernel_stack_top)" {
    style.fill: "#1e2e4e"
    style.font-color: "#88aaff"
    style.font-size: 12
    style.border-radius: 3
  }
  ctx_switch: "context_switch_asm()\nâ€¢ save old->saved_esp\nâ€¢ load new esp\nâ€¢ reload CR3 if needed\nâ€¢ ret â†’ trampoline â†’ iret" {
    style.fill: "#1e2e4e"
    style.font-color: "#aaccff"
    style.font-size: 12
    style.border-radius: 3
  }
}

tss_box: "Intel TSS  (kernel_tss)" {
  style.fill: "#1a0d2e"
  style.stroke: "#9966cc"
  style.border-radius: 6

  esp0_field: "esp0  â† next->kernel_stack_top\n(written before every switch)" {
    style.fill: "#2a1a3e"
    style.font-color: "#cc99ff"
    style.font-size: 12
    style.border-radius: 3
  }
  ss0_field: "ss0  = 0x0010  (kernel data)" {
    style.fill: "#2a1a3e"
    style.font-color: "#cc99ff"
    style.font-size: 12
    style.border-radius: 3
  }
}

# â”€â”€ KERNEL STACK DIAGRAM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

kstack_diagram: "Per-Process Kernel Stack  (4 KB each, grows â†“)" {
  style.fill: "#0a1a0a"
  style.stroke: "#338833"
  style.border-radius: 6

  frame_note: |md
    **On preemption** (timer IRQ from ring-0 proc):
    
    kernel_stack_top â”
      [high]  EFLAGS (0x202, IF=1)
              CS     (0x08 kernel)
              EIP    (resume addr)
              error_code = 0
              vector     = 32
              EAX..EDI   (pusha)
              DS/ES/FS/GS
              return â†’ irq_common_stub
              saved_esp â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    [low]
    
    **First activation** (fake initial frame):
    same layout, EIP = entry_func
  | {
    style.fill: "#0a1a0a"
    style.font-color: "#88cc88"
    style.font-size: 12
    style.border-radius: 3
  }
}

# â”€â”€ CONNECTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

scheduler.timer_irq -> scheduler.sched_tick: "every 10 ms"
scheduler.sched_tick -> scheduler.tss_update: "slice expired"
scheduler.tss_update -> scheduler.ctx_switch
scheduler.tss_update -> tss_box.esp0_field: "writes esp0" {
  style.stroke: "#9966cc"
  style.stroke-dash: 3
}

scheduler.ctx_switch -> pcb_a: "switch to A" {
  style.stroke: "#00ff88"
  style.stroke-dash: 5
}
scheduler.ctx_switch -> pcb_b: "switch to B" {
  style.stroke: "#ff4444"
  style.stroke-dash: 5
}
scheduler.ctx_switch -> pcb_c: "switch to C" {
  style.stroke: "#ffff00"
  style.stroke-dash: 5
}
scheduler.ctx_switch -> pcb_idle: "switch to idle" {
  style.stroke: "#888888"
  style.stroke-dash: 5
}

pcb_a -> vga_buffer.row2: "volatile uint16_t write\n0xB8000 + 2Ã—80Ã—2" {
  style.stroke: "#00ff88"
}
pcb_b -> vga_buffer.row12: "volatile uint16_t write\n0xB8000 + 12Ã—80Ã—2" {
  style.stroke: "#ff4444"
}
pcb_c -> vga_buffer.row22: "volatile uint16_t write\n0xB8000 + 22Ã—80Ã—2" {
  style.stroke: "#ffff00"
}

pcb_a -> kstack_diagram: "each process owns\n4 KB kernel stack" {
  style.stroke: "#338833"
  style.stroke-dash: 3
}
pcb_b -> kstack_diagram
pcb_c -> kstack_diagram

# timeline order hints
timeline.t_idle1 -> timeline.t_a: "timer preempts idle"
timeline.t_a -> timeline.t_b: "timer preempts A"
timeline.t_b -> timeline.t_c: "timer preempts B"
timeline.t_c -> timeline.t_idle2: "timer preempts C"
timeline.t_idle2 -> timeline.t_repeat

# non-cooperation annotation
no_coop: |md
  **Key Property â€” No Cooperation Required**

  Each process runs in a tight busy-loop.
  No `yield()`, no `sleep()`, no shared flags.
  The 100 Hz timer IRQ **preempts** each process
  mid-loop every 50 ms without its knowledge.

  Processes are unaware of each other.
  Hardware + scheduler enforce fairness.
| {
  near: bottom-left
  style.fill: "#0f0f0f"
  style.font-color: "#aaaaaa"
  style.stroke: "#333333"
  style.border-radius: 6
  style.font-size: 13
}