vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  ## MBR and Disk Layout: Two-Stage Bootloader Sector Map
| {near: top-center}

disk: Disk Image (os.img) {
  style: {
    fill: "#1a1a2e"
    stroke: "#4a4a8a"
    stroke-width: 3
    border-radius: 8
    font-color: white
    bold: true
    font-size: 18
  }

  sector0: LBA 0 — MBR Stage1 {
    style: {
      fill: "#6B2D8B"
      stroke: "#9B4DBB"
      stroke-width: 2
      font-color: white
      bold: true
    }
    s0_detail: |md
      **Offset 0x000 – 0x1FD:** Stage1 code (510 bytes)

      `org 0x7C00` — BIOS loads here

      - `cli` → `xor ax,ax` → setup DS/ES/SS
      - Save `DL` (boot drive) → `[boot_drive]`
      - INT 13h AH=02: read 8 sectors → `0x7E00`
      - `jmp 0x0000:0x7E00`
      - `disk_error`: INT 10h teletype → `hlt`

      **Offset 0x1FE:** `0x55` ← byte 510
      **Offset 0x1FF:** `0xAA` ← byte 511 (boot signature)
    |
  }

  sector1_8: LBA 1–8 — Stage2 Bootloader (4096 bytes, 8 sectors) {
    style: {
      fill: "#1a4a6b"
      stroke: "#2a7aab"
      stroke-width: 2
      font-color: white
      bold: true
    }
    s2_detail: |md
      **Loaded to:** `0x7E00` – `0x8DFF`

      1. Print "Loading kernel..." (INT 10h)
      2. Enable A20 (INT 15h AX=2401h → port 0x92 fallback)
      3. Verify A20 (compare `[0xFFFF:0x0010]` vs `[0x0000:0x0000]`)
      4. Enter **Unreal Mode** (temporary pmode → back to real)
         - Load minimal GDT (4GB flat data descriptor)
         - `CR0.PE=1` → load GS with 32-bit selector → `CR0.PE=0`
         - GS segment cache: 4GB limit active
      5. INT 13h loop: read 64 sectors → `GS:0x100000`
      6. `cli`
      7. `lgdt [gdt_descriptor]` (5-entry GDT)
      8. `mov cr0, eax` (set PE=1)
      9. `jmp 0x08:pm32_entry`
      10. Load DS/ES/FS/GS/SS = 0x10 → `jmp 0x100000`
    |
  }

  sector9_72: LBA 9–72 — Kernel Binary (32768 bytes, 64 sectors) {
    style: {
      fill: "#1a5c1a"
      stroke: "#2a8c2a"
      stroke-width: 2
      font-color: white
      bold: true
    }
    sk_detail: |md
      **Loaded to:** Physical `0x100000` – `0x107FFF`

      **ELF sections (linked at `0x100000`):**
      - `.text`   — kernel code (`entry.asm` + C files)
      - `.rodata` — string literals, const arrays
      - `.data`   — initialized globals
      - `.bss`    — uninitialized globals (zeroed by `entry.asm`)
      - `kernel_stack[16384]` — 16KB static stack in `.bss`

      **Entry point:** `kernel_entry` label in `entry.asm`
      `kmain()` linked at ≥ `0x100000`
    |
  }

  sector73_plus: LBA 73+ — (Free / Future Use) {
    style: {
      fill: "#2a2a2a"
      stroke: "#4a4a4a"
      stroke-width: 1
      stroke-dash: 4
      font-color: "#888888"
    }
    free_detail: |md
      *Not used in Milestone 1.*
      Reserved for future filesystem,
      initrd, or additional modules.
    |
  }
}

memory: Physical Memory at Boot {
  style: {
    fill: "#1a1a1a"
    stroke: "#6a4a2a"
    stroke-width: 3
    border-radius: 8
    font-color: white
    bold: true
    font-size: 18
  }

  mem_ivt: `0x00000 – 0x003FF` Real-Mode IVT (1KB) {
    style: { fill: "#3a2a1a"; stroke: "#8a6a4a"; font-color: "#ddaa77" }
  }
  mem_bda: `0x00400 – 0x004FF` BIOS Data Area (256B) {
    style: { fill: "#3a2a1a"; stroke: "#8a6a4a"; font-color: "#ddaa77" }
  }
  mem_stage1: `0x07C00 – 0x07DFF` Stage1 MBR (512B) {
    style: { fill: "#6B2D8B"; stroke: "#9B4DBB"; font-color: white; bold: true }
  }
  mem_stage2: `0x07E00 – 0x08DFF` Stage2 Bootloader (4KB) {
    style: { fill: "#1a4a6b"; stroke: "#2a7aab"; font-color: white; bold: true }
  }
  mem_ebda: `0x80000 – 0x9FFFF` EBDA / Usable (varies) {
    style: { fill: "#2a2a1a"; stroke: "#6a6a3a"; font-color: "#aaaa77" }
  }
  mem_vga: `0xA0000 – 0xBFFFF` VGA / Video Memory {
    style: { fill: "#3a1a3a"; stroke: "#8a4a8a"; font-color: "#ddaadd" }
    vga_text: "`0xB8000` = VGA Text Buffer (2000×2B)" {
      style: { fill: "#5a2a5a"; stroke: "#aa6aaa"; font-color: white; font-size: 13 }
    }
  }
  mem_bios_rom: `0xC0000 – 0xFFFFF` Video BIOS + System BIOS ROM {
    style: { fill: "#1a1a3a"; stroke: "#4a4a8a"; font-color: "#aaaadd" }
  }
  mem_1mb_boundary: `0x100000` ← 1MB Boundary {
    style: { fill: "#1a3a1a"; stroke: "#4a8a4a"; font-color: "#aaddaa"; bold: true; stroke-width: 3 }
  }
  mem_kernel: `0x100000 – 0x107FFF` Kernel Binary (32KB) {
    style: { fill: "#1a5c1a"; stroke: "#2a8c2a"; font-color: white; bold: true }
  }
  mem_free: `0x108000+` Free Usable RAM {
    style: { fill: "#1a2a1a"; stroke: "#3a5a3a"; font-color: "#88aa88"; stroke-dash: 3 }
  }
}

annotations: Key Facts {
  style: {
    fill: "#0d0d1a"
    stroke: "#3a3a6a"
    stroke-width: 2
    border-radius: 6
    font-color: "#ccccff"
  }
  ann_text: |md
    **Boot Signature:** Bytes 510–511 of MBR must be `0x55 0xAA`
    (NASM: `dw 0xAA55` → little-endian stores `0x55` at 510, `0xAA` at 511)

    **CHS Addressing:** Sector 1 = MBR (1-indexed); Stage2 at CHS (C=0, H=0, S=2–9)

    **Unreal Mode Trick:** `CR0.PE=1` → load 32-bit GS segment → `CR0.PE=0`
    GS retains 4GB limit allowing `GS:0x100000` writes from real mode

    **A20 Enable Priority:** BIOS INT 15h AX=2401h → Fast A20 port 0x92 → verify

    **Kernel Link Address = Load Address:** `0x100000` (identity-mapped; paging off)
    Higher-half mapping deferred to Milestone 3
  |
}

disk.sector0 -> disk.sector1_8: "Stage1 INT 13h reads 8 sectors" {
  style: { stroke: "#9B4DBB"; stroke-width: 2; animated: true }
}
disk.sector1_8 -> disk.sector9_72: "Stage2 INT 13h reads 64 sectors\n(via Unreal Mode → GS:0x100000)" {
  style: { stroke: "#2a7aab"; stroke-width: 2; animated: true }
}

disk.sector0 -> memory.mem_stage1: "BIOS loads 512B to 0x7C00\njumps here" {
  style: { stroke: "#9B4DBB"; stroke-dash: 3; stroke-width: 2 }
}
disk.sector1_8 -> memory.mem_stage2: "Stage1 INT 13h → 0x7E00\nthen jmp 0x7E00" {
  style: { stroke: "#2a7aab"; stroke-dash: 3; stroke-width: 2 }
}
disk.sector9_72 -> memory.mem_kernel: "Stage2 INT 13h → 0x100000\nvia GS segment (Unreal Mode)" {
  style: { stroke: "#2a8c2a"; stroke-dash: 3; stroke-width: 2 }
}

memory.mem_stage2 -> memory.mem_kernel: "After lgdt + CR0.PE=1\njmp 0x08:0x100000" {
  style: { stroke: "#ffaa00"; stroke-width: 3; animated: true }
}