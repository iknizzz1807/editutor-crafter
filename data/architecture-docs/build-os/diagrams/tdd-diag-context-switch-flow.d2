direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Context Switch Sequence
  **Preemptive Multitasking: Timer IRQ â†’ Process Switch**
| {near: top-center}

step1: {
  label: "Step 1: Timer IRQ Fires"
  timer_chip: {
    shape: rectangle
    style.fill: "#FFE4B5"
    style.stroke: "#CD853F"
    label: "PIT/Local APIC\nTimer Interrupt"
  }
  
  cpu_state1: {
    shape: rectangle
    label: "CPU State (Ring 0)"
    style.fill: "#E6E6FA"
    style.stroke: "#9370DB"
    
    regs1: {
      label: |md
        **Active Registers**
        
        CS:EIP = 0x08:kernel_code
        ESP   = kernel_stack_ptr
        EAX..EDI = current_values
        CR3   = current_pdir
        
      |
      shape: code
    }
  }
  
  current_pcb1: {
    shape: rectangle
    label: "Current PCB"
    style.fill: "#98FB98"
    style.stroke: "#228B22"
    
    pcb_fields1: {
      label: |md
        
        pid: 1
        state: RUNNING
        kstack: 0xC0200000
        regs: { ??? }
        cr3: 0x00100000
        
      |
      shape: code
    }
  }
  
  note1: |md
    **ISR Entry:**
    - CPU pushes SS, ESP, EFLAGS, CS, EIP
    - If privilege change: stack switch via TSS
    - Assembly stub pushes error code (0)
    - Jumps to `timer_handler()`
  |
  note1.style.fill: "#FFFACD"
  
  timer_chip -> cpu_state1: "IRQ 0\n(vector 32)" {
    style.stroke: red
    style.stroke-width: 3
    style.animated: true
  }
}

step2: {
  label: "Step 2: Save Current Registers to PCB"
  
  isr_prologue: {
    shape: rectangle
    label: "ISR Prologue (assembly)"
    style.fill: "#F0FFF0"
    style.stroke: "#2E8B57"
    
    asm_code2: {
      label: |md
        asm
        timer_isr:
            push dword 0          ; fake error code
            pusha                 ; EAX,ECX,EDX,EBX
                                 ; ESP,EBP,ESI,EDI
            push ds, es, fs, gs   ; segment regs
            mov eax, [current]
            mov [eax+PCB.regs], esp
        
      |
      shape: code
    }
  }
  
  current_pcb2: {
    shape: rectangle
    label: "Current PCB (UPDATED)"
    style.fill: "#FF6B6B"
    style.stroke: "#DC143C"
    style.bold: true
    
    pcb_fields2: {
      label: |md
        
        pid: 1
        state: READY        â† CHANGED
        kstack: 0xC0200000
        regs: {
          EAX = saved_eax   â† SAVED
          ECX = saved_ecx   â† SAVED
          EDX = saved_edx   â† SAVED
          EBX = saved_ebx   â† SAVED
          ESP = user_esp    â† SAVED
          EBP = saved_ebp   â† SAVED
          ESI = saved_esi   â† SAVED
          EDI = saved_edi   â† SAVED
          EIP = return_addr â† SAVED
          CS  = 0x08
          EFLAGS = saved_fl
        }
        cr3: 0x00100000
        
      |
      shape: code
    }
  }
  
  note2: |md
    **Register Layout in PCB:**
    
    offset 0:  EAX    (4 bytes)
    offset 4:  ECX
    offset 8:  EDX
    offset 12: EBX
    offset 16: ESP    (kernel ESP)
    offset 20: EBP
    offset 24: ESI
    offset 28: EDI
    offset 32: EIP
    offset 36: CS
    offset 40: EFLAGS
    
  |
  note2.style.fill: "#E0FFFF"
  
  isr_prologue -> current_pcb2: "Save all regs\nto PCB.regs" {
    style.stroke: red
    style.bold: true
    style.stroke-width: 2
  }
}

step3: {
  label: "Step 3: Pick Next Process"
  
  scheduler_c: {
    shape: rectangle
    label: "scheduler_tick()"
    style.fill: "#F5F5DC"
    style.stroke: "#DAA520"
    
    code3: {
      label: |md
        c
        void scheduler_tick() {
            current->ticks++;
            if (current->ticks >= TIME_SLICE) {
                current->state = READY;
                rotate_queue();
                next = dequeue(&ready_q);
                next->state = RUNNING;
            }
        }
        
      |
      shape: code
    }
  }
  
  ready_queue: {
    shape: rectangle
    label: "Ready Queue"
    style.fill: "#ADD8E6"
    style.stroke: "#4169E1"
    
    queue_state: {
      label: |md
        
        head â†’ PCB(pid=2) â†â†’ PCB(pid=3)
                 â†“            â†“
              READY        READY
        
      |
      shape: code
    }
  }
  
  next_pcb: {
    shape: rectangle
    label: "Next PCB"
    style.fill: "#90EE90"
    style.stroke: "#228B22"
    
    pcb_next: {
      label: |md
        
        pid: 2
        state: RUNNING â† NEW STATE
        kstack: 0xC0300000
        regs: { saved_regs }
        cr3: 0x00200000 â† DIFFERENT!
        ring: 3         â† USER MODE
        
      |
      shape: code
    }
  }
  
  scheduler_c -> ready_queue: "dequeue\nnext"
  ready_queue -> next_pcb: "select" {
    style.stroke: green
    style.bold: true
    style.stroke-width: 2
  }
}

step4: {
  label: "Step 4: Update TSS.ESP0"
  
  tss_before: {
    shape: rectangle
    label: "TSS (Before)"
    style.fill: "#D3D3D3"
    style.stroke: "#696969"
    
    tss_fields_b: {
      label: |md
        
        SS0  = 0x10 (kernel data)
        ESP0 = 0xC0200000 â† OLD
        
      |
      shape: code
    }
  }
  
  tss_update: {
    shape: rectangle
    label: "TSS Update"
    style.fill: "#FFB6C1"
    style.stroke: "#DC143C"
    
    code4: {
      label: |md
        c
        // MUST update before iret!
        tss.esp0 = next->kstack_top;
        // 0xC0300000 for pid=2
        
      |
      shape: code
    }
  }
  
  tss_after: {
    shape: rectangle
    label: "TSS (After)"
    style.fill: "#90EE90"
    style.stroke: "#228B22"
    style.bold: true
    
    tss_fields_a: {
      label: |md
        
        SS0  = 0x10 (kernel data)
        ESP0 = 0xC0300000 â† NEW
        
      |
      shape: code
    }
  }
  
  note4: |md
    **âš ï¸ CRITICAL:**
    If TSS.ESP0 is stale, userâ†’kernel
    transition will corrupt stack!
    
    Ring 3 â†’ Ring 0: CPU loads
    SS:ESP from TSS automatically.
  |
  note4.style.fill: "#FFE4E1"
  
  tss_before -> tss_update: "check current"
  tss_update -> tss_after: "write new ESP0" {
    style.stroke: red
    style.bold: true
  }
}

step5: {
  label: "Step 5: Load CR3 (if page dirs differ)"
  
  cr3_check: {
    shape: diamond
    label: "current->cr3\n== next->cr3?"
    style.fill: "#FFFACD"
    style.stroke: "#DAA520"
  }
  
  cr3_load: {
    shape: rectangle
    label: "Load New Page Directory"
    style.fill: "#FFA07A"
    style.stroke: "#CD5C5C"
    
    code5: {
      label: |md
        c
        if (current->cr3 != next->cr3) {
            asm volatile(
                "mov %0, %%cr3"
                : : "r"(next->cr3)
            );
            // TLB flushed!
        }
        
      |
      shape: code
    }
  }
  
  cr3_skip: {
    shape: rectangle
    label: "Skip CR3 Load"
    style.fill: "#98FB98"
    style.stroke: "#228B22"
    
    code5b: {
      label: |md
        
        Same process or
        kernel threads share
        the same page directory.
        No TLB flush needed.
        
      |
      shape: code
    }
  }
  
  note5: |md
    **Performance Note:**
    - CR3 reload flushes TLB (expensive!)
    - Kernel threads share kernel page dir
    - Use PCID if available to avoid flush
    - Consider `invlpg` for single page
  |
  note5.style.fill: "#F0E68C"
  
  cr3_check -> cr3_load: "No" {
    label: "Different\naddress spaces"
  }
  cr3_check -> cr3_skip: "Yes" {
    label: "Same\naddress space"
  }
}

step6: {
  label: "Step 6: Restore Registers"
  
  isr_epilogue: {
    shape: rectangle
    label: "ISR Epilogue (assembly)"
    style.fill: "#F0FFF0"
    style.stroke: "#2E8B57"
    
    code6: {
      label: |md
        asm
        restore_context:
            mov eax, [next]       ; get next PCB
            mov esp, [eax+PCB.regs]
            pop gs, fs, es, ds    ; restore segs
            popa                  ; restore general
            add esp, 8            ; skip error+vec
            iret                  ; RESTORE ALL!
        
      |
      shape: code
    }
  }
  
  restored_state: {
    shape: rectangle
    label: "Restored CPU State"
    style.fill: "#90EE90"
    style.stroke: "#228B22"
    style.bold: true
    
    regs6: {
      label: |md
        
        EAX = next_pcb.regs.eax
        ECX = next_pcb.regs.ecx
        ...
        ESP = next_pcb.regs.esp
        EIP = next_pcb.regs.eip
        CS  = next_pcb.regs.cs
        EFLAGS = next_pcb.regs.eflags
        CR3 = next_pcb.cr3
        
      |
      shape: code
    }
  }
  
  isr_epilogue -> restored_state: "pop from\nPCB.regs" {
    style.stroke: green
    style.bold: true
    style.stroke-width: 2
  }
}

step7: {
  label: "Step 7: IRET to New Process"
  
  iret_frame: {
    shape: rectangle
    label: "Stack Before IRET"
    style.fill: "#E6E6FA"
    style.stroke: "#9370DB"
    
    frame: {
      label: |md
        
        ESP â†’  [ SS     ]  â† if privilege change
               [ ESP    ]  â† user stack pointer
               [ EFLAGS ]  â† IF restored here
               [ CS     ]  â† 0x1B (ring 3) or 0x08
               [ EIP    ]  â† instruction pointer
        
      |
      shape: code
    }
  }
  
  cpu_final: {
    shape: rectangle
    label: "CPU State (Switched!)"
    style.fill: "#90EE90"
    style.stroke: "#228B22"
    style.bold: true
    
    final_regs: {
      label: |md
        
        CS:EIP = 0x1B:user_code  â† RING 3!
        ESP   = user_stack_ptr
        SS    = 0x23 (user data)
        CR3   = 0x00200000
        EFLAGS.IF = 1 (interrupts on)
        
      |
      shape: code
    }
  }
  
  user_process: {
    shape: rectangle
    label: "User Process Running"
    style.fill: "#87CEEB"
    style.stroke: "#4169E1"
    
    user_code: {
      label: |md
        c
        // Process 2 resumes here!
        // Has no idea it was suspended
        void user_main() {
            int count = 0;  // preserved!
            while(1) {
                count++;
                yield();  // back to kernel
            }
        }
        
      |
      shape: code
    }
  }
  
  note7: |md
    **IRET is Atomic:**
    1. Pops EIP, CS, EFLAGS
    2. If CS.RPL changes: pops ESP, SS
    3. Loads all in single operation
    4. No partial state possible
    
    **If returning to Ring 3:**
    - Stack switches to user ESP
    - SS loaded from stack
    - CPU clears CPL to 3
  |
  note7.style.fill: "#E0FFFF"
  
  iret_frame -> cpu_final: "iret" {
    style.stroke: green
    style.bold: true
    style.stroke-width: 3
    style.animated: true
  }
  
  cpu_final -> user_process: "execution\nresumes" {
    style.stroke: blue
    style.stroke-width: 2
  }
}

step1 -> step2 -> step3 -> step4 -> step5 -> step6 -> step7 {
  style.stroke: "#333"
  style.stroke-width: 4
}

legend: {
  near: bottom-center
  style.fill: "#F5F5F5"
  style.stroke: "#666"
  
  color_key: |md
    **Color Key:**
    ðŸŸ¡ Yellow: Interrupt source
    ðŸŸ£ Purple: CPU/Stack state
    ðŸŸ¢ Green: PCB/Success state
    ðŸ”´ Red: MODIFIED/Critical write
    ðŸ”µ Blue: User mode code
  |
}