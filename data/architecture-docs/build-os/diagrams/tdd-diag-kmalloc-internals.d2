vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Kernel Heap Block Structure
  sizeof(kheap_block_t) = 24 bytes
| {near: top-center}

direction: right

legend: {
  near: top-right
  Header: {
    style.fill: "#9B7ED9"
    style.stroke: "#6B4FB5"
    width: 80
  }
  Data: {
    style.fill: "#4A90D9"
    style.stroke: "#2E6BB0"
    width: 80
  }
  Free: {
    style.fill: "#5CB85C"
    style.stroke: "#3D8B3D"
    width: 80
  }
  Padding: {
    style.fill: "#888888"
    style.stroke: "#666666"
    width: 80
  }
  Pointers: {
    style.fill: "#E67E22"
    style.stroke: "#C45C00"
    width: 80
  }
}

memory_layout: {
  label: ""
  
  block_header: "Block Header" {
    style.fill: "#9B7ED9"
    style.stroke: "#6B4FB5"
    width: 600
    
    offset_00: "**0x00**" {
      shape: text
    }
    
    magic: "magic: uint32_t\n0xHEAP = 0x48454150" {
      width: 560
      style.fill: "#9B7ED9"
    }
    
    offset_04: "**0x04**" {
      shape: text
    }
    
    size: "size: uint32_t\npayload bytes (aligned)" {
      width: 560
      style.fill: "#9B7ED9"
    }
    
    offset_08: "**0x08**" {
      shape: text
    }
    
    flags: "flags: uint32_t\nBIT 0: is_free\nBIT 1-31: reserved" {
      width: 560
      style.fill: "#9B7ED9"
    }
    
    offset_0C: "**0x0C**" {
      shape: text
    }
    
    prev: "prev: kheap_block_t*\nprevious block in list" {
      width: 560
      style.fill: "#E67E22"
    }
    
    offset_10: "**0x10**" {
      shape: text
    }
    
    next: "next: kheap_block_t*\nnext block in list" {
      width: 560
      style.fill: "#E67E22"
    }
    
    offset_14: "**0x14**" {
      shape: text
    }
  }
  
  payload_section: "Payload Area" {
    width: 600
    
    offset_14_data: "**0x14**" {
      shape: text
    }
    
    allocated_payload: "user_data: uint8_t[size]\n(aligned to 16 bytes)" {
      width: 560
      style.fill: "#4A90D9"
    }
  }
  
  free_payload: "Free Block Payload" {
    width: 600
    
    free_data: "(contains free list linkage\nor zeroed memory)" {
      width: 560
      style.fill: "#5CB85C"
    }
  }
}

total_size: |md
  **Total: 24 bytes header + N bytes payload**
| {near: bottom-center}

cache_line: {
  near: bottom-center
  width: 640
  height: 4
  style.stroke-dash: 4
  style.stroke: "#FF6B6B"
  style.fill: transparent
}

cache_line_label: |md
  ─── 64-byte cache line boundary ───
|

allocation_algorithm: {
  label: "Allocation Algorithm"
  
  step1: "1. ALLOCATE(request_size)" {
    style.fill: "#E8F4FD"
    width: 300
  }
  
  step1a: "1a. Align size to 16 bytes" {
    style.fill: "#E8F4FD"
    width: 300
  }
  
  step2: "2. Find free block (first-fit)" {
    style.fill: "#E8F4FD"
    width: 300
  }
  
  step3: "3. Block found?" {
    shape: diamond
    style.fill: "#FFF3CD"
    width: 120
  }
  
  step4_yes: "4a. Check: remaining >= min_block" {
    style.fill: "#D4EDDA"
    width: 300
  }
  
  step5_split: "5. SPLIT block:" {
    style.fill: "#D4EDDA"
    width: 300
    
    split_detail: |md
      - new_size = request + 24
      - remaining = block.size - new_size
      - create new_block at offset
      - block.size = request
      - insert new_block after
    |
  }
  
  step4_no: "4b. No suitable block" {
    style.fill: "#F8D7DA"
    width: 300
  }
  
  step5_expand: "5. Expand heap:" {
    style.fill: "#F8D7DA"
    width: 300
    
    expand_detail: |md
      - alloc_pages(needed)
      - create new block
      - coalesce with tail
    |
  }
  
  step6: "6. Mark ALLOCATED" {
    style.fill: "#D4EDDA"
    width: 300
  }
  
  step7: "7. Return ptr + 24" {
    style.fill: "#D4EDDA"
    width: 300
  }
  
  step1 -> step1a -> step2 -> step3
  step3 -> step4_yes: "YES"
  step3 -> step4_no: "NO"
  step4_yes -> step5_split: "YES"
  step4_yes -> step6: "NO (too small)"
  step4_no -> step5_expand -> step6
  step5_split -> step6 -> step7
}

free_algorithm: {
  label: "Free Algorithm"
  
  f1: "1. FREE(ptr)" {
    style.fill: "#D4EDDA"
    width: 300
  }
  
  f2: "2. block = ptr - 24" {
    style.fill: "#D4EDDA"
    width: 300
  }
  
  f3: "3. Validate magic" {
    style.fill: "#D4EDDA"
    width: 300
  }
  
  f4: "4. Mark FREE" {
    style.fill: "#5CB85C"
    width: 300
  }
  
  f5: "5. Coalesce:" {
    style.fill: "#5CB85C"
    width: 300
    
    coalesce_detail: |md
      - if prev->is_free: merge
      - if next->is_free: merge
      - update all pointers
    |
  }
  
  f6: "6. Return" {
    style.fill: "#5CB85C"
    width: 300
  }
  
  f1 -> f2 -> f3 -> f4 -> f5 -> f6
}

split_example: {
  label: "Split Example (32-byte request from 128-byte block)"
  
  before: "BEFORE" {
    width: 400
    style.stroke: "#333"
    
    b1_header: "HDR" {
      style.fill: "#9B7ED9"
      width: 40
    }
    b1_free: "FREE (128 bytes)" {
      style.fill: "#5CB85C"
      width: 340
    }
  }
  
  arrow_down: {
    shape: text
    label: "↓ split"
  }
  
  after: "AFTER" {
    width: 400
    style.stroke: "#333"
    
    b2_header: "HDR" {
      style.fill: "#9B7ED9"
      width: 24
    }
    b2_alloc: "ALLOC\n(32)" {
      style.fill: "#4A90D9"
      width: 96
    }
    b3_header: "HDR" {
      style.fill: "#9B7ED9"
      width: 24
    }
    b3_free: "FREE\n(72)" {
      style.fill: "#5CB85C"
      width: 256
    }
  }
  
  before -> arrow_down -> after
}

coalesce_example: {
  label: "Coalesce Example (free middle block)"
  
  c_before: "BEFORE" {
    width: 400
    
    c1: "ALLOC" {style.fill: "#4A90D9"; width: 100}
    c2: "FREE" {style.fill: "#5CB85C"; width: 100}
    c3: "ALLOC\n(freeing)" {style.fill: "#4A90D9"; width: 100}
    c4: "FREE" {style.fill: "#5CB85C"; width: 100}
  }
  
  c_arrow: {
    shape: text
    label: "↓ coalesce"
  }
  
  c_after: "AFTER" {
    width: 400
    
    ca1: "ALLOC" {style.fill: "#4A90D9"; width: 100}
    ca2: "FREE (merged)" {style.fill: "#5CB85C"; width: 300}
  }
  
  c_before -> c_arrow -> c_after
}

struct_def: {
  label: "C Structure Definition"
  
  code: |c
    typedef struct kheap_block {
        uint32_t magic;      // 0x48454150 "HEAP"
        uint32_t size;       // payload size (16-byte aligned)
        uint32_t flags;      // bit 0: is_free
        struct kheap_block *prev;
        struct kheap_block *next;
    } __attribute__((packed)) kheap_block_t;
    
    // Minimum block size: 24 (header) + 16 (min payload) = 40 bytes
  |
}