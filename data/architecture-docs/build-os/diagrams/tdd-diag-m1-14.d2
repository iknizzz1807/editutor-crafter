direction: right
title: |md
  # A20 Line Enable Methods
  Three methods with fallback logic for enabling the A20 address line
|
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
classes: {
  method: {
    style: {
      fill: "#E8F4FD"
      stroke: "#2E86AB"
      stroke-width: 2
      border-radius: 8
    }
  }
  success: {
    style: {
      fill: "#D4EDDA"
      stroke: "#28A745"
      stroke-width: 2
    }
  }
  fallback: {
    style: {
      fill: "#FFF3CD"
      stroke: "#FFC107"
      stroke-width: 2
      stroke-dash: 4
    }
  }
  check: {
    shape: diamond
    style: {
      fill: "#F8D7DA"
      stroke: "#DC3545"
    }
  }
}
START: ● {
  near: top-left
}
STEP1: "Method 1: BIOS INT 15h" {
  class: method
  near: top-center
}
STEP1_DETAIL: |md
  asm
  mov ax, 0x2401
  int 0x15
  
  - Cleanest method
  - Requires BIOS support
  - May not work on all systems
|
CHECK1: "check_a20()" {
  class: check
}
STEP1_SUCCESS: "A20 Enabled ✓" {
  class: success
}
STEP2: "Method 2: Fast A20 (Port 0x92)" {
  class: fallback
}
STEP2_DETAIL: |md
  asm
  in al, 0x92
  or al, 2      ; Set A20 bit
  and al, 0xFE  ; Clear reset
  out 0x92, al
  
  - Direct hardware access
  - Faster than keyboard
  - Not universally supported
|
CHECK2: "check_a20()" {
  class: check
}
STEP2_SUCCESS: "A20 Enabled ✓" {
  class: success
}
STEP3: "Method 3: Keyboard Controller" {
  class: fallback
}
STEP3_DETAIL: |md
  asm
  ; Wait for input buffer empty
  wait1: in al, 0x64
         test al, 2
         jnz wait1
  ; Send read command
  mov al, 0xD0
  out 0x64, al
  ; Read output port
  wait2: in al, 0x64
         test al, 1
         jz wait2
  in al, 0x60
  ; Set A20 bit and write back
  or al, 2
  mov ah, al
  mov al, 0xD1
  out 0x64, al
  
  - Most reliable method
  - Slow (many port waits)
  - Works on all systems
|
CHECK3: "check_a20()" {
  class: check
}
STEP3_SUCCESS: "A20 Enabled ✓" {
  class: success
}
FAIL: "All Methods Failed\n(Continue anyway - some\nemulators don't need A20)" {
  style: {
    fill: "#F5F5F5"
    stroke: "#6C757D"
    stroke-dash: 3
  }
}
DONE: "Proceed to\nProtected Mode" {
  class: success
  near: bottom-center
}
START -> STEP1
STEP1 -> STEP1_DETAIL
STEP1_DETAIL -> CHECK1: "Execute BIOS call"
CHECK1 -> STEP1_SUCCESS: "A20=1"
CHECK1 -> STEP2: "A20=0 (BIOS failed)"
STEP2 -> STEP2_DETAIL
STEP2_DETAIL -> CHECK2: "Execute port 0x92"
CHECK2 -> STEP2_SUCCESS: "A20=1"
CHECK2 -> STEP3: "A20=0 (Fast A20 failed)"
STEP3 -> STEP3_DETAIL
STEP3_DETAIL -> CHECK3: "Execute KBC sequence"
CHECK3 -> STEP3_SUCCESS: "A20=1"
CHECK3 -> FAIL: "A20=0 (KBC failed)"
STEP1_SUCCESS -> DONE
STEP2_SUCCESS -> DONE
STEP3_SUCCESS -> DONE
FAIL -> DONE
check_a20_logic: |md
  **check_a20() Algorithm:**
  1. Write different values to 0x0000:0x0500 and 0xFFFF:0x0510
  2. If A20 disabled: both map to same physical address (wraparound)
  3. If A20 enabled: different physical addresses, values differ
  4. Return 1 if different (A20 on), 0 if same (A20 off)
| {
  near: bottom-right
  style.fill: "#FFF8E1"
  style.stroke: "#FF8F00"
}