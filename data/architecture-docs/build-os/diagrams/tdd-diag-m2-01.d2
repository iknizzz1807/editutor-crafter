direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Interrupt Handler Lifecycle
  Complete CPU → Handler → Return Sequence
| {near: top-center}
hardware: {
  style.fill: "#F8E6FF"
  style.stroke: "#9B4DCA"
  cpu_interrupt: "CPU Interrupt\nDetection" {
    shape: hexagon
    style.fill: "#E8D4F8"
  }
  pic: "PIC\n(8259)" {
    shape: diamond
    style.fill: "#E8D4F8"
  }
  cpu_interrupt -> pic: "IRQ Signal"
}
cpu_auto: "CPU Automatic\nOperations" {
  style.fill: "#E6F3FF"
  style.stroke: "#0066CC"
  finish_insn: "1. Finish Current\nInstruction" {
    style.fill: "#CCE5FF"
  }
  push_eflags: "2. Push EFLAGS\n(4 bytes)" {
    style.fill: "#CCE5FF"
  }
  push_cs: "3. Push CS\n(4 bytes)" {
    style.fill: "#CCE5FF"
  }
  push_eip: "4. Push EIP\n(4 bytes)" {
    style.fill: "#CCE5FF"
  }
  push_err: "5. Push Error Code\n(if applicable, 0-4 bytes)" {
    style.fill: "#FFE6CC"
    style.stroke: "#FF9900"
  }
  finish_insn -> push_eflags -> push_cs -> push_eip -> push_err
}
idt: "IDT Lookup" {
  style.fill: "#E6FFE6"
  style.stroke: "#009900"
  idt_array: "IDT[Vector]\n(8 bytes each)" {
    shape: cylinder
    style.fill: "#CCFFCC"
  }
  extract_handler: "Extract:\n• Handler Address\n• Segment Selector\n• Gate Type" {
    style.fill: "#CCFFCC"
  }
  idt_array -> extract_handler: "Index by\nVector 0-255"
}
handler_entry: "Handler Entry\n(Assembly Stub)" {
  style.fill: "#FFF0E6"
  style.stroke: "#FF6600"
  push_segments: "push gs, fs, es, ds\n(Segment Registers)" {
    style.fill: "#FFE0CC"
  }
  pusha: "pusha\n(8 GPRs: edi,esi,ebp,\nesp,ebx,edx,ecx,eax)" {
    style.fill: "#FFE0CC"
  }
  load_kernel: "mov ax, 0x10\nmov ds, ax (kernel data)" {
    style.fill: "#FFE0CC"
  }
  push_segments -> pusha -> load_kernel
}
c_handler: "C Handler\nExecution" {
  style.fill: "#E6FFFF"
  style.stroke: "#00CCCC"
  call_c: "call isr_common_handler\nor irq_common_handler" {
    style.fill: "#CCFFFF"
  }
  handler_work: "Handler Work:\n• Process interrupt\n• Read I/O ports\n• Update state" {
    style.fill: "#CCFFFF"
  }
  call_c -> handler_work
}
exit: "Exit Sequence\n(Assembly)" {
  style.fill: "#FFE6E6"
  style.stroke: "#CC0000"
  send_eoi: "Send EOI to PIC\n(if IRQ, outb 0x20)" {
    style.fill: "#FFCCCC"
    style.font-color: "#CC0000"
    style.bold: true
  }
  pop_segments: "pop gs, fs, es, ds\n(Restore Segments)" {
    style.fill: "#FFCCCC"
  }
  popa: "popa\n(Restore 8 GPRs)" {
    style.fill: "#FFCCCC"
  }
  skip_err: "add esp, 8\n(Skip int_no, err_code)" {
    style.fill: "#FFCCCC"
  }
  iret: "iret\n(Load EIP, CS, EFLAGS\nOptionally ESP, SS)" {
    style.fill: "#FF9999"
    style.font-color: "#990000"
    style.bold: true
  }
  send_eoi -> pop_segments -> popa -> skip_err -> iret
}
resume: "Resume\nInterrupted Code" {
  style.fill: "#E6FFE6"
  style.stroke: "#009900"
  resume_box: "Original Code\nContinues Execution" {
    shape: oval
    style.fill: "#CCFFCC"
  }
}
hardware.cpu_interrupt -> cpu_auto.finish_insn: "Trigger"
cpu_auto.push_err -> idt.idt_array: "Vector Lookup"
idt.extract_handler -> handler_entry.push_segments: "Jump to Handler"
handler_entry.load_kernel -> c_handler.call_c: "Call C"
c_handler.handler_work -> exit.send_eoi: "Return"
exit.iret -> resume.resume_box: "Return to\nInterrupted Code"
stack_layout: |md
  ## Stack Layout (grows down)
  High Addresses
  ┌─────────────────┐
  │ SS (if R3→R0)   │
  │ User ESP        │
  ├─────────────────┤
  │ EFLAGS          │ ← CPU pushed
  │ CS              │
  │ EIP             │
  │ Error Code      │ ← (conditional)
  ├─────────────────┤
  │ INT Number      │ ← Stub pushed
  │ EAX-EDI (pusha) │
  │ DS,ES,FS,GS     │
  └─────────────────┘ ← ESP
  Low Addresses
| {near: bottom-center}
legend: {
  near: bottom-right
  style.fill: "#F5F5F5"
  auto: "CPU Automatic" {style.fill: "#CCE5FF"}
  stub: "Assembly Stub" {style.fill: "#FFE0CC"}
  c_code: "C Handler" {style.fill: "#CCFFFF"}
  exit_code: "Exit/Cleanup" {style.fill: "#FFCCCC"}
  critical: "CRITICAL" {
    style.fill: "#FF9999"
    style.font-color: "#990000"
  }
}