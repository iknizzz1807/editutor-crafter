vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # PS/2 Keyboard: Scancode to ASCII Pipeline
  **IRQ1 → Port 0x60 → Extended Check → Release Check → Modifier Handling → ASCII Lookup → Buffer**
| {near: top-center}
direction: right
classes: {
  hardware: {
    style: {
      fill: "#E8D4F0"
      stroke: "#7B4B94"
      stroke-width: 2
      font-color: "#4A2C5A"
    }
  }
  interrupt: {
    style: {
      fill: "#FFE4B5"
      stroke: "#CC8800"
      stroke-width: 2
      font-color: "#805500"
    }
  }
  decode: {
    style: {
      fill: "#B5D8EB"
      stroke: "#2E75B6"
      stroke-width: 2
      font-color: "#1A4D6E"
    }
  }
  modifier: {
    style: {
      fill: "#C5E0B4"
      stroke: "#548235"
      stroke-width: 2
      font-color: "#375623"
    }
  }
  output: {
    style: {
      fill: "#F8CBAD"
      stroke: "#C55A11"
      stroke-width: 2
      font-color: "#833C0C"
    }
  }
  decision: {
    shape: diamond
    width: 120
    height: 80
    style: {
      fill: "#FFF2CC"
      stroke: "#BF8F00"
      stroke-width: 2
    }
  }
  buffer_box: {
    shape: cylinder
    style: {
      fill: "#DBEEF3"
      stroke: "#2E75B6"
      stroke-width: 2
    }
  }
}
# Hardware Layer
keyboard_controller: "Keyboard\nController\n(8042)" {
  class: hardware
  port_0x64: "Status Port\n0x64"
  port_0x60: "Data Port\n0x60"
}
# Interrupt Entry
irq1: "IRQ1\n(Keyboard\nInterrupt)" {
  class: interrupt
}
# Read Stage
read_scancode: "Read Scancode\nfrom Port 0x60\n\n`inb(0x60)`" {
  class: hardware
}
# Extended Scancode Check
extended_check: "Extended\nPrefix?" {
  class: decision
}
extended_handler: "Set Extended\nFlag = 1\nReturn for\nnext byte" {
  class: decode
}
# Release Check
release_check: "Key\nReleased?\n(bit 7)" {
  class: decision
}
release_handler: "Update Modifier\nState (if modifier)\nReturn" {
  class: modifier
}
# Modifier Key Check
modifier_check: "Modifier\nKey?" {
  class: decision
}
modifier_update: "Update Modifier\nState:\n• Shift\n• Ctrl\n• Alt\n• Caps Lock" {
  class: modifier
}
# ASCII Lookup
ascii_lookup: "ASCII Lookup\n\nSelect table:\n• Normal\n• Shifted\n\n`scancode_to_ascii[]`" {
  class: decode
}
# Valid Character Check
valid_check: "Valid\nASCII?" {
  class: decision
}
# Buffer Store
buffer_store: "Store in\nCircular Buffer\n\n`kb_buffer[write_pos]`" {
  class: output
}
# Final Buffer
keyboard_buffer: "Keyboard\nBuffer\n(256 bytes)" {
  class: buffer_box
  shape: cylinder
}
# Connections
keyboard_controller -> irq1: "Key pressed\nscancode ready" {
  style.stroke: "#7B4B94"
  style.stroke-width: 2
}
irq1 -> read_scancode: "Interrupt\nHandler" {
  style.stroke: "#CC8800"
  style.stroke-width: 2
  style.stroke-dash: 3
}
read_scancode -> extended_check: "scancode" {
  style.stroke: "#2E75B6"
}
extended_check -> extended_handler: "Yes\n(0xE0)" {
  style.stroke: "#BF8F00"
  style.stroke-width: 2
}
extended_check -> release_check: "No" {
  style.stroke: "#2E75B6"
}
release_check -> release_handler: "Yes\n(scancode & 0x80)" {
  style.stroke: "#BF8F00"
  style.stroke-width: 2
}
release_check -> modifier_check: "No\n(Key Press)" {
  style.stroke: "#2E75B6"
}
modifier_check -> modifier_update: "Yes\n(Shift/Ctrl/\nAlt/Caps)" {
  style.stroke: "#548235"
  style.stroke-width: 2
}
modifier_check -> ascii_lookup: "No\n(Character Key)" {
  style.stroke: "#2E75B6"
}
ascii_lookup -> valid_check: "ascii_char" {
  style.stroke: "#2E75B6"
}
valid_check -> buffer_store: "Yes\n(ascii != 0)" {
  style.stroke: "#C55A11"
  style.stroke-width: 2
}
valid_check -> end: "No\n(discard)" {
  style.stroke: "#BF8F00"
}
buffer_store -> keyboard_buffer: "write_pos++" {
  style.stroke: "#C55A11"
  style.stroke-width: 2
  style.animated: true
}
end: "End\nHandler" {
  shape: circle
  style.fill: "#E0E0E0"
}
extended_handler -> end: "return" {
  style.stroke-dash: 3
}
release_handler -> end: "return" {
  style.stroke-dash: 3
}
modifier_update -> end: "return" {
  style.stroke-dash: 3
}
buffer_store -> end: "return" {
  style.stroke-dash: 3
}
# Legend
legend: {
  near: bottom-center
  label: ""
  hw_legend: "Hardware" {class: hardware}
  int_legend: "Interrupt" {class: interrupt}
  dec_legend: "Decode" {class: decode}
  mod_legend: "Modifier" {class: modifier}
  out_legend: "Output" {class: output}
  hw_legend -> int_legend -> dec_legend -> mod_legend -> out_legend {
    style.opacity: 0
  }
}
# Data flow annotation
annotation: |md
  **Scancode Flow:**
  1. IRQ1 fires when keyboard data ready
  2. Read byte from port 0x60
  3. Check for extended prefix (0xE0)
  4. Check release bit (0x80)
  5. Handle modifier keys (Shift, Ctrl, Alt, Caps)
  6. Lookup ASCII using scancode table
  7. Store valid characters in circular buffer
| {near: bottom-right}