vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Frame Allocation Algorithm
  Linear scan → find clear bit → set bit → return address
| {near: top-center}
direction: right
# Step 1: Initialize scan
step1: {
  label: "Step 1: Initialize Scan"
  style.fill: "#E8E8E8"
  state: |md
    **State Before:**
    - `first_free = 256` (hint)
    - `total_frames = N`
    - `frame = first_free`
  |
  code: |md
    c
    for (frame = first_free; 
         frame < total_frames; 
         frame++)
    
  |
  note1: |md
    **Time Complexity:**
    - O(n) worst case
    - O(1) typical with hint
  |
  note1.shape: text
  note1.style.font-size: 14
}
# Step 2: Check bit
step2: {
  label: "Step 2: Test Bitmap Bit"
  style.fill: "#FFF9C4"
  state: |md
    **Checking frame `i`:**
    - `BITMAP_TEST(frame)`
    - Returns 0 if FREE
    - Returns 1 if USED
  |
  decision: {
    shape: diamond
    label: "Bit == 0\n(FREE)?"
  }
}
# Step 3a: Found free frame
step3a: {
  label: "Step 3a: Mark as Used"
  style.fill: "#C8E6C9"
  style.stroke: "#2E7D32"
  style.stroke-width: 3
  style.bold: true
  state: |md
    **CHANGED (green):**
    - `BITMAP_SET(frame)`
    - `free_count--`
    - `first_free = frame + 1`
  |
  code: |md
    c
    BITMAP_SET(frame);
    free_count--;
    first_free = frame + 1;
    return FRAME_TO_ADDR(frame);
    
  |
  note2: |md
    **CRITICAL:**
    - Frame must be 4KB aligned
    - Update hint for next alloc
  |
  note2.shape: text
  note2.style.font-size: 14
}
# Step 3b: Continue scanning
step3b: {
  label: "Step 3b: Continue Scan"
  style.fill: "#E8E8E8"
  state: |md
    **Frame already used:**
    - Increment `frame`
    - Continue loop
  |
}
# Step 4: Return
step4: {
  label: "Step 4: Return Frame Address"
  style.fill: "#C8E6C9"
  style.stroke: "#2E7D32"
  style.stroke-width: 3
  style.bold: true
  state: |md
    **Return Value:**
    - Physical address
    - `frame × 4096`
    - 4KB aligned
  |
  result: {
    shape: hexagon
    label: "Return:\nvoid* frame_addr"
    style.fill: "#81C784"
  }
}
# Wrap-around check
wraparound: {
  label: "Wrap-Around Check"
  style.fill: "#FFECB3"
  state: |md
    **If end reached:**
    - Reset `frame = 0`
    - Scan from beginning
    - To `first_free`
  |
}
# Out of memory
oom: {
  label: "Out of Memory"
  style.fill: "#FFCDD2"
  style.stroke: "#C62828"
  state: {
    shape: diamond
    label: "No free frame\nfound?"
    style.fill: "#FFCDD2"
  }
  null_return: {
    label: "Return NULL"
    style.fill: "#EF9A9A"
  }
}
# Bitmap visualization
bitmap_viz: {
  label: "Bitmap Visualization"
  style.fill: "#F5F5F5"
  style.stroke-dash: 3
  row0: {
    grid-columns: 8
    grid-gap: 2
    b0: {label: "1"; style.fill: "#FFCDD2"}
    b1: {label: "1"; style.fill: "#FFCDD2"}
    b2: {label: "0"; style.fill: "#C8E6C9"; style.stroke: "#2E7D32"; style.stroke-width: 3; style.bold: true}
    b3: {label: "1"; style.fill: "#FFCDD2"}
    b4: {label: "0"; style.fill: "#C8E6C9"}
    b5: {label: "1"; style.fill: "#FFCDD2"}
    b6: {label: "0"; style.fill: "#C8E6C9"}
    b7: {label: "1"; style.fill: "#FFCDD2"}
  }
  legend: |md
    **Legend:**
    - `1` = Used (red)
    - `0` = Free (green)
    - **Bold** = Selected frame
  |
}
# Connections
step1 -> step2: "scan frame i"
step2.decision -> step3a: "Yes\n(bit = 0)"
step2.decision -> step3b: "No\n(bit = 1)"
step3b -> step2: "frame++"
step3a -> step4: "allocate"
step4.result -> bitmap_viz: "address = i × 4KB"
step2 -> wraparound: "frame >= total?"
wraparound -> step2: "frame = 0"
wraparound -> oom.state: "scanned all?"
oom.state -> oom.null_return: "Yes"
oom.state -> step2: "No"