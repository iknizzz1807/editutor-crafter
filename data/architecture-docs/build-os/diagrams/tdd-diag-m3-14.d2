vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
classes: {
  step_box: {
    style: {
      fill: "#E3F2FD"
      stroke: "#1565C0"
      stroke-width: 2
      border-radius: 8
    }
  }
  decision: {
    shape: diamond
    style: {
      fill: "#FFF3E0"
      stroke: "#E65100"
      stroke-width: 2
    }
  }
  action: {
    style: {
      fill: "#E8F5E9"
      stroke: "#2E7D32"
      stroke-width: 2
      border-radius: 6
    }
  }
  error: {
    style: {
      fill: "#FFEBEE"
      stroke: "#C62828"
      stroke-width: 2
    }
  }
  arrow: {
    style: {
      stroke: "#37474F"
      stroke-width: 2
      font-size: 14
    }
  }
}
title: |md
  # kmalloc First-Fit Algorithm
  Kernel Heap Allocation Strategy
| {near: top-center}
direction: down
start: "kmalloc(size)" {
  class: step_box
  shape: oval
}
step1: "1. Validate size != 0" {
  class: step_box
}
decision1: "size == 0?" {
  class: decision
}
return_null: "return NULL" {
  class: error
}
step2: "2. Align size to 16 bytes\nsize = (size + 15) & ~15" {
  class: step_box
}
step3: "3. Initialize block = heap_first_block" {
  class: step_box
}
decision2: "block != NULL?" {
  class: decision
}
step4: "4. Validate magic number\nif (block->magic != HEAP_MAGIC)\n  PANIC" {
  class: step_box
}
decision3: "block->free &&\nblock->size >= size?" {
  class: decision
}
step5: "5. Move to next block\nblock = block->next" {
  class: action
}
decision_split: "block->size >= size +\nHEADER + MIN_BLOCK?" {
  class: decision
}
step6: |md
  **6. Split block**
  
  new_block = block + HEADER + size
  new_block->size = block->size - size - HEADER
  new_block->free = 1
  new_block->magic = HEAP_MAGIC
  new_block->next = block->next
  new_block->prev = block
  block->size = size
  
| {
  class: action
}
step7: "7. Mark block as used\nblock->free = 0\nheap_used += block->size + HEADER" {
  class: action
}
step8: "8. Return pointer\nreturn (void*)(block + HEADER)" {
  class: action
  shape: oval
  style.fill: "#C8E6C9"
}
step_expand: |md
  **9. Expand heap**
  - Calculate pages_needed
  - Map new pages at heap_end_virtual
  - Create/extend free block
| {
  class: step_box
}
decision_expand: "Heap space\navailable?" {
  class: decision
}
expand_fail: "return NULL\n(Out of memory)" {
  class: error
}
expand_success: "Add new block\nto heap list" {
  class: action
}
loop_back: "Retry allocation\nwith new block" {
  class: action
  style.fill: "#B3E5FC"
}
start -> step1 -> decision1
decision1 -> return_null: "Yes" {class: arrow}
decision1 -> step2: "No" {class: arrow}
step2 -> step3 -> decision2
decision2 -> step4: "Yes" {class: arrow}
step4 -> decision3
decision3 -> step5: "No" {class: arrow}
step5 -> decision2: "loop" {class: arrow; style.stroke-dash: 3}
decision3 -> decision_split: "Yes" {class: arrow}
decision_split -> step7: "No (too small)" {class: arrow}
decision_split -> step6: "Yes" {class: arrow}
step6 -> step7 -> step8
decision2 -> decision_expand: "No (end of list)" {class: arrow}
decision_expand -> expand_fail: "No" {class: arrow}
decision_expand -> expand_success: "Yes" {class: arrow}
expand_success -> loop_back -> decision2
legend: {
  near: bottom-right
  legend_title: "Legend" {
    style.font-size: 16
    style.bold: true
  }
  step_node: "Processing Step" {
    class: step_box
  }
  decision_node: "Decision Point" {
    class: decision
  }
  action_node: "Action/Modification" {
    class: action
  }
  error_node: "Error/Exit" {
    class: error
  }
}
annotations: |md
  **Algorithm Complexity:**
  - **Time:** O(n) worst case, n = number of blocks
  - **Space:** O(1) additional memory
  **Key Invariants:**
  - All blocks have valid HEAP_MAGIC
  - No two adjacent free blocks (after coalesce)
  - Returned pointer is 16-byte aligned
| {near: bottom-left}