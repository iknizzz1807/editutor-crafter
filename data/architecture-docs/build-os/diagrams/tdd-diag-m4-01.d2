vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Process Control Block (PCB) Memory Layout
  `sizeof(struct process) ≈ 88 bytes (cache-line aligned)`
| {near: top-center}
PCB: {
  style.fill: "#E8E8E8"
  style.stroke: "#666666"
  style.border-radius: 4
  header: {
    shape: rectangle
    style.fill: "#6B5B95"
    style.stroke: "#4A4A6A"
    style.font-color: white
    label: "struct process"
  }
  grid-rows: 11
  grid-columns: 4
  grid-gap: 0
  # Row 0: Identification
  f1: |md
    **pid**
    `uint32_t`
    `+0x00`
  | {style.fill: "#B8D4E3"; style.stroke: "#5B9BD5"}
  f1v: |md
    Process ID
    (1-65535)
    4 bytes
  | {style.fill: "#D6E9F8"; style.stroke: "#5B9BD5"}
  f2: |md
    **name[32]**
    `char[]`
    `+0x04`
  | {style.fill: "#B8D4E3"; style.stroke: "#5B9BD5"}
  f2v: |md
    Debug name
    null-terminated
    32 bytes
  | {style.fill: "#D6E9F8"; style.stroke: "#5B9BD5"}
  # Row 1: State
  f3: |md
    **state**
    `enum`
    `+0x24`
  | {style.fill: "#F8D7DA"; style.stroke: "#DC3545"}
  f3v: |md
    READY/RUNNING
    BLOCKED/ZOMBIE
    4 bytes
  | {style.fill: "#FCE4EC"; style.stroke: "#DC3545"}
  # Row 2: Scheduling
  f4: |md
    **priority**
    `int`
    `+0x28`
  | {style.fill: "#FFF3CD"; style.stroke: "#FFC107"}
  f4v: |md
    Higher = more CPU
    4 bytes
  | {style.fill: "#FFF9E6"; style.stroke: "#FFC107"}
  f5: |md
    **cpu_time**
    `uint64_t`
    `+0x2C`
  | {style.fill: "#FFF3CD"; style.stroke: "#FFC107"}
  f5v: |md
    Total ticks
    consumed
    8 bytes
  | {style.fill: "#FFF9E6"; style.stroke: "#FFC107"}
  f6: |md
    **wake_time**
    `uint64_t`
    `+0x34`
  | {style.fill: "#FFF3CD"; style.stroke: "#FFC107"}
  f6v: |md
    Tick to wake
    (if BLOCKED)
    8 bytes
  | {style.fill: "#FFF9E6"; style.stroke: "#FFC107"}
  # Row 3: CPU State - CRITICAL
  f7: |md
    **kernel_stack**
    `cpu_state*`
    `+0x3C`
  | {style.fill: "#D4EDDA"; style.stroke: "#28A745"; style.bold: true}
  f7v: |md
    **Saved regs**
    on kernel stack
    4 bytes
  | {style.fill: "#E8F5E9"; style.stroke: "#28A745"; style.bold: true}
  f8: |md
    **kernel_stack_top**
    `uint32_t`
    `+0x40`
  | {style.fill: "#D4EDDA"; style.stroke: "#28A745"; style.bold: true}
  f8v: |md
    **TSS.ESP0**
    value
    4 bytes
  | {style.fill: "#E8F5E9"; style.stroke: "#28A745"; style.bold: true}
  # Row 4: Memory
  f9: |md
    **page_directory**
    `page_dir*`
    `+0x44`
  | {style.fill: "#E2D5F1"; style.stroke: "#8E44AD"}
  f9v: |md
    CR3 value
    (address space)
    4 bytes
  | {style.fill: "#F3E5F5"; style.stroke: "#8E44AD"}
  # Row 5: Process tree
  f10: |md
    **parent_pid**
    `uint32_t`
    `+0x48`
  | {style.fill: "#D6D6D6"; style.stroke: "#666666"}
  f10v: |md
    Parent PID
    4 bytes
  | {style.fill: "#EEEEEE"; style.stroke: "#666666"}
  f11: |md
    **exit_code**
    `int`
    `+0x4C`
  | {style.fill: "#D6D6D6"; style.stroke: "#666666"}
  f11v: |md
    Exit status
    (if ZOMBIE)
    4 bytes
  | {style.fill: "#EEEEEE"; style.stroke: "#666666"}
  # Row 6: Queue linkage
  f12: |md
    **next**
    `process*`
    `+0x50`
  | {style.fill: "#FFE4B5"; style.stroke: "#FF8C00"}
  f12v: |md
    Next in
    run queue
    4 bytes
  | {style.fill: "#FFF8DC"; style.stroke: "#FF8C00"}
  f13: |md
    **prev**
    `process*`
    `+0x54`
  | {style.fill: "#FFE4B5"; style.stroke: "#FF8C00"}
  f13v: |md
    Prev in
    run queue
    4 bytes
  | {style.fill: "#FFF8DC"; style.stroke: "#FF8C00"}
}
legend: {
  near: bottom-center
  style.fill: transparent
  style.stroke: transparent
  grid-columns: 5
  grid-gap: 10
  l1: |md
    **Identification**
    Process identity
  | {style.fill: "#B8D4E3"; style.stroke: "#5B9BD5"}
  l2: |md
    **Scheduling**
    CPU allocation
  | {style.fill: "#FFF3CD"; style.stroke: "#FFC107"}
  l3: |md
    **CPU State** ⚠️
    Context switch
  | {style.fill: "#D4EDDA"; style.stroke: "#28A745"}
  l4: |md
    **Memory**
    Address space
  | {style.fill: "#E2D5F1"; style.stroke: "#8E44AD"}
  l5: |md
    **Queue**
    Run list links
  | {style.fill: "#FFE4B5"; style.stroke: "#FF8C00"}
}
kernel_stack_detail: {
  near: center-right
  style.fill: "#F5F5F5"
  style.stroke: "#999999"
  style.border-radius: 4
  title: |md
    ### kernel_stack points to:
  |
  stack_layout: {
    shape: rectangle
    style.fill: white
    style.stroke: "#666666"
    grid-rows: 10
    grid-gap: 0
    s0: |md
      `gs, fs, es, ds` → seg regs
    | {style.fill: "#E8F5E9"; style.stroke: "#28A745"}
    s1: |md
      `edi, esi, ebp, esp, ebx, edx, ecx, eax`
    | {style.fill: "#E8F5E9"; style.stroke: "#28A745"}
    s2: |md
      `int_no, err_code` → interrupt info
    | {style.fill: "#E8F5E9"; style.stroke: "#28A745"}
    s3: |md
      `eip, cs, eflags` → CPU pushed
    | {style.fill: "#C8E6C9"; style.stroke: "#2E7D32"}
    s4: |md
      `useresp, ss` → if ring 3→0
    | {style.fill: "#C8E6C9"; style.stroke: "#2E7D32"}
    s5: |md
      **↑ ESP points here**
    | {style.fill: "#FFCDD2"; style.stroke: "#C62828"; style.bold: true}
  }
  note: |md
    `kernel_stack_top` = base + 4096
    Used for **TSS.ESP0** on every switch
  | {style.fill: "#FFF9C4"; style.stroke: "#F9A825"}
}
PCB.f7 -> kernel_stack_detail.s5: {style.stroke: "#28A745"; style.stroke-dash: 3}
critical_note: |md
  ⚠️ **CRITICAL**: `kernel_stack` and `kernel_stack_top` must be correct
  or context switch corrupts process state. `kernel_stack_top` is used
  to set TSS.ESP0 before returning to user mode.
| {near: bottom-center; style.fill: "#FFEBEE"; style.stroke: "#C62828"}