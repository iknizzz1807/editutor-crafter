vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    header: "#9B59B6"
    data: "#3498DB"
    free: "#2ECC71"
    padding: "#95A5A6"
    pointer: "#E67E22"
    critical: "#E74C3C"
    reserved: "#7F8C8D"
  }
}
title: |md
  # Task State Segment (TSS)
  ## 32-bit x86 Structure (104 bytes)
| {near: top-center}
direction: right
tss_structure: {
  label: "TSS Memory Layout\n104 bytes total"
  style.fill: "${colors.data}"
  style.stroke: "#2980B9"
  # Offset 0x00 - Link field
  link_field: {
    label: |md
      **0x00-0x03: Link**
      ────────────────
      Task link (backlink)
      Used for task switches
    |
    style.fill: "${colors.padding}"
  }
  # Offset 0x04 - CRITICAL ESP0
  esp0: {
    label: |md
      **0x04-0x07: ESP0** ⚠️
      ────────────────
      **Kernel Stack Pointer**
      for Ring 0
      Updated on EVERY
      context switch!
    |
    style.fill: "${colors.critical}"
    style.stroke: "#C0392B"
    style.bold: true
  }
  # Offset 0x08 - CRITICAL SS0
  ss0: {
    label: |md
      **0x08-0x0B: SS0** ⚠️
      ────────────────
      **Kernel Stack Segment**
      = 0x10 (kernel data)
    |
    style.fill: "${colors.critical}"
    style.stroke: "#C0392B"
    style.bold: true
  }
  # Offset 0x0C-0x1B - Ring 1 & 2 (unused)
  ring12: {
    label: |md
      **0x0C-0x1B: Ring 1 & 2**
      ────────────────
      ESP1, SS1, ESP2, SS2
      (Unused in modern OS)
    |
    style.fill: "${colors.reserved}"
  }
  # Offset 0x1C - CR3
  cr3: {
    label: |md
      **0x1C-0x1F: CR3**
      ────────────────
      Page Directory Base
      (for hardware task switch)
    |
    style.fill: "${colors.pointer}"
  }
  # Offset 0x20-0x44 - General registers
  gp_regs: {
    label: |md
      **0x20-0x44: General Registers**
      ────────────────────────────────
      EIP, EFLAGS
      EAX, ECX, EDX, EBX
      ESP, EBP, ESI, EDI
      (for hardware task switch)
    |
    style.fill: "${colors.data}"
  }
  # Offset 0x48-0x52 - Segment registers
  seg_regs: {
    label: |md
      **0x48-0x53: Segment Registers**
      ─────────────────────────────────
      ES, CS, SS, DS, FS, GS
      (for hardware task switch)
    |
    style.fill: "${colors.header}"
  }
  # Offset 0x54-0x57 - LDTR and I/O bitmap
  misc: {
    label: |md
      **0x54-0x67: Miscellaneous**
      ────────────────────────────
      LDTR (LDT selector)
      Trap flag
      I/O Map Base Address
    |
    style.fill: "${colors.reserved}"
  }
}
# Critical fields detail
critical_detail: {
  label: "CRITICAL FIELDS for Software Task Switch"
  style.fill: "#FDF2E9"
  style.stroke: "${colors.critical}"
  esp0_detail: {
    label: |md
      ### ESP0 (Offset 0x04)
      **Purpose**: Stack pointer for Ring 0
      **When Used**: CPU reads this on EVERY
      interrupt/syscall from Ring 3 (user mode)
      **Must Set**: On every context switch
      to the new process's kernel_stack_top
      **Failure Mode**: Triple fault on next
      user-mode interrupt
    |
    style.fill: "#FADBD8"
  }
  ss0_detail: {
    label: |md
      ### SS0 (Offset 0x08)
      **Purpose**: Stack segment for Ring 0
      **Value**: 0x10 (kernel data selector)
      **Set Once**: During TSS initialization
      **Format**: Segment selector with:
      - Index: 2 (GDT entry)
      - TI: 0 (GDT)
      - RPL: 0 (Ring 0)
    |
    style.fill: "#FADBD8"
  }
}
# GDT descriptor
gdt_entry: {
  label: "TSS GDT Descriptor (Entry 5, Selector 0x28)"
  style.fill: "${colors.header}"
  desc_layout: {
    label: |md
      **Access Byte: 0x89**
      ┌─────────────────────────────────┐
      │ P │ DPL │ S │ Type             │
      │ 1 │ 00  │ 0 │ 01001 (32-bit TSS)│
      └─────────────────────────────────┘
      **Flags: 0x0**
      G=0 (byte granularity)
      **Base**: Address of kernel_tss
      **Limit**: 103 (sizeof(TSS) - 1)
    |
  }
}
# Ring transition diagram
ring_transition: {
  label: "Ring 3 → Ring 0 Transition"
  style.fill: "#EBF5FB"
  user_mode: {
    label: "User Mode (Ring 3)"
    shape: rectangle
    style.fill: "#D5F5E3"
    user_stack: {
      label: "User Stack\n(SS:ESP from TSS)"
      shape: rectangle
      style.fill: "#A9DFBF"
    }
  }
  kernel_mode: {
    label: "Kernel Mode (Ring 0)"
    shape: rectangle
    style.fill: "#FADBD8"
    kernel_stack: {
      label: "Kernel Stack\n(SS0:ESP0 from TSS)"
      shape: rectangle
      style.fill: "#F5B7B1"
    }
  }
  interrupt: {
    label: "INT/Syscall"
    shape: diamond
    style.fill: "${colors.critical}"
  }
  user_mode.user_stack -> interrupt: "1. Interrupt occurs"
  interrupt -> kernel_mode.kernel_stack: "2. CPU loads SS0:ESP0\n   from TSS"
}
# Warning callout
warning: {
  label: |md
    ## ⚠️ COMMON BUG WARNING
    **Symptom**: System works once, crashes on
    next user-mode interrupt
    **Cause**: Forgot to update TSS.ESP0 after
    context switch
    **Fix**: ALWAYS call `tss_set_kernel_stack()`
    BEFORE returning to user mode
  |
  near: top-right
  style.fill: "#FDEDEC"
  style.stroke: "${colors.critical}"
  style.stroke-width: 3
}
# Assembly example
code_example: {
  label: |md
    c
    // TSS update on context switch
    void context_switch(process_t *next) {
        // CRITICAL: Update TSS first!
        tss_set_kernel_stack(
            next->kernel_stack_top
        );
        // Then switch page directory
        if (next->page_directory != 
            current->page_directory) {
            load_cr3(next->page_directory);
        }
        // Finally switch stacks
        switch_to(&current->kernel_stack,
                  next->kernel_stack);
    }
  |
  near: bottom-center
  style.fill: "#F4F6F6"
  style.font: mono
}
# Connections
tss_structure.esp0 -> critical_detail.esp0_detail
tss_structure.ss0 -> critical_detail.ss0_detail