vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # TSS ESP0 Update on Context Switch
  Before returning to user mode, set TSS.ESP0 to current process's kernel_stack_top
|
direction: right
classes: {
  process_box: {
    style: {
      fill: "#E8F4FD"
      stroke: "#2E86AB"
      stroke-width: 2
    }
  }
  tss_box: {
    style: {
      fill: "#FFF3E0"
      stroke: "#E65100"
      stroke-width: 2
    }
  }
  action_box: {
    style: {
      fill: "#E8F5E9"
      stroke: "#2E7D32"
      stroke-width: 2
      bold: true
    }
  }
  danger_box: {
    style: {
      fill: "#FFEBEE"
      stroke: "#C62828"
      stroke-width: 2
    }
  }
}
step1: {
  class: process_box
  label: "Step 1: Timer Interrupt Triggers\nContext Switch"
  old_proc: "OLD PROCESS PCB\n\npid: 42\nstate: RUNNING\nkernel_stack: 0x9000\nkernel_stack_top: 0xA000"
  new_proc: "NEW PROCESS PCB\n\npid: 17\nstate: READY\nkernel_stack: 0x5000\nkernel_stack_top: 0x6000"
  old_proc -> new_proc: "scheduler_pick_next()"
}
step2: {
  class: tss_box
  label: "Step 2: TSS BEFORE Update\n(CRITICAL - Shows the problem)"
  tss_before: "kernel_tss {\n  ss0: 0x10\n  esp0: 0xA000  ← OLD!\n}"
  note_before: |md
    **DANGER**: TSS.ESP0 still points to
    OLD process's kernel stack!
    If interrupt fires from user mode
    before update, CPU uses wrong stack →
    CORRUPTION or TRIPLE FAULT
  |
  note_before.style.fill: "#FFCDD2"
}
step3: {
  class: action_box
  label: "Step 3: Update TSS.ESP0\n(MUST happen before switch)"
  tss_update: |md
    c
    // In scheduler_schedule():
    tss_set_kernel_stack(
      next->kernel_stack_top
    );
    // Assembly:
    mov eax, [next + offset]
    mov [kernel_tss + 4], eax
    
  |
  tss_after: "kernel_tss {\n  ss0: 0x10\n  esp0: 0x6000  ← NEW!\n}"
  tss_after.style.fill: "#C8E6C9"
  tss_update -> tss_after: "stores"
}
step4: {
  class: action_box
  label: "Step 4: Complete Context Switch"
  operations: |md
    1. Save old ESP to old PCB
       `old->kernel_stack = regs`
    2. Load new ESP from new PCB
       `switch_to(&old->kernel_stack,
                  new->kernel_stack)`
    3. Update current_process pointer
       `current_process = new`
    4. Switch page directory if needed
       `if (old->pd != new->pd)
           paging_load_directory(new->pd)`
  |
}
step5: {
  class: process_box
  label: "Step 5: New Process Runs"
  new_running: "NEW PROCESS PCB\n\npid: 17\nstate: RUNNING\nkernel_stack: 0x5000\nkernel_stack_top: 0x6000"
  new_running.style.fill: "#C8E6C9"
}
step6: {
  class: tss_box
  label: "Step 6: Safe User→Kernel Transition"
  tss_final: "kernel_tss {\n  ss0: 0x10\n  esp0: 0x6000 ✓\n}"
  safe_note: |md
    When interrupt/syscall from user mode:
    1. CPU reads TSS.SS0:ESP0
    2. Gets 0x10:0x6000 (correct!)
    3. Saves user SS:ESP to kernel stack
    4. Loads kernel SS:ESP from TSS
    5. Jumps to interrupt handler
    **Safe** - uses correct kernel stack
  |
  safe_note.style.fill: "#C8E6C9"
}
step1 -> step2 -> step3 -> step4 -> step5 -> step6
warning_box: {
  class: danger_box
  label: "⚠️ COMMON BUG: Forgetting TSS.ESP0 Update"
  warning_content: |md
    **Symptom**: User process runs once, crashes on next interrupt
    **Cause**: TSS.ESP0 not updated after context switch
    **Result**: CPU uses OLD process's kernel stack
    - Stack corruption
    - Random crashes
    - Triple fault on interrupt from user mode
    **Fix**: ALWAYS call `tss_set_kernel_stack()` 
    BEFORE `switch_to()` in scheduler
  |
}
warning_box.near: bottom-center