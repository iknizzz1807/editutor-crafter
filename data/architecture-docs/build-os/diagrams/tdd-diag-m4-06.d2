vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Round-Robin Scheduler: Process Queue
| {near: top-center}
classes: {
  pcb: {
    shape: rectangle
    style: {
      fill: "#E8F4FD"
      stroke: "#2196F3"
      stroke-width: 2
      font: mono
    }
  }
  running: {
    shape: rectangle
    style: {
      fill: "#C8E6C9"
      stroke: "#4CAF50"
      stroke-width: 3
      bold: true
    }
  }
  queue_label: {
    shape: text
    style: {
      font-size: 14
      italic: true
      font-color: "#666666"
    }
  }
  operation: {
    shape: rectangle
    style: {
      fill: "#FFF3E0"
      stroke: "#FF9800"
      stroke-width: 2
      border-radius: 4
    }
  }
  arrow_label: {
    shape: text
    style: {
      font-size: 12
      font-color: "#666666"
    }
  }
}
# Run Queue Container
run_queue: Run Queue (READY processes) {
  style: {
    fill: "#FAFAFA"
    stroke: "#9E9E9E"
    stroke-dash: 4
    border-radius: 8
  }
  head_label: "head →" {class: queue_label}
  tail_label: "← tail" {class: queue_label}
  # PCB nodes in queue
  proc1: |md
    **PCB: Process A**
    `pid: 1`
    `state: READY`
    `next: → proc2`
    `prev: NULL`
  | {class: pcb}
  proc2: |md
    **PCB: Process B**
    `pid: 2`
    `state: READY`
    `next: → proc3`
    `prev: ← proc1`
  | {class: pcb}
  proc3: |md
    **PCB: Process C**
    `pid: 3`
    `state: READY`
    `next: → proc4`
    `prev: ← proc2`
  | {class: pcb}
  proc4: |md
    **PCB: Process D**
    `pid: 4`
    `state: READY`
    `next: NULL`
    `prev: ← proc3`
  | {class: pcb}
  # Queue links
  proc1 -> proc2: "next" {
    class: arrow_label
    style.stroke: "#2196F3"
    style.stroke-width: 2
    target-arrowhead.shape: arrow
  }
  proc2 -> proc3: "next" {
    class: arrow_label
    style.stroke: "#2196F3"
    style.stroke-width: 2
    target-arrowhead.shape: arrow
  }
  proc3 -> proc4: "next" {
    class: arrow_label
    style.stroke: "#2196F3"
    style.stroke-width: 2
    target-arrowhead.shape: arrow
  }
  # Prev links (dashed)
  proc4 -> proc3: "prev" {
    class: arrow_label
    style.stroke: "#90CAF9"
    style.stroke-dash: 3
    target-arrowhead.shape: arrow
  }
  proc3 -> proc2: "prev" {
    class: arrow_label
    style.stroke: "#90CAF9"
    style.stroke-dash: 3
    target-arrowhead.shape: arrow
  }
  proc2 -> proc1: "prev" {
    class: arrow_label
    style.stroke: "#90CAF9"
    style.stroke-dash: 3
    target-arrowhead.shape: arrow
  }
}
# Current Running Process (outside queue)
current_process: |md
  **CURRENT PROCESS**
  **PCB: Process X**
  `pid: 5`
  `state: RUNNING`
  `next: NULL`
  `prev: NULL`
  `kernel_stack: 0x...`
  `page_directory: 0x...`
| {
  class: running
  near: center-right
}
# Head/Tail pointers
head_ptr: "run_queue_head" {
  shape: rectangle
  style: {
    fill: "#FFECB3"
    stroke: "#FFA000"
    font: mono
    font-size: 11
  }
}
tail_ptr: "run_queue_tail" {
  shape: rectangle
  style: {
    fill: "#FFECB3"
    stroke: "#FFA000"
    font: mono
    font-size: 11
  }
}
head_ptr -> run_queue.proc1: "points to" {
  style.stroke: "#FFA000"
  style.stroke-dash: 2
  target-arrowhead.shape: arrow
}
tail_ptr -> run_queue.proc4: "points to" {
  style.stroke: "#FFA000"
  style.stroke-dash: 2
  target-arrowhead.shape: arrow
}
# Global current pointer
current_ptr: "current_process" {
  shape: rectangle
  style: {
    fill: "#C8E6C9"
    stroke: "#4CAF50"
    font: mono
    font-size: 11
    bold: true
  }
}
current_ptr -> current_process: "points to" {
  style.stroke: "#4CAF50"
  style.stroke-width: 2
  target-arrowhead.shape: arrow
}
# Queue Operations
operations: Queue Operations {
  style: {
    fill: "#FFF8E1"
    stroke: "#FFC107"
    border-radius: 8
  }
  enqueue: |md
    **add_to_queue(proc)**
    proc.next = NULL
    if tail == NULL:
      head = tail = proc
      proc.prev = NULL
    else:
      tail.next = proc
      proc.prev = tail
      tail = proc
  | {class: operation}
  dequeue: |md
    **pick_next()**
    if head == NULL:
      return current
    next = head
    head = head.next
    if head == NULL:
      tail = NULL
    else:
      head.prev = NULL
    next.state = RUNNING
    return next
  | {class: operation}
  enqueue -> dequeue: "then" {
    style.stroke: "#FFC107"
    style.stroke-dash: 3
  }
}
# State transition flow
state_flow: Process State Flow {
  style: {
    fill: transparent
    stroke: "#9E9E9E"
    stroke-dash: 2
  }
  ready_state: "READY\n(in queue)" {
    shape: circle
    style: {
      fill: "#E8F4FD"
      stroke: "#2196F3"
    }
  }
  running_state: "RUNNING\n(current)" {
    shape: circle
    style: {
      fill: "#C8E6C9"
      stroke: "#4CAF50"
      bold: true
    }
  }
  ready_state -> running_state: "scheduler_pick_next()" {
    style.stroke: "#4CAF50"
    style.stroke-width: 2
    target-arrowhead.shape: arrow
  }
  running_state -> ready_state: "time slice expired\n(move to tail)" {
    style.stroke: "#2196F3"
    style.stroke-width: 2
    target-arrowhead.shape: arrow
  }
}
# Annotations
annotation: |md
  **Round-Robin Scheduling Rules:**
  1. Each process gets equal time slice (e.g., 100ms)
  2. On expiry, current → moved to queue tail
  3. Head of queue → becomes new RUNNING
  4. If queue empty, current continues
  5. New processes added to queue tail
  **Time Complexity:** O(1) for all operations
| {
  near: bottom-center
  shape: rectangle
  style: {
    fill: "#F5F5F5"
    stroke: "#BDBDBD"
    border-radius: 4
    font-size: 12
  }
}