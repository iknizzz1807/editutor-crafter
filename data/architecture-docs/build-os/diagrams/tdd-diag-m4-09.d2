vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Kernel Process Creation Algorithm
  **Four-Phase Initialization Sequence**
|
classes: {
  step_box: {
    style: {
      fill: "#E8F4FD"
      stroke: "#2E86AB"
      stroke-width: 2
      border-radius: 8
      font-size: 14
    }
  }
  pcb: {
    style: {
      fill: "#FFF3E0"
      stroke: "#E65100"
      stroke-width: 2
    }
  }
  stack: {
    style: {
      fill: "#E8F5E9"
      stroke: "#2E7D32"
      stroke-width: 2
    }
  }
  cpu_state: {
    style: {
      fill: "#F3E5F5"
      stroke: "#7B1FA2"
      stroke-width: 2
    }
  }
  queue: {
    style: {
      fill: "#FFEBEE"
      stroke: "#C62828"
      stroke-width: 2
    }
  }
  arrow: {
    style: {
      stroke: "#1565C0"
      stroke-width: 2
      animated: true
    }
  }
}
direction: right
Phase_1: {
  label: "Phase 1: PCB Allocation"
  class: step_box
  step1: {
    label: |md
      **process_find_free()**
      
      for i in 0..MAX_PROCESSES:
        if process_table[i].state == UNUSED:
          return &process_table[i]
      return NULL
      
    |
    class: pcb
  }
  step1_result: {
    label: |md
      **PCB Slot Acquired**
      
      proc->pid = next_pid++
      proc->state = READY
      proc->parent_pid = current->pid
      strncpy(proc->name, name, 31)
      
    |
    class: pcb
  }
  step1 -> step1_result: "Slot found" {
    class: arrow
  }
}
Phase_2: {
  label: "Phase 2: Stack Allocation"
  class: step_box
  step2: {
    label: |md
      **Allocate 4KB Kernel Stack**
      c
      void *stack_frame = frame_alloc();
      if (!stack_frame) return NULL;
      proc->kernel_stack_top = 
        (uint32_t)stack_frame + PAGE_SIZE;
      
    |
    class: stack
  }
  stack_layout: {
    label: |md
      **Stack Memory Layout**
      
      ┌─────────────────┐ 0x00102000
      │ kernel_stack_top│ ← ESP0 for TSS
      ├─────────────────┤
      │                 │
      │   4KB Stack     │ grows down
      │                 │
      ├─────────────────┤ 0x00101000
      │ stack_frame     │ ← frame_alloc()
      └─────────────────┘
      
    |
    class: stack
  }
  step2 -> stack_layout: "Frame allocated" {
    class: arrow
  }
}
Phase_3: {
  label: "Phase 3: cpu_state Setup"
  class: step_box
  step3: {
    label: |md
      **Initialize Saved State**
      c
      struct cpu_state *state = 
        (cpu_state*)(proc->kernel_stack_top 
          - sizeof(cpu_state));
      memset(state, 0, sizeof(cpu_state));
      
    |
    class: cpu_state
  }
  state_layout: {
    label: |md
      **cpu_state Fields for Kernel Process**
      
      state->eip    = (uint32_t)entry_point
      state->cs     = 0x08  // Kernel CS
      state->eflags = 0x202 // IF=1
      state->esp    = proc->kernel_stack_top
      state->ss     = 0x10  // Kernel DS
      state->ds = es = fs = gs = 0x10
      proc->kernel_stack = state;
      
    |
    class: cpu_state
  }
  step3 -> state_layout: "State positioned on stack" {
    class: arrow
  }
}
Phase_4: {
  label: "Phase 4: Scheduler Integration"
  class: step_box
  step4: {
    label: |md
      **Set Page Directory**
      c
      // Kernel processes share kernel PD
      proc->page_directory = 
        kernel_page_directory;
      
    |
    class: queue
  }
  queue_add: {
    label: |md
      **Add to Run Queue**
      c
      proc->state = PROCESS_STATE_READY;
      scheduler_add_to_queue(proc);
      // Queue operation:
      // tail->next = proc
      // proc->prev = tail
      // tail = proc
      
    |
    class: queue
  }
  return_val: {
    label: |md
      **Return PCB Pointer**
      c
      return proc;  // Ready to schedule!
      
    |
    class: pcb
    style.fill: "#C8E6C9"
  }
  step4 -> queue_add: "PD set" {
    class: arrow
  }
  queue_add -> return_val: "Queued" {
    class: arrow
  }
}
Phase_1 -> Phase_2: "Phase 1 → 2" {
  style: {
    stroke: "#4CAF50"
    stroke-width: 3
  }
}
Phase_2 -> Phase_3: "Phase 2 → 3" {
  style: {
    stroke: "#4CAF50"
    stroke-width: 3
  }
}
Phase_3 -> Phase_4: "Phase 3 → 4" {
  style: {
    stroke: "#4CAF50"
    stroke-width: 3
  }
}
Legend: {
  near: bottom-center
  label: |md
    ### Invariants
    - Stack MUST be 4KB aligned (from frame_alloc)
    - cpu_state positioned at top of stack, grows into stack
    - CS=0x08, DS/ES/FS/GS/SS=0x10 for kernel mode
    - EFLAGS.IF=1 to enable interrupts on first run
    - State READY before adding to run queue
  |
}