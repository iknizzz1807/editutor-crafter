vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Ring 0 → Ring 3 Transition via `iret`
  Stack Setup and Privilege Level Change
| {near: top-center}
direction: right
# ===========================================
# BEFORE: Kernel Mode Stack State
# ===========================================
before_section: {
  label: "BEFORE: Kernel Mode (Ring 0)"
  style.fill: "#E8E8E8"
  style.stroke: "#666666"
  kernel_code: {
    label: "Kernel Code\nExecuting"
    shape: rectangle
    style.fill: "#B5AFF6"
    style.stroke: "#6B5B95"
    style.bold: true
  }
  kernel_stack_before: {
    label: "Kernel Stack\n(ESP pointing here)"
    shape: rectangle
    style.fill: "#FFE4B5"
    style.stroke: "#CC8800"
  }
  kernel_code -> kernel_stack_before: "ESP = kernel_stack\nCS = 0x08, SS = 0x10" {
    style.stroke-dash: 3
    style.stroke: "#666666"
  }
}
# ===========================================
# STEP 1: Push User Stack Setup
# ===========================================
step1: {
  label: "Step 1: Push User Stack Setup"
  style.fill: "#E8F4E8"
  style.stroke: "#2E7D32"
  instruction: |md
    mov ax, 0x23    ; User DS (RPL=3)
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    push 0x23       ; SS = user data
    push user_esp   ; User stack pointer
    push 0x202      ; EFLAGS (IF=1)
    push 0x1B       ; CS = user code (RPL=3)
    push entry      ; EIP = user code
  | {shape: text}
  style.fill: transparent
}
# ===========================================
# STEP 2: Stack After Push
# ===========================================
stack_after_push: {
  label: "Step 2: Stack After Push"
  style.fill: "#E8E8E8"
  style.stroke: "#666666"
  esp_arrow: {
    label: "ESP →"
    shape: text
    style.font-color: "#E63946"
    style.bold: true
  }
  stack: {
    grid-rows: 5
    grid-gap: 0
    eip_cell: {
      label: "EIP\n(entry point)"
      style.fill: "#FFB3BA"
      style.stroke: "#E63946"
      style.bold: true
    }
    cs_cell: {
      label: "CS = 0x1B\n(user code, RPL=3)"
      style.fill: "#FFB3BA"
      style.stroke: "#E63946"
      style.bold: true
    }
    eflags_cell: {
      label: "EFLAGS = 0x202\n(IF=1, interrupts on)"
      style.fill: "#FFB3BA"
      style.stroke: "#E63946"
      style.bold: true
    }
    esp_cell: {
      label: "ESP\n(user stack top)"
      style.fill: "#FFB3BA"
      style.stroke: "#E63946"
      style.bold: true
    }
    ss_cell: {
      label: "SS = 0x23\n(user data, RPL=3)"
      style.fill: "#FFB3BA"
      style.stroke: "#E63946"
      style.bold: true
    }
  }
  esp_arrow -> stack.eip_cell
}
# ===========================================
# STEP 3: Execute iret
# ===========================================
step3: {
  label: "Step 3: Execute `iret`"
  style.fill: "#FFF3E0"
  style.stroke: "#EF6C00"
  iret_action: |md
    iret    ; Pop and transition to Ring 3
    **CPU Actions:**
    1. Pop EIP from stack
    2. Pop CS from stack (RPL=3 detected)
    3. Pop EFLAGS from stack
    4. **Privilege change detected** → Pop ESP
    5. **Privilege change detected** → Pop SS
    6. Load new CS:EIP, SS:ESP
    7. Switch to Ring 3
  | {shape: text}
  style.fill: transparent
}
# ===========================================
# AFTER: User Mode State
# ===========================================
after_section: {
  label: "AFTER: User Mode (Ring 3)"
  style.fill: "#E3F2FD"
  style.stroke: "#1565C0"
  user_code: {
    label: "User Code\nExecuting"
    shape: rectangle
    style.fill: "#90CAF9"
    style.stroke: "#1565C0"
    style.bold: true
  }
  user_stack: {
    label: "User Stack\n(at user_esp)"
    shape: rectangle
    style.fill: "#BBDEFB"
    style.stroke: "#1565C0"
  }
  user_code -> user_stack: "ESP = user_esp\nCS = 0x1B, SS = 0x23" {
    style.stroke-dash: 3
    style.stroke: "#1565C0"
  }
}
# ===========================================
# Connections
# ===========================================
before_section.kernel_stack_before -> step1: "1. Push values" {
  style.stroke: "#2E7D32"
  style.animated: true
}
step1 -> stack_after_push: "2. Stack built" {
  style.stroke: "#2E7D32"
}
stack_after_push -> step3: "3. Execute iret" {
  style.stroke: "#EF6C00"
  style.animated: true
}
step3 -> after_section.user_code: "4. Ring 3!" {
  style.stroke: "#1565C0"
  style.animated: true
}
# ===========================================
# Selector Bit Breakdown
# ===========================================
selector_breakdown: {
  label: "Selector Bit Breakdown"
  style.fill: "#F5F5F5"
  style.stroke: "#9E9E9E"
  cs_bits: {
    label: |md
      **CS = 0x1B** = `0001 1011`
      Index: 3 (User Code GDT entry)
      TI:    0 (GDT, not LDT)
      RPL:   3 (Ring 3)
    |
    shape: text
  }
  ss_bits: {
    label: |md
      **SS = 0x23** = `0010 0011`
      Index: 4 (User Data GDT entry)
      TI:    0 (GDT, not LDT)
      RPL:   3 (Ring 3)
    |
    shape: text
  }
}
selector_breakdown.cs_bits -> selector_breakdown.ss_bits
# ===========================================
# Critical Notes
# ===========================================
notes: {
  label: "Critical Requirements"
  style.fill: "#FFEBEE"
  style.stroke: "#C62828"
  note_content: |md
    ⚠️ **TSS.ESP0 must be set BEFORE `iret`**
    The TSS.ESP0 field tells the CPU where to find
    the kernel stack when an interrupt occurs in
    user mode. Without this, any interrupt from
    Ring 3 causes a **triple fault**.
    tss_set_kernel_stack(proc->kernel_stack_top);
    // NOW safe to jump_to_user_mode()
  |
  shape: text
  style.fill: transparent
}