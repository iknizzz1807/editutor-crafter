vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # System Call Interface: INT 0x80
|
title.near: top-center
title.shape: text
title.style.font-size: 32
title.style.bold: true
classes: {
  user_box: {
    style: {
      fill: "#E8F4FD"
      stroke: "#2E86AB"
      stroke-width: 2
      border-radius: 8
    }
  }
  kernel_box: {
    style: {
      fill: "#FFF3E0"
      stroke: "#E65100"
      stroke-width: 2
      border-radius: 8
    }
  }
  register: {
    shape: rectangle
    width: 120
    height: 40
    style: {
      fill: "#F5F5F5"
      stroke: "#9E9E9E"
      font: mono
      font-size: 14
    }
  }
  stack_item: {
    shape: rectangle
    width: 140
    height: 32
    style: {
      fill: "#FAFAFA"
      stroke: "#BDBDBD"
      font: mono
      font-size: 12
    }
  }
  arrow_user: {
    style: {
      stroke: "#2E86AB"
      stroke-width: 2
      animated: true
    }
  }
  arrow_kernel: {
    style: {
      stroke: "#E65100"
      stroke-width: 2
      animated: true
    }
  }
}
direction: right
user_mode: "User Mode (Ring 3)" {
  class: user_box
  user_code: ||md
    asm
    ; System call invocation
    mov eax, 2        ; SYS_WRITE
    mov ebx, 1        ; fd = stdout
    mov ecx, msg      ; buffer
    mov edx, 14       ; count
    int 0x80          ; Trigger syscall
    ; Return value in EAX
  ||
  user_registers: "Registers at INT 0x80" {
    reg_eax: "EAX = 0x02" {class: register}
    reg_ebx: "EBX = 0x01" {class: register}
    reg_ecx: "ECX = buf" {class: register}
    reg_edx: "EDX = 0x0E" {class: register}
  }
  user_stack_before: "User Stack (Before)" {
    usb_1: "Return Addr" {class: stack_item}
    usb_2: "Local Vars" {class: stack_item}
    usb_3: "..." {class: stack_item}
  }
}
transition: "CPU Transition" {
  shape: diamond
  style: {
    fill: "#FFE082"
    stroke: "#FF8F00"
    stroke-width: 3
  }
}
int_note: ||md
  **int 0x80** triggers:
  1. CPU pushes SS, ESP, EFLAGS, CS, EIP
  2. Loads CS:EIP from IDT[0x80]
  3. Switches to kernel stack (TSS.ESP0)
  4. Transitions to Ring 0
||
int_note.near: bottom-center
int_note.shape: text
int_note.style.font-size: 11
kernel_mode: "Kernel Mode (Ring 0)" {
  class: kernel_box
  idt_entry: "IDT[0x80] Entry" {
    shape: class
    offset_low: "uint16"
    selector: "uint16 = 0x08"
    type_attr: "uint8 = 0xEF"
    offset_high: "uint16"
  }
  idt_note: ||md
    DPL=3 allows user invocation
    Trap gate (IF preserved)
  ||
  idt_note.near: center-right
  idt_note.shape: text
  idt_note.style.font-size: 10
  syscall_entry: "syscall_entry (asm)" {
    shape: class
    step1: "+ Save DS, ES, FS, GS"
    step2: "+ Load kernel DS (0x10)"
    step3: "+ pusha (save GP regs)"
    step4: "+ Push args from stack"
    step5: "+ call syscall_dispatch"
    step6: "+ popa (restore GP regs)"
    step7: "+ Restore segment regs"
    step8: "+ iret"
  }
  kernel_stack: "Kernel Stack (During)" {
    ks_gs: "GS" {class: stack_item}
    ks_fs: "FS" {class: stack_item}
    ks_es: "ES" {class: stack_item}
    ks_ds: "DS" {class: stack_item}
    ks_pusha: "EAX...EDI" {class: stack_item}
    ks_ret: "Return Addr" {class: stack_item}
    ks_iret: "EIP, CS, EFLAGS" {class: stack_item}
    ks_user: "ESP, SS (user)" {class: stack_item; style.fill: "#E3F2FD"}
  }
  dispatch: "syscall_dispatch (C)" {
    shape: class
    dispatch_code: ||md
      c
      int32_t syscall_dispatch(
        uint32_t num,   // EAX
        uint32_t a1,    // EBX
        uint32_t a2,    // ECX
        uint32_t a3     // EDX
      ) {
        if (num > MAX_SYSCALL)
          return -1;
        return syscall_table[num](
          a1, a2, a3
        );
      }
    ||
  }
  syscall_table: "Syscall Table" {
    shape: sql_table
    Number: int {constraint: primary_key}
    Name: string
    Handler: function
    0: int; 0: "SYS_EXIT"; 0: "sys_exit"
    1: int; 1: "SYS_READ"; 1: "sys_read"
    2: int; 2: "SYS_WRITE"; 2: "sys_write"
    3: int; 3: "SYS_GETPID"; 3: "sys_getpid"
  }
}
return_path: "Return Path" {
  shape: diamond
  style: {
    fill: "#C8E6C9"
    stroke: "#388E3C"
    stroke-width: 3
  }
}
iret_note: ||md
  **iret** restores:
  1. EIP, CS, EFLAGS from stack
  2. ESP, SS (if privilege change)
  3. Returns to Ring 3
  4. EAX contains return value
||
iret_note.near: bottom-center
iret_note.shape: text
iret_note.style.font-size: 11
user_after: "User Mode (After)" {
  class: user_box
  user_code_after: ||md
    asm
    ; After iret returns here
    ; EAX = bytes written (14)
    ; or EAX = -1 on error
    test eax, eax
    js error_handler
    ; Success - continue execution
  ||
  user_stack_after: "User Stack (After)" {
    usa_1: "Return Addr" {class: stack_item}
    usa_2: "Local Vars" {class: stack_item}
    usa_3: "..." {class: stack_item}
  }
  result_reg: "EAX = 0x0E (14)" {
    class: register
    style: {
      fill: "#C8E6C9"
      stroke: "#388E3C"
    }
  }
}
user_mode -> transition: "int 0x80" {class: arrow_user; label: "Ring 3â†’0"}
transition -> kernel_mode: "IDT lookup" {class: arrow_kernel}
kernel_mode.idt_entry -> kernel_mode.syscall_entry: "jmp to handler"
kernel_mode.syscall_entry -> kernel_mode.dispatch: "call"
kernel_mode.dispatch -> kernel_mode.syscall_table: "table[num]"
kernel_mode -> return_path: "iret" {class: arrow_kernel; label: "Ring 0â†’3"}
return_path -> user_after: "continue" {class: arrow_user}
legend: ||md
  **Color Legend:**
  ðŸ”µ Blue = User Mode (Ring 3)
  ðŸŸ  Orange = Kernel Mode (Ring 0)
  ðŸŸ¢ Green = Return/Success
||
legend.near: bottom-left
legend.shape: text
legend.style.font-size: 12
legend.style.fill: "#FAFAFA"
legend.style.stroke: "#E0E0E0"
legend.style.border-radius: 4
timing: ||md
  **Timing (approximate):**
  | Phase | Cycles |
  |-------|--------|
  | int 0x80 entry | 50-100 |
  | Register save | 20-30 |
  | Dispatch call | 10-20 |
  | Handler exec | varies |
  | iret exit | 30-50 |
  | **Total** | **~150-250** |
||
timing.near: bottom-right
timing.shape: text
timing.style.font-size: 11
timing.style.fill: "#FAFAFA"
timing.style.stroke: "#E0E0E0"
timing.style.border-radius: 4