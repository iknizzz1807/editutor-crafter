vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Per-Process Kernel Stack
  **4KB dedicated kernel stack per process for safe ring 3→ring 0 transitions**
| {near: top-center}
direction: right
classes: {
  stack_frame: {
    style: {
      fill: "#E8F4FD"
      stroke: "#2E86AB"
      stroke-width: 2
      font: mono
    }
  }
  active: {
    style: {
      fill: "#FFE5E5"
      stroke: "#DC3545"
      stroke-width: 3
      bold: true
    }
  }
  tss_box: {
    style: {
      fill: "#FFF3CD"
      stroke: "#856404"
      stroke-width: 2
    }
  }
  unused: {
    style: {
      fill: "#E8E8E8"
      stroke: "#6C757D"
      stroke-dash: 3
    }
  }
}
Process_A: {
  label: "Process A\nKernel Stack (4KB)"
  stack_top: {
    label: "0x9000\n━━━━━━━━━━━━━━\nTop of Stack\n(TSS.ESP0)"
    class: active
    height: 80
  }
  active_region: {
    label: "Saved cpu_state\n(76 bytes)\n━━━━━━━━━━━━━━\nGS FS ES DS\nEDI ESI EBP ESP\nEBX EDX ECX EAX\nint_no err_code\nEIP CS EFLAGS\nuserESP SS"
    class: stack_frame
    height: 200
  }
  free_space: {
    label: "Available\nStack Space\n(grows DOWN ↓)"
    class: unused
    height: 120
  }
  stack_base: {
    label: "0x7000\n━━━━━━━━━━━━━━\nStack Base"
    class: stack_frame
    height: 40
  }
}
Process_B: {
  label: "Process B\nKernel Stack (4KB)"
  stack_top_b: {
    label: "0xA000\n━━━━━━━━━━━━━━\nTop of Stack\n(TSS.ESP0)"
    class: active
    height: 80
  }
  active_region_b: {
    label: "Saved cpu_state\n(76 bytes)\n━━━━━━━━━━━━━━\nGS FS ES DS\nEDI ESI EBP ESP\nEBX EDX ECX EAX\nint_no err_code\nEIP CS EFLAGS\nuserESP SS"
    class: stack_frame
    height: 200
  }
  free_space_b: {
    label: "Available\nStack Space\n(grows DOWN ↓)"
    class: unused
    height: 120
  }
  stack_base_b: {
    label: "0x8000\n━━━━━━━━━━━━━━\nStack Base"
    class: stack_frame
    height: 40
  }
}
TSS: {
  label: "Task State Segment"
  esp0_field: {
    label: "ESP0: 0x9000\n━━━━━━━━━━━━━━\nPoints to current\nprocess kernel\nstack top"
    class: tss_box
    height: 100
  }
  ss0_field: {
    label: "SS0: 0x0010\n━━━━━━━━━━━━━━\nKernel data\nsegment"
    class: tss_box
    height: 60
  }
}
CPU: {
  label: "On Interrupt from User Mode"
  step1: {
    label: "1. CPU reads TSS.ESP0"
    shape: text
    style.font: mono
  }
  step2: {
    label: "2. Saves user SS, ESP"
    shape: text
    style.font: mono
  }
  step3: {
    label: "3. Loads kernel SS0, ESP0"
    shape: text
    style.font: mono
  }
  step4: {
    label: "4. Pushes EFLAGS, CS, EIP"
    shape: text
    style.font: mono
  }
  step5: {
    label: "5. Jumps to IDT handler"
    shape: text
    style.font: mono
  }
}
context_switch: {
  label: "Context Switch\nMust Update TSS.ESP0"
  before: {
    label: "Before Switch:\nTSS.ESP0 = Process A\nkernel_stack_top"
    class: tss_box
  }
  after: {
    label: "After Switch:\nTSS.ESP0 = Process B\nkernel_stack_top"
    class: active
  }
}
TSS.esp0_field -> Process_A.stack_top: "ESP0 points here\nfor Process A" {
  style: {
    stroke: "#DC3545"
    stroke-width: 3
    animated: true
  }
}
context_switch.before -> TSS.esp0_field: "Read on\nuser interrupt" {
  style: {
    stroke: "#856404"
    stroke-dash: 3
  }
}
context_switch.after -> Process_B.stack_top_b: "Updated after\ncontext switch" {
  style: {
    stroke: "#DC3545"
    stroke-width: 3
  }
}
CPU -> TSS.esp0_field: "CPU reads\non interrupt" {
  style: {
    stroke: "#2E86AB"
    stroke-width: 2
  }
}
Process_A -> Process_B: "Context Switch" {
  label: "CRITICAL:\nUpdate TSS.ESP0\nbefore returning\nto user mode!"
  style: {
    stroke: "#DC3545"
    stroke-width: 3
    stroke-dash: 5
    animated: true
  }
}
footer: |md
  Stack Allocation (per process):
  ┌─────────────────────────────────────────────────────┐
  │ void *frame = frame_alloc();  // Get 4KB frame      │
  │ proc->kernel_stack_top = (uint32_t)frame + 4096;    │
  │                                                     │
  // TSS update on context switch:                     │
  │ tss_set_kernel_stack(next->kernel_stack_top);       │
  │ // ^ CRITICAL: Must happen BEFORE any return        │
  │ //   to user mode or triple fault on next interrupt │
  └─────────────────────────────────────────────────────┘
| {near: bottom-center}