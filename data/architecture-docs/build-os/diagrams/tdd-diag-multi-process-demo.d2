vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Multi-Process Demonstration
  **Three kernel processes with independent counters**
| {near: top-center}

direction: right

scheduler: Round-Robin Scheduler {
  style.fill: "#E8D5E0"
  style.stroke: "#8B4789"
  
  ready_queue: {
    label: "Ready Queue"
    shape: rectangle
    style.fill: "#F5E6F8"
  }
  
  timer: {
    label: "Timer\n100Hz"
    shape: circle
    style.fill: "#FFE4B5"
  }
  
  timer -> ready_queue: "tick\ntrigger"
}

process_a: Process A {
  style.fill: "#E6F3FF"
  style.stroke: "#4169E1"
  
  pcb_a: PCB {
    shape: class
    pid: "int = 1"
    state: "READY"
    kstack: "void* = 0xC0001000"
    counter: "volatile int = 0"
  }
  
  code_a: |c
    void process_a() {
      while(1) {
        counter++;
        print_at(0, "A:%d", counter);
        yield();
      }
    }
  | {shape: code}
}

process_b: Process B {
  style.fill: "#E6FFE6"
  style.stroke: "#228B22"
  
  pcb_b: PCB {
    shape: class
    pid: "int = 2"
    state: "READY"
    kstack: "void* = 0xC0002000"
    counter: "volatile int = 0"
  }
  
  code_b: |c
    void process_b() {
      while(1) {
        counter++;
        print_at(1, "B:%d", counter);
        yield();
      }
    }
  | {shape: code}
}

process_c: Process C {
  style.fill: "#FFF5E6"
  style.stroke: "#D2691E"
  
  pcb_c: PCB {
    shape: class
    pid: "int = 3"
    state: "READY"
    kstack: "void* = 0xC0003000"
    counter: "volatile int = 0"
  }
  
  code_c: |c
    void process_c() {
      while(1) {
        counter++;
        print_at(2, "C:%d", counter);
        yield();
      }
    }
  | {shape: code}
}

vga: VGA Console {
  style.fill: "#2D2D2D"
  style.stroke: "#555"
  style.font-color: "#FFF"
  
  row0: "Row 0: Process A: 0 → 1 → 2 → 3..." {
    style.fill: "#4169E1"
    style.font-color: "#FFF"
  }
  
  row1: "Row 1: Process B: 0 → 1 → 2 → 3..." {
    style.fill: "#228B22"
    style.font-color: "#FFF"
  }
  
  row2: "Row 2: Process C: 0 → 1 → 2 → 3..." {
    style.fill: "#D2691E"
    style.font-color: "#FFF"
  }
}

timeline: Execution Timeline {
  style.fill: "#F8F8F8"
  style.stroke: "#CCC"
  
  t0: "T0" {shape: circle; style.fill: "#4169E1"; style.font-color: "#FFF"}
  t1: "T1" {shape: circle; style.fill: "#228B22"; style.font-color: "#FFF"}
  t2: "T2" {shape: circle; style.fill: "#D2693E"; style.font-color: "#FFF"}
  t3: "T3" {shape: circle; style.fill: "#4169E1"; style.font-color: "#FFF"}
  t4: "T4" {shape: circle; style.fill: "#228B22"; style.font-color: "#FFF"}
  t5: "T5" {shape: circle; style.fill: "#D2691E"; style.font-color: "#FFF"}
  
  t0 -> t1 -> t2 -> t3 -> t4 -> t5: "context_switch"
}

scheduler.ready_queue -> process_a: "run next" {style.stroke: "#8B4789"}
process_a -> scheduler.ready_queue: "yield" {style.stroke: "#8B4789"; style.stroke-dash: 3}

scheduler.ready_queue -> process_b: "run next" {style.stroke: "#8B4789"}
process_b -> scheduler.ready_queue: "yield" {style.stroke: "#8B4789"; style.stroke-dash: 3}

scheduler.ready_queue -> process_c: "run next" {style.stroke: "#8B4789"}
process_c -> scheduler.ready_queue: "yield" {style.stroke: "#8B4789"; style.stroke-dash: 3}

process_a -> vga.row0: "print" {style.stroke: "#4169E1"; style.animated: true}
process_b -> vga.row1: "print" {style.stroke: "#228B22"; style.animated: true}
process_c -> vga.row2: "print" {style.stroke: "#D2691E"; style.animated: true}

note: |md
  ## Key Observations
  
  1. **Independent Counters**: Each process maintains its own `counter` variable
  2. **Independent Stacks**: Each PCB points to a unique kernel stack
  3. **Round-Robin**: Scheduler rotates A → B → C → A → B → C
  4. **Cooperative Yield**: Each process calls `yield()` after increment
  5. **VGA Output**: Each writes to a dedicated row (no corruption)
| {near: bottom-center; style.fill: "#FFFACD"}