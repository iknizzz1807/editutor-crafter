vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Paging Enablement Sequence
  Step-by-step transition from identity-mapped to higher-half kernel
| {near: top-center}

direction: right

step1: {
  label: "Step 1: Allocate PD"
  style.fill: "#E8D5E0"
  style.stroke: "#7B4B8C"
  style.stroke-width: 2
  
  pd_alloc: |md
    pd = alloc_page()
    memset(pd, 0, 4096)
  |
  
  pd_layout: {
    label: "Page Directory (4096 bytes)"
    shape: rectangle
    width: 300
    
    entry0: {
      label: "Entry 0\n(Identity)"
      style.fill: "#B8D4E3"
    }
    entry768: {
      label: "Entry 768\n(Higher-half)"
      style.fill: "#F6C889"
    }
    entry_other: {
      label: "Entries 1-767, 769-1023\n(Unmapped)"
      style.fill: "#E0E0E0"
    }
  }
  
  note1: |md
    - One 4KB page for PD
    - 1024 entries x 4 bytes each
    - Zeroed = not present
  |
}

step2: {
  label: "Step 2: Identity Map"
  style.fill: "#D5E8D4"
  style.stroke: "#6B9B6B"
  style.stroke-width: 2
  
  idmap_code: |md
    // Map first 4MB (entries 0-1023 of PT)
    for i in 0..1024:
      pt[i] = (i * 4096) | PE | RW | US
    pd[0] = (pt_phys) | PE | RW | US
  |
  
  idmap_layout: {
    label: "Identity Mapped Region"
    
    phys_mem: {
      label: "Physical Memory"
      shape: rectangle
      
      low: {
        label: "0x00000000 - 0x003FFFFF\n(First 4MB)"
        style.fill: "#B8D4E3"
        style.stroke: "#4A90A4"
      }
    }
    
    virt_mem: {
      label: "Virtual Memory"
      shape: rectangle
      
      vlow: {
        label: "0x00000000 - 0x003FFFFF\n(Virtual = Physical)"
        style.fill: "#B8D4E3"
        style.stroke: "#4A90A4"
      }
    }
  }
  
  note2: |md
    - Required for transition period
    - Enables execution after CR0.PG set
    - Maps kernel code/data at low addresses
  |
}

step3: {
  label: "Step 3: Higher-Half Map"
  style.fill: "#D4E5F7"
  style.stroke: "#4A7DB8"
  style.stroke-width: 2
  
  hhmap_code: |md
    // Map at 0xC0000000 (entry 768)
    // Same physical pages, different virtual
    pd[768] = (pt_phys) | PE | RW
  |
  
  hhmap_layout: {
    label: "Higher-Half Mapping"
    
    phys_view: {
      label: "Physical"
      kernel_phys: {
        label: "0x00000000+\nKernel"
        style.fill: "#B8D4E3"
      }
    }
    
    virt_view: {
      label: "Virtual"
      kernel_virt: {
        label: "0xC0000000+\nKernel"
        style.fill: "#F6C889"
      }
      user_space: {
        label: "0x00000000 - 0xBFFFFFFF\nUser Space"
        style.fill: "#E0E0E0"
      }
    }
    
    phys_view -> virt_view: "PD[768]" {
      style.stroke: "#4A7DB8"
      style.stroke-width: 2
    }
  }
  
  note3: |md
    - Entry 768 = 0xC0000000 / 4MB
    - Same page table as identity map
    - Supervisor-only (no US flag)
  |
}

step4: {
  label: "Step 4: Load CR3"
  style.fill: "#FFF2CC"
  style.stroke: "#D6A800"
  style.stroke-width: 2
  
  cr3_code: |md
    // Point CR3 to our PD
    asm volatile("mov %0, %%cr3" : : "r"(pd_phys));
  |
  
  cr3_layout: {
    label: "CR3 Register"
    shape: rectangle
    width: 400
    
    ign: {
      label: "Ignored"
      style.fill: "#E0E0E0"
    }
    pd_base: {
      label: "Page Directory Base\n(Physical Address)"
      style.fill: "#FFF2CC"
      style.stroke: "#D6A800"
      style.stroke-width: 2
      style.bold: true
    }
    flags: {
      label: "Flags\n(PCD, PWT)"
      style.fill: "#E0E0E0"
    }
  }
  
  cr3_state: {
    label: "Before to After"
    before: {
      label: "CR3 = 0x00000000"
      style.fill: "#FFCCCC"
    }
    after: {
      label: "CR3 = pd_phys"
      style.fill: "#CCFFCC"
    }
    before -> after
  }
  
  note4: |md
    - Physical address of PD
    - Low 12 bits reserved for flags
    - TLB NOT YET FLUSHED
  |
}

step5: {
  label: "Step 5: Set CR0.PG"
  style.fill: "#FFCCCC"
  style.stroke: "#CC3333"
  style.stroke-width: 2
  
  pg_code: |md
    // Enable paging
    uint32_t cr0;
    asm volatile("mov %%cr0, %0" : "=r"(cr0));
    cr0 |= 0x80000000;  // Set PG bit
    asm volatile("mov %0, %%cr0" : : "r"(cr0));
  |
  
  cr0_layout: {
    label: "CR0 Register"
    shape: rectangle
    width: 500
    
    pe: {
      label: "PE\n(1)"
      style.fill: "#D5E8D4"
    }
    pg: {
      label: "PG\n(0 to 1)"
      style.fill: "#FFCCCC"
      style.stroke: "#CC3333"
      style.stroke-width: 3
      style.bold: true
    }
    other: {
      label: "Other bits"
      style.fill: "#E0E0E0"
    }
  }
  
  paging_effect: {
    label: "Effect"
    before: {
      label: "Linear = Physical"
      style.fill: "#E0E0E0"
    }
    after: {
      label: "Linear to Page Table to Physical"
      style.fill: "#FFCCCC"
      style.stroke: "#CC3333"
    }
    before -> after
  }
  
  note5: |md
    - CRITICAL: Must have identity map!
    - Next instruction fetch goes through MMU
    - Without mapping = triple fault
  |
}

step6: {
  label: "Step 6: Continue Execution"
  style.fill: "#D5E8D4"
  style.stroke: "#6B9B6B"
  style.stroke-width: 2
  
  continue_code: |md
    // Jump to higher-half address
    asm volatile("jmp $0xC0100000, $continue");
  continue:
    // Now running in higher half
    // Can remove identity map if desired
  |
  
  addr_space: {
    label: "Final Address Space"
    
    layout: {
      user: {
        label: "0x00000000\nUser Space\n(Not mapped yet)"
        style.fill: "#E0E0E0"
        height: 80
      }
      
      kernel: {
        label: "0xC0000000\nKernel\n(Higher Half)"
        style.fill: "#F6C889"
        style.stroke: "#D6A800"
        style.stroke-width: 2
        height: 80
      }
      
      devices: {
        label: "0xFFC00000\nDevice MMIO\n(Optional)"
        style.fill: "#FFCCCC"
        height: 40
      }
    }
  }
  
  note6: |md
    - EIP now in higher half
    - Stack pointer updated to 0xC0xxxxxx
    - Identity map can be removed
    - Ready for user process creation
  |
}

step1 -> step2 -> step3 -> step4 -> step5 -> step6: "Next" {
  style.stroke: "#333333"
  style.stroke-width: 3
  style.animated: true
}

legend: {
  near: bottom-right
  
  colors: {
    label: "Color Legend"
    
    purple: {
      label: "Purple: Allocation"
      style.fill: "#E8D5E0"
    }
    green: {
      label: "Green: Identity Map"
      style.fill: "#D5E8D4"
    }
    blue: {
      label: "Blue: Higher-Half"
      style.fill: "#D4E5F7"
    }
    yellow: {
      label: "Yellow: CR3 Load"
      style.fill: "#FFF2CC"
    }
    red: {
      label: "Red: Paging Enable"
      style.fill: "#FFCCCC"
    }
  }
  
  critical: |md
    ## Critical Sequence
    
    1. Must allocate PD first - No PD = no page tables
    2. Must identity map - Code executes at low addr after PG set
    3. Must higher-half map - Required for kernel virtual addresses
    4. CR3 before PG - MMU needs page tables before enable
    5. Jump to higher-half - Transition EIP to virtual address
    
    Failure at any step = Triple Fault
  |
}

timing: {
  near: bottom-left
  label: "Timing Constraints"
  
  timing_info: |md
    | Operation | Cycles | Notes |
    |-----------|--------|-------|
    | alloc_page | ~1000 | Depends on allocator |
    | memset PD | ~4096 | One write per byte |
    | Map entries | ~8192 | 2 PTs x 1024 entries |
    | CR3 load | ~100 | TLB flush overhead |
    | CR0.PG set | ~50 | No TLB flush |
    | Far jump | ~20 | Pipeline flush |
    
    Total: ~15,000 cycles (~5-10 us @ 1-2 GHz)
  |
}