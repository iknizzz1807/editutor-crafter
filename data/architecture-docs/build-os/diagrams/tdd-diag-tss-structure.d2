vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # TSS Structure for Ring Transitions
  Task State Segment — Ring 3→0 Stack Switching Mechanism
| {near: top-center}

direction: right

tss_memory: TSS Memory Layout {
  direction: right
  
  offset_col: "Offset" {
    shape: text
    style.font: mono
    style.font-size: 14
  }
  
  field_col: "Field" {
    shape: text
    style.font: mono
    style.font-size: 14
  }
  
  size_col: "Size" {
    shape: text
    style.font: mono
    style.font-size: 14
  }
  
  # Row data using grid
  row00: "0x00" { style.opacity: 0 }
  row01: "0x04" { style.opacity: 0 }
  row02: "0x08" { style.opacity: 0 }
  row03: "0x0C" { style.opacity: 0 }
  row04: "0x10" { style.opacity: 0 }
  row05: "0x14" { style.opacity: 0 }
  row06: "0x18" { style.opacity: 0 }
  row07: "0x1C" { style.opacity: 0 }
  row08: "0x20" { style.opacity: 0 }
  row09: "0x24" { style.opacity: 0 }
  row10: "0x28" { style.opacity: 0 }
  row11: "0x2C" { style.opacity: 0 }
  row12: "0x30" { style.opacity: 0 }
  row13: "0x34" { style.opacity: 0 }
  row14: "0x38" { style.opacity: 0 }
  row15: "0x3C" { style.opacity: 0 }
  row16: "0x40" { style.opacity: 0 }
  row17: "0x44" { style.opacity: 0 }
  row18: "0x48" { style.opacity: 0 }
  row19: "0x4C" { style.opacity: 0 }
  row20: "0x50" { style.opacity: 0 }
  row21: "0x54" { style.opacity: 0 }
  row22: "0x58" { style.opacity: 0 }
  row23: "0x5C" { style.opacity: 0 }
  row24: "0x60" { style.opacity: 0 }
  row25: "0x64" { style.opacity: 0 }
  row26: "0x68" { style.opacity: 0 }
  row27: "0x6C" { style.opacity: 0 }
  row28: "0x70" { style.opacity: 0 }
  row29: "0x74" { style.opacity: 0 }
  row30: "0x78" { style.opacity: 0 }
  row31: "0x7C" { style.opacity: 0 }
  row32: "0x80" { style.opacity: 0 }
  row33: "0x84" { style.opacity: 0 }
  row34: "0x88" { style.opacity: 0 }
  row35: "0x8C" { style.opacity: 0 }
  row36: "0x90" { style.opacity: 0 }
  row37: "0x94" { style.opacity: 0 }
  row38: "0x98" { style.opacity: 0 }
  row39: "0x9C" { style.opacity: 0 }
  row40: "0xA0" { style.opacity: 0 }
  row41: "0xA4" { style.opacity: 0 }
  row42: "0xA8" { style.opacity: 0 }
  row43: "0xAC" { style.opacity: 0 }
  row44: "0xB0" { style.opacity: 0 }
  row45: "0xB4" { style.opacity: 0 }
  row46: "0xB8" { style.opacity: 0 }
  row47: "0xBC" { style.opacity: 0 }
  row48: "0xC0" { style.opacity: 0 }
  row49: "0xC4" { style.opacity: 0 }
  row50: "0xC8" { style.opacity: 0 }
  row51: "0xCC" { style.opacity: 0 }
  row52: "0xD0" { style.opacity: 0 }
  row53: "0xD4" { style.opacity: 0 }
  row54: "0xD8" { style.opacity: 0 }
  row55: "0xDC" { style.opacity: 0 }
  row56: "0xE0" { style.opacity: 0 }
  row57: "0xE4" { style.opacity: 0 }
  row58: "0xE8" { style.opacity: 0 }
  row59: "0xEC" { style.opacity: 0 }
  row60: "0xF0" { style.opacity: 0 }
  row61: "0xF4" { style.opacity: 0 }
  row62: "0xF8" { style.opacity: 0 }
  row63: "0xFC" { style.opacity: 0 }
  row64: "0x100" { style.opacity: 0 }
  row65: "0x104" { style.opacity: 0 }
  row66: "0x108" { style.opacity: 0 }
  row67: "0x10C" { style.opacity: 0 }
}

# TSS Structure Detail
tss_struct: TSS Structure {
  shape: class
  
  "+LINK": "uint16_t"
  "+ESP0": "uint32_t" 
  "+SS0": "uint16_t"
  "-padding0": "uint16_t"
  "+ESP1": "uint32_t"
  "+SS1": "uint16_t"
  "-padding1": "uint16_t"
  "+ESP2": "uint32_t"
  "+SS2": "uint16_t"
  "-padding2": "uint16_t"
  "+CR3": "uint32_t"
  "+EIP": "uint32_t"
  "+EFLAGS": "uint32_t"
  "+EAX": "uint32_t"
  "+ECX": "uint32_t"
  "+EDX": "uint32_t"
  "+EBX": "uint32_t"
  "+ESP": "uint32_t"
  "+EBP": "uint32_t"
  "+ESI": "uint32_t"
  "+EDI": "uint32_t"
  "+ES": "uint16_t"
  "-padding_es": "uint16_t"
  "+CS": "uint16_t"
  "-padding_cs": "uint16_t"
  "+SS": "uint16_t"
  "-padding_ss": "uint16_t"
  "+DS": "uint16_t"
  "-padding_ds": "uint16_t"
  "+FS": "uint16_t"
  "-padding_fs": "uint16_t"
  "+GS": "uint16_t"
  "-padding_gs": "uint16_t"
  "+LDT": "uint16_t"
  "-padding_ldt": "uint16_t"
  "+TRAP": "uint16_t"
  "+IOMAP_BASE": "uint16_t"
}

tss_struct: |md
  **sizeof(tss_struct) = 104 bytes (0x68)**
  
  Critical fields for privilege transitions:
  - **SS0 @ 0x04**: Kernel stack segment (0x10)
  - **ESP0 @ 0x08**: Kernel stack pointer top
  - Updated on EVERY context switch to user process
|

# Memory layout visualization
layout_viz: Memory Layout {
  direction: down
  
  header_row: {
    label: "0x00-0x03"
    link: "LINK"
    size: "4B"
  }
  
  ss0_row: {
    label: "0x04-0x07"
    ss0: "**SS0**"
    size: "4B"
    style.fill: "#E8D5B7"
    style.stroke: "#8B4513"
    style.bold: true
  }
  
  esp0_row: {
    label: "0x08-0x0B"
    esp0: "**ESP0**"
    size: "4B"
    style.fill: "#E8D5B7"
    style.stroke: "#8B4513"
    style.bold: true
  }
  
  ring1_row: {
    label: "0x0C-0x17"
    ring1: "ESP1/SS1"
    size: "12B"
    style.fill: "#D3D3D3"
  }
  
  ring2_row: {
    label: "0x18-0x23"
    ring2: "ESP2/SS2"
    size: "12B"
    style.fill: "#D3D3D3"
  }
  
  cr3_row: {
    label: "0x24-0x27"
    cr3: "CR3"
    size: "4B"
    style.fill: "#B0C4DE"
  }
  
  gpr_row: {
    label: "0x28-0x4F"
    gpr: "GPRs\n(EIP-EFLAGS-EAX-ECX-EDX-EBX-ESP-EBP-ESI-EDI)"
    size: "40B"
    style.fill: "#E6E6FA"
  }
  
  seg_row: {
    label: "0x50-0x5F"
    seg: "Segment Registers\n(ES-CS-SS-DS-FS-GS)"
    size: "16B"
    style.fill: "#FFE4E1"
  }
  
  ldt_row: {
    label: "0x60-0x63"
    ldt: "LDT+Trap"
    size: "4B"
    style.fill: "#D3D3D3"
  }
  
  iomap_row: {
    label: "0x64-0x67"
    iomap: "IOMAP_BASE"
    size: "4B"
    style.fill: "#D3D3D3"
  }
  
  total: |md
    **Total: 104 bytes (0x68)**
    Cache line aligned at 64B boundary
  |
}

# Legend
legend: {
  near: bottom-right
  
  critical: {
    shape: rectangle
    style.fill: "#E8D5B7"
    style.stroke: "#8B4513"
    label: "Critical for Ring 3→0"
  }
  
  gpr: {
    shape: rectangle
    style.fill: "#E6E6FA"
    label: "General Purpose"
  }
  
  seg: {
    shape: rectangle
    style.fill: "#FFE4E1"
    label: "Segment Registers"
  }
}

# TR Loading Sequence
tr_sequence: TR Loading Sequence {
  direction: down
  
  step1: Step 1: Allocate TSS {
    shape: rectangle
    style.fill: "#E8F5E9"
    
    code1: |c
      // Allocate page-aligned TSS
      tss_t *tss = kalloc(sizeof(tss_t));
      memset(tss, 0, sizeof(tss_t));
    |
  }
  
  step2: Step 2: Initialize Critical Fields {
    shape: rectangle
    style.fill: "#E8F5E9"
    
    code2: |c
      // Set kernel stack segment (ring 0)
      tss->ss0 = 0x10;  // Kernel data selector
      
      // ESP0 set during context switch
      // (per-process kernel stack top)
      tss->esp0 = 0;    // Initialize to 0
    |
  }
  
  step3: Step 3: Create GDT Entry {
    shape: rectangle
    style.fill: "#E8F5E9"
    
    code3: |c
      // GDT entry for TSS descriptor
      // Base = (uint32_t)tss
      // Limit = sizeof(tss_t) - 1 = 103
      // Type = 0x89 (Present, 32-bit TSS)
      gdt[5].limit_low   = sizeof(tss_t) - 1;
      gdt[5].base_low    = (uint32_t)tss & 0xFFFF;
      gdt[5].base_mid    = ((uint32_t)tss >> 16) & 0xFF;
      gdt[5].access      = 0x89;  // TSS descriptor
      gdt[5].flags_limit = 0x00;
      gdt[5].base_high   = ((uint32_t)tss >> 24) & 0xFF;
    |
  }
  
  step4: Step 4: Load Task Register {
    shape: rectangle
    style.fill: "#FFF3E0"
    style.stroke: "#FF6F00"
    style.bold: true
    
    code4: |c
      // Load TR with TSS selector (GDT index 5)
      // Selector = 0x28 (index 5, TI=0, RPL=0)
      asm volatile("ltr %0" : : "r"(0x28));
    |
  }
  
  step1 -> step2 -> step3 -> step4: "next"
}

# Context Switch Update
ctx_update: ESP0 Update on Context Switch {
  direction: down
  
  before: Before Switching to User Process {
    shape: rectangle
    style.fill: "#FFEBEE"
    
    code_before: |c
      void context_switch(process_t *next) {
          // ... save current state ...
          
          // CRITICAL: Update TSS.ESP0 before switch
          // This is where CPU will load SS0:ESP0
          // on any privilege level transition
          if (next->ring == 3) {
              tss->esp0 = (uint32_t)next->kernel_stack_top;
          }
          
          // ... restore next state ...
      }
    |
  }
  
  transition: Ring 3→0 Transition Hardware {
    shape: rectangle
    style.fill: "#E3F2FD"
    style.stroke: "#1976D2"
    
    hw: |md
      **CPU automatically performs:**
      
      1. Reads TSS.SS0 → loads SS
      2. Reads TSS.ESP0 → loads ESP
      3. Pushes user SS, ESP, EFLAGS, CS, EIP
      4. Loads CS:EIP from IDT gate
      5. Begins executing kernel handler
    |
  }
  
  before -> transition: "int 0x80\nor interrupt"
}

# Ring Transition Diagram
ring_transition: Ring Transition Stack Layout {
  direction: down
  
  user_stack: User Stack (Ring 3) {
    style.fill: "#C8E6C9"
    
    layout1: |md
      
      ESP →  [local vars    ]
             [return addr   ]
             [caller's EBP  ]
             [...           ]
      
    |
  }
  
  kernel_stack: Kernel Stack (Ring 0) {
    style.fill: "#FFCDD2"
    
    layout2: |md
      
      ESP0 → [SS     = 0x23 ]  ← Pushed by CPU
             [ESP    (user)]  ← Pushed by CPU
             [EFLAGS        ]  ← Pushed by CPU
             [CS    = 0x1B  ]  ← Pushed by CPU
             [EIP  (handler)]  ← Pushed by CPU
             [Error Code    ]  ← (if applicable)
             ─────────────────
             [saved EAX     ]  ← Pushed by handler
             [saved ECX     ]
             [saved EDX     ]
             [saved EBX     ]
             [...           ]
      
    |
  }
  
  user_stack -> kernel_stack: "INT 0x80\n(privilege transition)" {
    style.stroke: "#D32F2F"
    style.stroke-width: 3
    style.animated: true
  }
}

# Key Points Annotation
notes: |md
  ### Key Implementation Points
  
  1. **TSS is REQUIRED** even for software task switching
     - CPU uses SS0:ESP0 for stack switch on privilege change
     - Without valid TSS, any interrupt from ring 3 = Triple Fault
  
  2. **Update ESP0 on EVERY context switch**
     - Each process has its own kernel stack
     - TSS.ESP0 must point to current process's kernel stack top
  
  3. **Single TSS is sufficient**
     - Modern OS uses one TSS for all processes
     - Only SS0:ESP0 fields are used by hardware
     - Other fields (ESP1/SS1, etc.) unused in most designs
  
  4. **Selector calculation**
     - GDT index 5 × 8 = 0x28
     - TI=0 (GDT), RPL=0 (kernel)
| {near: bottom-center}

# Connections
tss_struct -> layout_viz: "maps to"
tr_sequence.ctx_update -> ring_transition: "enables"