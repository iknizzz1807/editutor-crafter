{
  "types": {
    "multiboot_header": "fields: magic uint32_t, flags uint32_t, checksum uint32_t, header_addr uint32_t, load_addr uint32_t, load_end_addr uint32_t, bss_end_addr uint32_t, entry_addr uint32_t",
    "Process Control Block (PCB)": "fields: pid int, registers struct, page_table uint32_t*, status enum, ...",
    "GDT Entry": "fields: limit_low uint16, base_low uint16, base_mid uint8, access uint8, granularity uint8, base_high uint8",
    "IDT Entry": "fields: offset_low uint16, selector uint16, zero uint8, type_attr uint8, offset_high uint16",
    "page_table_t": "forward declaration for page table structure",
    "gdt_entry": "fields: limit_low uint16_t, base_low uint16_t, base_mid uint8_t, access uint8_t, granularity uint8_t, base_high uint8_t",
    "gdtr": "fields: limit uint16_t, base uint32_t*",
    "idt_entry": "fields: offset_low uint16_t, selector uint16_t, zero uint8_t, type_attr uint8_t, offset_high uint16_t",
    "idtr": "fields: limit uint16_t, base uint32_t*",
    "registers": "fields: ds uint32_t, edi uint32_t, esi uint32_t, ebp uint32_t, esp uint32_t, ebx uint32_t, edx uint32_t, ecx uint32_t, eax uint32_t, int_no uint32_t, err_code uint32_t, eip uint32_t, cs uint32_t, eflags uint32_t, user_esp uint32_t, ss uint32_t",
    "multiboot_mmap_entry": "fields: size uint32_t, base_addr uint64_t, length uint64_t, type uint32_t, reserved uint32_t",
    "pmm_state": "fields: bitmap uint32_t*, total_frames size_t, free_frames size_t, last_alloc_index size_t, bitmap_frames uint32_t",
    "page_table_entry_t": "typedef for uint32_t",
    "cpu_registers": "fields: eax uint32_t, ebx uint32_t, ecx uint32_t, edx uint32_t, esi uint32_t, edi uint32_t, ebp uint32_t, esp uint32_t, eip uint32_t, eflags uint32_t, cs uint32_t, ds uint32_t, es uint32_t, fs uint32_t, gs uint32_t, ss uint32_t",
    "pcb": "fields: pid int, parent_pid int, state process_state_t, exit_code int, regs struct cpu_registers, kernel_stack void*, kernel_stack_base void*, page_directory uint32_t*, brk void*, image_start void*, image_size size_t, name char[16], time_used uint64_t, priority uint8_t, waiting_for int, next struct pcb*",
    "multiboot_info": "fields: flags uint32_t, mem_lower uint32_t, mem_upper uint32_t, boot_device uint32_t, cmdline uint32_t, mods_count uint32_t, mods_addr uint32_t, syms uint32_t[4], mmap_length uint32_t, mmap_addr uint32_t, drives_length uint32_t, drives_addr uint32_t, config_table uint32_t, boot_loader_name uint32_t, apm_table uint32_t, vbe_control_info uint32_t, vbe_mode_info uint32_t, vbe_mode uint16_t, vbe_interface_seg uint16_t, vbe_interface_off uint16_t, vbe_interface_len uint16_t",
    "heap_block_header": "fields: magic uint32_t, size size_t, is_free bool, next struct heap_block_header*",
    "heap_block_footer": "fields: magic uint32_t, header struct heap_block_header*",
    "crash_dump": "fields: magic uint32_t, error_code uint32_t, eip uint32_t, eax uint32_t, ebx uint32_t, ecx uint32_t, edx uint32_t, esi uint32_t, edi uint32_t, esp uint32_t, ebp uint32_t, cs uint32_t, ds uint32_t, es uint32_t, fs uint32_t, gs uint32_t, ss uint32_t, cr0 uint32_t, cr2 uint32_t, cr3 uint32_t, cr4 uint32_t, message char[64]",
    "serial_port": "fields: (implied by functions serial_init, serial_putc, serial_puts)",
    "test_state": "fields: (implied by test_heap_stress)",
    "ipc_message_t": "fields: src_pid uint32_t, dst_pid uint32_t, type ipc_msg_type_t, transaction_id uint32_t, data_len uint32_t, data uint8_t[IPC_MAX_DATA_SIZE]"
  },
  "methods": {
    "kmain(uint32_t mboot_magic, void* mboot_info)": "Main kernel entry point called from bootloader",
    "kprintf(const char* fmt, ...)": "Kernel-level formatted print function",
    "vga_init()": "Initialize VGA text mode driver",
    "gdt_init()": "Initialize and load the Global Descriptor Table",
    "idt_init()": "Initialize and load the Interrupt Descriptor Table",
    "pic_remap()": "Remap PIC IRQs to non-conflicting interrupt vectors",
    "keyboard_init()": "Initialize PS/2 keyboard driver and interrupt handler",
    "pmm_init(void* mboot_info)": "Initialize Physical Memory Manager using Multiboot memory map",
    "vmm_init()": "Initialize Virtual Memory Manager and set up initial page tables",
    "enable_paging()": "Enable paging by setting the CR0 register",
    "heap_init()": "Initialize kernel heap allocator",
    "scheduler_init()": "Initialize process scheduler",
    "panic(const char* file, int line, const char* msg)": "Halt system with error message",
    "arch_port_write_byte(uint16_t port, uint8_t value)": "Architecture-specific I/O port write",
    "scheduler_get_next_process()": "Get next process from scheduler queue",
    "gdt_init() returns void": "Initialize and load the Global Descriptor Table",
    "idt_init() returns void": "Initialize and load the Interrupt Descriptor Table",
    "idt_set_gate(uint8_t num, uint32_t base, uint16_t sel, uint8_t flags) returns void": "Set an IDT entry at specified index",
    "isr_handler(struct registers *regs) returns void": "C-level interrupt handler called from assembly stub",
    "pmm_init(struct multiboot_info *mboot_info) returns void": "Initialize Physical Memory Manager using Multiboot memory map",
    "pte_make_frame(uint32_t phys_addr) returns uint32_t": "Extract frame address from physical address for PTE",
    "pte_get_frame(page_table_entry_t pte) returns uint32_t": "Get frame address from page table entry",
    "pte_is_present(page_table_entry_t pte) returns bool": "Check if page table entry is present",
    "process_create(const char *name, void *entry_point) returns struct pcb*": "Creates a new process control block, allocates resources, and adds it to the scheduler ready queue.",
    "process_destroy(int pid) returns void": "Cleans up a terminated process, freeing all its allocated memory and removing it from system queues.",
    "kmain(uint32_t mboot_magic, void* mboot_info) returns void": "Main kernel entry point called from bootloader",
    "vga_init() returns void": "Initialize VGA text mode driver",
    "gdt_set_gate(int num, uint32_t base, uint32_t limit, uint8_t access, uint8_t gran) returns void": "Set an individual GDT entry",
    "gdt_flush() returns void": "Assembly function to load GDT and update segment registers",
    "pic_remap() returns void": "Remap PIC IRQs to non-conflicting interrupt vectors",
    "keyboard_init() returns void": "Initialize PS/2 keyboard driver and interrupt handler",
    "irq_enable(uint8_t irq) returns void": "Unmask the specified IRQ in PIC",
    "irq_disable(uint8_t irq) returns void": "Mask (disable) the specified IRQ in PIC",
    "irq_register_handler(int irq, void (*handler)(struct registers*)) returns void": "Register handler function for specific IRQ",
    "arch_port_write_byte(uint16_t port, uint8_t value) returns void": "Write byte to I/O port",
    "arch_port_read_byte(uint16_t port) returns uint8_t": "Read byte from I/O port",
    "pmm_alloc_frame() returns void*": "Allocate physical frame with OOM handling",
    "pmm_free_frame(void *phys_addr) returns void": "Free a previously allocated physical frame",
    "vmm_init() returns void": "Initialize Virtual Memory Manager and set up initial page tables",
    "map_page(uint32_t virt_addr, uint32_t phys_addr, uint32_t flags) returns void": "Map a virtual page to a physical frame with specified flags",
    "flush_tlb_single(uint32_t virt_addr) returns void": "Invalidate TLB entry for a specific virtual address",
    "heap_init() returns void": "Initialize kernel heap allocator",
    "kmalloc(size_t size) returns void*": "Allocate memory from the kernel heap",
    "kfree(void *ptr) returns void": "Free memory allocated with kmalloc",
    "scheduler_init() returns void": "Initialize process scheduler",
    "scheduler_get_next_process() returns struct pcb*": "Implements round-robin logic: selects the next process to run from the ready queue, rotating the queue.",
    "schedule() returns void": "The main scheduling function, called from timer interrupt. Performs context switch to the next chosen process.",
    "switch_context(cpu_registers_t** old_sp, cpu_registers_t* new_sp) returns void": "Assembly routine that saves current CPU state, switches stacks/page tables, and restores new CPU state.",
    "syscall_dispatcher(int syscall_num, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4, uint32_t arg5) returns int": "Central dispatcher for system calls, routing based on syscall number to the appropriate handler.",
    "kprintf(const char* fmt, ...) returns void": "Kernel-level formatted print function",
    "enable_paging() returns void": "Enable paging by setting the CR0 register",
    "panic(const char* file, int line, const char* msg) returns void": "Halt system with error message and register dump",
    "is_user_pointer(const void* ptr, size_t len) returns bool": "Validate user-space pointer before dereferencing",
    "handle_exception(struct registers *regs) returns void": "C-level exception handler with classification and response",
    "serial_init() returns void": "Initialize COM1 serial port at 9600 baud",
    "serial_putc(char c) returns void": "Write a single character to serial port",
    "serial_puts(const char* str) returns void": "Write null-terminated string to serial port",
    "test_heap_stress() returns void": "Stress test for kernel heap allocator",
    "klog(const char* fmt, ...) returns void": "Kernel logging function that formats and sends output to serial port",
    "ipc_send(uint32_t dst_pid, ipc_message_t* msg) returns void": "Send an IPC message to destination process",
    "ipc_receive(uint32_t* src_pid, ipc_message_t* msg) returns void": "Receive an IPC message, blocking if none available",
    "ipc_reply(uint32_t dst_pid, ipc_message_t* msg) returns void": "Send a reply to a previous message",
    "scheduler_init_mlfq() returns void": "Initialize Multilevel Feedback Queue scheduler data structures",
    "scheduler_get_next_process_mlfq() returns struct pcb*": "Select next process to run using MLFQ algorithm",
    "scheduler_enqueue_mlfq(struct pcb* proc) returns void": "Add a process to the appropriate MLFQ priority queue",
    "on_timer_tick_mlfq(struct pcb* current) returns void": "Update MLFQ state on timer tick; may demote current process",
    "priority_boost() returns void": "Periodically boost all processes to highest priority to prevent starvation"
  },
  "constants": {
    "VGA_BUFFER_ADDR": "0xB8000",
    "MULTIBOOT_MAGIC": "0x2BADB002",
    "PIC1_COMMAND": "0x20",
    "PIC1_DATA": "0x21",
    "PIC2_COMMAND": "0xA0",
    "PIC2_DATA": "0xA1",
    "KERNEL_STACK_SIZE": "16384",
    "KERNEL_CS": "0x08",
    "KERNEL_DS": "0x10",
    "IDT_PRESENT": "1 << 7",
    "IDT_DPL_0": "0 << 5",
    "IDT_DPL_3": "3 << 5",
    "IDT_GATE_32": "0xE",
    "PTE_PRESENT": "1 << 0",
    "PTE_WRITABLE": "1 << 1",
    "PTE_USER": "1 << 2",
    "PTE_WRITETHROUGH": "1 << 3",
    "PTE_CACHE_DISABLE": "1 << 4",
    "PTE_ACCESSED": "1 << 5",
    "PTE_DIRTY": "1 << 6",
    "PTE_PAT": "1 << 7",
    "PTE_GLOBAL": "1 << 8",
    "PTE_FRAME_MASK": "0xFFFFF000",
    "PROC_STATE_NEW": "0",
    "PROC_STATE_READY": "1",
    "PROC_STATE_RUNNING": "2",
    "PROC_STATE_BLOCKED": "3",
    "PROC_STATE_TERMINATED": "4",
    "VGA_HEIGHT": "25",
    "VGA_WIDTH": "80",
    "MB_ALIGN": "1 << 0",
    "MB_MEMINFO": "1 << 1",
    "MB_FLAGS": "MB_ALIGN | MB_MEMINFO",
    "MB_MAGIC": "0x1BADB002",
    "HEAP_MAGIC": "0xDEADBEEF",
    "RECURSIVE_PD_BASE": "0xFFC00000",
    "RECURSIVE_PT_BASE": "0xFFF00000",
    "MIN_BLOCK_SIZE": "16",
    "SYS_EXIT": "0",
    "SYS_WRITE": "1",
    "SYS_READ": "2",
    "SYS_FORK": "3",
    "SYS_GETPID": "4",
    "CRASH_DUMP_ADDR": "0x1000 (Physical address for crash dump structure)",
    "CRASH_MAGIC": "0xDEADFA11 (Magic number to identify valid crash dump)",
    "VGA_COLOR_RED": "4",
    "VGA_COLOR_WHITE": "15",
    "MAX_PROCESSES": "64",
    "PORT_COM1": "0x3F8 (I/O base address for COM1)",
    "NUM_ALLOCS": "100 (number of allocations in stress test)",
    "MAX_ALLOC_SIZE": "2048 (maximum allocation size in bytes for test)",
    "IPC_MAX_DATA_SIZE": "256",
    "NUM_PRIORITY_LEVELS": "5",
    "TIME_QUANTUM_LEVEL0": "10",
    "TIME_QUANTUM_LEVEL1": "20",
    "TIME_QUANTUM_LEVEL2": "40",
    "TIME_QUANTUM_LEVEL3": "80",
    "TIME_QUANTUM_LEVEL4": "160",
    "IPC_MSG_OPEN": "0",
    "IPC_MSG_READ": "1",
    "IPC_MSG_WRITE": "2",
    "IPC_MSG_CLOSE": "3",
    "IPC_MSG_REPLY": "4"
  },
  "terms": {
    "Monolithic Kernel": "all services in single privileged address space",
    "Microkernel": "minimal kernel with services in user space",
    "Protected Mode": "32-bit CPU mode with memory protection",
    "Paging": "virtual memory translation technique",
    "Triple Fault": "exception during exception handling causing reset",
    "Multiboot": "bootloader-kernel interface standard",
    "Context Switch": "saving/restoring CPU state between processes",
    "ISR": "Interrupt Service Routine handler function",
    "PCB": "Process Control Block data structure",
    "TLB": "Translation Lookaside Buffer cache",
    "DMA": "Direct Memory Access - device memory access without CPU",
    "Packed Structure": "data structure without compiler padding",
    "Boundary Tags": "heap block metadata for coalescing",
    "Recursive Mapping": "page directory mapped into itself",
    "Round-Robin": "scheduling algorithm with fixed time slices",
    "TLB Flush": "invalidating TLB entries",
    "Magic Number": "distinctive constant for data structure identification",
    "Process State Model": "finite state machine for process lifecycle",
    "System Call Convention": "method for user processes to invoke kernel services",
    "Bootstrapping": "process of loading and starting OS from powered-off state",
    "GDT": "Global Descriptor Table for segment definitions",
    "Linker Script": "configuration file for executable layout",
    "Higher-Half Kernel": "kernel in upper virtual address space",
    "BSS Section": "Block Started by Symbol - executable section for zero-initialized static variables",
    "IDT": "Interrupt Descriptor Table mapping vectors to handlers",
    "PIC": "Programmable Interrupt Controller",
    "EOI": "End of Interrupt signal to PIC/APIC",
    "IRQ": "Interrupt Request hardware signal line",
    "Scancode": "raw keyboard key value",
    "TSS": "Task State Segment for privilege transitions",
    "Bitmap": "array of bits tracking resource allocation",
    "Process Control Block (PCB)": "data structure containing all process information",
    "Zombie Process": "terminated process awaiting parent wait",
    "Stack Canary": "value to detect stack overflow",
    "Guard Page": "unmapped page below stack to catch overflow",
    "OOM Killer": "Out-Of-Memory process terminator",
    "Graceful Degradation": "continued operation with reduced functionality",
    "Serial Port (UART)": "hardware interface for serial communication",
    "Stress Testing": "testing under extreme load",
    "Canary Value": "memory value to detect corruption",
    "Post-mortem Debugging": "analysis after crash",
    "Fault Injection": "deliberate error introduction for testing",
    "Magic Breakpoint": "xchg bx,bx instruction for Bochs debugger",
    "Symmetric Multiprocessing (SMP)": "multiple identical CPUs sharing memory",
    "Multilevel Feedback Queue (MLFQ)": "scheduling algorithm with dynamic priorities",
    "Inter-Process Communication (IPC)": "mechanisms for process data exchange",
    "Virtual Filesystem (VFS)": "abstraction layer for filesystems",
    "Big Kernel Lock (BKL)": "global spinlock for SMP synchronization",
    "Application Processor (AP)": "secondary CPU core in SMP",
    "Bootstrap Processor (BSP)": "primary CPU core in SMP boot",
    "Inter-Processor Interrupt (IPI)": "interrupt between CPU cores in SMP",
    "VGA": "Video Graphics Array display standard"
  }
}