{
  "title": "Minimal Educational OS Kernel: Design Document",
  "overview": "This document outlines the design for a minimal, educational operating system kernel built from scratch. The core architectural challenge is bootstrapping a system that transitions from raw hardware to a protected environment where user processes can run safely, requiring careful orchestration of CPU modes, memory mapping, and hardware abstraction.",
  "sections": [
    {
      "id": "context-problem",
      "title": "1. Context and Problem Statement",
      "summary": "Explains the fundamental role of an OS kernel and the inherent complexity of interacting with bare hardware.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "The Kernel as a Conductor and Guardian",
          "summary": "Presents an analogy of an orchestra conductor and a building manager to explain kernel responsibilities."
        },
        {
          "id": "problem-detail",
          "title": "The Core Problem: Bridging Hardware and Software",
          "summary": "Describes the technical hurdles: bootstrapping, hardware diversity, and resource protection."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches and Our Path",
          "summary": "Compares monolithic, microkernel, and hybrid designs, justifying our monolithic educational approach."
        }
      ]
    },
    {
      "id": "goals-nongoals",
      "title": "2. Goals and Non-Goals",
      "summary": "Clearly defines the scope of the educational kernel and what is explicitly out of scope.",
      "subsections": [
        {
          "id": "goals",
          "title": "Must-Have Goals (Functional Requirements)",
          "summary": "Lists the core capabilities the kernel must provide, mapped to the project milestones."
        },
        {
          "id": "nongoals",
          "title": "Explicit Non-Goals",
          "summary": "Lists features that are important for real-world OSes but excluded for educational focus."
        }
      ]
    },
    {
      "id": "high-level-arch",
      "title": "3. High-Level Architecture",
      "summary": "Provides a bird's-eye view of the kernel's major components and their relationships.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "System Component Overview",
          "summary": "Describes the responsibilities of the bootloader, core kernel, device drivers, and memory/process managers."
        },
        {
          "id": "file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Outlines the directory and file organization for the codebase to enforce clear separation of concerns."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core data structures and types that form the skeleton of the kernel.",
      "subsections": [
        {
          "id": "cpu-structs",
          "title": "CPU and Hardware Structures",
          "summary": "Describes GDT, IDT, and page table entry structures crucial for CPU control."
        },
        {
          "id": "memory-structs",
          "title": "Memory Management Structures",
          "summary": "Defines structures for the frame allocator, heap, and page tables."
        },
        {
          "id": "process-structs",
          "title": "Process Management Structures",
          "summary": "Defines the Process Control Block (PCB) and scheduler queue structures."
        }
      ]
    },
    {
      "id": "component-boot",
      "title": "5.1 Component: Bootloader & Kernel Entry (Milestone 1)",
      "summary": "Design for the initial bootstrap code that loads the kernel and sets up the foundational CPU environment.",
      "subsections": [
        {
          "id": "boot-mental-model",
          "title": "Mental Model: The Stage Manager",
          "summary": "Analogy of a stage manager preparing the theater before the main show (kernel) begins."
        },
        {
          "id": "boot-adr",
          "title": "ADRs: BIOS vs. UEFI, 16-bit vs. 32-bit Boot",
          "summary": "Decision records for boot method and initial CPU mode."
        },
        {
          "id": "boot-pitfalls",
          "title": "Common Pitfalls: Bootloader & GDT",
          "summary": "Discusses incorrect memory addresses, GDT misalignment, and forgetting to disable interrupts."
        },
        {
          "id": "boot-implementation",
          "title": "Implementation Guidance: Bootloader & VGA",
          "summary": "Provides starter code for a multiboot header and VGA buffer writing, with TODOs for the core boot logic."
        }
      ]
    },
    {
      "id": "component-interrupts",
      "title": "5.2 Component: Interrupts & Keyboard Driver (Milestone 2)",
      "summary": "Design for handling hardware and software interrupts, including a PS/2 keyboard driver.",
      "subsections": [
        {
          "id": "int-mental-model",
          "title": "Mental Model: The Receptionist and Intercom",
          "summary": "Analogy of a receptionist handling urgent phone calls (interrupts) to explain the IDT and ISRs."
        },
        {
          "id": "int-adr",
          "title": "ADRs: PIC vs. APIC, Stack Switching",
          "summary": "Decision records for interrupt controller and kernel stack management on entry."
        },
        {
          "id": "int-pitfalls",
          "title": "Common Pitfalls: PIC, EOI, and Stack",
          "summary": "Discusses missing End-of-Interrupt (EOI), wrong PIC remapping, and stack corruption."
        },
        {
          "id": "int-implementation",
          "title": "Implementation Guidance: IDT & Keyboard ISR",
          "summary": "Provides starter code for ISR assembly stubs and PIC remapping, with TODOs for handler logic and scancode mapping."
        }
      ]
    },
    {
      "id": "component-memory",
      "title": "5.3 Component: Memory Management (Milestone 3)",
      "summary": "Design for physical frame allocation, virtual memory via paging, and a kernel heap allocator.",
      "subsections": [
        {
          "id": "mem-mental-model",
          "title": "Mental Model: The City Planner and Librarian",
          "summary": "Analogy of a city planner (physical allocator), address translator (paging), and librarian (heap allocator) managing resources."
        },
        {
          "id": "mem-adr",
          "title": "ADRs: Physical Allocator Bitmap vs. Stack, Paging Strategy",
          "summary": "Decision records for tracking free frames and kernel address space layout."
        },
        {
          "id": "mem-pitfalls",
          "title": "Common Pitfalls: Page Tables and The Heap",
          "summary": "Discusses TLB flushes, recursive page table mapping, and heap fragmentation/corruption."
        },
        {
          "id": "mem-implementation",
          "title": "Implementation Guidance: Page Tables & Heap",
          "summary": "Provides starter code for page directory/table structures and a linked list node, with TODOs for allocator algorithms."
        }
      ]
    },
    {
      "id": "component-process",
      "title": "5.4 Component: Process Management & Scheduler (Milestone 4)",
      "summary": "Design for processes, context switching, a round-robin scheduler, and a system call interface.",
      "subsections": [
        {
          "id": "proc-mental-model",
          "title": "Mental Model: The Chess Tournament Director",
          "summary": "Analogy of a tournament director managing players (processes), timing their turns (scheduler), and enforcing rules (isolation)."
        },
        {
          "id": "proc-adr",
          "title": "ADRs: Process State Model, Scheduler Algorithm",
          "summary": "Decision records for defining process states and choosing a simple round-robin scheduler."
        },
        {
          "id": "proc-pitfalls",
          "title": "Common Pitfalls: Context Switch and System Calls",
          "summary": "Discusses incomplete register saving, stack pointer mishandling, and unsafe system call arguments."
        },
        {
          "id": "proc-implementation",
          "title": "Implementation Guidance: PCB & Scheduler",
          "summary": "Provides starter code for the PCB structure and system call dispatch table, with TODOs for context switch assembly and scheduler logic."
        }
      ]
    },
    {
      "id": "interactions-flow",
      "title": "6. Interactions and Data Flow",
      "summary": "Traces the sequence of operations for key system workflows across components.",
      "subsections": [
        {
          "id": "flow-boot",
          "title": "Boot Sequence Flow",
          "summary": "Step-by-step walkthrough from BIOS to kernel main()."
        },
        {
          "id": "flow-interrupt",
          "title": "Interrupt Handling Flow",
          "summary": "Sequence from IRQ firing to ISR return."
        },
        {
          "id": "flow-syscall",
          "title": "System Call Flow",
          "summary": "Sequence from user-mode `int 0x80` to kernel handler and back."
        },
        {
          "id": "flow-context-switch",
          "title": "Context Switch Flow",
          "summary": "Sequence triggered by the timer interrupt to switch processes."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "7. Error Handling and Edge Cases",
      "summary": "Strategies for dealing with hardware failures, invalid requests, and resource exhaustion.",
      "subsections": [
        {
          "id": "errors-hardware",
          "title": "Hardware and Low-Level Errors",
          "summary": "Handling CPU exceptions (e.g., page faults) and device failures."
        },
        {
          "id": "errors-resource",
          "title": "Resource Management Edge Cases",
          "summary": "Dealing with out-of-memory conditions and full process tables."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "8. Testing Strategy",
      "summary": "Approaches to verify the kernel works correctly, emphasizing observable outputs.",
      "subsections": [
        {
          "id": "testing-milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "For each milestone, describes the expected behavior and how to confirm success (e.g., specific screen output)."
        },
        {
          "id": "testing-techniques",
          "title": "Testing Techniques for an OS Kernel",
          "summary": "Discusses using QEMU, serial port logging, and controlled fault injection."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "9. Debugging Guide",
      "summary": "A symptom-based troubleshooting guide for common implementation bugs.",
      "subsections": [
        {
          "id": "debug-table",
          "title": "Common Bug Symptom \u2192 Cause \u2192 Fix Table",
          "summary": "Structured table linking symptoms (e.g., triple fault, no output) to likely causes and fixes."
        },
        {
          "id": "debug-tools",
          "title": "Tools and Techniques: QEMU, Bochs, and Logging",
          "summary": "How to use emulator debuggers and strategic `printf`-style logging to inspect kernel state."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "10. Future Extensions",
      "summary": "Potential features to build upon the completed minimal kernel.",
      "subsections": [
        {
          "id": "extensions-features",
          "title": "Feature Additions",
          "summary": "Suggests adding a shell, filesystem, networking, and more advanced scheduling."
        },
        {
          "id": "extensions-arch",
          "title": "Architectural Evolutions",
          "summary": "Discusses evolving towards a microkernel or adding symmetric multiprocessing (SMP) support."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "11. Glossary",
      "summary": "Definitions of key terms, acronyms, and concepts used throughout the document.",
      "subsections": [
        {
          "id": "glossary-terms",
          "title": "Terms and Acronyms",
          "summary": "Alphabetical list of terms from 'BSS' to 'VGA' with clear, concise definitions."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-component",
      "title": "System Component Diagram",
      "description": "Shows the major software components of the OS (Bootloader, Kernel Core, Drivers, Managers) and their rough dependency/communication relationships. Include arrows for calls/interrupts.",
      "type": "component",
      "relevant_sections": [
        "high-level-arch"
      ]
    },
    {
      "id": "boot-sequence",
      "title": "Boot Sequence Diagram",
      "description": "A sequence diagram showing actors (BIOS, Bootloader, CPU, Kernel) and the flow of control from power-on to kernel main() execution, including mode transitions.",
      "type": "sequence",
      "relevant_sections": [
        "component-boot",
        "interactions-flow"
      ]
    },
    {
      "id": "page-table-struct",
      "title": "Page Table Structure Diagram",
      "description": "A class/relationship diagram showing the hierarchy of a Page Directory, Page Tables, and Page Table Entries (PTEs). Illustrate how a virtual address is split into indices and offset.",
      "type": "class",
      "relevant_sections": [
        "component-memory",
        "data-model"
      ]
    },
    {
      "id": "interrupt-flow",
      "title": "Interrupt Handling Flowchart",
      "description": "A flowchart detailing the steps from an interrupt request (IRQ) occurring, through the PIC, CPU, IDT lookup, handler execution, sending EOI, and returning with IRET. Include paths for exceptions and spurious IRQs.",
      "type": "flowchart",
      "relevant_sections": [
        "component-interrupts",
        "interactions-flow"
      ]
    },
    {
      "id": "process-state",
      "title": "Process State Machine",
      "description": "A state machine diagram showing process states (New, Ready, Running, Blocked, Terminated) and the events that cause transitions between them (e.g., scheduled, I/O request, preempted).",
      "type": "state-machine",
      "relevant_sections": [
        "component-process",
        "data-model"
      ]
    },
    {
      "id": "context-switch-seq",
      "title": "Context Switch Sequence Diagram",
      "description": "A sequence diagram showing the Timer Interrupt, Scheduler, and two Processes (A and B). Detail the save-registers, choose-next, switch-page-tables, restore-registers flow.",
      "type": "sequence",
      "relevant_sections": [
        "component-process",
        "interactions-flow"
      ]
    }
  ]
}