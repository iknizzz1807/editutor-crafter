[
  {
    "milestone_id": "build-os-m1",
    "criteria": [
      "Bootloader fits in 512 bytes (MBR) or uses a two-stage approach (stage1 in MBR loads stage2 from disk)",
      "Bootloader reads kernel binary from disk using BIOS INT 13h and loads it to a known physical address (e.g., 0x100000)",
      "GDT is configured with at least 5 entries: null descriptor, kernel code (ring 0, base=0, limit=4GB, executable+readable), kernel data (ring 0, base=0, limit=4GB, writable), user code (ring 3), user data (ring 3)",
      "Protected mode is entered by setting CR0.PE bit after loading GDTR; a far jump to the kernel code segment flushes the pipeline",
      "Segment registers (DS, ES, FS, GS, SS) are loaded with the kernel data segment selector after the far jump",
      "Kernel entry point (in C) zeroes the BSS section (from __bss_start to __bss_end as defined in linker script) and calls main()",
      "VGA text mode driver writes characters with foreground/background color attributes to 0xB8000",
      "Serial port (COM1, 0x3F8) is initialized for debug output; kprintf-like function outputs to both VGA and serial",
      "Kernel boots successfully in QEMU and displays a welcome message on screen and serial console"
    ]
  },
  {
    "milestone_id": "build-os-m2",
    "criteria": [
      "IDT contains 256 entries with entries 0-31 configured for CPU exceptions including divide error, page fault, and general protection fault with descriptive error messages",
      "All interrupt handlers save general-purpose registers (pusha) and segment registers on entry and restore them before iret; handlers for exceptions 8, 10-14 account for the error code pushed by the CPU",
      "PIC 8259 is remapped so IRQ0-7 map to vectors 32-39 and IRQ8-15 map to vectors 40-47, avoiding conflicts with CPU exception vectors 0-31",
      "EOI is sent to the correct PIC (master for IRQ0-7, both master and slave for IRQ8-15) at the end of each IRQ handler before iret",
      "Timer interrupt (IRQ0 via PIT channel 0) fires at a configurable frequency (e.g., 100Hz) and increments a global tick counter on each interrupt",
      "Keyboard interrupt (IRQ1) reads PS/2 scancode from port 0x60, converts to ASCII using a scancode-to-ASCII table, and places characters in a circular keyboard buffer",
      "Double fault handler (exception 8) catches cascading faults, prints diagnostic information including error code, and halts the system instead of allowing a triple fault",
      "Interrupts are enabled (sti) only after IDT is loaded and PIC is remapped and configured"
    ]
  },
  {
    "milestone_id": "build-os-m3",
    "criteria": [
      "Physical memory map obtained from multiboot info or E820, with regions classified as usable/reserved/ACPI",
      "Physical frame allocator (bitmap or free-list) allocates and frees 4KB frames with double-free prevention",
      "Page directory and page tables configured for identity-mapping (kernel + VGA + MMIO) and higher-half kernel mapping (0xC0000000+)",
      "Paging enabled by loading CR3 with page directory physical address and setting CR0.PG bit",
      "TLB flushed with invlpg or CR3 reload after modifying page table entries",
      "Page fault handler reads CR2 for faulting address and prints diagnostic (address, error code bits for present/write/user)",
      "Kernel heap allocator (kmalloc/kfree) provides dynamic allocation from dedicated virtual range using page allocator for backing frames",
      "Identity map maintained for low memory so VGA (0xB8000) and MMIO regions remain accessible at physical addresses"
    ]
  },
  {
    "milestone_id": "build-os-m4",
    "criteria": [
      "Process control block (PCB) stores PID, register state (EIP, ESP, EBP, general-purpose registers, EFLAGS), page directory pointer, process state (ready/running/blocked), and kernel stack pointer",
      "Context switch saves current process registers to its PCB and loads the next process's registers using assembly implementation for correctness",
      "TSS (Task State Segment) is configured with kernel stack pointer (SS0:ESP0) so the CPU knows which stack to use for ring 3 â†’ ring 0 transitions",
      "Timer interrupt (IRQ0) triggers the scheduler which selects the next ready process in round-robin order and performs context switch",
      "At least 3 kernel-mode processes run concurrently, each printing to a different screen region, demonstrating preemptive multitasking",
      "User-mode processes run in ring 3 with their own page directory; accessing kernel memory triggers page fault due to supervisor-only bit",
      "System call interface via INT 0x80: kernel reads syscall number from EAX and arguments from EBX/ECX/EDX, implementing sys_write and sys_exit at minimum",
      "TSS ESP0 is updated on every context switch to point to the current process's kernel stack top"
    ]
  },
  {
    "module_id": "mod-boot",
    "criteria": [
      "boot_sector_exactly_512_bytes",
      "boot_signature_0xAA55_valid",
      "gdt_null_descriptor_zero",
      "gdt_kernel_code_correct",
      "gdt_kernel_data_correct",
      "a20_line_enabled_verified",
      "protected_mode_cr0_pe_set",
      "far_jump_to_32_bit_code",
      "segment_registers_reloaded",
      "kernel_loaded_at_0x100000",
      "bss_section_zeroed",
      "c_entry_point_called",
      "vga_output_working",
      "serial_output_working",
      "boot_time_under_1_second"
    ]
  },
  {
    "module_id": "mod-interrupts",
    "criteria": [
      "IDT contains 256 entries loadable via lidt",
      "CPU exception handlers installed for vectors 0-31 with descriptive messages",
      "Exception handlers correctly distinguish between those with and without error codes",
      "PIC remapped to map IRQ0-7 to vectors 32-39 and IRQ8-15 to vectors 40-47",
      "EOI sent to correct PIC (master and/or slave) at end of every IRQ handler",
      "PIT timer fires at configurable frequency with tick counter incrementing",
      "PS/2 keyboard driver reads scancodes from port 0x60 and converts to ASCII",
      "Keyboard input buffered in circular buffer accessible via kb_getchar()",
      "Double fault handler catches cascading faults and prints diagnostics before halt",
      "All interrupt handlers save and restore complete register state",
      "ISR entry to C handler completes in under 150 cycles",
      "Timer accuracy within 1% of configured frequency",
      "Keyboard latency under 1ms from IRQ to buffer",
      "Register frame structure matches assembly push order exactly",
      "System does not hang after first interrupt (proves EOI works)"
    ]
  },
  {
    "module_id": "mod-memory",
    "criteria": [
      "e820_init parses multiboot memory map and stores usable regions",
      "frame_allocator_init marks kernel frames as used and usable regions as free",
      "alloc_frame returns valid 4KB-aligned physical addresses",
      "free_frame detects double-free and panics",
      "map_page creates page tables on demand and invalidates TLB",
      "unmap_page clears PTE and invalidates TLB",
      "identity mapping covers first 16MB including VGA at 0xB8000",
      "higher-half mapping maps 0xC0000000+ to physical 0x00000000+",
      "paging_init enables paging without triple fault",
      "page fault handler reads CR2 and decodes error code",
      "kmalloc returns 4-byte aligned pointers above HEAP_START",
      "kfree coalesces adjacent free blocks",
      "heap corruption (bad magic) causes panic on kmalloc/kfree"
    ]
  }
]