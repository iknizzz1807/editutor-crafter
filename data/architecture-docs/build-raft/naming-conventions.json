{
  "types": {
    "RaftNode": "fields: mu sync.Mutex, currentTerm int, votedFor int, log []LogEntry, commitIndex int, lastApplied int, nextIndex []int, matchIndex []int, id int, peers []int, state NodeState, stateMachine StateMachine, electionTimeout time.Duration, electionTimeoutTimer *time.Timer, lastHeartbeatReceived time.Time, transport Transport, configState ConfigState, learners map[int]bool",
    "NodeState": "fields: ID int, Term int, State string, VotedFor *int, CommitIndex int, LastApplied int, LogSummary map[string]interface{}, NextIndex map[int]int, MatchIndex map[int]int, ConfigState interface{}",
    "LogEntry": "fields: Term int, Index int, Command interface{}",
    "Message": "fields: Type string, From int, To int, Payload json.RawMessage",
    "HTTPServer": "fields: nodeID int, addr string, handler Handler, server *http.Server, mu sync.Mutex, clients map[int]*http.Client",
    "Handler": "type: func(Message) (interface{}, error)",
    "MemoryStore": "fields: mu sync.RWMutex, entries []LogEntry",
    "PersistentState": "fields: CurrentTerm int, VotedFor *int, Log []LogEntry",
    "VolatileState": "fields: (defined in implementation guidance)",
    "RequestVoteArgs": "fields: Term int, CandidateID int, LastLogIndex int, LastLogTerm int",
    "RequestVoteReply": "fields: Term int, VoteGranted bool",
    "AppendEntriesArgs": "fields: Term int, LeaderID int, PrevLogIndex int, PrevLogTerm int, Entries []LogEntry, LeaderCommit int",
    "AppendEntriesReply": "fields: Term int, Success bool",
    "Timer": "fields: mu sync.Mutex, duration time.Duration, timer *time.Timer, resetChan chan struct{}, timeoutChan chan struct{}, stopped bool, baseTimeout time.Duration, rangeTimeout time.Duration",
    "StateMachine": "interface with Apply method",
    "Configuration": "fields: Servers []int, Index int, Term int",
    "ConfigState": "fields: Current Configuration, Pending *Configuration",
    "ConfigCommand": "fields: Type string, Config Configuration",
    "HTTPTransport": "fields: mu sync.RWMutex, nodeID int, addr string, server *http.Server, clients map[int]*http.Client, handler func(Message) (interface{}, error), timeout time.Duration",
    "VirtualTransport": "fields: mu sync.RWMutex, nodes map[int]*VirtualEndpoint, dropRate float64, minDelay time.Duration, maxDelay time.Duration, partitions [][]int, clock *VirtualClock",
    "VirtualEndpoint": "fields: id int, inbox chan Message, handler func(Message) (interface{}, error)",
    "Simulator": "fields: (implied but not defined in detail)",
    "LogEvent": "fields: Timestamp time.Time, NodeID int, Term int, State string, Level string, Event string, Details map[string]interface{}",
    "Logger": "fields: mu sync.Mutex, nodeID int, level LogLevel, output *os.File",
    "Inspector": "fields: mu sync.RWMutex, nodes map[int]func() NodeState",
    "SnapshotMetadata": "fields: LastIncludedIndex int, LastIncludedTerm int, Configuration Configuration, ConfigurationIdx int",
    "Snapshot": "fields: Metadata SnapshotMetadata, Data []byte, CRC32 uint32",
    "Storage": "interface for snapshot persistence",
    "Snapshotter": "fields: storage Storage, maxLogSize int, snapshotInProgress bool, mu sync.RWMutex",
    "InstallSnapshotArgs": "fields: Term int, LeaderID int, LastIncludedIndex int, LastIncludedTerm int, Offset int, Data []byte, Done bool",
    "InstallSnapshotReply": "fields: Term int",
    "InstrumentedRaftNode": "fields: *RaftNode, metrics *RaftMetrics",
    "RaftMetrics": "fields: TermGauge prometheus.Gauge, ElectionCounter prometheus.Counter, CommitLatencyHist prometheus.Histogram, RPCErrorCounter *prometheus.CounterVec, LogSizeGauge prometheus.Gauge"
  },
  "methods": {
    "NewRaftNode(id int, peers []int, sm StateMachine, transport Transport) *RaftNode": "Creates and initializes a new Raft node",
    "run()": "Main event loop for Raft node",
    "runFollower()": "Handles follower state behavior",
    "runCandidate()": "Handles candidate state behavior",
    "runLeader()": "Handles the behavior of a node in Leader state",
    "resetElectionTimeout()": "Resets election timer with new random timeout",
    "NewHTTPServer(nodeID int, addr string, handler Handler) *HTTPServer": "Creates a new HTTP transport server",
    "Start() error": "Begins listening for incoming RPCs",
    "Send(to int, msg Message) (interface{}, error)": "Delivers a message to another node",
    "Stop() error": "Shuts down the HTTP server",
    "Append(entries []LogEntry) error": "Adds entries to the log store",
    "Get(index int) (LogEntry, error)": "Retrieves an entry from the log store",
    "LastIndex() int": "Returns the index of the last entry",
    "GetTerm(index int) (int, error)": "Returns the term of an entry at given index",
    "Truncate(fromIndex int) error": "Removes entries from given index onward",
    "handleRequestVote(args RequestVoteArgs) RequestVoteReply": "Processes vote request with strict log comparison for safety",
    "handleAppendEntries(args AppendEntriesArgs) AppendEntriesReply": "Processes incoming AppendEntries RPC with consistency check",
    "NewTimer(base, rangeDur time.Duration) *Timer": "Creates election timer with random range",
    "Timer.reset()": "Generates new random timeout and resets internal timer",
    "Timer.run()": "Monitors timer and sends to timeoutChan on expiration",
    "Timer.Reset()": "Signals timer to generate new random timeout",
    "Timer.TimeoutChan() <-chan struct{}": "Returns channel for timeout events",
    "Timer.Stop()": "Halts timer",
    "NewMemoryStore() *MemoryStore": "Creates empty in-memory store",
    "startReplicationLoop()": "Begins the leader's replication goroutine",
    "broadcastHeartbeats()": "Sends empty AppendEntries RPCs to all followers",
    "broadcastAppendEntries()": "Sends AppendEntries RPCs to all followers from leader",
    "handleAppendEntriesResult(peerID int, args AppendEntriesArgs, reply AppendEntriesReply)": "Processes a response from a follower",
    "advanceCommitIndex()": "Updates leader's commit index using safety rule (only entries from current term)",
    "applyCommittedEntries()": "Applies committed entries to state machine, updates lastApplied",
    "LogStore.Append(prevIndex int, prevTerm int, entries []LogEntry) error": "Adds entries to the log starting at the given index",
    "LogStore.Get(index int) (LogEntry, error)": "Returns the entry at the specified index",
    "LogStore.GetTerm(index int) int": "Returns the term of the entry at the specified index",
    "LogStore.LastIndex() int": "Returns the index of the last entry in the log",
    "LogStore.LastTerm() int": "Returns the term of the last entry in the log",
    "LogStore.Slice(start, end int) ([]LogEntry, error)": "Returns entries in the range [start, end]",
    "LogStore.Truncate(fromIndex int) error": "Removes all entries from fromIndex onward",
    "LogStore.Size() int": "Returns the number of entries in the log",
    "ConfigState.IsJoint() bool": "Returns true if in joint consensus state",
    "ConfigState.ContainsServer(serverID int) bool": "Checks if server is voting member",
    "ConfigState.VotingMembers() []int": "Returns list of voting members",
    "ConfigState.MajoritySize() int": "Returns number of votes needed for majority",
    "ConfigState.QuorumMajority(voters []int) bool": "Checks if voters constitute a quorum",
    "DecodeConfigCommand(cmd interface{}) (*ConfigCommand, error)": "Decodes a LogEntry's Command into a ConfigCommand",
    "ProposeConfigurationChange(newServers []int) error": "Proposes a new configuration change (leader only)",
    "NewHTTPTransport(nodeID int, addr string, handler func(Message) (interface{}, error)) *HTTPTransport": "Creates HTTP transport for RPC communication",
    "HTTPTransport.Start() error": "Begins listening for incoming RPCs",
    "HTTPTransport.Send(to int, msg Message) (interface{}, error)": "Delivers message to another node via HTTP",
    "HTTPTransport.Stop() error": "Shuts down HTTP server",
    "HTTPTransport.SetTimeout(d time.Duration)": "Updates RPC timeout duration",
    "recoverNode() error": "loads persistent state and initializes volatile state after crash/restart",
    "checkTermAndStepDown(term int)": "updates term and steps down if a higher term is seen",
    "CheckElectionSafety(nodes map[int]*RaftNode) error": "verifies at most one leader per term",
    "CheckStateMachineSafety(nodes map[int]*RaftNode) error": "verifies all nodes have same applied entries",
    "CheckLeaderCompleteness(nodes map[int]*RaftNode, committedEntries map[int]LogEntry) error": "verifies committed entries survive leader changes",
    "VirtualTransport.Register(nodeID int, handler func(Message) (interface{}, error))": "registers a node with the simulated network",
    "VirtualTransport.Send(from, to int, msg Message) (interface{}, error)": "sends a message with simulated delays and drops",
    "logEvent(event string, details map[string]interface{})": "structured logging helper",
    "Log(term int, state string, level LogLevel, event string, details map[string]interface{})": "core logging method",
    "Debug(term int, state, event string, details map[string]interface{})": "convenience debug log",
    "Info(term int, state, event string, details map[string]interface{})": "convenience info log",
    "Warn(term int, state, event string, details map[string]interface{})": "convenience warn log",
    "Error(term int, state, event string, details map[string]interface{})": "convenience error log",
    "NewInspector() *Inspector": "creates new state inspector",
    "RegisterNode(id int, stateGetter func() NodeState)": "registers a node for inspection",
    "ServeHTTP(w http.ResponseWriter, r *http.Request)": "HTTP handler for inspection endpoint",
    "GetStateForInspector() debug.NodeState": "returns node state for debug inspection",
    "NewSnapshotter(storage Storage, maxLogSize int) *Snapshotter": "creates new snapshot manager",
    "ShouldSnapshot(logSize int, lastSnapshotIdx int) bool": "determines if snapshot should be created",
    "BeginSnapshot() error": "marks snapshot creation start",
    "EndSnapshot()": "marks snapshot creation complete",
    "handleInstallSnapshot(args InstallSnapshotArgs) InstallSnapshotReply": "processes incoming snapshot installation",
    "sendInstallSnapshot(peerID int, snapshotID string) error": "sends snapshot chunks to follower"
  },
  "constants": {
    "Follower": "NodeState value 0",
    "Candidate": "NodeState value 1",
    "Leader": "NodeState value 2",
    "LevelDebug": "LogLevel value 0",
    "LevelInfo": "LogLevel value 1",
    "LevelWarn": "LogLevel value 2",
    "LevelError": "LogLevel value 3"
  },
  "terms": {
    "Replicated State Machine": "Multiple servers applying same command sequence",
    "Consensus": "Agreement among distributed processes",
    "CAP Theorem": "Trade-off between Consistency, Availability, and Partition tolerance",
    "Quorum": "Majority of servers required for decisions",
    "Term": "Monotonically increasing epoch number",
    "Log Entry": "Term, Index, and Command tuple",
    "Commit Index": "Highest index of a committed log entry",
    "State Machine": "Application logic applying commands",
    "Joint Consensus": "Protocol for safe membership changes",
    "Log Matching Property": "Logs are identical if they share an index and term",
    "Transport": "Abstract network communication layer",
    "LogStore": "Abstract storage for log entries",
    "Persistent State": "State that must survive crashes (term, votedFor, log)",
    "Volatile State": "In-memory state reconstructed after restart",
    "Leader": "Authoritative node coordinating operations",
    "Election Safety": "At most one leader per term",
    "Leader Completeness": "Leader contains all previously committed entries",
    "Randomized Timeout": "Timeout chosen randomly to prevent split votes",
    "Split Vote": "Election where no candidate achieves majority",
    "Log Comparison": "Process of determining which log is more up-to-date based on last term and index",
    "State Machine Safety": "All nodes apply same entries in same order",
    "Safety Properties": "Core correctness guarantees of Raft",
    "Figure 8 Scenario": "Safety violation scenario where committing old-term entries can lead to inconsistency",
    "Chain of Custody": "Mental model for Raft safety analogous to legal evidence handling",
    "Configuration": "Set of voting cluster members",
    "Learner": "Non-voting member catching up",
    "Disjoint Majorities": "Scenario where old and new configurations have non-overlapping majorities, potentially leading to dual leaders",
    "Catch-up": "Process of replicating log entries to a new or lagging server before allowing it to vote",
    "Two-Phase Commit Pattern": "Raft's normal operation: replication phase followed by commit phase",
    "Log Reconciliation": "Process to find matching log point with follower",
    "Consistency Check": "Verification that follower's log matches leader's at PrevLogIndex before appending new entries",
    "Heartbeat": "Empty AppendEntries RPC used to maintain leadership and prevent elections",
    "Quorum Intersection": "Property that any two majorities overlap",
    "Crash-stop": "failure model where servers fail by stopping and later may restart, but do not exhibit arbitrary (Byzantine) behavior",
    "Network Partition": "Network split isolating servers",
    "Leader Step-Down": "transition from leader to follower upon discovering a higher term",
    "Property-Based Testing": "testing approach that generates random inputs to verify invariants",
    "Safety Invariants": "properties that must always hold for correctness",
    "Liveness Properties": "properties that guarantee eventual progress",
    "Deterministic Simulation": "testing approach that controls randomness and timing to make failures reproducible",
    "Virtual Transport": "simulated network layer for testing",
    "Invariant Checking": "runtime verification of safety properties during tests",
    "Randomized Fault Injection": "introducing random network partitions, message loss, and crashes in tests",
    "Test Harness": "infrastructure to start nodes and observe behavior",
    "Event Trace": "recorded sequence of events for debugging test failures",
    "Structured Logging": "logging approach that captures events in a machine-readable format with consistent fields",
    "State Inspector": "tool that exposes internal node state via an API for debugging",
    "Heisenbug": "bug that disappears or alters behavior when attempting to study it",
    "Trace Visualization": "creating a timeline of events across nodes to understand system behavior",
    "Figure 8 scenario": "specific safety violation scenario from Raft paper involving committing old-term entries",
    "Log Compaction": "process of replacing old log entries with snapshots to bound storage growth",
    "Snapshot": "point-in-time capture of state machine state with Raft metadata",
    "Leader Lease": "time period during which leader can serve reads without quorum confirmation",
    "Linearizability": "strong consistency guarantee where each read returns the result of the most recent write",
    "gRPC": "high-performance RPC framework using HTTP/2 and Protocol Buffers",
    "Write-ahead log (WAL)": "durable log of operations before they're applied to state machine",
    "Learner Nodes": "non-voting Raft members that receive log replication but don't participate in elections",
    "Observability": "comprehensive monitoring, logging, and tracing of system behavior",
    "AppendEntries RPC": "Primary RPC for log replication and heartbeats",
    "Candidate": "Raft state when seeking votes",
    "Follower": "Raft state responding to leader/candidate RPCs",
    "Majority (Quorum)": "More than half of voting members",
    "Raft": "Consensus algorithm for replicated state machines",
    "RequestVote RPC": "RPC used by candidates to solicit votes"
  }
}