{
  "types": {
    "Vector3D": "fields: x double, y double, z double",
    "Point3D": "alias for Vector3D",
    "Color": "fields: r double, g double, b double",
    "Ray": "fields: origin Point3D, direction Vector3D",
    "HitRecord": "fields: point Point3D, normal Vector3D, t double, material shared_ptr<Material>",
    "Hittable": "abstract base class",
    "Material": "abstract base class",
    "HittableList": "container of Hittable objects",
    "Camera": "fields: lookfrom_ Point3D, lookat_ Point3D, world_up_ Vector3D, field_of_view_degrees_ double, aspect_ratio_ double, aperture_ double, focus_distance_ double",
    "ImageWriter": "utility class for PPM output",
    "RandomGenerator": "fields: generator mt19937, distribution uniform_real_distribution",
    "Renderer": "fields: image_width_ int, image_height_ int, samples_per_pixel_ int, max_depth_ int",
    "Sphere": "geometric primitive with center, radius, material",
    "LambertianMaterial": "fields: albedo Color",
    "MetalMaterial": "fields: albedo Color, fuzz double",
    "DielectricMaterial": "fields: refractive_index double",
    "Scene": "fields: world_ HittableList, scene_rng_ RandomGenerator",
    "GeometricValidator": "static validation methods for geometry",
    "MaterialValidator": "static validation methods for materials",
    "DebugUtils": "static debug utility class",
    "DebugLevel": "enum for diagnostic output levels",
    "TestUtils": "utility class for unit testing",
    "ImageCompare": "utility class for visual validation",
    "ComparisonResult": "struct containing image comparison metrics",
    "BVHNode": "fields: BoundingBox bounding_box, shared_ptr<BVHNode> left_child, shared_ptr<BVHNode> right_child, vector<shared_ptr<Hittable>> primitives",
    "BoundingBox": "fields: Point3D min_corner, Point3D max_corner",
    "BVHBuilder": "fields: SAH_cost_function cost_function, split_heuristic heuristic",
    "BVHTraverser": "fields: stack<BVHNode*> traversal_stack",
    "Vertex": "fields: Point3D position, Vector3D normal, double u, double v",
    "Triangle": "fields: int vertex0_index, int vertex1_index, int vertex2_index",
    "Mesh": "fields: vector<Vertex> vertices, vector<Triangle> triangles",
    "CSGNode": "fields: CSGOperation operation, shared_ptr<CSGNode> left_child, shared_ptr<CSGNode> right_child",
    "VolumeGrid": "fields: vector<double> density_data, int width, int height, int depth",
    "SubsurfaceMaterial": "fields: Color albedo, double scattering_coefficient, double absorption_coefficient",
    "EmissiveMaterial": "fields: Color emission_color, double emission_intensity",
    "ProceduralTexture": "fields: noise_function noise, double frequency, double amplitude"
  },
  "methods": {
    "hit(ray, t_min, t_max, hit_record)": "test ray intersection, return bool",
    "scatter(ray_in, hit_record, attenuation, scattered_ray)": "compute material scattering, return bool",
    "ray_color(ray, world, depth)": "recursive ray tracing, return Color",
    "write_ppm(filename, width, height, pixels)": "output PPM image file",
    "random_double()": "return random value [0,1)",
    "random_in_unit_sphere()": "return random Vector3D in unit sphere",
    "hit(ray, t_min, t_max, hit_record) returns bool": "test ray intersection",
    "at(t) returns Point3D": "evaluate point along ray at parameter t",
    "length() returns double": "compute vector magnitude",
    "dot(other) returns double": "computes dot product with another vector",
    "normalize() returns Vector3D": "return unit vector in same direction",
    "clamp(min, max) returns Color": "clamp color components",
    "gamma_correct(gamma) returns Color": "apply gamma correction",
    "add(object)": "add object to hittable list",
    "clear()": "remove all objects from list",
    "size() returns size_t": "return number of objects in list",
    "scatter(ray_in, hit_record, attenuation, scattered_ray) returns bool": "compute material scattering",
    "reflect(incident, normal) returns Vector3D": "computes reflection direction using law of reflection",
    "refract(incident, normal, eta_ratio) returns Vector3D": "computes refraction direction using Snell's law",
    "reflectance(cosine, refractive_index) returns double": "estimates Fresnel reflectance using Schlick approximation",
    "random_double() returns double": "return random value [0,1)",
    "random_in_unit_sphere() returns Vector3D": "return random Vector3D in unit sphere",
    "random_unit_vector() returns Vector3D": "random unit vector",
    "near_zero() returns bool": "checks if vector components are near zero",
    "get_ray(u, v) returns Ray": "generate camera ray",
    "compute_viewport_parameters() returns void": "calculate camera basis vectors and viewport geometry",
    "random_in_unit_disk() returns Vector3D": "random point in unit disk",
    "random_in_unit_disk_polar() returns Vector3D": "generate uniform random point using polar coordinates",
    "position() returns Point3D": "accessor for camera position",
    "target() returns Point3D": "accessor for look-at target",
    "field_of_view() returns double": "accessor for field of view in degrees",
    "aperture() returns double": "accessor for lens aperture size",
    "focus_distance() returns double": "accessor for focus plane distance",
    "cross(other) returns Vector3D": "compute cross product with another vector",
    "length_squared() returns double": "compute squared vector magnitude for efficiency",
    "ray_color(ray, world, depth) returns Color": "recursive ray tracing",
    "sample_pixel(camera, world, pixel_x, pixel_y) returns Color": "antialiasing with multiple samples",
    "render(camera, world, filename) returns void": "main rendering pipeline",
    "write_ppm(filename, width, height, pixels) returns void": "output PPM image file",
    "add_object(object) returns void": "add to scene",
    "is_valid_vector(v) returns bool": "check if vector has finite components",
    "is_near_zero(v) returns bool": "check if vector components near zero",
    "safe_normalize(v) returns Vector3D": "normalize with degenerate case handling",
    "is_valid_ray(ray) returns bool": "validate ray origin and direction",
    "sanitize_ray(ray) returns Ray": "repair degenerate rays with fallbacks",
    "clamp_color(c) returns Color": "clamp color to valid HDR range",
    "is_valid_albedo(albedo) returns bool": "check albedo in [0,1] range",
    "is_valid_intersection(t, t_min, t_max) returns bool": "validate intersection parameter",
    "ensure_outward_normal(normal, ray_direction) returns Vector3D": "flip normal to point outward",
    "clamp_refractive_index(eta) returns double": "clamp to physically valid range",
    "can_refract(cos_theta, eta_ratio) returns bool": "check for total internal reflection",
    "safe_schlick_reflectance(cos_theta, eta) returns double": "robust Fresnel calculation",
    "log_validation_error(component, error) returns void": "diagnostic error logging",
    "debug_normal_color(normal) returns Color": "convert normal to debug color",
    "approximately_equal(a, b, epsilon) returns bool": "floating point comparison with tolerance",
    "vectors_equal(a, b, epsilon) returns bool": "vector comparison with per-component epsilon",
    "colors_equal(a, b, epsilon) returns bool": "color comparison with per-component epsilon",
    "create_test_ray(origin, direction) returns Ray": "create ray with known properties for testing",
    "create_unit_sphere(center, radius) returns Sphere": "create test sphere at specified location",
    "compare_images(image1, image2, width, height, tolerance) returns ComparisonResult": "pixel-by-pixel image comparison",
    "load_ppm_image(filename, width, height) returns vector<Color>": "load PPM image for comparison",
    "save_difference_image(image1, image2, width, height, filename) returns void": "save difference image highlighting discrepancies",
    "debug_depth_color(t, max_depth) returns Color": "convert depth to grayscale",
    "debug_material_color(material_type) returns Color": "unique color per material type",
    "debug_ray_direction_color(direction) returns Color": "visualize ray directions",
    "set_debug_level(level) returns void": "configure diagnostic output",
    "log_intersection_stats(hits, misses, total) returns void": "statistical logging",
    "build_bvh(primitives) returns shared_ptr<BVHNode>": "construct acceleration structure with SAH splitting",
    "intersect_triangle(ray, vertices) returns HitRecord": "Möller-Trumbore ray-triangle intersection",
    "evaluate_noise(position) returns double": "Perlin noise evaluation at 3D point",
    "march_volume(ray, step_size) returns Color": "volumetric ray marching with density sampling",
    "scatter_subsurface(ray_in, hit_record) returns bool": "dipole approximation subsurface scattering",
    "sample_emissive_surface(point) returns Vector3D": "importance sampling for area lights",
    "evaluate_csg(ray, csg_tree) returns vector<double>": "boolean operation intersection intervals"
  },
  "constants": {
    "t_min": "0.001 - minimum intersection distance",
    "max_depth": "50 - maximum ray bounces",
    "samples_per_pixel": "10-100 - antialiasing samples",
    "t_max": "large value for maximum range",
    "M_PI": "mathematical constant pi for angle conversions",
    "lens_radius": "aperture / 2.0 for depth of field calculations",
    "viewport_height": "2.0 * tan(field_of_view_radians / 2.0) * focus_distance",
    "viewport_width": "viewport_height * aspect_ratio",
    "EPSILON": "1e-8 - numerical precision threshold",
    "T_MIN": "0.001 - minimum intersection distance",
    "T_MAX": "infinity - maximum intersection range",
    "MIN_REFRACTIVE_INDEX": "1.0 - minimum physical refractive index",
    "MAX_REFRACTIVE_INDEX": "4.0 - maximum physical refractive index",
    "MIN_VECTOR_LENGTH": "minimum valid vector length",
    "MAX_HDR_COMPONENT": "1000.0 - maximum HDR color component",
    "GAMMA_CORRECTION_POWER": "1.0/2.2 - standard gamma correction",
    "BVH_LEAF_SIZE": "maximum primitives per leaf node",
    "THREAD_POOL_SIZE": "number of worker threads",
    "VOLUME_STEP_SIZE": "ray marching interval distance",
    "CSG_EPSILON": "tolerance for boolean operations",
    "SUBSURFACE_SAMPLES": "number of dipole approximation samples"
  },
  "terms": {
    "backwards ray tracing": "tracing rays from camera toward scene",
    "primary rays": "initial rays from camera through pixels",
    "secondary rays": "rays from surface interactions",
    "Monte Carlo integration": "random sampling for rendering equation",
    "shadow acne": "speckled artifacts from self-intersection",
    "gamma correction": "nonlinear color space conversion",
    "architectural guardrails": "deliberate project scope limitations",
    "baseline efficiency": "reasonable performance without optimization",
    "teaching moment": "code that illuminates principles clearly",
    "intentional limitations": "features excluded to maintain focus",
    "parametric equation": "P(t) = origin + t * direction for ray representation",
    "quadratic discriminant": "b² - 4ac determining intersection behavior",
    "closest-hit algorithm": "finding nearest intersection among objects",
    "outward normal": "surface normal pointing away from interior",
    "HDR": "High Dynamic Range color values",
    "Lambertian reflection": "perfectly diffuse scattering following cosine distribution",
    "specular reflection": "mirror-like reflection following law of reflection",
    "Fresnel equations": "angle-dependent reflection and transmission at material interfaces",
    "total internal reflection": "complete reflection when refraction impossible",
    "refractive index": "ratio of light speed in vacuum to light speed in material",
    "albedo": "fraction of incident light reflected by a surface",
    "Schlick approximation": "polynomial Fresnel reflectance estimate",
    "cosine-weighted distribution": "diffuse scattering probability",
    "look-at camera model": "intuitive camera positioning using position, target, and up vector",
    "thin lens approximation": "simplified lens model for depth of field simulation",
    "viewport coordinate system": "rectangular window in 3D space through which camera sees scene",
    "lens disk sampling": "random ray origin distribution within circular aperture",
    "focus distance": "distance to plane of perfect focus in thin lens model",
    "field of view": "angular width of camera's view, controls zoom level",
    "camera basis vectors": "orthonormal coordinate system defining camera orientation",
    "depth of field": "focus effects where objects at different distances appear with varying sharpness",
    "bokeh": "aesthetic blur quality in out-of-focus areas",
    "pinhole camera model": "theoretical camera with infinite depth of field",
    "aperture": "size of lens opening controlling depth of field strength",
    "NDC coordinates": "normalized device coordinates in range [0,1]",
    "antialiasing": "multiple samples per pixel to reduce jagged edges",
    "aspect ratio": "width to height ratio preventing image distortion",
    "recursive ray tracing": "following ray bounces through surface interactions",
    "tone mapping": "converting HDR to display range",
    "color accumulation": "combining colors from multiple ray paths",
    "Russian roulette optimization": "probabilistic ray termination",
    "photographic sampling": "sampling light at each pixel location",
    "relay race of light simulation": "component handoff analogy",
    "pinball machine": "ray bouncing analogy",
    "entropy source": "randomness provider for realistic simulation",
    "discriminant": "quadratic formula term determining intersection",
    "energy conservation": "materials cannot create light energy",
    "graceful degradation": "reasonable fallback behavior for edge cases",
    "epsilon threshold": "tolerance for floating-point comparisons",
    "degenerate ray": "ray with invalid direction or components",
    "reference image": "known-correct rendering output for comparison",
    "visual validation": "comparing rendered output with expected visual results",
    "regression testing": "automated testing to catch functionality breakage",
    "statistical convergence": "Monte Carlo samples approaching expected distribution",
    "pixel-perfect match": "identical pixel values in deterministic rendering",
    "perceptual difference": "human-visible variations in image quality",
    "debug rendering modes": "false-color images showing isolated component data",
    "visual regression testing": "comparing rendered output against reference images",
    "deterministic mode": "fixed random seeds for reproducible testing",
    "diagnostic scene library": "test scenes designed to isolate specific functionality",
    "floating-point precision issues": "numerical errors affecting ray calculations",
    "acceleration structure": "spatial data organization for fast ray intersection",
    "bvh": "bounding volume hierarchy tree structure",
    "surface area heuristic": "BVH splitting cost function",
    "embarrassing parallelism": "computation easily divided into independent tasks",
    "subsurface scattering": "light transport through translucent materials",
    "dipole approximation": "mathematical model for subsurface light transport",
    "emissive material": "geometry that emits light",
    "procedural texture": "algorithmically generated surface properties",
    "triangle mesh": "surface represented by triangular faces",
    "constructive solid geometry": "boolean combinations of primitive shapes",
    "volumetric rendering": "light transport through participating media",
    "ray marching": "sampling technique for volume integration",
    "phase function": "angular scattering distribution in volumes",
    "multiple importance sampling": "variance reduction technique combining sampling strategies",
    "BVH": "bounding volume hierarchy tree structure"
  }
}