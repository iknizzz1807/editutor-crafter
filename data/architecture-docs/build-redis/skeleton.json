{
  "title": "Build Your Own Redis: Design Document",
  "overview": "This system implements an in-memory data structure store compatible with the Redis protocol, supporting key-value operations, data structures, persistence, pub/sub messaging, and horizontal scaling. The key architectural challenge is building a high-performance concurrent server that handles the Redis protocol while managing memory efficiently and providing durability guarantees.",
  "sections": [
    {
      "id": "context-and-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains what Redis is, why in-memory data stores are valuable, and the engineering challenges of building a production-quality database system.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "Mental Model: The Ultra-Fast Librarian",
          "summary": "Introduces Redis through the analogy of a super-fast librarian who memorizes everything and can instantly retrieve any book or information."
        },
        {
          "id": "problem-definition",
          "title": "Problem Definition",
          "summary": "Defines the specific challenges of building an in-memory database: protocol compatibility, concurrency, persistence, and performance."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches Comparison",
          "summary": "Compares different in-memory database architectures and protocol designs used by Redis, Memcached, and other systems."
        }
      ]
    },
    {
      "id": "goals-and-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Clearly defines what this Redis implementation will and will not support, setting appropriate scope for an educational project.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Lists the core Redis features we will implement: basic commands, data structures, persistence, pub/sub, and clustering."
        },
        {
          "id": "non-functional-goals",
          "title": "Non-Functional Goals",
          "summary": "Defines performance, reliability, and compatibility targets appropriate for a learning project."
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Lists Redis features we will NOT implement to keep scope manageable: Lua scripting, modules, streams, etc."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Presents the overall system design showing how the TCP server, protocol parser, data store, and persistence components interact.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Describes the major system components: Network Layer, Protocol Layer, Command Layer, Storage Layer, and Persistence Layer."
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "Provides a concrete directory and module organization for implementing the Redis clone in Go."
        },
        {
          "id": "data-flow",
          "title": "Request Processing Flow",
          "summary": "Traces how a client command flows through all system layers from TCP socket to storage and back."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines all key data structures used throughout the system: database entries, RESP types, client connections, and persistence records.",
      "subsections": [
        {
          "id": "core-types",
          "title": "Core Data Types",
          "summary": "Defines the fundamental types: RedisValue, DatabaseEntry, Connection, and their relationships."
        },
        {
          "id": "resp-protocol-types",
          "title": "RESP Protocol Types",
          "summary": "Describes the five RESP data types and their wire format representation."
        },
        {
          "id": "storage-structures",
          "title": "Storage Data Structures",
          "summary": "Details the internal data structures for strings, lists, sets, hashes, and their memory layout."
        }
      ]
    },
    {
      "id": "network-layer",
      "title": "Network Layer Design",
      "summary": "Covers TCP server implementation, connection management, and concurrent client handling (Milestone 1).",
      "subsections": [
        {
          "id": "tcp-server-mental-model",
          "title": "Mental Model: The Hotel Reception Desk",
          "summary": "Explains TCP server concepts through the analogy of a hotel managing multiple guest check-ins simultaneously."
        },
        {
          "id": "connection-lifecycle",
          "title": "Connection Lifecycle Management",
          "summary": "Describes how connections are established, maintained, and gracefully closed."
        },
        {
          "id": "concurrency-model",
          "title": "Concurrency Architecture Decision",
          "summary": "ADR comparing goroutine-per-connection vs event loop vs worker pool models for handling concurrent clients."
        },
        {
          "id": "network-pitfalls",
          "title": "Common Network Programming Pitfalls",
          "summary": "Lists typical mistakes when implementing TCP servers: partial reads, resource leaks, blocking operations."
        },
        {
          "id": "network-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides Go-specific TCP server skeleton code and connection handling patterns."
        }
      ]
    },
    {
      "id": "protocol-layer",
      "title": "RESP Protocol Implementation",
      "summary": "Implements Redis Serialization Protocol parsing and serialization for all five RESP data types (Milestone 1).",
      "subsections": [
        {
          "id": "resp-mental-model",
          "title": "Mental Model: The Universal Translator",
          "summary": "Explains RESP protocol as a translation system that converts between human-readable commands and wire format."
        },
        {
          "id": "resp-parsing-algorithm",
          "title": "RESP Parsing Algorithm",
          "summary": "Step-by-step algorithm for parsing RESP types from a byte stream, handling partial reads and framing."
        },
        {
          "id": "resp-serialization",
          "title": "RESP Serialization",
          "summary": "Algorithm for encoding Redis responses into RESP wire format with proper CRLF line endings."
        },
        {
          "id": "protocol-pitfalls",
          "title": "Protocol Implementation Pitfalls",
          "summary": "Common mistakes: forgetting CRLF, not handling binary data, improper length parsing."
        },
        {
          "id": "protocol-implementation",
          "title": "Implementation Guidance",
          "summary": "Provides RESP parser skeleton with buffer management and type detection logic."
        }
      ]
    },
    {
      "id": "command-layer",
      "title": "Command Processing Layer",
      "summary": "Implements command dispatch, argument validation, and the core GET/SET/DEL operations (Milestone 2).",
      "subsections": [
        {
          "id": "command-mental-model",
          "title": "Mental Model: The Restaurant Kitchen",
          "summary": "Explains command processing as a kitchen that receives orders, validates ingredients, and produces dishes."
        },
        {
          "id": "command-dispatch",
          "title": "Command Dispatch Pattern",
          "summary": "Architecture for routing parsed commands to appropriate handler functions with argument validation."
        },
        {
          "id": "basic-operations",
          "title": "Core Key-Value Operations",
          "summary": "Implementation details for GET, SET, and DEL commands including return value handling."
        },
        {
          "id": "command-pitfalls",
          "title": "Command Processing Pitfalls",
          "summary": "Case sensitivity issues, argument count validation, binary-safe string handling."
        },
        {
          "id": "command-implementation",
          "title": "Implementation Guidance",
          "summary": "Command handler skeleton code and dispatch table setup in Go."
        }
      ]
    },
    {
      "id": "storage-layer",
      "title": "Storage Layer Design",
      "summary": "Implements in-memory data structures, type safety, and concurrent access patterns for the core database (Milestones 2-4).",
      "subsections": [
        {
          "id": "storage-mental-model",
          "title": "Mental Model: The Organized Warehouse",
          "summary": "Explains storage layer as a warehouse with different sections for different types of items, with inventory tracking."
        },
        {
          "id": "hash-table-design",
          "title": "Hash Table Architecture Decision",
          "summary": "ADR comparing different hash table implementations: built-in map vs custom hash table vs concurrent map."
        },
        {
          "id": "data-structure-implementations",
          "title": "Data Structure Implementations",
          "summary": "Design decisions for implementing Redis lists, sets, and hashes with performance trade-offs."
        },
        {
          "id": "concurrency-control",
          "title": "Concurrency Control Strategy",
          "summary": "ADR for managing concurrent access: global lock vs per-key locks vs lock-free structures."
        },
        {
          "id": "storage-pitfalls",
          "title": "Storage Implementation Pitfalls",
          "summary": "Type confusion errors, memory leaks, race conditions in concurrent access."
        },
        {
          "id": "storage-implementation",
          "title": "Implementation Guidance",
          "summary": "Storage layer interfaces and data structure skeletons with thread-safety patterns."
        }
      ]
    },
    {
      "id": "expiration-system",
      "title": "Key Expiration System",
      "summary": "Implements TTL support with both lazy and active expiration strategies (Milestone 3).",
      "subsections": [
        {
          "id": "expiration-mental-model",
          "title": "Mental Model: The Parking Meter System",
          "summary": "Explains key expiration through parking meters that track time limits and enforce removal."
        },
        {
          "id": "expiration-strategies",
          "title": "Expiration Strategy Architecture Decision",
          "summary": "ADR comparing lazy-only vs active-only vs hybrid expiration approaches."
        },
        {
          "id": "time-handling",
          "title": "Time and Precision Handling",
          "summary": "Design decisions for time storage, precision, and handling clock-related edge cases."
        },
        {
          "id": "active-expiration-algorithm",
          "title": "Active Expiration Algorithm",
          "summary": "Probabilistic sampling algorithm for finding and removing expired keys in background."
        },
        {
          "id": "expiration-pitfalls",
          "title": "Expiration Implementation Pitfalls",
          "summary": "Clock drift issues, memory leaks from expired keys, performance problems with time checks."
        },
        {
          "id": "expiration-implementation",
          "title": "Implementation Guidance",
          "summary": "TTL tracking structures and expiration worker implementation in Go."
        }
      ]
    },
    {
      "id": "persistence-rdb",
      "title": "RDB Snapshot Persistence",
      "summary": "Implements point-in-time snapshots using binary serialization and background save processes (Milestone 5).",
      "subsections": [
        {
          "id": "rdb-mental-model",
          "title": "Mental Model: The Photography Studio",
          "summary": "Explains RDB snapshots as taking photographs of the database state at specific moments in time."
        },
        {
          "id": "serialization-format",
          "title": "Binary Serialization Format",
          "summary": "Design of the RDB file format with headers, type markers, and data encoding."
        },
        {
          "id": "background-save-adr",
          "title": "Background Save Architecture Decision",
          "summary": "ADR comparing fork-based vs thread-based vs blocking approaches for BGSAVE implementation."
        },
        {
          "id": "atomic-writes",
          "title": "Atomic File Operations",
          "summary": "Strategy for ensuring RDB files are never partially written or corrupted."
        },
        {
          "id": "rdb-pitfalls",
          "title": "RDB Implementation Pitfalls",
          "summary": "Blocking main thread, incomplete writes, handling fork() failures, endianness issues."
        },
        {
          "id": "rdb-implementation",
          "title": "Implementation Guidance",
          "summary": "RDB file format structures and background save implementation patterns."
        }
      ]
    },
    {
      "id": "persistence-aof",
      "title": "Append-Only File Persistence",
      "summary": "Implements write-ahead logging for durability with configurable fsync policies and log compaction (Milestone 6).",
      "subsections": [
        {
          "id": "aof-mental-model",
          "title": "Mental Model: The Laboratory Notebook",
          "summary": "Explains AOF as a scientist's notebook that records every experiment step so work can be recreated."
        },
        {
          "id": "wal-design",
          "title": "Write-Ahead Logging Design",
          "summary": "Architecture for logging commands before execution with crash recovery guarantees."
        },
        {
          "id": "fsync-policy-adr",
          "title": "Fsync Policy Architecture Decision",
          "summary": "ADR comparing always, everysec, and no fsync policies balancing durability vs performance."
        },
        {
          "id": "aof-rewrite",
          "title": "AOF Rewrite Algorithm",
          "summary": "Background process for compacting the AOF by generating minimal command sequence."
        },
        {
          "id": "aof-pitfalls",
          "title": "AOF Implementation Pitfalls",
          "summary": "Unbounded file growth, concurrent access during rewrite, data loss from buffered writes."
        },
        {
          "id": "aof-implementation",
          "title": "Implementation Guidance",
          "summary": "AOF logging infrastructure and rewrite process implementation."
        }
      ]
    },
    {
      "id": "pubsub-system",
      "title": "Publish/Subscribe System",
      "summary": "Implements Redis pub/sub messaging with channel subscriptions and pattern matching (Milestone 7).",
      "subsections": [
        {
          "id": "pubsub-mental-model",
          "title": "Mental Model: The News Broadcasting Network",
          "summary": "Explains pub/sub as a radio station broadcasting on different channels with listeners tuning in."
        },
        {
          "id": "subscription-management",
          "title": "Subscription Management",
          "summary": "Data structures and algorithms for tracking client subscriptions and delivering messages."
        },
        {
          "id": "pattern-matching",
          "title": "Pattern Subscription Matching",
          "summary": "Implementation of glob-style pattern matching for channel subscriptions."
        },
        {
          "id": "connection-state-adr",
          "title": "Connection State Architecture Decision",
          "summary": "ADR for handling subscribed clients and preventing regular commands during subscription mode."
        },
        {
          "id": "pubsub-pitfalls",
          "title": "Pub/Sub Implementation Pitfalls",
          "summary": "Memory leaks from disconnected subscribers, race conditions in publish, blocking state management."
        },
        {
          "id": "pubsub-implementation",
          "title": "Implementation Guidance",
          "summary": "Subscription tracking structures and message delivery implementation."
        }
      ]
    },
    {
      "id": "cluster-mode",
      "title": "Cluster Mode and Sharding",
      "summary": "Implements horizontal scaling with hash slot based key distribution and cluster topology management (Milestone 8).",
      "subsections": [
        {
          "id": "cluster-mental-model",
          "title": "Mental Model: The Mall Directory System",
          "summary": "Explains clustering as a shopping mall where each store handles specific types of items based on a directory system."
        },
        {
          "id": "hash-slot-algorithm",
          "title": "Hash Slot Assignment Algorithm",
          "summary": "CRC16-based key routing algorithm ensuring consistent mapping of keys to cluster nodes."
        },
        {
          "id": "cluster-topology",
          "title": "Cluster Topology Management",
          "summary": "Gossip protocol for sharing node state and detecting failures in the cluster."
        },
        {
          "id": "sharding-adr",
          "title": "Sharding Strategy Architecture Decision",
          "summary": "ADR comparing hash slot vs consistent hashing vs range-based sharding approaches."
        },
        {
          "id": "cluster-pitfalls",
          "title": "Cluster Implementation Pitfalls",
          "summary": "Network partitions, cross-slot operations, key migration complexity, split brain scenarios."
        },
        {
          "id": "cluster-implementation",
          "title": "Implementation Guidance",
          "summary": "Cluster node communication and hash slot management implementation."
        }
      ]
    },
    {
      "id": "interactions-and-data-flow",
      "title": "Component Interactions and Data Flow",
      "summary": "Describes how all system components communicate and the complete request/response flow through the system.",
      "subsections": [
        {
          "id": "request-flow",
          "title": "Complete Request Processing Flow",
          "summary": "Step-by-step trace of how a client command flows through network, protocol, command, and storage layers."
        },
        {
          "id": "persistence-integration",
          "title": "Persistence Integration Points",
          "summary": "How RDB and AOF persistence integrate with the main request processing pipeline."
        },
        {
          "id": "cluster-communication",
          "title": "Cluster Node Communication Patterns",
          "summary": "Message formats and protocols for inter-node communication in cluster mode."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Comprehensive error handling strategy covering network failures, protocol errors, storage issues, and cluster failures.",
      "subsections": [
        {
          "id": "error-categories",
          "title": "Error Categories and Response Codes",
          "summary": "Classification of different error types and appropriate Redis error response formats."
        },
        {
          "id": "failure-modes",
          "title": "System Failure Modes",
          "summary": "Analysis of potential failure scenarios and recovery strategies for each component."
        },
        {
          "id": "graceful-degradation",
          "title": "Graceful Degradation Strategies",
          "summary": "How the system behaves when individual components fail or become unavailable."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy and Milestones",
      "summary": "Comprehensive testing approach with specific checkpoints for each milestone to verify correct implementation.",
      "subsections": [
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Validation Checkpoints",
          "summary": "Specific tests and expected behaviors to verify after completing each project milestone."
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing with Redis Clients",
          "summary": "How to test compatibility using existing Redis clients and tools like redis-cli."
        },
        {
          "id": "performance-testing",
          "title": "Performance and Load Testing",
          "summary": "Approaches for testing system performance and identifying bottlenecks."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Systematic debugging strategies for common issues learners encounter when building Redis, with specific symptoms and solutions.",
      "subsections": [
        {
          "id": "protocol-debugging",
          "title": "Protocol and Network Issues",
          "summary": "Debugging TCP connection problems, RESP parsing errors, and client compatibility issues."
        },
        {
          "id": "concurrency-debugging",
          "title": "Concurrency and Race Condition Debugging",
          "summary": "Identifying and fixing race conditions, deadlocks, and data races in concurrent operations."
        },
        {
          "id": "persistence-debugging",
          "title": "Persistence and Data Corruption Issues",
          "summary": "Debugging RDB and AOF problems including corruption, incomplete writes, and recovery failures."
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools and Techniques",
          "summary": "Recommended tools and approaches for inspecting system state and tracing execution."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions and Scalability",
      "summary": "Discusses potential enhancements and how the current design accommodates future Redis features and optimizations.",
      "subsections": [
        {
          "id": "additional-commands",
          "title": "Additional Redis Commands",
          "summary": "How to extend the system to support more Redis commands and data types."
        },
        {
          "id": "performance-optimizations",
          "title": "Performance Optimization Opportunities",
          "summary": "Advanced optimizations like memory pooling, zero-copy networking, and lock-free data structures."
        },
        {
          "id": "advanced-features",
          "title": "Advanced Redis Features",
          "summary": "How to add Lua scripting, modules, streams, and other advanced Redis capabilities."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of all technical terms, acronyms, and Redis-specific vocabulary used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "High-Level System Architecture",
      "description": "Shows the major system components (Network Layer, Protocol Layer, Command Layer, Storage Layer, Persistence Layer) and their connections. Include client connections, command flow, and persistence interactions.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-and-data-flow"
      ]
    },
    {
      "id": "data-model",
      "title": "Core Data Model Relationships",
      "description": "Shows the relationships between RedisValue types, DatabaseEntry, Connection, and storage structures. Include inheritance hierarchy for different value types (String, List, Set, Hash).",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "storage-layer"
      ]
    },
    {
      "id": "request-processing-flow",
      "title": "Request Processing Sequence",
      "description": "Sequence diagram showing a complete client request from TCP connection through RESP parsing, command dispatch, storage access, and response serialization.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-and-data-flow",
        "network-layer",
        "protocol-layer",
        "command-layer"
      ]
    },
    {
      "id": "connection-state-machine",
      "title": "Client Connection State Machine",
      "description": "State machine showing connection states: Connected, Subscribed, Blocked, etc. Include transitions for SUBSCRIBE/UNSUBSCRIBE, blocking commands, and disconnection.",
      "type": "state-machine",
      "relevant_sections": [
        "network-layer",
        "pubsub-system"
      ]
    },
    {
      "id": "persistence-architecture",
      "title": "Persistence Architecture Components",
      "description": "Shows RDB and AOF components, their relationship to the main storage layer, background processes, and file system interactions. Include SAVE/BGSAVE flows.",
      "type": "component",
      "relevant_sections": [
        "persistence-rdb",
        "persistence-aof"
      ]
    },
    {
      "id": "cluster-topology",
      "title": "Cluster Node Topology and Communication",
      "description": "Shows cluster nodes, hash slot distribution, client redirections (MOVED responses), and gossip protocol communication between nodes.",
      "type": "component",
      "relevant_sections": [
        "cluster-mode"
      ]
    },
    {
      "id": "expiration-process",
      "title": "Key Expiration Process Flow",
      "description": "Flowchart showing both lazy expiration (on key access) and active expiration (background sampling) processes with decision points and cleanup actions.",
      "type": "flowchart",
      "relevant_sections": [
        "expiration-system"
      ]
    },
    {
      "id": "pubsub-message-flow",
      "title": "Pub/Sub Message Delivery Flow",
      "description": "Sequence diagram showing message publication, subscription matching (including pattern matching), and delivery to multiple subscribers.",
      "type": "sequence",
      "relevant_sections": [
        "pubsub-system"
      ]
    }
  ]
}