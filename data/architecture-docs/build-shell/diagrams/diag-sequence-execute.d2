shape: sequence_diagram

title: "Sequence: Executing `ls -l | grep foo`"
description: "A sequence diagram showing how a shell executes a piped command"

# Actors
user: "User"
repl: "REPL (Read-Eval-Print Loop)" {
  style.bold: true
}
parser: "Parser"
executor: "Executor"
pipe: "Pipe" {
  shape: cylinder
}
child1: "Child Process 1 (ls)" {
  style.fill: "#0f3460"
}
child2: "Child Process 2 (grep)" {
  style.fill: "#0f3460"
}

# Styling
style {
  stroke: "#3fb950"
  fill: "#16213e"
  font-color: "#e6edf3"
  opacity: 1.0
}

# Sequence of events
user -> repl: "ls -l | grep foo"
repl -> parser: "parse(command)"
parser -> repl: "return AST"
repl -> executor: "execute(AST)"

# Pipe creation and first child setup
executor -> pipe: "create()"
executor -> child1: "fork()"
child1 -> child1: "dup2(pipe.write, stdout)"
child1 -> pipe: "close(read)"
executor -> pipe: "close(write)"
child1 -> child1: "execvp(\"ls\", [\"ls\", \"-l\"])"

# Second child setup
executor -> child2: "fork()"
child2 -> child2: "dup2(pipe.read, stdin)"
child2 -> pipe: "close(write)"
executor -> pipe: "close(read)"
child2 -> child2: "execvp(\"grep\", [\"grep\", \"foo\"])"

# Waiting for children
executor -> child1: "wait()"
executor -> child2: "wait()"

# Cleanup and prompt display
executor -> repl: "return exit status"
repl -> user: "display prompt"