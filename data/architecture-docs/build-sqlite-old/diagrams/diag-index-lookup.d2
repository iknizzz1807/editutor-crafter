direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

# --- CLASSES: TECHNICAL VISUAL STANDARDS ---
classes: {
  header: {
    style: {
      fill: "#E4DBFE" # Purple: Metadata/Structure
      stroke-width: 2
      bold: true
    }
  }
  payload: {
    style: {
      fill: "#C7F1FF" # Blue: Logical Data
      stroke-width: 1
    }
  }
  pointer: {
    style: {
      stroke-dash: 3
      opacity: 0.6
    }
  }
  highlight: {
    style: {
      fill: "#ACE1AF" # Green: Found/Target Data
      stroke: "#167c3c"
      stroke-width: 3
    }
  }
  offset_label: {
    shape: text
    style: {
      font: mono
      font-size: 10
      font-color: "#525F7F"
    }
  }
}

# --- ARCHITECTURE: THE DOUBLE-LOOKUP WALK ---

title: |md
  # The Double-Lookup Walk (Index-to-Table)
  ### Trace: `SELECT * FROM users WHERE email = 'alice@db.com'`
| {near: top-center}

# Context Navigation
back_to_map: "Back to Map (L0)" {
  link: "#l0-satellite-map"
  shape: package
  style.fill: "#DEE1EB"
}

# --- COMPONENT 1: SECONDARY INDEX (NON-CLUSTERED) ---
secondary_index: "Secondary Index B+Tree (Leaf Page)" {
  link: "#milestone-7"
  
  page_struct: {
    grid-columns: 2
    grid-gap: 0
    
    # 8KB Page Layout Simulation (Byte-Offset Column)
    off0: "0x00" {class: offset_label}
    header: "PAGE_HEADER (Type: 0x0A - Index Leaf)" {class: header; width: 320}
    
    off12: "0x0C" {class: offset_label}
    ptr_array: "CELL POINTER ARRAY (Offsets: [0xFD2, 0xFA0, ...])" {class: header}
    
    off100: "0x64" {class: offset_label}
    unallocated: "FREE SPACE (Fragmented)" {style.fill: "#F6F9FC"; style.font-color: gray}
    
    off4000: "0xFA0" {class: offset_label}
    cell_n: "Cell N: ('bob@db.com' | RowID: 43)" {class: payload}
    
    off4050: "0xFD2" {class: offset_label}
    target_cell: "Cell 5: ('alice@db.com' | RowID: 42)" {class: highlight}
  }
}

# Root-level explanation for Step 1
step1_ex: |md
  ### Step 1: Index Seek
  1. VM traverses the Index B+Tree.
  2. Locates leaf page at `off4050`.
  3. Extracts the payload: key and **RowID 42**.
| {near: center-left}

# --- THE BRIDGE: LOGICAL POINTER EXTRACTION ---
rowid_extraction: "EXTRACTED ROWID: 42" {
  shape: diamond
  style.fill: "#FFF9C9"
  style.bold: true
  style.stroke: "#9D341E"
}

# Trace Line: Step 1 to Bridge
secondary_index.page_struct.target_cell -> rowid_extraction: "1. Key Match (Value -> Pointer)" {
  style: {
    stroke: "#6772E5"
    stroke-width: 4
    animated: true
  }
}

# --- COMPONENT 2: MAIN TABLE (CLUSTERED INDEX) ---
table_btree: "Table B-Tree (Clustered Leaf)" {
  link: "#milestone-5"
  
  page_struct: {
    grid-columns: 2
    grid-gap: 0
    
    off0: "0x00" {class: offset_label}
    header: "PAGE_HEADER (Type: 0x0D - Table Leaf)" {class: header; width: 320}
    
    off12: "0x0C" {class: offset_label}
    ptr_array: "POINTER ARRAY (Sorted by RowID)" {class: header}
    
    off2000: "0x7D0" {class: offset_label}
    unallocated: "FREE SPACE" {style.fill: "#F6F9FC"; style.font-color: gray}
    
    off3800: "0xED8" {class: offset_label}
    target_row: "Row 42: {ID: 42, Name: 'Alice', Bio: '...', Pic: [BLOB]}" {class: highlight}
    
    off3950: "0xF6E" {class: offset_label}
    other_row: "Row 43: {ID: 43, Name: 'Bob', ...}" {class: payload}
  }
}

# Root-level explanation for Step 2
step2_ex: |md
  ### Step 2: Table Point Lookup
  1. VM uses **RowID 42** to seek.
  2. B-Tree path: Root -> Internal -> Leaf.
  3. Reconstructs full row data from `0xED8`.
| {near: center-right}

# Trace Line: Bridge to Step 2
rowid_extraction -> table_btree.page_struct.target_row: "2. RowID Lookup (Clustered Seek)" {
  style: {
    stroke: "#6772E5"
    stroke-width: 4
    animated: true
  }
}

# --- DATA EMISSION: FINAL OUTPUT ---
result_set: "VDBE Output Register" {
  shape: sql_table
  style.fill: "#ACE1AF"
  row1: "Alice | Bio Content | [Full Columns]"
}

table_btree.page_struct.target_row -> result_set: "3. Emit Row (Project All Columns)" {
  style: {
    stroke: "#167c3c"
    stroke-width: 2
  }
  target-arrowhead: triangle
}

# --- LEGEND & METRICS ---
legend: {
  near: bottom-right
  secondary_color: "Index Metadata (Structure)" {
    style.fill: "#E4DBFE"
  }
  data_color: "Table Payload (Data)" {
    style.fill: "#C7F1FF"
  }
  path: "Logical Seek Path" {
    style.stroke: "#6772E5"
    style.stroke-width: 4
  }
}

# --- FOOTER ---
footer_note: |md
  **Latency Analysis**:
  - **Index Seek**: $O(\log_{fanout} N)$ I/O operations.
  - **Table Seek**: Additional $O(\log_{fanout} N)$ I/O (The "Double Lookup").
  - **Optimization**: Use *Covering Indexes* (Include Bio/Name in index) to bypass Step 2 (Clustered Seek).
| {near: bottom-center}