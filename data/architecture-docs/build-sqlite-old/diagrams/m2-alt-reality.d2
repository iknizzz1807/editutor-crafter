direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

sqlite_parser: "SQLite Parser (Recursive Descent + Pratt)" {
  style: {
    stroke: "#6e41ab"
    fill: "#f3f4f6"
    stroke-width: 2
  }

  rd_engine: "Recursive Descent Engine" {
    shape: class
    style.fill: "#3b82f6"
    label: "StmtParser\nsizeof=32 bytes"
    "parse_select()": "ASTNode*"
    "parse_insert()": "ASTNode*"
    "parse_create()": "ASTNode*"
  }

  pratt_engine: "Pratt Expression Parser" {
    shape: class
    style.fill: "#3b82f6"
    label: "ExprParser\nsizeof=24 bytes"
    "parse_expr(precedence: int)": "ASTNode*"
    "get_binding_power(token: TokenType)": "int"
  }

  ast_node: "ASTNode Structure (Memory Layout)" {
    shape: sql_table
    style.fill: "#3b82f6"
    "0x00: Type": "4B" { style: {stroke: "#9ca3af"; fill: "#3b82f6"} }
    "0x04: Line": "4B" { style: {stroke: "#9ca3af"; fill: "#3b82f6"} }
    "0x08: Col": "4B" { style: {stroke: "#9ca3af"; fill: "#3b82f6"} }
    "0x0C: Padding": "4B" { style: {stroke: "#9ca3af"; fill: "#9ca3af"} }
    "0x10: DataUnion": "48B" { style: {stroke: "#9ca3af"; fill: "#3b82f6"} }
    
    note: "sizeof=64B" {
      tooltip: "One Cache Line"
    }
  }

  rd_engine -> pratt_engine: "calls for WHERE/LIMIT" {style.stroke-dash: 5}
  pratt_engine -> ast_node: "owns/allocates" {
    target-arrowhead: {
      shape: triangle
      style.filled: true
    }
  }
}

postgres_comparison: "PostgreSQL Parser (Bison/LALR)" {
  style: {
    stroke: "#9ca3af"
    fill: "#f3f4f6"
    stroke-width: 2
  }

  bison_gen: "Bison-Generated Parser" {
    shape: class
    style.fill: "#9ca3af"
    label: "gram.y (LALR(1))\nComplex Table-Driven"
    "yyparse()": "int"
  }

  flex_scanner: "Flex Scanner" {
    shape: class
    style.fill: "#9ca3af"
    label: "scan.l\nDeterministic"
    "yylex()": "int"
  }

  parse_tree: "ParseTree (Full Syntax)" {
    style.fill: "#9ca3af"
    label: "Concrete Syntax Tree\nIncludes Semicolons/Parens"
  }

  flex_scanner -> bison_gen: "token stream"
  bison_gen -> parse_tree: "produces"
}

annotation_layer: {
  near: top-center
  comparison_note: |md
    ### Grammar Ambiguity & Parser Architecture
    - **SQLite**: Uses **Recursive Descent** for high-level grammar and **Pratt Parsing** for expressions.
      - *Pros*: Human-readable, easy to debug, $O(1)$ memory via Arena.
      - *Cons*: Manual handling of ambiguity.
    - **Postgres**: Uses **LALR(1)** (Bison).
      - *Pros*: Mathematically proven grammar, handles complex ambiguity.
      - *Cons*: Extremely difficult to modify, large generated state tables.
  |
}

sqlite_parser.ast_node."0x10: DataUnion" -> sqlite_parser.ast_node: "recursive child pointers" {
  style: {
    stroke: "#f59e0b"
    stroke-width: 2
  }
}