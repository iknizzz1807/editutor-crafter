vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

# LEGEND: Technical Standards
Legend: {
  grid-columns: 2
  near: top-left
  
  Header: "Header" {style: {fill: "#6A0DAD"; font-color: white}}
  "Meta/State"
  Data: "Data" {style: {fill: "#007FFF"; font-color: white}}
  "Buffer/Field"
  Changed: "Changed" {style: {fill: "#FF0000"; font-color: white; bold: true}}
  "Mutation"
}

# ALGORITHM: COST-BASED SELECTION (M8.5.2)
# Transitions between states represent memory mutation in the Planner context

step1: "Step 1: Context Initialization" {
  "Plan State": {
    shape: sql_table
    style: {fill: "#6A0DAD"; stroke-width: 2}
    "0x00: type": "UNDECIDED"
    "0x04: est_rows": "0"
    "0x0C: est_cost": "0.0"
    "0x14: target": "sys_stats (age)"
  }
  Annotation: |md
    ### TDD 8.5.2.1
    Planner identifies `WHERE age = 25` and retrieves `nRow` (1M) and `cardinality` (500) from `sys_stats`.
    *sizeof=64 bytes (one cache line)*
  |
}

step1 -> step2: "estimate_selectivity()"

step2: "Step 2: Selectivity Calculation" {
  "Plan State": {
    shape: sql_table
    style: {fill: "#6A0DAD"; stroke-width: 2}
    "0x00: type": "UNDECIDED"
    "0x04: est_rows": "500" {
      style: {fill: "#FF0000"; font-color: white; bold: true}
    }
    "0x0C: est_cost": "0.0"
    "0x14: target": "sys_stats (age)"
  }
  Annotation: |md
    ### TDD 8.4.2
    `estimate_selectivity` calculates `1 / 2000` (selectivity) across `1,000,000` rows.
    **MatchRows = 500**
  |
}

step2 -> step3: "calculate_cost_model()"

step3: "Step 3: Cost Modeling" {
  "Plan State": {
    shape: sql_table
    style: {fill: "#6A0DAD"; stroke-width: 2}
    "0x00: type": "UNDECIDED"
    "0x04: est_rows": "500"
    "0x0C: est_cost": "2005.0" {
      style: {fill: "#FF0000"; font-color: white; bold: true}
    }
    "0x14: target": "sys_stats (age)"
  }
  Annotation: |md
    ### TDD 8.5.2.2
    $Cost_{index} = (5 \times 1.0) + (500 \times 4.0)$
    Random I/O penalty (4.0) applied to each row lookup.
    **Total: 2005.0** vs Full Scan (10,000.0)
  |
}

step3 -> step4: "finalize_path()"

step4: "Step 4: Access Path Selection" {
  "Plan State": {
    shape: sql_table
    style: {fill: "#6A0DAD"; stroke-width: 2}
    "0x00: type": "PATH_INDEX" {
      style: {fill: "#FF0000"; font-color: white; bold: true}
    }
    "0x04: est_rows": "500"
    "0x0C: est_cost": "2005.0"
    "0x14: target": "sys_stats (age)"
  }
  Annotation: |md
    ### TDD 8.5.2.3
    $Cost_{index} < Cost_{scan}$
    Planner chooses Index Path. Compiler will emit `OP_IdxGE` for B-Tree traversal.
  |
}

# INTERNAL MEMORY REPRESENTATION ANNOTATION
Memory_Layout: |md
  **Implementation Detail:**
  The `PlanCandidate` struct alignment ensures `0x00` to `0x3F` fits within a single L1 cache line to prevent false sharing during multi-threaded plan evaluation.
| {
  near: bottom-right
  style: {stroke-dash: 3}
}

# Styling for data fields (Blue)
step1."Plan State"."0x14: target".style.fill: "#007FFF"
step2."Plan State"."0x14: target".style.fill: "#007FFF"
step3."Plan State"."0x14: target".style.fill: "#007FFF"
step4."Plan State"."0x14: target".style.fill: "#007FFF"

# Global font sizing for technical readability
***.style.font-size: 14