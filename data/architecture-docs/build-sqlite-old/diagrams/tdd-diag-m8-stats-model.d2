direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

# --- STYLING CLASSES ---
classes: {
  input_data: {
    style: {
      fill: "#3b82f6"
      font-color: white
      stroke-width: 2
    }
  }
  constant_val: {
    style: {
      fill: "#9ca3af"
      stroke-dash: 3
    }
  }
  process_node: {
    style: {
      fill: "#f3f4f6"
      stroke: "#6e41ab"
      stroke-width: 2
    }
  }
  result_node: {
    style: {
      fill: "#f59e0b"
      stroke: "#b45309"
      font-color: white
      bold: true
    }
  }
}

# --- DIAGRAM COMPONENTS ---

Statistics: "STATISTICS CATALOG (sys_stats)" {
  style.fill: "#6e41ab"
  style.font-color: white

  PageCount: "Page Count (N_pg)" {
    class: input_data
    shape: parallelogram
  }
  RowCount: "Row Count (N_row)" {
    class: input_data
    shape: parallelogram
  }
  Selectivity: "Selectivity (S)" {
    class: input_data
    shape: parallelogram
  }
}

Constants: "COST WEIGHTS" {
  seq_cost: "SEQ_PAGE_COST: 1.0" { class: constant_val }
  rand_cost: "RAND_PAGE_COST: 4.0" { class: constant_val }
  cpu_cost: "CPU_ROW_COST: 0.01" { class: constant_val }
}

Optimizer: "QUERY PLANNER EVALUATOR" {
  
  RowEstimation: {
    class: process_node
    label: |md
      **SELECTIVITY ENGINE**
      MatchRows = N_row * S
    |
  }

  TableScanLogic: {
    class: process_node
    label: |md
      **TABLE SCAN MODEL**
      Cost = (N_pg * 1.0) + (N_row * 0.01)
    |
  }

  IndexScanLogic: {
    class: process_node
    label: |md
      **INDEX SCAN MODEL**
      Cost = (Idx_pg * 1.0) + (MatchRows * 4.0) + (MatchRows * 0.01)
    |
  }
}

# --- DATA FLOW CONNECTIONS ---

Statistics.PageCount -> Optimizer.TableScanLogic: "N_pg"
Statistics.RowCount -> Optimizer.TableScanLogic: "N_row"
Statistics.RowCount -> Optimizer.RowEstimation: "N_row"
Statistics.Selectivity -> Optimizer.RowEstimation: "Selectivity S"

Optimizer.RowEstimation -> Optimizer.IndexScanLogic: "MatchRows"

Constants.seq_cost -> Optimizer.TableScanLogic
Constants.cpu_cost -> Optimizer.TableScanLogic

Constants.seq_cost -> Optimizer.IndexScanLogic
Constants.rand_cost -> Optimizer.IndexScanLogic
Constants.cpu_cost -> Optimizer.IndexScanLogic

DecisionEngine: "MIN() COMPARATOR" {
  shape: diamond
  style.fill: "#6e41ab"
  style.font-color: white
}

Optimizer.TableScanLogic -> DecisionEngine: "Cost_scan"
Optimizer.IndexScanLogic -> DecisionEngine: "Cost_idx"

FinalPlan: "ESTIMATED I/O UNITS (Final Cost)" {
  class: result_node
  shape: cylinder
}

DecisionEngine -> FinalPlan: "Selected Access Path"

# --- ANNOTATIONS ---
annotate: |md
  ### COST CALCULATION ENGINE
  - **Sequential I/O**: Preferred for low-selectivity (large result sets).
  - **Random I/O**: Penalized by factor of 4.0 to account for buffer misses.
  - **Double Lookup**: Costs include Index traversal + Table Seek for every matched row.
| {
  near: bottom-right
}