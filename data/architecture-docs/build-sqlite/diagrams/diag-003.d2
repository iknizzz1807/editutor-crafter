vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

REPL_SYSTEM: "Milestone 1: The REPL Architecture & Input Lifecycle" {
  link: "#satellite-map"
  style: {
    stroke-width: 4
    fill: "#f8f9fa"
  }

  USER_SPACE: "User / External Environment" {
    USER: "Human Operator" {
      shape: person
    }
    
    TERMINAL_EMULATOR: "TTY / Console" {
      style.fill: "#2e2e2e"
      style.font-color: "#ffffff"
      SHELL_PROMPT: "db > " {
        style.font: mono
      }
    }
  }

  GATEWAY_INTERNALS: "Database Interface Gateway" {
    style.fill: "#ffffff"
    
    INPUT_PIPELINE: "1. Input Acquisition Pipeline" {
      STDIN_STREAM: "stdin" {
        shape: queue
        style.stroke: "#333333"
      }
      
      GETLINE_LOGIC: "getline() Routine" {
        link: "#milestone-1"
        tooltip: |'md
          ## Buffer Growth Strategy
          1. Check current capacity vs bytes read.
          2. If `length + 1 >= capacity`, call `realloc`.
          3. Read until `\n`.
          4. Null-terminate string.
        '|
      }

      INPUT_BUFFER_MEMORY: "struct InputBuffer" {
        shape: sql_table
        link: "#milestone-1"
        buffer_ptr: "char* buffer" {constraint: "Heap Address"}
        capacity: "size_t buffer_length" {constraint: "Allocated Size"}
        used: "ssize_t input_length" {constraint: "Actual String Size"}
      }
    }

    ROUTING_LOGIC: "2. Command Dispatcher" {
      shape: diamond
      link: "#milestone-1"
      
      META_CHECK: "Starts with '.'?" {
        label: "Prefix Evaluation"
      }

      META_PATH: "Meta-Command Handler" {
        label: "Bypass Parser"
        link: "#milestone-1"
        tooltip: "Executes .exit, .schema, .timer directly"
      }

      SQL_PATH: "SQL Engine Entry" {
        label: "Prepare Statement"
        link: "#milestone-2"
        style.double-border: true
      }
    }

    RESULT_FORMATTER: "3. Output Serialization" {
      TABULAR: "ASCII Table Formatter" {
        shape: step
      }
      ERROR_WRITER: "stderr Formatter" {
        shape: step
        style.stroke: red
      }
    }
  }

  # Flow Connections
  USER_SPACE.USER -> USER_SPACE.TERMINAL_EMULATOR: "SQL Query"
  USER_SPACE.TERMINAL_EMULATOR -> GATEWAY_INTERNALS.INPUT_PIPELINE.STDIN_STREAM: "Character Stream"
  
  GATEWAY_INTERNALS.INPUT_PIPELINE.STDIN_STREAM -> GATEWAY_INTERNALS.INPUT_PIPELINE.GETLINE_LOGIC
  GATEWAY_INTERNALS.INPUT_PIPELINE.GETLINE_LOGIC -> GATEWAY_INTERNALS.INPUT_PIPELINE.INPUT_BUFFER_MEMORY: "Update Metadata"
  
  GATEWAY_INTERNALS.INPUT_PIPELINE.INPUT_BUFFER_MEMORY -> GATEWAY_INTERNALS.ROUTING_LOGIC: "Raw String Pointer"
  
  GATEWAY_INTERNALS.ROUTING_LOGIC.META_CHECK -> GATEWAY_INTERNALS.ROUTING_LOGIC.META_PATH: "Yes ('.')"
  GATEWAY_INTERNALS.ROUTING_LOGIC.META_CHECK -> GATEWAY_INTERNALS.ROUTING_LOGIC.SQL_PATH: "No"
  
  GATEWAY_INTERNALS.ROUTING_LOGIC.META_PATH -> GATEWAY_INTERNALS.RESULT_FORMATTER.TABULAR
  GATEWAY_INTERNALS.ROUTING_LOGIC.SQL_PATH -> GATEWAY_INTERNALS.RESULT_FORMATTER.TABULAR: "Rowset"
  
  GATEWAY_INTERNALS.RESULT_FORMATTER.TABULAR -> USER_SPACE.TERMINAL_EMULATOR: "Formatted Output"
}

STATE_TRANSITION_HEAP: "State-Transition: Dynamic Heap Expansion" {
  link: "#milestone-1"
  near: bottom-center

  BEFORE: "State A: Original Allocation" {
    style.fill: "#fff2cc"
    MEM_MAP: {
      grid-columns: 8
      grid-gap: 2
      B0: "S"; B1: "E"; B2: "L"; B3: "E"; B4: "C"; B5: "T"; B6: " "; B7: "\0"
      
      B*.style.font: mono
      B*.style.fill: "#d5e8d4"
    }
    METADATA: |'md
      - **Ptr**: 0x7ffee
      - **Capacity**: 1024 bytes
      - **Length**: 7 bytes
    '|
  }

  AFTER: "State B: Post-realloc() Expansion" {
    style.fill: "#dae8fe"
    MEM_MAP: {
      grid-columns: 8
      grid-gap: 2
      B0: "I"; B1: "N"; B2: "S"; B3: "E"; B4: "R"; B5: "T"; B6: "..."; B7: "\0"
      
      B*.style.font: mono
      B*.style.fill: "#f8cecc"
    }
    METADATA: |'md
      - **Ptr**: 0x8A002 (Moved)
      - **Capacity**: 2048 bytes
      - **Length**: 1240 bytes
    '|
  }

  BEFORE -> AFTER: "realloc(buffer, new_size)" {
    style.animated: true
    style.stroke: red
    style.bold: true
  }
}

MEMORY_LAYOUT: "Microscope View: Cache-Friendly InputBuffer" {
  link: "#milestone-1"
  near: top-right
  
  CACHE_LINE: "64-Byte CPU Cache Line" {
    style.fill: "#f5f5f5"
    style.stroke-dash: 5
    
    STRUCT_DATA: "Contiguous Memory" {
      grid-columns: 3
      grid-gap: 0
      P: "char* (8b)"
      C: "size_t (8b)"
      L: "ssize_t (8b)"
      
      P.style.fill: "#ffe6cc"
      C.style.fill: "#d5e8d4"
      L.style.fill: "#dae8fe"
    }
  }
  
  DESC: |'md
    ### Spatial Locality
    By keeping metadata (Length/Capacity) adjacent to the pointer, 
    the CPU pre-fetches the entire structure into L1 cache in 
    a single cycle, avoiding costly DRAM access.
  '|
}

SUMMARY_BLOCK: |'md
  # Milestone 1: Technical Contract
  - **Memory Safety**: Use `getline()` to prevent buffer overflows common in `scanf`.
  - **Abstraction**: `struct InputBuffer` encapsulates state for the entire lifecycle.
  - **Routing**: Meta-commands (`.`) bypass the VDBE to allow for administrative control even when the SQL engine is locked.
'| {
  shape: text
  link: "#milestone-1"
  near: bottom-left
}