vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  category: {
    style: {
      fill: "#1e1b4b"
      font-color: "#e0e7ff"
      stroke: "#4338ca"
      stroke-width: 2
      bold: true
    }
  }
  token_leaf: {
    style: {
      fill: "#e0e7ff"
      stroke: "#4338ca"
      border-radius: 4
      font-size: 12
    }
  }
  memory_label: {
    style: {
      font: mono
      font-size: 10
      fill: "transparent"
      stroke-width: 0
    }
  }
}

# --- SATELLITE VIEW: THE GRAMMAR MAP ---
token_taxonomy: "TOKEN TYPES TAXONOMY (THE ARCHITECT'S DICTIONARY)" {
  link: "#milestone-2"
  style.stroke-width: 4

  keywords: "Keywords" {
    class: category
    link: "#milestone-2"
    
    dml: "DML Commands" {
      sel: "SELECT" { class: token_leaf; link: "#milestone-2" }
      ins: "INSERT" { class: token_leaf; link: "#milestone-2" }
      upd: "UPDATE" { class: token_leaf; link: "#milestone-2" }
      del: "DELETE" { class: token_leaf; link: "#milestone-2" }
    }
    
    clauses: "Logical Clauses" {
      frm: "FROM" { class: token_leaf; link: "#milestone-2" }
      whr: "WHERE" { class: token_leaf; link: "#milestone-2" }
      join: "JOIN" { class: token_leaf; link: "#milestone-2" }
    }
  }

  operators: "Operators & Symbols" {
    class: category
    link: "#milestone-2"

    math: "Arithmetic" {
      plus: "+" { class: token_leaf }
      minus: "-" { class: token_leaf }
      star: "*" { class: token_leaf }
    }

    logic: "Comparison" {
      eq: "=" { class: token_leaf }
      neq: "!=" { class: token_leaf }
      gt: ">" { class: token_leaf }
      gte: ">=" { class: token_leaf }
    }

    punct: "Punctuation" {
      comma: "," { class: token_leaf }
      lpar: "(" { class: token_leaf }
      rpar: ")" { class: token_leaf }
      semi: ";" { class: token_leaf }
    }
  }

  literals: "Literals" {
    class: category
    link: "#milestone-2"
    
    types: {
      num: "NUMERIC" { class: token_leaf; tooltip: "Integers & Floats" }
      str: "STRING" { class: token_leaf; tooltip: "Single-quoted text" }
      blob: "BLOB" { class: token_leaf; tooltip: "Hexadecimal data" }
      nul: "NULL" { class: token_leaf }
    }
  }

  identifiers: "Identifiers" {
    class: category
    link: "#milestone-2"
    tbl: "Table Names" { class: token_leaf }
    col: "Column Names" { class: token_leaf }
    alias: "AS Aliases" { class: token_leaf }
  }
}

# --- MICROSCOPE VIEW: ZERO-COPY MEMORY LAYOUT ---
memory_layout: "MICROSCOPE: ZERO-COPY TOKEN REPRESENTATION" {
  link: "#milestone-2"

  token_struct: {
    shape: sql_table
    link: "#milestone-2"
    type: "enum TokenType" { constraint: "4 bytes" }
    start: "const char *start" { constraint: "8 bytes" }
    length: "int length" { constraint: "4 bytes" }
    
    style.fill: "#f8fafc"
  }

  raw_heap: "Raw Input Buffer (Contiguous Heap)" {
    link: "#milestone-2"
    grid-columns: 16
    grid-gap: 0
    
    b0: "S"; b1: "E"; b2: "L"; b3: "E"; b4: "C"; b5: "T"
    b6: " "; b7: "i"; b8: "d"; b9: " "; b10: "F"; b11: "R"; b12: "O"; b13: "M"
    b14: " "; b15: "u"
    
    # Offsets
    **.style.font: mono
    **.style.border-radius: 0
  }

  # Mapping pointers
  token_struct.start -> raw_heap.b0: "Points to offset in original buffer" {
    style: {
      stroke: "#ef4444"
      stroke-width: 2
      animated: true
    }
  }

  data_info: |'md
    ### Architectural Insight
    SQLite avoids `malloc()` during tokenization. Each `Token` is a 
    **window** into the original user input string.
    
    - **No copying**: Massive performance gain.
    - **Ephemeral**: Tokens are only valid while the buffer exists.
  '| {
    shape: package
    style.fill: "#fff7ed"
  }
}

# --- OPERATIONAL VIEW: STATE TRANSITIONS ---
tokenizer_fsa: "STATE MACHINE: CHARACTER SCANNING" {
  link: "#milestone-2"
  direction: right

  idle: "IDLE" { shape: circle }
  peek: "PEEK NEXT CHAR" { shape: diamond }
  
  idle -> peek: "Advance Cursor"
  
  peek -> alpha: "Is [a-zA-Z]?"
  peek -> digit: "Is [0-9]?"
  peek -> quote: "Is [']?"
  peek -> symbol: "Other?"

  alpha: "SCAN IDENTIFIER" { shape: step }
  digit: "SCAN NUMBER" { shape: step }
  quote: "SCAN STRING LITERAL" { shape: step }
  symbol: "CLASSIFY SYMBOL" { shape: step }

  alpha -> alpha: "Consume until non-alpha"
  alpha -> token_taxonomy.keywords: "Check Keyword Map"
  alpha -> token_taxonomy.identifiers: "Default to ID"
  
  digit -> token_taxonomy.literals: "Emit Numeric"
  quote -> token_taxonomy.literals: "Emit String"
  symbol -> token_taxonomy.operators: "Emit Symbol"
}

# Visual Connections between abstractions
token_taxonomy.keywords -> tokenizer_fsa.alpha: "Matching Logic" {
  style.stroke-dash: 3
}

tokenizer_fsa.symbol -> memory_layout.token_struct: "Creates" {
  style.stroke-dash: 3
}

# Footer Legend
footer: |'md
  ### Legend
  - **Category**: Structural grouping in the C Parser.
  - **Zero-Copy**: Pointer-based extraction from input.
  - **FSA**: Finite State Automata logic for character processing.
'| {
  near: bottom-center
  shape: package
}