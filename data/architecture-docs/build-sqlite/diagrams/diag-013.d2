vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  memory_page: {
    style: {
      stroke-width: 3
      border-radius: 8
      fill: "#ffffff"
      shadow: true
    }
  }
  header_seg: {
    style: {
      fill: "#bbdefb"
      stroke: "#1565c0"
      bold: true
      font-size: 14
    }
  }
  pointer_seg: {
    style: {
      fill: "#fff3e0"
      stroke: "#e65100"
      font: mono
      font-size: 12
    }
  }
  cell_seg: {
    style: {
      fill: "#e8f5e9"
      stroke: "#2e7d32"
      font-size: 13
    }
  }
  varint: {
    style: {
      fill: "#f3e5f5"
      stroke: "#7b1fa2"
      font: mono
    }
  }
}

btree_atlas: "B-Tree Node Structure & Warehouse View" {
  link: "#milestone-4"

  internal_node: "Internal Node (Page Type 0x05)" {
    class: memory_page
    link: "#milestone-4"
    
    header: "B-Tree Header (12 Bytes)" {
      shape: sql_table
      class: header_seg
      "Offset 00": "Page Type (0x05)"
      "Offset 01": "Freeblock Offset"
      "Offset 03": "Cell Count (N)"
      "Offset 05": "Cell Content Start"
      "Offset 08": "Right Child Ptr (Page ID)"
    }

    ptr_array: "Cell Pointer Array (Top-Down)" {
      p0: "Offset: 0x0FE0" {class: pointer_seg}
      p1: "Offset: 0x0FC0" {class: pointer_seg}
      p2: "Offset: 0x0FA0" {class: pointer_seg}
    }

    free_space: "Unallocated Page Space (Gap)" {
      style: {
        stroke-dash: 5
        fill: transparent
        opacity: 0.3
      }
      height: 100
    }

    cells: "Cell Content Area (Bottom-Up)" {
      c2: "Cell 2: [Key 500 | Child ID 210]" {class: cell_seg}
      c1: "Cell 1: [Key 300 | Child ID 205]" {class: cell_seg}
      c0: "Cell 0: [Key 100 | Child ID 102]" {class: cell_seg}
    }

    # Connectivity shows the indirection mapping
    ptr_array.p0 -> cells.c0: "Indirection 0"
    ptr_array.p1 -> cells.c1: "Indirection 1"
    ptr_array.p2 -> cells.c2: "Indirection 2"
  }

  leaf_node: "Leaf Node (Page Type 0x0D)" {
    class: memory_page
    link: "#milestone-4"

    header: "Leaf Header (8 Bytes)" {
      shape: sql_table
      class: header_seg
      "Offset 00": "Page Type (0x0D)"
      "Offset 03": "Cell Count (2)"
      "Offset 05": "Content Start"
    }

    ptr_array: "Cell Pointer Array" {
      p0: "Offset: 0x0F00" {class: pointer_seg}
      p1: "Offset: 0x0E00" {class: pointer_seg}
    }

    records: "Table Records (Record Format)" {
      r1: "Record 1: Alice (ID: 5)" {class: cell_seg; link: "#milestone-7"}
      r0: "Record 0: Bob (ID: 2)" {class: cell_seg; link: "#milestone-7"}
    }

    ptr_array.p0 -> records.r0
    ptr_array.p1 -> records.r1
  }

  internal_node.header."Offset 08" -> leaf_node: "Page Traversal" {
    style: {
      stroke-width: 4
      stroke: "#1565c0"
      animated: true
    }
  }
}

serialization_microscope: "Milestone 7: Row Serialization Format" {
  link: "#milestone-7"
  
  byte_stream: "Compact Record Layout" {
    shape: sql_table
    style.fill: "#fffde7"
    "Component": "Encoding / Strategy"
    "Payload Len": "Varint (Value: 0x12)" {class: varint}
    "RowID (Key)": "Varint (Value: 0x05)" {class: varint}
    "Header Len": "Varint (Value: 0x03)" {class: varint}
    "Type Col 1": "0x01 (8-bit signed int)"
    "Type Col 2": "0x1B (String, len 5)"
    "Data 1": "0x0A (10 points)"
    "Data 2": "['A','l','i','c','e']"
  }

  varint_analysis: "Varint Bit-Structure (Value 133)" {
    shape: rectangle
    style.fill: "#f3e5f5"
    byte1: "1 | 0000001" {
      label: "C-Bit: 1 (More) | Data: 1"
      style.font: mono
    }
    byte2: "0 | 0000101" {
      label: "C-Bit: 0 (Stop) | Data: 5"
      style.font: mono
    }
    byte1 -> byte2: "Concatenation"
  }
}

system_legend: |'md
  ### B-Tree Logistics
  - **Memory Indirection**: The `Cell Pointer Array` allows O(1) row access by offset. Sorting is done by reordering the 2-byte pointers, not the data.
  - **Varints**: Variable-length integers are the core of SQLite's density. Integers are packed into 7-bit chunks with the high bit acting as a "Continuation" flag.
  - **Header vs Payload**: The Record Header defines types (Serial Type IDs); the Payload follows immediately, allowing zero-copy access to specific columns.
'| {
  near: bottom-center
}

# Global Overrides for Table Text Density
btree_atlas.internal_node.header.style.font-size: 10
btree_atlas.leaf_node.header.style.font-size: 10
serialization_microscope.byte_stream.style.font-size: 10