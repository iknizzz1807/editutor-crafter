vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

storage_integration: "STORAGE LAYER INTEGRATION: VM TO DISK HANDSHAKE" {
  link: "#satellite-map"
  
  # EXECUTION FLOW: TOP LAYER (The Verb)
  execution_sequence: {
    shape: sequence_diagram
    link: "#milestone-3"
    style: {
      stroke: "#01579B"
      fill: "#E1F5FE"
      stroke-width: 4
    }

    vdbe: "VDBE VM (Logic)" {
      link: "#milestone-3"
      style.fill: "#B3E5FC"
    }
    btree_mgr: "B-Tree Manager" {
      link: "#milestone-4"
      style.fill: "#FFF9C4"
    }
    pager: "Pager (Cache)" {
      link: "#milestone-4"
      style.fill: "#C8E6C9"
    }
    vfs: "VFS (OS I/O)" {
      link: "#milestone-10"
      style.fill: "#F5F5F5"
    }

    vdbe -> btree_mgr: "1. cursor_open(root_page)" { link: "#milestone-3" }
    btree_mgr -> pager: "2. get_page(page_id)" { link: "#milestone-4" }
    pager -> vfs: "3. pread(4096, offset)" { link: "#milestone-10" }
    vfs -> pager: "4. return raw_bytes" 
    pager -> btree_mgr: "5. page_handle"
    
    vdbe -> btree_mgr: "6. cursor_next()"
    btree_mgr -> btree_mgr: "Binary scan cell pointers"
    btree_mgr -> vdbe: "7. record_payload"
    
    vdbe -> vdbe: "Unpack to Registers" { link: "#milestone-7" }
  }

  # MEMORY LAYOUTS: BOTTOM LAYER (The Noun)
  memory_visuals: {
    grid-columns: 1
    grid-gap: 40
    style.stroke-width: 0

    # 4KB PAGE MICROSCOPE
    page_microscope: "B-TREE PAGE MICROSCOPE (4KB)" {
      link: "#milestone-4"
      style.fill: "#FAFAFA"
      
      header_block: {
        grid-columns: 2
        style.stroke-width: 0
        
        fixed_header: "PAGE HEADER (12B)" {
          link: "#milestone-4"
          style.fill: "#FFCCBC"
          grid-columns: 4
          f: "Flags\n(1b)"
          fs: "Free\nStart (2b)"
          cc: "Cell\nCount (2b)"
          co: "Content\nOffset (2b)"
        }
        
        pointer_array: "POINTER ARRAY (Indirection)" {
          style.fill: "#D1C4E9"
          grid-columns: 4
          p0: "P[0]"
          p1: "P[1]"
          p2: "P[2]"
          p3: "P[3]"
        }
      }

      free_space: "--- UNALLOCATED (Fragmentation) ---" {
        style: {
          stroke-dash: 5
          fill: white
          opacity: 0.5
        }
      }

      cell_storage: "CELL CONTENT (Stacked Bottom-Up)" {
        style.fill: "#B2DFDB"
        cell_3: "Cell 3"
        cell_2: "Cell 2"
        cell_1: "Cell 1"
        cell_0: "Cell 0"
      }

      # Visualizing the logical mapping inside memory
      header_block.pointer_array.p0 -> cell_storage.cell_0: "ptr"
      header_block.pointer_array.p1 -> cell_storage.cell_1: "ptr"
    }

    # SERIALIZATION TRANSITION
    serialization: "RECORD SERIALIZATION: MEMORY TO BINARY" {
      link: "#milestone-7"
      direction: right
      
      registers: {
        shape: sql_table
        label: "VM REGISTERS"
        reg0: "ID: 500" { constraint: "INT64" }
        reg1: "Name: 'Alice'" { constraint: "TEXT" }
        reg2: "Points: 10.5" { constraint: "REAL" }
        style.fill: "#E3F2FD"
      }

      transformer: "Record Packing Logic" {
        shape: rectangle
        style.fill: "#BBDEFB"
        style.double-border: true
      }

      binary: {
        shape: sql_table
        label: "ON-DISK BINARY"
        header: "Header: [0x04 0x01 0x18 0x07]" { constraint: "Varint-Types" }
        payload: "Payload: [F4 01 41 6C 69 63 65 ...]" { constraint: "Raw-Bytes" }
        style.fill: "#E8F5E9"
      }

      registers -> transformer: "read"
      transformer -> binary: "pack"
    }
  }
}

# INTER-COMPONANT KNOWLEDGE LINKS
storage_integration.execution_sequence.vdbe -> storage_integration.memory_visuals.serialization.registers: "Register Access" {
  style.stroke-dash: 3
}

storage_integration.execution_sequence.btree_mgr -> storage_integration.memory_visuals.page_microscope: "B-Tree Traversal" {
  style.stroke-dash: 3
}

# ARCHITECTURAL ANNOTATION
storage_annotation: |'md
### Detailed System Handshake
1. **Instruction Fetch**: VDBE pulls bytecode (M3).
2. **Key Search**: B-Tree translates logical ID 500 to a Page ID (M4).
3. **Buffer Management**: Pager retrieves Page 5 from Disk if not in Cache.
4. **Indirection**: The `Cell Pointer` array allows for fast deletion/insertion without moving all data in the 4KB block.
5. **Deserialization**: The `Record Packing Logic` converts binary types into CPU-friendly types for registers (M7).
'| {
  near: storage_integration
  style: {
    fill: "#FFFDE7"
    stroke: "#FBC02D"
    stroke-width: 2
  }
}

# GLOBS FOR CONSISTENT THEME
***.style.font: mono
***.style.stroke-width: 2
(*** -> ***)[*]: {
  style.stroke: "#37474F"
}