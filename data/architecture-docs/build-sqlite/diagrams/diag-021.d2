vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

# --- CLASSES ---
classes: {
  base_rel: {
    style: {
      fill: "#ecf0f1"
      stroke: "#2c3e50"
      stroke-width: 2
    }
  }
  optimal_path: {
    style: {
      stroke: "#27ae60"
      stroke-width: 4
      animated: true
    }
  }
  pruned_path: {
    style: {
      stroke: "#c0392b"
      stroke-width: 1
      opacity: 0.3
      stroke-dash: 3
    }
  }
  dp_node: {
    style: {
      fill: "#fdfefe"
      border-radius: 8
      shadow: true
    }
  }
}

# --- HEADER ---
Title: "BUILD-SQLITE: MILESTONE 5 - JOIN ORDER OPTIMIZATION (DP LATTICE)" {
  shape: rectangle
  style: {
    fill: "#2c3e50"
    font-color: white
    bold: true
    font-size: 20
  }
  link: "#satellite-map"
}

# --- SEARCH SPACE LATTICE ---
Lattice: {
  label: "Dynamic Programming Search Space: Power Set of {A, B, C, D}"
  link: "#milestone-5"

  Level_1: "N=1 (Base Scans)" {
    A: "Scan(A)" {class: [base_rel; dp_node]; link: "#milestone-4"}
    B: "Scan(B)" {class: [base_rel; dp_node]; link: "#milestone-4"}
    C: "Scan(C)" {class: [base_rel; dp_node]; link: "#milestone-4"}
    D: "Scan(D)" {class: [base_rel; dp_node]; link: "#milestone-4"}
  }

  Level_2: "N=2 (Sub-Plans)" {
    AB: "{A, B}" {class: [dp_node]; link: "#milestone-5"}
    BC: "{B, C}" {class: [dp_node]; link: "#milestone-5"}
    CD: "{C, D}" {class: [dp_node]; link: "#milestone-5"}
  }

  Level_3: "N=3 (Intermediate)" {
    ABC: "{A, B, C}" {class: [dp_node]; link: "#milestone-5"}
    BCD: "{B, C, D}" {class: [dp_node]; link: "#milestone-5"}
  }

  Level_4: "N=4 (Root Plan)" {
    ABCD: "OPTIMAL PLAN: ((B⨝C)⨝A)⨝D" {
      shape: rectangle
      style: {
        fill: "#f1c40f"
        bold: true
        stroke-width: 4
      }
      link: "#milestone-5"
    }
  }
}

# --- CONNECTIONS (Lattice Navigation) ---
Lattice.Level_1.A -> Lattice.Level_2.AB: {class: optimal_path}
Lattice.Level_1.B -> Lattice.Level_2.AB

Lattice.Level_1.B -> Lattice.Level_2.BC: "Cost: 50" {class: optimal_path}
Lattice.Level_1.C -> Lattice.Level_2.BC

# DP Pruning Example for {A,B,C}
Lattice.Level_2.AB -> Lattice.Level_3.ABC: "Plan: (AB)⨝C\nCost: 1200" {class: pruned_path}
Lattice.Level_2.BC -> Lattice.Level_3.ABC: "Plan: (BC)⨝A\nCost: 800" {class: optimal_path}

Lattice.Level_3.ABC -> Lattice.Level_4.ABCD: {class: optimal_path}
Lattice.Level_3.BCD -> Lattice.Level_4.ABCD: {class: pruned_path}

# --- STATE TRANSITION: PRUNING LOGIC ---
PruningLogic: {
  label: "State Transition: Cost-Based Pruning"
  link: "#milestone-5"

  Before: "Candidates for {A,B,C}" {
    C1: "(A⨝B)⨝C" {
      tooltip: "Cost: 1200"
      style.stroke: red
    }
    C2: "(B⨝C)⨝A" {
      tooltip: "Cost: 800"
      style.stroke: green
    }
  }

  Decision: "Cost(C2) < Cost(C1)?" {
    shape: diamond
    link: "#milestone-5"
  }

  After: "Memoization Update" {
    Winner: "(B⨝C)⨝A" {
      style.fill: "#2ecc71"
      style.font-color: white
    }
    Memo_Update: "Store in DP[0111]" {
      shape: step
    }
  }

  Before -> Decision -> After
}

# --- MEMORY LAYOUT: DP MEMOIZATION TABLE ---
MemoTable: {
  shape: sql_table
  label: "Memory Layout: DP Memoization Table (Bitmap Indexed)"
  link: "#milestone-3"

  "Bitmap ID": "Best Physical Plan" {constraint: "Estimated Cost"}
  "0001 (A)": "TableScan(A)" {constraint: "100"}
  "0011 (AB)": "NestedLoop(A,B)" {constraint: "500"}
  "0110 (BC)": "HashJoin(B,C)" {constraint: "300"}
  "0111 (ABC)": "HashJoin((BC),A)" {constraint: "800"}
  "1111 (ABCD)": "MergeJoin((ABC),D)" {constraint: "1500"}
}

# --- MATHEMATICAL FOUNDATION ---
CostEstimation: {
  label: "Microscope: Cardinality & Costing"
  link: "#milestone-5"

  Formula: |latex
    C_{total} = \sum_{sub} (Cost(R) + Cost(S) + |R \bowtie S|)
  |

  Stats: {
    shape: sql_table
    "Metric": "Description"
    "|R|": "Cardinality (Rows)"
    "T(R)": "Tuples per Page"
    "V(R, a)": "Distinct values in 'a'"
  }
}

# --- GLOBAL SYSTEM CONNECTIONS ---
Parser: "Architect (M2)" {
  shape: step
  style.fill: "#3498db"
  style.font-color: white
  link: "#milestone-2"
}

VDBE: "Engine (M3)" {
  shape: step
  style.fill: "#9b59b6"
  style.font-color: white
  link: "#milestone-3"
}

Parser -> Lattice: "Syntax Tree (AST)"
Lattice -> VDBE: "Optimal Bytecode"
MemoTable -> VDBE: "Instruction Set"

# Explanation Block
Explanation: |'md
  ### The DP Optimizer Strategy
  1. **Base Case**: Estimate costs for single table scans (Milestone 4).
  2. **Inductive Step**: For each size $k \in [2, N]$, find optimal way to join subsets of size $k-1$ and size 1.
  3. **Pruning**: For every subset (e.g., $\{A,B,C\}$), we only store the **minimum cost** plan in the Memoization Table.
  4. **Complexity**: Reduces $N!$ permutations to $O(3^N)$ subproblems.
'|

Explanation.style.stroke-dash: 5
Explanation.near: Lattice