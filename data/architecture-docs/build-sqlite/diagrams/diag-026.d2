vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

# --- MASTER CLASSES ---
classes: {
  storage_media: {
    shape: cylinder
    style: {
      fill: "#eceff1"
      stroke: "#455a64"
      stroke-width: 2
    }
  }
  memory_mapped: {
    style: {
      stroke-dash: 3
      border-radius: 6
      fill: "#f1f8e9"
    }
  }
  kernel_operation: {
    shape: package
    style: {
      fill: "#fff9c4"
      stroke: "#fbc02d"
      stroke-dash: 0
    }
  }
}

# --- THE CHECKPOINT SYNTHESIS ---

checkpoint_arch: "CHECKPOINT DYNAMICS: WAL TO DB CONSOLIDATION" {
  link: "#milestone-6"

  # SECTION 1: THE DATA RECONCILIATION (LWW)
  lww_reconciliation: "LOG RECONCILIATION: LAST-WRITE-WINS" {
    direction: right
    link: "#milestone-6"

    wal_source: "Write-Ahead Log (.wal)" {
      class: storage_media
      link: "#milestone-6"
      
      f1: "Frame 1: Page 5 (v1)" {
        style.opacity: 0.4
        tooltip: "Obsolete Version"
      }
      f2: "Frame 2: Page 12 (v1)" {
        style.fill: "#c8e6c9"
      }
      f3: "Frame 3: Page 5 (v2)" {
        style.fill: "#4fc3f7"
        style.stroke: "#0277bd"
        style.stroke-width: 3
        tooltip: "Most Recent Version"
      }

      f1 -> f2 -> f3
    }

    shm_index: "WAL-Index (.shm)" {
      shape: sql_table
      class: memory_mapped
      link: "#milestone-6"
      page_no: "Page Number" {constraint: primary_key}
      latest_frame: "Max Frame Index"
      "5": "3"
      "12": "2"
    }

    pager_logic: "Checkpointer" {
      shape: rectangle
      style.fill: "#e1f5fe"
      link: "#milestone-4"
    }

    main_db: "Main Database (.db)" {
      class: storage_media
      link: "#milestone-4"
      p5: "Page 5 (Updated)" {
        style.fill: "#4fc3f7"
      }
      p12: "Page 12 (Updated)" {
        style.fill: "#c8e6c9"
      }
    }

    wal_source.f3 -> pager_logic: "Read Latest"
    shm_index -> pager_logic: "Lookup Mapping"
    pager_logic -> main_db.p5: "pwrite(offset=5*4096)"
    pager_logic -> main_db.p12: "pwrite(offset=12*4096)"
  }

  # SECTION 2: THE DURABILITY TRANSITION
  durability_barrier: "THE ATOMIC TRANSITION: FSYNC BARRIER" {
    link: "#milestone-6"
    direction: right

    volatile_ram: "Kernel Page Cache (Dirty)" {
      class: memory_mapped
      link: "#milestone-1"
      d5: "Dirty Page 5" { style.fill: "#ffe0b2" }
      d12: "Dirty Page 12" { style.fill: "#ffe0b2" }
    }

    fsync_barrier: "fsync() OS Call" {
      class: kernel_operation
      link: "#milestone-10"
      style.bold: true
    }

    durable_disk: "Physical Storage Platter" {
      class: storage_media
      link: "#milestone-4"
      s5: "Page 5" { style.fill: "#81c784" }
      s12: "Page 12" { style.fill: "#81c784" }
    }

    volatile_ram -> fsync_barrier: "System Request"
    fsync_barrier -> durable_disk: "Hardware Cache Flush" {
      style.stroke-width: 5
      style.animated: true
    }
  }

  # SECTION 3: VFS INTERACTION FLOW
  system_sequence: "VFS CALL HANDSHAKE" {
    shape: sequence_diagram
    link: "#milestone-10"

    vdbe: "VDBE Engine" { link: "#milestone-3" }
    pager: "Pager Module" { link: "#milestone-4" }
    vfs: "VFS Layer" { link: "#milestone-10" }
    disk: "Disk Controller"

    vdbe -> pager: "CheckpointRequested()"
    pager -> vfs: "xRead(.wal, frame_3)"
    vfs -> pager: "Data Buffer"
    pager -> vfs: "xWrite(.db, page_5)"
    vfs -> pager: "Buffer Ack"
    pager -> vfs: "xSync(.db)" {
      style.stroke: "#d32f2f"
      style.stroke-width: 2
    }
    vfs -> disk: "FLUSH_CACHE_COMMAND"
    disk -> vfs: "Success"
    vfs -> pager: "Sync Complete"
    pager -> vdbe: "Checkpoint Done (mxFrame=0)"
  }
}

# --- DOCUMENTATION BLOCK ---

arch_docs: |'md
### THE CHECKPOINT ARCHITECTURE (Milestone 6)

The **Checkpoint** is the critical operation where volatile log data becomes permanent database state.

#### 1. Last-Write-Wins (LWW)
SQLite optimizes checkpoints using the `.shm` (Shared Memory) index. Instead of replaying every single write in the WAL, the engine looks up the highest frame number for a specific Page ID. Only the "Winner" (the latest version) is written to the main `.db` file, drastically reducing I/O.

#### 2. The fsync() Wall
Data written to the OS is not safe. The `fsync()` system call acts as a hard barrier, forcing the Disk Controller to drain its internal volatile caches onto physical media.

#### 3. Log Reset
Once `fsync()` confirms that the main database is updated, the WAL header is reset. Future transactions will start overwriting the WAL from Frame 1.
'| {
  near: top-center
  link: "#milestone-6"
}

# Explicit interconnects for system map
checkpoint_arch.lww_reconciliation.pager_logic.link: "#milestone-4"
checkpoint_arch.durability_barrier.fsync_barrier.link: "#milestone-10"
checkpoint_arch.system_sequence.vdbe.link: "#milestone-3"