vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

# Global Classes for Visual Consistency
classes: {
  memory_page: {
    shape: sql_table
    style: {
      stroke: "#334155"
      fill: "#f1f5f9"
    }
  }
  process_step: {
    shape: step
    style: {
      fill: "#e0f2fe"
      stroke: "#0369a1"
    }
  }
  critical_node: {
    style: {
      fill: "#fee2e2"
      stroke: "#b91c1c"
      bold: true
    }
  }
  annotation: {
    shape: text
    style: {
      font-size: 12
      italic: true
    }
  }
}

# --- SYSTEM RECOVERY ATLAS ---

recovery_atlas: "CRASH RECOVERY ARCHITECTURE" {
  link: "#milestone-6"

  # Stage 1: Detection
  detection: "PHASE 1: THE SENTINEL" {
    style.fill: "#fafafa"
    
    boot_check: "System Boot" {
      class: process_step
    }
    
    file_scanner: "File System Scanner" {
      shape: diamond
      label: "Hot Journal\nDetected?"
    }

    boot_check -> file_scanner: "Checking for unmerged logs"

    metadata: |'md
      ### The Detection Heuristic
      1. Check for `db-journal` or `db-wal`.
      2. Verify if the process ID (PID) in the header is still active.
      3. If file exists and PID is dead, trigger recovery.
    '|
  }

  # Stage 2: Rollback Mechanism (Legacy/Journal Mode)
  rollback_logic: "PHASE 2: ATOMIC ROLLBACK (Journal Mode)" {
    link: "#milestone-6"
    style.fill: "#fff7ed"

    journal_file: "Hot Journal" {
      class: memory_page
      header: "Header: Page Count + Checksum"
      p1: "Page 42 (Original Content)" {style.fill: "#bbf7d0"}
      p2: "Page 109 (Original Content)" {style.fill: "#bbf7d0"}
    }

    main_db_corrupt: "Main DB (Inconsistent State)" {
      class: memory_page
      p1: "Page 42 (Corrupted/Partial)" {style.fill: "#fecaca"}
      p2: "Page 109 (Inconsistent)" {style.fill: "#fecaca"}
    }

    apply_rollback: "Restore Original Pages" {
      class: process_step
    }

    journal_file.p1 -> apply_rollback: "Copy Back"
    apply_rollback -> main_db_corrupt.p1: "Overwrite Corrupt"

    after_state: "State: CONSISTENT" {
      style.stroke: green
      shape: rectangle
    }

    main_db_corrupt -> after_state: "Delete Journal"
  }

  # Stage 3: WAL Replay (Modern Mode)
  wal_replay: "PHASE 3: LOG-FORWARD REPLAY (WAL Mode)" {
    link: "#milestone-6"
    style.fill: "#f0fdf4"

    wal_file: "WAL File (Sequential Appends)" {
      class: memory_page
      frame_1: "Frame 1: Page 5 + Commit"
      frame_2: "Frame 2: Page 12 + Commit"
      frame_3: "Frame 3: Page 5 (Newer) + Uncommitted" {style.stroke-dash: 3}
    }

    replay_engine: "Replay Engine" {
      class: process_step
    }

    db_file: "Main Database File" {
      class: memory_page
      p5: "Page 5 (Old Version)"
      p12: "Page 12 (Old Version)"
    }

    wal_file.frame_1 -> replay_engine: "Read valid frames"
    replay_engine -> db_file.p5: "Sync to Disk"
    
    wal_info: |'md
      ### WAL Advantage
      - Readers are **not blocked** during recovery.
      - Replay only happens up to the **Last Valid Commit Marker**.
      - Frame 3 is ignored (Truncated).
    '|
  }

  # Microscope View: Checksum Failure
  microscope: "MICROSCOPE: THE TORN PAGE DETECTION" {
    link: "#milestone-10"
    
    torn_page: "Disk Page 4096 bytes" {
      shape: sql_table
      header: "Magic Number | LSN"
      data_a: "First 2KB: Written successfully" {style.fill: "#dcfce7"}
      data_b: "Last 2KB: Garbage/Power Loss" {class: critical_node}
      footer: "Expected Checksum: 0xAF42"
    }

    checksum_calc: "Validator" {
      shape: diamond
      label: "Actual == Expected?"
    }

    torn_page.footer -> checksum_calc
    checksum_calc -> recovery_atlas.rollback_logic: "Mismatch -> Force Rollback" {
      style.stroke: red
      style.animated: true
    }
  }
}

# Inter-component connections
recovery_atlas.detection.file_scanner -> recovery_atlas.rollback_logic: "db-journal found"
recovery_atlas.detection.file_scanner -> recovery_atlas.wal_replay: "db-wal found"

# Legend & Metadata
legend: {
  near: bottom-right
  stable: "Stable Data" {style.fill: "#bbf7d0"}
  corrupt: "Inconsistent Data" {style.fill: "#fecaca"}
  action: "Recovery Action" {style.fill: "#e0f2fe"}
}

footer_note: |'md
  **Architect's Note**: SQLite recovery relies on the **Idempotency** of the log. 
  The process can crash *during recovery* and restart indefinitely without 
  further corruption because `fsync()` barriers protect the WAL/Journal validity.
'| {
  near: bottom-center
}