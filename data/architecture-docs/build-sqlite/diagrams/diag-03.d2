vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Meta-Command Router Architecture"
title.near: top-center

# 1. Input Stage (Memory View)
Input Subsystem: {
  link: "#anchor-repl"
  label: "Input Handling"
  style: {
    fill: "#f5f5f5"
    stroke: "#333"
  }

  REPL Loop: {
    shape: circle
    label: "While(true)"
    style.fill: "#fff"
  }

  Input Buffer: {
    shape: class
    label: "struct InputBuffer"
    
    # Internal Memory Layout Visualization
    +buffer: "char* (Heap Ptr)"
    +buffer_len: "size_t (Capacity)"
    +input_len: "ssize_t (Length)"
    
    Memory View: |md
      **Heap Content:**
      `0x400` -> `['.', 'e', 'x', 'i', 't', '\0']`
    |
  }

  REPL Loop -> Input Buffer: "getline(&buffer, ...)"
}

# 2. The Router (Branch Prediction)
Router: {
  link: "#anchor-repl"
  label: "Command Dispatcher"
  style: {
    stroke-width: 2
    fill: "#e3f2fd"
  }

  CPU Register: {
    shape: square
    label: "CPU Register\n(Load buffer[0])"
    style.fill: "#bbdefb"
  }

  Decision: {
    shape: diamond
    label: "Is First Byte '.'?"
    style: {
      fill: "#2196f3"
      font-color: white
    }
  }

  CPU Register -> Decision: "Hardware Check"
}

Input Subsystem.Input Buffer -> Router.CPU Register: "Read First Byte"

# 3. Path A: Meta-Commands
Meta Processor: {
  link: "#anchor-repl"
  label: "Meta-Command Handler"
  style.fill: "#ffcdd2"

  String Comparator: {
    shape: diamond
    label: "strcmp(buffer, ...)"
  }

  Commands: {
    Exit: {
      shape: step
      label: ".exit"
      style.fill: "#d32f2f"
      style.font-color: white
    }
    Tables: {
      shape: step
      label: ".tables"
    }
    Schema: {
      shape: step
      label: ".schema"
    }
    Help: {
      shape: step
      label: ".help"
    }
  }

  Error: {
    shape: parallelogram
    label: "Unrecognized Command"
    style.font-color: "#b71c1c"
  }
}

Router.Decision -> Meta Processor.String Comparator: "YES (Meta-Command)" {
  style: {
    stroke: "#d32f2f"
    stroke-width: 2
  }
}

Meta Processor.String Comparator -> Meta Processor.Commands.Exit: "Match"
Meta Processor.String Comparator -> Meta Processor.Commands.Tables: "Match"
Meta Processor.String Comparator -> Meta Processor.Commands.Schema: "Match"
Meta Processor.String Comparator -> Meta Processor.Commands.Help: "Match"
Meta Processor.String Comparator -> Meta Processor.Error: "No Match"

System Exit: {
  link: "#anchor-repl"
  shape: square
  label: "exit(0)"
  style.fill: "black"
  style.font-color: "white"
}

Meta Processor.Commands.Exit -> System Exit: "Cleanup & Terminate"

# 4. Path B: SQL Commands
SQL Engine: {
  link: "#anchor-repl"
  label: "SQL Pipeline"
  style.fill: "#c8e6c9"

  Compiler: {
    shape: package
    label: "prepare_statement()"
  }
  
  VM: {
    shape: package
    label: "execute_statement()"
  }

  Storage: {
    shape: cylinder
    label: "B-Tree"
  }
}

Router.Decision -> SQL Engine.Compiler: "NO (SQL Statement)" {
  label: "Hot Path"
  style: {
    stroke: "#2e7d32"
    stroke-width: 2
    stroke-dash: 3
  }
}

SQL Engine.Compiler -> SQL Engine.VM: "Bytecode / AST"
SQL Engine.VM -> SQL Engine.Storage: "Read/Write"

# 5. Feedback Loop
Next Iteration: {
  link: "#anchor-repl"
  shape: cloud
  label: "Reset Buffer"
}

Meta Processor.Commands.Tables -> Next Iteration
Meta Processor.Commands.Schema -> Next Iteration
Meta Processor.Commands.Help -> Next Iteration
Meta Processor.Error -> Next Iteration
SQL Engine.VM -> Next Iteration

Next Iteration -> Input Subsystem.REPL Loop: "Loop" {
  style.stroke-dash: 5
}