vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    memory: "#2D2D2D"
    cell: "#4A4A4A"
    new_cell: "#4CAF50"
    promote: "#FF9800"
    pointer: "#2196F3"
    text: "#E0E0E0"
    bg_step: "#1e1e1e"
  }
}

classes: {
  btree_node: {
    label: ""
    shape: rectangle
    style: {
      fill: ${colors.memory}
      stroke: ${colors.text}
      stroke-width: 2
      border-radius: 4
      shadow: true
    }
  }
  key_cell: {
    shape: square
    width: 40
    height: 40
    style: {
      fill: ${colors.cell}
      stroke: ${colors.text}
      font-color: white
      font-size: 16
      bold: true
    }
  }
  pointer_cell: {
    shape: square
    width: 15
    height: 40
    label: ""
    style: {
      fill: ${colors.pointer}
      stroke: transparent
    }
  }
  step_container: {
    style: {
      fill: ${colors.bg_step}
      stroke: ${colors.text}
      stroke-dash: 3
      border-radius: 8
    }
  }
}

direction: right

# ----------------------------------------------------------------------
# STEP 1: OVERFLOW DETECTION
# ----------------------------------------------------------------------
Step 1: {
  class: step_container
  link: "#anchor-btree"
  label: "Step 1: Overflow Detection"
  
  Memory Page 0x1A: {
    class: btree_node
    direction: right
    
    p0: {class: pointer_cell}
    k1: "10" {class: key_cell}
    p1: {class: pointer_cell}
    k2: "20" {class: key_cell}
    p2: {class: pointer_cell}
    k3: "40" {class: key_cell}
    p3: {class: pointer_cell}
    k4: "50" {class: key_cell}
    p4: {class: pointer_cell}
  }

  Insert Action: {
    shape: callout
    type: arrow
    label: "Insert Key: 30"
    style: {
      fill: ${colors.new_cell}
      font-color: black
      stroke: transparent
    }
  }

  Insert Action -> Memory Page 0x1A: "Capacity Full (Max 4)" {
    style: {
      stroke: ${colors.promote}
      stroke-width: 2
    }
  }
}

Step 1 -> Step 2: "Trigger Split Algorithm" {
  style: {
    stroke-width: 4
    stroke: ${colors.text}
  }
}

# ----------------------------------------------------------------------
# STEP 2: KEY REDISTRIBUTION (IN RAM)
# ----------------------------------------------------------------------
Step 2: {
  class: step_container
  link: "#anchor-btree"
  label: "Step 2: Sorting & Median"

  Virtual Buffer: {
    direction: right
    label: "Virtual Sorted Buffer (RAM)"
    
    # Visualizing the array in memory
    v1: "10" {class: key_cell}
    v2: "20" {class: key_cell}
    v3: "30" {
      class: key_cell
      style: {
        fill: ${colors.promote}
        font-color: black
        stroke: ${colors.promote}
        stroke-width: 3
      }
      label: "30\n(Median)"
    }
    v4: "40" {class: key_cell}
    v5: "50" {class: key_cell}
  }

  Operations: {
    direction: down
    style: {
        fill: transparent
        stroke: transparent
    }
    
    alloc: "Allocate New Page 0x1B" {
      shape: package
      style.fill: ${colors.new_cell}
      style.font-color: black
    }
    
    calc: "Calc Split Point (Index 2)" {
      shape: step
      style.fill: ${colors.promote}
      style.font-color: black
    }
  }

  Virtual Buffer.v3 -> Operations.calc: "Identify Median"
  Operations.alloc -> Operations.calc
}

Step 2 -> Step 3: "Promote & Split" {
  style: {
    stroke-width: 4
    stroke: ${colors.text}
  }
}

# ----------------------------------------------------------------------
# STEP 3: PARENT PROMOTION
# ----------------------------------------------------------------------
Step 3: {
  class: step_container
  link: "#anchor-btree"
  label: "Step 3: Hierarchy Update"

  Parent Page: {
    class: btree_node
    direction: right
    label: "Parent Node (0x01)"
    
    pp0: {class: pointer_cell}
    # The promoted key
    pk1: "30" {
      class: key_cell
      style: {
        fill: ${colors.promote}
        font-color: black
      }
    }
    pp1: {class: pointer_cell}
  }

  Children: {
    direction: right
    
    # Original Page (Left)
    Page 0x1A: {
      class: btree_node
      direction: right
      label: "Page 0x1A (Left Child)"
      
      l_p0: {class: pointer_cell}
      l_k1: "10" {class: key_cell}
      l_p1: {class: pointer_cell}
      l_k2: "20" {class: key_cell}
      l_p2: {class: pointer_cell}
    }

    # New Page (Right)
    Page 0x1B: {
      class: btree_node
      direction: right
      label: "Page 0x1B (Right Child)"
      style.stroke: ${colors.new_cell}
      
      r_p0: {class: pointer_cell}
      r_k1: "40" {class: key_cell}
      r_p1: {class: pointer_cell}
      r_k2: "50" {class: key_cell}
      r_p2: {class: pointer_cell}
    }
  }

  # Linkage
  Parent Page.pp0 -> Children.Page 0x1A: "Keys < 30" {
    style: {
      stroke: ${colors.pointer}
      stroke-width: 2
    }
  }
  Parent Page.pp1 -> Children.Page 0x1B: "Keys >= 30" {
    style: {
      stroke: ${colors.pointer}
      stroke-width: 2
    }
  }
}

# ----------------------------------------------------------------------
# TECHNICAL ANNOTATIONS
# ----------------------------------------------------------------------
explanation: |md
  # The Split Mechanics
  1. **Overflow**: Page 0x1A hits 4KB limit.
  2. **Median Calculation**: Keys sorted in RAM: `[10, 20, 30, 40, 50]`. Median is `30`.
  3. **Right Split**: New Page 0x1B created. Keys > Median `[40, 50]` moved here.
  4. **Promotion**: Median `30` moves up to Parent.
  5. **Left Keep**: Page 0x1A keeps keys < Median `[10, 20]`.
| {
  shape: text
  style: {
    font-size: 16
    font: mono
    fill: ${colors.memory}
    stroke: ${colors.text}
    font-color: ${colors.text}
  }
}

Step 3 -> explanation: "Done" {
  style: {
    stroke: transparent
  }
}