vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  c_token: {
    shape: square
    width: 60
    style: {
      fill: "#E1F5FE"
      stroke: "#0288D1"
      font-size: 14
    }
  }
  c_func: {
    shape: package
    style: {
      fill: "#E8EAF6"
      stroke: "#3949AB"
      stroke-width: 2
      shadow: true
    }
  }
  c_ast: {
    shape: oval
    style: {
      fill: "#F1F8E9"
      stroke: "#558B2F"
    }
  }
  c_code: {
    shape: text
    style: {
      font: mono
      font-size: 10
    }
  }
}

# -------------------------------------------------------------------------
# 1. The Token Stream (Input)
# -------------------------------------------------------------------------
Stream: Token Stream (Input) {
  link: "#anchor-parser"
  style.fill: "#FAFAFA"
  style.stroke: "#9E9E9E"
  grid-rows: 1

  t1: SELECT {class: c_token; style.fill: "#B3E5FC"}
  t2: "*" {class: c_token}
  t3: FROM {class: c_token; style.fill: "#B3E5FC"}
  t4: users {class: c_token}
  t5: WHERE {class: c_token; style.fill: "#FFF9C4"; style.stroke: "#FBC02D"}
  t6: id {class: c_token}
  t7: "=" {class: c_token}
  t8: "1" {class: c_token}

  t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7 -> t8
}

# -------------------------------------------------------------------------
# 2. The Recursive Descent Engine
# -------------------------------------------------------------------------
Parser: Recursive Descent Call Stack {
  link: "#anchor-parser"
  style.fill: transparent
  style.stroke-width: 0

  # Level 1
  Function1: parse_statement() {
    class: c_func
    
    code1: |c
      Token t = peek();
      if (t == SELECT)
        return parse_select();
    | {class: c_code}
  }

  # Level 2
  Function2: parse_select() {
    class: c_func
    
    code2: |c
      consume(SELECT);
      parse_table();
      if (peek() == WHERE)
         parse_expression(0);
    | {class: c_code}
  }

  # Level 3
  Function3: parse_expression(min_prec=0) {
    class: c_func
    style.fill: "#FFF3E0"
    style.stroke: "#EF6C00"
    
    code3: |c
      left = parse_term();
      while (prec(op) > min) {
         op = consume();
         right = parse_expression(prec+1);
         left = make_node(op, left, right);
      }
    | {class: c_code}
  }

  # Level 4
  Function4: parse_term() {
    class: c_func
    style.fill: "#E0F2F1"
    
    code4: |c
      if (token == ID) return Node(ID);
      if (token == INT) return Node(INT);
    | {class: c_code}
  }

  Function1 -> Function2: "1. Match SELECT"
  Function2 -> Function3: "2. Found WHERE"
  Function3 -> Function4: "3. Get LHS (id)"
}

# -------------------------------------------------------------------------
# 3. The Abstract Syntax Tree (Output)
# -------------------------------------------------------------------------
AST: Abstract Syntax Tree (Memory) {
  link: "#anchor-parser"
  style.fill: "#F9FBE7"
  style.stroke: "#827717"

  Root: SelectStmt {
    class: c_ast
    style.fill: "#B2DFDB"
  }

  Where: WhereClause {
    class: c_ast
    style.fill: "#FFE0B2"
  }

  Op: BinaryExpr (=) {
    class: c_ast
    style.fill: "#FFCC80"
  }

  Left: Identifier (id) {
    class: c_ast
    shape: rectangle
  }

  Right: Literal (1) {
    class: c_ast
    shape: rectangle
  }

  Root -> Where
  Where -> Op
  Op -> Left
  Op -> Right
}

# -------------------------------------------------------------------------
# Cross-System Interaction
# -------------------------------------------------------------------------

# Lookahead
Parser.Function2.code2 -> Stream.t5: Lookahead (Peek) {
  style.stroke: "#FBC02D"
  style.stroke-dash: 3
}

# Precedence Check
Parser.Function3.code3 -> Stream.t7: Checks Precedence {
  style.stroke: "#EF6C00"
  style.stroke-dash: 3
}

# Construction Concept
Parser.Function3 -> AST.Op: Builds Node {
  style.stroke: "#4CAF50"
  style.stroke-width: 2
}