vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
    pad: 20
  }
}
direction: right

User: Client {
  shape: person
  link: "#anchor-executor"
}

Pipeline: Execution Pipeline {
  link: "#anchor-executor"
  style: {
    fill: "#f5f5f5"
    stroke: "#333"
    stroke-dash: 3
  }

  Frontend: Analysis Phase {
    link: "#anchor-executor"
    Parser: {
      shape: rectangle
      link: "#anchor-executor"
    }
    AST: Abstract Syntax Tree {
      shape: class
      link: "#anchor-executor"
    }
    Parser -> AST: produces
  }

  Optimizer: Planning Phase {
    link: "#anchor-executor"
    Stats: Cost Model
    PlanGenerator
    QueryPlan: Physical Plan {
      shape: class
      tooltip: "Tree of Operators (SeqScan, Filter, Project)"
      link: "#anchor-executor"
    }
    PlanGenerator -> QueryPlan: "Cost-Based Choice"
    Stats -> PlanGenerator: "Cardinality Est."
  }

  Runtime: Execution Phase {
    link: "#anchor-executor"
    tooltip: "The Volcano Model"
    
    Executor: Virtual Machine {
      shape: rectangle
      link: "#anchor-executor"
    }

    OpTree: Operator Tree {
      link: "#anchor-executor"
      Project
      Filter: Predicate Check
      Scan: Table Access
      
      Project -> Filter: GetNext()
      Filter -> Scan: GetNext()
    }
    
    Cursor: Cursor Abstraction {
      shape: package
      style: {
        fill: "#ffab91"
        stroke: "#d84315"
        stroke-width: 2
      }
      link: "#anchor-executor"
      tooltip: "Decouples Logic from Storage"
    }

    Executor -> OpTree.Project: Drives
    OpTree.Scan -> Cursor: cursor_advance()
  }
}

Storage: Storage Engine {
  link: "#anchor-executor"
  style: {
    fill: "#eceff1"
    stroke: "#455a64"
  }
  
  BTree: B-Tree Index {
    shape: hexagon
    link: "#anchor-executor"
  }
  
  Pager: Page Cache {
    shape: queue
    link: "#anchor-executor"
  }
  
  Disk: database.db {
    shape: cylinder
    link: "#anchor-executor"
  }

  BTree -> Pager: get_page(id)
  Pager -> Disk: read/write(4KB)
}

# Main Flow
User -> Pipeline.Frontend.Parser: "SQL Query"
Pipeline.Frontend.AST -> Pipeline.Optimizer.PlanGenerator: Input
Pipeline.Optimizer.QueryPlan -> Pipeline.Runtime.Executor: "Bytecode / Plan"
Pipeline.Runtime.Cursor -> Storage.BTree: "Seek / Next"

# Data Return Flow
Storage.Disk -> Storage.Pager: Raw Bytes
Storage.Pager -> Storage.BTree: Node
Storage.BTree -> Pipeline.Runtime.Cursor: "Row Data"
Pipeline.Runtime.Cursor -> Pipeline.Runtime.OpTree.Scan: Tuple
Pipeline.Runtime.OpTree.Project -> User: Result Set

# Styling for flow clarity
(Pipeline.Runtime.OpTree.Project -> User)[0].style: {
  stroke: "#2e7d32"
  stroke-width: 3
  animated: true
}

(User -> Pipeline.Frontend.Parser)[0].style: {
  stroke: "#1565c0"
  stroke-width: 3
}