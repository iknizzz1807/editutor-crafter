vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
    pad: 20
  }
}

title: |md
  # Query Operation Types
  The Volcano Iterator Model (Pull-based Execution)
| {
  near: top-center
  link: "#anchor-executor"
}

# -------------------------------------------------------------------------
# 1. The Abstract Interface
# -------------------------------------------------------------------------
OperatorInterface: {
  shape: class
  label: "Abstract Operator"
  
  # Methods defined in the interface
  +open(): void
  +next(): Row | EOF
  +close(): void
  
  style: {
    stroke-width: 2
    fill: "#f6f8fa"
    stroke: "#24292e"
    shadow: true
  }
  link: "#anchor-executor"
}

# -------------------------------------------------------------------------
# 2. Concrete Implementations (The Enum)
# -------------------------------------------------------------------------
Implementations: {
  style: {
    fill: transparent
    stroke: transparent
  }
  
  # Leaf Nodes (Sources)
  TableScan: {
    shape: class
    label: "TableScan\n(Leaf)"
    attributes: ["table_id"; "cursor"]
    link: "#anchor-executor"
    style.fill: "#dae8fc"
  }
  
  IndexScan: {
    shape: class
    label: "IndexScan\n(Leaf)"
    attributes: ["index_id"; "search_key"]
    link: "#anchor-executor"
    style.fill: "#dae8fc"
  }

  # Unary Nodes (Processors)
  Filter: {
    shape: class
    label: "Filter\n(Unary)"
    attributes: ["predicate"; "child_op"]
    link: "#anchor-executor"
    style.fill: "#d5e8d4"
  }

  Project: {
    shape: class
    label: "Project\n(Unary)"
    attributes: ["columns"; "child_op"]
    link: "#anchor-executor"
    style.fill: "#d5e8d4"
  }
  
  Limit: {
    shape: class
    label: "Limit\n(Unary)"
    attributes: ["count"; "child_op"]
    link: "#anchor-executor"
    style.fill: "#ffe6cc"
  }

  # Visual hierarchy showing inheritance
  TableScan -> OperatorInterface: extends
  IndexScan -> OperatorInterface: extends
  Filter -> OperatorInterface: extends
  Project -> OperatorInterface: extends
  Limit -> OperatorInterface: extends
}

# -------------------------------------------------------------------------
# 3. Execution Pipeline Example
# -------------------------------------------------------------------------
Pipeline: {
  label: "Execution Pipeline: SELECT name FROM users WHERE age > 21 LIMIT 5"
  link: "#anchor-executor"
  style: {
    fill: "#fafbfc"
    stroke: "#959da5"
    stroke-dash: 3
  }

  # Nodes instantiated in the pipeline
  OpLimit: Limit (5) {
    shape: package
    style.fill: "#ffe6cc"
    link: "#anchor-executor"
  }

  OpProject: Project (name) {
    shape: package
    style.fill: "#d5e8d4"
    link: "#anchor-executor"
  }

  OpFilter: Filter (age > 21) {
    shape: package
    style.fill: "#d5e8d4"
    link: "#anchor-executor"
  }

  OpScan: TableScan (users) {
    shape: cylinder
    style.fill: "#dae8fc"
    link: "#anchor-executor"
  }

  # Control Flow (Down the stack)
  OpLimit -> OpProject: "1. call next()" {
    style: {
      stroke: "#0366d6"
      stroke-width: 2
    }
  }
  OpProject -> OpFilter: "2. call next()" {
    style: {
      stroke: "#0366d6"
      stroke-width: 2
    }
  }
  OpFilter -> OpScan: "3. call next()" {
    style: {
      stroke: "#0366d6"
      stroke-width: 2
    }
  }

  # Data Flow (Up the stack)
  OpScan -> OpFilter: "4. return Row" {
    style: {
      stroke: "#28a745"
      stroke-dash: 3
    }
  }
  OpFilter -> OpProject: "5. return Row" {
    style: {
      stroke: "#28a745"
      stroke-dash: 3
    }
  }
  OpProject -> OpLimit: "6. return Row" {
    style: {
      stroke: "#28a745"
      stroke-dash: 3
    }
  }
}

# Legend / context connection
Implementations.Limit -> Pipeline.OpLimit: "instantiated as" {
  style: {
    opacity: 0.3
    stroke-dash: 5
  }
}