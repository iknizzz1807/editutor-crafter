vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Join Strategies Overview
  The Executor selects the optimal strategy based on **Data Size**, **Indexes**, and **Sort Order**.
| {near: top-center}

classes: {
  strategy: {
    style: {
      stroke-width: 2
      shadow: true
      border-radius: 8
    }
  }
  data: {
    shape: cylinder
    style: {
      multiple: true
      fill: "#f4f6f8"
    }
  }
  process: {
    shape: step
    style: {
      fill: white
      stroke-width: 1
    }
  }
  note: {
    shape: text
    style: {
      font-size: 14
      font-color: "#555"
      text-transform: none
    }
  }
}

Optimizer: Query Optimizer {
  shape: diamond
  style.fill: "#ffd700"
  link: "#anchor-join"
  tooltip: "Cost-Based Decision Maker"
}

Strategies: {
  style.fill: transparent
  style.stroke-width: 0

  NestedLoop: Nested Loop Join {
    link: "#anchor-join"
    class: strategy
    style.fill: "#ffebec"
    label: "Nested Loop\n(The Generalist)"

    Outer: Outer Table\n(Driving Table) {class: data}
    Inner: Inner Table {class: data}

    Methods: {
      style.fill: transparent
      style.stroke-width: 0
      
      Naive: Simple Loop {
        class: process
        label: "Scan Entire Table\nO(N * M)"
        style.stroke: red
        style.stroke-dash: 3
      }
      
      Index: Index Seek {
        class: process
        label: "B-Tree Lookup\nO(N * log M)"
        style.stroke: darkred
        style.stroke-width: 2
      }
    }

    Complexity: |md
      **Complexity**: High CPU
      **Memory**: Low
    | { class: note }

    Outer -> Methods.Naive: For each row
    Methods.Naive -> Inner: Full Scan
    
    Outer -> Methods.Index: For each row
    Methods.Index -> Inner: Key Seek
  }

  HashJoin: Hash Join {
    link: "#anchor-join"
    class: strategy
    style.fill: "#e6fffa"
    label: "Hash Join\n(The Heavy Lifter)"

    Build: Build Input\n(Smaller Side) {class: data}
    Probe: Probe Input\n(Larger Side) {class: data}

    Memory: {
      shape: package
      label: "In-Memory Hash Table"
      style.fill: white
      
      Bucket1: "Hash(Key) -> Row"
      Bucket2: "Hash(Key) -> Row"
    }

    Complexity: |md
      **Complexity**: O(N+M)
      **Memory**: High (Hash Table)
    | { class: note }

    Build -> Memory: "1. Build Phase\n(O(N))"
    Probe -> Memory: "2. Probe Phase\n(O(M))"
  }

  MergeJoin: Merge Join {
    link: "#anchor-join"
    class: strategy
    style.fill: "#e6f7ff"
    label: "Sort-Merge Join\n(The Zipper)"

    SortedA: Table A\n(Sorted) {class: data}
    SortedB: Table B\n(Sorted) {class: data}

    Zipper: Zipper Logic {
      class: process
      label: "Compare Cursors\nAdvance Smallest"
    }

    Complexity: |md
      **Complexity**: O(N+M)
      **Memory**: Low (Streaming)
    | { class: note }

    SortedA -> Zipper: Stream
    SortedB -> Zipper: Stream
  }
}

# Decision Paths
Optimizer -> Strategies.NestedLoop: "Has Index on Join Key?" {
  style: {
    stroke: darkred
    stroke-width: 2
  }
}
Optimizer -> Strategies.NestedLoop: "One table is very small?" {
  style: {
    stroke: red
    stroke-dash: 3
  }
}

Optimizer -> Strategies.HashJoin: "Large Unsorted Data?\n(Requires RAM)" {
  style: {
    stroke: teal
    stroke-width: 2
  }
}

Optimizer -> Strategies.MergeJoin: "Input already sorted?\n(e.g. PK Join)" {
  style: {
    stroke: blue
    stroke-width: 2
  }
}