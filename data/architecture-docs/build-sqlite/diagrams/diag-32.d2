vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Query Planner Architecture
  From Declarative SQL to Imperative Execution
| {near: top-center}

direction: right

classes: {
  stage: {
    link: "#anchor-optimize"
    style: {
      border-radius: 5
      shadow: true
    }
  }
  data: {
    shape: class
    link: "#anchor-optimize"
    style: {
      stroke-dash: 3
    }
  }
}

# -------------------------------------------------------------------------
# 1. Parsing & Logical Analysis
# -------------------------------------------------------------------------

Input: |sql
  SELECT * FROM u, o 
  WHERE u.id = o.uid 
  AND u.active = 1
| {
  shape: document
  class: stage
  style.fill: "#222"
  style.stroke: "#61D85E"
}

Parser: {
  shape: step
  label: "Parser & Binder"
  class: stage
  tooltip: "Syntax Check & Name Resolution"
}

AST: Abstract Syntax Tree {
  class: data
  +Statement: SELECT
  +From: [u, o]
  +Where: [AND]
  +Eq1: [u.id, o.uid]
  +Eq2: [u.active, 1]
}

LogicalPlanner: {
  shape: step
  label: "Logical Planner"
  class: stage
}

LogicalPlan: Logical Plan {
  class: data
  tooltip: "Relational Algebra"
  +Filter: (active=1)
  +Join: (Cross Product)
  +Scan: u
  +Scan: o
}

# -------------------------------------------------------------------------
# 2. The Optimizer Core
# -------------------------------------------------------------------------

Optimizer: **THE OPTIMIZER (CBO)** {
  link: "#anchor-optimize"
  style: {
    fill: "#2D2B55"
    stroke: "#FF9F1C"
    stroke-width: 2
    double-border: true
  }

  # Components
  StatsRepo: Table Statistics {
    shape: class
    users_rows: "100k"
    users_pages: "500"
    active_hist: "1%:99%"
    orders_rows: "5M"
    orders_pages: "25k"
    style.fill: "#1E1E3F"
  }

  RBO: Rule-Based Rewriter {
    shape: package
    style.fill: "#4B4B75"
    
    rules: {
      label: "Heuristics"
      shape: class
      +Predicate Pushdown
      +Constant Folding
      +Column Pruning
    }
  }

  Enumerator: Join Order Enumerator {
    shape: diamond
    label: "Dynamic Programming\n(Join Ordering)"
    style.fill: "#FF9F1C"
    style.font-color: black
  }

  CostModel: Cost Calculator {
    shape: cylinder
    style.fill: "#D9D9D9"
    style.font-color: black
    
    formula: |latex
      Cost = N_{page} \times C_{IO} + N_{row} \times C_{CPU}
    |
  }

  Candidates: Candidate Plans {
    shape: queue
    style.fill: "#1E1E3F"
    
    p1: "Plan A: NestedLoop\nCost: 10^9"
    p2: "Plan B: HashJoin\nCost: 500" {
      style.font-color: "#61D85E"
      style.bold: true
    }
    p3: "Plan C: MergeJoin\nCost: 1200"
  }
}

# -------------------------------------------------------------------------
# 3. Execution
# -------------------------------------------------------------------------

PhysicalPlan: Selected Physical Plan {
  class: data
  style.stroke: "#61D85E"
  style.stroke-width: 2
  +HashJoin: (Build: u, Probe: o)
  +IndexScan: u (active=1)
  +SeqScan: o
}

Executor: Execution Engine {
  shape: square
  class: stage
  label: "Volcano Executor"
  tooltip: "Iterates over the plan (next, next...)"
}

# -------------------------------------------------------------------------
# Connections
# -------------------------------------------------------------------------

Input -> Parser: "Tokens"
Parser -> AST: "Build"
AST -> LogicalPlanner: "Analyze"
LogicalPlanner -> LogicalPlan: "Algebra"

LogicalPlan -> Optimizer.RBO: "Input"

# Optimizer Internal Flow
Optimizer.RBO -> Optimizer.Enumerator: "Optimized\nLogical Plan"
Optimizer.StatsRepo -> Optimizer.CostModel: "Selectivity &\nCardinality"
Optimizer.Enumerator -> Optimizer.CostModel: "Ask Cost"
Optimizer.CostModel -> Optimizer.Enumerator: "Return Cost"
Optimizer.Enumerator -> Optimizer.Candidates: "Generate"
Optimizer.Candidates -> PhysicalPlan: "Pick Lowest Cost"

PhysicalPlan -> Executor: "Bytecode / Ops"