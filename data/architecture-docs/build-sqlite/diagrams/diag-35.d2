vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: right

classes: {
  struct: {
    shape: class
    style: {
      stroke-width: 2
      fill: "#fdfdfd"
      stroke: "#333"
      shadow: true
    }
  }
  pointer: {
    target-arrowhead: {
      shape: triangle
    }
    style: {
      stroke: "#555"
      stroke-width: 2
    }
  }
}

# 1. The Input Query
input_sql: |sql
  EXPLAIN SELECT u.name, o.total
  FROM orders o
  JOIN users u ON o.user_id = u.id
  WHERE u.active = 1;
| {
  shape: text
  link: "#anchor-optimize"
  style.font-size: 16
}

# 2. The Formatted Output (What the user sees)
terminal_view: {
  label: "STDOUT (Terminal)"
  shape: package
  style.fill: "#2b2b2b"
  style.stroke: "#555"
  style.font-color: "#eee"
  link: "#anchor-optimize"

  output: |md
    QUERY PLAN
    -----------------------------------------------------------
    Hash Join  (cost=185.00 rows=500 width=64)
      Hash Cond: (o.user_id = u.id)
      ->  Seq Scan on orders o  (cost=0.00..120.00 rows=5000)
      ->  Hash  (cost=40.00..40.00 rows=200)
            ->  Index Scan using idx_active on users u
                  Index Cond: (active = 1)
                  (cost=0.00..35.00 rows=200)
  | {
    shape: text
    style.font: mono
    style.font-size: 14
    style.font-color: "#a9b7c6"
  }
}

# 3. The Memory Layout (The Microscope)
memory_heap: {
  label: "Executor Memory (Plan Tree)"
  style.fill: "#e8eff5"
  style.stroke: "#2c3e50"
  style.stroke-dash: 3
  link: "#anchor-optimize"

  # Root Node
  plan_root: {
    class: struct
    label: "PlanNode (HashJoin)"
    
    +type: JOIN_HASH
    +cost: 185.00
    +cardinality: 500
    +output_cols: "[u.name, o.total]"
    
    # Cost Logic Visualized
    "Total Cost" : "Left.Cost + Right.Cost + CPU_Hash"
  }

  # Outer Relation (Probe)
  outer_node: {
    class: struct
    label: "PlanNode (SeqScan)"
    
    +type: SCAN_SEQ
    +table: "orders (o)"
    +cost: 120.00
    +est_rows: 5000
    
    # Cost Formula annotation
    "Cost Formula": "N_pages * C_seq_io"
  }

  # Inner Relation (Build)
  hash_node: {
    class: struct
    label: "PlanNode (Hash)"
    
    +type: MATERIALIZE_HASH
    +cost: 40.00
    +buckets: 256
    +memory_usage: "12 KB"
  }

  # Source of Inner
  inner_node: {
    class: struct
    label: "PlanNode (IndexScan)"
    
    +type: SCAN_INDEX
    +index: "idx_active"
    +cost: 35.00
    +est_rows: 200
    
    "Cost Formula": "log(N) * C_rand_io"
  }

  # Pointers structure
  plan_root -> outer_node: "left_tree (Probe)" {
    class: pointer
    style.stroke: "#d63031"
  }
  plan_root -> hash_node: "right_tree (Build)" {
    class: pointer
    style.stroke: "#0984e3"
  }
  hash_node -> inner_node: "child" {
    class: pointer
  }
}

# Cost Calculation Callout (Positioned via connection for ELK compatibility)
cost_math: |md
  # Cost Model Math
  $$ Cost = (N_{pages} \times 1.0) + (N_{rows} \times 0.01) $$
| {
  link: "#anchor-optimize"
  style.fill: "#fff3cd"
  style.stroke: "#856404"
  style.font-color: "#856404"
}

# Main Flow
input_sql -> terminal_view: "Parsed & Optimized"
terminal_view -> memory_heap: "Reflects Internal State" {
  style.stroke-dash: 5
  style.opacity: 0.4
}

# Connect Math to Heap to position it
memory_heap -- cost_math: "Applies Formula" {
  style.stroke-dash: 3
  style.opacity: 0.3
}