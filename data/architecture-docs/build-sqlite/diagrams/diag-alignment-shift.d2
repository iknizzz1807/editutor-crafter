vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  memory_cell: {
    shape: square
    style: {
      stroke: "#444444"
      font-size: 10
    }
  }
  active_int: {
    style: {
      fill: "#3dfa89"
      bold: true
      stroke-width: 3
    }
  }
  straddle_int: {
    style: {
      fill: "#ff6b6b"
      bold: true
      stroke-width: 3
    }
  }
  register: {
    shape: rectangle
    style: {
      fill: "#f8f9fa"
      double-border: true
      stroke: "#007bff"
    }
  }
  boundary: {
    style: {
      stroke: "#ff0000"
      stroke-dash: 5
      stroke-width: 4
    }
  }
}

"Memory Alignment vs Record Packing": {
  link: "#milestone-7"
  
  "ALIGNED CASE (Nirvana)": {
    direction: right
    description: |md
      **Offset 0x04**: Data starts on a 4-byte boundary. 
      The CPU issues a single `MOV` instruction. 
      Data resides within one **L1 Cache Line**.
    |
    
    cache_line: {
      label: "L1 Cache Line (64 Bytes)"
      grid-columns: 8
      
      b0: "0x00"; b1: "0x01"; b2: "0x02"; b3: "0x03"
      
      data: "INT32" {
        grid-columns: 4
        class: active_int
        i0: "0x04"; i1: "0x05"; i2: "0x06"; i3: "0x07"
      }
      
      b8: "0x08"; b9: "0x09"; b10: "0x0A"; b11: "0x0B"
    }

    cpu_cycle: {
      shape: step
      "1. Issue Load" -> "2. Fetch from L1" -> "3. Fill Register"
    }

    cpu_register: "64-bit Register" {
      class: register
      value: "0x00000000[INT32]"
    }

    cache_line.data -> cpu_register: "Direct Load (1 Cycle)" {
      style.animated: true
      style.stroke: "#3dfa89"
    }
  }

  "UNALIGNED CASE (The Tax)": {
    direction: right
    description: |md
      **Offset 0x3F**: Data straddles the 64-byte boundary.
      One byte is in Cache Line A, three bytes are in Cache Line B.
      **Penalty**: Pipeline stall.
    |

    mem_layout: {
      grid-columns: 2
      horizontal-gap: 0
      
      line_a: "Cache Line A" {
        style.fill: "#eeeeee"
        pad: "..." { shape: text }
        byte_63: "0x3F" { class: straddle_int }
      }
      
      border: "" { class: boundary; width: 5 }

      line_b: "Cache Line B" {
        style.fill: "#dddddd"
        bytes: {
          grid-columns: 3
          b64: "0x40" { class: straddle_int }
          b65: "0x41" { class: straddle_int }
          b66: "0x42" { class: straddle_int }
        }
        rest: "..." { shape: text }
      }
    }

    pipeline_tax: {
      shape: package
      label: "Internal CPU Micro-Ops"
      
      fetch_a: "Fetch Line A"
      fetch_b: "Fetch Line B"
      shift_a: "Shift & Mask A"
      shift_b: "Shift & Mask B"
      merge: "OR Logic (Combine)"
      
      fetch_a -> shift_a
      fetch_b -> shift_b
      shift_a -> merge
      shift_b -> merge
    }

    cpu_register: "64-bit Register" {
      class: register
      value: "[Merged Data]"
    }

    mem_layout.line_a.byte_63 -> pipeline_tax.fetch_a
    mem_layout.line_b.bytes -> pipeline_tax.fetch_b
    pipeline_tax.merge -> cpu_register: "Assembly (10-20 Cycles)" {
      style.stroke: "#ff6b6b"
      style.stroke-dash: 3
    }
  }
}

legend: {
  near: bottom-right
  
  aligned: "Aligned" {
    style.fill: "#3dfa89"
  }
  unaligned: "Straddling Boundary" {
    style.fill: "#ff6b6b"
  }
  tax: "CPU Stall Path" {
    style.stroke: "#ff6b6b"
    style.stroke-dash: 3
  }
}

"Memory Alignment vs Record Packing"."ALIGNED CASE (Nirvana)".cache_line.*.class: memory_cell
"Memory Alignment vs Record Packing"."UNALIGNED CASE (The Tax)".mem_layout.line_a.byte_63.class: memory_cell
"Memory Alignment vs Record Packing"."UNALIGNED CASE (The Tax)".mem_layout.line_b.bytes.*.class: memory_cell