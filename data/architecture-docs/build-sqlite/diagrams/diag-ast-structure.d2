vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    stmt: "#E8F5E9"
    expr: "#E3F2FD"
    bin_expr: "#FFF3E0"
    leaf: "#F3E5F5"
    stroke_dark: "#37474F"
    text_dark: "#263238"
    highlight_or: "#FF7043"
    highlight_and: "#42A5F5"
  }
}
direction: right
title: |md
  # AST Node Hierarchy
  ### Abstract Syntax Tree Structure & Operator Precedence
| {near: top-center}
# ============================================
# AST NODE TYPE HIERARCHY
# ============================================
AST_Node_Types: {
  label: "AST Node Type Hierarchy"
  Statement: {
    label: "Statement Nodes"
    style.fill: ${colors.stmt}
    style.stroke: ${colors.stroke_dark}
    shape: class
    +type: AST_SELECT_STMT | AST_INSERT_STMT | AST_CREATE_STMT
    +line: int
    +column: int
  }
  Expression: {
    label: "Expression Nodes"
    style.fill: ${colors.expr}
    style.stroke: ${colors.stroke_dark}
    shape: class
    +type: AST_BINARY_EXPR | AST_UNARY_EXPR | AST_LITERAL | AST_IDENTIFIER
    +line: int
    +column: int
  }
  SelectStmt: {
    label: "SELECT Statement"
    style.fill: ${colors.stmt}
    style.stroke: ${colors.stroke_dark}
    shape: class
    +columns: ASTNode*
    +table_name: char*
    +where: ASTNode*
    +order_by: ASTNode*
    +limit: ASTNode*
  }
  BinaryExpr: {
    label: "Binary Expression"
    style.fill: ${colors.bin_expr}
    style.stroke: ${colors.stroke_dark}
    shape: class
    +left: ASTNode*
    +operator: char* ("AND", "OR", "=", "<", etc.)
    +right: ASTNode*
  }
  UnaryExpr: {
    label: "Unary Expression"
    style.fill: ${colors.bin_expr}
    style.stroke: ${colors.stroke_dark}
    shape: class
    +operator: char* ("NOT", "-")
    +operand: ASTNode*
  }
  LiteralExpr: {
    label: "Literal Expression"
    style.fill: ${colors.leaf}
    style.stroke: ${colors.stroke_dark}
    shape: class
    +token: Token (INTEGER, FLOAT, STRING, NULL)
  }
  IdentifierExpr: {
    label: "Identifier Expression"
    style.fill: ${colors.leaf}
    style.stroke: ${colors.stroke_dark}
    shape: class
    +name: char*
  }
  Statement -- Expression: "contains" {style.stroke-dash: 3}
  SelectStmt -- Statement: "extends" {target-arrowhead.shape: triangle; target-arrowhead.style.filled: false}
  BinaryExpr -- Expression: "extends" {target-arrowhead.shape: triangle; target-arrowhead.style.filled: false}
  UnaryExpr -- Expression: "extends" {target-arrowhead.shape: triangle; target-arrowhead.style.filled: false}
  LiteralExpr -- Expression: "extends" {target-arrowhead.shape: triangle; target-arrowhead.style.filled: false}
  IdentifierExpr -- Expression: "extends" {target-arrowhead.shape: triangle; target-arrowhead.style.filled: false}
}
# ============================================
# PRECEDENCE DEMONSTRATION
# ============================================
Precedence_Comparison: {
  label: "Operator Precedence: AND Binds Tighter Than OR"
  # Expression A: a OR b AND c
  Expr_A: {
    label: "\"a OR b AND c\""
    style.fill: "transparent"
    style.stroke: ${colors.stroke_dark}
    OR_A: {
      label: "OR\n(evaluated LAST)"
      style.fill: ${colors.highlight_or}
      style.stroke: ${colors.stroke_dark}
      style.font-color: white
      style.bold: true
    }
    id_a1: {
      label: "a"
      style.fill: ${colors.leaf}
      shape: circle
    }
    AND_A: {
      label: "AND\n(evaluated FIRST)"
      style.fill: ${colors.highlight_and}
      style.stroke: ${colors.stroke_dark}
      style.font-color: white
      style.bold: true
    }
    id_b1: {
      label: "b"
      style.fill: ${colors.leaf}
      shape: circle
    }
    id_c1: {
      label: "c"
      style.fill: ${colors.leaf}
      shape: circle
    }
    id_a1 -> OR_A: "left"
    AND_A -> OR_A: "right"
    id_b1 -> AND_A: "left"
    id_c1 -> AND_A: "right"
  }
  # Expression B: (a OR b) AND c
  Expr_B: {
    label: "\"(a OR b) AND c\""
    style.fill: "transparent"
    style.stroke: ${colors.stroke_dark}
    AND_B: {
      label: "AND\n(evaluated LAST)"
      style.fill: ${colors.highlight_and}
      style.stroke: ${colors.stroke_dark}
      style.font-color: white
      style.bold: true
    }
    OR_B: {
      label: "OR\n(evaluated FIRST)"
      style.fill: ${colors.highlight_or}
      style.stroke: ${colors.stroke_dark}
      style.font-color: white
      style.bold: true
    }
    id_a2: {
      label: "a"
      style.fill: ${colors.leaf}
      shape: circle
    }
    id_b2: {
      label: "b"
      style.fill: ${colors.leaf}
      shape: circle
    }
    id_c2: {
      label: "c"
      style.fill: ${colors.leaf}
      shape: circle
    }
    OR_B -> AND_B: "left"
    id_c2 -> AND_B: "right"
    id_a2 -> OR_B: "left"
    id_b2 -> OR_B: "right"
  }
}
# ============================================
# PRECEDENCE TABLE
# ============================================
Precedence_Table: {
  label: "Operator Precedence Levels\n(Higher = Binds Tighter)"
  style.fill: "#FAFAFA"
  style.stroke: ${colors.stroke_dark}
  |`md
  | Level | Operators | Associativity |
  |-------|-----------|---------------|
  | 7 (Highest) | PRIMARY (literals, identifiers, parens) | - |
  | 6 | UNARY (-, +, NOT) | Right |
  | 5 | *, /, % | Left |
  | 4 | +, - | Left |
  | 3 | =, <, >, <=, >=, <>, != | Left |
  | 2 | AND | Left |
  | 1 (Lowest) | OR | Left |
  `|
}
# ============================================
# KEY INSIGHT
# ============================================
Key_Insight: {
  label: "Key Insight"
  style.fill: "#FFF8E1"
  style.stroke: "#FFB300"
  style.stroke-width: 2
  insight_text: |md
    **Tree Depth = Evaluation Order**
    Deeper nodes are evaluated first (bottom-up).
    - In `a OR b AND c`: AND is deeper → evaluated first
    - In `(a OR b) AND c`: OR is deeper → evaluated first
    Parentheses force a "fresh parse" at the lowest precedence,
    effectively restarting the tree construction.
  | {shape: text}
}
# ============================================
# CONNECTIONS
# ============================================
AST_Node_Types -- Precedence_Comparison: "produces different trees for same tokens" {style.stroke-dash: 5; style.stroke: "#9E9E9E"}
Precedence_Comparison -- Precedence_Table: "governed by" {style.stroke-dash: 5; style.stroke: "#9E9E9E"}
Precedence_Table -- Key_Insight: {style.stroke-dash: 5; style.stroke: "#9E9E9E"}
# Legend
legend: {
  near: bottom-right
  label: "Legend"
  style.fill: "transparent"
  style.stroke: ${colors.stroke_dark}
  stmt_node: {
    label: "Statement Node"
    style.fill: ${colors.stmt}
  }
  expr_node: {
    label: "Expression Node"
    style.fill: ${colors.expr}
  }
  bin_node: {
    label: "Binary/Unary Expr"
    style.fill: ${colors.bin_expr}
  }
  leaf_node: {
    label: "Literal/Identifier"
    style.fill: ${colors.leaf}
  }
  stmt_node -- expr_node -- bin_node -- leaf_node {style.stroke: transparent}
}