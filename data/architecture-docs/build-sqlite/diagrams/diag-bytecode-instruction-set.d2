vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: VDBE Instruction Set Reference {
  near: top-center
  shape: text
  style: {
    font-size: 32
    bold: true
    underline: true
  }
}

instruction_format: {
  label: Instruction Format (32 bytes)
  style: {
    fill: "#E8F4FD"
    stroke: "#2E86AB"
    stroke-width: 2
    border-radius: 4
  }
  
  header: {
    grid-columns: 5
    grid-gap: 0
    
    op_byte: "Opcode\n(1 byte)" {
      style: {
        fill: "#FFE5B4"
        stroke: "#D48806"
        font: mono
        bold: true
      }
    }
    p1_bytes: "P1\n(4 bytes)" {
      style: {
        fill: "#D4EDDA"
        stroke: "#28A745"
        font: mono
      }
    }
    p2_bytes: "P2\n(4 bytes)" {
      style: {
        fill: "#D4EDDA"
        stroke: "#28A745"
        font: mono
      }
    }
    p3_bytes: "P3\n(4 bytes)" {
      style: {
        fill: "#D4EDDA"
        stroke: "#28A745"
        font: mono
      }
    }
    p4_ptr: "P4\n(ptr/str)" {
      style: {
        fill: "#E2D5F0"
        stroke: "#7B4B94"
        font: mono
      }
    }
  }
  
  legend: |md
    **P1**: Primary operand (cursor#, register#, value)  
    **P2**: Jump target or secondary operand  
    **P3**: Comparison register or tertiary operand  
    **P4**: Variable-length (string, blob, or pointer)
  |
}

legend.style.fill: transparent
legend.style.font-size: 14

opcode_categories: {
  direction: right
  
  cursor_ops: Cursor Operations {
    style: {
      fill: "#FFF3E0"
      stroke: "#E65100"
      border-radius: 8
    }
    
    opcodes: {
      shape: sql_table
      style.fill: white
      
      opcode: Opcode {constraint: primary_key}
      p1: P1 {constraint: not_null}
      p2: P2
      p3: P3
      desc: Description
      
      row1: ["OpenTable"; "cursor#"; "root_page"; "0"; "Open B-tree cursor on table"]
      row2: ["OpenIndex"; "cursor#"; "root_page"; "0"; "Open B+tree cursor on index"]
      row3: ["Close"; "cursor#"; ""; ""; "Close cursor, free resources"]
      row4: ["Rewind"; "cursor#"; "jump_if_empty"; ""; "Position before first row"]
      row5: ["Last"; "cursor#"; "jump_if_empty"; ""; "Position after last row"]
    }
  }
  
  data_ops: Data Movement {
    style: {
      fill: "#E8F5E9"
      stroke: "#2E7D32"
      border-radius: 8
    }
    
    opcodes: {
      shape: sql_table
      style.fill: white
      
      opcode: Opcode {constraint: primary_key}
      p1: P1 {constraint: not_null}
      p2: P2 {constraint: not_null}
      p3: P3
      desc: Description
      
      row1: ["Column"; "cursor#"; "col_idx"; "dest_reg"; "Read column into register"]
      row2: ["Rowid"; "cursor#"; "dest_reg"; ""; "Get current row rowid"]
      row3: ["Integer"; "value"; "dest_reg"; ""; "Load integer constant"]
      row4: ["String8"; "0"; "dest_reg"; "string"; "Load string from P4"]
      row5: ["Null"; "dest_reg"; "dest_reg_end"; ""; "Load NULL into register(s)"]
    }
  }
  
  result_ops: Result & Control {
    style: {
      fill: "#FCE4EC"
      stroke: "#C2185B"
      border-radius: 8
    }
    
    opcodes: {
      shape: sql_table
      style.fill: white
      
      opcode: Opcode {constraint: primary_key}
      p1: P1 {constraint: not_null}
      p2: P2 {constraint: not_null}
      p3: P3
      desc: Description
      
      row1: ["ResultRow"; "start_reg"; "count"; ""; "Output result row"]
      row2: ["Halt"; "err_code"; ""; ""; "End program execution"]
      row3: ["Goto"; ""; "target_addr"; ""; "Unconditional jump"]
      row4: ["Next"; "cursor#"; "jump_target"; ""; "Advance cursor, jump if more"]
      row5: ["Prev"; "cursor#"; "jump_target"; ""; "Move cursor backward"]
    }
  }
}

write_ops: Write Operations {
  style: {
    fill: "#F3E5F5"
    stroke: "#7B1FA2"
    border-radius: 8
  }
  
  opcodes: {
    shape: sql_table
    style.fill: white
    
    opcode: Opcode {constraint: primary_key}
    p1: P1 {constraint: not_null}
    p2: P2 {constraint: not_null}
    p3: P3
    desc: Description
    
    row1: ["MakeRecord"; "start_reg"; "count"; "dest_reg"; "Serialize registers into record"]
    row2: ["Insert"; "cursor#"; "record_reg"; "flags"; "Insert record at cursor"]
    row3: ["Delete"; "cursor#"; ""; ""; "Delete current row"]
    row4: ["NewRowid"; "cursor#"; "dest_reg"; ""; "Generate new rowid"]
    row5: ["IdxInsert"; "cursor#"; "record_reg"; ""; "Insert into index B+tree"]
  }
}

compare_ops: Comparison & Conditional Jumps {
  style: {
    fill: "#E3F2FD"
    stroke: "#1565C0"
    border-radius: 8
  }
  
  opcodes: {
    shape: sql_table
    style.fill: white
    
    opcode: Opcode {constraint: primary_key}
    p1: P1 {constraint: not_null}
    p2: P2 {constraint: not_null}
    p3: P3 {constraint: not_null}
    desc: Description
    
    row1: ["Eq"; "reg1"; "jump_target"; "reg2"; "Jump if reg1 == reg2"]
    row2: ["Ne"; "reg1"; "jump_target"; "reg2"; "Jump if reg1 != reg2"]
    row3: ["Lt"; "reg1"; "jump_target"; "reg2"; "Jump if reg1 < reg2"]
    row4: ["Le"; "reg1"; "jump_target"; "reg2"; "Jump if reg1 <= reg2"]
    row5: ["Gt"; "reg1"; "jump_target"; "reg2"; "Jump if reg1 > reg2"]
    row6: ["Ge"; "reg1"; "jump_target"; "reg2"; "Jump if reg1 >= reg2"]
    row7: ["IsNull"; "reg"; "jump_target"; ""; "Jump if register is NULL"]
    row8: ["NotNull"; "reg"; "jump_target"; ""; "Jump if register is not NULL"]
  }
  
  note: |md
    **Three-Valued Logic**: If either operand is NULL,  
    comparison returns NULL (not TRUE), so no jump occurs.
  |
  note.style: {
    fill: "#FFF9C4"
    stroke: "#F57F17"
    font-size: 12
    italic: true
  }
}

aggregate_ops: Aggregate Operations {
  style: {
    fill: "#E0F7FA"
    stroke: "#00838F"
    border-radius: 8
  }
  
  opcodes: {
    shape: sql_table
    style.fill: white
    
    opcode: Opcode {constraint: primary_key}
    p1: P1 {constraint: not_null}
    p2: P2 {constraint: not_null}
    p3: P3
    desc: Description
    
    row1: ["AggStep"; "agg_ctx"; "value_reg"; ""; "Accumulate value into aggregate"]
    row2: ["AggFinal"; "agg_ctx"; "dest_reg"; ""; "Finalize aggregate, store result"]
    row3: ["SorterOpen"; "sorter#"; "n_cols"; ""; "Open sorter for GROUP BY"]
    row4: ["SorterInsert"; "sorter#"; "record_reg"; ""; "Insert row into sorter"]
    row5: ["SorterSort"; "sorter#"; "jump_empty"; ""; "Sort sorter contents"]
    row6: ["SorterData"; "sorter#"; "dest_reg"; ""; "Read current sorter row"]
    row7: ["SorterNext"; "sorter#"; "jump_more"; ""; "Advance sorter cursor"]
  }
}

register_model: {
  label: Register File Model
  style: {
    fill: "#FAFAFA"
    stroke: "#9E9E9E"
    stroke-dash: 3
    border-radius: 8
  }
  
  registers: {
    grid-columns: 8
    grid-gap: 2
    
    r0: "r0" {
      style: {
        fill: "#BBDEFB"
        stroke: "#1976D2"
        font: mono
        font-size: 11
      }
    }
    r1: "r1" {
      style: {
        fill: "#BBDEFB"
        stroke: "#1976D2"
        font: mono
        font-size: 11
      }
    }
    r2: "r2" {
      style: {
        fill: "#BBDEFB"
        stroke: "#1976D2"
        font: mono
        font-size: 11
      }
    }
    ellipsis: "..." {
      style: {
        fill: transparent
        stroke: transparent
        font-size: 14
      }
    }
    rn: "rN" {
      style: {
        fill: "#BBDEFB"
        stroke: "#1976D2"
        font: mono
        font-size: 11
      }
    }
  }
  
  desc: |md
    - Unlimited registers (allocated as needed)
    - Each holds: INTEGER | REAL | TEXT | BLOB | NULL
    - Column values loaded into consecutive registers
    - Aggregate state stored in context registers
  |
  desc.style: {
    fill: transparent
    font-size: 13
  }
}

execution_cycle: Execution Cycle {
  direction: right
  
  fetch: Fetch {
    shape: circle
    style: {
      fill: "#4CAF50"
      font-color: white
      stroke: "#2E7D32"
      stroke-width: 2
    }
  }
  
  decode: Decode {
    shape: circle
    style: {
      fill: "#2196F3"
      font-color: white
      stroke: "#1565C0"
      stroke-width: 2
    }
  }
  
  execute: Execute {
    shape: circle
    style: {
      fill: "#FF9800"
      font-color: white
      stroke: "#E65100"
      stroke-width: 2
    }
  }
  
  update: Update PC {
    shape: circle
    style: {
      fill: "#9C27B0"
      font-color: white
      stroke: "#7B1FA2"
      stroke-width: 2
    }
  }
  
  fetch -> decode: "read instr\nat PC" {
    style: {
      stroke-width: 2
      animated: true
    }
  }
  decode -> execute: "dispatch\nopcode" {
    style: {
      stroke-width: 2
      animated: true
    }
  }
  execute -> update: "apply\noperands" {
    style: {
      stroke-width: 2
      animated: true
    }
  }
  update -> fetch: "PC++\nor jump" {
    style: {
      stroke-width: 2
      animated: true
    }
  }
  
  halt_check: "Halt?" {
    shape: diamond
    style: {
      fill: "#F44336"
      font-color: white
    }
  }
  
  execute -> halt_check
  halt_check -> fetch: "No" {
    style.stroke: "#4CAF50"
  }
}

connections: {
  instruction_format -> opcode_categories.cursor_ops: "formats"
  opcode_categories.cursor_ops -> opcode_categories.data_ops
  opcode_categories.data_ops -> opcode_categories.result_ops
  opcode_categories.result_ops -> compare_ops
  compare_ops -> write_ops
  write_ops -> aggregate_ops
  
  register_model -> execution_cycle: "VM state"
}