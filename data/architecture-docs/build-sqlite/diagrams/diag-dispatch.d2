vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  instruction: {
    shape: rectangle
    style: {
      stroke-width: 2
      border-radius: 3
    }
  }
  memory_block: {
    style: {
      fill: "#f5f5f5"
      stroke: "#222222"
      stroke-dash: 2
    }
  }
  cpu_component: {
    style: {
      fill: "#e1f5fe"
      stroke: "#01579b"
      bold: true
    }
  }
  highlight: {
    style: {
      stroke: "#d32f2f"
      stroke-width: 4
      fill: "#ffcdd2"
    }
  }
}

# High-Level Context
vdbe_optimization: "VDBE DISPATCH OPTIMIZATION" {
  link: "#milestone-3"
  
  description: |md
    ### Switch vs. Computed Gotos
    In a register-based VM like SQLite, the time spent **dispatching** (deciding which code to run for the next opcode) can outweigh the actual work.
  |
}

# --- SCENARIO 1: THE SWITCH STATEMENT ---
switch_dispatch: "SCENARIO A: Standard Switch Loop (The Hub)" {
  style.fill: "#fff3e0"
  
  dispatch_loop: {
    label: "while(true) { switch(*pc++) { ... } }"
    class: cpu_component
    
    cases: {
      grid-columns: 1
      case_open: "case OP_OpenRead:"
      case_column: "case OP_Column:"
      case_next: "case OP_Next:"
    }
  }

  handlers: "Code Segment (Handlers)" {
    op_open: "OP_OpenRead Implementation" { class: instruction }
    op_col: "OP_Column Implementation" { class: instruction }
    op_nxt: "OP_Next Implementation" { class: instruction }
  }

  # All paths lead back to the center
  dispatch_loop.cases.case_open -> handlers.op_open: "Jump"
  handlers.op_open -> dispatch_loop: "Return to Loop (Bottleneck)"
  
  dispatch_loop.cases.case_column -> handlers.op_col: "Jump"
  handlers.op_col -> dispatch_loop: "Return to Loop"

  prediction_fail: "CPU Branch Predictor" {
    shape: diamond
    label: "Prediction Miss!"
    class: highlight
    tooltip: "CPU cannot guess the next branch because all opcodes converge here."
  }
  dispatch_loop -> prediction_fail: "Multiple targets"
}

# --- SCENARIO 2: COMPUTED GOTOS ---
computed_goto: "SCENARIO B: Computed Gotos (The Threaded Code)" {
  style.fill: "#e8f5e9"

  opcode_table: "Jump Table (Memory)" {
    shape: sql_table
    op_0: "0x00: &&L_OpenRead"
    op_1: "0x01: &&L_Column"
    op_2: "0x02: &&L_Next"
  }

  execution_flow: "Flattened Execution (No Central Loop)" {
    
    h1: "L_OpenRead:" {
      class: instruction
      logic: "/* do work */"
      jump: "goto *label_ptr[++pc];" { 
        style.font-color: green
        style.bold: true 
      }
    }

    h2: "L_Column:" {
      class: instruction
      logic: "/* do work */"
      jump: "goto *label_ptr[++pc];" {
        style.font-color: green
        style.bold: true
      }
    }

    h3: "L_Next:" {
      class: instruction
      logic: "/* do work */"
      jump: "goto *label_ptr[++pc];"
    }
  }

  opcode_table.op_0 -> execution_flow.h1: "Direct Dispatch"
  execution_flow.h1.jump -> execution_flow.h2: "Direct Threading"
  execution_flow.h2.jump -> execution_flow.h3: "Direct Threading"

  efficiency: "Predictor Success" {
    shape: cloud
    label: "BTB Warm"
    style.fill: "#c8e6c9"
    tooltip: "Branch Target Buffer remembers the unique jump target for each handler."
  }
  execution_flow.h1 -> efficiency
}

# --- MICROSCOPIC VIEW: CPU PIPELINE ---
cpu_view: "MICROSCOPIC: Instruction Pipeline" {
  near: bottom-center
  
  pipeline: {
    grid-columns: 4
    fetch: "Fetch" { class: cpu_component }
    decode: "Decode" { class: cpu_component }
    execute: "Execute" { class: cpu_component }
    wb: "Writeback" { class: cpu_component }
  }

  stall_view: "Impact of Switch (Branch Mispredict)" {
    fetch -> decode: "Bubble" {
      style: {
        stroke: red
        animated: true
      }
      label: "Pipeline Flush"
    }
  }

  goto_view: "Impact of Computed Goto" {
    fetch -> decode: "Prefetched" {
      style: {
        stroke: green
        stroke-dash: 3
      }
      label: "Linear Flow"
    }
  }
}

# Connections and annotations
switch_dispatch -> computed_goto: "OPTIMIZATION: Threaded Code" {
  style.stroke-width: 5
}

legend: {
  near: bottom-right
  switch_label: "Traditional Switch: O(1) jump but high branch penalty" {
    shape: text
  }
  goto_label: "Computed Goto: Direct jump, allows CPU to 'learn' the path" {
    shape: text
  }
}

vdbe_optimization.style.bold: true
vdbe_optimization.style.font-size: 25