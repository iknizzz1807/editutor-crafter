vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # GROUP BY: Hash Aggregation Execution
  `SELECT category, COUNT(*), SUM(price) FROM products GROUP BY category`
| {near: top-center}
direction: right
# Input Phase
input_phase: {
  label: "Phase 1: Input Stream"
  style.fill: "#E8F4FD"
  input_rows: {
    label: "Products Table\n(Scanning)"
    style.fill: "#F0F7FF"
    row1: |md
      `category: 'A'`
      `price: 10`
|
    row1.shape: text
    row2: |md
      `category: 'B'`
      `price: 20`
|
    row2.shape: text
    row3: |md
      `category: 'A'`
      `price: 30`
|
    row3.shape: text
    row4: |md
      `category: 'C'`
      `price: 15`
|
    row4.shape: text
    row5: |md
      `category: 'B'`
      `price: 25`
|
    row5.shape: text
  }
  flow_label: |md
    **Each row processed:**
    1. Extract GROUP BY key
    2. Hash lookup/create entry
    3. Update aggregate state
|
  flow_label.shape: text
  flow_label.near: bottom-center
}
# Hash Table Phase
hash_phase: {
  label: "Phase 2: Hash Table (In-Memory)"
  style.fill: "#FFF3E0"
  hash_function: {
    label: "Hash Function\nhash(category)"
    shape: diamond
    style.fill: "#FFE0B2"
  }
  buckets: {
    label: "Hash Buckets"
    style.fill: "#FFF8E1"
    bucket_a: {
      label: "Bucket: 'A' (hash=...)"
      style.fill: "#C8E6C9"
      entry_a: {
        label: "GroupEntry { key='A' }"
        style.fill: "#A5D6A7"
        state_a: {
          label: "AggregateState"
          style.fill: "#81C784"
          count_a: |md
            `count: 2`
            `(10->11->12)`
|
          count_a.shape: text
          sum_a: |md
            `sum: 40`
            `(0->10->40)`
|
          sum_a.shape: text
        }
      }
    }
    bucket_b: {
      label: "Bucket: 'B' (hash=...)"
      style.fill: "#C8E6C9"
      entry_b: {
        label: "GroupEntry { key='B' }"
        style.fill: "#A5D6A7"
        state_b: {
          label: "AggregateState"
          style.fill: "#81C784"
          count_b: |md
            `count: 2`
            `(0->1->2)`
|
          count_b.shape: text
          sum_b: |md
            `sum: 45`
            `(0->20->45)`
|
          sum_b.shape: text
        }
      }
    }
    bucket_c: {
      label: "Bucket: 'C' (hash=...)"
      style.fill: "#C8E6C9"
      entry_c: {
        label: "GroupEntry { key='C' }"
        style.fill: "#A5D6A7"
        state_c: {
          label: "AggregateState"
          style.fill: "#81C784"
          count_c: |md
            `count: 1`
            `(0->1)`
|
          count_c.shape: text
          sum_c: |md
            `sum: 15`
            `(0->15)`
|
          sum_c.shape: text
        }
      }
    }
  }
}
# Output Phase
output_phase: {
  label: "Phase 3: Finalize & Output"
  style.fill: "#F3E5F5"
  finalize: {
    label: "AggFinal:\nIterate Hash Table"
    shape: diamond
    style.fill: "#E1BEE7"
  }
  results: {
    label: "Result Rows"
    style.fill: "#F3E5F5"
    header: {
      label: "| category | COUNT | SUM |"
      shape: text
    }
    r1: |md
      `| 'A'      | 2     | 40  |`
|
    r1.shape: text
    r1.style.font: mono
    r2: |md
      `| 'B'      | 2     | 45  |`
|
    r2.shape: text
    r2.style.font: mono
    r3: |md
      `| 'C'      | 1     | 15  |`
|
    r3.shape: text
    r3.style.font: mono
  }
}
# Data Flow Connections
input_phase.input_rows.row1 -> hash_phase.hash_function: "category='A', price=10" {
  style.stroke: "#2196F3"
  style.stroke-width: 2
}
hash_phase.hash_function -> hash_phase.buckets.bucket_a.entry_a: "hash('A')" {
  style.stroke: "#4CAF50"
  style.stroke-width: 2
}
input_phase.input_rows.row2 -> hash_phase.hash_function: "Row 2" {
  style.stroke: "#2196F3"
  style.stroke-dash: 3
}
input_phase.input_rows.row3 -> hash_phase.hash_function: "Row 3" {
  style.stroke: "#2196F3"
  style.stroke-dash: 3
}
input_phase.input_rows.row4 -> hash_phase.hash_function: "Row 4" {
  style.stroke: "#2196F3"
  style.stroke-dash: 3
}
input_phase.input_rows.row5 -> hash_phase.hash_function: "Row 5" {
  style.stroke: "#2196F3"
  style.stroke-dash: 3
}
hash_phase.buckets.bucket_a -> output_phase.finalize: "" {
  style.stroke: "#9C27B0"
  style.stroke-width: 2
}
hash_phase.buckets.bucket_b -> output_phase.finalize: "" {
  style.stroke: "#9C27B0"
  style.stroke-width: 2
}
hash_phase.buckets.bucket_c -> output_phase.finalize: "" {
  style.stroke: "#9C27B0"
  style.stroke-width: 2
}
output_phase.finalize -> output_phase.results: "Emit Groups" {
  style.stroke: "#9C27B0"
  style.stroke-width: 2
  style.animated: true
}
# State Update Detail Box
state_detail: {
  label: "Aggregate State Update Logic"
  near: top-right
  style.fill: "#FAFAFA"
  style.stroke: "#BDBDBD"
  code: |c
    // For each input row:
    hash = hash_func(group_key)
    entry = hash_table.get_or_create(hash, group_key)
    // Update aggregates
    entry->count++;         // COUNT(*)
    entry->sum += row->value; // SUM(price)
    // AVG computed at finalize:
    // avg = entry->sum / entry->count
|
  code.shape: text
  code.style.font: mono
  code.style.font-size: 12
}
# Complexity Note
complexity: {
  label: "Complexity Analysis"
  near: bottom-right
  style.fill: "#E3F2FD"
  style.stroke: "#2196F3"
  note: |md
    **Time: O(N)** - Single pass through input
    **Space: O(K)** - K = number of distinct groups
    **Hash lookup: O(1)** average case
    **Finalize: O(K)** - One output per group
|
  note.shape: text
}
# Memory Warning
memory_note: {
  label: "Memory Consideration"
  near: bottom-center
  style.fill: "#FFEBEE"
  style.stroke: "#F44336"
  warning: |md
    If K (distinct groups) is very large, hash table 
    may not fit in memory. Production databases spill 
    to disk using external sorting or partitioning.
|
  warning.shape: text
  warning.style.font-size: 11
}