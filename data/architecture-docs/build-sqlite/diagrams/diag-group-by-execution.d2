vars: {
  d2-config: {
    layout-engine: elk
  }
}

title: GROUP BY Execution: Partitioning & Aggregation {
  near: top-center
  shape: text
  style: {
    font-size: 32
    bold: true
    underline: true
  }
}

# Color definitions via classes
classes: {
  data-row: {
    shape: rectangle
    style: {
      fill: "#E3F2FD"
      stroke: "#1976D2"
      stroke-width: 2
    }
  }
  operator: {
    shape: rectangle
    style: {
      fill: "#FFF3E0"
      stroke: "#F57C00"
      stroke-width: 3
      bold: true
    }
  }
  hash-bucket: {
    shape: rectangle
    style: {
      fill: "#F3E5F5"
      stroke: "#7B1FA2"
      stroke-width: 2
    }
  }
  accumulator: {
    shape: rectangle
    style: {
      fill: "#E8F5E9"
      stroke: "#388E3C"
      stroke-width: 2
      font: mono
    }
  }
  result-row: {
    shape: rectangle
    style: {
      fill: "#FFEBEE"
      stroke: "#D32F2F"
      stroke-width: 2
      bold: true
    }
  }
  filter: {
    shape: diamond
    style: {
      fill: "#FFECB3"
      stroke: "#FF8F00"
      stroke-width: 2
    }
  }
  rejected: {
    shape: rectangle
    style: {
      fill: "#FFEBEE"
      stroke: "#B71C1C"
      stroke-dash: 3
      opacity: 0.6
    }
  }
}

# Input rows flowing in
input_rows: {
  label: "Input Rows\n(WHERE filtered)"
  class: data-row
  
  row1: "(1, 'A', 100)" {class: data-row}
  row2: "(2, 'B', 50)" {class: data-row}
  row3: "(1, 'A', 200)" {class: data-row}
  row4: "(3, 'C', 75)" {class: data-row}
  row5: "(2, 'B', 25)" {class: data-row}
  row6: "(1, 'A', 150)" {class: data-row}
}

# GROUP BY operator
groupby: {
  label: "GROUP BY\ncustomer_id"
  class: operator
  width: 200
  height: 80
}

# Hash partitioning
hash_partition: {
  label: "Hash Partition\nby group key"
  class: operator
  
  hash_fn: "hash(customer_id) % 3"
}

# Hash buckets with accumulators
buckets: {
  label: "Aggregate State (per group)"
  
  bucket_A: {
    label: "Bucket: customer_id=1"
    class: hash-bucket
    
    key_A: "Key: 1" {
      style: {
        fill: "#7B1FA2"
        font-color: white
        bold: true
      }
    }
    
    count_A: "COUNT(*): 3\n(start: 0 → 1 → 2 → 3)" {
      class: accumulator
    }
    
    sum_A: "SUM(amount): 450\n(start: 0 → 100 → 300 → 450)" {
      class: accumulator
    }
  }
  
  bucket_B: {
    label: "Bucket: customer_id=2"
    class: hash-bucket
    
    key_B: "Key: 2" {
      style: {
        fill: "#7B1FA2"
        font-color: white
        bold: true
      }
    }
    
    count_B: "COUNT(*): 2\n(start: 0 → 1 → 2)" {
      class: accumulator
    }
    
    sum_B: "SUM(amount): 75\n(start: 0 → 50 → 75)" {
      class: accumulator
    }
  }
  
  bucket_C: {
    label: "Bucket: customer_id=3"
    class: hash-bucket
    
    key_C: "Key: 3" {
      style: {
        fill: "#7B1FA2"
        font-color: white
        bold: true
      }
    }
    
    count_C: "COUNT(*): 1\n(start: 0 → 1)" {
      class: accumulator
    }
    
    sum_C: "SUM(amount): 75\n(start: 0 → 75)" {
      class: accumulator
    }
  }
}

# Finalize step
finalize: {
  label: "Finalize\nAggregates"
  class: operator
}

# HAVING filter
having: {
  label: "HAVING\nSUM(amount) > 100"
  class: filter
}

# Output results
output: {
  label: "Result Rows"
  
  pass1: "(1, 3, 450)" {
    class: result-row
    label: "customer_id=1\nCOUNT=3, SUM=450\n✓ PASS"
  }
  
  pass2: "(2, 2, 75)" {
    class: rejected
    label: "customer_id=2\nCOUNT=2, SUM=75\n✗ FAIL (75 ≤ 100)"
  }
  
  pass3: "(3, 1, 75)" {
    class: rejected
    label: "customer_id=3\nCOUNT=1, SUM=75\n✗ FAIL (75 ≤ 100)"
  }
}

final_output: {
  label: "Final Output"
  
  out1: "1 | 3 | 450" {
    class: result-row
  }
}

# Flow connections
input_rows -> groupby: "stream" {
  style: {
    animated: true
    stroke: "#1976D2"
    stroke-width: 2
  }
}

groupby -> hash_partition: "partition" {
  style: {
    stroke: "#F57C00"
    stroke-width: 2
  }
}

hash_partition -> buckets.bucket_A: "hash=0" {
  style: {stroke: "#7B1FA2"}
}
hash_partition -> buckets.bucket_B: "hash=1" {
  style: {stroke: "#7B1FA2"}
}
hash_partition -> buckets.bucket_C: "hash=2" {
  style: {stroke: "#7B1FA2"}
}

buckets -> finalize: "emit groups" {
  style: {
    stroke: "#388E3C"
    stroke-width: 2
  }
}

finalize -> having: "evaluate\nper group" {
  style: {
    stroke: "#FF8F00"
    stroke-width: 2
  }
}

having -> output.pass1: "TRUE" {
  style: {
    stroke: "#388E3C"
    stroke-width: 3
    bold: true
  }
}

having -> output.pass2: "FALSE" {
  style: {
    stroke: "#B71C1C"
    stroke-dash: 3
  }
}

having -> output.pass3: "FALSE" {
  style: {
    stroke: "#B71C1C"
    stroke-dash: 3
  }
}

output.pass1 -> final_output.out1: "emit" {
  style: {
    stroke: "#D32F2F"
    stroke-width: 3
    animated: true
  }
}

# Legend
legend: {
  near: bottom-right
  
  leg1: "Input/Intermediate Data" {class: data-row}
  leg2: "Operator/Transform" {class: operator}
  leg3: "Hash Bucket" {class: hash-bucket}
  leg4: "Accumulator State" {class: accumulator}
  leg5: "Final Result" {class: result-row}
  leg6: "Rejected (HAVING)" {class: rejected}
}

# SQL Query reference
sql_query: |md
  sql
  SELECT customer_id, COUNT(*), SUM(amount)
  FROM orders
  GROUP BY customer_id
  HAVING SUM(amount) > 100;
  
| {
  near: bottom-left
  shape: rectangle
  style: {
    fill: "#FAFAFA"
    stroke: "#9E9E9E"
    font: mono
    font-size: 14
  }
}