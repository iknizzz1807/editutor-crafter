vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: Index Maintenance on INSERT {
  near: top-center
  shape: text
  style: {
    font-size: 32
    bold: true
    underline: true
  }
}

state_evolution: {
  label: State Evolution: INSERT with Index Maintenance
  
  initial: {
    label: "Initial State\n(Before INSERT)"
    style.fill: "#E8F5E9"
    style.stroke: "#4CAF50"
    
    table_btree_initial: {
      label: Table B-tree\n(page 2)
      style.fill: "#BBDEFB"
      style.stroke: "#1976D2"
      
      row1: "rowid=1: (Alice)"
      row2: "rowid=2: (Bob)"
    }
    
    index_btree_initial: {
      label: Index B+tree\n(email column)\n(page 5)
      style.fill: "#E1BEE7"
      style.stroke: "#7B1FA2"
      
      idx_entry1: "(alice@ex.com -> 1)"
      idx_entry2: "(bob@ex.com -> 2)"
    }
  }
  
  initial_arrow: {
    shape: text
    label: "INSERT (3, 'Charlie', 'charlie@ex.com')"
    style: {
      font-color: "#D32F2F"
      bold: true
    }
  }
  
  step1: {
    label: "Step 1: Insert into Table B-tree"
    style.fill: "#FFF3E0"
    style.stroke: "#FF9800"
    
    table_btree_step1: {
      label: Table B-tree\n(page 2)
      style.fill: "#BBDEFB"
      style.stroke: "#1976D2"
      
      row1_s1: "rowid=1: (Alice)"
      row2_s1: "rowid=2: (Bob)"
      row3_s1: {
        label: "rowid=3: (Charlie)"
        style.fill: "#4CAF50"
        style.font-color: white
        style.bold: true
      }
    }
    
    table_status: {
      label: "Table insert\nsuccessful"
      shape: text
      style: {
        font-color: "#4CAF50"
        bold: true
      }
    }
    
    index_pending: {
      label: Index B+tree\n(pending update)
      style.fill: "#FFECB3"
      style.stroke: "#FFA000"
      style.stroke-dash: 3
      
      idx_note: "Awaiting insert..."
    }
  }
  
  step2_success: {
    label: "Step 2a: Index Insert SUCCESS -> COMMIT"
    style.fill: "#E8F5E9"
    style.stroke: "#4CAF50"
    
    table_final_success: {
      label: Table B-tree\n(committed)
      style.fill: "#BBDEFB"
      style.stroke: "#1976D2"
      
      rows_final: "All rows persisted"
    }
    
    index_final_success: {
      label: Index B+tree\n(page 5)
      style.fill: "#E1BEE7"
      style.stroke: "#7B1FA2"
      
      idx1: "(alice@ex.com -> 1)"
      idx2: "(bob@ex.com -> 2)"
      idx3: {
        label: "(charlie@ex.com -> 3)"
        style.fill: "#4CAF50"
        style.font-color: white
        style.bold: true
      }
    }
    
    commit_status: {
      label: "TRANSACTION COMMITTED\nBoth structures updated atomically"
      shape: text
      style: {
        font-color: "#4CAF50"
        bold: true
      }
    }
  }
  
  step2_failure: {
    label: "Step 2b: Index Insert FAILS -> ROLLBACK"
    style.fill: "#FFEBEE"
    style.stroke: "#F44336"
    
    failure_reason: {
      label: "Failure Reason:\nUNIQUE constraint violation\n'charlie@ex.com' already exists"
      shape: text
      style: {
        font-color: "#F44336"
        bold: true
      }
    }
    
    rollback_action: {
      label: "ROLLBACK REQUIRED"
      style.fill: "#FFCDD2"
      style.stroke: "#F44336"
      
      rollback_arrow: "Delete rowid=3 from table"
      rollback_result: "Restore table to\ninitial state"
    }
    
    table_rolled_back: {
      label: Table B-tree\n(rolled back)
      style.fill: "#BBDEFB"
      style.stroke: "#1976D2"
      
      row1_rb: "rowid=1: (Alice)"
      row2_rb: "rowid=2: (Bob)"
      row3_rb: {
        label: "rowid=3: DELETED"
        style.fill: "#FFCDD2"
        style.stroke: "#F44336"
        style.stroke-dash: 3
        style.opacity: 0.4
      }
    }
    
    rollback_status: {
      label: "TRANSACTION ROLLED BACK\nNo partial state remains"
      shape: text
      style: {
        font-color: "#F44336"
        bold: true
      }
    }
  }
  
  initial -> step1: "1. Begin transaction"
  step1 -> step2_success: "2a. Index insert OK" {
    style.stroke: "#4CAF50"
    style.stroke-width: 3
  }
  step1 -> step2_failure: "2b. Index insert FAILS" {
    style.stroke: "#F44336"
    style.stroke-width: 3
  }
}

timing_diagram: {
  label: Timing Diagram: Index Maintenance Sequence
  
  timeline: {
    shape: sequence_diagram
    
    client
    tx_manager: "Transaction\nManager"
    table_btree: "Table\nB-tree"
    index_btree: "Index\nB+tree"
    journal: "Rollback\nJournal"
    
    start: {
      client -> tx_manager: "INSERT INTO users\nVALUES (3, 'Charlie',\n'charlie@ex.com')"
    }
    
    begin_phase: {
      tx_manager -> journal: "BEGIN TRANSACTION"
      tx_manager -> journal.t1: "Create journal file"
      journal.t1 -> tx_manager: "Journal ready"
    }
    
    table_phase: {
      tx_manager -> table_btree: "Insert rowid=3"
      table_btree -> journal.t2: "Log original\npage 2"
      journal.t2 -> table_btree: "Logged"
      table_btree -> tx_manager: "Insert successful"
    }
    
    index_phase: {
      tx_manager -> index_btree: "Insert\n('charlie@ex.com', 3)"
      index_btree -> tx_manager: {
        label: "SUCCESS\n(unique check passed)"
        style.stroke: "#4CAF50"
      }
    }
    
    commit_success: {
      tx_manager -> journal.t3: "fsync journal"
      journal.t3 -> tx_manager: "Durable"
      tx_manager -> table_btree.t2: "Mark pages dirty"
      tx_manager -> index_btree.t2: "Mark pages dirty"
      tx_manager -> journal.t4: "DELETE journal"
      tx_manager -> client: {
        label: "COMMIT successful"
        style.stroke: "#4CAF50"
        style.bold: true
      }
    }
  }
  
  failure_scenario: {
    label: "Failure Scenario Timing"
    
    failure_timeline: {
      shape: sequence_diagram
      
      client2: "Client"
      tx_mgr2: "Transaction\nManager"
      tbl2: "Table\nB-tree"
      idx2: "Index\nB+tree"
      jnl2: "Journal"
      
      fail_start: {
        client2 -> tx_mgr2: "INSERT with\nduplicate email"
      }
      
      fail_table: {
        tx_mgr2 -> tbl2: "Insert rowid=4"
        tbl2 -> jnl2: "Log page"
        tbl2 -> tx_mgr2: "OK"
      }
      
      fail_index: {
        tx_mgr2 -> idx2: "Insert\n(duplicate key)"
        idx2 -> tx_mgr2: {
          label: "UNIQUE constraint\nviolation!"
          style.stroke: "#F44336"
          style.bold: true
        }
      }
      
      fail_rollback: {
        tx_mgr2 -> tbl2.t2: "ROLLBACK:\nDelete rowid=4"
        tx_mgr2 -> jnl2.t2: "DELETE journal"
        tx_mgr2 -> client2: {
          label: "Error:\nUNIQUE constraint\nfailed"
          style.stroke: "#F44336"
          style.bold: true
        }
      }
    }
  }
}

critical_rules: {
  label: "Critical Rules for Index Maintenance"
  style.fill: "#FFF8E1"
  style.stroke: "#FF8F00"
  
  rule1: {
    shape: text
    label: |md
      **1. Insert Order Matters**
      - Always insert into table FIRST
      - Then insert into ALL indexes
      - Reason: Table insert may fail, no index work wasted
    |
  }
  
  rule2: {
    shape: text
    label: |md
      **2. Journal Before Modify**
      - Write original page to journal BEFORE any modification
      - This enables rollback on index failure
      - Without journaling, partial state corrupts database
    |
  }
  
  rule3: {
    shape: text
    label: |md
      **3. Atomic Multi-Structure Update**
      - Table + ALL indexes must succeed together
      - ANY failure -> rollback ALL changes
      - Partial updates leave database inconsistent
    |
  }
  
  rule4: {
    shape: text
    label: |md
      **4. Multiple Indexes = Multiple Points of Failure**
      - Table with N indexes has N+1 insert operations
      - Each index is a potential failure point
      - More indexes = slower writes, more rollback risk
    |
  }
}

performance: {
  label: "Performance Impact: Write Amplification"
  style.fill: "#E3F2FD"
  style.stroke: "#1565C0"
  
  perf_diagram: {
    label: ""
    
    single_insert: {
      label: "Single INSERT\nwith N indexes"
      
      ops: {
        label: "Operations Required"
        shape: sql_table
        op: "Operation"
        count: "Count"
      }
    }
    
    example: {
      label: "Example: Table with 5 indexes"
      
      calc: {
        shape: text
        label: |md
          INSERT requires:
          - 1 table B-tree modification
          - 5 index B+tree modifications
          - 6 page writes to journal
          - 2-3 fsync operations
          
          Total: ~15 disk operations
          (vs 2-3 without indexes)
        |
        style.font: mono
      }
    }
  }
}

recovery: {
  label: "Recovery Guarantee"
  style.fill: "#E8F5E9"
  style.stroke: "#388E3C"
  
  recovery_text: {
    shape: text
    label: |md
      **After ANY crash, the database is ALWAYS in a consistent state:**
      
      - **Before journal fsync**: Table unchanged, index unchanged
      - **After journal fsync, before table write**: Recovery restores from journal
      - **After table write, before index write**: Recovery restores from journal
      - **After index write, before commit**: Recovery restores from journal
      - **After commit (journal deleted)**: All changes persisted
      
      **The rollback journal ensures atomic multi-structure updates.**
    |
  }
}

state_evolution -> timing_diagram: "Temporal view"
timing_diagram -> critical_rules: "Enforced by"
critical_rules -> performance: "Causes"
performance -> recovery: "But guarantees"