vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: {
  label: "LRU Eviction: Data Walk Through"
  near: top-center
  shape: text
  style: {
    font-size: 32
    bold: true
    underline: true
  }
}

classes: {
  frame: {
    shape: rectangle
    style: {
      fill: "#E8F4E8"
      stroke: "#2E7D32"
      stroke-width: 2
    }
  }
  hot_frame: {
    shape: rectangle
    style: {
      fill: "#FFCDD2"
      stroke: "#C62828"
      stroke-width: 3
    }
  }
  cold_frame: {
    shape: rectangle
    style: {
      fill: "#BBDEFB"
      stroke: "#1565C0"
      stroke-width: 3
    }
  }
  pinned_frame: {
    shape: rectangle
    style: {
      fill: "#FFF9C4"
      stroke: "#F57F17"
      stroke-width: 2
      stroke-dash: 4
    }
  }
  process_box: {
    shape: rectangle
    style: {
      fill: "#F3E5F5"
      stroke: "#7B1FA2"
      stroke-width: 2
      border-radius: 8
    }
  }
  data_flow: {
    style: {
      stroke: "#1565C0"
      stroke-width: 2
      animated: true
    }
  }
  control_flow: {
    style: {
      stroke: "#C62828"
      stroke-width: 2
      stroke-dash: 3
    }
  }
}

step1: "Step 1: Page Request" {
  class: process_box
  
  request: {
    label: |md
      **VM requests Page 42**
      
      FetchPage(PageID{0, 42})
    |
    shape: rectangle
    style.fill: white
  }
  
  check_cache: {
    label: "Check Page Table\npageTable[42] ?"
    shape: diamond
    style.fill: white
  }
  
  hit_path: {
    label: "HIT\nPin & Return"
    shape: rectangle
    style: {
      fill: "#C8E6C9"
      stroke: "#2E7D32"
    }
  }
  
  miss_path: {
    label: "MISS\nProceed to Step 2"
    shape: rectangle
    style: {
      fill: "#FFCDD2"
      stroke: "#C62828"
    }
  }
  
  request -> check_cache
  check_cache -> hit_path: "Found"
  check_cache -> miss_path: "Not Found"
}

step2: "Step 2: Find Victim (LRU Scan)" {
  class: process_box
  
  explanation: |md
    **Scan all frames for eviction candidate:**
    - Skip pinned pages (PinCount > 0)
    - Skip empty frames (use immediately)
    - Select least recently used unpinned page
  |
  
  frame_table: {
    grid-columns: 5
    grid-gap: 4
    
    header_id: {
      label: "Frame"
      style.fill: "#CFD8DC"
      style.bold: true
    }
    header_page: {
      label: "PageID"
      style.fill: "#CFD8DC"
      style.bold: true
    }
    header_pin: {
      label: "PinCount"
      style.fill: "#CFD8DC"
      style.bold: true
    }
    header_dirty: {
      label: "Dirty"
      style.fill: "#CFD8DC"
      style.bold: true
    }
    header_access: {
      label: "LastAccess"
      style.fill: "#CFD8DC"
      style.bold: true
    }
    
    f0_id: "0" {class: pinned_frame}
    f0_page: "Page 5" {class: pinned_frame}
    f0_pin: "**2**"
    f0_pin.style.fill: "#FFF9C4"
    f0_dirty: "No"
    f0_access: "10:45:23"
    
    f1_id: "1" {class: hot_frame}
    f1_page: "Page 17" {class: hot_frame}
    f1_pin: "0"
    f1_dirty: "Yes"
    f1_access: "10:45:21"
    
    f2_id: "2" {class: cold_frame}
    f2_page: "Page 8" {class: cold_frame}
    f2_pin: "0"
    f2_dirty: "**Yes**"
    f2_dirty.style.fill: "#FFCDD2"
    f2_access: "**10:44:15**"
    f2_access.style.fill: "#BBDEFB"
    
    f3_id: "3" {class: pinned_frame}
    f3_page: "Page 12" {class: pinned_frame}
    f3_pin: "**1**"
    f3_pin.style.fill: "#FFF9C4"
    f3_dirty: "No"
    f3_access: "10:45:20"
  }
  
  lru_decision: {
    label: |md
      **Victim Selection Logic:**
      
      Frame 0: SKIP (PinCount=2 > 0)
      Frame 1: Candidate (LRU=10:45:21)
      Frame 2: BEST VICTIM (LRU=10:44:15)
      Frame 3: SKIP (PinCount=1 > 0)
      
      → Select Frame 2 (Page 8)
    |
    shape: rectangle
    style: {
      fill: "#BBDEFB"
      border-radius: 4
    }
  }
  
  frame_table -> lru_decision
}

step3: "Step 3: Write Dirty Page (If Needed)" {
  class: process_box
  
  dirty_check: {
    label: "victim.Dirty == true ?"
    shape: diamond
    style.fill: white
  }
  
  write_path: {
    label: |md
      **Write Page 8 to Disk**
      
      diskMgr.WritePage(
        PageID{0, 8},
        frames[2]
      )
      
      - 4KB write to offset 32768
      - Sync to ensure durability
    |
    shape: rectangle
    style: {
      fill: "#FFCDD2"
      stroke: "#C62828"
      border-radius: 4
    }
  }
  
  skip_write: {
    label: "Skip\n(Already clean)"
    shape: rectangle
    style.fill: "#E8F5E9"
  }
  
  continue_flow: {
    label: "Proceed to Step 4"
    shape: rectangle
    style.fill: "#E1BEE7"
  }
  
  dirty_check -> write_path: "Yes (Dirty)"
  dirty_check -> skip_write: "No (Clean)"
  write_path -> continue_flow
  skip_write -> continue_flow
}

step4: "Step 4: Load New Page from Disk" {
  class: process_box
  
  load_operation: {
    label: |md
      **Read Page 42 from Disk**
      
      diskMgr.ReadPage(
        PageID{0, 42},
        frames[2]
      )
      
      - 4KB read from offset 172032
      - Page data now in memory
    |
    shape: rectangle
    style: {
      fill: "#BBDEFB"
      stroke: "#1565C0"
      border-radius: 4
    }
  }
  
  disk_layout: {
    label: |md
      **Database File Layout (4KB pages)**
      
      Offset      Page
      ---------   ----
      0x000000    Page 0 (header)
      0x001000    Page 1 (schema)
      ...
      0x02A000    Page 42 ← READ FROM HERE
      ...
    |
    shape: rectangle
    style: {
      fill: "#FFF8E1"
      font: mono
    }
  }
  
  load_operation -> disk_layout
}

step5: "Step 5: Update Metadata & Page Table" {
  class: process_box
  
  before_after: {
    grid-columns: 2
    grid-gap: 16
    
    before: "BEFORE (Frame 2)" {
      shape: rectangle
      style: {
        fill: "#FFCDD2"
        stroke: "#C62828"
        stroke-width: 2
      }
      
      b_content: |md
        PageID:    {0, 8}
        PinCount:  0
        Dirty:     true
        LastAccess: 10:44:15
      |
    }
    
    after: "AFTER (Frame 2)" {
      shape: rectangle
      style: {
        fill: "#C8E6C9"
        stroke: "#2E7D32"
        stroke-width: 2
      }
      
      a_content: |md
        PageID:    {0, 42}
        PinCount:  1  ← Incremented
        Dirty:     false
        LastAccess: 10:45:25  ← NOW
      |
    }
  }
  
  page_table_update: {
    label: |md
      **Page Table Updates:**
      
      delete(pageTable, PageID{0, 8})
      pageTable[PageID{0, 42}] = 2
    |
    shape: rectangle
    style: {
      fill: "#E1BEE7"
      border-radius: 4
    }
  }
  
  before_after -> page_table_update
}

step6: "Step 6: Pin Count Prevents Mid-Operation Eviction" {
  class: process_box
  
  timeline: {
    label: "**B-Tree Operation Timeline:**"
    shape: text
  }
  
  operation_flow: {
    grid-columns: 1
    grid-gap: 8
    
    op1: {
      label: |md
        **1. Fetch Page 42** → PinCount = 1
        
        page := bufferPool.FetchPage(PageID{0, 42})
        // page.PinCount is now 1
        // Page 42 CANNOT be evicted
      |
      shape: rectangle
      style.fill: "#C8E6C9"
    }
    
    op2: {
      label: |md
        **2. Modify Page (B-Tree Insert)**
        
        // Safe: Page guaranteed resident during modification
        insertIntoNode(page, key, value)
        page.MarkDirty()
      |
      shape: rectangle
      style.fill: "#E3F2FD"
    }
    
    op3: {
      label: |md
        **3. Unpin When Complete** → PinCount = 0
        
        page.Unpin(true)
        // Now Page 42 CAN be evicted (if needed)
      |
      shape: rectangle
      style.fill: "#FFF9C4"
    }
  }
  
  protection_note: {
    label: |md
      **⚠️ Critical Safety Property:**
      
      A page with `PinCount > 0` is **never** selected as an eviction victim.
      This prevents use-after-free bugs where a page is modified after eviction.
    |
    shape: rectangle
    style: {
      fill: "#FFCDD2"
      stroke: "#C62828"
      stroke-width: 2
      border-radius: 8
    }
  }
  
  operation_flow -> protection_note
}

step1.miss_path -> step2: "Cache Miss\nFind Victim" {
  class: data_flow
}

step2.lru_decision -> step3.dirty_check: "Victim: Frame 2\n(Page 8, Dirty)" {
  class: data_flow
}

step3.continue_flow -> step4.load_operation: "Frame Ready" {
  class: data_flow
}

step4.load_operation -> step5.before_after: "Page Loaded" {
  class: data_flow
}

step5.page_table_update -> step6.operation_flow: "Return Page\nPinCount=1" {
  class: data_flow
}

legend: "Legend" {
  near: bottom-right
  style: {
    fill: "#FAFAFA"
    stroke: "#9E9E9E"
    border-radius: 8
  }
  
  grid-columns: 2
  grid-gap: 4
  
  l1: {label: "Pinned"; class: pinned_frame}
  l1_desc: "Cannot evict (PinCount>0)"
  
  l2: {label: "Hot"; class: hot_frame}
  l2_desc: "Recently accessed"
  
  l3: {label: "Cold (LRU)"; class: cold_frame}
  l3_desc: "Eviction candidate"
  
  l4: {
    label: ""
    shape: rectangle
    style.fill: "#FFCDD2"
  }
  l4_desc: "Dirty (needs write)"
}

metrics: "Performance Metrics" {
  near: bottom-left
  style: {
    fill: "#E8F5E9"
    stroke: "#2E7D32"
    border-radius: 8
  }
  
  content: ||md
    **Latency Breakdown:**
    
    | Operation | Time |
    |-----------|------|
    | Cache hit | ~100 ns |
    | LRU scan | ~10 μs (1000 frames) |
    | Dirty write | ~100 μs (SSD) |
    | Disk read | ~100 μs (SSD) |
    | **Total miss** | ~210 μs |
    
    **Hit Rate Impact:**
    - 99% hit rate → avg ~300 ns
    - 90% hit rate → avg ~21 μs
    - **Every 1% miss = 10x more I/O**
  ||
}