vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    outer: "#E8F4FD"
    inner: "#FFF3E0"
    match: "#C8E6C9"
    no_match: "#FFCDD2"
    arrow_match: "#2E7D32"
    arrow_no_match: "#C62828"
    timing: "#F3E5F5"
  }
}

title: |md
  # Nested Loop JOIN: O(n × m) Cross Product with Filter
| {near: top-center}

direction: right

section_concept: {
  label: "JOIN Algorithm Concept"
  
  concept_flow: {
    outer: "Outer Table\n(orders)" {
      style.fill: "${colors.outer}"
      style.stroke: "#1565C0"
    }
    
    inner: "Inner Table\n(customers)" {
      style.fill: "${colors.inner}"
      style.stroke: "#E65100"
    }
    
    filter: "ON Condition\nFilter" {
      shape: diamond
      style.fill: "#FFF9C4"
      style.stroke: "#F9A825"
    }
    
    output: "Matching\nRows" {
      style.fill: "${colors.match}"
      style.stroke: "${colors.arrow_match}"
    }
    
    outer -> inner: "For each row" {
      label: "× scan all"
      style.stroke-dash: 3
    }
    inner -> filter: "Compare" {
      label: " ON cond"
    }
    filter -> output: "Match" {
      label: " ✓"
      style.stroke: "${colors.arrow_match}"
    }
  }
  
  complexity: |md
    **Time Complexity: O(n × m)**
    - n = rows in outer table
    - m = rows in inner table
    - Every outer row scans ALL inner rows
  | {
    near: bottom-center
    style.fill: "${colors.timing}"
    style.stroke: "#7B1FA2"
  }
}

section_trace: {
  label: "Execution Trace: orders JOIN customers ON o.customer_id = c.id"
  
  outer_table: {
    label: "Outer Table: orders"
    style.fill: "${colors.outer}"
    
    o1: "Row 0\nid=1\ncust_id=100\n$50" {
      style.fill: "#BBDEFB"
      style.stroke: "#1565C0"
      style.bold: true
    }
    o2: "Row 1\nid=2\ncust_id=200\n$75" {
      style.fill: "#BBDEFB"
      style.stroke: "#1565C0"
    }
    o3: "Row 2\nid=3\ncust_id=100\n$30" {
      style.fill: "#BBDEFB"
      style.stroke: "#1565C0"
    }
  }
  
  inner_table: {
    label: "Inner Table: customers"
    style.fill: "${colors.inner}"
    
    c1: "Row 0\nid=100\nAlice" {
      style.fill: "#FFE0B2"
      style.stroke: "#E65100"
    }
    c2: "Row 1\nid=200\nBob" {
      style.fill: "#FFE0B2"
      style.stroke: "#E65100"
    }
    c3: "Row 2\nid=300\nCharlie" {
      style.fill: "#FFE0B2"
      style.stroke: "#E65100"
    }
  }
  
  comparisons: {
    label: "Comparisons Made"
    
    iter1: {
      label: "Iteration 1: o1 (cust_id=100)"
      style.fill: "#E3F2FD"
      
      c1_1: "o1 vs c1\n100=100\nMATCH" {
        style.fill: "${colors.match}"
        style.stroke: "${colors.arrow_match}"
      }
      c1_2: "o1 vs c2\n100!=200\nX" {
        style.fill: "${colors.no_match}"
        style.stroke: "${colors.arrow_no_match}"
      }
      c1_3: "o1 vs c3\n100!=300\nX" {
        style.fill: "${colors.no_match}"
        style.stroke: "${colors.arrow_no_match}"
      }
      
      c1_1 -> c1_2 -> c1_3
    }
    
    iter2: {
      label: "Iteration 2: o2 (cust_id=200)"
      style.fill: "#E3F2FD"
      
      c2_1: "o2 vs c1\n200!=100\nX" {
        style.fill: "${colors.no_match}"
        style.stroke: "${colors.arrow_no_match}"
      }
      c2_2: "o2 vs c2\n200=200\nMATCH" {
        style.fill: "${colors.match}"
        style.stroke: "${colors.arrow_match}"
      }
      c2_3: "o2 vs c3\n200!=300\nX" {
        style.fill: "${colors.no_match}"
        style.stroke: "${colors.arrow_no_match}"
      }
      
      c2_1 -> c2_2 -> c2_3
    }
    
    iter3: {
      label: "Iteration 3: o3 (cust_id=100)"
      style.fill: "#E3F2FD"
      
      c3_1: "o3 vs c1\n100=100\nMATCH" {
        style.fill: "${colors.match}"
        style.stroke: "${colors.arrow_match}"
      }
      c3_2: "o3 vs c2\n100!=200\nX" {
        style.fill: "${colors.no_match}"
        style.stroke: "${colors.arrow_no_match}"
      }
      c3_3: "o3 vs c3\n100!=300\nX" {
        style.fill: "${colors.no_match}"
        style.stroke: "${colors.arrow_no_match}"
      }
      
      c3_1 -> c3_2 -> c3_3
    }
    
    iter1 -> iter2 -> iter3
  }
  
  summary: {
    label: "Summary"
    style.fill: "#E8F5E9"
    
    total: "Total Comparisons: 3 x 3 = 9"
    matches: "Matches Found: 3"
    output: "Output Rows: (o1,c1), (o2,c2), (o3,c1)"
  }
  
  outer_table.o1 -> comparisons.iter1
  outer_table.o2 -> comparisons.iter2
  outer_table.o3 -> comparisons.iter3
  comparisons -> summary
}

section_timing: {
  label: "Performance Scaling"
  
  timing_table: {
    timing_header: {
      shape: rectangle
      label: ""
      style.fill: "#424242"
      style.font-color: white
      width: 500
    }
    
    small: {
      label: |md
        **Small Tables**
        - orders: 100 rows
        - customers: 50 rows
        - Comparisons: **5,000**
        - Time: ~5ms
      |
      style.fill: "${colors.match}"
    }
    
    medium: {
      label: |md
        **Medium Tables**
        - orders: 10,000 rows
        - customers: 1,000 rows
        - Comparisons: **10,000,000**
        - Time: ~500ms
      |
      style.fill: "#FFF9C4"
    }
    
    large: {
      label: |md
        **Large Tables**
        - orders: 1,000,000 rows
        - customers: 100,000 rows
        - Comparisons: **100,000,000,000**
        - Time: ~83 minutes!
      |
      style.fill: "${colors.no_match}"
    }
    
    grid-columns: 3
    small -> medium -> large
  }
  
  optimization: {
    label: "Optimization: Index on Join Column"
    
    before: {
      label: "Without Index"
      style.fill: "${colors.no_match}"
      
      b1: "Full scan\nO(m) per row"
      b2: "Total: O(n x m)"
      
      b1 -> b2
    }
    
    arrow: "->" {
      shape: text
      label: "=>"
      style.font-size: 40
    }
    
    after: {
      label: "With Index"
      style.fill: "${colors.match}"
      
      a1: "Index lookup\nO(log m) per row"
      a2: "Total: O(n x log m)"
      
      a1 -> a2
    }
    
    improvement: |md
      **10^8x faster** for large tables!
    | {
      style.fill: "#E8F5E9"
      style.stroke: "${colors.arrow_match}"
    }
    
    before -> arrow -> after
    after -> improvement
  }
}

section_code: {
  label: "Implementation"
  
  pseudocode: |go
    func NestedLoopJoin(outer, inner Table, onCondition) []Row {
        var results []Row
        
        // Outer loop: O(n)
        for _, outerRow := range outer.Scan() {
            // Inner loop: O(m)
            for _, innerRow := range inner.Scan() {
                // Evaluate join condition
                if onCondition(outerRow, innerRow) {
                    results = append(results, 
                        Concat(outerRow, innerRow))
                }
            }
        }
        
        return results
    }
  | {
    shape: rectangle
    style.fill: "#263238"
    style.font-color: "#ECEFF1"
    width: 450
  }
  
  key_point: {
    label: "Key Insight"
    style.fill: "#FFF3E0"
    style.stroke: "#E65100"
    style.double-border: true
    
    point: |md
      **The inner table is scanned in full for EVERY row of the outer table.**
      
      This is why indexes on join columns are critical:
      - Index on `customers.id` -> O(log m) lookup
      - Index on `orders.customer_id` -> enables merge join
      
      Without indexes, nested loop is the only option.
    |
  }
}

legend: {
  near: bottom-center
  style.fill: "#FAFAFA"
  style.stroke: "#BDBDBD"
  
  l1: "Match" {
    style.fill: "${colors.match}"
  }
  l2: "No Match" {
    style.fill: "${colors.no_match}"
  }
  l3: "Outer Row" {
    style.fill: "#BBDEFB"
  }
  l4: "Inner Row" {
    style.fill: "#FFE0B2"
  }
  
  grid-columns: 4
  grid-gap: 20
}