vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    header: "#E8E8E8"
    pointers: "#D4E5F7"
    free: "#FFF9E6"
    cells: "#E6F3E6"
    text: "#333333"
    annotation: "#666666"
    offset: "#999999"
  }
}
title: B-tree Page Format: Slotted Page (4096 bytes) {
  near: top-center
  shape: text
  style: {
    font-size: 28
    bold: true
  }
}
direction: right
offsets: {
  grid-rows: 9
  grid-columns: 1
  grid-gap: 0
  o0: "0" {
    style: {
      font: mono
      font-size: 14
      font-color: ${colors.offset}
      fill: transparent
      stroke: transparent
    }
  }
  o8: "8" {
    style: {
      font: mono
      font-size: 14
      font-color: ${colors.offset}
      fill: transparent
      stroke: transparent
    }
  }
  o24: "24" {
    style: {
      font: mono
      font-size: 14
      font-color: ${colors.offset}
      fill: transparent
      stroke: transparent
    }
  }
  o32: "32" {
    style: {
      font: mono
      font-size: 14
      font-color: ${colors.offset}
      fill: transparent
      stroke: transparent
    }
  }
  o40: "40" {
    style: {
      font: mono
      font-size: 14
      font-color: ${colors.offset}
      fill: transparent
      stroke: transparent
    }
  }
  o_mid: "..." {
    style: {
      font: mono
      font-size: 14
      font-color: ${colors.offset}
      fill: transparent
      stroke: transparent
    }
  }
  o3800: "3800" {
    style: {
      font: mono
      font-size: 14
      font-color: ${colors.offset}
      fill: transparent
      stroke: transparent
    }
  }
  o4092: "4092" {
    style: {
      font: mono
      font-size: 14
      font-color: ${colors.offset}
      fill: transparent
      stroke: transparent
    }
  }
  o4095: "4095" {
    style: {
      font: mono
      font-size: 14
      font-color: ${colors.offset}
      fill: transparent
      stroke: transparent
    }
  }
}
page: {
  label: ""
  width: 600
  style: {
    fill: white
    stroke: ${colors.text}
    stroke-width: 2
  }
  header: {
    label: |md
      ## Page Header
      **8 bytes** (leaf) / **12 bytes** (internal)
      - page_type (1): 0x0D=tbl_leaf, 0x05=tbl_int, 0x0A=idx_leaf, 0x02=idx_int
      - first_freeblock (2): Offset to first free block (0=none)
      - cell_count (2): Number of cells on page
      - cell_content_start (2): First byte of cell content area
      - fragmented_bytes (1): Bytes in fragmented free space
      - right_child (4): (internal only) Rightmost child page
    |
    width: 580
    height: 140
    style: {
      fill: ${colors.header}
      stroke: ${colors.annotation}
      stroke-width: 1
      font-size: 12
    }
  }
  pointers: {
    label: |md
      ## Cell Pointer Array
      Array of **2-byte big-endian offsets** pointing to each cell's location.
      ptr[0] → Cell 0 offset
      ptr[1] → Cell 1 offset
      ptr[2] → Cell 2 offset
      ...
      ptr[n-1] → Cell n-1 offset
      Grows **DOWNWARD** toward free space.
    |
    width: 580
    height: 120
    style: {
      fill: ${colors.pointers}
      stroke: ${colors.annotation}
      stroke-width: 1
    }
  }
  free_space: {
    label: |md
      ## Free Space
      Gap between cell pointers and cell content.
      - Grows as cells are deleted (fragmentation)
      - Shrinks as new cells/pointers added
      - `cell_content_start - (header + 2*cell_count)` = free bytes
    |
    width: 580
    height: 140
    style: {
      fill: ${colors.free}
      stroke: ${colors.annotation}
      stroke-width: 1
    }
  }
  cells: {
    label: |md
      ## Cell Content Area
      Actual cell data grows **UPWARD** from end.
      **Table Leaf Cell:**
      [payload_size:varint] [rowid:varint] [payload:bytes] [overflow_page:4bytes?]
      **Table Internal Cell:**
      [left_child:4bytes] [rowid:varint]
    |
    width: 580
    height: 160
    style: {
      fill: ${colors.cells}
      stroke: ${colors.annotation}
      stroke-width: 1
    }
  }
}
growth_down: {
  label: "Pointers grow ↓"
  width: 120
  style: {
    fill: transparent
    stroke: ${colors.annotation}
    font-size: 14
    stroke-width: 2
  }
}
growth_up: {
  label: "Cells grow ↑"
  width: 120
  style: {
    fill: transparent
    stroke: ${colors.annotation}
    font-size: 14
    stroke-width: 2
  }
}
collision: {
  label: |md
    **Collision Point**
    When `cell_content_start` reaches
    `header_size + 2 * cell_count`,
    the page is **FULL**.
    → Must split or redistribute
  |
  width: 180
  style: {
    fill: "#FFE6E6"
    stroke: "#CC0000"
    font-size: 11
  }
}
legend: {
  near: bottom-center
  grid-columns: 2
  grid-gap: 20
  ptr_legend: {
    label: "Cell Pointers: 2 bytes each\nGrow from header → middle"
    shape: rectangle
    width: 200
    style: {
      fill: ${colors.pointers}
      stroke: ${colors.annotation}
      font-size: 12
    }
  }
  cell_legend: {
    label: "Cell Content: Variable size\nGrow from end → middle"
    shape: rectangle
    width: 200
    style: {
      fill: ${colors.cells}
      stroke: ${colors.annotation}
      font-size: 12
    }
  }
}
insight: |md
  ### Key Insight: Bidirectional Growth
  This design enables **O(1) cell access** via the pointer array
  while supporting **variable-length cells** without fragmentation
  between cells. Insert adds pointer at array end, cell at content end.
| {
  near: top-right
  width: 250
  style: {
    fill: "#F0F8FF"
    stroke: "#4169E1"
    stroke-width: 2
    border-radius: 8
    font-size: 12
  }
}
offsets -- page {
  style: {
    stroke: transparent
  }
}
page.pointers -> growth_down: "grows toward"
page.cells -> growth_up: "grows toward"
page.free_space -> collision: "collision zone"