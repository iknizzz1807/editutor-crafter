vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    wrong: "#FF6B6B"
    correct: "#4ECDC4"
    neutral: "#95A5A6"
    highlight: "#F39C12"
  }
}
title: |md
  # Operator Precedence: Naive vs. Correct Parsing
  **Expression:** `NOT a = b AND c OR d`
| {near: top-center}
direction: right
# ============================================
# LEFT SIDE: WRONG - Naive Left-to-Right
# ============================================
WRONG: {
  label: "❌ Naive Left-to-Right\n(Parse Order)"
  style.fill: "${colors.wrong}"
  style.stroke: "#C0392B"
  style.font-color: white
  step1: {
    label: "Step 1: NOT a"
    style.fill: "#E74C3C"
    style.stroke: "#C0392B"
    style.font-color: white
  }
  step2: {
    label: "Step 2: (NOT a) = b"
    style.fill: "#E74C3C"
    style.stroke: "#C0392B"
    style.font-color: white
  }
  step3: {
    label: "Step 3: ((NOT a) = b) AND c"
    style.fill: "#E74C3C"
    style.stroke: "#C0392B"
    style.font-color: white
  }
  step4: {
    label: "Step 4: (((NOT a) = b) AND c) OR d\n= FINAL RESULT"
    style.fill: "#8B0000"
    style.stroke: "#5B0000"
    style.font-color: white
    style.bold: true
  }
  step1 -> step2 -> step3 -> step4
}
# ============================================
# RIGHT SIDE: CORRECT - Proper Precedence
# ============================================
CORRECT: {
  label: "✓ Correct Precedence\n(Priority-Based)"
  style.fill: "${colors.correct}"
  style.stroke: "#16A085"
  style.font-color: white
  # Highest precedence: NOT and comparison
  not_node: {
    label: "NOT\n(prec: 2)"
    style.fill: "#27AE60"
    style.stroke: "#1E8449"
    style.font-color: white
  }
  eq_node: {
    label: "a = b\n(prec: 3)"
    style.fill: "#2ECC71"
    style.stroke: "#27AE60"
    style.font-color: white
  }
  # Medium precedence: AND
  and_node: {
    label: "AND\n(prec: 1)"
    style.fill: "#1ABC9C"
    style.stroke: "#16A085"
    style.font-color: white
  }
  # Lowest precedence: OR
  or_node: {
    label: "OR\n(prec: 0)"
    style.fill: "#006666"
    style.stroke: "#004D4D"
    style.font-color: white
    style.bold: true
  }
  c_node: {
    label: "c"
    style.fill: "${colors.neutral}"
    style.stroke: "#7F8C8D"
  }
  d_node: {
    label: "d"
    style.fill: "${colors.neutral}"
    style.stroke: "#7F8C8D"
  }
  # Build correct tree structure
  eq_node -> not_node: "operand"
  not_node -> and_node: "left"
  c_node -> and_node: "right"
  and_node -> or_node: "left"
  d_node -> or_node: "right"
}
# ============================================
# CENTER: PRECEDENCE TABLE
# ============================================
PRECEDENCE_TABLE: ||md
  ## Precedence Levels
  (Higher = Tighter Binding)
  | Level | Operators | Assoc |
  |-------|-----------|-------|
  | 6 | `PRIMARY` | - |
  | 5 | `NOT`, unary `-` | Right |
  | 4 | `*`, `/`, `%` | Left |
  | 3 | `+`, `-` | Left |
  | 2 | `=`, `<`, `>`, `<=`, `>=`, `<>` | Left |
  | 1 | `AND` | Left |
  | 0 | `OR` | Left |
||
PRECEDENCE_TABLE.style.fill: "#2C3E50"
PRECEDENCE_TABLE.style.stroke: "#1A252F"
PRECEDENCE_TABLE.style.font-color: white
PRECEDENCE_TABLE.near: center-left
# ============================================
# BOTTOM: FINAL STRUCTURES COMPARISON
# ============================================
comparison: {
  direction: right
  wrong_tree: ||md
    ### Wrong AST (Flat)
    OR
    ├── AND
    │   ├── =
    │   │   ├── NOT
    │   │   │   └── a
    │   │   └── b
    │   └── c
    └── d
    Evaluates left-to-right
    ignoring precedence
||
  wrong_tree.style.fill: "${colors.wrong}"
  wrong_tree.style.stroke: "#C0392B"
  wrong_tree.style.font-color: white
  wrong_tree.style.opacity: "0.9"
  correct_tree: ||md
    ### Correct AST (Deep)
    OR
    ├── AND
    │   ├── NOT
    │   │   └── =
    │   │       ├── a
    │   │       └── b
    │   └── c
    └── d
    NOT deepest (highest prec)
    OR at root (lowest prec)
||
  correct_tree.style.fill: "${colors.correct}"
  correct_tree.style.stroke: "#16A085"
  correct_tree.style.font-color: white
  correct_tree.style.opacity: "0.9"
  semantic_diff: ||md
    ## Semantic Difference
    **Wrong:** `(NOT a) = b` first
    - Negates `a`, then compares
    **Correct:** `NOT (a = b)` first
    - Compares `a` and `b`, then negates
    These produce **different** boolean
    results for most inputs!
||
  semantic_diff.style.fill: "${colors.highlight}"
  semantic_diff.style.stroke: "#D68910"
  semantic_diff.style.font-color: white
  semantic_diff.style.bold: true
}
# ============================================
# CONNECTIONS
# ============================================
WRONG -> comparison.wrong_tree: "produces" {
  style.stroke: "${colors.wrong}"
  style.stroke-dash: 3
}
CORRECT -> comparison.correct_tree: "produces" {
  style.stroke: "${colors.correct}"
  style.stroke-dash: 3
}
# Legend
legend: ||md
  ### Key Insight
  **Precedence determines tree depth.**
  Higher precedence operators appear
  DEEPER in the AST (evaluated first).
  Parentheses `()` restart precedence
  parsing, overriding defaults.
||
legend.near: bottom-right
legend.style.fill: "#34495E"
legend.style.stroke: "#2C3E50"
legend.style.font-color: white