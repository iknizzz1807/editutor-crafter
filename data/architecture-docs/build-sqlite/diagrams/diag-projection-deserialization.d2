vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Column Projection: Finding the Right Field
  Variable-Length Record Deserialization
| {near: top-center}

direction: right

# Step 1: Serialized Record
record_container: {
  label: "Serialized Record\n(Variable-Length Encoding)"
  style.fill: "#E8E8E8"
  style.stroke: "#666666"
  
  header: {
    style.fill: "#D4B8E8"
    style.stroke: "#8B5CF6"
    label: "Header"
    
    size: "Size=15"
    t1: "Type[0]=6"
    t2: "Type[1]=19"
    t3: "Type[2]=0"
  }
  
  body: {
    style.fill: "#B8D4E8"
    style.stroke: "#3B82F6"
    label: "Body"
    
    col0: "Col0\n(8 bytes)\nINTEGER"
    col1: "Col1\n(6 bytes)\nTEXT"
    col2: "Col2\n(0 bytes)\nNULL"
  }
}

# Byte offset scale
offset_scale: {
  label: "Byte Offset Scale"
  style.fill: "transparent"
  style.stroke: "#999999"
  style.stroke-dash: 2
  
  off0: "0"
  off1: "8"
  off2: "14"
  off14: "14"
  
  off0 -> off1: "header\n(8b)"
  off1 -> off2: "col0\n(8b)"
  off2 -> off14: "col1\n(6b)"
}

offset_scale.off14 -> record_container.body.col2: "col2\n(0b)"

# Step 2: Type Code Lookup Table
type_table: {
  label: "Serial Type → Size Lookup"
  style.fill: "#FFF9E6"
  style.stroke: "#F59E0B"
  
  table_content: ||md
    | Type | Meaning | Bytes |
    |------|---------|-------|
    | 0    | NULL    | 0     |
    | 1    | INT8    | 1     |
    | 6    | INT64   | 8     |
    | 19   | TEXT(3) | 6     |
    | N≥13 | TEXT    | (N-13)/2 |
  ||
}

# Step 3: Projection Process
projection_process: {
  label: "Projection: SELECT col2 FROM table"
  style.fill: "#E8F5E8"
  style.stroke: "#10B981"
  
  step1: {
    label: "1. Read Header"
    style.fill: "#D4B8E8"
    
    h1: "Parse varint size"
    h2: "Read type codes"
    h3: "types = [6, 19, 0]"
  }
  
  step2: {
    label: "2. Calculate Offsets"
    style.fill: "#B8D4E8"
    
    o0: "col0 offset = 8 (after header)"
    o1: "col0 size = 8 (type 6)"
    o2: "col1 offset = 16"
    o3: "col1 size = 6 (type 19)"
    o4: "col2 offset = 22"
    o5: "col2 size = 0 (type 0)"
  }
  
  step3: {
    label: "3. Extract Column"
    style.fill: "#B8E8D4"
    
    skip: "Skip bytes 8-21"
    read: "Read bytes 22-21 (0 bytes)"
    result: "Result: NULL"
  }
}

# Connections showing data flow
record_container.header -> projection_process.step1: "read header"
type_table -> projection_process.step2: "lookup sizes"
projection_process.step1 -> projection_process.step2: "type codes"
projection_process.step2 -> projection_process.step3: "offsets"

# Complexity comparison
complexity_box: {
  style.fill: "#FFE4E4"
  style.stroke: "#EF4444"
  
  complexity_content: ||md
    **Why Not Array Indexing?**
    
    ❌ `row[2]` is NOT O(1)
    
    ✓ Must decode types[0], types[1] first
    ✓ Must sum sizes of preceding columns
    ✓ Projection is O(n) where n = column index
    
    **Example**: To read column 50, must first
    decode columns 0-49 to find byte offset
  ||
}

# Memory layout visualization
memory_layout: {
  label: "Memory Layout (hex)"
  style.fill: "#F0F0F0"
  style.font: "mono"
  
  hex: ||md
    Offset  Hex Data      Meaning
    ──────────────────────────────
    00-00   0F            Header size (15)
    01-01   06            Type[0] = INT64
    02-02   13            Type[1] = TEXT(3)
    03-03   00            Type[2] = NULL
    04-0B   00 00 00 2A   Col0 = 42
            00 00 00 00   
    0C-11   41 6C 69 63   Col1 = "Alice"
            65 00         
    12-12   (nothing)     Col2 = NULL
  ||
}

record_container -> memory_layout: "byte view"
memory_layout -> complexity_box: "demonstrates"

# Legend
legend: {
  style.fill: "transparent"
  near: bottom-right
  
  l1: {
    style.fill: "#D4B8E8"
    label: "Header (metadata)"
  }
  l2: {
    style.fill: "#B8D4E8"
    label: "Body (data)"
  }
  l3: {
    style.fill: "#B8E8D4"
    label: "Target column"
  }
}