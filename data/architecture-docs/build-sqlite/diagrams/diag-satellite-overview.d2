vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    frontend: "#E8F5E9"
    compiler: "#E3F2FD"
    execution: "#FFF3E0"
    storage: "#FCE4EC"
    durability: "#F3E5F5"
    accent-green: "#4CAF50"
    accent-blue: "#2196F3"
    accent-orange: "#FF9800"
    accent-red: "#F44336"
    accent-purple: "#9C27B0"
  }
}

title: |md
  # SQLite Architecture: The Complete System Map
| {near: top-center}

legend: {
  near: bottom-right
  legend_box: {
    shape: rectangle
    style.fill: white
    style.stroke: "#CCCCCC"
    
    leg_fe: "Frontend Layer" {style.fill: "${colors.frontend}"}
    leg_co: "Compilation Layer" {style.fill: "${colors.compiler}"}
    leg_ex: "Execution Layer" {style.fill: "${colors.execution}"}
    leg_st: "Storage Layer" {style.fill: "${colors.storage}"}
    leg_du: "Durability Layer" {style.fill: "${colors.durability}"}
  }
}

direction: down

# ==================== FRONTEND LAYER ====================
frontend_layer: "Frontend Layer (SQL Processing)" {
  style.fill: "${colors.frontend}"
  style.stroke: "${colors.accent-green}"
  link: "#build-sqlite-m1"
  
  sql_input: "SQL Input\n(Raw Query Text)" {
    shape: rectangle
    style.fill: white
    style.stroke: "${colors.accent-green}"
    style.bold: true
  }
  
  tokenizer: "Tokenizer\n(Lexical Analysis)" {
    shape: rectangle
    link: "#build-sqlite-m1"
    tooltip: "Character-by-character state machine\nConverts raw SQL into token stream"
  }
  
  token_stream: "Token Stream\n[KEYWORD, IDENTIFIER, OPERATOR, ...]" {
    shape: rectangle
    style.fill: "#F5F5F5"
    style.stroke-dash: 3
  }
  
  parser: "Parser\n(Syntax Analysis)" {
    shape: rectangle
    link: "#build-sqlite-m2"
    tooltip: "Recursive descent parser\nBuilds Abstract Syntax Tree"
  }
  
  ast: "AST\n(Abstract Syntax Tree)" {
    shape: rectangle
    style.fill: white
    style.stroke: "${colors.accent-green}"
    style.bold: true
    link: "#build-sqlite-m2"
  }
  
  sql_input -> tokenizer: "raw chars" {
    label: "SELECT * FROM users"
    style.stroke: "${colors.accent-green}"
  }
  
  tokenizer -> token_stream: "tokens" {
    label: "[KEYWORD('SELECT'), OPERATOR('*'), ...]"
    style.stroke: "${colors.accent-green}"
  }
  
  token_stream -> parser: "token array" {
    style.stroke: "${colors.accent-green}"
  }
  
  parser -> ast: "tree structure" {
    label: "SelectStatement\n├── Columns: [*]\n├── Table: users\n└── Where: nil"
    style.stroke: "${colors.accent-green}"
  }
}

# ==================== COMPILATION LAYER ====================
compiler_layer: "Compilation Layer (Bytecode Generation)" {
  style.fill: "${colors.compiler}"
  style.stroke: "${colors.accent-blue}"
  link: "#build-sqlite-m3"
  
  compiler: "Compiler\n(AST → Bytecode)" {
    shape: rectangle
    link: "#build-sqlite-m3"
    tooltip: "Depth-first AST traversal\nEmits VDBE opcodes"
  }
  
  query_planner: "Query Planner\n(Cost-Based Optimizer)" {
    shape: diamond
    link: "#build-sqlite-m8"
    tooltip: "Estimates I/O cost\nChooses index vs table scan"
  }
  
  bytecode: "Bytecode Program\n(VDBE Instructions)" {
    shape: rectangle
    style.fill: white
    style.stroke: "${colors.accent-blue}"
    style.bold: true
    link: "#build-sqlite-m3"
    
    bytecode_example: |md
      
      0: OpenTable  0 2 0
      1: Rewind     0 5 0
      2: Column     0 0 1
      3: ResultRow  1 1 0
      4: Next       0 2 0
      5: Halt       0 0 0
      
    |
  }
  
  ast -> compiler: "AST nodes" {
    style.stroke: "${colors.accent-blue}"
  }
  
  compiler <-> query_planner: "optimize" {
    style.stroke: "${colors.accent-blue}"
    style.stroke-dash: 5
  }
  
  compiler -> bytecode: "instruction array" {
    label: "opcode + operands"
    style.stroke: "${colors.accent-blue}"
  }
}

# ==================== EXECUTION LAYER ====================
execution_layer: "Execution Layer (Virtual Machine)" {
  style.fill: "${colors.execution}"
  style.stroke: "${colors.accent-orange}"
  link: "#build-sqlite-m3"
  
  vdbe: "VDBE\n(Virtual Database Engine)" {
    shape: rectangle
    style.fill: white
    style.stroke: "${colors.accent-orange}"
    style.bold: true
    link: "#build-sqlite-m3"
    tooltip: "Register-based VM\nFetch-decode-execute loop"
  }
  
  registers: "Register File\n[r0, r1, r2, ...]" {
    shape: rectangle
    style.fill: "#FFFDE7"
  }
  
  cursors: "Cursors\n[Table, Index]" {
    shape: rectangle
    style.fill: "#FFFDE7"
    link: "#build-sqlite-m6"
    tooltip: "B-tree traversal state\nPosition tracking"
  }
  
  bytecode -> vdbe: "program" {
    label: "execute"
    style.stroke: "${colors.accent-orange}"
  }
  
  vdbe -- registers: "R/W" {
    style.stroke: "${colors.accent-orange}"
    style.stroke-dash: 3
  }
  
  vdbe -- cursors: "navigate" {
    style.stroke: "${colors.accent-orange}"
    style.stroke-dash: 3
  }
}

# ==================== STORAGE LAYER ====================
storage_layer: "Storage Layer (Page-Based Persistence)" {
  style.fill: "${colors.storage}"
  style.stroke: "${colors.accent-red}"
  
  buffer_pool: "Buffer Pool\n(In-Memory Page Cache)" {
    shape: rectangle
    style.fill: white
    style.stroke: "${colors.accent-red}"
    style.bold: true
    link: "#build-sqlite-m4"
    tooltip: "LRU eviction\nPin/unpin lifecycle\nDirty page tracking"
  }
  
  page_table: "Page Table\n(page_id → frame)" {
    shape: rectangle
    style.fill: "#FFEBEE"
  }
  
  frames: "Frames\n[page data buffers]" {
    shape: rectangle
    style.fill: "#FFEBEE"
  }
  
  btree: "B-tree\n(Clustered Tables)" {
    shape: rectangle
    link: "#build-sqlite-m5"
    tooltip: "Table leaf/internal pages\nKey: rowid"
  }
  
  bplustree: "B+tree\n(Secondary Indexes)" {
    shape: rectangle
    link: "#build-sqlite-m7"
    tooltip: "Index leaf/internal pages\nKey: (column, rowid)\nLeaf pages linked"
  }
  
  disk: "Disk\n(Database File)" {
    shape: cylinder
    style.fill: "#ECEFF1"
    style.stroke: "#607D8B"
    link: "#build-sqlite-m5"
  }
  
  cursors -> btree: "traverse" {
    style.stroke: "${colors.accent-red}"
  }
  
  cursors -> bplustree: "seek" {
    style.stroke: "${colors.accent-red}"
  }
  
  btree -> buffer_pool: "fetch page" {
    label: "page request"
    style.stroke: "${colors.accent-red}"
  }
  
  bplustree -> buffer_pool: "fetch page" {
    style.stroke: "${colors.accent-red}"
  }
  
  buffer_pool -- page_table: "lookup" {
    style.stroke-dash: 3
  }
  
  buffer_pool -- frames: "store" {
    style.stroke-dash: 3
  }
  
  buffer_pool <-> disk: "read/write\n4KB pages" {
    style.stroke: "#607D8B"
    style.stroke-width: 2
  }
}

# ==================== DURABILITY LAYER ====================
durability_layer: "Durability Layer (ACID Transactions)" {
  style.fill: "${colors.durability}"
  style.stroke: "${colors.accent-purple}"
  link: "#build-sqlite-m9"
  
  tx_manager: "Transaction Manager\n(BEGIN/COMMIT/ROLLBACK)" {
    shape: rectangle
    link: "#build-sqlite-m9"
    tooltip: "Atomicity guarantee\nWrite ordering"
  }
  
  rollback_journal: "Rollback Journal\n(Original Page Images)" {
    shape: rectangle
    style.fill: white
    style.stroke: "${colors.accent-purple}"
    link: "#build-sqlite-m9"
    tooltip: "Before-images saved\nfsync before modify\nWriters block readers"
  }
  
  wal: "WAL\n(Write-Ahead Log)" {
    shape: rectangle
    style.fill: white
    style.stroke: "${colors.accent-purple}"
    link: "#build-sqlite-m10"
    tooltip: "Append-only frames\nCumulative checksum\nConcurrent readers"
  }
  
  wal_index: "WAL-Index\n(Shared Memory)" {
    shape: rectangle
    style.fill: "#F3E5F5"
    link: "#build-sqlite-m10"
    tooltip: "page → frame mapping\nSnapshot isolation"
  }
  
  checkpoint: "Checkpoint\n(Merge WAL → DB)" {
    shape: diamond
    link: "#build-sqlite-m10"
    tooltip: "Passive/Full/Truncate\nBlocked by old snapshots"
  }
  
  buffer_pool -> tx_manager: "before modify" {
    label: "intercept"
    style.stroke: "${colors.accent-purple}"
  }
  
  tx_manager -> rollback_journal: "write original" {
    label: "DELETE mode"
    style.stroke: "${colors.accent-purple}"
    style.stroke-dash: 5
  }
  
  tx_manager -> wal: "append frame" {
    label: "WAL mode"
    style.stroke: "${colors.accent-purple}"
  }
  
  wal -> wal_index: "update index" {
    style.stroke: "${colors.accent-purple}"
  }
  
  wal -> checkpoint: "frames ready" {
    style.stroke: "${colors.accent-purple}"
  }
  
  checkpoint -> disk: "write pages" {
    label: "merge back"
    style.stroke: "#607D8B"
  }
}

# ==================== LAYER CONNECTIONS ====================
frontend_layer.ast -> compiler_layer.compiler: "AST" {
  style.stroke: "#333333"
  style.stroke-width: 2
}

compiler_layer.bytecode -> execution_layer.vdbe: "program" {
  style.stroke: "#333333"
  style.stroke-width: 2
}

execution_layer.vdbe -> storage_layer.buffer_pool: "page requests" {
  style.stroke: "#333333"
  style.stroke-width: 2
}

# ==================== QUERY FEATURES ====================
features_layer: "Query Features (Milestone 11)" {
  style.fill: "#E0F7FA"
  style.stroke: "#00BCD4"
  link: "#build-sqlite-m11"
  
  aggregates: "Aggregates\nCOUNT, SUM, AVG, MIN, MAX" {
    shape: rectangle
    tooltip: "NULL handling\nState accumulation"
  }
  
  group_by: "GROUP BY\n(Partitioning)" {
    shape: rectangle
    tooltip: "Hash-based aggregation\nHAVING filter"
  }
  
  joins: "JOINs\n(Nested Loop)" {
    shape: rectangle
    tooltip: "Cross product + filter\nO(n*m) complexity"
  }
  
  aggregates -- group_by: {
    style.stroke-dash: 3
  }
  
  group_by -- joins: {
    style.stroke-dash: 3
  }
}

execution_layer.vdbe -> features_layer.aggregates: "compute" {
  style.stroke: "#00BCD4"
  style.stroke-dash: 3
}

features_layer.joins -> storage_layer.cursors: "multiple scans" {
  style.stroke: "#00BCD4"
  style.stroke-dash: 3
}

# ==================== ANNOTATIONS ====================
annotation_crash: |md
  **Crash Recovery Path:**
  1. Detect hot journal/WAL
  2. Validate checksums
  3. Replay or rollback
  4. Consistent state restored
| {
  near: bottom-left
  shape: text
  style.fill: "${colors.durability}"
  style.font-size: 12
}

annotation_flow: |md
  **Query Flow:**
  SQL → Tokens → AST → Bytecode → VM → B-tree → Pages
| {
  near: top-left
  shape: text
  style.font-size: 12
  style.fill: "${colors.frontend}"
}