vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    query-layer: "#E8F4FD"
    storage-layer: "#FEF3E2"
    disk-layer: "#E8F8E8"
    accent-blue: "#2E86AB"
    accent-orange: "#D97706"
    accent-green: "#059669"
    text-dark: "#1F2937"
    border-gray: "#D1D5DB"
  }
}
title: |md
  # SQLite Architecture: Satellite Map
  Complete system view from SQL input to durable disk storage
| {near: top-center}
direction: down
# === QUERY/API LAYER ===
query_layer: "Query/API Layer" {
  style: {
    fill: ${colors.query-layer}
    stroke: ${colors.accent-blue}
    stroke-width: 3
    font-color: ${colors.text-dark}
    border-radius: 12
  }
  annotation_query: |md
    **Query Layer**
    Transforms SQL text into
    executable bytecode
  | {
    shape: text
    style: {
      font-size: 11
      font-color: ${colors.accent-blue}
      italic: true
    }
  }
  sql_input: "SQL Input" {
    link: "#sql-tokenizer"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-blue}
      stroke-width: 2
      shadow: true
    }
  }
  tokenizer: "Tokenizer\n(Lexical Analysis)" {
    link: "#sql-tokenizer"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-blue}
      stroke-width: 2
      shadow: true
    }
    tooltip: "Finite State Machine: char stream → token stream"
  }
  parser: "Parser\n(AST Builder)" {
    link: "#sql-parser"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-blue}
      stroke-width: 2
      shadow: true
    }
    tooltip: "Recursive Descent + Precedence Climbing"
  }
  compiler: "Bytecode\nCompiler" {
    link: "#bytecode-compiler"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-blue}
      stroke-width: 2
      shadow: true
    }
    tooltip: "AST → VDBE bytecode instructions"
  }
  vdbe: "VDBE\n(Virtual Machine)" {
    link: "#bytecode-compiler"
    shape: rectangle
    style: {
      fill: "#DBEAFE"
      stroke: ${colors.accent-blue}
      stroke-width: 2
      shadow: true
    }
    tooltip: "Register-based bytecode interpreter"
  }
  sql_input -> tokenizer: "raw SQL\nstring" {
    style.stroke: ${colors.accent-blue}
    style.stroke-width: 2
  }
  tokenizer -> parser: "token\nstream" {
    style.stroke: ${colors.accent-blue}
    style.stroke-width: 2
  }
  parser -> compiler: "AST" {
    style.stroke: ${colors.accent-blue}
    style.stroke-width: 2
  }
  compiler -> vdbe: "bytecode\nprogram" {
    style.stroke: ${colors.accent-blue}
    style.stroke-width: 2
  }
}
# === STORAGE ENGINE LAYER ===
storage_layer: "Storage Engine Layer" {
  style: {
    fill: ${colors.storage-layer}
    stroke: ${colors.accent-orange}
    stroke-width: 3
    font-color: ${colors.text-dark}
    border-radius: 12
  }
  annotation_storage: |md
    **Storage Engine**
    Manages memory, indexes,
    and query optimization
  | {
    shape: text
    style: {
      font-size: 11
      font-color: ${colors.accent-orange}
      italic: true
    }
  }
  query_planner: "Query\nPlanner" {
    link: "#query-planner"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-orange}
      stroke-width: 2
      shadow: true
    }
    tooltip: "Cost-based optimization, join ordering"
  }
  buffer_pool: "Buffer Pool\nManager" {
    link: "#buffer-pool"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-orange}
      stroke-width: 2
      shadow: true
    }
    tooltip: "LRU cache, pin counts, dirty page tracking"
  }
  btree: "B-tree\nStorage" {
    link: "#btree-storage"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-orange}
      stroke-width: 2
      shadow: true
    }
    tooltip: "Slotted pages, varint encoding, splits"
  }
  indexes: "Secondary\nIndexes" {
    link: "#secondary-indexes"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-orange}
      stroke-width: 2
      shadow: true
    }
    tooltip: "B+tree indexes, double lookup pattern"
  }
  aggregates: "Aggregates\n& JOINs" {
    link: "#aggregates-joins"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-orange}
      stroke-width: 2
      shadow: true
    }
    tooltip: "Hash GROUP BY, nested loop JOIN"
  }
  query_planner -> buffer_pool: "page\nrequests" {
    style.stroke: ${colors.accent-orange}
    style.stroke-width: 2
  }
  buffer_pool -> btree: "page\naccess" {
    style.stroke: ${colors.accent-orange}
    style.stroke-width: 2
  }
  btree <-> indexes: "index\nmaintenance" {
    style.stroke: ${colors.accent-orange}
    style.stroke-width: 2
    style.stroke-dash: 3
  }
  btree -> aggregates: "row\ndata" {
    style.stroke: ${colors.accent-orange}
    style.stroke-width: 2
  }
}
# === DISK/RECOVERY LAYER ===
disk_layer: "Disk/Recovery Layer" {
  style: {
    fill: ${colors.disk-layer}
    stroke: ${colors.accent-green}
    stroke-width: 3
    font-color: ${colors.text-dark}
    border-radius: 12
  }
  annotation_disk: |md
    **Disk Layer**
    Durability through
    transaction logging
  | {
    shape: text
    style: {
      font-size: 11
      font-color: ${colors.accent-green}
      italic: true
    }
  }
  page_files: "Page Files\n(.db)" {
    link: "#disk-storage"
    shape: cylinder
    style: {
      fill: white
      stroke: ${colors.accent-green}
      stroke-width: 2
      shadow: true
    }
    tooltip: "4KB pages, B-tree structure"
  }
  journal: "Rollback\nJournal" {
    link: "#transactions"
    shape: cylinder
    style: {
      fill: white
      stroke: ${colors.accent-green}
      stroke-width: 2
      shadow: true
    }
    tooltip: "UNDO logging, atomicity guarantee"
  }
  wal: "Write-Ahead\nLog (WAL)" {
    link: "#wal-mode"
    shape: cylinder
    style: {
      fill: "#D1FAE5"
      stroke: ${colors.accent-green}
      stroke-width: 2
      shadow: true
    }
    tooltip: "REDO logging, concurrent readers"
  }
  sqlite_master: "sqlite_master\n(System Catalog)" {
    link: "#system-catalog"
    shape: rectangle
    style: {
      fill: white
      stroke: ${colors.accent-green}
      stroke-width: 2
      shadow: true
    }
    tooltip: "Schema metadata, root pages"
  }
  page_files <-> journal: "undo\nlogging" {
    style.stroke: ${colors.accent-green}
    style.stroke-width: 2
    style.stroke-dash: 3
  }
  page_files <-> wal: "redo\nlogging" {
    style.stroke: ${colors.accent-green}
    style.stroke-width: 2
    style.stroke-dash: 3
  }
  page_files -> sqlite_master: "schema\nlookup" {
    style.stroke: ${colors.accent-green}
    style.stroke-width: 2
  }
}
# === CROSS-LAYER CONNECTIONS ===
query_layer.vdbe -> storage_layer.query_planner: "execution\nplan" {
  style.stroke: "#6B7280"
  style.stroke-width: 2
  style.stroke-dash: 5
}
storage_layer.buffer_pool -> disk_layer.page_files: "disk\nI/O" {
  style.stroke: "#6B7280"
  style.stroke-width: 3
}
storage_layer.query_planner -> disk_layer.sqlite_master: "table\nlookup" {
  style.stroke: "#6B7280"
  style.stroke-width: 2
  style.stroke-dash: 5
}
# === LEGEND ===
legend: "Legend" {
  near: bottom-right
  style: {
    fill: white
    stroke: ${colors.border-gray}
    border-radius: 8
    shadow: true
  }
  item1: "Click any box to navigate\nto detailed documentation" {
    shape: text
    style.font-size: 12
  }
  item2: "─▶ Data flow" {
    shape: text
    style.font-size: 12
  }
  item3: "╌▶ Optional/alternative path" {
    shape: text
    style.font-size: 12
  }
}