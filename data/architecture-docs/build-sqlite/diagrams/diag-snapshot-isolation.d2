vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
title: |md
  # Snapshot Isolation: Concurrent Reader Views
  Each reader sees a consistent point-in-time snapshot
| {near: top-center}
direction: right
WAL_File: WAL File (Append-Only Log) {
  style.fill: "#E8E8E8"
  style.stroke: "#666666"
  header: Frame 0\n(Header) {
    style.fill: "#B8B8B8"
    width: 120
  }
  frame1: Frame 1\nPage 42\nT=100ms {
    style.fill: "#A8D5BA"
    width: 120
  }
  frame2: Frame 2\nPage 17\nT=150ms {
    style.fill: "#A8D5BA"
    width: 120
  }
  frame3: Frame 3\nPage 42\n(COMMIT)\nT=200ms {
    style.fill: "#7BC47F"
    width: 120
    style.bold: true
  }
  frame4: Frame 4\nPage 55\nT=250ms {
    style.fill: "#A8D5BA"
    width: 120
  }
  frame5: Frame 5\nPage 17\n(COMMIT)\nT=300ms {
    style.fill: "#7BC47F"
    width: 120
    style.bold: true
  }
  frame6: Frame 6\nPage 99\nT=350ms {
    style.fill: "#FFE4B5"
    width: 120
    style.stroke-dash: 3
  }
  header -> frame1 -> frame2 -> frame3 -> frame4 -> frame5 -> frame6: appends
}
Reader_A: Reader A (Started T=180ms) {
  style.fill: "#D4E6F1"
  style.stroke: "#2874A6"
  snapshot_a: Snapshot {
    style.fill: "#AED6F1"
    max_frame: "max_frame = Frame 2\n(end of T=150ms)"
    style.font: mono
  }
  visible_a: Visible Frames {
    style.fill: "#7FB3D5"
    v1: Frame 1 ✓
    v2: Frame 2 ✓
    style.stroke: "#2874A6"
  }
  invisible_a: Invisible to A {
    style.fill: "#F5B7B1"
    style.stroke: "#922B21"
    i1: Frame 3 (too new)
    i2: Frame 4 (too new)
    i3: Frame 5 (too new)
    i4: Frame 6 (too new)
  }
  snapshot_a -> visible_a: captures
  visible_a -> invisible_a: "ignores\n(newer)"
}
Reader_B: Reader B (Started T=280ms) {
  style.fill: "#D5F5E3"
  style.stroke: "#1E8449"
  snapshot_b: Snapshot {
    style.fill: "#ABEBC6"
    max_frame: "max_frame = Frame 5\n(end of T=300ms)"
    style.font: mono
  }
  visible_b: Visible Frames {
    style.fill: "#58D68D"
    w1: Frame 1 ✓
    w2: Frame 2 ✓
    w3: Frame 3 ✓
    w4: Frame 4 ✓
    w5: Frame 5 ✓
    style.stroke: "#1E8449"
  }
  invisible_b: Invisible to B {
    style.fill: "#F5B7B1"
    style.stroke: "#922B21"
    x1: Frame 6 (uncommitted)
  }
  snapshot_b -> visible_b: captures
  visible_b -> invisible_b: "ignores\n(uncommitted)"
}
WAL_File.frame2 -> Reader_A.snapshot_a: "A starts here\n(snapshot=Frame2)" {
  style.stroke: "#2874A6"
  style.stroke-width: 2
  style.animated: true
}
WAL_File.frame5 -> Reader_B.snapshot_b: "B starts here\n(snapshot=Frame5)" {
  style.stroke: "#1E8449"
  style.stroke-width: 2
  style.animated: true
}
Reader_A -> Reader_B: "Both readers\nconcurrent\n(no blocking)" {
  style.stroke: "#888888"
  style.stroke-dash: 3
}
legend: {
  near: bottom-center
  style.fill: transparent
  committed: Committed Transaction {
    style.fill: "#7BC47F"
    width: 100
  }
  written: Written Frame {
    style.fill: "#A8D5BA"
    width: 100
  }
  uncommitted: Uncommitted (In Progress) {
    style.fill: "#FFE4B5"
    width: 100
    style.stroke-dash: 3
  }
  committed -> written -> uncommitted
}
explanation: |md
  ### How Snapshot Isolation Works
  1. **Reader starts**: Captures `max_frame` = current last committed frame
  2. **Page read**: Check WAL index for frame ≤ `max_frame`
  3. **Found**: Read from WAL at that frame offset
  4. **Not found**: Read from main database file
  **Key insight**: Writer appends to WAL while readers use their 
  captured snapshot. Neither blocks the other.
| {near: bottom-right}