vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: SQLite Varint Encoding {
  near: top-center
  style: {
    font-size: 36
    bold: true
    underline: true
  }
}

subtitle: Variable-Length Integer Format (1-9 bytes) {
  near: top-center
  style: {
    font-size: 18
    italic: true
    font-color: "#666666"
  }
}

legend: {
  near: top-right
  style.fill: "#f8f8f8"
  style.stroke: "#cccccc"
  style.border-radius: 8
  
  legend_title: Bit Pattern Key {
    style.bold: true
  }
  
  continuation: |md
    `1xxx xxxx` - More bytes follow
    `0xxx xxxx` - Final byte (or single byte)
    High bits indicate continuation count
  |
}

encoding_rules: {
  label: "Encoding Rules by Value Range"
  style.fill: "#e8f4f8"
  style.stroke: "#2196F3"
  style.border-radius: 8
  
  header: {
    grid-columns: 3
    grid-gap: 0
    
    h_range: "Value Range" {
      style.fill: "#1976D2"
      style.font-color: white
      style.bold: true
    }
    h_bytes: "Bytes" {
      style.fill: "#1976D2"
      style.font-color: white
      style.bold: true
    }
    h_pattern: "High-Bit Pattern" {
      style.fill: "#1976D2"
      style.font-color: white
      style.bold: true
    }
  }
  
  rows: {
    grid-columns: 3
    grid-gap: 0
    
    r1_range: "0 - 127"
    r1_bytes: "1"
    r1_pattern: "`0xxxxxxx`"
    
    r2_range: "128 - 16,383"
    r2_bytes: "2"
    r2_pattern: "`10xxxxxx xxxxxxxx`"
    
    r3_range: "16,384 - 2,097,151"
    r3_bytes: "3"
    r3_pattern: "`110xxxxx ...`"
    
    r4_range: "2,097,152 - 268,435,455"
    r4_bytes: "4"
    r4_pattern: "`1110xxxx ...`"
    
    r5_range: "Up to 2^35-1"
    r5_bytes: "5"
    r5_pattern: "`11110xxx ...`"
    
    r6_range: "Up to 2^42-1"
    r6_bytes: "6"
    r6_pattern: "`111110xx ...`"
    
    r7_range: "Up to 2^49-1"
    r7_bytes: "7"
    r7_pattern: "`1111110x ...`"
    
    r8_range: "Up to 2^56-1"
    r8_bytes: "8"
    r8_pattern: "`11111110 ...`"
    
    r9_range: "Any 64-bit (incl. negative)"
    r9_bytes: "9"
    r9_pattern: "`11111111` + 8 raw bytes"
  }
}

example_1: {
  label: "Example 1: Value = 42 (Single Byte)"
  style.fill: "#e8f5e9"
  style.stroke: "#4CAF50"
  style.border-radius: 8
  
  value_info: {
    grid-columns: 2
    
    v_label: "Decimal Value:" {
      style.bold: true
    }
    v_val: "42"
    
    b_label: "Binary:" {
      style.bold: true
    }
    b_val: "`0010 1010`"
  }
  
  encoded_1: {
    label: "Encoded Byte"
    style.fill: "#c8e6c9"
    style.border-radius: 4
    
    byte_layout: {
      grid-columns: 8
      grid-gap: 0
      
      b0: "0" {
        style.fill: "#81C784"
        style.font-color: white
        style.bold: true
      }
      b1: "0" {
        style.fill: "#A5D6A7"
      }
      b2: "1" {
        style.fill: "#A5D6A7"
      }
      b3: "0" {
        style.fill: "#A5D6A7"
      }
      b4: "1" {
        style.fill: "#A5D6A7"
      }
      b5: "0" {
        style.fill: "#A5D6A7"
      }
      b6: "1" {
        style.fill: "#A5D6A7"
      }
      b7: "0" {
        style.fill: "#A5D6A7"
      }
    }
    
    bit_labels: {
      grid-columns: 8
      grid-gap: 0
      
      l0: "STOP" {
        style.font-size: 10
        style.fill: "#81C784"
        style.bold: true
      }
      l1: "payload..." {
        style.font-size: 10
      }
    }
  }
  
  explanation_1: |md
    - High bit = `0` -> **Final byte** (no continuation)
    - Remaining 7 bits encode the value directly
    - Total: **1 byte** (same as raw value for small ints)
  |
}

example_2: {
  label: "Example 2: Value = 300 (Two Bytes)"
  style.fill: "#fff3e0"
  style.stroke: "#FF9800"
  style.border-radius: 8
  
  value_info_2: {
    grid-columns: 2
    
    v2_label: "Decimal Value:" {
      style.bold: true
    }
    v2_val: "300"
    
    b2_label: "Binary (9 bits):" {
      style.bold: true
    }
    b2_val: "`1 0010 1100`"
  }
  
  encoded_2: {
    label: "Encoded Bytes"
    style.fill: "#ffe0b2"
    style.border-radius: 4
    
    byte1: {
      label: "Byte 1 (continuation)"
      style.fill: "#ffcc80"
      style.border-radius: 4
      
      b1_layout: {
        grid-columns: 8
        grid-gap: 0
        
        b1_0: "1" {
          style.fill: "#F57C00"
          style.font-color: white
          style.bold: true
        }
        b1_1: "0" {
          style.fill: "#FFB74D"
        }
        b1_2: "0" {
          style.fill: "#FFB74D"
        }
        b1_3: "0" {
          style.fill: "#FFB74D"
        }
        b1_4: "0" {
          style.fill: "#FFB74D"
        }
        b1_5: "0" {
          style.fill: "#FFB74D"
        }
        b1_6: "0" {
          style.fill: "#FFB74D"
        }
        b1_7: "1" {
          style.fill: "#FFB74D"
        }
      }
      
      b1_labels: {
        grid-columns: 8
        grid-gap: 0
        
        bl1_0: "CONT" {
          style.font-size: 10
          style.fill: "#F57C00"
          style.font-color: white
          style.bold: true
        }
        bl1_1: "6 bits" {
          style.font-size: 10
        }
      }
    }
    
    byte2: {
      label: "Byte 2 (final)"
      style.fill: "#c8e6c9"
      style.border-radius: 4
      
      b2_layout: {
        grid-columns: 8
        grid-gap: 0
        
        b2_0: "0" {
          style.fill: "#81C784"
          style.font-color: white
          style.bold: true
        }
        b2_1: "0" {
          style.fill: "#A5D6A7"
        }
        b2_2: "1" {
          style.fill: "#A5D6A7"
        }
        b2_3: "0" {
          style.fill: "#A5D6A7"
        }
        b2_4: "1" {
          style.fill: "#A5D6A7"
        }
        b2_5: "1" {
          style.fill: "#A5D6A7"
        }
        b2_6: "0" {
          style.fill: "#A5D6A7"
        }
        b2_7: "0" {
          style.fill: "#A5D6A7"
        }
      }
      
      b2_labels: {
        grid-columns: 8
        grid-gap: 0
        
        bl2_0: "STOP" {
          style.font-size: 10
          style.fill: "#81C784"
          style.font-color: white
          style.bold: true
        }
        bl2_1: "7 bits" {
          style.font-size: 10
        }
      }
    }
  }
  
  arrow_1: (example_2.encoded_2.byte1 -> example_2.encoded_2.byte2): "next byte" {
    style.stroke: "#666666"
    style.stroke-dash: 3
  }
  
  calc_2: {
    label: "Decoding Calculation"
    style.fill: "#fff8e1"
    style.border-radius: 4
    
    calc_text: |md
      Byte 1: 0b10000001 -> High bit=1 (continue), payload = 000001
      Byte 2: 0b00101100 -> High bit=0 (stop), payload = 0101100
      
      Result = (000001 << 7) | 0101100
             = (1 << 7) | 44
             = 128 + 44
             = 300
    |
  }
  
  explanation_2: |md
    - High bit = `1` in byte 1 -> **More bytes follow**
    - High bit = `0` in byte 2 -> **Final byte**
    - Payload bits are concatenated: `(byte1 & 0x3F) << 7 | (byte2 & 0x7F)`
    - Total: **2 bytes** (saves space vs 4-byte fixed int)
  |
}

example_3: {
  label: "Example 3: Value = 16,384 (Three Bytes)"
  style.fill: "#fce4ec"
  style.stroke: "#E91E63"
  style.border-radius: 8
  
  value_info_3: {
    grid-columns: 2
    
    v3_label: "Decimal Value:" {
      style.bold: true
    }
    v3_val: "16,384"
    
    b3_label: "Binary (15 bits):" {
      style.bold: true
    }
    b3_val: "`100 0000 0000 0000`"
  }
  
  encoded_3: {
    label: "Encoded Bytes"
    style.fill: "#f8bbd9"
    style.border-radius: 4
    
    byte1_3: {
      label: "Byte 1"
      style.fill: "#f48fb1"
      style.border-radius: 4
      
      b13_layout: {
        grid-columns: 8
        grid-gap: 0
        
        b13_0: "1" {
          style.fill: "#C2185B"
          style.font-color: white
          style.bold: true
        }
        b13_1: "1" {
          style.fill: "#C2185B"
          style.font-color: white
          style.bold: true
        }
        b13_2: "0" {
          style.fill: "#EC407A"
        }
        b13_3: "0" {
          style.fill: "#EC407A"
        }
        b13_4: "0" {
          style.fill: "#EC407A"
        }
        b13_5: "0" {
          style.fill: "#EC407A"
        }
        b13_6: "0" {
          style.fill: "#EC407A"
        }
        b13_7: "0" {
          style.fill: "#EC407A"
        }
      }
      
      b13_labels: {
        grid-columns: 8
        grid-gap: 0
        
        bl13_0: "2-bit" {
          style.font-size: 9
          style.fill: "#C2185B"
          style.font-color: white
        }
        bl13_1: "header" {
          style.font-size: 9
          style.fill: "#C2185B"
          style.font-color: white
        }
      }
    }
    
    byte2_3: {
      label: "Byte 2"
      style.fill: "#ffcc80"
      style.border-radius: 4
      
      b23_layout: {
        grid-columns: 8
        grid-gap: 0
        
        b23_0: "0" {
          style.fill: "#81C784"
          style.font-color: white
          style.bold: true
        }
        b23_1: "0" {
          style.fill: "#A5D6A7"
        }
        b23_2: "0" {
          style.fill: "#A5D6A7"
        }
        b23_3: "0" {
          style.fill: "#A5D6A7"
        }
        b23_4: "0" {
          style.fill: "#A5D6A7"
        }
        b23_5: "0" {
          style.fill: "#A5D6A7"
        }
        b23_6: "0" {
          style.fill: "#A5D6A7"
        }
        b23_7: "0" {
          style.fill: "#A5D6A7"
        }
      }
      
      b23_labels: {
        grid-columns: 8
        grid-gap: 0
        
        bl23_0: "STOP" {
          style.font-size: 10
          style.fill: "#81C784"
          style.font-color: white
          style.bold: true
        }
      }
    }
    
    byte3_3: {
      label: "Byte 3"
      style.fill: "#ffcc80"
      style.border-radius: 4
      
      b33_layout: {
        grid-columns: 8
        grid-gap: 0
        
        b33_0: "0" {
          style.fill: "#81C784"
          style.font-color: white
          style.bold: true
        }
        b33_1: "0" {
          style.fill: "#A5D6A7"
        }
        b33_2: "0" {
          style.fill: "#A5D6A7"
        }
        b33_3: "0" {
          style.fill: "#A5D6A7"
        }
        b33_4: "0" {
          style.fill: "#A5D6A7"
        }
        b33_5: "0" {
          style.fill: "#A5D6A7"
        }
        b33_6: "0" {
          style.fill: "#A5D6A7"
        }
        b33_7: "0" {
          style.fill: "#A5D6A7"
        }
      }
      
      b33_labels: {
        grid-columns: 8
        grid-gap: 0
        
        bl33_0: "STOP" {
          style.font-size: 10
          style.fill: "#81C784"
          style.font-color: white
          style.bold: true
        }
      }
    }
  }
  
  explanation_3: |md
    - High bits = `11` -> **3-byte encoding** (2 continuation bytes)
    - This example hits the boundary: 16,384 = 2^14
    - Requires 14 payload bits, split across bytes
    - Total: **3 bytes** (still better than 4-byte fixed int)
  |
}

continuation_pattern: {
  label: "High-Bit Continuation Pattern"
  style.fill: "#e3f2fd"
  style.stroke: "#2196F3"
  style.border-radius: 8
  
  pattern_table: {
    grid-columns: 2
    grid-gap: 0
    
    p_header: "Pattern" {
      style.fill: "#1976D2"
      style.font-color: white
      style.bold: true
    }
    m_header: "Meaning" {
      style.fill: "#1976D2"
      style.font-color: white
      style.bold: true
    }
    
    p1: "`0xxxxxxx`"
    m1: "Single byte (0-127)"
    
    p2: "`10xxxxxx`"
    m2: "2-byte sequence starts"
    
    p3: "`110xxxxx`"
    m3: "3-byte sequence starts"
    
    p4: "`1110xxxx`"
    m4: "4-byte sequence starts"
    
    p5: "`11110xxx`"
    m5: "5-byte sequence starts"
    
    p6: "`111110xx`"
    m6: "6-byte sequence starts"
    
    p7: "`1111110x`"
    m7: "7-byte sequence starts"
    
    p8: "`11111110`"
    m8: "8-byte sequence (raw 64-bit follows)"
    
    p9: "`11111111`"
    m9: "9-byte sequence (reserved for large/special)"
  }
}

size_comparison: {
  label: "Space Efficiency Comparison"
  style.fill: "#f3e5f5"
  style.stroke: "#9C27B0"
  style.border-radius: 8
  
  comparison_text: |md
    | Value Range | Fixed Int | Varint | Savings |
    |-------------|-----------|--------|---------|
    | 0-127 | 4 bytes | 1 byte | **75%** |
    | 128-16,383 | 4 bytes | 2 bytes | **50%** |
    | 16,384-2M | 4 bytes | 3 bytes | **25%** |
    | 2M-268M | 4 bytes | 4 bytes | 0% |
    | > 268M | 4 bytes | 5-9 bytes | overhead |
  |
}

algorithm: {
  label: "Encoding Algorithm (Pseudocode)"
  style.fill: "#fafafa"
  style.stroke: "#9E9E9E"
  style.border-radius: 8
  style.font: mono
  
  algo_text: |go
    func EncodeVarint(value int64) []byte {
        if value < 0 {
            return append([]byte{0xFF}, int64ToBytes(value)...)
        }
        if value < 0x80 {
            return []byte{byte(value)}
        }
        if value < 0x4000 {
            return []byte{
                0x80 | byte(value >> 7),
                byte(value & 0x7F),
            }
        }
        return nil
    }
  |
}

decoding: {
  label: "Decoding Algorithm (Pseudocode)"
  style.fill: "#fafafa"
  style.stroke: "#9E9E9E"
  style.border-radius: 8
  style.font: mono
  
  decode_text: |go
    func DecodeVarint(data []byte, offset int) (int64, int) {
        first := data[offset]
        if first < 0x80 {
            return int64(first), 1
        }
        if first < 0xC0 {
            return int64(first&0x3F) << 7 |
                   int64(data[offset+1]&0x7F), 2
        }
        if first < 0xE0 {
            // 3-byte decode
        }
        if first == 0xFF {
            return bytesToInt64(data[offset+1:]), 9
        }
        return 0, 0
    }
  |
}

insights: {
  near: bottom-center
  label: "Key Design Insights"
  style.fill: "#e8f5e9"
  style.stroke: "#4CAF50"
  style.border-radius: 8
  
  insight_text: |md
    1. **Big-endian**: Most significant bits come first (network byte order)
    2. **Self-describing**: First byte reveals total length via high bits
    3. **7-bit payload**: Each byte contributes 7 bits to the value
    4. **Optimized for small values**: Most integers in databases are small
    5. **Tradeoff**: Encoding/decoding CPU cost vs. I/O bandwidth savings
  |
}

encoding_rules -> example_1: "" {
  style.stroke: "transparent"
}
example_1 -> example_2: "larger value" {
  style.stroke: "#999999"
  style.stroke-dash: 2
}
example_2 -> example_3: "larger value" {
  style.stroke: "#999999"
  style.stroke-dash: 2
}