vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  continuation_bit: {
    label: "C"
    style: {
      fill: "#ff7b7b"
      stroke: "#9e1a1a"
      bold: true
      font-color: white
    }
  }
  data_bit: {
    style: {
      fill: "#7bb6ff"
      stroke: "#1a4a9e"
    }
  }
  bit_box: {
    width: 30
    height: 30
    style: {
      font-size: 14
      font: mono
    }
  }
  header_text: {
    shape: text
    style: {
      font-size: 18
      bold: true
    }
  }
}

direction: down

title: "THE VARINT SQUEEZE: VARIABLE-LENGTH INTEGER SERIALIZATION" {
  shape: text
  style: {
    font-size: 28
    bold: true
    underline: true
  }
}

# --- STAGE 1: INPUT ---
input_view: {
  label: "STEP 1: RAW INPUT"
  val: "Decimal: 300" {
    shape: rectangle
    style.double-border: true
    link: "#milestone-7"
  }
  binary: "Binary: 00000001 00101100" {
    style.font: mono
  }
  val -> binary
}

# --- STAGE 2: SLICING ---
bit_slicing: {
  label: "STEP 2: 7-BIT CHUNKING"
  
  chunk_high: "0000010" {
    class: data_bit
    tooltip: "Most Significant 7 bits"
  }
  chunk_low: "0101100" {
    class: data_bit
    tooltip: "Least Significant 7 bits"
  }
  
  explanation: |'md
    We divide the number into **7-bit groups**. 
    The 8th bit is reserved for the 
    **Continuation Flag**.
  '|
}

# --- STAGE 3: MEMORY LAYOUT ---
memory_layout: {
  label: "STEP 3: MICROSCOPE VIEW (MEMORY PAGE)"
  link: "#milestone-4"

  byte_0: "BYTE 0 (0x82)" {
    grid-columns: 8
    grid-gap: 0
    
    c: "1" { class: [continuation_bit; bit_box]; tooltip: "1 = More bytes follow" }
    b6: "0" { class: [data_bit; bit_box] }
    b5: "0" { class: [data_bit; bit_box] }
    b4: "0" { class: [data_bit; bit_box] }
    b3: "0" { class: [data_bit; bit_box] }
    b2: "0" { class: [data_bit; bit_box] }
    b1: "1" { class: [data_bit; bit_box] }
    b0: "0" { class: [data_bit; bit_box] }
  }

  byte_1: "BYTE 1 (0x2C)" {
    grid-columns: 8
    grid-gap: 0
    
    c: "0" { class: [continuation_bit; bit_box]; tooltip: "0 = Last byte of varint" }
    b6: "0" { class: [data_bit; bit_box] }
    b5: "1" { class: [data_bit; bit_box] }
    b4: "0" { class: [data_bit; bit_box] }
    b3: "1" { class: [data_bit; bit_box] }
    b2: "1" { class: [data_bit; bit_box] }
    b1: "0" { class: [data_bit; bit_box] }
    b0: "0" { class: [data_bit; bit_box] }
  }
}

# --- LOGIC & STATS ---
algorithm_rules: |'md
### VLQ (Variable Length Quantity) Logic
1. **MSB (Bit 7)**:
   - `1`: This is NOT the last byte.
   - `0`: This IS the last byte.
2. **Payload (Bits 0-6)**:
   - Pure data bits shifted into the final integer.
3. **Storage**:
   - Small ints (0-127) stay in **1 byte**.
   - Large ints scale up to **9 bytes**.
'| {
  shape: rectangle
  link: "#milestone-3"
  style.fill: "#fdf6e3"
}

efficiency_table: {
  shape: sql_table
  label: "DENSITY METRICS"
  link: "#milestone-4"
  
  "Int Range" : "Bytes Used"
  "0 - 127" : "1 Byte"
  "128 - 16,383" : "2 Bytes"
  "16,384 - 2,097,151" : "3 Bytes"
  "2^63 - 1" : "9 Bytes"
}

# --- CONNECTIONS ---
input_view.binary -> bit_slicing: "Bit Shift"
bit_slicing.chunk_high -> memory_layout.byte_0: "Set MSB=1"
bit_slicing.chunk_low -> memory_layout.byte_1: "Set MSB=0"

memory_layout -> algorithm_rules: "Execution Logic"
algorithm_rules -> efficiency_table: "Resulting Density"

# Legend
legend: {
  near: top-right
  c_bit: "MSB: Continuation" { class: continuation_bit }
  d_bit: "Payload: Data" { class: data_bit }
}

# Global tooltips
memory_layout.byte_0.c.tooltip: "Continuation Flag: 1 indicates the next byte is part of this number."
memory_layout.byte_1.c.tooltip: "Termination Flag: 0 indicates the number ends here."