vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    memory-bg: "#2d3436"
    byte-fill: "#0984e3"
    padding-fill: "#d63031"
    text-color: "#dfe6e9"
    label-color: "#fdcb6e"
  }
}

title: |md
  # Memory Alignment vs Packed
  Standard Struct vs Manual Serialization
| {
  near: top-center
  shape: text
}

classes: {
  memory_container: {
    style: {
      fill: ${colors.memory-bg}
      stroke: ${colors.text-color}
      stroke-width: 2
      border-radius: 4
      font-color: ${colors.text-color}
    }
  }
  
  byte_cell: {
    width: 60
    height: 60
    shape: square
    style: {
      stroke: ${colors.text-color}
      font-size: 14
      font-color: ${colors.text-color}
    }
  }

  data_byte: {
    style.fill: ${colors.byte-fill}
  }

  padding_byte: {
    label: "PAD"
    style: {
      fill: ${colors.padding-fill}
      fill-pattern: lines
      font-color: white
      stroke-dash: 3
    }
  }
}

# -----------------------------------------------------------------------
# SCENARIO A: The Naive Struct (Aligned)
# -----------------------------------------------------------------------
Aligned Layout: {
  link: "#ms-table"
  tooltip: "Compiler inserts padding to align integers to 4-byte boundaries"
  class: memory_container
  direction: down

  Header: |md
    ### Struct Layout (In RAM)
    `struct { char a; int b; }`
  | {
    shape: text
  }

  Memory Strip: {
    direction: right
    
    # Address 0x00
    addr_00: "0x00\nchar a" {
      class: [byte_cell; data_byte]
    }

    # Address 0x01 - 0x03 (Padding Holes)
    addr_01: "0x01" { class: [byte_cell; padding_byte] }
    addr_02: "0x02" { class: [byte_cell; padding_byte] }
    addr_03: "0x03" { class: [byte_cell; padding_byte] }

    # Address 0x04 - 0x07 (Integer)
    addr_04: "0x04\nint b" { class: [byte_cell; data_byte] }
    addr_05: "0x05\nint b" { class: [byte_cell; data_byte] }
    addr_06: "0x06\nint b" { class: [byte_cell; data_byte] }
    addr_07: "0x07\nint b" { class: [byte_cell; data_byte] }
  }

  Annotation: "3 Bytes Wasted (Padding)" {
    shape: text
    style: {
      font-color: ${colors.padding-fill}
      bold: true
    }
  }

  # Invisible link to enforce ordering
  Memory Strip -> Annotation: { style.opacity: 0 }
}

# -----------------------------------------------------------------------
# TRANSITION
# -----------------------------------------------------------------------
# We use a connection label instead of a standalone shape for better ELK layout
Aligned Layout -> Packed Layout: "serialize_row()" {
  style: {
    stroke-width: 4
    stroke: ${colors.text-color}
  }
  target-arrowhead: {
    shape: arrow
    style.filled: true
  }
}

# -----------------------------------------------------------------------
# SCENARIO B: The Packed Layout (Serialized)
# -----------------------------------------------------------------------
Packed Layout: {
  link: "#ms-table"
  tooltip: "Manual memcpy eliminates padding for disk storage"
  class: memory_container
  direction: down

  Header: |md
    ### Packed Layout (On Disk)
    `memcpy(buffer, &a, 1);`
    `memcpy(buffer+1, &b, 4);`
  | {
    shape: text
  }

  Memory Strip: {
    direction: right
    
    # Address 0x00
    addr_00: "0x00\nchar a" {
      class: [byte_cell; data_byte]
    }

    # Address 0x01 - 0x04 (Integer immediately follows)
    addr_01: "0x01\nint b" { class: [byte_cell; data_byte] }
    addr_02: "0x02\nint b" { class: [byte_cell; data_byte] }
    addr_03: "0x03\nint b" { class: [byte_cell; data_byte] }
    addr_04: "0x04\nint b" { class: [byte_cell; data_byte] }
    
    # Empty space representation
    addr_05: "0x05\nNext..." { 
      class: byte_cell
      style: {
        stroke-dash: 3
        opacity: 0.5
      }
    }
  }

  Annotation: "Contiguous Memory (Zero Waste)" {
    shape: text
    style: {
      font-color: ${colors.byte-fill}
      bold: true
    }
  }

  # Invisible link to enforce ordering
  Memory Strip -> Annotation: { style.opacity: 0 }
}