direction: right

vars: {
  d2-config: {
    theme-id: 200
    layout-engine: elk
  }
}

classes: {
  state: {
    shape: circle
    style: {
      stroke-width: 2
      fill: "#f8f9fa"
    }
  }
  terminal: {
    style: {
      double-border: true
      fill: "#e9ecef"
      stroke: "#495057"
    }
  }
  struct_style: {
    style: {
      fill: "#fff3cd"
      stroke: "#856404"
    }
  }
}

lexer_logic: Lexer Internal State Machine {
  style: {
    fill: "#f1f3f5"
    stroke: "#dee2e6"
    stroke-dash: 5
  }

  start: START {
    class: state
    style.fill: "#d4edda"
    style.stroke: "#28a745"
  }

  whitespace: WHITESPACE {
    class: state
  }

  numeric: NUMERIC_LITERAL {
    class: state
    tooltip: "Scanning for integers and floating point values"
  }

  id_kw: IDENTIFIER_OR_KEYWORD {
    class: state
    tooltip: "Resolving keywords vs table/column identifiers"
  }

  string_lit: STRING_LITERAL {
    class: state
    style.fill: "#fff3cd"
  }

  operator: OPERATOR_SCAN {
    class: state
  }

  error: ERROR_STATE {
    class: state
    style.fill: "#f8d7da"
    style.stroke: "#dc3545"
  }

  emit: EMIT_TOKEN {
    shape: rectangle
    class: terminal
    style.fill: "#cfe2ff"
  }

  # Transitions from Start
  start -> whitespace: "is_space()"
  whitespace -> start: "continue"

  start -> numeric: "is_digit()"
  numeric -> numeric: "is_digit() || '.'"
  numeric -> emit: "[non-digit]"

  start -> id_kw: "is_alpha() || '_'"
  id_kw -> id_kw: "is_alnum() || '_'"
  id_kw -> emit: "[non-alnum]" {
    label: "Check Keyword Trie"
  }

  start -> string_lit: "'"
  string_lit -> string_lit: "[any char]"
  string_lit -> emit: "'"
  string_lit -> error: "[EOF before ']'"

  start -> operator: "is_op_char()"
  operator -> operator: "peek_next_op()" {
    tooltip: "Handles multi-char ops like >=, !="
  }
  operator -> emit: "finalized"

  start -> emit: "\\0 (EOF)"
}

data_definitions: {
  label: Compiler Support Structures
  near: bottom-center

  Token: {
    shape: class
    class: struct_style
    +type: TokenType
    +start: const char*
    +length: uint32_t
    +line: uint32_t
    +metadata: uint8_t
    
    +scanner_next_token(cursor: const char**): Token
  }

  TokenType: {
    shape: sql_table
    style.fill: "#e2e3e5"
    TOKEN_SELECT: 0
    TOKEN_INSERT: 1
    TOKEN_IDENTIFIER: 2
    TOKEN_NUMBER: 3
    TOKEN_STRING: 4
    TOKEN_OPERATOR: 5
    TOKEN_EOF: 6
    TOKEN_ERROR: 7
  }
}

# Link to external system map
lexer_logic.link: "layers.milestone_2"

# Relationship between logic and data
lexer_logic.emit -> data_definitions.Token: "Instantiates with slice reference"
data_definitions.Token -> data_definitions.TokenType: "Categorizes as"

# Styling specific connections
(lexer_logic.start -> lexer_logic.error): {
  style: {
    stroke: red
    stroke-width: 2
  }
}