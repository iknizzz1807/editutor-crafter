vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  addr_color: "#E1BEE7"
  flow_color: "#BBDEFB"
  jump_color: "#FFCDD2"
  patch_color: "#C8E6C9"
}

direction: down

title: |md
  # SELECT Compilation to Bytecode
| {near: top-center}

select_ast: {
  label: "SELECT AST\n(Query struct)"
  style.fill: "${flow_color}"
  
  fields: {
    label: |md
      • pSrcList: tables
      • pWhere: condition
      • pEList: columns
      • pOrderBy: sorting
    |
  }
}

compiler_entry: {
  label: "sqlite3Select()\nCompiler Entry"
  style.fill: "${flow_color}"
}

group_address_table: {
  label: "Address Labels\n(Jump Patching)"
  style.fill: "${addr_color}"
  style.stroke: "#7B1FA2"
  
  addr_table: {
    shape: sql_table
    addr: int
    label_col: string
    target: string
  }
  
  rows: ||md
    | Addr | Label | Target |
    |------|-------|--------|
    | 0 | start_addr | OpenTable |
    | 1 | rewind_addr | Rewind |
    | 2 | loop_start | Column loop |
    | ... | where_skip | Next (if FALSE) |
    | ... | empty_jump | Halt (empty table) |
    | N | halt_addr | Halt |
  ||
}

group_bytecode: {
  label: "Generated Bytecode (VDBE)"
  
  instr_0: {
    label: "[0] OpenTable P1=0 P2=rootpage P3=0\n# Open cursor 0 on table"
    style.fill: "${flow_color}"
  }
  
  instr_1: {
    label: "[1] Rewind P1=0 P2=N+1\n# If empty, jump to Halt"
    style.fill: "${jump_color}"
  }
  
  loop_start: {
    shape: diamond
    label: "Loop Start\naddr=2"
    style.fill: "${patch_color}"
  }
  
  instr_2: {
    label: "[2] Column P1=0 P2=0 P3=1\n# r[1] = rowid"
    style.fill: "${flow_color}"
  }
  
  instr_3: {
    label: "[3] Column P1=0 P2=1 P3=2\n# r[2] = col1"
    style.fill: "${flow_color}"
  }
  
  instr_4: {
    label: "[4] Column P1=0 P2=2 P3=3\n# r[3] = col2"
    style.fill: "${flow_color}"
  }
  
  instr_5: {
    label: "[5] Ne P1=2 P2=8 P3=4\n# if r[2] != r[4] goto Next"
    style.fill: "${jump_color}"
  }
  
  instr_6: {
    label: "[6] IsNull P1=3 P2=8\n# if r[3] IS NULL goto Next"
    style.fill: "${jump_color}"
  }
  
  instr_7: {
    label: "[7] ResultRow P1=1 P2=3\n# Output r[1..3]"
    style.fill: "${patch_color}"
  }
  
  instr_8: {
    label: "[8] Next P1=0 P2=2\n# Advance cursor, goto 2"
    style.fill: "${jump_color}"
  }
  
  instr_9: {
    label: "[9] Halt P1=0 P2=0\n# End execution"
    style.fill: "${patch_color}"
  }
}

group_patching: {
  label: "Jump Target Patching"
  style.fill: "${patch_color}"
  
  patch_step_1: {
    label: "1. Record forward jump addresses\n(empty_jump, where_skip)"
  }
  
  patch_step_2: {
    label: "2. Emit body instructions\n(Column, WHERE, ResultRow)"
  }
  
  patch_step_3: {
    label: "3. Resolve labels with actual addrs\npatchJump(addr, target)"
  }
}

legend: {
  label: "Legend"
  
  legend_flow: {
    label: "Sequential Flow"
    style.fill: "${flow_color}"
  }
  
  legend_jump: {
    label: "Jump/Branch"
    style.fill: "${jump_color}"
  }
  
  legend_patch: {
    label: "Patch Point"
    style.fill: "${patch_color}"
  }
}

select_ast -> compiler_entry: "compile"
compiler_entry -> group_address_table: "init labels"
compiler_entry -> group_bytecode: "emit instructions"

group_bytecode.instr_0 -> group_bytecode.instr_1
group_bytecode.instr_1 -> group_bytecode.loop_start: "if rows"
group_bytecode.loop_start -> group_bytecode.instr_2
group_bytecode.instr_2 -> group_bytecode.instr_3
group_bytecode.instr_3 -> group_bytecode.instr_4
group_bytecode.instr_4 -> group_bytecode.instr_5
group_bytecode.instr_5 -> group_bytecode.instr_8: "FALSE (skip)"
group_bytecode.instr_5 -> group_bytecode.instr_6: "TRUE (continue)"
group_bytecode.instr_6 -> group_bytecode.instr_8: "TRUE (skip)"
group_bytecode.instr_6 -> group_bytecode.instr_7: "FALSE (continue)"
group_bytecode.instr_7 -> group_bytecode.instr_8
group_bytecode.instr_8 -> group_bytecode.loop_start: "more rows"

group_bytecode.instr_1 -> group_bytecode.instr_9: "empty table" {
  style.stroke-dash: 3
}

group_bytecode -> group_patching: "resolve jumps"