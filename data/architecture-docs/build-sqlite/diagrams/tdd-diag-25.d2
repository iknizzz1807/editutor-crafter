vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  arrow_style: {
    stroke: "#4A90D9"
    stroke-width: 3
  }
}

title: Column Deserialization Algorithm {
  near: top-center
  shape: text
  style: {
    font-size: 32
    bold: true
  }
}

step_1_parse_header: {
  shape: rectangle
  label: "1. Parse Header"
  style: {
    fill: "#E8F4FD"
    stroke: "#2E6DA4"
    stroke-width: 2
  }
  
  details: |md
    - Read header size varint
    - Validate header bounds
    - Initialize serial type array
  |
}

step_2_read_serial_types: {
  shape: rectangle
  label: "2. Read Serial Types"
  style: {
    fill: "#E8F4FD"
    stroke: "#2E6DA4"
    stroke-width: 2
  }
  
  details: |md
    - Iterate through header bytes
    - Decode each serial type varint
    - Calculate column byte offsets
    - Store in serialTypes[] array
  |
}

step_3_skip_to_offset: {
  shape: rectangle
  label: "3. Skip to Target Column Offset"
  style: {
    fill: "#E8F4FD"
    stroke: "#2E6DA4"
    stroke-width: 2
  }
  
  details: |md
    - Validate colIndex bounds
    - Retrieve cached offset
    - Get column size from serial type
    - Position at record[offset]
  |
}

step_4_decode_value: {
  shape: diamond
  label: "4. Decode Based on Serial Type"
  style: {
    fill: "#FFF3E0"
    stroke: "#E65100"
    stroke-width: 2
  }
  
  decode_branches: |md
    **Serial Type - Decode Action:**

    Type 0 (NULL): return ValueNull
    Type 1 (Int8): read 1 byte as int64
    Type 2 (Int16): read 2 bytes BE as int64
    Type 3 (Int24): read 3 bytes BE as int64
    Type 4 (Int32): read 4 bytes BE as int64
    Type 5 (Int48): read 6 bytes BE as int64
    Type 6 (Int64): read 8 bytes BE as int64
    Type 7 (Float): read 8 bytes BE as float64
    Type 8 (Zero): return int64(0)
    Type 9 (One): return int64(1)
    Type >=12 (BLOB): read N bytes as []byte
    Type >=13 (TEXT): read N bytes as string
  |
}

step_5_return_value: {
  shape: oval
  label: "5. Return Value"
  style: {
    fill: "#E8F5E9"
    stroke: "#2E7D32"
    stroke-width: 3
  }
  
  return_details: |md
    - Create Value{Type, Data}
    - Cache value for future access
    - Return to caller
  |
}

step_1_parse_header -> step_2_read_serial_types: {
  style: ${arrow_style}
}

step_2_read_serial_types -> step_3_skip_to_offset: {
  style: ${arrow_style}
}

step_3_skip_to_offset -> step_4_decode_value: {
  style: ${arrow_style}
}

step_4_decode_value -> step_5_return_value: {
  style: ${arrow_style}
}

legend: |md
  **Column Deserialization Algorithm**

  Module: execution/column_access.go
  Function: ColumnCache.GetColumn(colIndex)

  **Flow:** Record bytes - Header - Serial Types - Offset - Decode - Value

  **Optimization:** Lazy deserialization with caching
  Only parses accessed columns, caches results
| {
  near: bottom-center
}