direction: right

title: Cost Model Comparison - Query Planner M8

vars: {
  d2-config: {
    pad: 20
    layout-engine: elk
    theme-id: 200
  }
}

# Input
query: {
  label: "SQL Query\n(SELECT ... WHERE)"
  shape: oval
  style.fill: "#E3F2FD"
}

# Cost Model Container
cost_model: {
  label: "Cost Model"
  style.fill: "#FAFAFA"
  style.stroke: "#666"
  
  # Constants
  constants: {
    label: "Cost Constants"
    style.fill: "#FFF3E0"
    
    seq_io: "seqIOCost = 1.0\n(Sequential I/O)"
    rand_io: "randomIOCost = 4.0\n(Random I/O)"
    cpu_cost: "cpuCostPerRow = 0.01"
  }
  
  # Statistics
  stats: {
    label: "Table Statistics"
    style.fill: "#E8F5E9"
    
    page_count: "pageCount"
    row_count: "rowCount"
    rows_per_page: "rowsPerPage"
    selectivity: "selectivity\n(estimated)"
  }
}

# Table Scan Path
table_scan: {
  label: "Table Scan Cost"
  style.fill: "#FFEBEE"
  style.stroke: "#C62828"
  
  formula: {
    label: "Cost = pageCount × seqIOCost\n+ rowCount × cpuCostPerRow"
    shape: cylinder
    style.fill: "#FFCDD2"
  }
  
  description: {
    label: "Read all pages sequentially\nBest for: Low selectivity\n(large result sets)"
    shape: text
    style.font-size: 12
  }
}

# Index Scan Path
index_scan: {
  label: "Index Scan Cost"
  style.fill: "#E3F2FD"
  style.stroke: "#1565C0"
  
  formula: {
    label: "Cost = traversalCost\n+ (matchingRows / rowsPerPage) × randomIOCost\n+ matchingRows × cpuCostPerRow"
    shape: cylinder
    style.fill: "#BBDEFB"
  }
  
  description: {
    label: "Index traversal + random page fetches\nBest for: High selectivity\n(small result sets)"
    shape: text
    style.font-size: 12
  }
  
  matching: {
    label: "matchingRows =\nrowCount × selectivity"
    shape: code
    style.fill: "#E1F5FE"
  }
}

# Comparison
comparison: {
  label: "Cost Comparison"
  style.fill: "#F3E5F5"
  style.stroke: "#7B1FA2"
  
  compare: {
    label: "MIN(tableScanCost,\nindexScanCost)"
    shape: diamond
    style.fill: "#E1BEE7"
  }
}

# Decision Output
decision: {
  label: "Query Plan\nSelection"
  shape: oval
  style.fill: "#C8E6C9"
  style.stroke: "#388E3C"
  
  plan: {
    label: "Chosen Plan"
    shape: class
    
    full_scan: "• Full Table Scan\n  (if tableScanCost lower)"
    idx_scan: "• Index Scan\n  (if indexScanCost lower)"
  }
}

# Connections
query -> cost_model: "Parse &\nAnalyze"

cost_model.constants -> table_scan: "use"
cost_model.stats -> table_scan: "use"

cost_model.constants -> index_scan: "use"
cost_model.stats -> index_scan: "use"
index_scan.formula -> index_scan.matching: "calculates"

table_scan -> comparison: "tableScanCost"
index_scan -> comparison: "indexScanCost"

comparison -> decision: "winner"

# Legend
legend: {
  label: "Cost Model Rules"
  style.fill: "#ECEFF1"
  
  rule1: {
    label: "Sequential I/O is cheaper than Random I/O"
    shape: text
    style.font-size: 11
    style.bold: true
  }
  
  rule2: {
    label: "→ seqIOCost (1.0) < randomIOCost (4.0)"
    shape: text
    style.font-size: 10
  }
  
  rule3: {
    label: "Index scan wins when selectivity is LOW"
    shape: text
    style.font-size: 11
    style.bold: true
  }
  
  rule4: {
    label: "→ Few matching rows = fewer random I/Os"
    shape: text
    style.font-size: 10
  }
  
  rule5: {
    label: "Table scan wins when selectivity is HIGH"
    shape: text
    style.font-size: 11
    style.bold: true
  }
  
  rule6: {
    label: "→ Reading many rows sequentially beats\n   many random page fetches"
    shape: text
    style.font-size: 10
  }
}

# Example calculation
example: {
  label: "Example: 10,000 rows, 100 pages, 1% selectivity"
  style.fill: "#FFFDE7"
  
  table_ex: {
    label: "Table Scan: 100 × 1.0 + 10000 × 0.01\n= 200"
    shape: code
  }
  
  idx_ex: {
    label: "Index Scan: 16 + (100/20) × 4.0 + 100 × 0.01\n= 16 + 20 + 1 = 37"
    shape: code
  }
  
  result: {
    label: "→ Index Scan wins (37 < 200)"
    shape: text
    style.bold: true
    style.fill: "#C8E6C9"
  }
}