direction: right

title: GROUP BY Hash Table Structure {
  shape: text
  near: top-center
  style.font-size: 24
  style.bold: true
}

# GroupByExecutor struct
GroupByExecutor: {
  shape: class
  style.fill: "#E3F2FD"
  style.stroke: "#1976D2"
  
  groupColumns: "[]int"
  aggregates: "[]AggregateSpec"
  groups: "map[string][]AggregateState"
}

# Groups Map Visualization
Groups_Map: {
  label: "groups: map[string][]AggregateState"
  shape: rectangle
  style.fill: "#FFF3E0"
  style.stroke: "#F57C00"
  style.stroke-dash: 3
  
  # Bucket Array
  Bucket_Array: {
    label: ""
    shape: rectangle
    style.fill: "#FFFFFF"
    style.stroke: "#666666"
    
    bucket_0: {
      shape: rectangle
      style.fill: "#FFECB3"
      label: "0"
    }
    bucket_1: {
      shape: rectangle
      style.fill: "#C8E6C9"
      label: "1"
    }
    bucket_2: {
      shape: rectangle
      style.fill: "#FFECB3"
      label: "2"
    }
    bucket_3: {
      shape: rectangle
      style.fill: "#C8E6C9"
      label: "3"
    }
    bucket_n: {
      shape: rectangle
      style.fill: "#E0E0E0"
      label: "..."
    }
  }
}

# Key-Value Entries
Entry_1: {
  label: "Entry (Department='Engineering')"
  shape: rectangle
  style.fill: "#E8F5E9"
  style.stroke: "#4CAF50"
  
  key_1: {
    label: "Key\n(serialized)"
    shape: rectangle
    style.fill: "#C8E6C9"
  }
  key_1_label: {
    label: "\"Engineering\""
    shape: text
  }
  
  value_1: {
    label: "Value: []AggregateState"
    shape: rectangle
    style.fill: "#FFFFFF"
    style.stroke: "#666666"
    
    count_state: {
      shape: class
      style.fill: "#BBDEFB"
      label: CountStarState
    }
    count_state_div: {
      label: "--"
      shape: text
    }
    count_state_count: "count: int"
    
    sum_state: {
      shape: class
      style.fill: "#BBDEFB"
      label: SumState
    }
    sum_state_div: {
      label: "--"
      shape: text
    }
    sum_state_sum: "sum: int64"
    sum_state_count: "count: int"
    
    avg_state: {
      shape: class
      style.fill: "#BBDEFB"
      label: AvgState
    }
    avg_state_div: {
      label: "--"
      shape: text
    }
    avg_state_sum: "sum: float64"
    avg_state_count: "count: int"
  }
}

Entry_2: {
  label: "Entry (Department='Sales')"
  shape: rectangle
  style.fill: "#FFF8E1"
  style.stroke: "#FFC107"
  
  key_2: {
    label: "Key\n(serialized)"
    shape: rectangle
    style.fill: "#FFECB3"
  }
  key_2_label: {
    label: "\"Sales\""
    shape: text
  }
  
  value_2: {
    label: "Value: []AggregateState"
    shape: rectangle
    style.fill: "#FFFFFF"
    style.stroke: "#666666"
    
    count_state_2: {
      shape: class
      style.fill: "#BBDEFB"
      label: CountStarState
    }
    count_state_2_div: {
      label: "--"
      shape: text
    }
    count_state_2_count: "count: int"
    
    sum_state_2: {
      shape: class
      style.fill: "#BBDEFB"
      label: SumState
    }
    sum_state_2_div: {
      label: "--"
      shape: text
    }
    sum_state_2_sum: "sum: int64"
    sum_state_2_count: "count: int"
    
    avg_state_2: {
      shape: class
      style.fill: "#BBDEFB"
      label: AvgState
    }
    avg_state_2_div: {
      label: "--"
      shape: text
    }
    avg_state_2_sum: "sum: float64"
    avg_state_2_count: "count: int"
  }
}

# Composite Key Example
Composite_Key_Entry: {
  label: "Entry (Composite Key: Dept='HR', Year=2024)"
  shape: rectangle
  style.fill: "#F3E5F5"
  style.stroke: "#9C27B0"
  
  composite_key: {
    label: "Key\n(serialized composite)"
    shape: rectangle
    style.fill: "#E1BEE7"
  }
  composite_key_label: {
    label: "\"HR|2024\""
    shape: text
  }
  
  composite_value: {
    label: "Value: []AggregateState"
    shape: rectangle
    style.fill: "#FFFFFF"
    style.stroke: "#666666"
    
    min_state: {
      shape: class
      style.fill: "#BBDEFB"
      label: MinState
    }
    min_state_div: {
      label: "--"
      shape: text
    }
    min_state_min: "min: Value"
    min_state_hasValue: "hasValue: bool"
    
    max_state: {
      shape: class
      style.fill: "#BBDEFB"
      label: MaxState
    }
    max_state_div: {
      label: "--"
      shape: text
    }
    max_state_max: "max: Value"
    max_state_hasValue: "hasValue: bool"
  }
}

# AggregateState Interface
AggregateState_Interface: {
  shape: class
  style.fill: "#FCE4EC"
  style.stroke: "#E91E63"
  
  interface_marker: "<<interface>>"
  name: "AggregateState"
  divider: {
    label: "--"
    shape: text
  }
  method1: "+ Update(value Value)"
  method2: "+ Finalize() Value"
}

# Legend
Legend: {
  label: "Legend"
  shape: rectangle
  style.fill: "#FAFAFA"
  style.stroke: "#9E9E9E"
  
  key_desc: {
    label: "Key = Serialized GROUP BY column values\n(concatenated with delimiters for composite keys)"
    shape: text
  }
  
  value_desc: {
    label: "Value = Array of AggregateState objects\n(one per aggregate function in SELECT)"
    shape: text
  }
  
  flow_desc: {
    label: "Flow: For each row → compute key →\nlookup/create states → call Update()"
    shape: text
  }
}

# Connections
GroupByExecutor.groups -> Groups_Map: {
  style.stroke: "#1976D2"
  style.stroke-width: 2
}

Groups_Map.bucket_1 -> Entry_1: {
  style.stroke: "#4CAF50"
  style.stroke-dash: 3
}

Groups_Map.bucket_3 -> Entry_2: {
  style.stroke: "#FFC107"
  style.stroke-dash: 3
}

Groups_Map.bucket_0 -> Composite_Key_Entry: {
  style.stroke: "#9C27B0"
  style.stroke-dash: 3
}

Entry_1.value_1 -- AggregateState_Interface: {
  style.stroke: "#E91E63"
  style.stroke-dash: 5
  label: "implements"
}

# Example Data Flow
Data_Flow: {
  label: "Processing Flow"
  shape: rectangle
  style.fill: "#E0F7FA"
  style.stroke: "#00BCD4"
  
  step1: "1. Scan input row"
  step2: "2. Extract GROUP BY columns"
  step3: "3. Serialize to string key"
  step4: "4. Lookup/create aggregate states"
  step5: "5. Call Update() for each aggregate"
  step6: "6. After scan, call Finalize()"
}

# Memory Layout Note
Memory_Note: {
  label: "Memory Layout Notes"
  shape: rectangle
  style.fill: "#FFEBEE"
  style.stroke: "#F44336"
  
  note1: "• Map buckets are contiguous array in memory"
  note2: "• Each bucket may chain multiple entries (hash collision)"
  note3: "• Keys are heap-allocated strings"
  note4: "• AggregateState slice is heap-allocated"
  note5: "• Each state object is separately allocated"
}

# Positioning
GroupByExecutor -- Groups_Map: {
  style.opacity: 0
}

Groups_Map -- Entry_1: {
  style.opacity: 0
}

Entry_1 -- Entry_2: {
  style.opacity: 0
}

Entry_2 -- Composite_Key_Entry: {
  style.opacity: 0
}

AggregateState_Interface -- Legend: {
  style.opacity: 0
}

Legend -- Data_Flow: {
  style.opacity: 0
}

Data_Flow -- Memory_Note: {
  style.opacity: 0
}