direction: right
title: Expression Precedence Tree | M2 Parser - Precedence Climbing Algorithm
# Left Example: Natural Precedence
left_panel: {
  label: "a OR b AND c"
  # Root operator (lowest precedence = root)
  or_root: {
    shape: class
    label: "OR\n(operator)"
    style.fill: "#E8F5E9"
    style.stroke: "#4CAF50"
  }
  # Left operand (simple identifier)
  a_left: {
    shape: class
    label: "a\n(identifier)"
    style.fill: "#E3F2FD"
    style.stroke: "#2196F3"
  }
  # Right subtree (AND has higher precedence)
  and_subtree: {
    label: "AND subtree"
    style.fill: "#FFF3E0"
    style.stroke: "#FF9800"
    and_node: {
      shape: class
      label: "AND\n(operator)"
      style.fill: "#E8F5E9"
      style.stroke: "#4CAF50"
    }
    b_node: {
      shape: class
      label: "b\n(identifier)"
      style.fill: "#E3F2FD"
      style.stroke: "#2196F3"
    }
    c_node: {
      shape: class
      label: "c\n(identifier)"
      style.fill: "#E3F2FD"
      style.stroke: "#2196F3"
    }
    and_node -> b_node: "left"
    and_node -> c_node: "right"
  }
  or_root -> a_left: "left"
  or_root -> and_subtree: "right\ndeeper"
}
# Right Example: Parenthesized Override
right_panel: {
  label: "(a OR b) AND c"
  # Root operator (AND is root due to parens)
  and_root: {
    shape: class
    label: "AND\n(operator)"
    style.fill: "#E8F5E9"
    style.stroke: "#4CAF50"
  }
  # Left subtree (OR in parens)
  or_subtree: {
    label: "OR subtree (parens forced)"
    style.fill: "#FFF3E0"
    style.stroke: "#FF9800"
    or_node: {
      shape: class
      label: "OR\n(operator)"
      style.fill: "#E8F5E9"
      style.stroke: "#4CAF50"
    }
    a_node: {
      shape: class
      label: "a\n(identifier)"
      style.fill: "#E3F2FD"
      style.stroke: "#2196F3"
    }
    b_node: {
      shape: class
      label: "b\n(identifier)"
      style.fill: "#E3F2FD"
      style.stroke: "#2196F3"
    }
    or_node -> a_node: "left"
    or_node -> b_node: "right"
  }
  # Right operand
  c_right: {
    shape: class
    label: "c\n(identifier)"
    style.fill: "#E3F2FD"
    style.stroke: "#2196F3"
  }
  and_root -> or_subtree: "left\ndeeper"
  and_root -> c_right: "right"
}
# Precedence Legend
legend: {
  label: "Operator Precedence (Low → High)"
  prec_or: {
    shape: text
    label: "OR (lowest) = 1"
    style.fill: "#FFCDD2"
  }
  prec_and: {
    shape: text
    label: "AND = 2"
    style.fill: "#C8E6C9"
  }
  prec_comp: {
    shape: text
    label: "Comparison (=, <, >) = 3"
  }
  prec_add: {
    shape: text
    label: "Additive (+, -) = 4"
  }
  prec_mul: {
    shape: text
    label: "Multiplicative (*, /) = 5"
  }
  prec_unary: {
    shape: text
    label: "Unary (-, NOT) = 6"
  }
  prec_primary: {
    shape: text
    label: "Primary (highest) = 7"
    style.fill: "#BBDEFB"
  }
  prec_or -> prec_and -> prec_comp -> prec_add -> prec_mul -> prec_unary -> prec_primary
}
# Annotations
annotation_binding: {
  shape: text
  label: "Higher precedence → Deeper in AST\nLower precedence → Closer to root"
  style.italic: true
}
annotation_parens: {
  shape: text
  label: "Parentheses force sub-expression\nto be parsed as a unit first"
  style.italic: true
}
# Result format
result_left: {
  shape: rectangle
  label: "Result: OR(a, AND(b, c))"
  style.fill: "#F3E5F5"
  style.stroke: "#9C27B0"
}
result_right: {
  shape: rectangle
  label: "Result: AND(OR(a, b), c)"
  style.fill: "#F3E5F5"
  style.stroke: "#9C27B0"
}
# Connections
left_panel -> result_left
right_panel -> result_right
legend -> annotation_binding
annotation_binding -> annotation_parens