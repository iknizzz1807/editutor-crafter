direction: right
title: Precedence Climbing Algorithm | Expression: NOT a = 1 AND b > 2
step_1: {
  shape: rectangle
  label: "STEP 1: Entry\nparse_expr(min_prec=PREC_OR)\n\nCall stack: [parse_expr(0)]\nToken: NOT\nAction: Call parse_unary()"
}
step_2: {
  shape: rectangle
  label: "STEP 2: parse_unary()\n\nCall stack: [parse_expr(0), parse_unary]\nToken: NOT\nAction: Detect unary NOT\nConsume NOT, recurse"
}
step_3: {
  shape: rectangle
  label: "STEP 3: parse_unary(inner)\n\nCall stack: [parse_expr(0), parse_unary, parse_unary]\nToken: a\nAction: No unary op\nFall through to parse_primary()"
}
step_4: {
  shape: rectangle
  label: "STEP 4: parse_primary()\n\nCall stack: [..., parse_primary]\nToken: a\nAction: Identifier 'a'\nReturn AstIdentifier('a')\nConsume 'a'"
}
step_5: {
  shape: rectangle
  label: "STEP 5: Enter expr loop\nmin_prec = PREC_COMPARISON(4)\n\nToken: =\nAction: peek operator '='\nprecedence('=') = 4 >= 4 ✓\nContinue in loop"
}
step_6: {
  shape: rectangle
  label: "STEP 6: Build comparison\n\nConsume '='\nRecurse: parse_expr(5)\n  → parse_primary('1')\n  → return 1\nBuild: AstBinary('=', a, 1)\nleft = (a = 1)"
}
step_7: {
  shape: rectangle
  label: "STEP 7: Check AND\n\nToken: AND\nprecedence('AND') = 2 < 4\nBREAK loop\nReturn (a = 1) to outer"
}
step_8: {
  shape: rectangle
  label: "STEP 8: Complete NOT\n\nBack in outer parse_unary\nBuild: AstUnary('NOT', (a = 1))\nleft = NOT(a = 1)\nReturn to expr(0) loop"
}
step_9: {
  shape: rectangle
  label: "STEP 9: Check AND at root\nmin_prec = PREC_OR(0)\n\nToken: AND\nprecedence('AND') = 2 >= 0 ✓\nConsume AND\nRecurse: parse_expr(3)"
}
step_10: {
  shape: rectangle
  label: "STEP 10: Parse right side\nparse_expr(3) → parse_unary\n\nToken: b → identifier\nToken: > → op, prec=4 >= 3 ✓\nConsume >, parse 2\nBuild: (b > 2)\nReturn (b > 2)"
}
step_11: {
  shape: rectangle
  label: "STEP 11: Combine with AND\n\nLeft: NOT(a = 1)\nRight: (b > 2)\nBuild: AstBinary('AND',\n         NOT(a = 1),\n         (b > 2))\nleft = AND(...)"
}
step_12: {
  shape: rectangle
  label: "STEP 12: Final check\n\nToken: EOF\nNo more operators\nBREAK loop\n\nReturn final AST"
}
final_ast: {
  shape: rectangle
  label: "FINAL AST\n\n        AND\n       /    \\\n     NOT    GT\n      |    /  \\\n     EQ   b    2\n    /   \\\n   a     1\n\nPrecedence applied:\n• NOT binds tightest (to a=1)\n• = and > next (comparisons)\n• AND loosest (root)"
}
arrow_style: {
  style.stroke: "#2563eb"
  style.stroke-width: 2
}
step_1 -> step_2 -> step_3 -> step_4 -> step_5 -> step_6 -> step_7 -> step_8 -> step_9 -> step_10 -> step_11 -> step_12 -> final_ast
legend: {
  shape: rectangle
  label: "PRECEDENCE LEVELS\n━━━━━━━━━━━━━━━━━\n0: OR (loosest)\n1: AND\n2: NOT (unary)\n3: Comparison (=, <, >, <=, >=)\n4: Additive (+, -)\n5: Multiplicative (*, /)\n6: Unary (-, +, NOT)\n7: Primary (tightest)\n\nHigher = tighter binding"
}
call_stack_visual: {
  shape: rectangle
  label: "CALL STACK EVOLUTION\n━━━━━━━━━━━━━━━━━━━━\n[parse_expr(0)]\n       ↓\n[parse_expr(0), parse_unary]\n       ↓\n[parse_expr(0), parse_unary, parse_expr(4)]\n       ↓\n[parse_expr(0)] ← returns NOT(a=1)\n       ↓\n[parse_expr(0), parse_expr(3)]\n       ↓\n[parse_expr(0)] ← returns b>2\n       ↓\nFINAL: AND(NOT(EQ), GT)"
}