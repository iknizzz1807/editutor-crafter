direction: right
title: |md
  # System Catalog Schema - sqlite_master
|
create_input: {
  label: |md
    **CREATE TABLE Statement**
    sql
    CREATE TABLE users (
      id INTEGER PRIMARY KEY,
      name TEXT NOT NULL,
      email TEXT UNIQUE
    );
    
  |
  shape: rectangle
}
parser: {
  label: "Parser\nSchema Extraction"
  shape: rectangle
  extracted: {
    label: "Extracted Metadata"
    shape: class
    type: "string"
    name: "string"
    tbl_name: "string"
    rootpage: "int"
    sql: "string"
  }
}
sqlite_master: {
  shape: sql_table
  style.fill: "#E3F2FD"
  type: TEXT
  name: TEXT
  tbl_name: TEXT
  rootpage: INTEGER
  sql: TEXT
}
btree: {
  label: "B-tree Storage\nPage 1"
  shape: cylinder
  style.fill: "#FFF3E0"
}
example_rows: {
  shape: sql_table
  style.fill: "#F5F5F5"
  type: TEXT
  name: TEXT
  tbl_name: TEXT
  rootpage: INTEGER
  sql: TEXT
}
page_allocator: {
  label: "Page Allocator"
  shape: rectangle
  style.fill: "#E8F5E9"
}
create_input -> parser: "1. Parse DDL" {
  style.stroke: "#1976D2"
}
parser -> page_allocator: "2. Request page" {
  style.stroke: "#388E3C"
}
page_allocator -> parser: "3. Return rootpage=2" {
  style.stroke: "#388E3C"
  style.stroke-dash: 3
}
parser -> sqlite_master: "4. Insert row" {
  style.stroke: "#1976D2"
}
sqlite_master -> btree: "5. Store in Page 1" {
  style.stroke: "#F57C00"
}
sqlite_master <-> example_rows: "Populated rows" {
  style.stroke-dash: 3
  style.stroke: "#9E9E9E"
}
legend: {
  label: |md
    **Object Types in sqlite_master**
    - `table` - User tables
    - `index` - Secondary indexes
    - `view` - Virtual tables
    - `trigger` - Event handlers
  |
  shape: rectangle
  style.fill: "#FAFAFA"
}
notes: {
  label: |md
    **Key Points**
    - sqlite_master lives on page 1 (reserved)
    - rootpage=0 for views/triggers (no storage)
    - Auto-indexes have NULL sql field
    - DDL is stored verbatim for reconstruction
  |
  shape: rectangle
  style.fill: "#FFFDE7"
}