direction: right
title: "WHERE Clause Bytecode Execution | age > 18 AND status = 'active'"
# Bytecode program listing
bytecode_program: {
  shape: rectangle
  Near: |sql
  0:  Integer    18       r1         -- r1 = 18
  1:  String     'active' r2         -- r2 = 'active'  
  2:  Next       csr1     9          -- advance cursor, goto 9 if done
  3:  Column     csr1     0     r3   -- r3 = row.age
  4:  Le         r1       r3    8    -- if age <= 18, goto 8 (skip)
  5:  Column     csr1     1     r4   -- r4 = row.status
  6:  Ne         r2       r4    8    -- if status != 'active', goto 8 (skip)
  7:  ResultRow  r3       2          -- output row (age, status)
  8:  Goto       0        2          -- loop back to instruction 2
  9:  Halt       0        0          -- end execution
  |
}
# Execution trace for row (age=25, status='active')
trace_match: {
  shape: sequence_diagram
  label: "Row MATCHES: (age=25, status='active')"
  executor: Executor
  cursor: Cursor
  registers: Registers {
    shape: queue
  }
  executor -> cursor: "Next csr1 (row 1)"
  cursor -> executor: "found row"
  executor -> registers: "Column csr1, 0 → r3"
  registers -> executor: "r3 = 25"
  executor -> executor: "Le r1(18), r3(25), 8 - 25 <= 18? FALSE - continue (no jump)"
  executor -> registers: "Column csr1, 1 → r4"
  registers -> executor: "r4 = 'active'"
  executor -> executor: "Ne r2('active'), r4('active'), 8 - 'active' != 'active'? FALSE - continue (no jump)"
  executor -> cursor: "ResultRow r3, r2 - OUTPUT: (25, 'active')"
}
# Execution trace for row that fails first condition
trace_fail_age: {
  shape: sequence_diagram
  label: "Row FAILS age: (age=15, status='active')"
  executor2: Executor
  cursor2: Cursor
  registers2: Registers {
    shape: queue
  }
  executor2 -> cursor2: "Next csr1 (row 2)"
  cursor2 -> executor2: "found row"
  executor2 -> registers2: "Column csr1, 0 → r3"
  registers2 -> executor2: "r3 = 15"
  executor2 -> executor2: "Le r1(18), r3(15), 8 - 15 <= 18? TRUE - JUMP to 8 (SKIP)"
  executor2 -> cursor2: "Goto 2 (loop) - Row REJECTED"
}
# Execution trace for row that fails second condition
trace_fail_status: {
  shape: sequence_diagram
  label: "Row FAILS status: (age=30, status='inactive')"
  executor3: Executor
  cursor3: Cursor
  registers3: Registers {
    shape: queue
  }
  executor3 -> cursor3: "Next csr1 (row 3)"
  cursor3 -> executor3: "found row"
  executor3 -> registers3: "Column csr1, 0 → r3"
  registers3 -> executor3: "r3 = 30"
  executor3 -> executor3: "Le r1(18), r3(30), 8 - 30 <= 18? FALSE - continue (no jump)"
  executor3 -> registers3: "Column csr1, 1 → r4"
  registers3 -> executor3: "r4 = 'inactive'"
  executor3 -> executor3: "Ne r2('active'), r4('inactive'), 8 - 'active' != 'inactive'? TRUE - JUMP to 8 (SKIP)"
  executor3 -> cursor3: "Goto 2 (loop) - Row REJECTED"
}
# Flow diagram showing jump targets
flow_diagram: {
  label: "Control Flow with Jump Targets"
  start: {
    shape: oval
    label: "Start"
  }
  init: {
    shape: rectangle
    label: "Init registers\nr1=18, r2='active'"
  }
  loop_check: {
    shape: diamond
    label: "Next row\navailable?"
  }
  read_age: {
    shape: rectangle
    label: "Column csr1, 0 → r3\n(read age)"
  }
  compare_age: {
    shape: diamond
    label: "age <= 18?"
  }
  read_status: {
    shape: rectangle
    label: "Column csr1, 1 → r4\n(read status)"
  }
  compare_status: {
    shape: diamond
    label: "status !=\n'active'?"
  }
  output: {
    shape: stored_data
    label: "ResultRow\nOUTPUT"
    style.fill: "#90EE90"
  }
  skip: {
    shape: circle
    label: "SKIP\n(addr 8)"
    style.fill: "#FFB6C1"
  }
  loop_back: {
    shape: rectangle
    label: "Goto 2\n(loop)"
  }
  halt: {
    shape: oval
    label: "Halt"
  }
  start -> init -> loop_check
  loop_check -> read_age: "yes (addr 2)"
  loop_check -> halt: "no → addr 9"
  read_age -> compare_age
  compare_age -> skip: "TRUE\n(age <= 18)"
  compare_age -> read_status: "FALSE\n(age > 18)"
  read_status -> compare_status
  compare_status -> skip: "TRUE\n(status != 'active')"
  compare_status -> output: "FALSE\n(status = 'active')"
  output -> loop_back
  skip -> loop_back
  loop_back -> loop_check
}
# Inverted comparison explanation
inverted_logic: {
  label: "Inverted Comparison Pattern"
  sql_intent: {
    shape: text
    label: "**SQL Intent:** age > 18 AND status = 'active'"
  }
  bytecode_reality: {
    shape: text
    label: "**Bytecode:** Jump on condition FAILURE"
  }
  table: {
    shape: sql_table
    label: "Comparison Mapping"
    SQL: string
    Bytecode: string
    Jump_On: string
  }
  note: {
    shape: text
    label: "Why inverted? Early rejection is more efficient. Jump to SKIP immediately when predicate fails. No need to track 'and' success - fall through to output."
  }
}
# Jump target summary
jump_summary: {
  label: "Jump Targets Summary"
  addr_8: {
    shape: class
    label: "Address 8: Goto 2"
    style.fill: "#FFB6C1"
    Purpose: "SKIP row"
    Triggered_by: "Le (age<=18) OR Ne (status!='active')"
    Action: "Loop to next row without output"
  }
  addr_2: {
    shape: class
    label: "Address 2: Next csr1"
    style.fill: "#87CEEB"
    Purpose: "LOOP start"
    Reached_by: "Goto 8 (after skip/output)"
    Action: "Advance cursor, check for more rows"
  }
  addr_9: {
    shape: class
    label: "Address 9: Halt"
    style.fill: "#90EE90"
    Purpose: "EXIT"
    Reached_by: "Next csr1 (no more rows)"
    Action: "End execution"
  }
}
bytecode_program -> trace_match
trace_match -> trace_fail_age
trace_fail_age -> trace_fail_status
trace_fail_status -> flow_diagram
flow_diagram -> inverted_logic
inverted_logic -> jump_summary