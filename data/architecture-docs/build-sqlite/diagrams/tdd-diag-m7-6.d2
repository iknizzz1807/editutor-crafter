direction: right
title: Covering Index Optimization - SELECT email FROM users WHERE email = X
# Query Input
query_input: {
  shape: rectangle
  label: "SQL Query\nSELECT email FROM users\nWHERE email = 'alice@example.com'"
  style.fill: "#E8F5E9"
}
# Parser
parser: {
  shape: rectangle
  label: "Parser\n(Parse SQL → AST)"
}
# Query Planner
planner: {
  shape: rectangle
  label: "Query Planner\n\n• Detect index on 'email'\n• Analyze column needs\n• Only 'email' required\n• Index covers all columns!"
  style.fill: "#FFF3E0"
}
# Covering Index Decision
covering_decision: {
  shape: diamond
  label: "Is Index\nCovering?"
  style.fill: "#E1F5FE"
}
yes_label: {
  shape: text
  label: "YES\n(All columns\nin index)"
}
# VDBE Compiler
vdbe_compiler: {
  shape: rectangle
  label: "VDBE Compiler\n(Generate Bytecode)"
  style.fill: "#F3E5F5"
}
# Bytecode Program
bytecode: {
  shape: rectangle
  label: "Bytecode Program\n(Covering Index Scan)"
  style.fill: "#FFEBEE"
  opcodes: |`plaintext
    0: OpenRead    csr=1  root=3  (idx_email)
    1: String8     r1='alice@example.com'
    2: SeekGE      csr=1  r1
    3: Column      csr=1  col=0  → r2
    4: ResultRow   r2     1
    5: Close       csr=1
    6: Halt
  `|
  note: {
    shape: text
    label: "✓ NO SeekRowid opcode!\n✓ NO table lookup!\n✓ All data from index!"
    style.bold: true
    style.fill: "#C8E6C9"
  }
}
# B+tree Index
index_btree: {
  shape: cylinder
  label: "B+tree Index\nidx_email"
  style.fill: "#E3F2FD"
  index_structure: |`plaintext
    Index Leaf Cells:
    ┌─────────────────────────┐
    │ key: alice@example.com  │
    │ rowid: 1                │
    │ (email value in key!)   │
    └─────────────────────────┘
    ┌─────────────────────────┐
    │ key: bob@example.com    │
    │ rowid: 2                │
    └─────────────────────────┘
  `|
}
# Result
result: {
  shape: rectangle
  label: "Result\nemail='alice@example.com'"
  style.fill: "#E8F5E9"
}
# Table (NOT ACCESSED)
table_btree: {
  shape: cylinder
  label: "Table B+tree\nusers"
  style.fill: "#FFCDD2"
  style.stroke-dash: 3
  skip_label: {
    shape: text
    label: "⨯ SKIPPED\n(No table lookup\nrequired!)"
    style.bold: true
  }
}
# Comparison Box
comparison: {
  shape: rectangle
  label: "Comparison: Normal vs Covering Index"
  style.fill: "#FAFAFA"
  normal: {
    shape: rectangle
    label: "Normal Index Scan\n(Double Lookup)"
    style.fill: "#FFCDD2"
    normal_ops: |`plaintext
      OpenRead csr=1 (index)
      OpenRead csr=2 (table)  ← Extra!
      SeekGE csr=1
      Column csr=1 col=0 → r1
      SeekRowid csr=2 r1  ← TABLE LOOKUP
      Column csr=2 col=2 → r2
      ResultRow r2
    `|
  }
  covering: {
    shape: rectangle
    label: "Covering Index Scan\n(Index Only)"
    style.fill: "#C8E6C9"
    covering_ops: |`plaintext
      OpenRead csr=1 (index)
      SeekGE csr=1
      Column csr=1 col=0 → r1
      ResultRow r1
      -- SeekRowid ELIMINATED --
    `|
  }
}
# Flow Connections
query_input -> parser: "1. Parse"
parser -> planner: "2. AST"
planner -> covering_decision: "3. Check\ncolumns"
covering_decision -> yes_label: {
  style.stroke: "#4CAF50"
  style.stroke-width: 3
}
yes_label -> vdbe_compiler: "4. Generate\noptimized bytecode"
vdbe_compiler -> bytecode: "5. Program"
bytecode -> index_btree: "6. Execute\nSeekGE + Column"
index_btree -> result: "7. Return\ndirectly"
# Show skipped table
bytecode -> table_btree: {
  style.stroke-dash: 3
  style.stroke: "#B71C1C"
  label: "✗ NOT\nACCESSED"
}
# Comparison note
bytecode -> comparison: {
  style.stroke-dash: 2
  style.stroke: "#9E9E9E"
  label: "Compare"
}
# Legend
legend: {
  shape: rectangle
  label: "Covering Index Benefits\n\n• Eliminates SeekRowid opcode\n• Skips table B+tree lookup\n• Fewer I/O operations\n• Better cache locality\n• Faster query execution"
  style.fill: "#E8F5E9"
}