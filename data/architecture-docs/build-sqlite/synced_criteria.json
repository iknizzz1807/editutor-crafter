[
  {
    "milestone_id": "build-sqlite-m1",
    "criteria": [
      "Tokenizer recognizes SQL keywords (SELECT, INSERT, CREATE, WHERE, JOIN, etc.) case-insensitively",
      "String literals enclosed in single quotes are parsed including escaped quotes ('it''s' → it's)",
      "Numeric literals including integers and floating-point values (42, 3.14, -7) are recognized as distinct token types",
      "Operators (=, <, >, <=, >=, !=, <>) and punctuation (comma, parentheses, semicolon) are tokenized as distinct tokens",
      "Identifiers (table names, column names) support quoted identifiers with double quotes (\"column name\")",
      "Tokenizer reports error position (line and column) for unrecognized characters",
      "Token stream correctly tokenizes at least 20 diverse SQL statements in a test suite",
      "The tokenizer returns a list or stream of objects containing type, value, line, and column"
    ]
  },
  {
    "milestone_id": "build-sqlite-m2",
    "criteria": [
      "Tokenizer output is correctly consumed as parser input (token stream integration)",
      "SELECT parser produces AST with column list including * wildcard support",
      "SELECT parser produces AST with FROM clause containing table name",
      "SELECT parser produces optional WHERE clause as Expression node",
      "SELECT parser produces optional ORDER BY clause with column names and ASC/DESC",
      "SELECT parser produces optional LIMIT clause with numeric value",
      "INSERT parser produces AST with target table name",
      "INSERT parser produces optional column name list before VALUES",
      "INSERT parser produces VALUES clause with one or more tuples of expressions",
      "CREATE TABLE parser extracts table name from statement",
      "CREATE TABLE parser extracts column definitions with names and data types (INTEGER, TEXT, REAL, BLOB)",
      "CREATE TABLE parser extracts column constraints (PRIMARY KEY, NOT NULL, UNIQUE)",
      "Expression parser correctly handles operator precedence: NOT > comparison > AND > OR",
      "Parenthesized expressions correctly override default precedence levels",
      "Binary expressions (AND, OR, comparison operators) produce BinaryExpression AST nodes",
      "Unary NOT expression produces UnaryExpression AST node",
      "Parser provides error position (line and column) for syntax errors",
      "Parser reports meaningful error messages for unexpected tokens",
      "NULL keyword is parsed as LiteralExpression not IdentifierExpression",
      "String and numeric literals are parsed as LiteralExpression nodes",
      "Column references are parsed as IdentifierExpression nodes",
      "Test suite passes for 15+ valid SQL statements across SELECT, INSERT, and CREATE TABLE",
      "Test suite correctly rejects 10+ invalid SQL statements with position information"
    ]
  },
  {
    "milestone_id": "build-sqlite-m3",
    "criteria": [
      "Compiler translates SELECT AST into a bytecode program with opcodes for OpenTable, Rewind, Column, ResultRow, Next, Halt",
      "Compiler translates INSERT AST into bytecode with opcodes for OpenTable, MakeRecord, Insert, Halt",
      "Virtual machine executes bytecode programs step-by-step, processing one opcode per cycle",
      "VM maintains a register file (array of typed values) for intermediate computation",
      "EXPLAIN command outputs the bytecode program for a given SQL statement in human-readable format",
      "WHERE clause compiles to conditional jump opcodes that skip non-matching rows",
      "Bytecode execution of SELECT * FROM t on a 10,000-row table completes in under 100ms"
    ]
  },
  {
    "milestone_id": "build-sqlite-m4",
    "criteria": [
      "Buffer pool manages a configurable number of in-memory page frames (default 1000 pages)",
      "Pages are fixed-size (4096 bytes by default, configurable)",
      "FetchPage loads a page from disk into a free frame, or returns the cached frame if already resident",
      "LRU eviction selects the least recently used unpinned page for replacement when no free frames exist",
      "Dirty page tracking marks pages modified in memory; eviction writes dirty pages to disk before replacement",
      "Pin/Unpin mechanism prevents eviction of pages currently in use by B-tree operations",
      "FlushAll writes all dirty pages to disk (used before checkpoint or shutdown)",
      "Buffer pool hit rate is measurable and logged for performance tuning",
      "Buffer pool initializes with a fixed number of 4096-byte frames",
      "FetchPage returns the correct page from memory if already loaded (hit)",
      "FetchPage loads page from disk if not in memory (miss)",
      "LRU algorithm correctly identifies the least recently used page for eviction",
      "Pinned pages (count > 0) are never selected for eviction",
      "Dirty pages are written back to disk only when evicted or on FlushAll",
      "Buffer pool hit rate is tracked and accessible for performance metrics"
    ]
  },
  {
    "milestone_id": "build-sqlite-m5",
    "criteria": [
      "Page header contains page type (leaf/internal, table/index), cell count, free space pointer, and right-child pointer (internal only)",
      "Table B-tree leaf pages store rows keyed by rowid with variable-length record encoding",
      "Table B-tree internal pages store rowid separator keys and child page numbers",
      "Index B+tree leaf pages store (indexed column value, rowid) pairs with data only in leaves",
      "Index B+tree internal pages store only separator keys and child pointers (no row data)",
      "CREATE TABLE creates a B-tree root page and records the schema in a system catalog (sqlite_master equivalent)",
      "INSERT serializes a row and inserts into the correct B-tree leaf; node splitting creates a new page and promotes a separator key",
      "Full table scan traverses all leaf pages in rowid order, returning all rows",
      "Pages serialize to and deserialize from exactly 4096-byte buffers via the buffer pool",
      "Slotted page format implements bidirectional growth (pointers vs cells)",
      "Node split algorithm correctly rebalances the tree and promotes keys to parents",
      "Varint implementation handles 1-9 byte encoding for 64-bit integers",
      "System catalog (sqlite_master) persists table root page numbers"
    ]
  },
  {
    "milestone_id": "build-sqlite-m6",
    "criteria": [
      "SELECT * FROM table returns all rows in rowid order via B-tree leaf scan",
      "SELECT col1, col2 returns only specified columns (projection)",
      "WHERE clause filters rows during scan, evaluating boolean expressions on deserialized column values",
      "INSERT adds a row to the B-tree; subsequent SELECT returns the inserted data",
      "UPDATE modifies columns in rows matching WHERE; subsequent SELECT reflects changes",
      "DELETE removes rows matching WHERE; subsequent SELECT no longer returns them",
      "NOT NULL constraint rejects INSERT or UPDATE setting a NOT NULL column to null",
      "Operations on non-existent tables return an error with the table name",
      "WHERE clause correctly filters rows using Three-Valued Logic (NULL = NULL evaluates to NULL, not TRUE)",
      "Column projection correctly deserializes variable-length records to extract requested fields",
      "INSERT with NULL for INTEGER PRIMARY KEY triggers auto-increment behavior",
      "UPDATE cannot change the rowid (primary key) - must reject or handle as delete+insert",
      "DELETE during iteration uses two-pass approach to avoid cursor corruption"
    ]
  },
  {
    "milestone_id": "build-sqlite-m7",
    "criteria": [
      "CREATE INDEX builds a B+tree index mapping (indexed column value → rowid) from existing table data",
      "Index is automatically maintained on INSERT, UPDATE, and DELETE (index entries added/removed/updated)",
      "Index lookup retrieves rows matching an equality predicate without full table scan, verified by counting pages read",
      "Range scan on index returns rows within a value range using B+tree leaf traversal",
      "Query execution uses index scan when an indexed column appears in WHERE with equality or range predicate",
      "UNIQUE index rejects INSERT or UPDATE that would create duplicate values",
      "CREATE INDEX builds a B+tree mapping column values to rowids",
      "INSERT/UPDATE/DELETE operations maintain all associated indexes synchronously",
      "Index lookup (equality) avoids full table scan and visits significantly fewer pages",
      "Index range scan (BETWEEN or < >) traverses linked leaf pages",
      "UNIQUE index correctly rejects duplicate value insertions",
      "Bytecode VM can perform a 'Double Lookup' from index cursor to table cursor"
    ]
  },
  {
    "milestone_id": "build-sqlite-m8",
    "criteria": [
      "ANALYZE command collects row count per table and distinct value count per indexed column",
      "Cost model estimates pages read for full table scan based on total pages",
      "Cost model estimates I/O cost for index scan based on selectivity and random I/O factor",
      "Planner selects index scan when estimated selectivity is below threshold (e.g., 20%)",
      "Planner falls back to table scan when no suitable index exists or selectivity is too high",
      "EXPLAIN displays the chosen plan including scan type, index name if used, and estimated row count",
      "For multi-table queries, planner estimates join cardinality and considers join order to minimize intermediate result size"
    ]
  },
  {
    "milestone_id": "build-sqlite-m9",
    "criteria": [
      "BEGIN starts a transaction and buffers all subsequent writes until COMMIT or ROLLBACK",
      "COMMIT makes all changes permanent by flushing dirty pages and removing the rollback journal",
      "ROLLBACK undoes all changes by restoring original pages from the rollback journal",
      "Rollback journal records original page contents BEFORE any modification to the database file",
      "Changes are not visible to other database connections until COMMIT completes",
      "Crash recovery on startup detects an existing rollback journal and automatically rolls back the incomplete transaction",
      "Journal file is fsync'd before modified pages are written to the database file (write ordering guarantee)",
      "BEGIN/COMMIT/ROLLBACK commands correctly toggle the transaction manager state",
      "A .db-journal file is created and contains original page data before any write to the main .db file",
      "The journal file is physically flushed to disk (fsync) before the main database is modified",
      "A manual ROLLBACK restores the database state from the journal and deletes the journal file",
      "Startup logic detects a 'Hot Journal' and automatically restores the database to a consistent state"
    ]
  },
  {
    "milestone_id": "build-sqlite-m10",
    "criteria": [
      "WAL mode appends modified pages to a separate WAL file instead of modifying the main database file",
      "Writers append to WAL; readers check WAL for the most recent version of a page before reading from the main database",
      "Multiple readers can execute queries concurrently while a single writer appends to the WAL",
      "Checkpoint (PRAGMA wal_checkpoint) copies WAL pages back into the main database file",
      "WAL checkpoint is required to prevent unbounded WAL growth—auto-checkpoint triggers after configurable page count (default 1000)",
      "Readers see a consistent snapshot: a reader that starts before a commit does not see that commit's changes (snapshot isolation for reads)",
      "WAL file corruption is detected via page checksums",
      "Writers append to a separate WAL file instead of modifying the main .db file",
      "Readers search the WAL for the most recent page version before falling back to the main file",
      "Writers and multiple readers can operate simultaneously without blocking",
      "Checkpointing copies WAL pages to the main database and truncates the WAL",
      "Automatic checkpoint triggers after 1000 pages (configurable)",
      "Readers use a consistent snapshot based on the WAL state at their start time",
      "Checksums are used to detect and reject corrupted WAL frames"
    ]
  },
  {
    "milestone_id": "build-sqlite-m11",
    "criteria": [
      "COUNT(*) returns the number of rows including NULLs",
      "COUNT(col) returns count of non-NULL values only",
      "SUM produces correct results over grouped and ungrouped queries",
      "AVG returns REAL/float even if input column is INTEGER",
      "AVG ignores NULL values in computation",
      "MIN and MAX produce correct results over grouped and ungrouped queries",
      "GROUP BY partitions rows into groups before applying aggregate functions",
      "GROUP BY without ORDER BY can return groups in any order",
      "HAVING filters groups after aggregation based on aggregate values",
      "INNER JOIN combines rows from two tables matching a join condition",
      "Nested loop join is implemented as the baseline join algorithm",
      "JOIN with WHERE clause filters correctly after or during join",
      "Empty table with aggregates returns appropriate default values (0 for COUNT, NULL for SUM/AVG)",
      "Multiple aggregates can be computed in a single query"
    ]
  }
]