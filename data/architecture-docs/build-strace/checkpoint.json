{
  "project_id": "build-strace",
  "meta": {
    "id": "build-strace",
    "name": "System Call Tracer (strace clone)",
    "description": "ptrace-based syscall interception and decoding for x86_64 Linux",
    "difficulty": "intermediate",
    "estimated_hours": "22-35",
    "essence": "Process introspection through kernel-mediated interception of system calls on x86_64 Linux, requiring register manipulation, word-by-word argument decoding from tracee memory, and process state management across fork/exec boundaries.\n",
    "why_important": "Understanding ptrace-based tracing reveals how debuggers, profilers, and security tools interact with the kernel to observe program behavior \u2014 foundational knowledge for systems programming and tooling development.\n",
    "learning_outcomes": [
      "Implement ptrace-based process attachment and syscall interception using PTRACE_SYSCALL",
      "Track syscall entry/exit state to correctly read arguments vs return values",
      "Decode syscall arguments by reading registers and dereferencing pointers from tracee memory word-by-word",
      "Handle multi-process tracing across fork and exec with PTRACE_O_TRACEFORK",
      "Build syscall filtering and timing statistics",
      "Handle signal delivery to traced processes correctly"
    ],
    "skills": [
      "ptrace System Call",
      "x86_64 Syscall ABI",
      "Process Control",
      "Register Manipulation",
      "Remote Memory Inspection",
      "Signal Handling in Traced Processes",
      "Multi-process Debugging"
    ],
    "tags": [
      "ptrace",
      "debugging",
      "system-calls",
      "linux",
      "x86_64",
      "process-control"
    ],
    "architecture_doc": "architecture-docs/build-strace/index.md",
    "languages": {
      "recommended": [
        "C",
        "Rust"
      ],
      "also_possible": [
        "Go"
      ]
    },
    "resources": [
      {
        "name": "ptrace(2) man page",
        "url": "https://man7.org/linux/man-pages/man2/ptrace.2.html",
        "type": "reference"
      },
      {
        "name": "How strace works",
        "url": "https://blog.packagecloud.io/how-does-strace-work/",
        "type": "article"
      },
      {
        "name": "x86_64 syscall table",
        "url": "https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/",
        "type": "reference"
      }
    ],
    "prerequisites": [
      {
        "type": "project",
        "name": "process-spawner"
      },
      {
        "type": "project",
        "name": "signal-handler"
      }
    ],
    "milestones": [
      {
        "id": "build-strace-m1",
        "name": "Basic ptrace Syscall Intercept",
        "description": "Use ptrace to trace a child process, stopping at each syscall entry and exit. Target architecture: x86_64 Linux.\n",
        "acceptance_criteria": [
          "Fork a child process; child calls PTRACE_TRACEME then exec's the target program",
          "Parent uses PTRACE_SYSCALL + waitpid loop to stop the child at each syscall boundary",
          "Explicitly track entry/exit state with a toggle flag: on entry, read syscall number from orig_rax register; on exit, read return value from rax register",
          "Print syscall number and return value for each intercepted syscall (e.g., \"syscall(0) = 5\")",
          "Detect error returns: on x86_64, return values in range [-4096, -1] indicate error; display as -1 ERRNO (e.g., -1 ENOENT\")\"",
          "Handle signals delivered to the tracee: when waitpid reports a signal-delivery stop (not a syscall stop), re-inject the signal using PTRACE_SYSCALL with the signal number, do not suppress it",
          "Handle tracee exit cleanly: detect WIFEXITED/WIFSIGNALED from waitpid and exit the tracer"
        ],
        "pitfalls": [
          "ptrace stops twice per syscall (entry and exit); failing to toggle state causes argument reads on exit and return-value reads on entry, producing garbage output",
          "Register layout is x86_64-specific: orig_rax for syscall number, rax for return value; on i386 it's orig_eax/eax, on ARM it's completely different",
          "PTRACE_TRACEME must be called in the child BEFORE exec(); after exec the tracee stops automatically on the first signal (SIGTRAP)",
          "Signal stops and syscall stops are both reported via waitpid; must distinguish them using PTRACE_O_TRACESYSGOOD (sets bit 7 of signal in status) or by checking the signal number",
          "Suppressing signals intended for the tracee (by passing 0 to PTRACE_SYSCALL instead of the signal number) breaks the traced program"
        ],
        "concepts": [
          "ptrace system call and tracing lifecycle",
          "x86_64 syscall ABI (register conventions)",
          "Syscall entry/exit state tracking",
          "Signal delivery in traced processes"
        ],
        "skills": [
          "ptrace API usage",
          "Process control with waitpid",
          "x86_64 register inspection",
          "Signal handling in tracer context"
        ],
        "deliverables": [
          "Child process creation with PTRACE_TRACEME + exec",
          "PTRACE_SYSCALL + waitpid interception loop",
          "Entry/exit toggle with correct register reads",
          "Error return detection with errno mapping",
          "Signal re-injection for non-syscall stops"
        ],
        "estimated_hours": "5-8"
      },
      {
        "id": "build-strace-m2",
        "name": "Argument Decoding",
        "description": "Map syscall numbers to names and decode arguments including strings read word-by-word from tracee memory.\n",
        "acceptance_criteria": [
          "Map x86_64 syscall numbers to human-readable names using a syscall table (at least the 50 most common syscalls)",
          "Decode integer arguments from x86_64 argument registers: rdi, rsi, rdx, r10, r8, r9 (in that order)",
          "Read string arguments (e.g., file paths for open/stat) from tracee memory using PTRACE_PEEKDATA in a word-by-word loop until a null terminator byte is found within a read word",
          "Handle PTRACE_PEEKDATA correctly: set errno to 0 before call, check errno after (since -1 is both a valid data value and an error indicator)",
          "Truncate displayed strings at a configurable maximum length (default 32 bytes) with \"...\" suffix",
          "Format output matching strace style: syscall_name(arg1, arg2, ...) = return_value (e.g., 'open(/etc/passwd\", O_RDONLY) = 3')\"",
          "Decode flag arguments for common syscalls: open() flags (O_RDONLY, O_WRONLY, O_CREAT), mmap() prot and flags"
        ],
        "pitfalls": [
          "PTRACE_PEEKDATA reads one word (8 bytes on x86_64) at a time; string reading requires looping and scanning each word for a null byte, handling the case where the null is in the middle of a word",
          "PTRACE_PEEKDATA returns -1 on error but -1 (0xFFFFFFFFFFFFFFFF) is also valid data; must pre-clear errno and check it to distinguish error from data",
          "Some syscalls have different argument semantics depending on flags (e.g., clone's arguments vary by flag bits); decode common cases, skip exotic ones",
          "String pointers may be NULL (e.g., execve with NULL envp); must check for NULL before attempting PEEKDATA",
          "Buffer overread: a string in the tracee might not be null-terminated within readable memory; set a maximum read length to prevent infinite loops"
        ],
        "concepts": [
          "x86_64 syscall ABI argument registers",
          "Remote process memory reading (PTRACE_PEEKDATA)",
          "Word-by-word string extraction with null terminator scan",
          "Flag decoding with bitmask analysis"
        ],
        "skills": [
          "Remote memory access across address spaces",
          "Syscall ABI knowledge and argument interpretation",
          "String marshalling from word-aligned reads",
          "Bitmask flag decoding"
        ],
        "deliverables": [
          "Syscall number-to-name mapping table for x86_64",
          "Register-based argument extraction per syscall signature",
          "Word-by-word string reader with null terminator detection and length limit",
          "Flag decoder for common syscalls (open, mmap, etc.)",
          "strace-style formatted output"
        ],
        "estimated_hours": "6-8"
      },
      {
        "id": "build-strace-m3",
        "name": "Multi-Process and Fork Following",
        "description": "Handle traced processes that fork or exec, tracing all descendants.\n",
        "acceptance_criteria": [
          "Set PTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK, and PTRACE_O_TRACECLONE options on the tracee so child processes are automatically traced",
          "Use waitpid(-1, ...) to catch events from ANY traced process (not just the original)",
          "Detect fork/vfork/clone events via PTRACE_EVENT_FORK/VFORK/CLONE and retrieve new child PID with PTRACE_GETEVENTMSG",
          "Tag all output lines with the PID of the process that made the syscall (e.g., \"[pid 1234] open(...) = 3\")",
          "Handle PTRACE_EVENT_EXEC correctly: the tracee's memory map changes entirely after exec; reset any cached state for that PID",
          "Handle multiple simultaneously traced processes without losing events or mixing up entry/exit state between PIDs",
          "Maintain per-PID state tracking (entry/exit toggle, current syscall number) in a hash map"
        ],
        "pitfalls": [
          "Must set PTRACE_O_TRACEFORK BEFORE the tracee calls fork, otherwise the child runs untraced and may exit before we can attach",
          "waitpid(-1) returns events from any traced child; must dispatch to the correct per-PID state based on the returned PID",
          "PTRACE_EVENT_EXEC stops look like SIGTRAP stops; must use status>>16 to extract the event type",
          "After exec, the tracee has a new memory map; any cached memory pointers or string addresses from before exec are invalid",
          "A traced child that forks creates a grandchild that must also be traced; this requires the PTRACE_O_TRACE* options to be inherited"
        ],
        "concepts": [
          "Multi-process ptrace tracing",
          "PTRACE_EVENT dispatching",
          "Per-PID state management",
          "Fork/exec lifecycle in traced processes"
        ],
        "skills": [
          "Multi-process coordination",
          "Event-driven process management",
          "Per-process state tracking with hash maps",
          "ptrace option configuration"
        ],
        "deliverables": [
          "PTRACE_O_TRACE* option setup for automatic child tracing",
          "waitpid(-1) loop handling events from all traced processes",
          "Per-PID state map tracking entry/exit toggle and current syscall",
          "PID-tagged output for multi-process traces",
          "Correct exec handling resetting per-PID cached state"
        ],
        "estimated_hours": "5-8"
      },
      {
        "id": "build-strace-m4",
        "name": "Filtering and Statistics",
        "description": "Add syscall filtering by name and generate timing/frequency statistics.\n",
        "acceptance_criteria": [
          "Filter output to show only specified syscalls by name (e.g., -e trace=open,read,write); unmatched syscalls are still traced (for dependency tracking) but not printed",
          "Collect per-syscall wall-clock timing using clock_gettime(CLOCK_MONOTONIC): record time at entry, compute duration at exit",
          "Generate summary table (like strace -c) showing: syscall name, call count, error count, cumulative time, percentage of total time; sorted by cumulative time descending",
          "Support -o filename flag to redirect trace output to a file instead of stderr",
          "Support -p PID flag to attach to an already-running process using PTRACE_ATTACH (instead of fork+exec)",
          "Detach cleanly from attached process on tracer exit or SIGINT using PTRACE_DETACH"
        ],
        "pitfalls": [
          "Timing must use CLOCK_MONOTONIC not CLOCK_REALTIME; CLOCK_REALTIME is subject to NTP adjustments that can produce negative durations",
          "Error detection requires checking if the x86_64 return value is in [-4096, -1]; simply checking < 0 misclassifies legitimate negative return values",
          "PTRACE_ATTACH sends SIGSTOP to the target; must waitpid for the SIGSTOP before beginning PTRACE_SYSCALL tracing",
          "File output with -o must handle concurrent writes from multiple traced processes; use per-line write() calls or a mutex",
          "Signal filter: when attached to a running process, existing signal handlers must not be disrupted; always re-inject signals"
        ],
        "concepts": [
          "Syscall filtering and pattern matching",
          "High-resolution timing with CLOCK_MONOTONIC",
          "Statistical aggregation and reporting",
          "Process attachment vs fork-based tracing"
        ],
        "skills": [
          "Performance profiling and timing",
          "Statistical data collection",
          "PTRACE_ATTACH lifecycle management",
          "Output management and file redirection"
        ],
        "deliverables": [
          "Syscall name filter with -e trace=name,name syntax",
          "Per-syscall timing with CLOCK_MONOTONIC",
          "Summary statistics table (count, errors, time, percentage)",
          "File output option with -o flag",
          "PTRACE_ATTACH support for tracing running processes with -p PID",
          "Clean detach on exit/signal"
        ],
        "estimated_hours": "6-10"
      }
    ],
    "domain": "systems"
  },
  "blueprint": {
    "title": "System Call Tracer (strace clone)",
    "overview": "This project builds a fully functional strace clone from scratch \u2014 a ptrace-based system call tracer that intercepts, decodes, and reports every syscall a target process makes on x86_64 Linux. You will start by forking a child, attaching via ptrace, and toggling between syscall entry and exit stops. Then you'll decode arguments by reading registers, dereference string pointers word-by-word from the tracee's address space, follow fork/exec across process boundaries, and finally add filtering and statistical profiling.\n\nThe project is a window into the kernel-userspace boundary. Every syscall is a precisely choreographed register dance: the application loads arguments into rdi, rsi, rdx, r10, r8, r9, puts the syscall number in rax, and executes the `syscall` instruction. The kernel saves state, dispatches, and returns a result in rax. Your tracer sits in between, mediated by ptrace, observing this dance twice per call \u2014 once on entry, once on exit. Understanding this mechanism is foundational to debuggers (GDB), sandboxes (seccomp), profilers (perf), and container runtimes.\n\nBy the end, you'll have a tool that can attach to any process, print decoded syscall traces with arguments, follow multi-process workloads, filter by syscall name, and produce timing statistics \u2014 the core functionality of the real strace.",
    "design_philosophy": "This project teaches by making the invisible visible. Syscalls are the most important abstraction boundary in any operating system, yet most developers treat them as opaque function calls. By building a tracer, you are forced to understand: (1) the exact register-level ABI contract between userspace and kernel, (2) how processes exist as state machines that the kernel can freeze and inspect, (3) how memory isolation works and how ptrace punctures it with PEEKDATA, and (4) how fork/exec create new process identities while maintaining tracing relationships. Each milestone peels back one more layer of the kernel's process management machinery.",
    "is_build_your_own": true,
    "implementation": {
      "primary_language": "C",
      "rationale": "ptrace is a C-native API with pointer-sized word semantics, errno-based error signaling, and register structures defined in C headers (<sys/ptrace.h>, <sys/user.h>, <sys/wait.h>). The project's core challenge \u2014 reading words from tracee memory, interpreting register structures, handling the errno-vs-valid-data ambiguity of PTRACE_PEEKDATA \u2014 maps directly to C idioms. The real strace is written in C. Using C also forces the learner to confront manual memory management for per-PID state maps and string buffers, which is the point of a systems project.",
      "style_guide": "Linux kernel style: snake_case for functions and variables, UPPER_CASE for constants/macros, 8-space tabs or 4-space indentation (we'll use 4-space for readability), braces on same line for functions. Use stdint.h types (uint64_t, int64_t) for register values. All structs padded explicitly. Error handling via goto cleanup pattern.",
      "build_system": "Makefile with gcc, -Wall -Wextra -Werror -std=c11 -g -O2. Separate compilation units per milestone. Optional: CMake for IDE integration.",
      "alternatives": [
        "Rust \u2014 viable with nix crate for ptrace bindings, but adds abstraction over the raw errno/PEEKDATA semantics that are the learning point",
        "Go \u2014 possible via syscall.PtraceSyscall but Go's runtime (goroutines, GC) adds confounding complexity when tracing fork/exec"
      ]
    },
    "prerequisites": {
      "assumed_known": [
        "C programming: pointers, structs, arrays, bitwise operations",
        "Basic Linux command line and process concepts (PID, stdin/stdout/stderr)",
        "fork() and exec() system calls at a conceptual level",
        "What a system call is (userspace \u2192 kernel transition)",
        "Basic signal concepts (SIGTERM, SIGKILL, SIGINT)",
        "Compilation with gcc and Makefiles"
      ],
      "must_teach_first": [
        {
          "concept": "ptrace lifecycle and request types",
          "depth": "thorough",
          "when": "Milestone 1 \u2014 before any code"
        },
        {
          "concept": "x86_64 syscall ABI \u2014 which registers hold what",
          "depth": "thorough",
          "when": "Milestone 1 \u2014 register inspection"
        },
        {
          "concept": "waitpid status macros (WIFEXITED, WIFSTOPPED, WIFSIGNALED, WSTOPSIG)",
          "depth": "thorough",
          "when": "Milestone 1 \u2014 the interception loop"
        },
        {
          "concept": "The difference between syscall-delivery-stop and signal-delivery-stop",
          "depth": "basic",
          "when": "Milestone 1 \u2014 signal re-injection"
        },
        {
          "concept": "PTRACE_PEEKDATA word semantics and errno ambiguity",
          "depth": "thorough",
          "when": "Milestone 2 \u2014 string reading"
        },
        {
          "concept": "ptrace event stops (PTRACE_EVENT_FORK etc.) and status>>16 decoding",
          "depth": "thorough",
          "when": "Milestone 3 \u2014 multi-process"
        },
        {
          "concept": "CLOCK_MONOTONIC vs CLOCK_REALTIME",
          "depth": "basic",
          "when": "Milestone 4 \u2014 timing"
        }
      ]
    },
    "milestones": [
      {
        "id": "build-strace-m1",
        "title": "Basic ptrace Syscall Intercept",
        "anchor_id": "anchor-m1-basic-intercept",
        "summary": "Fork a child process, have it call PTRACE_TRACEME and exec the target, then run a PTRACE_SYSCALL + waitpid loop in the parent to stop at every syscall entry and exit. Track entry/exit state with a toggle flag, read the syscall number from orig_rax on entry and the return value from rax on exit. Detect errno-range errors, re-inject signals, and handle tracee termination.",
        "misconception": "Developers assume ptrace stops the child once per syscall \u2014 you call PTRACE_SYSCALL, the child runs the syscall, and you get the result. It's like intercepting a function call: one stop, one result.",
        "reveal": "ptrace stops the tracee TWICE per syscall: once at entry (before the kernel executes it) and once at exit (after). These two stops look identical from waitpid's perspective \u2014 both report SIGTRAP. The tracer must maintain its own toggle flag to know which stop it's at. Reading rax on entry gives you stale data from the previous syscall's return; reading orig_rax on exit still works but you're supposed to read arguments on entry only. This double-stop model is the single most confusing aspect of ptrace and the source of most beginner bugs.",
        "cascade": [
          "Debugger breakpoints (GDB) \u2014 GDB uses the same ptrace stops but with PTRACE_SINGLESTEP; understanding entry/exit explains how GDB can modify syscall arguments in flight",
          "seccomp-BPF (cross-domain: security) \u2014 seccomp filters run at syscall entry only, which is why they can block calls but can't inspect return values; the entry/exit distinction maps directly",
          "Strace's -e inject feature \u2014 once you understand the two-stop model, you can modify registers between entry and exit to fake syscall results, which is the basis for fault injection testing",
          "Container runtimes (cross-domain: DevOps) \u2014 runc uses ptrace during container setup to intercept syscalls the container shouldn't make; this entry-stop is where seccomp handoff happens",
          "CPU syscall instruction \u2014 the x86_64 `syscall` instruction saves RIP to RCX and RFLAGS to R11, then jumps to the kernel entry point; orig_rax exists because the kernel may clobber rax during dispatch"
        ],
        "yaml_acceptance_criteria": [
          "Fork a child process; child calls PTRACE_TRACEME then exec's the target program",
          "Parent uses PTRACE_SYSCALL + waitpid loop to stop the child at each syscall boundary",
          "Explicitly track entry/exit state with a toggle flag: on entry, read syscall number from orig_rax register; on exit, read return value from rax register",
          "Print syscall number and return value for each intercepted syscall (e.g., \"syscall(0) = 5\")",
          "Detect error returns: on x86_64, return values in range [-4096, -1] indicate error; display as -1 ERRNO (e.g., \"-1 ENOENT\")",
          "Handle signals delivered to the tracee: when waitpid reports a signal-delivery stop (not a syscall stop), re-inject the signal using PTRACE_SYSCALL with the signal number, do not suppress it",
          "Handle tracee exit cleanly: detect WIFEXITED/WIFSIGNALED from waitpid and exit the tracer"
        ]
      },
      {
        "id": "build-strace-m2",
        "title": "Argument Decoding",
        "anchor_id": "anchor-m2-arg-decode",
        "summary": "Map syscall numbers to human-readable names via a lookup table. Extract arguments from the six x86_64 argument registers (rdi, rsi, rdx, r10, r8, r9). Read string arguments from tracee memory word-by-word using PTRACE_PEEKDATA, scanning each 8-byte word for a null terminator. Decode bitmask flags for common syscalls. Format output in strace style.",
        "misconception": "Developers assume reading a string from another process is like reading from shared memory \u2014 just dereference the pointer. After all, if the tracee passed a pointer to the kernel, can't we just read that address?",
        "reveal": "Each process has its own virtual address space. The pointer 0x7ffd1234abcd in the tracee maps to a completely different physical page (or no page at all) in the tracer. PTRACE_PEEKDATA is the only way to cross this boundary, and it reads exactly one word (8 bytes on x86_64) per call \u2014 a kernel-mediated, context-switching read. To extract a C string, you must loop: read a word, scan its bytes for '\\0', append valid bytes to a buffer, and repeat. This is why strace is slow \u2014 every string argument costs multiple ptrace round-trips through the kernel.",
        "cascade": [
          "/proc/PID/mem \u2014 an alternative to PEEKDATA that allows read() on the tracee's memory as a file, amortizing the per-word syscall overhead; this is how modern strace optimizes string reads",
          "process_vm_readv (cross-domain: performance engineering) \u2014 a single syscall that copies arbitrary regions between address spaces without context switches, 10-100x faster than PEEKDATA loops",
          "Virtual memory and page tables \u2014 the reason address spaces are isolated: each process has its own page table root (CR3 register), and the MMU translates virtual\u2192physical per-process",
          "GDB memory inspection \u2014 GDB's 'x' command uses the exact same PEEKDATA mechanism; now you understand why examining large memory regions in GDB is slow",
          "ELF string tables \u2014 the syscall name table you build mirrors how ELF binaries store symbol names: an array of null-terminated strings indexed by offset"
        ],
        "yaml_acceptance_criteria": [
          "Map x86_64 syscall numbers to human-readable names using a syscall table (at least the 50 most common syscalls)",
          "Decode integer arguments from x86_64 argument registers: rdi, rsi, rdx, r10, r8, r9 (in that order)",
          "Read string arguments (e.g., file paths for open/stat) from tracee memory using PTRACE_PEEKDATA in a word-by-word loop until a null terminator byte is found within a read word",
          "Handle PTRACE_PEEKDATA correctly: set errno to 0 before call, check errno after (since -1 is both a valid data value and an error indicator)",
          "Truncate displayed strings at a configurable maximum length (default 32 bytes) with \"...\" suffix",
          "Format output matching strace style: syscall_name(arg1, arg2, ...) = return_value (e.g., 'open(\"/etc/passwd\", O_RDONLY) = 3')",
          "Decode flag arguments for common syscalls: open() flags (O_RDONLY, O_WRONLY, O_CREAT), mmap() prot and flags"
        ]
      },
      {
        "id": "build-strace-m3",
        "title": "Multi-Process and Fork Following",
        "anchor_id": "anchor-m3-multi-process",
        "summary": "Set PTRACE_O_TRACEFORK/TRACEVFORK/TRACECLONE options so child processes are automatically traced. Switch from waitpid(child_pid) to waitpid(-1) to receive events from any traced process. Detect fork/clone events via status>>16, retrieve new PIDs with PTRACE_GETEVENTMSG, maintain a hash map of per-PID state (entry/exit toggle, current syscall number), tag output with PIDs, and handle exec events by resetting cached state.",
        "misconception": "Developers assume that fork() in the tracee creates a child that inherits the tracing relationship automatically \u2014 after all, the child inherits file descriptors, signal handlers, and memory; why not the ptrace attachment?",
        "reveal": "Tracing is NOT inherited across fork. By default, a forked child runs completely untraced and may exit before you even know it exists. You must explicitly opt-in via PTRACE_O_TRACEFORK (and friends) BEFORE the tracee forks. When the fork happens, the kernel delivers a PTRACE_EVENT_FORK stop to the parent-tracee, and the new child starts in a stopped state waiting for your PTRACE_SYSCALL. Without this, you get silent child processes running unwatched \u2014 and the bugs are non-deterministic because the child might finish before your tracer reacts.",
        "cascade": [
          "Container process trees (cross-domain: DevOps) \u2014 container runtimes must trace the entire process tree to enforce namespaces and cgroup limits; PTRACE_O_TRACEFORK is how they catch every descendant",
          "Process group and session leadership \u2014 fork following forces you to understand PID namespaces, process groups, and why waitpid(-1) is necessary: you can't predict which PID will stop next",
          "Race conditions in tracing \u2014 the window between fork() and PTRACE_ATTACH is a classic TOCTOU race; PTRACE_O_TRACEFORK eliminates it by making the kernel do the attachment atomically",
          "Hash map design for per-PID state \u2014 this is a practical exercise in choosing a data structure (open addressing vs chaining) for a hot-path lookup keyed by small integers (PIDs)",
          "Exec and address space replacement \u2014 PTRACE_EVENT_EXEC teaches you that exec() replaces the ENTIRE address space (text, data, heap, stack, mmap regions) but keeps the PID; any cached pointers are now dangling"
        ],
        "yaml_acceptance_criteria": [
          "Set PTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK, and PTRACE_O_TRACECLONE options on the tracee so child processes are automatically traced",
          "Use waitpid(-1, ...) to catch events from ANY traced process (not just the original)",
          "Detect fork/vfork/clone events via PTRACE_EVENT_FORK/VFORK/CLONE and retrieve new child PID with PTRACE_GETEVENTMSG",
          "Tag all output lines with the PID of the process that made the syscall (e.g., \"[pid 1234] open(...) = 3\")",
          "Handle PTRACE_EVENT_EXEC correctly: the tracee's memory map changes entirely after exec; reset any cached state for that PID",
          "Handle multiple simultaneously traced processes without losing events or mixing up entry/exit state between PIDs",
          "Maintain per-PID state tracking (entry/exit toggle, current syscall number) in a hash map"
        ]
      },
      {
        "id": "build-strace-m4",
        "title": "Filtering and Statistics",
        "anchor_id": "anchor-m4-filter-stats",
        "summary": "Add syscall name filtering (-e trace=open,read,write), per-syscall wall-clock timing using CLOCK_MONOTONIC, a summary statistics table (count, errors, cumulative time, percentage), file output with -o, PTRACE_ATTACH to running processes with -p PID, and clean detach on exit/SIGINT.",
        "misconception": "Developers assume timing a syscall is straightforward: just call clock_gettime() before and after the ptrace stop. The syscall takes however long the difference shows.",
        "reveal": "You're not timing the syscall itself \u2014 you're timing the syscall PLUS all the ptrace overhead. Each PTRACE_SYSCALL requires: (1) the tracer calling ptrace (a syscall itself), (2) the kernel scheduling the tracee, (3) the tracee running until the next syscall boundary, (4) the kernel stopping the tracee and waking the tracer, (5) waitpid returning in the tracer. This adds microseconds of overhead per stop. The real strace acknowledges this: its -c output warns 'wall clock time' not 'CPU time'. For fast syscalls (getpid ~100ns), the ptrace overhead exceeds the syscall time by 100x. Also, you must use CLOCK_MONOTONIC because CLOCK_REALTIME can jump backwards during NTP adjustments, producing negative durations.",
        "cascade": [
          "perf and eBPF (cross-domain: observability) \u2014 these tools avoid ptrace's overhead by running in-kernel; eBPF attaches programs directly to syscall tracepoints with near-zero overhead, which is why modern profiling has moved away from ptrace",
          "PTRACE_ATTACH vs PTRACE_SEIZE \u2014 ATTACH sends SIGSTOP which disrupts the target; SEIZE (newer API) avoids this, teaching the evolution of the ptrace API",
          "Profiling methodology (cross-domain: performance engineering) \u2014 the observer effect: instrumenting a system changes its behavior. Your tracer slows the tracee by 10-100x, which changes timing-sensitive behavior like lock contention and cache warming",
          "Signal safety during detach \u2014 PTRACE_DETACH must be called while the tracee is stopped; if you detach from a running tracee, you corrupt its state. Your SIGINT handler must coordinate this carefully",
          "Statistical aggregation patterns \u2014 computing running means, percentages, and sorted summaries from streaming data is a fundamental pattern in monitoring systems (Prometheus, statsd)"
        ],
        "yaml_acceptance_criteria": [
          "Filter output to show only specified syscalls by name (e.g., -e trace=open,read,write); unmatched syscalls are still traced (for dependency tracking) but not printed",
          "Collect per-syscall wall-clock timing using clock_gettime(CLOCK_MONOTONIC): record time at entry, compute duration at exit",
          "Generate summary table (like strace -c) showing: syscall name, call count, error count, cumulative time, percentage of total time; sorted by cumulative time descending",
          "Support -o filename flag to redirect trace output to a file instead of stderr",
          "Support -p PID flag to attach to an already-running process using PTRACE_ATTACH (instead of fork+exec)",
          "Detach cleanly from attached process on tracer exit or SIGINT using PTRACE_DETACH"
        ]
      }
    ],
    "diagrams": [
      {
        "id": "diag-satellite-map",
        "title": "System Call Tracer \u2014 Satellite Architecture Map",
        "description": "The top-level map showing all major components of the strace clone and how they connect: the tracer process, the tracee process, the kernel's ptrace infrastructure, the syscall table, the argument decoder, the per-PID state map, and the statistics/filter engine. Every milestone's components are placed in this map with anchor IDs. This is the 'Home Base' that every subsequent diagram references back to.",
        "anchor_target": "anchor-satellite",
        "level": "satellite"
      },
      {
        "id": "diag-m1-ptrace-lifecycle",
        "title": "ptrace Tracing Lifecycle: Fork \u2192 TRACEME \u2192 Exec \u2192 SYSCALL Loop",
        "description": "A state_evolution diagram showing the complete lifecycle: parent forks, child calls PTRACE_TRACEME, child calls execvp (which triggers an automatic SIGTRAP stop), parent calls waitpid and receives the initial stop, parent calls PTRACE_SYSCALL, child resumes and hits syscall entry, kernel stops child, parent reads registers, parent calls PTRACE_SYSCALL again, child enters kernel, kernel executes syscall, child exits syscall, kernel stops child again, parent reads return value. Annotated with which process is running at each step.",
        "anchor_target": "anchor-m1-basic-intercept",
        "level": "street"
      },
      {
        "id": "diag-m1-entry-exit-toggle",
        "title": "Syscall Entry/Exit Toggle State Machine",
        "description": "A state_evolution diagram showing the two-state machine (ENTRY \u2194 EXIT) that the tracer must maintain. On ENTRY state: read orig_rax for syscall number, read argument registers. Transition to EXIT. On EXIT state: read rax for return value, check error range [-4096, -1]. Transition to ENTRY. Shows what goes wrong if the toggle is not maintained: reading rax on entry gives stale return value from previous call.",
        "anchor_target": "anchor-m1-basic-intercept",
        "level": "microscopic"
      },
      {
        "id": "diag-m1-x86-registers",
        "title": "x86_64 Syscall Register Convention \u2014 struct user_regs_struct Layout",
        "description": "A structure_layout diagram showing the exact byte layout of struct user_regs_struct from <sys/user.h>. Highlights orig_rax (offset 120), rax (offset 80), and the six argument registers rdi (offset 112), rsi (offset 104), rdx (offset 96), r10 (offset 40), r8 (offset 72), r9 (offset 64) with their byte offsets. Shows which fields are read on entry vs exit.",
        "anchor_target": "anchor-m1-basic-intercept",
        "level": "microscopic"
      },
      {
        "id": "diag-m1-waitpid-status-decode",
        "title": "waitpid Status Word Bit Layout and Macro Dispatch",
        "description": "A structure_layout diagram showing the 32-bit waitpid status word: bits 0-6 for signal number if stopped, bit 7 for core dump flag, bits 8-15 for exit status or stop signal, bits 16-23 for ptrace event. Shows how WIFEXITED, WIFSTOPPED, WIFSIGNALED, WSTOPSIG, and (status>>16) extract information. Includes the PTRACE_O_TRACESYSGOOD bit (bit 7 of stop signal = 0x80) that distinguishes syscall stops from signal stops.",
        "anchor_target": "anchor-m1-basic-intercept",
        "level": "microscopic"
      },
      {
        "id": "diag-m1-signal-vs-syscall-stop",
        "title": "Signal-Delivery Stop vs Syscall Stop \u2014 Decision Tree",
        "description": "A data_walk decision tree showing how the tracer processes each waitpid return: check WIFEXITED \u2192 handle exit. Check WIFSIGNALED \u2192 handle termination. Check WIFSTOPPED \u2192 extract signal with WSTOPSIG. If signal == (SIGTRAP | 0x80) \u2192 syscall stop, process entry/exit. If signal == SIGTRAP and status>>16 != 0 \u2192 ptrace event. Otherwise \u2192 signal-delivery stop, re-inject via PTRACE_SYSCALL(pid, sig). Shows the consequence of passing 0 instead of the signal number: the tracee's signal is silently eaten.",
        "anchor_target": "anchor-m1-basic-intercept",
        "level": "street"
      },
      {
        "id": "diag-m1-error-detection",
        "title": "x86_64 Syscall Return Value Error Detection",
        "description": "A data_walk diagram showing how to interpret the rax return value. The kernel returns errors as negative errno values: rax = -ENOENT = -2 = 0xFFFFFFFFFFFFFFFE. The valid error range is [-4096, -1] (values like -ENOSYS = -38 through -EPERM = -1). Values outside this range are valid (e.g., mmap returning a high address like 0x7f...). Shows the cast to long, the range check, and the negation to recover the errno number. Includes a mini errno table.",
        "anchor_target": "anchor-m1-basic-intercept",
        "level": "microscopic"
      },
      {
        "id": "diag-m2-peekdata-word-walk",
        "title": "PTRACE_PEEKDATA Word-by-Word String Extraction",
        "description": "A data_walk diagram showing the step-by-step process of reading a string from tracee memory. The tracee has the string \"/etc/passwd\\0\" starting at address 0x7ffd0010. PEEKDATA reads 8 bytes at 0x7ffd0010 \u2192 gets '/etc/pas'. Scan each byte for \\0 \u2014 not found. PEEKDATA reads 8 bytes at 0x7ffd0018 \u2192 gets 'swd\\0????'. Scan \u2014 found \\0 at byte 3. Append 'swd' to buffer, stop. Shows memory alignment, the word boundary, and the null terminator hidden inside a word.",
        "anchor_target": "anchor-m2-arg-decode",
        "level": "microscopic"
      },
      {
        "id": "diag-m2-peekdata-errno-ambiguity",
        "title": "PEEKDATA's -1 Ambiguity: Error vs Valid Data",
        "description": "A before_after diagram. BEFORE: naive code calls ptrace(PEEKDATA, ...) and checks 'if (result == -1) \u2192 error'. But the tracee's memory legitimately contains 0xFFFFFFFFFFFFFFFF at that address. The code falsely reports an error. AFTER: correct code sets errno = 0 before the call, calls PEEKDATA, then checks 'if (result == -1 && errno != 0) \u2192 real error'. Shows the three cases: (1) data != -1 \u2192 success, (2) data == -1 and errno == 0 \u2192 valid data that happens to be all-ones, (3) data == -1 and errno != 0 \u2192 actual error (e.g., address unmapped).",
        "anchor_target": "anchor-m2-arg-decode",
        "level": "microscopic"
      },
      {
        "id": "diag-m2-argument-register-mapping",
        "title": "Syscall Argument Register Mapping with Examples",
        "description": "A structure_layout / trace_example diagram showing how argument registers map to real syscalls. Example 1: open(\"/etc/passwd\", O_RDONLY, 0) \u2192 rdi=pointer to string, rsi=0x0 (O_RDONLY), rdx=0x0 (mode). Example 2: read(3, buf, 4096) \u2192 rdi=3 (fd), rsi=pointer to buffer, rdx=4096 (count). Example 3: mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) \u2192 rdi=0, rsi=4096, rdx=3, r10=0x22, r8=-1, r9=0. Shows how each syscall has a different argument 'schema' and why you need per-syscall decode logic.",
        "anchor_target": "anchor-m2-arg-decode",
        "level": "street"
      },
      {
        "id": "diag-m2-flag-bitmask-decode",
        "title": "Bitmask Flag Decoding: open() Flags Example",
        "description": "A data_walk diagram showing how to decode O_WRONLY|O_CREAT|O_TRUNC = 0x241 into its constituent flags. Start with value 0x241. Check O_WRONLY (0x1) \u2192 set, emit 'O_WRONLY', subtract. Check O_CREAT (0x40) \u2192 set, emit 'O_CREAT'. Check O_TRUNC (0x200) \u2192 set, emit 'O_TRUNC'. Remainder is 0 \u2192 done. Shows the general bitmask iteration algorithm and the special case of O_RDONLY = 0 (it's not a flag bit, it's the absence of O_WRONLY and O_RDWR).",
        "anchor_target": "anchor-m2-arg-decode",
        "level": "microscopic"
      },
      {
        "id": "diag-m2-syscall-table-design",
        "title": "Syscall Table Structure: Number \u2192 Name \u2192 Argument Schema",
        "description": "A structure_layout diagram showing the data structure for the syscall table. An array indexed by syscall number. Each entry contains: name (string), nargs (argument count), and an array of arg_type enums (INT, UINT, PTR, STR, FLAGS_OPEN, FLAGS_MMAP_PROT, FLAGS_MMAP_FLAGS, FD, etc.). Shows entries for read (0), write (1), open (2), close (3), stat (4), mmap (9). Shows how the decoder dispatches based on arg_type.",
        "anchor_target": "anchor-m2-arg-decode",
        "level": "street"
      },
      {
        "id": "diag-m2-full-trace-example",
        "title": "Complete Trace of open() \u2014 From Registers to Formatted Output",
        "description": "A trace_example end-to-end walkthrough: (1) waitpid returns, toggle says ENTRY. (2) PTRACE_GETREGS \u2192 orig_rax=2 (open), rdi=0x7ffd1234, rsi=0x0, rdx=0x0. (3) Lookup syscall 2 \u2192 'open', args=[STR, FLAGS_OPEN, UINT]. (4) Arg 0: type STR \u2192 PEEKDATA loop at 0x7ffd1234 \u2192 \"/etc/passwd\". (5) Arg 1: type FLAGS_OPEN \u2192 0x0 \u2192 \"O_RDONLY\". (6) Arg 2: type UINT \u2192 0. (7) Print 'open(' but wait for exit. (8) PTRACE_SYSCALL \u2192 waitpid \u2192 toggle says EXIT. (9) PTRACE_GETREGS \u2192 rax=3. (10) Print 'open(\"/etc/passwd\", O_RDONLY) = 3'.",
        "anchor_target": "anchor-m2-arg-decode",
        "level": "street"
      },
      {
        "id": "diag-m3-fork-event-sequence",
        "title": "Fork Event Sequence: Parent Forks, Kernel Notifies Tracer",
        "description": "A state_evolution diagram showing: (1) Tracee (PID 100) resumes after PTRACE_SYSCALL. (2) Tracee calls fork(). (3) Kernel creates child (PID 200) in stopped state. (4) Kernel stops tracee (PID 100) with PTRACE_EVENT_FORK. (5) Tracer calls waitpid(-1) \u2192 returns PID 100 with event stop. (6) Tracer calls PTRACE_GETEVENTMSG(100) \u2192 gets 200. (7) Tracer initializes per-PID state for PID 200. (8) Tracer calls PTRACE_SYSCALL(100) and PTRACE_SYSCALL(200). (9) Both processes are now traced. Shows the race-free nature of PTRACE_O_TRACEFORK: the child is stopped before it runs any instructions.",
        "anchor_target": "anchor-m3-multi-process",
        "level": "street"
      },
      {
        "id": "diag-m3-per-pid-state-map",
        "title": "Per-PID State Hash Map \u2014 Structure and Lookup",
        "description": "A structure_layout diagram showing the hash map from PID \u2192 tracee_state. Each tracee_state struct contains: pid (pid_t, 4 bytes), in_syscall (bool, 1 byte \u2014 the entry/exit toggle), current_syscall (int, 4 bytes \u2014 syscall number captured at entry), entry_time (struct timespec, 16 bytes \u2014 for timing in M4), padding to align. Shows the hash map with chaining for collisions. Shows three example PIDs (100, 200, 342) mapped to their states, with PID 100 in EXIT state (current_syscall=2=open) and PID 200 in ENTRY state.",
        "anchor_target": "anchor-m3-multi-process",
        "level": "microscopic"
      },
      {
        "id": "diag-m3-waitpid-dispatch-flowchart",
        "title": "waitpid(-1) Event Dispatch: Multi-PID Decision Tree",
        "description": "A data_walk flowchart showing the expanded event loop for multi-process tracing. waitpid(-1, &status, 0) \u2192 get PID. Lookup PID in hash map (if not found and WIFSTOPPED \u2192 new child, initialize state). Check WIFEXITED/WIFSIGNALED \u2192 remove PID from map. Check status>>16 for PTRACE_EVENT_FORK/VFORK/CLONE \u2192 handle new child. Check status>>16 for PTRACE_EVENT_EXEC \u2192 reset PID state. Check WSTOPSIG for SIGTRAP|0x80 \u2192 syscall stop \u2192 dispatch to entry/exit handler for this PID. Otherwise \u2192 signal stop \u2192 re-inject.",
        "anchor_target": "anchor-m3-multi-process",
        "level": "street"
      },
      {
        "id": "diag-m3-exec-state-reset",
        "title": "PTRACE_EVENT_EXEC: Address Space Replacement",
        "description": "A before_after diagram. BEFORE exec: PID 100's address space has text at 0x400000, heap at 0x600000, stack at 0x7ffd..., and we may have cached string buffers or addresses. AFTER exec: PID 100 keeps the same PID but has a completely new address space from the new ELF binary. Text is now at 0x555... (PIE), new heap, new stack. All previously cached pointers are dangling. The per-PID state must reset: clear current_syscall, reset toggle to ENTRY (because the exec stop acts like a synthetic entry point), invalidate any cached data.",
        "anchor_target": "anchor-m3-multi-process",
        "level": "microscopic"
      },
      {
        "id": "diag-m3-multi-process-output",
        "title": "Interleaved Multi-Process Output Example",
        "description": "A trace_example showing real interleaved output from tracing a shell script that forks: [pid 100] execve(\"/bin/sh\", ...) = 0 / [pid 100] read(0, ...) = 5 / [pid 100] fork() = 200 / [pid 200] execve(\"/bin/ls\", ...) = 0 / [pid 200] open(\".\", O_RDONLY) = 3 / [pid 100] wait4(200, ...) \u2192 still running, so next event is from 200 / [pid 200] write(1, \"file.c\\n\", 7) = 7 / [pid 200] exit_group(0) / [pid 100] wait4(200, ...) = 200. Shows how PIDs interleave and why per-PID state is essential.",
        "anchor_target": "anchor-m3-multi-process",
        "level": "street"
      },
      {
        "id": "diag-m4-timing-overhead",
        "title": "Syscall Timing: What You're Actually Measuring",
        "description": "A data_walk timeline showing the real sequence of events when timing a syscall: (T0) clock_gettime in tracer at entry stop. (T1) ptrace(PTRACE_SYSCALL) \u2014 tracer\u2192kernel. (T2) kernel schedules tracee. (T3) tracee resumes, enters kernel for the real syscall. (T4) kernel executes syscall (e.g., read from disk = 50\u03bcs). (T5) kernel stops tracee at exit. (T6) kernel wakes tracer. (T7) waitpid returns in tracer. (T8) clock_gettime in tracer at exit stop. Shows that T8-T0 includes ptrace overhead (T1\u2192T3 and T5\u2192T8), not just the syscall (T4). Annotates typical overhead values.",
        "anchor_target": "anchor-m4-filter-stats",
        "level": "microscopic"
      },
      {
        "id": "diag-m4-filter-architecture",
        "title": "Syscall Filter: Trace Everything, Print Selectively",
        "description": "A street-level architecture diagram showing the filter pipeline. All syscalls are intercepted (PTRACE_SYSCALL doesn't filter). At entry: decode syscall number \u2192 lookup name \u2192 check against filter set (a bitset or hash set of allowed names). If filtered-out: still toggle state, still time, but skip output. If allowed: decode arguments, format, print. At exit: still read return value (needed for statistics), only print if allowed. Shows that filtering happens in the tracer's display logic, not in the kernel.",
        "anchor_target": "anchor-m4-filter-stats",
        "level": "street"
      },
      {
        "id": "diag-m4-statistics-table",
        "title": "Statistics Accumulation and Summary Table",
        "description": "A structure_layout + trace_example diagram showing the per-syscall statistics structure: struct syscall_stats { char *name; uint64_t count; uint64_t errors; double total_time_us; }. Shows accumulation during tracing (at each exit: stats[nr].count++, if error: stats[nr].errors++, stats[nr].total_time_us += duration). Then shows the final sorted output table matching strace -c format: '% time  seconds  usecs/call  calls  errors  syscall' with example rows for read, write, open, mmap.",
        "anchor_target": "anchor-m4-filter-stats",
        "level": "street"
      },
      {
        "id": "diag-m4-attach-vs-fork",
        "title": "PTRACE_ATTACH vs Fork+TRACEME: Two Entry Points",
        "description": "A before_after / comparison diagram. LEFT: Fork+TRACEME flow \u2014 parent forks, child calls TRACEME, child execs, child stops on SIGTRAP, parent is already in waitpid loop. RIGHT: PTRACE_ATTACH flow \u2014 target is already running (PID from -p flag), tracer calls PTRACE_ATTACH(PID), kernel sends SIGSTOP to target, tracer must waitpid for the SIGSTOP, THEN set PTRACE_O_TRACESYSGOOD and other options, THEN begin PTRACE_SYSCALL loop. Key difference: ATTACH starts mid-execution (entry/exit state unknown; must assume next stop is entry) and must eventually PTRACE_DETACH.",
        "anchor_target": "anchor-m4-filter-stats",
        "level": "street"
      },
      {
        "id": "diag-m4-clean-detach",
        "title": "Clean Detach Sequence on SIGINT",
        "description": "A state_evolution diagram showing the tracer's shutdown sequence when Ctrl+C is pressed. (1) Tracer installs SIGINT handler that sets a volatile flag. (2) Main loop checks flag after each waitpid. (3) For each PID in the state map: if the tracee is currently stopped \u2192 call PTRACE_DETACH(pid, 0). If the tracee is running \u2192 send SIGSTOP, waitpid for the stop, then PTRACE_DETACH. (4) The detached process continues running normally. Shows the danger of calling PTRACE_DETACH on a non-stopped process (ESRCH or corruption) and why ordering matters.",
        "anchor_target": "anchor-m4-filter-stats",
        "level": "microscopic"
      },
      {
        "id": "diag-m1-three-level-view",
        "title": "Three-Level View: Application \u2192 Kernel \u2192 Hardware for a Syscall",
        "description": "A satellite/street hybrid showing what happens when a traced program calls write(1, \"hello\", 5). Level 1 (Application): libc wrapper puts args in registers, executes `syscall` instruction. Level 2 (Kernel): entry_SYSCALL_64 saves registers to pt_regs on kernel stack, checks if traced \u2192 yes \u2192 notify tracer via ptrace, tracer reads regs, tracer resumes \u2192 kernel dispatches to sys_write \u2192 VFS \u2192 driver \u2192 returns to pt_regs \u2192 checks traced again \u2192 notify tracer \u2192 tracer reads return \u2192 resumes \u2192 sysret to userspace. Level 3 (Hardware): `syscall` instruction sets RIP=LSTAR MSR, sets CPL=0, saves old RIP to RCX, saves RFLAGS to R11. Shows how ptrace hooks into the kernel's syscall entry/exit path.",
        "anchor_target": "anchor-m1-basic-intercept",
        "level": "street"
      },
      {
        "id": "diag-m2-address-space-isolation",
        "title": "Virtual Address Space Isolation: Why PEEKDATA Exists",
        "description": "A microscopic diagram showing two processes (tracer and tracee) each with their own page tables. Tracee has virtual address 0x7ffd1234 mapped to physical page 0x1a3000 containing the string '/etc/passwd'. Tracer has virtual address 0x7ffd1234 mapped to physical page 0x8b7000 containing something completely different (or unmapped). The kernel's ptrace PEEKDATA implementation: looks up tracee's page table, translates VA\u2192PA, reads the word from the physical page, copies it into tracer's return value. Shows CR3 register switch conceptually.",
        "anchor_target": "anchor-m2-arg-decode",
        "level": "microscopic"
      }
    ]
  },
  "primary_language": "C",
  "accumulated_md": "# System Call Tracer (strace clone)\n\nThis project builds a fully functional strace clone from scratch \u2014 a ptrace-based system call tracer that intercepts, decodes, and reports every syscall a target process makes on x86_64 Linux. You will start by forking a child, attaching via ptrace, and toggling between syscall entry and exit stops. Then you'll decode arguments by reading registers, dereference string pointers word-by-word from the tracee's address space, follow fork/exec across process boundaries, and finally add filtering and statistical profiling.\n\nThe project is a window into the kernel-userspace boundary. Every syscall is a precisely choreographed register dance: the application loads arguments into rdi, rsi, rdx, r10, r8, r9, puts the syscall number in rax, and executes the `syscall` instruction. The kernel saves state, dispatches, and returns a result in rax. Your tracer sits in between, mediated by ptrace, observing this dance twice per call \u2014 once on entry, once on exit. Understanding this mechanism is foundational to debuggers (GDB), sandboxes (seccomp), profilers (perf), and container runtimes.\n\nBy the end, you'll have a tool that can attach to any process, print decoded syscall traces with arguments, follow multi-process workloads, filter by syscall name, and produce timing statistics \u2014 the core functionality of the real strace.\n\n\n\n<!-- MS_ID: build-strace-m1 -->\n# Milestone 1: Basic ptrace Syscall Intercept\n## Where You Are in the System\nBefore writing a single line of code, orient yourself. Your strace clone has one job at its core: sit between a running process and the kernel, observe every syscall that crosses that boundary, and report what it sees. This milestone builds that core \u2014 the bare minimum tracer that intercepts syscalls and prints their numbers and return values.\nBy the end of this milestone you'll have a working tracer that can attach to any program, stop it at every syscall boundary, and print output like:\n```\nsyscall(12) = 94367748206592\nsyscall(21) = 0\nsyscall(9) = 94367748206592\nsyscall(1) = -1 EBADF\n```\nNot pretty yet \u2014 that's Milestone 2. But correct. And correctness here is harder than it looks, because ptrace has a behavior that trips up almost everyone the first time.\n\n![System Call Tracer \u2014 Satellite Architecture Map](./diagrams/diag-satellite-map.svg)\n\n---\n## The Core Revelation: ptrace Stops Twice\nHere's the assumption that will break your first implementation:\n> *You call PTRACE_SYSCALL, the child runs the syscall, stops, and you read the result.*\nThis feels right. It mirrors how you think about function interception: intercept the call, get the result. One stop, one event.\n**It's wrong.** ptrace stops the tracee *twice* per syscall \u2014 once at syscall entry (before the kernel executes anything) and once at syscall exit (after the kernel has completed the call and written the return value). Both stops look identical to `waitpid`. Neither stop says \"I'm the entry stop\" or \"I'm the exit stop.\" Your tracer receives a SIGTRAP both times and must maintain its own toggle flag to know which one it's seeing.\nThis isn't a quirk or an implementation detail. It's fundamental to ptrace's design \u2014 and it's the source of more bugs in ptrace-based tools than anything else.\nWhy does this matter practically? On entry, the return value register (`rax`) contains **garbage** \u2014 specifically, the return value from the *previous* syscall. On exit, the argument registers still contain the call's arguments, but they may have been modified by the kernel. If you try to read the syscall number on exit, you can \u2014 `orig_rax` preserves it \u2014 but if you try to read `rax` on entry thinking it's the return value, you'll get stale data and produce completely wrong output.\nThe double-stop model is also what makes syscall *injection* possible: between entry and exit, the kernel is executing your syscall. If you wake up at entry and modify the registers before continuing, you can change which syscall runs or what arguments it receives. If you wake up at exit and modify `rax`, you can lie about what the syscall returned. This is how `strace -e inject=` works, and how seccomp-based sandboxes intercept and redirect syscalls. You're building the foundation for all of that right now.\n\n![Syscall Entry/Exit Toggle State Machine](./diagrams/diag-m1-entry-exit-toggle.svg)\n\n---\n## The ptrace Lifecycle\nBefore the toggle flag makes sense, you need to understand the full sequence from process creation to your first intercepted syscall. Let's walk through it.\n### Step 1: Fork and TRACEME\nYour tracer starts with `fork()`. The child process needs to tell the kernel \"I want to be traced.\" It does this with `ptrace(PTRACE_TRACEME, 0, NULL, NULL)`.\n`PTRACE_TRACEME` is the only ptrace request that's made by the *tracee* (the process being traced) rather than the *tracer*. It tells the kernel: \"Whenever I make a syscall, deliver a SIGTRAP to pause me and wake up my parent.\" You call it in the child, before `exec()`.\nAfter `PTRACE_TRACEME`, the child calls `exec()` to become the target program. Here's a subtlety: after a successful `exec()` in a traced process, the kernel automatically delivers **SIGTRAP** to the tracee. This is a one-time stop that happens right at the start of the new program's execution, before any instructions run. Your parent must handle this initial stop \u2014 it's not a syscall stop, it's the post-exec notification.\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <program> [args...]\\n\", argv[0]);\n        return 1;\n    }\n    pid_t child = fork();\n    if (child == 0) {\n        /* Child: request tracing, then become the target program */\n        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n        execvp(argv[1], &argv[1]);\n        /* If execvp returns, something went wrong */\n        perror(\"execvp\");\n        exit(1);\n    }\n    /* Parent: wait for the initial SIGTRAP from exec */\n    int status;\n    waitpid(child, &status, 0);\n    /* status now indicates the post-exec SIGTRAP stop */\n    /* ... tracing loop goes here ... */\n}\n```\nNotice the call sequence in the child: `PTRACE_TRACEME` first, then `execvp`. Order matters. If you reverse them, the new program won't be traced because the tracing flag wasn't set when `exec` ran.\n\n![ptrace Tracing Lifecycle: Fork \u2192 TRACEME \u2192 Exec \u2192 SYSCALL Loop](./diagrams/diag-m1-ptrace-lifecycle.svg)\n\n### Step 2: The PTRACE_SYSCALL + waitpid Loop\nOnce you've caught the initial stop, the tracing loop begins. It follows a simple rhythm:\n1. Call `ptrace(PTRACE_SYSCALL, child, NULL, NULL)` \u2014 this tells the kernel \"resume the tracee, but stop it at the next syscall boundary.\"\n2. Call `waitpid(child, &status, 0)` \u2014 block until something happens to the tracee.\n3. Check `status` to figure out what happened.\n4. If it's a syscall stop: inspect registers, print output, go to step 1.\n5. If it's a signal stop: re-inject the signal, go to step 1.\n6. If the process exited: clean up and exit the tracer.\nThe `PTRACE_SYSCALL` request is key. It means \"stop at the next syscall entry OR exit.\" The kernel doesn't distinguish between them for you \u2014 you get one stop notification for each boundary. Your toggle flag tracks which boundary you're at.\n```c\n    /* Start the tracing loop */\n    int in_syscall = 0;  /* Toggle: 0 = not in syscall (entry), 1 = in syscall (exit) */\n    while (1) {\n        /* Resume tracee, stop at next syscall boundary */\n        ptrace(PTRACE_SYSCALL, child, NULL, NULL);\n        /* Wait for the next stop */\n        waitpid(child, &status, 0);\n        /* Check what happened */\n        if (WIFEXITED(status)) {\n            printf(\"Process exited with status %d\\n\", WEXITSTATUS(status));\n            break;\n        }\n        if (WIFSIGNALED(status)) {\n            printf(\"Process killed by signal %d\\n\", WTERMSIG(status));\n            break;\n        }\n        if (WIFSTOPPED(status)) {\n            /* Handle the stop */\n            /* ... */\n        }\n    }\n```\nLet's unpack those `waitpid` status macros \u2014 they're not optional knowledge, they're your primary tool for understanding what happened to the tracee.\n---\n## Understanding waitpid Status\n`waitpid()` returns a 32-bit integer called the *wait status*. This integer is not a simple exit code \u2014 it encodes several different kinds of events in a bit-packed format, and you decode it with a set of macros.\n{{DIAGRAM:diag-m1-waitpid-status-decode}}\nHere's what each macro checks and returns:\n**`WIFEXITED(status)`** \u2014 Returns true if the child terminated normally by calling `exit()` or returning from `main()`. When true, `WEXITSTATUS(status)` extracts the exit code (the argument passed to `exit()`).\n**`WIFSIGNALED(status)`** \u2014 Returns true if the child was killed by a signal (like `SIGKILL` or `SIGSEGV`). When true, `WTERMSIG(status)` extracts the signal number that killed it.\n**`WIFSTOPPED(status)`** \u2014 Returns true if the child was *stopped* (paused) rather than terminated. This is the case for both syscall stops and signal delivery stops in a ptrace-traced process. When true, `WSTOPSIG(status)` extracts the signal number that caused the stop. For syscall stops, this will be `SIGTRAP` (signal 5).\n**`WIFCONTINUED(status)`** \u2014 Returns true if a stopped child was resumed with `SIGCONT`. You won't need this for basic tracing.\nFor your tracer, the most important distinction is between:\n- `WIFEXITED` / `WIFSIGNALED` \u2192 the tracee is gone, stop tracing\n- `WIFSTOPPED` \u2192 the tracee is paused, inspect it and decide what to do\n---\n## x86_64 Syscall Register Conventions\nNow you need to know *what* to read when the tracee stops. Syscalls on x86_64 follow a strict register convention baked into the Linux ABI (Application Binary Interface \u2014 the contract between userspace and kernel that specifies exactly which registers carry which values).\nWhen a program executes the `syscall` instruction on x86_64:\n- **`rax`** \u2014 holds the syscall number before the call\n- **`rdi`** \u2014 holds argument 1\n- **`rsi`** \u2014 holds argument 2\n- **`rdx`** \u2014 holds argument 3\n- **`r10`** \u2014 holds argument 4 (note: this is `r10`, not `rcx` as in the normal calling convention \u2014 the `syscall` instruction uses `rcx` internally to save the return address)\n- **`r8`** \u2014 holds argument 5\n- **`r9`** \u2014 holds argument 6\nAfter the kernel completes the syscall, **`rax`** holds the return value.\nHere's the critical problem: the kernel may use `rax` for its own purposes during dispatch. If you read `rax` on entry, you'll get the syscall number \u2014 but the kernel might overwrite `rax` before giving you control on exit, destroying it. So the kernel saves the original `rax` value into a special field called `orig_rax` *before* doing anything else.\nThis means:\n- **On entry**: Read `orig_rax` for the syscall number. (Reading `rax` on entry gives the syscall number too, but `orig_rax` is the authoritative source.)\n- **On exit**: Read `rax` for the return value. Read `orig_rax` if you need the syscall number again.\nTo read these registers, you use `ptrace(PTRACE_GETREGS, pid, NULL, &regs)` where `regs` is a `struct user_regs_struct` defined in `<sys/user.h>`.\n\n![x86_64 Syscall Register Convention \u2014 struct user_regs_struct Layout](./diagrams/diag-m1-x86-registers.svg)\n\n```c\n#include <sys/user.h>  /* struct user_regs_struct */\nstruct user_regs_struct regs;\nptrace(PTRACE_GETREGS, child, NULL, &regs);\n/* On syscall entry: */\nlong syscall_number = regs.orig_rax;\n/* On syscall exit: */\nlong return_value = regs.rax;\n```\nThe `struct user_regs_struct` contains fields for all general-purpose registers. The ones you'll use most in this milestone:\n```c\nstruct user_regs_struct {\n    /* ... many fields ... */\n    unsigned long long orig_rax;  /* Saved rax (syscall number) */\n    unsigned long long rax;       /* Return value (on exit) */\n    unsigned long long rdi;       /* Argument 1 */\n    unsigned long long rsi;       /* Argument 2 */\n    unsigned long long rdx;       /* Argument 3 */\n    unsigned long long r10;       /* Argument 4 */\n    unsigned long long r8;        /* Argument 5 */\n    unsigned long long r9;        /* Argument 6 */\n    /* ... more fields ... */\n};\n```\n---\n## Three-Level View: What Happens During a Syscall\nUnderstanding the entry/exit stops requires seeing what happens at all three levels.\n\n![Three-Level View: Application \u2192 Kernel \u2192 Hardware for a Syscall](./diagrams/diag-m1-three-level-view.svg)\n\n**Level 1 \u2014 Application (Tracee)**\nThe program calls `write(1, \"hello\", 5)`. The compiler has already translated this into: load 1 into `rdi`, load the string pointer into `rsi`, load 5 into `rdx`, load 1 (the syscall number for `write`) into `rax`, execute the `syscall` instruction.\n**Level 2 \u2014 Kernel**\nWhen `syscall` executes:\n1. The CPU switches to ring 0 (kernel mode) and jumps to the syscall entry point (`entry_SYSCALL_64`).\n2. The kernel checks if this process is being traced (the `PT_TRACED` flag is set on the task).\n3. If traced: before doing anything else, save `rax` to `orig_rax`, then signal the tracer with SIGTRAP. The tracee is now paused. This is the **entry stop**.\n4. The tracer wakes up, inspects registers, then calls `PTRACE_SYSCALL` to resume.\n5. The kernel executes the actual syscall (calls `sys_write`).\n6. The return value is placed in `rax`.\n7. The kernel signals the tracer again with SIGTRAP. The tracee is paused again. This is the **exit stop**.\n8. The tracer wakes up, reads the return value from `rax`, then calls `PTRACE_SYSCALL` to resume.\n9. The `syscall` instruction completes in userspace. Execution continues.\n**Level 3 \u2014 Hardware**\nThe `syscall` instruction does specific things at the hardware level:\n- Saves the return address (next instruction's `RIP`) into `RCX`.\n- Saves `RFLAGS` into `R11`.\n- Loads the kernel's code segment (`CS`) and stack pointer.\n- Jumps to the address stored in `IA32_LSTAR` MSR (Model-Specific Register) \u2014 the kernel entry point.\nThis is why `rcx` and `r11` are clobbered by the `syscall` instruction: they're used by the hardware to save state. The kernel calling convention for syscalls explicitly uses `r10` instead of `rcx` for argument 4 to avoid this conflict.\nThe `orig_rax` field exists because of step 3 above \u2014 the kernel overwrites `rax` during its own internal dispatch, so it first saves the original value.\n---\n## The Toggle Flag in Practice\nNow you have everything to implement the full entry/exit logic:\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/user.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <program> [args...]\\n\", argv[0]);\n        return 1;\n    }\n    pid_t child = fork();\n    if (child == 0) {\n        /* Child: enable tracing and exec the target */\n        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n        execvp(argv[1], &argv[1]);\n        perror(\"execvp\");\n        exit(1);\n    }\n    /* Parent: catch the post-exec SIGTRAP */\n    int status;\n    waitpid(child, &status, 0);\n    if (!WIFSTOPPED(status)) {\n        fprintf(stderr, \"Unexpected initial status\\n\");\n        return 1;\n    }\n    /* The tracing loop */\n    int in_syscall = 0;  /* Toggle: 0 = next stop is entry, 1 = next stop is exit */\n    while (1) {\n        /* Resume tracee, asking kernel to stop at next syscall boundary */\n        if (ptrace(PTRACE_SYSCALL, child, NULL, NULL) == -1) {\n            perror(\"ptrace PTRACE_SYSCALL\");\n            break;\n        }\n        /* Block until the tracee stops again */\n        waitpid(child, &status, 0);\n        /* Tracee has exited \u2014 stop tracing */\n        if (WIFEXITED(status)) {\n            printf(\"+++ exited with %d +++\\n\", WEXITSTATUS(status));\n            break;\n        }\n        /* Tracee was killed by a signal \u2014 stop tracing */\n        if (WIFSIGNALED(status)) {\n            printf(\"+++ killed by signal %d +++\\n\", WTERMSIG(status));\n            break;\n        }\n        /* Tracee has stopped \u2014 inspect why */\n        if (WIFSTOPPED(status)) {\n            int sig = WSTOPSIG(status);\n            if (sig == SIGTRAP) {\n                /* This is a syscall stop (or the initial post-exec stop) */\n                struct user_regs_struct regs;\n                ptrace(PTRACE_GETREGS, child, NULL, &regs);\n                if (!in_syscall) {\n                    /* Entry: syscall is about to execute */\n                    /* Just record that we're entering; we'll print on exit */\n                    in_syscall = 1;\n                } else {\n                    /* Exit: syscall has completed */\n                    long syscall_num = (long)regs.orig_rax;\n                    long return_val  = (long)regs.rax;\n                    /* Detect error returns */\n                    if (return_val >= -4096 && return_val <= -1) {\n                        int err_num = (int)(-return_val);\n                        printf(\"syscall(%ld) = -1 %s\\n\",\n                               syscall_num, strerror(err_num));\n                    } else {\n                        printf(\"syscall(%ld) = %ld\\n\",\n                               syscall_num, return_val);\n                    }\n                    in_syscall = 0;\n                }\n            } else {\n                /* Signal-delivery stop: a real signal for the tracee */\n                /* Re-inject it \u2014 do NOT pass 0 or you'll swallow the signal */\n                ptrace(PTRACE_SYSCALL, child, NULL, (void *)(long)sig);\n                continue;  /* Skip the PTRACE_SYSCALL at top of loop */\n            }\n        }\n    }\n    return 0;\n}\n```\nRead through this carefully. Notice the subtle continuation in the signal-delivery case: when you handle a signal stop, you call `PTRACE_SYSCALL` with the signal number immediately in the handler and `continue` to skip the `PTRACE_SYSCALL` at the top of the loop \u2014 otherwise you'd call it twice and lose an event.\n---\n## Signal Stops vs Syscall Stops\nThe code above has a subtle problem. We're distinguishing signal-delivery stops from syscall stops by checking if the stop signal is `SIGTRAP`. But `SIGTRAP` *is* the signal for both types of stops. How do you actually tell them apart?\n\n![Signal-Delivery Stop vs Syscall Stop \u2014 Decision Tree](./diagrams/diag-m1-signal-vs-syscall-stop.svg)\n\nThere are two approaches:\n### Approach 1: PTRACE_O_TRACESYSGOOD (Recommended)\nIf you set the option `PTRACE_O_TRACESYSGOOD` on the tracee, the kernel will set bit 7 of the stop signal number for syscall stops. That is, instead of delivering `SIGTRAP` (signal 5) for syscall stops, it delivers `SIGTRAP | 0x80` = `0x85`. Signal-delivery stops still use plain `SIGTRAP` (5).\nYou set options with:\n```c\nptrace(PTRACE_SETOPTIONS, child, NULL, PTRACE_O_TRACESYSGOOD);\n```\nCall this right after the initial `waitpid` that catches the post-exec stop.\nThen your stop handling becomes:\n```c\nif (WIFSTOPPED(status)) {\n    int sig = WSTOPSIG(status);\n    if (sig == (SIGTRAP | 0x80)) {\n        /* Syscall stop \u2014 handle entry/exit toggle */\n        /* sig & 0x7F == SIGTRAP, bit 7 is the TRACESYSGOOD indicator */\n        /* ... */\n    } else if (sig == SIGTRAP) {\n        /* Plain SIGTRAP \u2014 could be post-exec stop, breakpoint, or other ptrace event */\n        /* For now, just resume */\n    } else {\n        /* Genuine signal delivery stop \u2014 re-inject the signal */\n        ptrace(PTRACE_SYSCALL, child, NULL, (void *)(long)sig);\n        continue;\n    }\n}\n```\n### Approach 2: Check orig_rax\nAnother approach: on every SIGTRAP stop, call `PTRACE_GETREGS` and check `orig_rax`. If `orig_rax` is a valid syscall number (0 through ~450 on Linux), it's likely a syscall stop. But this is fragile \u2014 `orig_rax` can contain valid-looking values in edge cases.\n**Use `PTRACE_O_TRACESYSGOOD`.** It's the correct approach, used by real strace. The bit-7 trick was invented precisely to solve this disambiguation problem.\nHere's the updated initialization:\n```c\n    /* Catch post-exec stop */\n    waitpid(child, &status, 0);\n    /* Set options: use TRACESYSGOOD to mark syscall stops */\n    ptrace(PTRACE_SETOPTIONS, child, NULL, PTRACE_O_TRACESYSGOOD);\n    /* Now enter the tracing loop */\n```\n---\n## Error Detection on x86_64\nWhen a syscall fails, the kernel doesn't return a positive number and set `errno`. Instead, it returns a negative number in the range `[-4096, -1]`. The C library wrapper (in glibc) detects this range, negates the value, stores it in `errno`, and returns `-1` to your program.\nFor example, if you call `open(\"nonexistent\", O_RDONLY)`, the kernel returns `-2` (which is `-ENOENT`). glibc sees `-2`, sets `errno = 2` (ENOENT), and returns `-1`.\nIn your tracer, you see the *raw kernel return value* \u2014 not the glibc-processed one. So you need to do the same detection:\n```c\n/* On x86_64, kernel error returns are in the range [-4096, -1] */\n/* This range covers all possible errno values (the largest is ~4095) */\nlong return_val = (long)regs.rax;\nif (return_val >= -4096L && return_val <= -1L) {\n    /* Error return */\n    int err_num = (int)(-return_val);  /* Negate to get the errno value */\n    printf(\"syscall(%ld) = -1 %s\\n\", syscall_num, strerror(err_num));\n} else {\n    /* Success return */\n    printf(\"syscall(%ld) = %ld\\n\", syscall_num, return_val);\n}\n```\nWhy the range `[-4096, -1]`? The Linux kernel reserves 4096 values for error codes. The actual defined errno values top out around 133 (`EHWPOISON`), but the kernel reserves the full 4096 range to be safe for future additions.\n\n![x86_64 Syscall Return Value Error Detection](./diagrams/diag-m1-error-detection.svg)\n\nThe cast `(long)regs.rax` matters. `regs.rax` is `unsigned long long`. If a syscall returns `-2`, the bit pattern in `rax` is `0xFFFFFFFFFFFFFFFE` \u2014 which as an unsigned 64-bit integer is a very large positive number. By casting to `long` (signed), you restore the correct negative interpretation. Always cast `rax` to `long` before comparing.\n---\n## Putting It Together: Complete Working Tracer\nHere is the complete, correct implementation for Milestone 1. Every concept from this chapter is present:\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/user.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <program> [args...]\\n\", argv[0]);\n        return 1;\n    }\n    pid_t child = fork();\n    if (child < 0) {\n        perror(\"fork\");\n        return 1;\n    }\n    if (child == 0) {\n        /*\n         * CHILD PROCESS\n         * 1. Tell the kernel we want to be traced.\n         * 2. exec the target program.\n         * After exec succeeds, the kernel delivers SIGTRAP and pauses us.\n         */\n        if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1) {\n            perror(\"ptrace TRACEME\");\n            exit(1);\n        }\n        execvp(argv[1], &argv[1]);\n        /* execvp only returns on error */\n        perror(\"execvp\");\n        exit(1);\n    }\n    /*\n     * PARENT (TRACER) PROCESS\n     */\n    int status;\n    /* Step 1: Catch the initial SIGTRAP delivered after exec */\n    if (waitpid(child, &status, 0) == -1) {\n        perror(\"waitpid (initial)\");\n        return 1;\n    }\n    if (!WIFSTOPPED(status)) {\n        fprintf(stderr, \"Unexpected: child did not stop after exec\\n\");\n        return 1;\n    }\n    /* Step 2: Set TRACESYSGOOD so syscall stops set bit 7 of the signal */\n    if (ptrace(PTRACE_SETOPTIONS, child, NULL,\n               (void *)(long)PTRACE_O_TRACESYSGOOD) == -1) {\n        perror(\"ptrace SETOPTIONS\");\n        return 1;\n    }\n    /*\n     * Step 3: The tracing loop.\n     *\n     * Toggle state:\n     *   in_syscall == 0: next syscall stop will be an ENTRY stop\n     *   in_syscall == 1: next syscall stop will be an EXIT stop\n     */\n    int in_syscall = 0;\n    for (;;) {\n        /* Resume tracee; stop at next syscall entry or exit */\n        if (ptrace(PTRACE_SYSCALL, child, NULL, NULL) == -1) {\n            /* Tracee may have exited between our waitpid and this call */\n            if (errno == ESRCH) break;\n            perror(\"ptrace PTRACE_SYSCALL\");\n            break;\n        }\n        /* Block until the tracee changes state */\n        pid_t stopped = waitpid(child, &status, 0);\n        if (stopped == -1) {\n            perror(\"waitpid\");\n            break;\n        }\n        /* The tracee exited normally */\n        if (WIFEXITED(status)) {\n            printf(\"+++ exited with %d +++\\n\", WEXITSTATUS(status));\n            break;\n        }\n        /* The tracee was killed by a signal */\n        if (WIFSIGNALED(status)) {\n            printf(\"+++ killed by signal %d (%s) +++\\n\",\n                   WTERMSIG(status), strsignal(WTERMSIG(status)));\n            break;\n        }\n        /* The tracee stopped */\n        if (WIFSTOPPED(status)) {\n            int sig = WSTOPSIG(status);\n            if (sig == (SIGTRAP | 0x80)) {\n                /*\n                 * SYSCALL STOP (entry or exit, distinguished by toggle)\n                 * Bit 7 is set because we used PTRACE_O_TRACESYSGOOD.\n                 */\n                struct user_regs_struct regs;\n                if (ptrace(PTRACE_GETREGS, child, NULL, &regs) == -1) {\n                    perror(\"ptrace GETREGS\");\n                    break;\n                }\n                if (in_syscall == 0) {\n                    /*\n                     * ENTRY STOP\n                     * The syscall is about to execute. orig_rax has the\n                     * syscall number. We note it and flip the toggle.\n                     * (We don't print yet \u2014 we print on exit when we have\n                     * both the syscall number AND the return value.)\n                     */\n                    in_syscall = 1;\n                    /* Syscall number: regs.orig_rax \u2014 saved for exit print */\n                } else {\n                    /*\n                     * EXIT STOP\n                     * The syscall has completed. rax has the return value.\n                     * orig_rax still has the syscall number.\n                     */\n                    long syscall_num = (long)regs.orig_rax;\n                    long return_val  = (long)regs.rax;\n                    if (return_val >= -4096L && return_val <= -1L) {\n                        int err_num = (int)(-return_val);\n                        printf(\"syscall(%ld) = -1 %s\\n\",\n                               syscall_num, strerror(err_num));\n                    } else {\n                        printf(\"syscall(%ld) = %ld\\n\",\n                               syscall_num, return_val);\n                    }\n                    in_syscall = 0;\n                }\n            } else if (sig == SIGTRAP) {\n                /*\n                 * Plain SIGTRAP without bit 7 \u2014 this is the post-exec stop\n                 * or some other ptrace event. Just resume with no signal.\n                 * (The toggle stays at 0; we haven't entered a syscall.)\n                 */\n            } else {\n                /*\n                 * SIGNAL-DELIVERY STOP\n                 * A real signal (SIGTERM, SIGPIPE, SIGHUP, etc.) was\n                 * delivered to the tracee. We must re-inject it by passing\n                 * the signal number as the 4th argument to PTRACE_SYSCALL.\n                 * Passing 0 would suppress the signal, which would break\n                 * the traced program's signal-handling logic.\n                 */\n                if (ptrace(PTRACE_SYSCALL, child, NULL,\n                           (void *)(long)sig) == -1) {\n                    if (errno == ESRCH) break;\n                    perror(\"ptrace PTRACE_SYSCALL (signal re-inject)\");\n                    break;\n                }\n                /* Note: we re-injected via PTRACE_SYSCALL above; skip the\n                 * PTRACE_SYSCALL call at the top of the loop. */\n                continue;\n            }\n        }\n    }\n    return 0;\n}\n```\n### Building and Testing\n```makefile\n# Makefile\nCC = gcc\nCFLAGS = -Wall -Wextra -g\nstrace_clone: strace_clone.c\n\t$(CC) $(CFLAGS) -o strace_clone strace_clone.c\nclean:\n\trm -f strace_clone\n```\nTest it:\n```bash\nmake\n./strace_clone /bin/ls /tmp\n```\nYou should see a stream of `syscall(N) = M` lines, followed by `+++ exited with 0 +++`. The syscall numbers will be x86_64 numbers \u2014 `59` is `execve`, `12` is `brk`, `9` is `mmap`. You'll decode these in Milestone 2.\n---\n## Common Bugs and How to Avoid Them\n### Bug 1: Reading rax on Entry\n```c\n/* WRONG: rax on entry is garbage (previous syscall's return value) */\nif (!in_syscall) {\n    long return_val = (long)regs.rax;  /* \u2190 This is wrong! */\n    printf(\"syscall(%ld) = %ld\\n\", regs.orig_rax, return_val);\n    in_syscall = 1;\n}\n```\nThe fix is to not print the return value on entry. Print on exit when `rax` is valid.\n### Bug 2: Not Re-Injecting Signals\n```c\n/* WRONG: passing 0 suppresses the signal */\nptrace(PTRACE_SYSCALL, child, NULL, NULL);  /* suppresses the signal! */\n```\nIf a program receives `SIGPIPE` (write to a closed pipe) and you suppress it by passing 0, the program won't get the signal. It will continue writing to a closed pipe and produce corrupt behavior. Always re-inject real signals.\n### Bug 3: Forgetting the Toggle\nIf your toggle flag is wrong \u2014 say, you initialize it to 1 instead of 0, or you increment instead of toggling \u2014 you'll be one stop off on every syscall. Entry reads will look like exits and vice versa. The output will look plausible but be completely wrong. The numbers will be garbage. Initialize `in_syscall = 0` and toggle it cleanly.\n### Bug 4: Missing PTRACE_TRACEME Before exec\nIf the child calls `exec` before `PTRACE_TRACEME`, the new program is not traced. The parent's `waitpid` will block forever (or until the child exits). Always `PTRACE_TRACEME` first.\n---\n## Hardware Soul: What the CPU Does\n*When your tracer intercepts a syscall, what's happening in the hardware?*\n**Cache behavior**: The `syscall` instruction causes a CPU privilege level transition. The kernel entry code lives in a different cache region than userspace. This is an L1 instruction cache miss (cold path) on the first syscall of a program, then typically hot for subsequent calls. The `struct user_regs_struct` you read with `PTRACE_GETREGS` is a 216-byte structure \u2014 it fits in approximately 4 cache lines (64 bytes each). Each `PTRACE_GETREGS` call copies this structure across process boundaries, touching 4 cache lines.\n**TLB behavior**: The `waitpid` call that blocks your tracer is a full context switch. The CPU flushes TLB entries on context switch (or invalidates them on architectures with ASID support). When your tracer resumes to inspect registers, the kernel maps the tracee's register state into your address space \u2014 no TLB miss for the register copy, but your tracer's own TLB state must be reconstructed.\n**Branch prediction**: The `WIFSTOPPED`/`WIFEXITED`/`WIFSIGNALED` macros are simple bit operations. They're essentially free. The branch predictor will correctly predict \"almost always WIFSTOPPED\" after the first few iterations.\n**Syscall overhead**: Each `ptrace(PTRACE_SYSCALL, ...)` is itself a syscall. Each `waitpid` is a syscall. So intercepting *one* syscall in the tracee costs *two* syscalls in the tracer (plus the context switch overhead and cache effects). This is why ptrace-based tracing has significant overhead \u2014 strace can slow a program by 2-10x depending on syscall frequency.\n---\n## Knowledge Cascade: What This Unlocks\nYou've just implemented the core mechanism of one of Linux's most powerful diagnostic tools. That toggle flag and SIGTRAP stop aren't isolated ideas \u2014 they connect to a wide web of systems knowledge.\n### 1. GDB Uses the Same Mechanism (Just With PTRACE_SINGLESTEP)\nGDB's breakpoints work by inserting an `INT 3` instruction (opcode `0xCC`) at a target address, which generates a SIGTRAP when executed. But GDB also uses `PTRACE_SINGLESTEP` to step one instruction at a time \u2014 this is the same double-stop model. When GDB says \"hit breakpoint, stopped at line 42,\" it has just received a SIGTRAP via `waitpid`, read the register state, and displayed it to you. The mechanism you built today is the foundation of every debugger on Linux.\n**The connection to your toggle**: When you understand entry/exit stops, you understand why GDB can modify syscall arguments *in flight* \u2014 it wakes up at entry, modifies registers before resuming, and the kernel executes the modified syscall. Fault injection (breaking programs deliberately to test error handling) is built on exactly this mechanism.\n### 2. seccomp-BPF Filters Only at Entry\nseccomp (Secure Computing Mode) is a Linux kernel feature that lets you install a BPF (Berkeley Packet Filter) program to filter syscalls. Here's the critical connection: **seccomp filters run at syscall entry only, not exit**. They can allow or deny a call, but they cannot inspect the return value. Now you know *why* \u2014 the entry/exit model means the filter runs at the first SIGTRAP (entry stop), before the kernel has executed the syscall. Return values don't exist yet. seccomp can block `open()` but can't block `open()` that returns a file descriptor pointing to a sensitive file \u2014 it has to make that decision based on arguments alone.\nContainer runtimes like runc use seccomp profiles to restrict what syscalls containers can make. When you run `docker run --security-opt seccomp=profile.json`, that profile is compiled into a BPF program loaded via `prctl(PR_SET_SECCOMP, ...)`. The ptrace entry stop is where this filter executes.\n### 3. strace -e inject: Modifying Syscalls In Flight\nReal strace has a feature called `strace -e inject=open:retval=-1:error=ENOENT` that makes `open()` always fail with ENOENT. How does it work? On the entry stop, strace notes the syscall. On the exit stop, it modifies `rax` to `-2` (which is `-ENOENT`) using `PTRACE_SETREGS`. The program's glibc library sees `-2`, sets `errno = ENOENT`, and returns `-1` to the program. The actual `open()` ran and succeeded \u2014 strace lied about the result. This is fault injection: a technique for testing that programs handle errors correctly.\nYou now understand the two stops well enough to implement this yourself: read on entry, modify `rax` on exit.\n### 4. The x86_64 syscall ABI vs. the C Calling Convention\nYou've learned that syscalls use `rdi, rsi, rdx, r10, r8, r9` for arguments. The normal C function calling convention uses `rdi, rsi, rdx, rcx, r8, r9`. The difference is argument 4: `r10` for syscalls vs. `rcx` for function calls. This exists because the `syscall` instruction hardware-saves the return address in `RCX` \u2014 so `rcx` is clobbered by the mechanism itself. The ABI designers shifted argument 4 to `r10` to avoid the conflict. Now when you see `r10` in a Linux syscall table, you know exactly why.\n### 5. The Performance Cost of Observability\nEvery syscall interception costs approximately:\n- 2 context switches (tracer \u2192 tracee \u2192 tracer)\n- 2 additional syscalls by the tracer (PTRACE_SYSCALL + waitpid)\n- 4 cache line reads (PTRACE_GETREGS for the register struct)\n- ~5,000-10,000 CPU cycles of overhead per intercepted syscall\nThis is why you don't use ptrace in production \u2014 it's too slow. Production observability tools (like `perf`, `eBPF` probes, or `ftrace`) use kernel-side hooks that avoid the full context switch. They sample in the kernel and only surface data to userspace periodically. What you're building is the *right tool* for debugging and learning, not for production profiling. Knowing this cost precisely is what lets you make the right tool choice.\n---\n## Summary: What You've Built\nYour tracer now:\n- Forks a child, has it request tracing, and execs the target program\n- Catches the post-exec SIGTRAP and configures `PTRACE_O_TRACESYSGOOD`\n- Runs a `PTRACE_SYSCALL + waitpid` loop indefinitely\n- Toggles an `in_syscall` flag to distinguish entry from exit\n- On exit: reads `orig_rax` for the syscall number and `rax` for the return value\n- Detects error returns using the `[-4096, -1]` range and prints errno names\n- Re-injects real signals to the tracee rather than suppressing them\n- Detects `WIFEXITED` / `WIFSIGNALED` to stop the tracing loop cleanly\nThe output isn't human-readable yet \u2014 syscall numbers instead of names, raw integers instead of decoded arguments. Milestone 2 fixes that. But the machinery underneath \u2014 the toggle, the register reads, the signal handling \u2014 is complete and correct. Everything in the remaining milestones builds on exactly what you've built here.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-strace-m2 -->\n<!-- MS_ID: build-strace-m2 -->\n# Milestone 2: Argument Decoding\n## Where You Are Now\nYour Milestone 1 tracer produces output like this:\n```\nsyscall(59) = 0\nsyscall(12) = 94412374278144\nsyscall(21) = -1 ENOENT\nsyscall(9) = 94412374278144\nsyscall(1) = 5\n```\nThis is *correct*. The toggle works. The error detection is right. The signal handling is right. But it's completely unreadable to a human being. Syscall 59 is `execve`. Syscall 12 is `brk`. Syscall 21 is `access`. Without names, you have numbers. Without arguments, you have calls in a vacuum.\nReal strace shows you this instead:\n```\nexecve(\"/bin/ls\", [\"/bin/ls\", \"/tmp\"], 0x7ffd3b2a8120 /* 23 vars */) = 0\nbrk(NULL) = 0x55f1a3c06000\naccess(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory)\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f...\nwrite(1, \"file1.txt  file2.txt\\n\", 21)  = 21\n```\nThis milestone builds everything that transforms the first form into the second. You'll build a syscall name table, extract arguments from the six x86_64 argument registers, read string arguments word-by-word from the tracee's memory, decode bitmask flags into human-readable names, and format output in strace style.\nThere's one concept at the center of this milestone that is genuinely surprising the first time you encounter it. Let's start there.\n---\n## The Core Revelation: Address Spaces Are Not Shared\nHere's what feels obvious: the tracee passed a string pointer to the kernel as a syscall argument. You have that pointer. The pointer is just a number \u2014 a virtual address like `0x7ffd1234abcd`. Surely you can just dereference it?\n```c\n/* What you want to do: */\nstruct user_regs_struct regs;\nptrace(PTRACE_GETREGS, child, NULL, &regs);\nchar *path = (char *)regs.rdi;  /* rdi = first argument */\nprintf(\"open(\\\"%s\\\", ...)\\n\", path);  /* \u2190 SEGFAULT or garbage */\n```\nThis feels completely reasonable. The pointer exists. It points to memory. Print the memory.\n**It crashes or prints garbage.** Here is why.\n\n![Virtual Address Space Isolation: Why PEEKDATA Exists](./diagrams/diag-m2-address-space-isolation.svg)\n\nEvery process on Linux has its own *virtual address space* \u2014 a private, independent mapping of virtual addresses to physical memory pages. The virtual address `0x7ffd1234abcd` in the tracee's address space maps to one set of physical pages. That same virtual address in *your tracer's* address space maps to something completely different \u2014 your tracer's own stack, or unmapped memory that will segfault if you dereference it, or (in rare cases where the addresses happen to coincide) a completely unrelated region.\nThe CPU's Memory Management Unit (MMU) enforces this separation at the hardware level. Every process has a pointer to its own page table stored in the `CR3` register. When a context switch happens, the kernel loads the new process's page table address into `CR3`. From that moment, all virtual addresses resolve through *that process's* page tables. Virtual address isolation isn't a software policy \u2014 it's physics. The hardware translates addresses differently depending on which `CR3` is loaded.\nThis is the foundation of process isolation. It's why one buggy process can't corrupt another's memory. It's also exactly why you can't just dereference a pointer from the tracee: your tracer's `CR3` is loaded, not the tracee's.\n> **The key insight**: A pointer is not data. A pointer is a *key* that only makes sense within the address space that owns it. To read what a tracee pointer *points to*, you need the kernel to do the translation on your behalf, using the tracee's page tables.\n`PTRACE_PEEKDATA` is exactly that: a kernel-mediated, cross-address-space read. You ask the kernel: \"In process `pid`'s address space, at virtual address `addr`, what are the 8 bytes?\" The kernel temporarily maps the tracee's page tables, reads the data, and returns it to you. One word at a time.\n---\n## PTRACE_PEEKDATA: The Word-by-Word Bridge\n`PTRACE_PEEKDATA` has this signature:\n```c\nlong ptrace(PTRACE_PEEKDATA, pid_t pid, void *addr, void *data);\n```\n- `pid` \u2014 the tracee's PID\n- `addr` \u2014 the virtual address in the tracee's address space to read from\n- `data` \u2014 ignored for PEEKDATA (the return value carries the data)\n- **Return value** \u2014 the 8 bytes at that address, returned as a `long`\nOn x86_64, one `PTRACE_PEEKDATA` call reads exactly **8 bytes** (one machine word). If you want to read a string, you must call it repeatedly, advancing the address by 8 each time, until you find a null byte.\n\n![PTRACE_PEEKDATA Word-by-Word String Extraction](./diagrams/diag-m2-peekdata-word-walk.svg)\n\n### The errno Ambiguity \u2014 A Critical Trap\nHere's the trap that breaks naive implementations:\n`PTRACE_PEEKDATA` returns its data via the return value. On error, it returns `-1`. But `-1` is `0xFFFFFFFFFFFFFFFF` as an 8-byte word \u2014 which is *valid data* that could legitimately appear in the tracee's memory. So how do you know if `-1` means \"error\" or means \"I read 8 bytes of 0xFF\"?\nYou can't tell from the return value alone. The POSIX solution: `errno`.\nWhen `PTRACE_PEEKDATA` succeeds, it does **not** modify `errno`. When it fails, it sets `errno` to indicate the error (e.g., `EIO` if the address is unmapped, `ESRCH` if the PID is gone). So the pattern is:\n```c\nerrno = 0;                                      /* Clear before the call */\nlong word = ptrace(PTRACE_PEEKDATA, pid, addr, NULL);\nif (word == -1 && errno != 0) {\n    /* Genuine error */\n    perror(\"PTRACE_PEEKDATA\");\n    return -1;\n}\n/* word is valid data \u2014 may be -1, that's fine */\n```\n\n![PEEKDATA's -1 Ambiguity: Error vs Valid Data](./diagrams/diag-m2-peekdata-errno-ambiguity.svg)\n\nThis is not optional. If you skip the `errno = 0` pre-clear, you may have stale `errno` from a previous call polluting your error check. Always zero `errno` before calling `PTRACE_PEEKDATA`.\n### Reading a String Word by Word\nWith this in mind, here's the algorithm for reading a null-terminated string from the tracee:\n1. Start at the pointer address.\n2. Read one 8-byte word with `PTRACE_PEEKDATA`.\n3. Scan the 8 bytes, one byte at a time, for a null byte (`'\\0'`).\n4. Append non-null bytes to your output buffer.\n5. If a null byte is found: done.\n6. If no null byte in this word: advance address by 8, go to step 2.\n7. Stop if you've read more than your max-length limit.\nThe byte ordering matters. On x86_64 (which is little-endian), the first byte of a word stored at address `A` is the least-significant byte of the `long` returned by `PTRACE_PEEKDATA`. That is, if the memory at address `A` contains the bytes `['h', 'e', 'l', 'l', 'o', '\\0', ?, ?]`, then `PTRACE_PEEKDATA` returns a `long` whose byte 0 (least-significant) is `'h'`, byte 1 is `'e'`, and so on.\n```c\n#define MAX_STRING_LEN 32\n/* Read a string from tracee memory at virtual address 'addr'.\n * Fills 'buf' (at most 'maxlen' bytes + NUL).\n * Returns 1 if truncated, 0 if complete, -1 on error. */\nint read_tracee_string(pid_t pid, unsigned long addr,\n                       char *buf, int maxlen, int *truncated)\n{\n    int i = 0;\n    *truncated = 0;\n    while (i < maxlen) {\n        errno = 0;\n        long word = ptrace(PTRACE_PEEKDATA, pid, (void *)addr, NULL);\n        if (word == -1 && errno != 0) {\n            if (i == 0) return -1;   /* Error on first read: nothing retrieved */\n            break;                    /* Error mid-string: return what we have */\n        }\n        /* Scan the 8 bytes of this word */\n        unsigned char *bytes = (unsigned char *)&word;\n        for (int b = 0; b < 8; b++) {\n            if (bytes[b] == '\\0') {\n                buf[i] = '\\0';\n                return 0;  /* Complete string found */\n            }\n            if (i < maxlen) {\n                buf[i++] = (char)bytes[b];\n            } else {\n                buf[i] = '\\0';\n                *truncated = 1;\n                return 0;  /* Truncated */\n            }\n        }\n        addr += 8;  /* Advance to next word */\n    }\n    buf[i] = '\\0';\n    *truncated = (i >= maxlen);\n    return 0;\n}\n```\nUse it like this:\n```c\nchar path[MAX_STRING_LEN + 1];\nint truncated;\nif (read_tracee_string(child, regs.rdi, path, MAX_STRING_LEN, &truncated) == 0) {\n    printf(\"\\\"%s%s\\\"\", path, truncated ? \"...\" : \"\");\n} else {\n    printf(\"\\\"<unreadable>\\\"\");\n}\n```\n### Null Pointer Check \u2014 Don't Peek at NULL\nBefore calling `PTRACE_PEEKDATA`, always check that the pointer is not NULL. Many syscalls accept NULL for optional arguments \u2014 for example, `execve(path, argv, NULL)` with a NULL environment pointer. Attempting `PTRACE_PEEKDATA` on address 0 will fail with `EIO` because address 0 is unmapped in every normal process. Print `NULL` (strace's convention) instead:\n```c\nif (regs.rdi == 0) {\n    printf(\"NULL\");\n} else {\n    /* read_tracee_string(...) */\n}\n```\n---\n## Building the Syscall Name Table\nTo print `open` instead of `2` (or `openat` instead of `257`), you need a lookup table mapping syscall numbers to their names. On x86_64 Linux, syscall numbers are dense integers starting from 0 \u2014 a perfect candidate for a simple array.\n\n![Syscall Table Structure: Number \u2192 Name \u2192 Argument Schema](./diagrams/diag-m2-syscall-table-design.svg)\n\n### Table Design\n```c\n/* syscall_table.h */\n#define MAX_SYSCALL_NUM 335  /* Highest syscall number on modern Linux x86_64 */\nextern const char *syscall_names[MAX_SYSCALL_NUM + 1];\nstatic inline const char *syscall_name(long num) {\n    if (num < 0 || num > MAX_SYSCALL_NUM) return \"unknown\";\n    const char *name = syscall_names[num];\n    return name ? name : \"unknown\";\n}\n```\n```c\n/* syscall_table.c \u2014 excerpt showing the structure */\nconst char *syscall_names[] = {\n    [0]   = \"read\",\n    [1]   = \"write\",\n    [2]   = \"open\",\n    [3]   = \"close\",\n    [4]   = \"stat\",\n    [5]   = \"fstat\",\n    [6]   = \"lstat\",\n    [7]   = \"poll\",\n    [8]   = \"lseek\",\n    [9]   = \"mmap\",\n    [10]  = \"mprotect\",\n    [11]  = \"munmap\",\n    [12]  = \"brk\",\n    [13]  = \"rt_sigaction\",\n    [14]  = \"rt_sigprocmask\",\n    [15]  = \"rt_sigreturn\",\n    [16]  = \"ioctl\",\n    [17]  = \"pread64\",\n    [18]  = \"pwrite64\",\n    [19]  = \"readv\",\n    [20]  = \"writev\",\n    [21]  = \"access\",\n    [22]  = \"pipe\",\n    [23]  = \"select\",\n    [24]  = \"sched_yield\",\n    [25]  = \"mremap\",\n    [26]  = \"msync\",\n    [27]  = \"mincore\",\n    [28]  = \"madvise\",\n    [29]  = \"shmget\",\n    [30]  = \"shmat\",\n    [31]  = \"shmctl\",\n    [32]  = \"dup\",\n    [33]  = \"dup2\",\n    [34]  = \"pause\",\n    [35]  = \"nanosleep\",\n    [36]  = \"getitimer\",\n    [37]  = \"alarm\",\n    [38]  = \"setitimer\",\n    [39]  = \"getpid\",\n    [40]  = \"sendfile\",\n    [41]  = \"socket\",\n    [42]  = \"connect\",\n    [43]  = \"accept\",\n    [44]  = \"sendto\",\n    [45]  = \"recvfrom\",\n    [46]  = \"sendmsg\",\n    [47]  = \"recvmsg\",\n    [48]  = \"shutdown\",\n    [49]  = \"bind\",\n    [50]  = \"listen\",\n    [51]  = \"getsockname\",\n    [52]  = \"getpeername\",\n    [53]  = \"socketpair\",\n    [54]  = \"setsockopt\",\n    [55]  = \"getsockopt\",\n    [56]  = \"clone\",\n    [57]  = \"fork\",\n    [58]  = \"vfork\",\n    [59]  = \"execve\",\n    [60]  = \"exit\",\n    [61]  = \"wait4\",\n    [62]  = \"kill\",\n    [63]  = \"uname\",\n    [72]  = \"fcntl\",\n    [74]  = \"fsync\",\n    [78]  = \"getdents\",\n    [79]  = \"getcwd\",\n    [80]  = \"chdir\",\n    [82]  = \"rename\",\n    [83]  = \"mkdir\",\n    [84]  = \"rmdir\",\n    [85]  = \"creat\",\n    [86]  = \"link\",\n    [87]  = \"unlink\",\n    [88]  = \"symlink\",\n    [89]  = \"readlink\",\n    [90]  = \"chmod\",\n    [91]  = \"fchmod\",\n    [99]  = \"sysinfo\",\n    [102] = \"getuid\",\n    [104] = \"getgid\",\n    [107] = \"geteuid\",\n    [108] = \"getegid\",\n    [110] = \"getppid\",\n    [111] = \"getpgrp\",\n    [112] = \"setsid\",\n    [158] = \"arch_prctl\",\n    [186] = \"gettid\",\n    [202] = \"futex\",\n    [218] = \"set_tid_address\",\n    [228] = \"clock_gettime\",\n    [231] = \"exit_group\",\n    [257] = \"openat\",\n    [262] = \"newfstatat\",\n    [269] = \"faccessat\",\n    [281] = \"epoll_pwait\",\n    [302] = \"prlimit64\",\n    /* Sparse entries return NULL \u2192 syscall_name() returns \"unknown\" */\n};\n```\nThe C99 designated initializer syntax (`[n] = \"name\"`) lets you define a sparse array cleanly. Entries you don't define are initialized to NULL by default, and your `syscall_name()` function handles that with the `\"unknown\"` fallback.\n> \ud83d\udd2d **Deep Dive**: The authoritative x86_64 syscall table lives in the Linux kernel source at `arch/x86/entry/syscalls/syscall_64.tbl`. It's generated during kernel build into header files. For the definitive current list, see [Ryan Chapman's syscall table](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/) or the kernel source directly.\n---\n## Extracting Arguments from Registers\nWith Milestone 1, you already know how to get a `struct user_regs_struct`. Now you need to map the six argument registers to the six argument positions of each syscall.\n\n![Syscall Argument Register Mapping with Examples](./diagrams/diag-m2-argument-register-mapping.svg)\n\nThe x86_64 Linux syscall ABI assigns arguments in this fixed order:\n| Argument # | Register | `user_regs_struct` field |\n|-----------|----------|--------------------------|\n| 1         | `rdi`    | `regs.rdi`               |\n| 2         | `rsi`    | `regs.rsi`               |\n| 3         | `rdx`    | `regs.rdx`               |\n| 4         | `r10`    | `regs.r10`               |\n| 5         | `r8`     | `regs.r8`                |\n| 6         | `r9`     | `regs.r9`                |\nIt helps to put these into an array at the start of your argument-decoding code, so you can index them generically:\n```c\nunsigned long long args[6] = {\n    regs.rdi,\n    regs.rsi,\n    regs.rdx,\n    regs.r10,\n    regs.r8,\n    regs.r9\n};\n```\nNow `args[0]` is always argument 1, `args[1]` is always argument 2, and so on. You can build a dispatch table keyed on syscall number that says \"for syscall N, argument 0 is a string, argument 1 is an integer flags field, argument 2 is a mode.\"\n---\n## The Argument Schema: Knowing What Type Each Argument Is\nDifferent syscalls have different argument types. `open(path, flags, mode)` has a string, flags bitmask, and integer. `read(fd, buf, count)` has an integer, a pointer (usually printed as a hex address), and an integer. You need a way to describe each syscall's argument signature so your decoder can format each argument correctly.\nDefine an argument type enum and a syscall descriptor struct:\n```c\n/* arg_type.h */\ntypedef enum {\n    ARG_INT,      /* Print as signed decimal integer */\n    ARG_UINT,     /* Print as unsigned decimal integer */\n    ARG_HEX,      /* Print as hexadecimal (addresses, pointers) */\n    ARG_STR,      /* Read from tracee memory as a null-terminated string */\n    ARG_PTR,      /* Pointer: print as hex if non-NULL, else \"NULL\" */\n    ARG_OPEN_FLAGS,  /* Bitmask: O_RDONLY | O_CREAT | ... */\n    ARG_MMAP_PROT,   /* Bitmask: PROT_READ | PROT_WRITE | ... */\n    ARG_MMAP_FLAGS,  /* Bitmask: MAP_SHARED | MAP_PRIVATE | MAP_ANONYMOUS | ... */\n    ARG_IGNORE,   /* Don't print (e.g., padding args, high args for simple calls) */\n} ArgType;\ntypedef struct {\n    int         num_args;     /* How many arguments to display */\n    ArgType     arg_types[6]; /* Type for each argument position */\n} SyscallDesc;\n```\nThen build a table mapping syscall numbers to their descriptors:\n```c\n/* syscall_desc.c \u2014 partial */\nstatic const SyscallDesc desc_table[] = {\n    [0]  = { 3, { ARG_INT, ARG_PTR,  ARG_UINT } },         /* read(fd, buf, count) */\n    [1]  = { 3, { ARG_INT, ARG_STR,  ARG_UINT } },         /* write(fd, buf, count) */\n    [2]  = { 3, { ARG_STR, ARG_OPEN_FLAGS, ARG_UINT } },   /* open(path, flags, mode) */\n    [3]  = { 1, { ARG_INT } },                              /* close(fd) */\n    [4]  = { 2, { ARG_STR, ARG_PTR  } },                   /* stat(path, statbuf) */\n    [5]  = { 2, { ARG_INT, ARG_PTR  } },                   /* fstat(fd, statbuf) */\n    [9]  = { 6, { ARG_PTR, ARG_UINT, ARG_MMAP_PROT,\n                  ARG_MMAP_FLAGS, ARG_INT, ARG_UINT } },    /* mmap(...) */\n    [11] = { 2, { ARG_PTR, ARG_UINT } },                   /* munmap(addr, len) */\n    [21] = { 2, { ARG_STR, ARG_INT  } },                   /* access(path, mode) */\n    [39] = { 0, { 0 } },                                    /* getpid() */\n    [57] = { 0, { 0 } },                                    /* fork() */\n    [59] = { 3, { ARG_STR, ARG_PTR, ARG_PTR } },           /* execve(path, argv, envp) */\n    [60] = { 1, { ARG_INT } },                              /* exit(code) */\n    [257]= { 4, { ARG_INT, ARG_STR, ARG_OPEN_FLAGS,\n                  ARG_UINT } },                             /* openat(dfd, path, flags, mode) */\n    /* ... more entries ... */\n};\n#define DESC_TABLE_SIZE (sizeof(desc_table) / sizeof(desc_table[0]))\nconst SyscallDesc *get_syscall_desc(long num) {\n    if (num < 0 || (size_t)num >= DESC_TABLE_SIZE) return NULL;\n    /* Zero-initialized entries have num_args = 0 \u2014 that's fine, prints no args */\n    return &desc_table[num];\n}\n```\n> **Note on write(fd, buf, count)**: For `write`, argument 1 (`buf`) is technically a string in memory, but we mark it as `ARG_STR` rather than `ARG_PTR`. This lets us peek at the buffer and print its content (up to the truncation limit), which is exactly what strace does. It's intentional \u2014 showing what was written is the useful thing.\n---\n## Bitmask Flag Decoding\nWhen you call `open(\"/etc/passwd\", O_RDONLY | O_CLOEXEC, 0)`, the flags argument is `0x80000` (O_CLOEXEC = 0x80000, O_RDONLY = 0). Printing `0x80000` is correct but useless to a reader. Printing `O_CLOEXEC` is immediately meaningful.\n\n![Bitmask Flag Decoding: open() Flags Example](./diagrams/diag-m2-flag-bitmask-decode.svg)\n\nThe approach: define a table of `(bit_value, name)` pairs for each flag set, then iterate through the table building a string of names joined by `|`.\n```c\ntypedef struct {\n    unsigned long value;\n    const char   *name;\n} FlagEntry;\n/* open() flags \u2014 from <fcntl.h>, matched to actual numeric values */\nstatic const FlagEntry open_flags[] = {\n    /* Access mode \u2014 these are special: only bits 0-1 */\n    { O_RDONLY,   \"O_RDONLY\"   },\n    { O_WRONLY,   \"O_WRONLY\"   },\n    { O_RDWR,     \"O_RDWR\"    },\n    /* Single-bit flags */\n    { O_CREAT,    \"O_CREAT\"   },\n    { O_EXCL,     \"O_EXCL\"    },\n    { O_NOCTTY,   \"O_NOCTTY\"  },\n    { O_TRUNC,    \"O_TRUNC\"   },\n    { O_APPEND,   \"O_APPEND\"  },\n    { O_NONBLOCK, \"O_NONBLOCK\"},\n    { O_DSYNC,    \"O_DSYNC\"   },\n    { O_SYNC,     \"O_SYNC\"    },\n    { O_CLOEXEC,  \"O_CLOEXEC\" },\n    { O_TMPFILE,  \"O_TMPFILE\" },\n    { O_DIRECTORY,\"O_DIRECTORY\"},\n    { O_NOFOLLOW, \"O_NOFOLLOW\"},\n    { O_PATH,     \"O_PATH\"    },\n    { 0, NULL }   /* sentinel */\n};\n/* mmap() prot flags \u2014 from <sys/mman.h> */\nstatic const FlagEntry mmap_prot_flags[] = {\n    { PROT_NONE,  \"PROT_NONE\"  },\n    { PROT_READ,  \"PROT_READ\"  },\n    { PROT_WRITE, \"PROT_WRITE\" },\n    { PROT_EXEC,  \"PROT_EXEC\"  },\n    { 0, NULL }\n};\n/* mmap() map flags */\nstatic const FlagEntry mmap_map_flags[] = {\n    { MAP_SHARED,     \"MAP_SHARED\"     },\n    { MAP_PRIVATE,    \"MAP_PRIVATE\"    },\n    { MAP_FIXED,      \"MAP_FIXED\"      },\n    { MAP_ANONYMOUS,  \"MAP_ANONYMOUS\"  },\n    { MAP_GROWSDOWN,  \"MAP_GROWSDOWN\"  },\n    { MAP_DENYWRITE,  \"MAP_DENYWRITE\"  },\n    { MAP_EXECUTABLE, \"MAP_EXECUTABLE\" },\n    { MAP_LOCKED,     \"MAP_LOCKED\"     },\n    { MAP_NORESERVE,  \"MAP_NORESERVE\"  },\n    { MAP_POPULATE,   \"MAP_POPULATE\"   },\n    { MAP_HUGETLB,    \"MAP_HUGETLB\"    },\n    { 0, NULL }\n};\n```\nThe decoding function:\n```c\n/* Decode a bitmask flags value into a \"|\"-separated string.\n * Special case: O_RDONLY = 0, which needs explicit handling.\n * Returns number of bytes written to buf. */\nint decode_flags(unsigned long value, const FlagEntry *table,\n                 char *buf, int bufsize)\n{\n    int written = 0;\n    int first = 1;\n    /* Special case: if value is 0 and the first entry is 0, print its name */\n    if (value == 0 && table[0].value == 0 && table[0].name != NULL) {\n        return snprintf(buf, bufsize, \"%s\", table[0].name);\n    }\n    for (int i = 0; table[i].name != NULL; i++) {\n        if (table[i].value == 0) continue;  /* Skip the zero-value entry in loop */\n        if ((value & table[i].value) == table[i].value) {\n            int n = snprintf(buf + written, bufsize - written,\n                             \"%s%s\",\n                             first ? \"\" : \"|\",\n                             table[i].name);\n            written += n;\n            first = 0;\n            value &= ~table[i].value;  /* Clear matched bits */\n        }\n    }\n    /* If there are remaining unrecognized bits, print them as hex */\n    if (value != 0) {\n        int n = snprintf(buf + written, bufsize - written,\n                         \"%s0x%lx\", first ? \"\" : \"|\", value);\n        written += n;\n    }\n    /* If nothing matched at all, print the raw value */\n    if (first) {\n        written = snprintf(buf, bufsize, \"0x%lx\", value);\n    }\n    return written;\n}\n```\nThe O_RDONLY edge case is important. `O_RDONLY` is defined as `0` in the Linux headers. A bitwise `AND` with zero always produces zero \u2014 so you can't detect `O_RDONLY` by masking. The special case handles this: if the entire value is 0 and the first table entry covers 0, print it directly.\nSimilarly, `PROT_NONE` is 0 for mmap. The same logic applies.\n---\n## Three-Level View: What Happens When You Print an Argument\nLet's trace through all three levels for the specific case of `open(\"/etc/passwd\", O_RDONLY)` being printed by your tracer.\n**Level 1 \u2014 Application (Tracee)**\nThe tracee's code (inside glibc or your test program) calls:\n```c\nint fd = open(\"/etc/passwd\", O_RDONLY);\n```\nglibc's wrapper places `/etc/passwd`'s address in `rdi`, `O_RDONLY` (which is 0) in `rsi`, and syscall number 2 in `rax`, then executes the `syscall` instruction. The string `\"/etc/passwd\"` lives somewhere in the tracee's memory \u2014 perhaps on its stack at address `0x7ffd3a2c1000`.\n**Level 2 \u2014 Your Tracer (Kernel-mediated)**\nYour tracer wakes up on the entry stop, reads `orig_rax = 2` (open), reads `rdi = 0x7ffd3a2c1000`. It looks up syscall 2 in the descriptor table: first argument is `ARG_STR`. So it calls `PTRACE_PEEKDATA(child, 0x7ffd3a2c1000)`.\nThe kernel handles this PEEKDATA request:\n1. Finds the tracee's page table (its `mm_struct`).\n2. Walks the page table to find which physical page backs `0x7ffd3a2c1000`.\n3. Maps that physical page into kernel address space temporarily.\n4. Copies 8 bytes from that page to the return value.\n5. Returns to your tracer.\nYour tracer receives, say, `0x7361702f6374652f` \u2014 which as bytes (little-endian) is `/`, `e`, `t`, `c`, `/`, `p`, `a`, `s`. No null terminator yet. Advance address by 8 to `0x7ffd3a2c1008`. Call `PTRACE_PEEKDATA` again. Receive `0x0064777773`, which bytes are `s`, `w`, `d`, `\\0`. Null terminator found. The string is `/etc/passwd`.\n**Level 3 \u2014 Hardware**\nWhen the `ptrace(PTRACE_PEEKDATA, ...)` syscall executes:\n- The CPU is running your tracer's code. The MMU is using your tracer's page table (`CR3` points to your tracer's `mm_struct`).\n- The kernel syscall handler switches context: it uses the tracee's `mm_struct` to do the virtual\u2192physical translation for `0x7ffd3a2c1000`.\n- This translation involves a 4-level page table walk on x86_64 (PGD \u2192 P4D \u2192 PUD \u2192 PMD \u2192 PTE). If the tracee's TLB has the address cached, the walk is short. If not, it's a full 4-level walk.\n- The physical page is accessed via the kernel's direct mapping of physical memory (the kernel maps all physical memory starting at a fixed virtual address). No TLB miss for the kernel's own access.\n- The 8 bytes are copied into the `long` return value.\n- The context switches back to your tracer.\nThe cost per `PTRACE_PEEKDATA` call: roughly 1,000-3,000 CPU cycles (one full context switch into the kernel, a page table walk, and a context switch back). For a 32-byte string, you need 4 calls: **4,000\u201312,000 CPU cycles just to read a path argument**. This is why strace is slow. A program that makes 10,000 `open()` calls would have your tracer spend ~100M cycles just reading the path arguments.\n---\n## Formatting Output in strace Style\nNow you have all the pieces. The output format strace uses is:\n```\nsyscall_name(arg1, arg2, ...) = return_value\n```\nFor errors:\n```\nsyscall_name(arg1, arg2, ...) = -1 ERRNO (error message)\n```\nLet's build the `print_syscall` function that assembles this output. It's called on the **exit stop**, when you have both the entry registers (saved from the entry stop) and the return value in `rax`.\n> **Important**: To print arguments, you need the register state from **entry**, not exit. Argument registers (`rdi`, `rsi`, etc.) may have been modified by the kernel during the syscall. But the crucial field `orig_rax` persists. For arguments, you need to save the entry registers. Add a `struct user_regs_struct entry_regs` to your per-process state and populate it on entry.\n\n![Complete Trace of open() \u2014 From Registers to Formatted Output](./diagrams/diag-m2-full-trace-example.svg)\n\n```c\n/* print one argument of a given type */\nstatic void print_arg(pid_t pid, unsigned long long value, ArgType type)\n{\n    char buf[MAX_STRING_LEN + 4];  /* +4 for \"...\" + NUL */\n    char flags_buf[256];\n    int truncated;\n    switch (type) {\n    case ARG_INT:\n        printf(\"%lld\", (long long)value);\n        break;\n    case ARG_UINT:\n        printf(\"%llu\", (unsigned long long)value);\n        break;\n    case ARG_HEX:\n        printf(\"0x%llx\", (unsigned long long)value);\n        break;\n    case ARG_STR:\n        if (value == 0) {\n            printf(\"NULL\");\n        } else {\n            if (read_tracee_string(pid, (unsigned long)value,\n                                   buf, MAX_STRING_LEN, &truncated) == 0) {\n                printf(\"\\\"%s%s\\\"\", buf, truncated ? \"...\" : \"\");\n            } else {\n                printf(\"\\\"<unreadable>\\\"\");\n            }\n        }\n        break;\n    case ARG_PTR:\n        if (value == 0) printf(\"NULL\");\n        else            printf(\"0x%llx\", (unsigned long long)value);\n        break;\n    case ARG_OPEN_FLAGS:\n        decode_flags((unsigned long)value, open_flags, flags_buf, sizeof(flags_buf));\n        printf(\"%s\", flags_buf);\n        break;\n    case ARG_MMAP_PROT:\n        decode_flags((unsigned long)value, mmap_prot_flags, flags_buf, sizeof(flags_buf));\n        printf(\"%s\", flags_buf);\n        break;\n    case ARG_MMAP_FLAGS:\n        decode_flags((unsigned long)value, mmap_map_flags, flags_buf, sizeof(flags_buf));\n        printf(\"%s\", flags_buf);\n        break;\n    case ARG_IGNORE:\n        break;\n    }\n}\nvoid print_syscall(pid_t pid,\n                   struct user_regs_struct *entry_regs,\n                   long return_val)\n{\n    long syscall_num = (long)entry_regs->orig_rax;\n    const char *name = syscall_name(syscall_num);\n    const SyscallDesc *desc = get_syscall_desc(syscall_num);\n    unsigned long long args[6] = {\n        entry_regs->rdi, entry_regs->rsi, entry_regs->rdx,\n        entry_regs->r10, entry_regs->r8,  entry_regs->r9\n    };\n    printf(\"%s(\", name);\n    if (desc != NULL && desc->num_args > 0) {\n        for (int i = 0; i < desc->num_args; i++) {\n            if (i > 0) printf(\", \");\n            print_arg(pid, args[i], desc->arg_types[i]);\n        }\n    }\n    printf(\") = \");\n    /* Print return value */\n    if (return_val >= -4096L && return_val <= -1L) {\n        int err_num = (int)(-return_val);\n        printf(\"-1 %s (%s)\\n\", strerrorname_np(err_num), strerror(err_num));\n        /* Note: strerrorname_np is glibc >= 2.32; fallback below */\n    } else {\n        printf(\"%ld\\n\", return_val);\n    }\n}\n```\n> **Portable errno name**: `strerrorname_np` (non-portable glibc extension since 2.32) returns just the name like `\"ENOENT\"`. If your system doesn't have it, build a small table mapping errno values to their symbolic names:\n>\n> ```c\n> static const char *errno_names[] = {\n>     [EPERM]   = \"EPERM\",\n>     [ENOENT]  = \"ENOENT\",\n>     [ESRCH]   = \"ESRCH\",\n>     [EINTR]   = \"EINTR\",\n>     [EIO]     = \"EIO\",\n>     [ENXIO]   = \"ENXIO\",\n>     [E2BIG]   = \"E2BIG\",\n>     /* ... */\n>     [EBADF]   = \"EBADF\",\n>     [ECHILD]  = \"ECHILD\",\n>     [EAGAIN]  = \"EAGAIN\",\n>     [ENOMEM]  = \"ENOMEM\",\n>     [EACCES]  = \"EACCES\",\n>     [EFAULT]  = \"EFAULT\",\n>     /* ... */\n> };\n> ```\n---\n## Integrating with the Milestone 1 Loop\nIn Milestone 1, you had a single toggle flag and a `struct user_regs_struct` read on exit. Now you need to save the entry registers. Modify the state:\n```c\n/* Per-process state \u2014 will grow significantly in Milestone 3 */\ntypedef struct {\n    int                    in_syscall;   /* Toggle: 0=entry, 1=exit */\n    struct user_regs_struct entry_regs;  /* Registers saved at entry stop */\n} ProcessState;\n```\nAnd update the tracing loop:\n```c\nProcessState state = { .in_syscall = 0 };\n/* Inside the WIFSTOPPED / (sig == (SIGTRAP | 0x80)) branch: */\nstruct user_regs_struct regs;\nif (ptrace(PTRACE_GETREGS, child, NULL, &regs) == -1) {\n    perror(\"ptrace GETREGS\");\n    break;\n}\nif (state.in_syscall == 0) {\n    /* ENTRY: save registers, flip toggle */\n    state.entry_regs = regs;\n    state.in_syscall = 1;\n} else {\n    /* EXIT: print with saved entry registers + current return value */\n    long return_val = (long)regs.rax;\n    print_syscall(child, &state.entry_regs, return_val);\n    state.in_syscall = 0;\n}\n```\nThat's it. The entry state saves the register snapshot. The exit state uses both the saved entry registers (for arguments and syscall number) and the current `rax` (for the return value).\n---\n## What Real Traces Look Like\nAfter this milestone, running `./strace_clone /bin/ls /tmp` produces something like:\n```\nexecve(\"/bin/ls\", [\"/bin/ls\", \"/tmp\"], 0x7ffd3b2c1200) = 0\nbrk(NULL) = 0x562a1a3c0000\narch_prctl(0x3001, 0x7ffd13e26250) = -1 EINVAL (Invalid argument)\naccess(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, \"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, 0x7ffd13e265d0) = 0\nmmap(NULL, 25673, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f12ab312000\nclose(3) = 0\nopenat(AT_FDCWD, \"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>...\", 832) = 832\n...\nwrite(1, \"file1.txt  file2.txt\\n\", 21)  = 21\n+++ exited with 0 +++\n```\nThis matches real strace output. Notice `O_RDONLY|O_CLOEXEC` for the flags, `PROT_READ` for mmap, hex address for the statbuf pointer, and the ELF magic bytes peeked out of the read buffer.\n---\n## Common Bugs in This Milestone\n### Bug 1: Using exit registers for argument printing\n```c\n/* WRONG: reading argument registers on exit */\nif (state.in_syscall == 1) {\n    /* regs is from GETREGS on EXIT STOP */\n    printf(\"arg1 = %llu\\n\", regs.rdi);  /* rdi may have been modified! */\n}\n```\nSome syscalls modify their argument registers as part of execution (rare, but it happens with some kernel internals). More importantly, you may have an architecture guarantee that arguments are preserved, but it's safer and more correct to save them at entry. Always save entry registers.\n### Bug 2: Forgetting `errno = 0` before PEEKDATA\n```c\n/* WRONG: no errno pre-clear */\nlong word = ptrace(PTRACE_PEEKDATA, pid, addr, NULL);\nif (word == -1 && errno != 0) {\n    /* Bug: errno might be non-zero from a previous failed call,\n     * making valid data look like an error */\n}\n```\nEven if your PEEKDATA succeeds, a stale non-zero `errno` from an earlier operation (like a failed `printf` call, or a prior PEEKDATA that genuinely failed) will make `word == -1` look like an error when it's actually valid data. Always `errno = 0` first.\n### Bug 3: Infinite loop on non-null-terminated strings\nIf you trace a program writing to a pipe or socket, the `buf` argument to `write()` may not be null-terminated \u2014 it's a binary buffer, not a C string. Your string reader *must* stop at `maxlen` bytes regardless of whether it found `'\\0'`. The loop bound is essential:\n```c\nwhile (i < maxlen) {   /* \u2190 This bound is load-bearing. Never remove it. */\n    /* PEEKDATA + scan ... */\n}\n```\n### Bug 4: Wrong byte order when scanning a PEEKDATA word\nOn x86_64 (little-endian), the first byte of a word at address `A` is the *least significant byte* of the returned `long`. This means:\n```c\nunsigned char *bytes = (unsigned char *)&word;\n/* bytes[0] is the byte at address A     (LSB of the long) */\n/* bytes[1] is the byte at address A+1   */\n/* bytes[7] is the byte at address A+7   (MSB of the long) */\n```\nIf you extract bytes as `(word >> 0) & 0xFF`, `(word >> 8) & 0xFF`, etc., you get the same result. Either approach works as long as you start from the least significant end. Getting this wrong means reading strings in the wrong byte order \u2014 the test is simple: if `/etc/ld.so.cache` reads as `cte/ld.so.cache/` you have an endianness bug.\n### Bug 5: Decoding flags when O_RDONLY (0) is not explicitly flagged\nIf you open a file with `O_RDONLY`, the flags argument is 0. Iterating through your flags table with `value & flag == flag` will never match any entry (since `0 & anything = 0`). Result: decode_flags returns an empty string or prints nothing. Handle the `value == 0` case explicitly by printing the name of the first table entry (which should be `O_RDONLY`/`PROT_NONE`).\n---\n## Hardware Soul: The Memory Cost of Argument Decoding\nWhen your tracer reads a string argument, what's happening at the hardware level?\n**Cache lines**: The tracee's string data lives in the tracee's cache. When the tracer calls `PTRACE_PEEKDATA`, the kernel reads the physical page. If the tracee recently accessed this string (it just put it in `rdi` before `syscall`), the data is likely in L1 or L2 cache. The kernel can satisfy the PEEKDATA from the CPU cache \u2014 no DRAM access needed. This is one reason PEEKDATA is \"only\" ~1,000-3,000 cycles rather than 10,000+ cycles.\n**TLB**: The tracee's page table mapping for the string address is likely still in the TLB (the tracee just accessed it). But your tracer is running with a different `CR3` \u2014 its TLB entries don't include the tracee's virtual addresses. The kernel uses its own TLB tags (or temporarily switches page tables) to perform the access. Modern x86_64 CPUs use PCID (Process Context IDs) to avoid full TLB flushes on context switches, but cross-process memory access still has TLB overhead.\n**Context switch cost**: Every `ptrace()` call is a userspace\u2192kernel\u2192userspace round trip. That's a minimum of ~200\u2013500 cycles just for the mode switch, plus the actual work. For a 64-byte path name (8 PEEKDATA calls): 8 \u00d7 1,500 cycles \u2248 12,000 cycles. At 3 GHz, that's 4 microseconds *just to read one filename*. A program that opens 10,000 files takes 40ms of pure tracing overhead reading filenames \u2014 before any other tracing work.\n**This is why strace is slow**. It's not the toggle logic or the flag decoding. It's the PEEKDATA loop. The real strace codebase addresses this with multiple optimizations we'll discuss in the Knowledge Cascade.\n---\n## Knowledge Cascade: What This Unlocks\n### 1. /proc/PID/mem \u2014 Amortizing PEEKDATA Overhead\n`/proc/PID/mem` is a special file that represents the tracee's entire address space as a file. Open it, `lseek` to the desired virtual address, and call `read()` to get data. The key advantage: you can read *arbitrary lengths* in one `read()` call, not just 8 bytes.\n```c\n/* Alternative to PTRACE_PEEKDATA for long strings */\nchar path_buf[1024];\nint memfd;\nchar mempath[64];\nsnprintf(mempath, sizeof(mempath), \"/proc/%d/mem\", pid);\nmemfd = open(mempath, O_RDONLY);\npread(memfd, path_buf, sizeof(path_buf), (off_t)addr);\nclose(memfd);\n```\nModern strace (versions \u2265 4.14) uses `/proc/PID/mem` for string reads, falling back to PEEKDATA only when the file isn't accessible. A 256-byte path string costs 1 `pread()` call instead of 32 `PTRACE_PEEKDATA` calls \u2014 a 32\u00d7 reduction in syscall overhead for that read. The catch: `/proc/PID/mem` requires the tracee to be stopped (which ptrace ensures) and requires appropriate permissions (which you have, since you're the tracer).\n### 2. process_vm_readv \u2014 The Modern Cross-Address-Space Copy\nLinux 3.2 introduced `process_vm_readv(2)`, a syscall designed specifically for this problem:\n```c\n#include <sys/uio.h>\nssize_t process_vm_readv(pid_t pid,\n                         const struct iovec *local_iov,\n                         unsigned long liovcnt,\n                         const struct iovec *remote_iov,\n                         unsigned long riovcnt,\n                         unsigned long flags);\n```\nYou describe a list of source regions in the *remote* (tracee) address space and a list of destination buffers in your *local* address space. The kernel copies all of them in a single syscall, without the per-word overhead of PEEKDATA. This is 10-100\u00d7 faster than a PEEKDATA loop for multi-word copies.\n`process_vm_readv` doesn't require the tracee to be stopped \u2014 it works on running processes. This makes it ideal for profiling tools that want to sample the tracee's memory without full ptrace overhead. The tradeoff: less precision (the target may have moved on while you're reading), and it requires `PTRACE_MODE_ATTACH_REALCREDS` privileges if the target isn't your child.\n### 3. Virtual Memory and Page Tables \u2014 Why Address Spaces Are Isolated\nThe `CR3` register holds the physical address of the page directory (the top of the 4-level page table on x86_64). Every process has its own `CR3` value stored in its kernel-side task structure. During context switch, the kernel does `mov %cr3, <new_value>` \u2014 and from that moment, all virtual address translations go through the new process's page tables.\nThis hardware mechanism is why process isolation works and why PEEKDATA must exist. The MMU is not a software construct; it's silicon that enforces virtual\u2192physical translation on every single memory access the CPU makes. Bypassing it requires going through the kernel, which is exactly what PEEKDATA does.\nUnderstanding `CR3` and page tables is also the foundation for:\n- Container runtimes (each container process has its own address space \u2014 no additional mechanism needed)\n- VM introspection (hypervisors reading guest VM memory use the same \"cross-address-space read\" concept but at the VM level)\n- Kernel Samepage Merging (KSM) \u2014 the kernel scans different processes' physical pages looking for duplicates to merge\n> \ud83d\udd2d **Deep Dive**: For a thorough treatment of x86_64 virtual memory and page table structure, see the Intel Software Developer's Manual Volume 3A, Section 4 (\"Paging\"), or for a more accessible treatment, Bovet & Cesati's *Understanding the Linux Kernel* (3rd edition), Chapter 2.\n### 4. GDB's `x` Command \u2014 The Same Mechanism\nWhen you use GDB's `x/s $rdi` to examine a string at the address in `rdi`, GDB is doing exactly what you've just built: calling `PTRACE_PEEKDATA` in a loop, scanning for null bytes, and printing the result. This is why examining 1MB of memory in GDB can take several seconds \u2014 it's thousands of PEEKDATA calls, each costing a kernel round trip.\nGDB also uses `/proc/PID/mem` as an optimization (since GDB 7.12, approximately). You can verify this with `strace -p $(pgrep gdb)` \u2014 you'll see `pread64` calls on the `/proc/...mem` file descriptor, interspersed with the usual ptrace calls.\nNow you understand not just *that* GDB is slow at memory examination, but *exactly why* and *what the limit is*. A PEEKDATA word costs ~1,500 cycles. At 1 GHz effective throughput (accounting for kernel overhead), examining 1MB via PEEKDATA would take ~190,000 calls \u00d7 1,500 cycles = 285,000,000 cycles \u2248 95ms. Via `/proc/PID/mem`, it's one `pread()` \u2248 5ms.\n### 5. ELF String Tables \u2014 The Same Index Structure\nThe syscall name table you built \u2014 a fixed array indexed by number, containing string pointers \u2014 mirrors the structure ELF binaries use to store symbol names. An ELF file contains a `.strtab` section (a flat array of null-terminated strings packed end-to-end) and a `.symtab` section (an array of symbol entries, each containing an offset into `.strtab`). To find a symbol's name, you index `.symtab` by symbol number, read the `st_name` offset, then index into `.strtab` at that offset.\nYour table is the same pattern: array index = syscall number, value = pointer to name string. ELF just flattens the strings into one big buffer and uses offsets instead of pointers. This is a common pattern in systems software: \"index \u2192 offset \u2192 null-terminated string in a flat buffer.\" You'll see it in font files, debug information (DWARF), and network protocol tables.\n---\n## Summary: What You've Built\nYour tracer now:\n- Looks up syscall numbers in a name table and prints human-readable names like `open`, `mmap`, `write`\n- Saves register state at entry and uses it on exit to print argument values\n- Extracts integer, pointer, and string arguments from the six x86_64 syscall argument registers (`rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9`)\n- Reads string arguments from the tracee's memory word-by-word via `PTRACE_PEEKDATA`, correctly handling the `errno`-vs-`-1` ambiguity\n- Truncates strings at a configurable maximum (default 32 bytes) with a `...` suffix\n- Decodes bitmask flag arguments for `open()`, `mmap()` prot, and `mmap()` flags into `O_RDONLY|O_CLOEXEC`-style strings\n- Handles edge cases: NULL pointers (prints `NULL`), unrecognized syscalls (`unknown`), unknown flags (prints remaining bits as hex)\n- Formats output in strace style: `syscall_name(arg1, arg2) = return_value`\nThe output of your tracer is now human-readable. Milestone 3 will make it multi-process-aware: following `fork()`, `vfork()`, and `clone()` across process boundaries, tagging every line with the PID that made the call, and maintaining per-PID state to keep the entry/exit toggle correct across interleaved events.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-strace-m3 -->\n# Milestone 3: Multi-Process and Fork Following\n## Where You Are Now\nYour Milestone 2 tracer produces beautifully formatted output for a single process:\n```\nexecve(\"/bin/ls\", [\"/bin/ls\", \"/tmp\"], 0x7ffd3b2c1200) = 0\nbrk(NULL) = 0x562a1a3c0000\naccess(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, \"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nwrite(1, \"file1.txt  file2.txt\\n\", 21) = 21\n+++ exited with 0 +++\n```\nNow run your tracer against something that calls `fork()`:\n```bash\n./strace_clone bash -c \"echo hello | cat\"\n```\nWhat happens? Your tracer prints the bash startup syscalls faithfully. Then bash calls `fork()` to spawn a subshell, and `fork()` again to run `echo`, and `fork()` again to run `cat`. The forked children run entirely unobserved. Your tracer is watching bash's side of the story \u2014 everything the children do is invisible. The `echo` and `cat` processes run, write to the pipe, exit, and you never saw a single syscall from them.\nThis isn't just an annoyance. It's a fundamental limitation that makes your tracer incorrect for any non-trivial workload. Shell scripts, Python programs, web servers, databases \u2014 they all fork. The real strace traces the *entire process tree*, and that's what you'll build in this milestone.\nBy the end, your tracer will produce output like this:\n```\n[pid 12345] execve(\"/bin/bash\", [\"/bin/bash\", \"-c\", \"echo hello | cat\"], ...) = 0\n[pid 12345] pipe([3, 4]) = 0\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|...) = 12346\n[pid 12346] execve(\"/bin/echo\", [\"/bin/echo\", \"hello\"], ...) = 0\n[pid 12346] write(1, \"hello\\n\", 6) = 6\n[pid 12346] exit_group(0) = ?\n[pid 12345] wait4(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], ...) = 12346\n+++ exited with 0 +++\n```\nEvery process. Every syscall. Correctly interleaved. That's what this milestone delivers.\n\n![Interleaved Multi-Process Output Example](./diagrams/diag-m3-multi-process-output.svg)\n\n---\n## The Core Revelation: Tracing Is Not Inherited\nHere is the assumption that will break your first attempt at multi-process tracing:\n> *The child process inherits everything from its parent \u2014 file descriptors, memory mappings, signal handlers. Surely it inherits the ptrace relationship too?*\nThis feels completely reasonable. After all, if ptrace is about observation, and the child is a copy of the parent, shouldn't the kernel observe the child too? The child even shares the parent's executable code until copy-on-write kicks in. Why would the tracing relationship be different?\n**It isn't inherited. Not at all.** When a traced process calls `fork()`, the child process starts life *completely untraced*. It runs at full speed, unobserved, making syscalls your tracer never sees. By the time you even learn that a fork happened \u2014 via the `PTRACE_SYSCALL` event that fires in the parent \u2014 the child may have already run thousands of syscalls and possibly exited.\nThis is not an oversight in the kernel design. There's a deep reason: ptrace is a relationship between *specific processes*. The kernel tracks a tracer PID for each tracee. When a fork creates a new PID, that new PID has no tracer until one is explicitly designated. The kernel won't automatically assign your tracer as the observer of a process it didn't ask to observe. Automatic inheritance would be a security hole \u2014 imagine a traced sandbox program forking an untraced helper that escapes the sandbox's policy.\nThe solution is to opt in *before* the fork happens, using `PTRACE_SETOPTIONS`. When you set `PTRACE_O_TRACEFORK`, `PTRACE_O_TRACEVFORK`, and `PTRACE_O_TRACECLONE` on a tracee, you're telling the kernel: \"When this process calls `fork()`, `vfork()`, or `clone()`, automatically attach to the new child on my behalf, and deliver a special event stop to tell me about it.\" The kernel does this atomically \u2014 there is no window where the child runs untraced. The child starts in a stopped state, waiting for your tracer to give it the first `PTRACE_SYSCALL` command.\n\n![Fork Event Sequence: Parent Forks, Kernel Notifies Tracer](./diagrams/diag-m3-fork-event-sequence.svg)\n\nThis atomicity is the key property. Let's understand why it matters.\n### The Race Condition That Doesn't Exist (Because You Set the Option)\nImagine an alternative design: you receive a `fork()` exit event (child PID = 12346), then you call `ptrace(PTRACE_ATTACH, 12346, ...)` to start tracing the new child. What's the problem?\nThere's a window. Between the moment `fork()` completes in the tracee and the moment your tracer's `PTRACE_ATTACH` syscall executes, the child is running freely. For a fast child \u2014 one that does minimal work and exits quickly \u2014 it may finish entirely within this window. You'd get `ESRCH` (no such process) from `PTRACE_ATTACH` because the process no longer exists. Or worse, the child might spawn *its own* children before you attach, which are also untraced.\nThis is a classic Time-of-Check-to-Time-of-Use (TOCTOU) race condition. The \"check\" is `fork()` returning a PID, and the \"use\" is attaching to that PID \u2014 but the PID's lifetime is unconstrained between those two events.\n`PTRACE_O_TRACEFORK` eliminates the race entirely. The kernel performs the attachment *inside the `fork()` syscall handler*, before the child process ever gets scheduled. The child begins its life in a ptrace stop state. By the time you learn a fork happened, the child is already frozen, waiting for you. No race. No window. Atomic guarantee.\n---\n## Setting the Options: Before the Fork Happens\nYou already know how to set ptrace options \u2014 you used `PTRACE_SETOPTIONS` in Milestone 1 to set `PTRACE_O_TRACESYSGOOD`. Now you add the fork-following options to the same call:\n```c\n/* After the initial post-exec waitpid, set ALL options at once */\nlong opts = PTRACE_O_TRACESYSGOOD   /* Bit 7 on syscall stops          */\n           | PTRACE_O_TRACEFORK     /* Catch fork() in tracee          */\n           | PTRACE_O_TRACEVFORK    /* Catch vfork() in tracee         */\n           | PTRACE_O_TRACECLONE    /* Catch clone() in tracee         */\n           | PTRACE_O_TRACEEXEC;    /* Catch execve() in tracee        */\nif (ptrace(PTRACE_SETOPTIONS, child, NULL, (void *)opts) == -1) {\n    perror(\"ptrace SETOPTIONS\");\n    return 1;\n}\n```\nA crucial detail: **these options are set on the parent tracee, not on future children**. When a child is created with `PTRACE_O_TRACEFORK` active, the new child *automatically inherits the same options*. So if the child later forks grandchildren, those grandchildren are also automatically traced and get the same option set. Your single `PTRACE_SETOPTIONS` call propagates down the entire process tree indefinitely.\nLet's clarify what each option does:\n**`PTRACE_O_TRACEFORK`** \u2014 Intercepts calls to `fork()`. On x86_64, `fork()` is syscall 57. When a traced process calls `fork()`, the kernel delivers a `PTRACE_EVENT_FORK` stop to your tracer at the exit of the `fork()` syscall.\n**`PTRACE_O_TRACEVFORK`** \u2014 Intercepts `vfork()` (syscall 58). `vfork()` is a variant of `fork()` where the parent *suspends* until the child calls `exec()` or `_exit()`. The child borrows the parent's address space without copying it. The event is `PTRACE_EVENT_VFORK`.\n**`PTRACE_O_TRACECLONE`** \u2014 Intercepts `clone()` (syscall 56). `clone()` is the general-purpose process/thread creation syscall on Linux. Both `fork()` and `vfork()` are implemented as thin wrappers around `clone()` in glibc. Threads are also created via `clone()` with different flags. The event is `PTRACE_EVENT_CLONE`.\n**`PTRACE_O_TRACEEXEC`** \u2014 Intercepts `execve()`. When a traced process successfully replaces its image with a new program, the kernel delivers `PTRACE_EVENT_EXEC`. This is essential for handling address space replacement, which we'll cover later in this milestone.\n> **Why trace clone for threads?** When a program creates a thread using `pthread_create()`, glibc calls `clone()` with `CLONE_VM | CLONE_THREAD | ...` flags. The resulting thread shares the address space with the parent (it's not a separate process). By setting `PTRACE_O_TRACECLONE`, you trace threads too. Whether you *want* to trace every thread is a design choice \u2014 real strace traces all threads by default. For this milestone, we'll trace them all.\n---\n## Switching to waitpid(-1): Catching Any Child\nWith Milestones 1 and 2, your `waitpid` call looked like this:\n```c\nwaitpid(child, &status, 0);  /* Wait for ONE specific PID */\n```\nThis is no longer sufficient. You might now be tracing 5, 10, or 50 PIDs simultaneously. You don't know which one will stop next \u2014 it depends on scheduler timing, I/O, signals, and factors completely outside your control. If you call `waitpid(12345, ...)` while PID 12346 has just stopped and is waiting for you, you'll deadlock: 12346 is frozen waiting for your `PTRACE_SYSCALL`, and you're blocked waiting for 12345.\nThe fix is simple and powerful: use `-1` as the PID argument to `waitpid`:\n```c\npid_t stopped_pid = waitpid(-1, &status, 0);\n```\nWhen the PID argument is `-1`, `waitpid` returns the status of *any* child that changes state. It picks whoever stopped first. The return value is the PID of the process that stopped \u2014 this is essential, because now you need to know *which* process triggered the event to dispatch to the correct per-PID state.\nThe tracing loop structure changes from this:\n```c\n/* Milestone 2: single-process */\nwhile (1) {\n    ptrace(PTRACE_SYSCALL, child, NULL, NULL);\n    waitpid(child, &status, 0);\n    /* ... handle status ... */\n}\n```\nTo this:\n```c\n/* Milestone 3: multi-process */\nwhile (active_process_count > 0) {\n    pid_t stopped_pid = waitpid(-1, &status, 0);\n    if (stopped_pid == -1) break;\n    /* Dispatch: find state for stopped_pid, handle the event */\n    ProcessState *state = find_state(stopped_pid);\n    handle_event(stopped_pid, state, status);\n}\n```\nNotice the loop condition changed too. You no longer loop until a single process exits \u2014 you loop until *all* traced processes have exited.\n\n![waitpid(-1) Event Dispatch: Multi-PID Decision Tree](./diagrams/diag-m3-waitpid-dispatch-flowchart.svg)\n\n---\n## Decoding ptrace Events: The status>>16 Trick\nWhen `PTRACE_O_TRACEFORK` and friends are set, the kernel delivers special \"ptrace event\" stops to your tracer. These events come through the same `waitpid` status word you've been using, but they're encoded in the *high 16 bits* of the status \u2014 a region you haven't used yet.\nHere's the status word layout for a ptrace event stop:\n```\nBits 31-24: 0\nBits 23-16: PTRACE_EVENT_* constant (the event type)\nBits  15-8: SIGTRAP (signal 5)\nBits   7-0: 0x7f (stopped, not exited)\n```\nThe `WIFSTOPPED(status)` macro is true. `WSTOPSIG(status)` returns `SIGTRAP` (not `SIGTRAP | 0x80` \u2014 event stops don't set bit 7 even with `TRACESYSGOOD`). The event type sits in `status >> 16`.\nThe defined event constants in `<sys/ptrace.h>`:\n| Constant | Value | Triggered By |\n|----------|-------|-------------|\n| `PTRACE_EVENT_FORK` | 1 | `fork()` in tracee |\n| `PTRACE_EVENT_VFORK` | 2 | `vfork()` in tracee |\n| `PTRACE_EVENT_CLONE` | 3 | `clone()` in tracee |\n| `PTRACE_EVENT_EXEC` | 4 | successful `execve()` in tracee |\n| `PTRACE_EVENT_VFORK_DONE` | 5 | vfork child called exec/exit, parent resumes |\n| `PTRACE_EVENT_EXIT` | 6 | tracee is about to exit (not yet dead) |\nTo extract the event type:\n```c\nint event = (status >> 16) & 0xff;\n```\nOr use the macro if your headers define it:\n```c\n/* Some systems define this, some don't \u2014 define it yourself to be safe */\n#define PTRACE_EVENT(status) ((status) >> 16)\n```\nA complete stop classification now looks like this:\n```c\nif (WIFEXITED(status)) {\n    /* Tracee exited \u2014 remove from state map */\n} else if (WIFSIGNALED(status)) {\n    /* Tracee killed by signal \u2014 remove from state map */\n} else if (WIFSTOPPED(status)) {\n    int sig = WSTOPSIG(status);\n    int event = (status >> 16) & 0xff;\n    if (event != 0) {\n        /* ptrace event stop \u2014 handle fork/exec/etc. */\n        handle_ptrace_event(stopped_pid, event, status);\n    } else if (sig == (SIGTRAP | 0x80)) {\n        /* Syscall stop (TRACESYSGOOD) */\n        handle_syscall_stop(stopped_pid, state);\n    } else if (sig == SIGTRAP) {\n        /* Plain SIGTRAP \u2014 post-exec stop or breakpoint */\n        /* Just resume */\n        ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n    } else {\n        /* Signal-delivery stop \u2014 re-inject */\n        ptrace(PTRACE_SYSCALL, stopped_pid, NULL, (void *)(long)sig);\n    }\n}\n```\n---\n## Retrieving the New Child PID with PTRACE_GETEVENTMSG\nWhen you receive a `PTRACE_EVENT_FORK`, `PTRACE_EVENT_VFORK`, or `PTRACE_EVENT_CLONE` stop on process P, you know P forked. But what's the child's PID?\n`PTRACE_GETEVENTMSG` retrieves the message associated with the most recent ptrace event:\n```c\nunsigned long new_child_pid;\nif (ptrace(PTRACE_GETEVENTMSG, stopped_pid, NULL, &new_child_pid) == -1) {\n    perror(\"PTRACE_GETEVENTMSG\");\n    /* Handle error */\n} else {\n    /* new_child_pid is the new process's PID */\n    printf(\"[pid %lu] forked\\n\", new_child_pid);\n    /* Create state for new_child_pid in your state map */\n    init_process_state((pid_t)new_child_pid);\n    /* Resume the new child (it's currently stopped, waiting for us) */\n    ptrace(PTRACE_SYSCALL, (pid_t)new_child_pid, NULL, NULL);\n}\n```\nTwo things to understand here:\n**First**: When `PTRACE_GETEVENTMSG` is called after a fork event, the returned value is the new child's PID. When called after an exec event, it returns the old PID (before exec replaced the process image) \u2014 useful if PIDs change, though on Linux exec doesn't change the PID.\n**Second**: At the moment your tracer receives the fork event, **the new child is already stopped**. It hasn't run a single instruction. You must call `ptrace(PTRACE_SYSCALL, new_child_pid, ...)` to let it start executing. If you forget this, the child is frozen forever, and your loop will never get an exit event for it \u2014 you'll hang.\nHere's the complete fork event handler:\n```c\nvoid handle_fork_event(pid_t parent_pid, int event) {\n    unsigned long child_pid_ul;\n    if (ptrace(PTRACE_GETEVENTMSG, parent_pid, NULL, &child_pid_ul) == -1) {\n        perror(\"PTRACE_GETEVENTMSG\");\n        /* Resume parent anyway */\n        ptrace(PTRACE_SYSCALL, parent_pid, NULL, NULL);\n        return;\n    }\n    pid_t child_pid = (pid_t)child_pid_ul;\n    const char *fork_type = (event == PTRACE_EVENT_FORK)  ? \"fork\"  :\n                            (event == PTRACE_EVENT_VFORK) ? \"vfork\" : \"clone\";\n    fprintf(stderr, \"[pid %d] %s() = %d\\n\", parent_pid, fork_type, child_pid);\n    /* Create state for the new child */\n    ProcessState *child_state = state_map_insert(child_pid);\n    child_state->in_syscall = 0;  /* Child starts fresh \u2014 not mid-syscall */\n    active_process_count++;\n    /* Release the child so it can start executing */\n    if (ptrace(PTRACE_SYSCALL, child_pid, NULL, NULL) == -1) {\n        /* Child may have already exited \u2014 that's OK */\n        if (errno != ESRCH) {\n            perror(\"ptrace PTRACE_SYSCALL (new child)\");\n        }\n    }\n    /* Resume the parent too */\n    ptrace(PTRACE_SYSCALL, parent_pid, NULL, NULL);\n}\n```\n---\n## Per-PID State: The Hash Map\nIn Milestone 2, your per-process state was a single struct for a single process:\n```c\ntypedef struct {\n    int                     in_syscall;\n    struct user_regs_struct entry_regs;\n} ProcessState;\nProcessState state = { .in_syscall = 0 };\n```\nNow you need this for potentially dozens of PIDs simultaneously. You need a data structure that:\n1. Inserts a new PID \u2192 state mapping when a child is born\n2. Looks up state by PID on every `waitpid` event (hot path \u2014 called for *every* syscall)\n3. Removes a PID when the process exits\n4. Handles whatever maximum number of simultaneous processes your workload generates\nOn Linux, PIDs are integers in the range `[1, 4194304]` (by default, configurable via `/proc/sys/kernel/pid_max`). A direct array of size 4M would be wasteful but possible. A hash map is more appropriate for general use.\n\n![Per-PID State Hash Map \u2014 Structure and Lookup](./diagrams/diag-m3-per-pid-state-map.svg)\n\n### Designing the State Struct\nBefore building the map, expand `ProcessState` to include everything per-PID you'll need:\n```c\n#include <sys/user.h>\n#include <sys/ptrace.h>\ntypedef struct {\n    pid_t                   pid;         /* Which process this entry belongs to */\n    int                     in_syscall;  /* Toggle: 0=entry next, 1=exit next */\n    struct user_regs_struct entry_regs;  /* Register snapshot from entry stop */\n    int                     valid;       /* Is this slot occupied? (for open addressing) */\n} ProcessState;\n```\nThe memory layout of this struct matters. Let's account for it:\n| Field | Type | Size | Offset |\n|-------|------|------|--------|\n| `pid` | `pid_t` (int) | 4 bytes | 0 |\n| `in_syscall` | `int` | 4 bytes | 4 |\n| `entry_regs` | `struct user_regs_struct` | 216 bytes | 8 |\n| `valid` | `int` | 4 bytes | 224 |\n| (padding) | \u2014 | 4 bytes | 228 |\n| **Total** | | **232 bytes** | |\nAt 232 bytes per entry, a table with 256 slots costs 59 KB \u2014 fits comfortably in L2 cache (typically 256 KB\u20131 MB). The `entry_regs` struct alone is 216 bytes (27 64-bit registers), spanning approximately 4 cache lines (64 bytes each). Every `PTRACE_GETREGS` call writes all 216 bytes into your state.\n### A Simple Open-Addressing Hash Map\nFor a systems project at this level, a simple open-addressing hash map with linear probing is correct and efficient. PIDs are small integers \u2014 they hash well with a simple modulo. Here's a minimal implementation:\n```c\n#define STATE_MAP_SIZE 256   /* Must be a power of 2 for mask trick */\n#define STATE_MAP_MASK (STATE_MAP_SIZE - 1)\nstatic ProcessState state_map[STATE_MAP_SIZE];\n/* Initialize the map \u2014 all entries start invalid */\nvoid state_map_init(void) {\n    memset(state_map, 0, sizeof(state_map));\n    for (int i = 0; i < STATE_MAP_SIZE; i++) {\n        state_map[i].valid = 0;\n    }\n}\n/* Hash function: PID modulo table size (PIDs are already somewhat random) */\nstatic int hash_pid(pid_t pid) {\n    return (int)(pid & STATE_MAP_MASK);\n}\n/* Insert a new PID entry; returns pointer to the state, NULL on error */\nProcessState *state_map_insert(pid_t pid) {\n    int idx = hash_pid(pid);\n    for (int i = 0; i < STATE_MAP_SIZE; i++) {\n        int slot = (idx + i) & STATE_MAP_MASK;\n        if (!state_map[slot].valid) {\n            state_map[slot].pid = pid;\n            state_map[slot].in_syscall = 0;\n            state_map[slot].valid = 1;\n            memset(&state_map[slot].entry_regs, 0,\n                   sizeof(state_map[slot].entry_regs));\n            return &state_map[slot];\n        }\n    }\n    return NULL;  /* Table full */\n}\n/* Look up state for a PID; returns NULL if not found */\nProcessState *state_map_find(pid_t pid) {\n    int idx = hash_pid(pid);\n    for (int i = 0; i < STATE_MAP_SIZE; i++) {\n        int slot = (idx + i) & STATE_MAP_MASK;\n        if (!state_map[slot].valid) return NULL;  /* Empty slot: not present */\n        if (state_map[slot].pid == pid) return &state_map[slot];\n    }\n    return NULL;\n}\n/* Remove a PID entry */\nvoid state_map_remove(pid_t pid) {\n    int idx = hash_pid(pid);\n    for (int i = 0; i < STATE_MAP_SIZE; i++) {\n        int slot = (idx + i) & STATE_MAP_MASK;\n        if (!state_map[slot].valid) return;  /* Not found */\n        if (state_map[slot].pid == pid) {\n            state_map[slot].valid = 0;\n            /* Note: open addressing with linear probing requires tombstones\n             * or rehashing on removal to preserve lookup correctness.\n             * For simplicity here, we zero the slot and accept that\n             * lookups may stop at empty slots. For a small table with\n             * low load factor this is fine. */\n            return;\n        }\n    }\n}\n```\n> **Design Decision: Open Addressing vs. Chaining**\n>\n> | Option | Pros | Cons | Used By |\n> |--------|------|------|---------|\n> | **Open addressing (this code) \u2713** | Cache-friendly (sequential probing), no allocations | Deletion is tricky (tombstones needed), degrades at high load | Real strace (similar approach) |\n> | Chaining (linked list per bucket) | Simple deletion, no clustering | Pointer chasing, allocations, cache misses | HashMap in many languages |\n> | Direct array (4M entries) | O(1) guaranteed, zero collisions | 4M \u00d7 232B = ~928 MB (!), wasteful | Not appropriate here |\n>\n> With a 256-slot table and a maximum of ~50 simultaneously traced processes (realistic for most workloads), the load factor stays below 0.2 \u2014 collision chains will be very short.\n> **Tombstone Note**: The removal code above has a subtle bug: open addressing with linear probing requires that you don't simply clear removed slots, or else lookups will incorrectly terminate at those empty slots and miss entries that were probed past them. For production code, use a tombstone marker (`valid = -1`) that lookup skips but insert can reuse. For this milestone, with a large table and low load factor, the practical impact is negligible, but be aware of it.\n---\n## PID-Tagged Output\nWhen multiple processes are active, output lines must identify which process made each syscall. Real strace uses the format `[pid NNNN]` as a prefix on every line when tracing more than one process.\nModify your `print_syscall` function from Milestone 2 to accept the PID and a flag indicating whether to show it:\n```c\nvoid print_syscall(pid_t pid, int show_pid,\n                   struct user_regs_struct *entry_regs,\n                   long return_val)\n{\n    if (show_pid) {\n        fprintf(stderr, \"[pid %d] \", pid);\n    }\n    long syscall_num = (long)entry_regs->orig_rax;\n    const char *name = syscall_name(syscall_num);\n    /* ... rest of formatting as in Milestone 2 ... */\n}\n```\nAlternatively \u2014 and this is cleaner \u2014 always print the PID prefix. Real strace only suppresses it when tracing a single process, but showing it always is simpler and always correct. The cost is a few extra characters per line.\nFor the fork/exec events themselves (not syscall stops), print them as strace does:\n```\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|SIGCHLD) = 12346\n```\nThis means printing the fork-type syscall result *in the parent's context* when the fork event fires. The parent's `orig_rax` contains the clone/fork syscall number, and the new child's PID is the return value. You print it at the fork event stop, which fires at the *exit* of the fork syscall in the parent \u2014 so you have both the syscall name and the child PID.\n---\n## Handling PTRACE_EVENT_EXEC: Address Space Replacement\n`exec()` is the most dramatic thing a process can do short of dying. When `execve()` succeeds, the kernel throws away everything about the process's current state:\n- The entire text (code) segment is replaced\n- The heap is destroyed and rebuilt\n- The stack is replaced with a fresh one\n- All memory-mapped regions are unmapped and replaced\n- File descriptors marked `O_CLOEXEC` are closed\nWhat doesn't change:\n- The PID\n- The PPID (parent PID)\n- The ptrace attachment (the process stays traced)\n\n![PTRACE_EVENT_EXEC: Address Space Replacement](./diagrams/diag-m3-exec-state-reset.svg)\n\nFor your tracer, this means: **any pointer you cached from before the exec is now dangling**. The string `\"/bin/old_program\"` that used to be at address `0x7ffd12340000` in the tracee's address space no longer exists at that address. The address space has been completely replaced.\nWhat does this mean practically for your per-PID state?\nThe `entry_regs` you saved at a syscall entry stop is invalidated if exec happens before the exit stop. Fortunately, `exec()` fires `PTRACE_EVENT_EXEC` *at the exit of the execve syscall*, which means the previous syscall (if any) has already completed. The entry/exit toggle should be in the \"entry\" state (waiting for the next entry) at the point exec fires. But to be safe, you should reset the toggle:\n```c\nvoid handle_exec_event(pid_t pid) {\n    ProcessState *state = state_map_find(pid);\n    if (state == NULL) {\n        /* Exec from a previously unknown PID \u2014 this can happen if TRACEME\n         * is used and the initial stop triggers an exec event.\n         * Insert new state. */\n        state = state_map_insert(pid);\n        if (state == NULL) {\n            fprintf(stderr, \"State map full\\n\");\n            return;\n        }\n    }\n    /* Reset per-PID state: address space is now entirely different */\n    state->in_syscall = 0;\n    memset(&state->entry_regs, 0, sizeof(state->entry_regs));\n    /* The PTRACE_EVENT_EXEC stop fires at the exit of execve.\n     * The execve return value will be 0 (success) in rax.\n     * We could print execve(...) = 0 here, but we already printed\n     * the execve entry. Alternatively, handle it as a special case. */\n    fprintf(stderr, \"[pid %d] <... execve resumed> = 0\\n\", pid);\n    /* Resume the process */\n    ptrace(PTRACE_SYSCALL, pid, NULL, NULL);\n}\n```\n> **The exec entry/exit problem**: With `PTRACE_EVENT_EXEC` set, execve stops are slightly unusual. The entry stop fires normally (you see it as a syscall entry, read `orig_rax = 59` for execve). Then, if exec succeeds, instead of a plain syscall exit stop, you get a `PTRACE_EVENT_EXEC` stop. Your toggle will be in the \"in_syscall\" state (waiting for exit). The exec event handler should reset it to 0. If exec *fails* (returns -1 ENOENT etc.), you get a normal syscall exit stop instead \u2014 no exec event. Handle both cases.\n---\n## Tracking Active Processes: The Exit Count\nYour loop must know when all traced processes have exited so it can stop. Maintain a counter:\n```c\nint active_count = 0;  /* Number of currently-traced, live processes */\n```\n- Increment when you create a new state (on fork events and at startup for the initial child).\n- Decrement when `WIFEXITED(status)` or `WIFSIGNALED(status)` is true for any PID.\n- Loop condition: `while (active_count > 0)`.\nBe careful with the ordering: remove the PID's state from the map *and* decrement the counter when you see the exit event. Don't decrement twice.\n```c\nif (WIFEXITED(status)) {\n    int code = WEXITSTATUS(status);\n    fprintf(stderr, \"[pid %d] +++ exited with %d +++\\n\", stopped_pid, code);\n    state_map_remove(stopped_pid);\n    active_count--;\n} else if (WIFSIGNALED(status)) {\n    int sig = WTERMSIG(status);\n    fprintf(stderr, \"[pid %d] +++ killed by signal %d (%s) +++\\n\",\n            stopped_pid, sig, strsignal(sig));\n    state_map_remove(stopped_pid);\n    active_count--;\n}\n```\n---\n## Putting It All Together: The Complete Multi-Process Loop\nHere is the full tracing loop for Milestone 3. This replaces the single-process loop from Milestone 2:\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/user.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n/* ... (ProcessState, state_map_*, print_syscall, etc. from earlier sections) ... */\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <program> [args...]\\n\", argv[0]);\n        return 1;\n    }\n    state_map_init();\n    pid_t child = fork();\n    if (child < 0) { perror(\"fork\"); return 1; }\n    if (child == 0) {\n        /* Child: request tracing */\n        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n        execvp(argv[1], &argv[1]);\n        perror(\"execvp\");\n        exit(1);\n    }\n    /* Catch initial post-exec SIGTRAP */\n    int status;\n    waitpid(child, &status, 0);\n    if (!WIFSTOPPED(status)) {\n        fprintf(stderr, \"Unexpected initial status\\n\");\n        return 1;\n    }\n    /* Set all options: syscall marking + fork following + exec events */\n    long opts = PTRACE_O_TRACESYSGOOD\n               | PTRACE_O_TRACEFORK\n               | PTRACE_O_TRACEVFORK\n               | PTRACE_O_TRACECLONE\n               | PTRACE_O_TRACEEXEC;\n    if (ptrace(PTRACE_SETOPTIONS, child, NULL, (void *)opts) == -1) {\n        perror(\"ptrace SETOPTIONS\");\n        return 1;\n    }\n    /* Initialize state for the first child */\n    ProcessState *init_state = state_map_insert(child);\n    init_state->in_syscall = 0;\n    int active_count = 1;\n    /* Resume the initial child */\n    ptrace(PTRACE_SYSCALL, child, NULL, NULL);\n    /* \u2500\u2500 MAIN TRACING LOOP \u2500\u2500 */\n    while (active_count > 0) {\n        /* Wait for ANY traced process to change state */\n        pid_t stopped_pid = waitpid(-1, &status, 0);\n        if (stopped_pid == -1) {\n            if (errno == ECHILD) break;  /* No more children */\n            perror(\"waitpid\");\n            break;\n        }\n        /* \u2500\u2500 PROCESS EXITED OR KILLED \u2500\u2500 */\n        if (WIFEXITED(status)) {\n            fprintf(stderr, \"[pid %d] +++ exited with %d +++\\n\",\n                    stopped_pid, WEXITSTATUS(status));\n            state_map_remove(stopped_pid);\n            active_count--;\n            continue;\n        }\n        if (WIFSIGNALED(status)) {\n            fprintf(stderr, \"[pid %d] +++ killed by signal %d (%s) +++\\n\",\n                    stopped_pid, WTERMSIG(status), strsignal(WTERMSIG(status)));\n            state_map_remove(stopped_pid);\n            active_count--;\n            continue;\n        }\n        /* \u2500\u2500 PROCESS STOPPED \u2500\u2500 */\n        if (!WIFSTOPPED(status)) continue;\n        int sig   = WSTOPSIG(status);\n        int event = (status >> 16) & 0xff;\n        ProcessState *state = state_map_find(stopped_pid);\n        if (state == NULL) {\n            /* Unknown PID \u2014 this can happen for the grandchild of a clone\n             * if our state_map_insert in the fork handler raced with the\n             * grandchild's first stop. Insert it now. */\n            state = state_map_insert(stopped_pid);\n            if (state == NULL) {\n                fprintf(stderr, \"State map full \u2014 resuming unknown PID %d\\n\",\n                        stopped_pid);\n                ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n                continue;\n            }\n            active_count++;\n        }\n        /* \u2500\u2500 PTRACE EVENT STOPS (fork, exec, etc.) \u2500\u2500 */\n        if (event != 0) {\n            switch (event) {\n            case PTRACE_EVENT_FORK:\n            case PTRACE_EVENT_VFORK:\n            case PTRACE_EVENT_CLONE: {\n                unsigned long new_pid_ul;\n                ptrace(PTRACE_GETEVENTMSG, stopped_pid, NULL, &new_pid_ul);\n                pid_t new_pid = (pid_t)new_pid_ul;\n                const char *kind = (event == PTRACE_EVENT_FORK)  ? \"fork\"  :\n                                   (event == PTRACE_EVENT_VFORK) ? \"vfork\" : \"clone\";\n                fprintf(stderr, \"[pid %d] %s() = %d\\n\",\n                        stopped_pid, kind, new_pid);\n                /* Create state for the new child */\n                ProcessState *child_state = state_map_insert(new_pid);\n                if (child_state != NULL) {\n                    child_state->in_syscall = 0;\n                    active_count++;\n                }\n                /* Start the new child's tracing */\n                if (ptrace(PTRACE_SYSCALL, new_pid, NULL, NULL) == -1) {\n                    if (errno != ESRCH) perror(\"ptrace new child\");\n                }\n                break;\n            }\n            case PTRACE_EVENT_EXEC:\n                /* Address space replaced \u2014 reset cached state */\n                state->in_syscall = 0;\n                memset(&state->entry_regs, 0, sizeof(state->entry_regs));\n                fprintf(stderr, \"[pid %d] <execve resumed> = 0\\n\", stopped_pid);\n                break;\n            case PTRACE_EVENT_EXIT:\n                /* Process is about to exit \u2014 we'll get WIFEXITED soon */\n                break;\n            default:\n                break;\n            }\n            /* Resume after any event stop */\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        /* \u2500\u2500 SYSCALL STOP (TRACESYSGOOD: bit 7 set) \u2500\u2500 */\n        if (sig == (SIGTRAP | 0x80)) {\n            struct user_regs_struct regs;\n            if (ptrace(PTRACE_GETREGS, stopped_pid, NULL, &regs) == -1) {\n                if (errno == ESRCH) { continue; }\n                perror(\"ptrace GETREGS\");\n                ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n                continue;\n            }\n            if (state->in_syscall == 0) {\n                /* ENTRY: save register snapshot, flip toggle */\n                state->entry_regs = regs;\n                state->in_syscall = 1;\n            } else {\n                /* EXIT: print using saved entry registers + current rax */\n                long return_val = (long)regs.rax;\n                print_syscall(stopped_pid, /*show_pid=*/1,\n                              &state->entry_regs, return_val);\n                state->in_syscall = 0;\n            }\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        /* \u2500\u2500 PLAIN SIGTRAP (post-exec stop or other) \u2500\u2500 */\n        if (sig == SIGTRAP) {\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        /* \u2500\u2500 SIGNAL-DELIVERY STOP: re-inject the signal \u2500\u2500 */\n        ptrace(PTRACE_SYSCALL, stopped_pid, NULL, (void *)(long)sig);\n    }\n    return 0;\n}\n```\n---\n## Three-Level View: What Happens When fork() Is Intercepted\nLet's trace through what happens at all three levels when a traced process calls `fork()`.\n**Level 1 \u2014 Application (Tracee)**\nThe process calls `fork()`. glibc's `fork()` wrapper is, on Linux, a thin wrapper around `clone()` with `SIGCHLD` flag. The actual syscall number is 57 (`fork`) or 56 (`clone`), depending on the glibc version and architecture. The `syscall` instruction fires.\n**Level 2 \u2014 Kernel**\n1. The entry stop fires. Your tracer wakes up, reads `orig_rax = 57`, saves entry registers, flips toggle to `in_syscall = 1`. Calls `PTRACE_SYSCALL` to resume.\n2. The kernel performs `do_fork()`: allocates a new `task_struct`, copies the parent's address space (copy-on-write), assigns a new PID, sets up the child's kernel stack.\n3. **Because `PTRACE_O_TRACEFORK` is set**: the kernel checks the tracee's `PT_TRACED` flag and the options. It sets `PT_TRACED` on the new child's `task_struct`. It puts the new child into `TASK_STOPPED` state before it ever runs. It adds the child to the tracer's list of traced processes.\n4. The kernel delivers `PTRACE_EVENT_FORK` to the tracer: it sets `status = (PTRACE_EVENT_FORK << 16) | (SIGTRAP << 8) | 0x7f` and wakes up the tracer's `waitpid`.\n5. Both parent and child are now stopped. The parent is waiting for your `PTRACE_SYSCALL` to resume it past the exit stop. The child is waiting for your `PTRACE_SYSCALL` to start it.\n**Level 3 \u2014 Hardware**\n`clone()`/`fork()` is one of the most expensive syscalls. Creating a new process involves:\n- Allocating a new `task_struct` (~4 KB kernel allocation)\n- Duplicating the page table (each level of the 4-level page table must be copied \u2014 at minimum, the top-level PGD, which is 4 KB)\n- For copy-on-write: marking all writable pages as read-only in both parent's and child's page tables, requiring TLB invalidation\n- A TLB shootdown: sending IPIs (Inter-Processor Interrupts) to all other CPU cores to flush their TLB entries for the parent's pages\nThe TLB shootdown is significant on multi-core systems. If your traced process was running on 8 cores before the fork, the kernel must interrupt all 8 cores to invalidate their TLB entries. This is on the order of 1\u201310 microseconds per fork \u2014 expensive enough that fork-heavy programs benefit from `posix_spawn()` or `vfork()` optimizations.\nFrom your tracer's perspective: the `waitpid` that returns the `PTRACE_EVENT_FORK` event typically arrives 50\u2013200 microseconds after the fork syscall entry, depending on system load and the cost of the page table operations.\n---\n## The Tricky Cases: What Can Go Wrong\n### Race: New Child's First Stop Arrives Before Fork Event\nThe kernel guarantees that the `PTRACE_EVENT_FORK` stop on the parent fires before the child is scheduled. But your `waitpid(-1)` loop doesn't care about ordering \u2014 both events are queued. In practice, the fork event arrives first because the parent's event is queued before the child is even runnable. But defensively, handle the case where `state_map_find(stopped_pid)` returns NULL by inserting a new entry. The code above does this.\n### Clone Flags and Thread vs. Process\nWhen `clone()` is called with `CLONE_VM` (shared memory map) and `CLONE_THREAD` (same thread group), it creates a thread rather than a separate process. From ptrace's perspective, threads are treated like processes: they get their own PID (actually a TID, Thread ID), and each thread gets its own entry/exit toggle. Your state map handles this naturally \u2014 each TID is an independent key.\nThe practical complication: when a multi-threaded program exits, all threads receive an exit event. Your `active_count` must be decremented for each TID, not just for the main process's PID. The code above already handles this because it decrements on every `WIFEXITED` event from `waitpid(-1)`.\n### Exec Mid-Trace: The Toggle Confusion\nIf a process is in the `in_syscall = 1` state (you saw the entry stop, you're waiting for the exit stop) and then calls `execve()`, you'll see the execve entry stop, flip to `in_syscall = 1` (already 1... wait, no). Let's think through this carefully:\n1. Process calls `read()`: entry stop fires, toggle \u2192 1.\n2. Process returns from `read()`: exit stop fires, toggle \u2192 0. Print `read(...) = N`.\n3. Process calls `execve()`: entry stop fires, toggle \u2192 1. You save entry_regs (with `orig_rax = 59`).\n4. Exec succeeds: instead of exit stop, you get `PTRACE_EVENT_EXEC`. Your toggle is at 1.\n5. You must reset toggle to 0 and clear entry_regs.\nThis is exactly what the exec event handler does. Without it, the *next* syscall in the new program would be treated as an exit (because toggle is still 1), and you'd read garbage from the entry_regs that belonged to the old address space.\n### vfork: Parent Waits for Child\n`vfork()` is special: the parent is suspended in the kernel until the child calls `exec()` or `_exit()`. From your tracer's perspective, after the `PTRACE_EVENT_VFORK` stop fires:\n- Resume both parent and child with `PTRACE_SYSCALL`.\n- The parent won't produce any events until the child execs or exits (because it's suspended in the kernel).\n- The child will produce a stream of events.\n- When the child execs, you'll see `PTRACE_EVENT_VFORK_DONE` on the parent.\nYour code handles this correctly already \u2014 `waitpid(-1)` will naturally pick up the child's events while the parent produces none. When the parent eventually unsuspends, it'll start producing events again.\n---\n## Hardware Soul: The Cost of Multi-Process Tracing\nWhen you're tracing 10 simultaneous processes, what's the hardware doing?\n**Cache thrashing from context switches**: Each `waitpid` return potentially represents a context switch to a different process. A context switch replaces the CPU's register file, flushes the L1 instruction TLB (if no PCID), and may invalidate L1 data cache lines that belonged to the previous process. With 10 processes interleaving, you're generating 20 context switches per syscall (enter tracee \u2192 tracer, inspect, tracer \u2192 tracee, exit tracee \u2192 tracer, inspect, tracer \u2192 next tracee...). Each context switch costs 1,000\u20135,000 cycles on modern hardware.\n**State map lookup on hot path**: Every `waitpid` event requires a state map lookup. With a 256-slot open-addressing table and load factor 0.1, the average lookup is O(1) with essentially zero collision probing. The entire table (59 KB) fits in L2 cache. Once the trace starts, the table stays hot. A lookup costs roughly 5\u201315 cycles for the hash computation and 1-2 cache hits.\n**`struct user_regs_struct` size**: At 216 bytes, saving entry_regs requires writing ~4 cache lines. At 64 bytes per cache line, that's 4 cache line writes per entry stop. With the state map in L2 cache (hot), this costs approximately 4 \u00d7 5 cycles = 20 cycles for the memory write \u2014 negligible compared to the context switch overhead.\n**The TLB picture**: Your tracer runs in its own address space. Every `PTRACE_GETREGS` and `PTRACE_PEEKDATA` call is a syscall into the kernel. The kernel access to tracee memory uses the kernel's own mapping of physical memory (which doesn't require switching `CR3`) \u2014 so the TLB concern for your tracer's own address space is limited to the syscall entry/exit mechanism itself, not per-PEEKDATA.\n---\n## Common Bugs in This Milestone\n### Bug 1: Not Resuming the New Child\n```c\n/* WRONG: forget to resume the new child */\ncase PTRACE_EVENT_FORK: {\n    unsigned long new_pid;\n    ptrace(PTRACE_GETEVENTMSG, stopped_pid, NULL, &new_pid);\n    /* Create state... */\n    /* \u2190 MISSING: ptrace(PTRACE_SYSCALL, new_pid, NULL, NULL) */\n    break;\n}\n```\nThe new child sits frozen forever. Your `active_count` is incremented but the child never produces an exit event. The loop hangs.\n### Bug 2: Using waitpid(original_pid) instead of waitpid(-1)\n```c\n/* WRONG: still using the original child PID */\nwaitpid(child, &status, 0);  /* Misses events from all other PIDs */\n```\nEvents from forked children are never seen. Those children are frozen, waiting for your `PTRACE_SYSCALL`. The loop deadlocks when the original process waits for a child that your tracer never resumed.\n### Bug 3: Not Checking for NULL from state_map_find\n```c\n/* WRONG: crashing if state not found */\nProcessState *state = state_map_find(stopped_pid);\nstate->in_syscall = 1;  /* SEGFAULT if state is NULL */\n```\nAlways null-check. If the state map returns NULL, a PID showed up that you didn't expect \u2014 insert it defensively.\n### Bug 4: Misidentifying Event Stops as Syscall Stops\n```c\n/* WRONG: checking bit 7 first, before checking event */\nif (sig == (SIGTRAP | 0x80)) {\n    /* handle as syscall stop */\n}\n```\nIf `event != 0`, it's a ptrace event stop, not a syscall stop, even if some bit patterns coincide. Always check `event` first, then `sig`.\n### Bug 5: Double-Decrementing active_count\n```c\n/* WRONG: decrementing twice for one process exit */\nif (WIFEXITED(status)) {\n    active_count--;        /* Decrement 1 */\n    state_map_remove(stopped_pid);\n}\nif (state_map_find(stopped_pid) == NULL) {\n    active_count--;        /* Decrement 2 \u2014 same process! */\n}\n```\nThe loop exits prematurely or goes negative. Decrement exactly once per PID exit event.\n---\n## Testing Multi-Process Tracing\nTest progressively:\n```bash\n# Simple fork: bash -c runs a subshell\n./strace_clone bash -c \"ls /tmp\"\n# Multiple children: pipeline creates two children\n./strace_clone bash -c \"echo hello | cat\"\n# exec after fork: demonstrates PTRACE_EVENT_EXEC\n./strace_clone bash -c \"exec ls /tmp\"\n# Many forks: make -j4 forks multiple compilers\n./strace_clone make -j4\n# Thread creation via clone: any threaded program\n./strace_clone python3 -c \"import threading; threading.Thread(target=lambda: None).start()\"\n```\nExpected output for the pipeline test:\n```\n[pid 12345] execve(\"/bin/bash\", [\"/bin/bash\", \"-c\", \"echo hello | cat\"], ...) = 0\n[pid 12345] pipe([3, 4]) = 0\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|...) = 12346\n[pid 12346] execve(\"/bin/echo\", ...) = 0\n[pid 12346] write(1, \"hello\\n\", 6) = 6\n[pid 12346] exit_group(0) = ?\n[pid 12345] wait4(-1, ...) = 12346\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|...) = 12347\n[pid 12347] execve(\"/bin/cat\", ...) = 0\n...\n[pid 12345] +++ exited with 0 +++\n[pid 12347] +++ exited with 0 +++\n```\nThe interleaving order depends on scheduler timing and may vary between runs \u2014 that's expected.\n---\n## Knowledge Cascade: What This Unlocks\n### 1. Container Runtimes \u2014 The Entire Process Tree Must Be Observed\nWhen Docker, Podman, or runc starts a container, it must enforce that *every* process inside the container operates within the container's namespaces and cgroup limits. The container runtime can't just trace the initial process \u2014 it needs to follow every `fork()`, `vfork()`, and `clone()` the container makes, exactly as you've just built.\nContainer runtimes use `PTRACE_O_TRACEFORK` (or its equivalent in seccomp-BPF notification mode) to catch process creation. If a container process tries to `unshare()` its namespaces to escape containment, the seccomp filter catches it. If it forks a child that tries to access forbidden resources, the child is also observed because of the fork-following options. The atomicity guarantee \u2014 no window between fork and ptrace attachment \u2014 is what makes containers secure against fork-based escape attempts.\nThe `PTRACE_O_TRACEFORK` mechanism you just implemented is the same mechanism that makes Linux containers work at a fundamental level. You've just built the observation layer that container security depends on.\n### 2. PID Namespaces and Why waitpid(-1) Works\nLinux supports *PID namespaces*: a process in a container sees PIDs starting from 1, even though the host kernel assigns them much larger PIDs. From inside the container, PID 1 is the container's init process. From outside, it might be PID 73412.\nYour tracer runs outside any container namespace, so it sees the *host PIDs*. `waitpid(-1)` collects events from all direct child PIDs in your tracer's PID namespace \u2014 which includes all the traced processes, since they're children (or descendants) of your tracer process.\nWhen you build a container runtime that uses ptrace for enforcement, you need to understand which PID namespace your `waitpid(-1)` operates in. Events from processes in nested PID namespaces still arrive with their host PID, not their namespace-local PID. The `/proc/PID/status` file shows both `Pid:` (host PID) and `NSpid:` (namespace-local PIDs) \u2014 relevant if you're building tooling that needs to correlate traces across namespace boundaries.\n### 3. Race Conditions in Tracing \u2014 The TOCTOU Window\nBefore `PTRACE_O_TRACEFORK` existed, the only way to trace fork children was:\n1. Receive fork exit event (child PID in rax).\n2. Call `PTRACE_ATTACH(child_pid)`.\n3. `waitpid(child_pid)` for the SIGSTOP.\nSteps 1\u21922 involve a window. The child process is running. It might:\n- Open a file your policy forbids\n- Spawn its own children (which are also untraced)\n- Complete entirely and exit\nThis is a Time-of-Check-to-Time-of-Use (TOCTOU) race. The \"check\" (learning the child PID) is temporally separated from the \"use\" (attaching). In security contexts, an adversarial program can deliberately exploit this window \u2014 calling fork, doing the forbidden thing in the child immediately, and exiting before the tracer attaches.\n`PTRACE_O_TRACEFORK` eliminates this by making the attachment happen *inside the kernel, inside the fork syscall handler*. The child is placed into a stopped state before it is ever scheduled. There is no window. The attachment and the fork are atomic with respect to the child's execution. This is the correct pattern for secure tracing: **push the attachment into the kernel where it's atomic**, rather than doing it from userspace where races exist.\nThis principle \u2014 pushing critical operations into the kernel to eliminate races \u2014 generalizes. `signalfd()` eliminates the signal/accept race. `epoll()` with edge triggering eliminates the epoll/read race. `O_CREAT|O_EXCL` eliminates the exists/create race. Atomicity at the kernel boundary is the pattern.\n### 4. Hash Map Design at the System Level\nYour per-PID state hash map is a microcosm of a general systems programming problem: **fast lookup keyed by process ID for a hot-path operation**. Let's compare how production systems solve this:\nThe Linux kernel itself uses a hash table for its process table (`struct pid_hash`). It uses a hash of the PID value, with chaining for collision resolution. The key operations are `find_task_by_vpid()` and `find_task_by_pid_ns()` \u2014 called thousands of times per second on a busy system. The kernel's hash is sized to approximately the square root of `pid_max`, giving O(1) average lookup even with many processes.\nReal strace uses a simpler structure: a sorted array of `struct tcb` (traced control block) pointers, binary-searched by PID. With fewer than ~100 traced processes (typical), binary search over a sorted 100-element array is cache-friendly and fast. The `struct tcb` in strace is large (~500 bytes) and lives in a flat array \u2014 no pointer chasing, good locality.\nFor your implementation, the flat open-addressing table with 256 slots is optimal for the common case (< 50 traced processes). If you need to handle 1000+ simultaneously traced processes (tracing a large build system, for example), consider increasing the table size or switching to chaining.\n### 5. exec and Address Space Replacement \u2014 Why Pointers Die\n`exec()` is the most radical operation in Unix process management. The kernel discards the old address space and installs a new one in a single atomic operation from the process's perspective. For your tracer, this creates a fundamental discontinuity: any memory address you read from the tracee before exec is now meaningless.\nThis is the same concept that makes certain security vulnerabilities dangerous. Return-oriented programming (ROP) attacks chain together existing code fragments (\"gadgets\") in the target process's memory. If the target calls `exec()`, all those gadgets are gone \u2014 the ROP chain is broken. Address Space Layout Randomization (ASLR) randomizes where libraries and stack are placed on every exec, making it impossible to predict gadget addresses across exec boundaries.\nFor database engines that implement process-based connection isolation (PostgreSQL's `postmaster`/`backend` model), exec after fork is how each connection gets a clean state. The postmaster forks a child, which optionally execs a fresh backend binary. The backend has a fresh address space with no inherited heap fragments, memory leaks, or leftover state from other connections.\nYour `PTRACE_EVENT_EXEC` handler \u2014 clearing cached state when exec fires \u2014 is the minimal correct response to this reality. The next time you build anything that persists state across exec boundaries (a container runtime, a process supervisor, a debugging framework), you'll know exactly which state survives exec (PID, file descriptors without O_CLOEXEC, certain kernel state) and which does not (everything in the address space).\n---\n## Summary: What You've Built\nYour tracer now:\n- Sets `PTRACE_O_TRACEFORK`, `PTRACE_O_TRACEVFORK`, `PTRACE_O_TRACECLONE`, and `PTRACE_O_TRACEEXEC` options so the kernel atomically attaches to every child process, with no race window\n- Uses `waitpid(-1)` to receive events from *any* traced process, with the returned PID identifying which process stopped\n- Decodes the `status >> 16` bits to distinguish fork, exec, and other ptrace event stops from normal syscall stops\n- Calls `PTRACE_GETEVENTMSG` on fork events to retrieve the new child PID, inserts it into the per-PID state map, and starts the child tracing with an initial `PTRACE_SYSCALL`\n- Maintains a hash map (open addressing, 256 slots) of `ProcessState` structs keyed by PID, each holding the entry/exit toggle and the saved entry register snapshot\n- Tags every output line with `[pid NNNN]` to identify which process made each syscall\n- Resets per-PID cached state (toggle, entry_regs) when `PTRACE_EVENT_EXEC` fires, because the address space has been entirely replaced\n- Tracks an `active_count` and exits the main loop when all traced processes have exited\nMilestone 4 will add the final layer: syscall filtering by name (`-e trace=open,read`), wall-clock timing with `CLOCK_MONOTONIC`, summary statistics tables, file output redirection, and `PTRACE_ATTACH` for tracing already-running processes.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-strace-m4 -->\n# Milestone 4: Filtering and Statistics\n## Where You Are Now\nYour Milestone 3 tracer follows entire process trees, producing beautifully tagged output across every forked child and exec'd program:\n```\n[pid 12345] execve(\"/bin/bash\", [\"/bin/bash\", \"-c\", \"make -j4\"], ...) = 0\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|SIGCHLD) = 12346\n[pid 12346] execve(\"/usr/bin/gcc\", [\"/usr/bin/gcc\", \"-O2\", \"main.c\", \"-o\", \"main\"], ...) = 0\n[pid 12346] openat(AT_FDCWD, \"/usr/include/stdio.h\", O_RDONLY|O_CLOEXEC) = 3\n[pid 12346] read(3, \"...\", 4096) = 4096\n... (thousands more lines) ...\n[pid 12345] +++ exited with 0 +++\n```\nThis works. But it has two practical problems that you'll hit immediately when using it on real workloads.\n**First**: volume. Running `make -j4` on a moderate codebase generates tens of thousands of syscall lines. You're debugging a file-not-found error \u2014 you care about `openat` calls, not the thousands of `mmap`, `brk`, and `futex` calls surrounding them. You need to filter.\n**Second**: insight. After your trace runs, you want to know: which syscall took the most time? Which one failed most often? Is this program spending 80% of its time in `read` or `write`? The raw trace is a log \u2014 what you need is a *summary*. Real strace's `-c` flag prints exactly this, and it's one of the most useful diagnostics tools in production systems work.\nBy the end of this milestone, your tracer will support:\n```bash\n./strace_clone -e trace=openat,read,write -o trace.log ./target_program\n./strace_clone -c ./target_program          # summary mode: count + time per syscall\n./strace_clone -p 8492                     # attach to running process\n```\nAnd produce, on exit, a summary like:\n```\n% time     seconds  usecs/call     calls    errors  syscall\n------ ----------- ----------- --------- --------- ----------------\n 64.32    0.031423          12      2619         0  read\n 21.17    0.010342          41       252         3  openat\n 10.44    0.005103           4      1277         0  write\n  4.07    0.001989          88        22        18  connect\n  ...\n------ ----------- ----------- --------- --------- ----------------\n100.00    0.048857                  4170        21  total\n```\nThere are two deceptions hiding in this milestone \u2014 one about time, one about attachment \u2014 that almost every first implementation gets wrong. Let's find them.\n\n![Syscall Timing: What You're Actually Measuring](./diagrams/diag-m4-timing-overhead.svg)\n\n---\n## The Core Revelation: You're Not Timing the Syscall\nHere is what seems obvious: call `clock_gettime()` when you receive the entry stop, call it again when you receive the exit stop, subtract. The difference is how long the syscall took.\nThis feels exactly right. Entry stop = syscall starts. Exit stop = syscall ends. Delta = syscall duration.\n**It's wrong.** Not wrong in a subtle, edge-case way \u2014 wrong in a fundamental way that makes your measurements 10x to 100x too large for fast syscalls.\nThink through what actually happens between your entry `clock_gettime()` and your exit `clock_gettime()`:\n1. The kernel delivers the entry stop. Your tracer's `waitpid` returns.\n2. **Your tracer calls `clock_gettime()` \u2014 entry timestamp recorded.**\n3. Your tracer calls `PTRACE_GETREGS` (one syscall into the kernel).\n4. Your tracer formats and prints the line (string operations, `fprintf`).\n5. Your tracer calls `ptrace(PTRACE_SYSCALL, ...)` to resume the tracee (another syscall).\n6. The kernel schedules the tracee. The tracee runs until the next syscall boundary.\n7. The tracee actually executes the syscall (say, `getpid` \u2014 about 100 nanoseconds).\n8. The kernel stops the tracee at the exit boundary. The tracer's `waitpid` returns.\n9. Your tracer calls `PTRACE_GETREGS` again (another syscall into the kernel).\n10. **Your tracer calls `clock_gettime()` \u2014 exit timestamp recorded.**\nThe delta between steps 2 and 10 includes: `PTRACE_GETREGS`, formatting, `fprintf`, `PTRACE_SYSCALL`, kernel scheduling, the actual syscall, another kernel wake-up, another `PTRACE_GETREGS`. That's easily 10\u201350 microseconds of overhead wrapping a `getpid` call that takes ~100 nanoseconds.\nYour measurement: 10\u201350\u00b5s. Actual syscall: 0.1\u00b5s. **Error factor: 100\u2013500\u00d7.**\n> **What you're actually measuring**: wall-clock time from \"tracer noticed entry\" to \"tracer noticed exit\" \u2014 which is dominated by ptrace overhead, not by the syscall itself.\nReal strace knows this and says so. Look at the bottom of its `-c` output:\n```\n% time     seconds  usecs/call  ...\n```\nIt says \"seconds,\" not \"CPU time.\" In `strace(1)` man page: *\"the values in 'seconds' column may be much larger than actual time spent executing system calls since the wall-clock time includes the time spent waiting for the tracer to handle events.\"*\nThis isn't a bug in your implementation \u2014 it's an inherent property of the ptrace observation model. The act of observing adds overhead. Your summary table is still *useful*: relative percentages tell you which syscalls dominate *even accounting for overhead*, and call counts are always accurate. Just don't mistake your timing for true syscall latency.\nThe lesson: **build the timing correctly, understand what it measures, and communicate it honestly in your output.**\nNow, the second deception: which clock to use.\n### CLOCK_MONOTONIC vs CLOCK_REALTIME\n`clock_gettime()` accepts a clock ID that selects which clock source to read. Two are relevant here:\n**`CLOCK_REALTIME`** \u2014 The system's wall clock. This matches what you'd see on a clock on the wall. It can be adjusted: Network Time Protocol (NTP) can step the clock forward or backward to synchronize it with time servers. If NTP steps the clock backward by 100ms between your entry and exit timestamps, you get a negative duration. If NTP steps it forward, you get an inflated duration. Real-time adjustments happen routinely on any server running `ntpd` or `chronyd`.\n**`CLOCK_MONOTONIC`** \u2014 A clock that only ever goes forward, monotonically. It has no epoch (it doesn't represent \"time since 1970\") \u2014 it's just a counter that increases at a stable rate. NTP cannot adjust it backward. It may be slewed (gradually sped up or slowed down) to stay close to real time, but it never jumps. For measuring durations, this is the correct choice.\n```c\nstruct timespec ts;\nclock_gettime(CLOCK_MONOTONIC, &ts);\n/* ts.tv_sec is seconds, ts.tv_nsec is nanoseconds [0, 999999999] */\n```\nTo compute a duration in nanoseconds:\n```c\n/* Compute elapsed nanoseconds between two timespec values */\nstatic long long timespec_diff_ns(const struct timespec *start,\n                                  const struct timespec *end)\n{\n    return (long long)(end->tv_sec  - start->tv_sec)  * 1000000000LL\n         + (long long)(end->tv_nsec - start->tv_nsec);\n}\n```\n**Always use `CLOCK_MONOTONIC` for measuring durations between two events. Always use `CLOCK_REALTIME` only when you need the actual calendar time.**\n---\n## Extending Per-PID State for Timing\nTo record timing, you need to store the entry timestamp alongside the entry registers in your per-PID state struct. Add a `timespec` field:\n```c\n#include <time.h>\ntypedef struct {\n    pid_t                   pid;\n    int                     in_syscall;\n    struct user_regs_struct entry_regs;\n    struct timespec         entry_time;   /* CLOCK_MONOTONIC timestamp at entry */\n    int                     valid;\n} ProcessState;\n```\nMemory layout update (from Milestone 3's 232-byte struct):\n| Field | Type | Size | Offset |\n|-------|------|------|--------|\n| `pid` | `pid_t` (int) | 4 bytes | 0 |\n| `in_syscall` | `int` | 4 bytes | 4 |\n| `entry_regs` | `struct user_regs_struct` | 216 bytes | 8 |\n| `entry_time` | `struct timespec` | 16 bytes | 224 |\n| `valid` | `int` | 4 bytes | 240 |\n| (padding) | \u2014 | 4 bytes | 244 |\n| **Total** | | **248 bytes** | |\nOn entry stop, record the timestamp immediately after `PTRACE_GETREGS` returns:\n```c\nif (state->in_syscall == 0) {\n    /* Entry stop */\n    state->entry_regs = regs;\n    clock_gettime(CLOCK_MONOTONIC, &state->entry_time);\n    state->in_syscall = 1;\n}\n```\nOn exit stop, compute the duration and pass it to the statistics accumulator:\n```c\n} else {\n    /* Exit stop */\n    struct timespec exit_time;\n    clock_gettime(CLOCK_MONOTONIC, &exit_time);\n    long long elapsed_ns = timespec_diff_ns(&state->entry_time, &exit_time);\n    long syscall_num = (long)state->entry_regs.orig_rax;\n    long return_val  = (long)regs.rax;\n    int  is_error    = (return_val >= -4096L && return_val <= -1L);\n    stats_record(syscall_num, elapsed_ns, is_error);\n    print_syscall(stopped_pid, /*show_pid=*/1, &state->entry_regs, return_val);\n    state->in_syscall = 0;\n}\n```\n---\n## Building the Statistics Accumulator\nThe statistics table needs to track, per syscall number:\n- Total call count\n- Error count\n- Cumulative time (nanoseconds)\nAt the end of the trace, you sort by cumulative time descending and print the table.\n{{DIAGRAM:diag-m4-statistics-table}}\nDefine the accumulator structure:\n```c\n#define MAX_SYSCALL_NUM 335\ntypedef struct {\n    long long total_ns;    /* Cumulative nanoseconds (measured, overhead-inclusive) */\n    long      call_count;  /* Total invocations */\n    long      error_count; /* Invocations that returned error ([-4096, -1]) */\n} SyscallStats;\nstatic SyscallStats stats[MAX_SYSCALL_NUM + 1];\nvoid stats_init(void) {\n    memset(stats, 0, sizeof(stats));\n}\nvoid stats_record(long syscall_num, long long elapsed_ns, int is_error) {\n    if (syscall_num < 0 || syscall_num > MAX_SYSCALL_NUM) return;\n    stats[syscall_num].total_ns   += elapsed_ns;\n    stats[syscall_num].call_count++;\n    if (is_error) stats[syscall_num].error_count++;\n}\n```\nThe accumulator is an array indexed by syscall number \u2014 O(1) update per syscall, no allocation, perfect cache behavior. The entire array is `336 \u00d7 (8 + 8 + 8) = 8,064 bytes` \u2014 fits in L1 cache (typically 32 KB). Every `stats_record` call touches exactly one 64-byte cache line within this array (the `SyscallStats` for that syscall number), and the hot syscalls stay permanently warm.\n### Printing the Summary Table\nWhen tracing ends, sort by `total_ns` descending and print. Because you're sorting a fixed-size array of 336 elements, even an O(n\u00b2) sort is instantaneous. Use `qsort` with a custom comparator on an index array:\n```c\nvoid stats_print(FILE *out) {\n    /* Build index array of syscalls that had at least one call */\n    int indices[MAX_SYSCALL_NUM + 1];\n    int count = 0;\n    long long grand_total_ns = 0;\n    long grand_calls = 0;\n    long grand_errors = 0;\n    for (int i = 0; i <= MAX_SYSCALL_NUM; i++) {\n        if (stats[i].call_count > 0) {\n            indices[count++] = i;\n            grand_total_ns += stats[i].total_ns;\n            grand_calls    += stats[i].call_count;\n            grand_errors   += stats[i].error_count;\n        }\n    }\n    /* Sort by total_ns descending using qsort with a comparator */\n    /* comparator captures stats[] via global \u2014 acceptable here */\n    qsort(indices, count, sizeof(int), compare_by_total_ns);\n    /* Print header */\n    fprintf(out, \"%% time     seconds  usecs/call     calls    errors  syscall\\n\");\n    fprintf(out, \"------ ----------- ----------- --------- --------- ----------------\\n\");\n    /* Print each row */\n    for (int i = 0; i < count; i++) {\n        int n = indices[i];\n        double pct      = (grand_total_ns > 0)\n                          ? 100.0 * stats[n].total_ns / grand_total_ns\n                          : 0.0;\n        double secs     = stats[n].total_ns / 1e9;\n        long   usecs_pc = (stats[n].call_count > 0)\n                          ? (long)(stats[n].total_ns / 1000 / stats[n].call_count)\n                          : 0;\n        fprintf(out, \"%6.2f %11.6f %11ld %9ld %9ld  %s\\n\",\n                pct, secs, usecs_pc,\n                stats[n].call_count, stats[n].error_count,\n                syscall_name((long)n));\n    }\n    /* Print footer */\n    fprintf(out, \"------ ----------- ----------- --------- --------- ----------------\\n\");\n    fprintf(out, \"100.00 %11.6f           %9ld %9ld  total\\n\",\n            grand_total_ns / 1e9, grand_calls, grand_errors);\n}\n/* qsort comparator: sort indices by total_ns descending */\nstatic int compare_by_total_ns(const void *a, const void *b) {\n    int ia = *(const int *)a;\n    int ib = *(const int *)b;\n    if (stats[ib].total_ns > stats[ia].total_ns) return  1;\n    if (stats[ib].total_ns < stats[ia].total_ns) return -1;\n    return 0;\n}\n```\nNote that the summary is printed to `stderr` by default (or to the `-o` file if specified \u2014 we'll set that up shortly). When you print the normal trace output to `stderr` and the summary also to `stderr`, you can redirect them independently.\n---\n## Syscall Filtering with -e trace=\nThe `-e trace=` flag tells your tracer which syscalls to *print*. Crucially, you still trace everything (all syscalls still trigger stops, the toggle still fires, statistics still accumulate) \u2014 you just skip the print step for syscalls not in the filter set.\n\n![Syscall Filter: Trace Everything, Print Selectively](./diagrams/diag-m4-filter-architecture.svg)\n\nThis distinction matters enormously. If you tried to *not trace* certain syscalls, you'd need to implement selective PTRACE_SYSCALL behavior, which doesn't exist at the ptrace API level \u2014 ptrace gives you all-or-nothing interception. More importantly, even if you skip printing `mmap`, you still need to count it for the statistics table. The filter is purely a *display* filter, not a tracing filter.\n### Parsing the Filter String\nThe flag syntax is `-e trace=open,read,write`. Parse it at startup:\n```c\n#define MAX_FILTER_SYSCALLS 64\ntypedef struct {\n    int     enabled;                          /* 1 if filter is active */\n    int     count;                            /* Number of names in filter */\n    char    names[MAX_FILTER_SYSCALLS][32];   /* Syscall names to show */\n    int     nums[MAX_FILTER_SYSCALLS];        /* Corresponding syscall numbers (-1 if unknown) */\n} SyscallFilter;\nstatic SyscallFilter filter = { .enabled = 0 };\n/* Parse \"-e trace=open,read,write\" into the filter struct.\n * 'spec' points to the string after \"trace=\" */\nvoid filter_parse(const char *spec) {\n    filter.enabled = 1;\n    filter.count   = 0;\n    char buf[256];\n    strncpy(buf, spec, sizeof(buf) - 1);\n    buf[sizeof(buf) - 1] = '\\0';\n    char *tok = strtok(buf, \",\");\n    while (tok != NULL && filter.count < MAX_FILTER_SYSCALLS) {\n        strncpy(filter.names[filter.count], tok, 31);\n        filter.names[filter.count][31] = '\\0';\n        /* Try to resolve name to number at parse time for O(1) lookup */\n        filter.nums[filter.count] = syscall_num_by_name(tok);\n        filter.count++;\n        tok = strtok(NULL, \",\");\n    }\n}\n/* Returns 1 if syscall_num passes the filter (should be printed), 0 if not */\nint filter_passes(long syscall_num) {\n    if (!filter.enabled) return 1;  /* No filter: print everything */\n    for (int i = 0; i < filter.count; i++) {\n        if (filter.nums[i] == (int)syscall_num) return 1;\n    }\n    return 0;\n}\n```\n`syscall_num_by_name()` requires a reverse lookup: name \u2192 number. The simplest implementation is a linear scan of your `syscall_names[]` array from Milestone 2:\n```c\nint syscall_num_by_name(const char *name) {\n    for (int i = 0; i <= MAX_SYSCALL_NUM; i++) {\n        if (syscall_names[i] != NULL && strcmp(syscall_names[i], name) == 0) {\n            return i;\n        }\n    }\n    return -1;  /* Unknown name */\n}\n```\nThis is O(n) and runs once at startup \u2014 completely acceptable. If an unknown name is given, `filter.nums[i] = -1`, which will never match a real syscall number (syscall numbers are \u2265 0), so the filter silently ignores unrecognized names. You could warn the user; real strace does.\n### Applying the Filter\nIn `print_syscall()`, add the filter check before formatting output:\n```c\nvoid print_syscall(pid_t pid, int show_pid,\n                   struct user_regs_struct *entry_regs,\n                   long return_val,\n                   FILE *out)\n{\n    long syscall_num = (long)entry_regs->orig_rax;\n    /* Filter check: only print if this syscall passes the display filter */\n    if (!filter_passes(syscall_num)) return;\n    /* ... rest of formatting ... */\n}\n```\nNote: `stats_record()` is called *before* `print_syscall()` in the exit handler, so statistics always accumulate regardless of the filter. The filter only gates printing.\n---\n## File Output with -o\nThe `-o filename` flag redirects trace output from `stderr` to a file. The design decision here is how to handle the file handle throughout the codebase.\nThe cleanest approach: a global `FILE *trace_out` that defaults to `stderr` and is set to the opened file if `-o` is given. Every print call uses `trace_out` instead of `stderr`.\n```c\nstatic FILE *trace_out = NULL;  /* Set in main() */\nvoid tracer_init_output(const char *filename) {\n    if (filename != NULL) {\n        trace_out = fopen(filename, \"w\");\n        if (trace_out == NULL) {\n            perror(\"fopen output file\");\n            exit(1);\n        }\n    } else {\n        trace_out = stderr;\n    }\n}\n```\nFor multi-process traces, multiple processes may have syscalls completing in the same `waitpid` batch. Since you process one event at a time (your loop is single-threaded), there's no concurrent write issue \u2014 each `fprintf(trace_out, ...)` call is fully sequential. If you were using threads, you'd need a mutex around writes. With your single-threaded event loop, the sequential guarantee is free.\nClean up on exit:\n```c\nvoid tracer_close_output(void) {\n    if (trace_out != NULL && trace_out != stderr) {\n        fclose(trace_out);\n    }\n}\n```\nThe summary table (`stats_print`) should write to the same `trace_out` file if `-o` is active. If no `-o` flag is used, write the summary to `stderr` (so it appears in the terminal even when the trace is piped elsewhere).\n---\n## Command-Line Argument Parsing\nNow that you have `-e`, `-o`, `-p`, and `-c` flags, you need structured argument parsing. `getopt()` is the POSIX standard:\n```c\n#include <getopt.h>\ntypedef struct {\n    const char *output_file;    /* -o filename, or NULL */\n    const char *filter_spec;    /* -e trace=..., or NULL */\n    pid_t       attach_pid;     /* -p PID, or 0 */\n    int         summary_mode;   /* -c flag */\n    /* argv for the program to run (after options), or NULL if -p */\n    char      **target_argv;\n} TracerOptions;\nTracerOptions parse_options(int argc, char *argv[]) {\n    TracerOptions opts = { NULL, NULL, 0, 0, NULL };\n    int opt;\n    while ((opt = getopt(argc, argv, \"o:e:p:c\")) != -1) {\n        switch (opt) {\n        case 'o':\n            opts.output_file = optarg;\n            break;\n        case 'e':\n            /* Expect \"trace=name,name,...\" */\n            if (strncmp(optarg, \"trace=\", 6) == 0) {\n                opts.filter_spec = optarg + 6;\n            } else {\n                fprintf(stderr, \"Unknown -e option: %s\\n\", optarg);\n                exit(1);\n            }\n            break;\n        case 'p':\n            opts.attach_pid = (pid_t)atoi(optarg);\n            if (opts.attach_pid <= 0) {\n                fprintf(stderr, \"Invalid PID: %s\\n\", optarg);\n                exit(1);\n            }\n            break;\n        case 'c':\n            opts.summary_mode = 1;\n            break;\n        default:\n            fprintf(stderr, \"Usage: %s [-o file] [-e trace=...] [-c] \"\n                            \"[-p pid | program [args...]]\\n\", argv[0]);\n            exit(1);\n        }\n    }\n    if (opts.attach_pid == 0) {\n        if (optind >= argc) {\n            fprintf(stderr, \"Need -p PID or a program to run\\n\");\n            exit(1);\n        }\n        opts.target_argv = &argv[optind];\n    }\n    return opts;\n}\n```\n`getopt()` is POSIX-standard and available on any Linux system. `optarg` is a global pointer to the current option's argument. `optind` is the index of the first non-option argument after processing \u2014 pointing at your target program's `argv`.\n---\n## PTRACE_ATTACH: Tracing a Running Process\nEverything you've built so far assumes you start the tracee yourself: fork, PTRACE_TRACEME, exec. But one of strace's most powerful features is `-p PID`: attach to an *already-running* process without restarting it. This requires a completely different entry point into the ptrace lifecycle.\n\n![PTRACE_ATTACH vs Fork+TRACEME: Two Entry Points](./diagrams/diag-m4-attach-vs-fork.svg)\n\n### How PTRACE_ATTACH Works\n`ptrace(PTRACE_ATTACH, pid, NULL, NULL)` tells the kernel: \"I want to become the tracer for process `pid`.\" The kernel:\n1. Checks that you have permission (you must be the process owner, or have `CAP_SYS_PTRACE` capability).\n2. Sets the `PT_TRACED` flag on the target process's `task_struct`.\n3. **Sends `SIGSTOP` to the target process.** This stops it so you can set up the tracing relationship cleanly.\n4. Returns 0 to your tracer.\nThe `SIGSTOP` is critical \u2014 and it's also a source of disruption. The target process was running happily; you've now injected a `SIGSTOP` into it. Any signal handlers the target has for `SIGSTOP` will fire. The process is visibly paused. If it was in the middle of a critical section, holding a mutex, or doing time-sensitive I/O, the `SIGSTOP` interrupts that.\nThis is why a newer API exists \u2014 but let's first implement `PTRACE_ATTACH` correctly, then discuss the alternative.\n```c\nvoid attach_to_process(pid_t pid) {\n    if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {\n        perror(\"ptrace PTRACE_ATTACH\");\n        if (errno == EPERM) {\n            fprintf(stderr, \"Permission denied. Try running as root, or:\\n\");\n            fprintf(stderr, \"  echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope\\n\");\n        }\n        exit(1);\n    }\n    /* Wait for the SIGSTOP that PTRACE_ATTACH sends */\n    int status;\n    pid_t stopped = waitpid(pid, &status, 0);\n    if (stopped == -1) {\n        perror(\"waitpid after PTRACE_ATTACH\");\n        exit(1);\n    }\n    if (!WIFSTOPPED(status)) {\n        fprintf(stderr, \"Process %d did not stop after PTRACE_ATTACH\\n\", pid);\n        exit(1);\n    }\n    /* The stop signal should be SIGSTOP (or occasionally SIGTRAP).\n     * Either way, we don't re-inject it \u2014 it was our attachment signal. */\n    /* Set the same options as in the fork case */\n    long opts = PTRACE_O_TRACESYSGOOD\n               | PTRACE_O_TRACEFORK\n               | PTRACE_O_TRACEVFORK\n               | PTRACE_O_TRACECLONE\n               | PTRACE_O_TRACEEXEC;\n    if (ptrace(PTRACE_SETOPTIONS, pid, NULL, (void *)opts) == -1) {\n        perror(\"ptrace SETOPTIONS after ATTACH\");\n        exit(1);\n    }\n    /* Create state for this PID and start tracing */\n    ProcessState *state = state_map_insert(pid);\n    state->in_syscall = 0;\n    active_count = 1;\n    /* Resume the process \u2014 it will now be traced */\n    if (ptrace(PTRACE_SYSCALL, pid, NULL, NULL) == -1) {\n        perror(\"ptrace PTRACE_SYSCALL after ATTACH\");\n        exit(1);\n    }\n}\n```\n### The ptrace_scope Permission Wall\nModern Linux kernels restrict which processes can trace which other processes, controlled by `/proc/sys/kernel/yama/ptrace_scope`:\n| Value | Meaning |\n|-------|---------|\n| 0 | Permissive: any process can trace any other process it owns |\n| 1 | Restricted: can only trace children or processes that called `prctl(PR_SET_PTRACER, tracer_pid)` |\n| 2 | Admin-only: only processes with `CAP_SYS_PTRACE` can trace |\n| 3 | Completely disabled |\nMost desktop Linux distributions default to 1. This means `PTRACE_ATTACH` on an arbitrary process will fail with `EPERM` unless you're root or the target has explicitly allowed it. Your code already handles this with the helpful error message. For development, running as root or temporarily setting `ptrace_scope` to 0 is the pragmatic approach.\n### Key Difference from Fork+TRACEME\nWith fork+TRACEME, the tracee starts in a controlled state: it requested tracing, exec'd the target program, and paused at the post-exec SIGTRAP. The toggle starts at 0 (not mid-syscall). The address space is fresh.\nWith PTRACE_ATTACH, the target process might be *anywhere* in its execution: inside a syscall (having executed the `syscall` instruction but not yet returned), between syscalls, in a signal handler. You cannot know. The toggle must conservatively start at 0 (assume you're at an entry boundary), and the first stop after `PTRACE_SYSCALL` will tell you more. If the process was stopped mid-syscall, you'll get an exit stop first \u2014 which, with toggle at 0, you'd misidentify as an entry stop. This produces one garbage print, then the trace self-corrects. Real strace handles this edge case by checking `orig_rax` on the first stop to determine whether it looks like an entry or exit. For this milestone, the conservative approach (start at 0) is acceptable.\n---\n## Clean Detach: The SIGINT Handler\nWhen your tracer receives `SIGINT` (Ctrl+C), it must not simply `exit()`. If the tracee is ptrace-traced and the tracer exits without detaching, the kernel sends `SIGHUP` to the tracee, which typically kills it. That's not what users expect from \"press Ctrl+C to stop tracing\" \u2014 they expect the traced process to continue running normally.\nThe correct sequence on tracer exit when using `PTRACE_ATTACH`:\n1. The tracee must be in a **stopped state** for `PTRACE_DETACH` to succeed.\n2. If the tracee is running (between stops), you must send it `SIGSTOP` and wait for it to stop.\n3. Call `ptrace(PTRACE_DETACH, pid, NULL, NULL)`.\n4. The tracee resumes as if it was never traced.\n\n![Clean Detach Sequence on SIGINT](./diagrams/diag-m4-clean-detach.svg)\n\nIf you forked the tracee yourself (not PTRACE_ATTACH mode), the user probably wants to kill it when they Ctrl+C. In that case, you can let the default SIGINT behavior kill both tracer and tracee via the terminal's process group signal delivery.\nThe tricky part: your `SIGINT` handler runs *asynchronously*, while your main loop might be anywhere. Signal safety rules restrict what you can call from a signal handler \u2014 you cannot call `ptrace()` or `waitpid()` from a signal handler, because they may allocate memory or modify global state in non-reentrant ways.\nThe correct pattern: use a flag and handle detach in the main loop.\n```c\n#include <signal.h>\nstatic volatile sig_atomic_t g_interrupted = 0;\nstatic pid_t g_attached_pid = 0;  /* Set if we used PTRACE_ATTACH */\nstatic void sigint_handler(int sig) {\n    (void)sig;\n    g_interrupted = 1;\n}\nvoid install_sigint_handler(void) {\n    struct sigaction sa;\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigint_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;  /* No SA_RESTART: let syscalls (waitpid) be interrupted */\n    sigaction(SIGINT, &sa, NULL);\n}\n```\nIn the main loop, check `g_interrupted` after each `waitpid` return:\n```c\nwhile (active_count > 0) {\n    pid_t stopped_pid = waitpid(-1, &status, 0);\n    if (stopped_pid == -1) {\n        if (errno == EINTR) {\n            /* waitpid was interrupted \u2014 could be SIGINT */\n            if (g_interrupted) {\n                handle_interrupt();\n                break;\n            }\n            continue;\n        }\n        if (errno == ECHILD) break;\n        perror(\"waitpid\");\n        break;\n    }\n    /* ... normal event handling ... */\n    /* Check interrupt flag between events */\n    if (g_interrupted) {\n        handle_interrupt();\n        break;\n    }\n}\n```\nThe detach sequence, called from the main loop context (safe to call ptrace here):\n```c\nvoid handle_interrupt(void) {\n    if (g_attached_pid != 0) {\n        /* We attached to a running process \u2014 detach cleanly */\n        /* The process may or may not be stopped right now.\n         * PTRACE_DETACH requires the tracee to be stopped.\n         * Send SIGSTOP and wait for it. */\n        kill(g_attached_pid, SIGSTOP);\n        int status;\n        waitpid(g_attached_pid, &status, 0);\n        /* Detach, allowing the process to continue */\n        ptrace(PTRACE_DETACH, g_attached_pid, NULL, NULL);\n        fprintf(stderr, \"Detached from process %d\\n\", g_attached_pid);\n    } else {\n        /* We forked the tracee \u2014 let it die naturally or kill it */\n        /* The traced children will be killed when the tracer exits\n         * because they're in the same process group */\n        fprintf(stderr, \"Interrupted\\n\");\n    }\n    /* Print summary if in summary mode */\n    if (summary_mode) {\n        stats_print(stderr);\n    }\n}\n```\n> **Why SA_RESTART is not set**: The `waitpid()` syscall is a blocking wait. When `SIGINT` arrives, the kernel interrupts `waitpid` and returns `-1` with `errno == EINTR`. Without `SA_RESTART`, this interruption surfaces to your code so you can check `g_interrupted`. With `SA_RESTART`, the kernel would automatically restart `waitpid`, and you might not notice the signal for a long time (until the next child event). For responsiveness, you want `EINTR` to propagate.\n---\n## Three-Level View: What PTRACE_DETACH Does\nLet's see detach at all three levels for clarity.\n**Level 1 \u2014 Application (Tracer)**\nYou call `ptrace(PTRACE_DETACH, pid, NULL, NULL)`. The function returns 0 on success. The target process starts running again.\n**Level 2 \u2014 Kernel**\nThe kernel's `ptrace_detach()` function:\n1. Clears the `PT_TRACED` flag on the target's `task_struct`.\n2. Sets the target's parent back to its real parent (before you attached, it had been reparented to your tracer for `waitpid` purposes).\n3. Removes the target from your tracer's list of traced children.\n4. Sends `SIGCONT` to the target if it was stopped, waking it up.\n5. Wakes the target's scheduler entry so it can run.\nThe target process resumes as if `ptrace` had never happened. Any pending signals that were suppressed during tracing are delivered. Any partial syscall state is intact.\n**Level 3 \u2014 Hardware**\nFrom the CPU's perspective, the target process was in `TASK_STOPPED` state \u2014 its scheduler entry was removed from the run queue. `PTRACE_DETACH` re-adds it to the run queue. The next time the scheduler runs (at the next timer interrupt, or immediately if a CPU is idle), the target's thread is scheduled and its saved `RIP` register picks up execution exactly where it stopped.\nThe `PT_TRACED` flag in the kernel's `task_struct` is what causes the entry/exit stops to fire. Clearing it stops all future tracing overhead. From that moment, the target process runs at full speed with zero ptrace overhead.\n---\n## Hardware Soul: The Observer Effect in Practice\nYour tracer imposes real overhead on the traced process. Let's quantify it.\n**Per-syscall overhead breakdown** (approximate, 3 GHz x86_64):\n- Tracer `waitpid` returns: ~100 cycles (kernel wake-up)\n- `PTRACE_GETREGS`: ~500 cycles (kernel boundary + register copy)\n- `clock_gettime(CLOCK_MONOTONIC)`: ~30 cycles (VDSO fast path)\n- Filter check (`filter_passes`): ~10 cycles\n- `fprintf` to print line (with format + string ops): ~500\u20135,000 cycles\n- `ptrace(PTRACE_SYSCALL, ...)`: ~300 cycles (kernel boundary)\n- Context switch tracer \u2192 tracee: ~1,000\u20133,000 cycles\n**Total overhead per traced syscall**: ~3,000\u201310,000 cycles \u2248 **1\u20133 microseconds at 3 GHz**.\nFor a syscall like `gettimeofday` (~100 ns = 300 cycles), you're adding 10\u201330\u00d7 overhead. For `read()` on a local SSD (~50\u2013100 \u00b5s), the overhead is negligible (2%).\n**Cache behavior**: Your `stats[]` array (8 KB) fits entirely in L1 data cache (typically 32 KB). After the first few dozen syscalls, all hot entries are permanently cached. `stats_record()` is essentially:\n- 1 bounds check (branch predicted correctly)\n- 1 L1 cache read + increment + write (\u00d73 fields)\n- Total: ~5\u201310 cycles\n**The observer effect on real programs**: If you trace a lock-contention benchmark (many threads fighting over a mutex), the ptrace overhead between syscall entry and exit extends the critical section window. Threads that would have been in and out of the kernel quickly now spend 10\u201350\u00d7 longer stopped, allowing more contention. Your trace may show `futex` calls dominating \u2014 but some of that dominance is *caused by* the tracing itself. The observed system is not the unobserved system. Keep this in mind when interpreting timing results.\n---\n## Complete Main Function: Wiring Everything Together\nHere's how all the new components wire together in `main()`:\n```c\nint main(int argc, char *argv[]) {\n    TracerOptions opts = parse_options(argc, argv);\n    /* Initialize subsystems */\n    state_map_init();\n    stats_init();\n    tracer_init_output(opts.output_file);\n    install_sigint_handler();\n    if (opts.filter_spec != NULL) {\n        filter_parse(opts.filter_spec);\n    }\n    if (opts.attach_pid != 0) {\n        /* Attach to running process */\n        g_attached_pid = opts.attach_pid;\n        attach_to_process(opts.attach_pid);\n        /* active_count set to 1 inside attach_to_process */\n    } else {\n        /* Fork and exec the target program */\n        pid_t child = fork();\n        if (child < 0) { perror(\"fork\"); return 1; }\n        if (child == 0) {\n            ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n            execvp(opts.target_argv[0], opts.target_argv);\n            perror(\"execvp\");\n            exit(1);\n        }\n        /* Catch post-exec SIGTRAP */\n        int status;\n        waitpid(child, &status, 0);\n        if (!WIFSTOPPED(status)) {\n            fprintf(stderr, \"Unexpected initial status\\n\");\n            return 1;\n        }\n        long tracer_opts = PTRACE_O_TRACESYSGOOD\n                         | PTRACE_O_TRACEFORK\n                         | PTRACE_O_TRACEVFORK\n                         | PTRACE_O_TRACECLONE\n                         | PTRACE_O_TRACEEXEC;\n        ptrace(PTRACE_SETOPTIONS, child, NULL, (void *)tracer_opts);\n        ProcessState *init_state = state_map_insert(child);\n        init_state->in_syscall = 0;\n        active_count = 1;\n        ptrace(PTRACE_SYSCALL, child, NULL, NULL);\n    }\n    /* \u2500\u2500 MAIN TRACING LOOP (same structure as Milestone 3) \u2500\u2500 */\n    while (active_count > 0) {\n        pid_t stopped_pid = waitpid(-1, &status, 0);\n        if (stopped_pid == -1) {\n            if (errno == EINTR && g_interrupted) { handle_interrupt(); break; }\n            if (errno == ECHILD) break;\n            perror(\"waitpid\"); break;\n        }\n        if (g_interrupted) { handle_interrupt(); break; }\n        if (WIFEXITED(status)) {\n            if (!opts.summary_mode || filter.enabled == 0) {\n                fprintf(trace_out, \"[pid %d] +++ exited with %d +++\\n\",\n                        stopped_pid, WEXITSTATUS(status));\n            }\n            state_map_remove(stopped_pid);\n            active_count--;\n            continue;\n        }\n        if (WIFSIGNALED(status)) {\n            fprintf(trace_out, \"[pid %d] +++ killed by signal %d (%s) +++\\n\",\n                    stopped_pid, WTERMSIG(status), strsignal(WTERMSIG(status)));\n            state_map_remove(stopped_pid);\n            active_count--;\n            continue;\n        }\n        if (!WIFSTOPPED(status)) continue;\n        int sig   = WSTOPSIG(status);\n        int event = (status >> 16) & 0xff;\n        ProcessState *state = state_map_find(stopped_pid);\n        if (state == NULL) {\n            state = state_map_insert(stopped_pid);\n            if (state == NULL) {\n                ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n                continue;\n            }\n            active_count++;\n        }\n        if (event != 0) {\n            handle_ptrace_event(stopped_pid, state, event);\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        if (sig == (SIGTRAP | 0x80)) {\n            struct user_regs_struct regs;\n            if (ptrace(PTRACE_GETREGS, stopped_pid, NULL, &regs) == -1) {\n                ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n                continue;\n            }\n            if (state->in_syscall == 0) {\n                /* Entry: save regs + timestamp */\n                state->entry_regs = regs;\n                clock_gettime(CLOCK_MONOTONIC, &state->entry_time);\n                state->in_syscall = 1;\n            } else {\n                /* Exit: compute duration, record stats, maybe print */\n                struct timespec exit_time;\n                clock_gettime(CLOCK_MONOTONIC, &exit_time);\n                long long elapsed_ns = timespec_diff_ns(&state->entry_time,\n                                                        &exit_time);\n                long syscall_num = (long)state->entry_regs.orig_rax;\n                long return_val  = (long)regs.rax;\n                int  is_error    = (return_val >= -4096L && return_val <= -1L);\n                stats_record(syscall_num, elapsed_ns, is_error);\n                if (!opts.summary_mode) {\n                    /* Print the syscall line (filtered inside print_syscall) */\n                    print_syscall(stopped_pid, /*show_pid=*/1,\n                                  &state->entry_regs, return_val, trace_out);\n                }\n                state->in_syscall = 0;\n            }\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        if (sig == SIGTRAP) {\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        /* Signal-delivery stop: re-inject */\n        ptrace(PTRACE_SYSCALL, stopped_pid, NULL, (void *)(long)sig);\n    }\n    /* Print summary if requested */\n    if (opts.summary_mode) {\n        stats_print(stderr);\n    }\n    tracer_close_output();\n    return 0;\n}\n```\n---\n## Common Bugs in This Milestone\n### Bug 1: Timing Across the Print\n```c\n/* WRONG: clock_gettime after fprintf includes I/O time in the measurement */\nif (state->in_syscall == 0) {\n    clock_gettime(CLOCK_MONOTONIC, &state->entry_time);\n    /* ... save regs ... */\n    fprintf(trace_out, \"entering syscall...\\n\");   /* 500\u20135000 cycles of I/O */\n    state->in_syscall = 1;\n}\n```\nIf you print at entry, the I/O time is included between entry and exit timestamps, making the timing wildly inaccurate. Take the `clock_gettime` immediately after `PTRACE_GETREGS`, before any I/O. Similarly, take the exit `clock_gettime` immediately \u2014 before printing.\n### Bug 2: CLOCK_REALTIME for Duration\n```c\n/* WRONG: REALTIME can go backwards */\nclock_gettime(CLOCK_REALTIME, &state->entry_time);\n```\nIf NTP slews or steps the clock between entry and exit, you get a negative `elapsed_ns`. Then you add it to `stats[n].total_ns`, producing a cumulative time that decreases. The summary table shows negative seconds for that syscall. Use `CLOCK_MONOTONIC`.\n### Bug 3: Forgetting to Wait for SIGSTOP After PTRACE_ATTACH\n```c\n/* WRONG: skip the waitpid after PTRACE_ATTACH */\nptrace(PTRACE_ATTACH, pid, NULL, NULL);\nptrace(PTRACE_SETOPTIONS, pid, NULL, opts);  /* ESRCH or EIO: process not yet stopped */\n```\n`PTRACE_ATTACH` is asynchronous \u2014 the kernel sends `SIGSTOP` to the target, but that signal may not have been delivered and processed by the time your next `ptrace` call runs. You must `waitpid(pid, ...)` to confirm the process has stopped before calling any other ptrace request on it.\n### Bug 4: Not Filtering But Still Suppressing Stats\n```c\n/* WRONG: returning early before stats_record */\nvoid handle_exit_stop(pid_t pid, ProcessState *state,\n                      struct user_regs_struct *regs) {\n    long syscall_num = (long)state->entry_regs.orig_rax;\n    if (!filter_passes(syscall_num)) return;  /* \u2190 Skips stats! */\n    long return_val = (long)regs->rax;\n    stats_record(syscall_num, elapsed_ns, is_error);\n    print_syscall(pid, 1, &state->entry_regs, return_val, trace_out);\n}\n```\nThe filter controls *printing*, not *recording*. Call `stats_record` unconditionally, then conditionally print.\n### Bug 5: PTRACE_DETACH Without Stopping the Tracee First\n```c\n/* WRONG: detaching from a running tracee */\nptrace(PTRACE_DETACH, pid, NULL, NULL);  /* May return EIO or corrupt state */\n```\n`PTRACE_DETACH` requires the tracee to be in a ptrace stop. If the tracee is running (between stops), `PTRACE_DETACH` fails with `EIO`. You must stop the process first (send `SIGSTOP`, then `waitpid`) before detaching.\n### Bug 6: O_RDONLY = 0 in Stats vs. \"Not Called\"\nThe `stats[]` array is zero-initialized. `stats[n].call_count == 0` means \"never called.\" But your accumulation uses `stats[n].total_ns += elapsed_ns` \u2014 what if `elapsed_ns` is 0? That's fine, it's still a valid count. The danger is if you mistakenly print entries with `call_count == 0` in the summary. The filter `if (stats[i].call_count > 0)` before adding to the print index prevents this.\n---\n## Testing Your Complete Tracer\nBuild and test progressively:\n```bash\n# Basic filtering: only show file operations\n./strace_clone -e trace=openat,read,write,close /bin/ls /tmp\n# Count mode: summary statistics only\n./strace_clone -c /bin/ls /tmp\n# Output to file: trace goes to trace.log, summary to stderr\n./strace_clone -c -o trace.log /bin/ls /tmp\n# Attach to a running process (find a long-running process first)\nsleep 60 &\n./strace_clone -p $!\n# Attach and filter: only network syscalls on a running server\n./strace_clone -p $(pgrep nginx | head -1) -e trace=accept,read,write,close\n# Filter + count: who's calling mmap most?\n./strace_clone -c -e trace=mmap,munmap,brk /bin/python3 -c \"import numpy\"\n```\nExpected summary output for a simple `ls /tmp`:\n```\n% time     seconds  usecs/call     calls    errors  syscall\n------ ----------- ----------- --------- --------- ----------------\n 42.18    0.001853         231         8         0  read\n 28.44    0.001249         178         7         0  mmap\n 15.21    0.000668         111         6         0  openat\n  8.02    0.000352          58         6         0  close\n  3.11    0.000136          17         8         0  fstat\n  2.14    0.000094          31         3         3  access\n  0.90    0.000039          19         2         0  getdents64\n...\n------ ----------- ----------- --------- --------- ----------------\n100.00    0.004391                    74         3  total\n```\n---\n## Knowledge Cascade: What This Unlocks\n### 1. perf and eBPF \u2014 Moving Beyond ptrace's Overhead\nThe fundamental problem with ptrace-based profiling is the cost you've now measured: thousands of cycles per intercepted syscall. For profiling, this is unacceptable \u2014 the overhead changes the program's behavior.\nModern Linux solved this with eBPF (extended Berkeley Packet Filter). An eBPF program is a small, JIT-compiled bytecode program that runs *inside the kernel* \u2014 attached directly to a syscall tracepoint, kprobe, or perf event. When the attached event fires, the eBPF program runs in-kernel, records timing data into a shared map structure, and returns. The profiling data accumulates in kernel memory; your userspace tool reads it periodically.\nThe critical difference: **no context switch per event**. The eBPF program runs in the same kernel context as the syscall itself. For a `getpid` call, the overhead is a few dozen nanoseconds \u2014 not microseconds. `bpftrace -e 'tracepoint:syscalls:sys_enter_openat { @[comm] = count(); }'` counts `openat` calls by process name with essentially zero impact on the traced system.\nThis is why production performance engineering has moved from `strace` to `bpftrace`/`bcc`/`perf` for high-frequency measurement. Your tracer is the right tool for *correctness debugging* (what exactly did this program call?). For *performance profiling* (how often, how long?), eBPF gives you accurate data at production fidelity.\n### 2. PTRACE_SEIZE \u2014 The Evolution of Attachment\nYou used `PTRACE_ATTACH`, which sends `SIGSTOP` to the target. Linux 3.4 introduced `PTRACE_SEIZE` as a cleaner alternative:\n```c\nptrace(PTRACE_SEIZE, pid, NULL, opts);\n```\n`PTRACE_SEIZE` attaches without sending `SIGSTOP`. The process continues running normally. Instead, you receive a notification at the next natural stop (syscall boundary, signal delivery, etc.). This is much less disruptive \u2014 the target doesn't experience an unexpected pause, signal handlers don't fire for `SIGSTOP`, and time-sensitive code doesn't get disrupted.\nWith `PTRACE_SEIZE`, you use `PTRACE_INTERRUPT` (instead of `SIGSTOP`) when you want to force the target to stop:\n```c\nptrace(PTRACE_INTERRUPT, pid, NULL, NULL);\n```\nAnd `PTRACE_LISTEN` replaces `PTRACE_CONT` for passively waiting for the next stop. The attach-then-detach workflow is much cleaner and safer.\nReal strace uses `PTRACE_SEIZE` since version 4.9 (2013). The `PTRACE_ATTACH` path remains for compatibility with older kernels. The evolution from `PTRACE_ATTACH` to `PTRACE_SEIZE` reflects a general principle in Linux API design: when the original API has unavoidable side effects (the `SIGSTOP`), a new API is introduced that achieves the same goal without the disruption.\n### 3. The Observer Effect \u2014 Profiling as a Physics Problem\nYour tracer slows the traced program by 10\u2013100\u00d7. This is the observer effect in systems programming: the measurement apparatus changes what it measures.\nThis isn't unique to ptrace. Every instrumentation technique has a cost:\n| Technique | Overhead per event | Production-safe? |\n|-----------|-------------------|-----------------|\n| ptrace (your tracer) | ~2\u201310 \u00b5s | No |\n| `strace -c` | ~1\u20135 \u00b5s | No |\n| eBPF tracepoint | ~50\u2013200 ns | Yes (low frequency) |\n| Linux perf (sampling) | < 5 \u00b5s per sample | Yes |\n| Hardware PMU counters | ~1 ns | Yes |\nSampling profilers (like `perf record`) sidestep the problem: instead of intercepting every event, they use a timer interrupt to sample the program counter every N milliseconds. The overhead is proportional to *sample rate*, not event rate. A program making 1,000,000 syscalls/second with a 1ms sample interval gives you ~1000 samples \u2014 1000 interrupts, not 1,000,000. The cost is roughly 0.1% instead of 100\u00d7.\nThe observer effect is especially severe for concurrent programs. Lock contention benchmarks are profoundly affected by tracing: if thread A is inside a 500ns critical section and your tracer adds 5\u00b5s of overhead, thread B waiting for the lock experiences an apparent 10\u00d7 increase in contention. The trace shows \"lots of `futex` time\" \u2014 but the futex time is *caused by the trace*. This is why production performance investigation uses sampling or eBPF, not ptrace.\n### 4. Statistical Aggregation \u2014 The Pattern Behind Monitoring Systems\nThe `SyscallStats` accumulator you built is the simplest form of a *streaming aggregation* pattern:\n- **Prometheus** (CNCF metrics) maintains exactly this structure: a counter per label combination, incremented on each event, queried periodically.\n- **statsd** (Etsy, now industry standard) accumulates counts and timings in-memory, then flushes aggregates to a time-series database every 10 seconds.\n- **Kernel perf events** use ring buffers and mmap'd memory to give userspace programs running totals without system calls.\nThe design choice you made \u2014 `total_ns += elapsed_ns` per syscall \u2014 is exactly how Prometheus's `histogram_observe` works for timing data. The \"sorted by cumulative time\" output is how `perf report` ranks hot functions. The percentage calculation (`total_ns / grand_total_ns \u00d7 100`) is how profilers identify bottlenecks.\nThe difference between your accumulator and a production monitoring system is primarily the *output path*. Your system prints at the end. Prometheus exposes an HTTP endpoint. statsd sends UDP packets. But the core \u2014 iterate events, increment counters, accumulate totals \u2014 is identical.\n### 5. Signal Safety and the SIGINT Handler Pattern\nYour `g_interrupted = 1` signal handler pattern is the canonical solution to a fundamental problem in Unix systems programming: signal handlers run asynchronously, interrupting the main thread at any point, but most interesting operations (`ptrace`, `waitpid`, `malloc`) are not *async-signal-safe* \u2014 they may be in the middle of modifying shared state when the signal arrives.\nThe POSIX specification defines a small set of async-signal-safe functions you can call from signal handlers (see `signal-safety(7)`): `write()`, `_exit()`, `kill()`, `sigprocmask()`, and about 70 others. Notably absent: `printf`, `malloc`, `ptrace`, `waitpid`.\nThe safe pattern: signal handler sets a flag (`volatile sig_atomic_t`), main loop checks the flag after each blocking operation. The main loop can then safely call whatever it needs, because it's not inside a signal handler.\nThis pattern generalizes everywhere:\n- Database systems use it for `SIGTERM` shutdown (flush WAL, checkpoint, close files)\n- Web servers use it for graceful reload (`SIGHUP` \u2192 set flag \u2192 drain connections \u2192 reload config)\n- Container runtimes use it for clean pod termination (`SIGTERM` \u2192 flag \u2192 stop all traced processes \u2192 report)\nYour SIGINT handler is a microcosm of production-quality signal handling. The `SA_RESTART` decision (not set, so `waitpid` returns `EINTR`) is the same decision any production daemon makes: \"do I want blocking calls to automatically restart, or do I want them to be interrupted so I can notice signals quickly?\" For a signal-responsive system, `EINTR` propagation is the right choice.\n---\n## A Note on What Your Measurements Mean\nBefore you interpret your first summary table, internalize this:\nThe percentages are meaningful. If `read` shows 64% of your trace time, it's genuinely the dominant syscall \u2014 even accounting for overhead, other syscalls would show similar relative overhead, so the *relative* ranking is trustworthy.\nThe absolute times are not meaningful for comparing to production. A `read()` that takes 100\u00b5s in your trace may take 5\u00b5s untraced. What you're measuring is \"how much time the tracer noticed this syscall consuming,\" not \"how long this syscall actually runs.\"\nThe call counts are exact. They're not subject to timing distortion. If you see 2,619 `read` calls, the program made exactly 2,619 `read` calls.\nThe error counts are exact. 18 failed `connect` calls means 18 real failures.\nReal strace's output header says `% time` not `% CPU time` for precisely this reason. Your output should say the same. Accuracy in communicating what you measure is a form of engineering integrity.\n---\n## Summary: What You've Built\nYour tracer now has the complete feature set of the core strace functionality:\n- Parses `-e trace=name,name,...` to build a display filter; unmatched syscalls accumulate statistics but don't print, preserving the accurate count/timing picture\n- Records `CLOCK_MONOTONIC` timestamps at entry and exit to compute elapsed nanoseconds per syscall, correctly understanding that this measures \"ptrace-observed wall time\" not true syscall CPU time\n- Maintains a zero-allocation, L1-cache-resident `SyscallStats[336]` array accumulating call count, error count, and total nanoseconds per syscall number\n- Sorts and prints a `strace -c`-style summary table (by cumulative time descending) with percentage, seconds, microseconds-per-call, total calls, error count, and syscall name\n- Opens a file on `-o filename` and directs all trace output there; summary always goes to `stderr`\n- Attaches to a running process with `PTRACE_ATTACH`, waits for the `SIGSTOP` acknowledgment, sets full options, and enters the same event loop as the fork case\n- Installs a signal-safe `SIGINT` handler using `volatile sig_atomic_t` and `SA_RESTART=0`; on interrupt, stops the attached tracee with `SIGSTOP`, waits for it to stop, calls `PTRACE_DETACH`, prints the summary, and exits without killing the traced process\n---\n<!-- END_MS -->\n",
  "current_ms_index": 4,
  "diagrams_to_generate": [],
  "diagram_attempt": 0,
  "current_diagram_code": null,
  "current_diagram_meta": null,
  "last_error": null,
  "status": "visualizing",
  "phase": "atlas",
  "tdd_blueprint": {},
  "tdd_accumulated_md": "",
  "tdd_current_mod_index": 0,
  "tdd_diagrams_to_generate": [],
  "external_reading": "",
  "running_criteria": [
    {
      "milestone_id": "build-strace-m1",
      "criteria": [
        "Fork a child process using fork(); the child calls ptrace(PTRACE_TRACEME, 0, NULL, NULL) before execvp() to register itself for tracing",
        "The child calls execvp() to exec the target program immediately after PTRACE_TRACEME; if execvp returns, report error and exit with status 1",
        "The parent catches the initial post-exec SIGTRAP by calling waitpid() and verifies the child stopped with WIFSTOPPED(status)",
        "The parent calls ptrace(PTRACE_SETOPTIONS, child, NULL, PTRACE_O_TRACESYSGOOD) after the initial stop so syscall stops have bit 7 set (SIGTRAP | 0x80 = 0x85)",
        "Implement a PTRACE_SYSCALL + waitpid loop: call ptrace(PTRACE_SYSCALL, child, NULL, NULL) to resume the tracee, then waitpid() to block until the next stop",
        "Maintain an in_syscall toggle flag (initialized to 0); flip it between 0 and 1 on every syscall stop to track entry vs exit",
        "On syscall entry stop (in_syscall == 0, signal == SIGTRAP|0x80): call ptrace(PTRACE_GETREGS) and record orig_rax as the syscall number; do not read rax as a return value",
        "On syscall exit stop (in_syscall == 1, signal == SIGTRAP|0x80): read rax (cast to long) as the return value and orig_rax as the syscall number",
        "Print syscall number and return value on exit in the format: syscall(N) = V, e.g. 'syscall(1) = 5'",
        "Detect error returns by checking: (long)regs.rax >= -4096L && (long)regs.rax <= -1L; negate rax to obtain the errno value",
        "Print error returns in the format: syscall(N) = -1 ERRNAME, e.g. 'syscall(2) = -1 ENOENT', using strerror() or equivalent",
        "Detect signal-delivery stops (WSTOPSIG(status) is not SIGTRAP and not SIGTRAP|0x80); re-inject the signal by calling ptrace(PTRACE_SYSCALL, child, NULL, (void*)(long)sig); do NOT pass 0 which would suppress the signal",
        "Detect tracee normal exit with WIFEXITED(status); print exit status and terminate the tracer loop",
        "Detect tracee signal-killed exit with WIFSIGNALED(status); print killing signal and terminate the tracer loop",
        "Handle ESRCH errno from ptrace calls (tracee may have exited between waitpid and ptrace) gracefully without crashing"
      ]
    },
    {
      "milestone_id": "build-strace-m2",
      "criteria": [
        "Build a static array syscall name table indexed by syscall number covering at least the 50 most common x86_64 syscalls (0=read, 1=write, 2=open, 3=close, 9=mmap, 11=munmap, 12=brk, 21=access, 39=getpid, 57=fork, 59=execve, 60=exit, 257=openat, and others); implement a syscall_name(long num) lookup function that returns 'unknown' for out-of-range or unmapped numbers",
        "Save struct user_regs_struct at syscall entry stop into per-process state; use the saved entry registers (not exit registers) to read argument values, since argument registers may be modified by the kernel during syscall execution",
        "Extract the six syscall arguments from the correct x86_64 registers in the entry snapshot: rdi (arg1), rsi (arg2), rdx (arg3), r10 (arg4), r8 (arg5), r9 (arg6) \u2014 note r10 not rcx for arg4",
        "Implement a word-by-word string reader using PTRACE_PEEKDATA: loop reading 8-byte words, scan each word's bytes from LSB to MSB for a null terminator (\\0), append non-null bytes to output buffer, stop when null found or max length exceeded",
        "Before every PTRACE_PEEKDATA call, set errno = 0; after the call, check for error as (word == -1 && errno != 0) \u2014 not just word == -1 \u2014 because -1 (0xFFFFFFFFFFFFFFFF) is valid data that can legitimately appear in tracee memory",
        "Check for NULL pointer before calling PTRACE_PEEKDATA: if the argument value is 0, print 'NULL' instead of attempting to read tracee address 0 (which is always unmapped)",
        "Truncate strings that reach the configurable maximum length (default 32 bytes) by stopping the PEEKDATA loop at maxlen bytes and appending '...' suffix to the displayed string",
        "Decode open() flags bitmask using a (value, name) flag table covering at minimum: O_RDONLY (0), O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_NONBLOCK, O_CLOEXEC; handle the O_RDONLY=0 edge case explicitly since bitwise AND with 0 never produces a match",
        "Decode mmap() prot flags covering PROT_NONE (0), PROT_READ, PROT_WRITE, PROT_EXEC; decode mmap() map flags covering MAP_SHARED, MAP_PRIVATE, MAP_FIXED, MAP_ANONYMOUS; print remaining unrecognized bits as hex with '|0x...' suffix",
        "Format output in strace style: 'syscall_name(arg1, arg2, ...) = return_value' where errors display as '-1 ERRNO (error message)' and successful returns display the signed decimal return value",
        "Define a per-syscall argument schema (ArgType enum + SyscallDesc struct) specifying the type of each argument position (ARG_INT, ARG_STR, ARG_PTR, ARG_OPEN_FLAGS, ARG_MMAP_PROT, ARG_MMAP_FLAGS, etc.) so the print function can dispatch correctly by argument type",
        "Handle PEEKDATA errors mid-string gracefully: if PEEKDATA fails after reading some bytes, return what was read so far rather than discarding it; if PEEKDATA fails on the very first word, print '<unreadable>'"
      ]
    },
    {
      "milestone_id": "build-strace-m3",
      "criteria": [
        "Set PTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK, PTRACE_O_TRACECLONE, and PTRACE_O_TRACEEXEC options in a single PTRACE_SETOPTIONS call on the initial tracee, before the tracee makes any fork/clone calls",
        "Switch the main tracing loop to use waitpid(-1, &status, 0) and use the returned pid_t to identify which process stopped",
        "Decode ptrace event type by extracting bits 23-16 of the waitpid status word with (status >> 16) & 0xff, and dispatch on PTRACE_EVENT_FORK, PTRACE_EVENT_VFORK, and PTRACE_EVENT_CLONE",
        "On fork/vfork/clone events, call PTRACE_GETEVENTMSG to retrieve the new child PID as an unsigned long, insert it into the per-PID state map with in_syscall=0, increment active_count, and call ptrace(PTRACE_SYSCALL, new_child_pid, NULL, NULL) to start the child tracing",
        "Implement a per-PID state hash map using open addressing with at minimum 256 slots, where each slot holds pid, in_syscall toggle, and saved entry_regs (struct user_regs_struct)",
        "Maintain correct, independent in_syscall toggle state for each PID: syscall entry and exit events for different PIDs must not affect each other's toggle",
        "Tag every printed syscall line with the PID prefix '[pid NNNN]' identifying which process made the call",
        "On PTRACE_EVENT_EXEC, reset the affected PID's in_syscall to 0 and zero out entry_regs, then resume the process with PTRACE_SYSCALL",
        "Track the count of active traced processes; decrement on WIFEXITED or WIFSIGNALED events and print '+++ exited with N +++' or '+++ killed by signal N +++' with the PID prefix; exit the main loop when active_count reaches 0",
        "Handle the case where state_map_find returns NULL for a stopped PID by defensively inserting a new state entry rather than crashing",
        "Correctly identify event stops (event != 0) before checking the signal number, to avoid misclassifying fork/exec event stops as syscall stops or signal-delivery stops",
        "Options set on the initial tracee must propagate automatically to all forked descendants so that grandchildren of the initial child are also traced without additional PTRACE_SETOPTIONS calls"
      ]
    },
    {
      "milestone_id": "build-strace-m4",
      "criteria": [
        "Parse -e trace=name,name,... flag using getopt(); resolve each name to a syscall number at parse time using reverse lookup of syscall_names[]; unknown names produce a warning but do not abort",
        "Apply the filter in print_syscall() only: unmatched syscalls skip the fprintf output but still call stats_record() and still participate in the entry/exit toggle cycle",
        "Record CLOCK_MONOTONIC timestamp (struct timespec) in ProcessState.entry_time immediately after PTRACE_GETREGS on every entry stop, before any I/O operations",
        "Compute elapsed nanoseconds as (exit_tv_sec - entry_tv_sec)*1e9 + (exit_tv_nsec - entry_tv_nsec) using signed arithmetic to detect pathological negative values",
        "Maintain a SyscallStats[336] array with fields total_ns (long long), call_count (long), error_count (long); call stats_record() on every exit stop regardless of filter state",
        "Detect error returns in stats_record() using the x86_64 range [-4096, -1] on the signed cast of rax, consistent with the detection used for print output",
        "stats_print() builds an index array of entries with call_count > 0, sorts descending by total_ns using qsort with a comparator accessing the global stats array, then prints the header, one row per syscall, and a totals footer",
        "Summary table columns: % time (2 decimal places), seconds (6 decimal places), usecs/call (integer), calls (integer), errors (integer), syscall name; total row shows grand totals with 100.00% time",
        "Support -o filename flag via getopt(); open file with fopen(filename, 'w') and assign to trace_out global; if flag absent, trace_out = stderr; close file at exit; summary always prints to stderr",
        "Support -c flag that suppresses per-syscall line output (only accumulates statistics) and prints the summary table to stderr on exit",
        "Implement attach_to_process(pid_t pid) that calls ptrace(PTRACE_ATTACH, pid, NULL, NULL), then waitpid(pid, &status, 0) to confirm SIGSTOP receipt, then ptrace(PTRACE_SETOPTIONS) with the full option set including TRACESYSGOOD and all fork-following flags",
        "Handle PTRACE_ATTACH permission failure (EPERM) with an informative message explaining ptrace_scope and suggesting solutions",
        "Install SIGINT handler using sigaction() with SA_RESTART not set, so waitpid() returns EINTR when interrupted; handler sets only a volatile sig_atomic_t flag and nothing else",
        "In the main loop, check g_interrupted after each waitpid() return (including EINTR path); if set and g_attached_pid != 0, send SIGSTOP to the attached process, waitpid() for the stop, call ptrace(PTRACE_DETACH, ...), then print the summary and exit",
        "If the tracer forked the tracee (not PTRACE_ATTACH mode), SIGINT does not call PTRACE_DETACH; instead print the summary and let normal process-group signal delivery terminate the children",
        "The tracing event loop uses waitpid(-1, ...) and dispatches by returned PID to per-PID ProcessState exactly as in Milestone 3; timing and statistics integrate into the existing exit-stop handler path without restructuring the loop"
      ]
    }
  ],
  "explained_concepts": [],
  "system_diagram_d2": null,
  "system_diagram_iteration": 0,
  "system_diagram_done": false,
  "project_structure_md": "",
  "project_charter_md": ""
}