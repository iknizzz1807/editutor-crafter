direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SATELLITE CONTEXT: Milestone 1 - Syscall Interception
# This diagram acts as the blueprint for implementing kernel error interpretation on x86_64.

layer_source: {
  direction: down
  label: "KERNEL SPACE / CPU REGISTERS"

  regs: {
    shape: sql_table
    label: "struct user_regs_struct (sys/user.h)"
    
    r15: "0x00 | uint64_t | r15"
    r14: "0x08 | uint64_t | r14"
    "dots_1": "..."
    orig_rax: "0x78 | uint64_t | orig_rax (Syscall Number)"
    rax: "0x80 | uint64_t | rax (Return Value / Result)" {
      style: {
        stroke: "#3f87a6"
        stroke-width: 4
      }
    }
    label_bottom: "Total Size: 216 Bytes (Registers @ Syscall Exit)"
  }
}

layer_logic: {
  direction: down
  label: "TRACER INTERPRETATION LOGIC (main.c)"

  decoder: {
    shape: class
    label: "Syscall Result Interpreter"
    
    implementation: |md
      c
      // 1. Essential cast to signed type
      // raw_rax: 0xfffffffffffffffe
      long ret = (long)regs.rax; 

      // 2. Linux x86_64 ABI Error Range check
      // Kernel reserves the last 4096 values for errors
      if (ret >= -4096L && ret <= -1L) {
          // 3. Transformation to userspace errno
          int err_num = (int)(-ret);
          const char* name = strerrorname_np(err_num);
          printf("-1 %s (%s)\n", name, strerror(err_num));
      } else {
          // Success: rax contains result or address
          printf("%ld\n", ret);
      }
      
    |
  }
  
  error_boundary: {
    shape: rectangle
    label: "ABI Boundary: Error vs Success"
    tooltip: "Linux Kernel x86_64 Syscall Calling Convention"
    
    range: "Valid Error Range: [-4096, -1]" {
      style: {
        fill: "#ff9999"
        stroke: red
      }
    }
    threshold: "Threshold: 0xFFFFFFFFFFFFF000"
  }
}

layer_metadata: {
  direction: down
  label: "LINUX KERNEL METADATA"

  errno_table: {
    shape: sql_table
    label: "Errno Mapping (errno-base.h)"
    
    e1: "1  | EPERM   | Operation not permitted"
    e2: "2  | ENOENT  | No such file or directory"
    e5: "5  | EIO     | I/O error"
    e9: "9  | EBADF   | Bad file descriptor"
    e12: "12 | ENOMEM  | Out of memory"
    e13: "13 | EACCES  | Permission denied"
    e22: "22 | EINVAL  | Invalid argument"
    "dots_2": "... | ... | ..."
    e4095: "4095 | EHWPOISON | Memory page corrupted"
  }
}

layer_data_walk: {
  direction: down
  label: "DATA TRANSFORMATION WALK"

  error_walk: {
    label: "WALK: Open(non_existent_file)"
    style.stroke: red
    
    step1: "1. Raw Bits: 0xFFFFFFFFFFFFFFFE"
    step2: "2. Signed Long: -2"
    step3: "3. Check: -2 is in [-4096, -1]"
    step4: "4. Result: |-(-2)| = 2 -> ENOENT"
  }

  success_walk: {
    label: "WALK: mmap(0, 4096, ...)"
    style.stroke: green
    
    step1: "1. Raw Bits: 0x00007f12ab312000"
    step2: "2. Signed Long: 139718228156416"
    step3: "3. Check: Not in range"
    step4: "4. Result: Raw Address Returned"
  }
}

# Execution Flow (Data Walk)
layer_source.regs.rax -> layer_logic.decoder: "uint64_t | 8 bytes | 0xFFFFFFFFFFFFFFFE" {
  style: {
    stroke: blue
    animated: true
  }
}

layer_logic.decoder -> layer_metadata.errno_table: "Lookup: 2" {
  style.stroke-dash: 3
}

layer_metadata.errno_table -> layer_data_walk.error_walk: "Status: ENOENT"

layer_logic.error_boundary -> layer_logic.decoder: "Guard Conditions" {
  style.stroke: purple
}

layer_data_walk.error_walk -> output: "output | string | \"-1 ENOENT (No such file...)\""
layer_data_walk.success_walk -> output: "output | string | \"139718228156416\""

output: {
  shape: code
  label: "Tracer Output"
}