direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- PROCESS 1: TRACER (STRACE CLONE) ---
tracer: {
  label: "Tracer Process (pid 100)"
  direction: down
  
  stack: {
    shape: sql_table
    label: "Process Address Space (tracer_vm)"
    row1: "0x7ffd1234 | uint64_t | 0xDEADBEEF"
    row2: "..."
    label_bottom: "Virtual Address 0x7ffd1234 maps to physical 0x8b7000"
  }

  code: |md
    c
    // tracer.c
    long word;
    errno = 0;
    word = ptrace(PTRACE_PEEKDATA, 200, 0x7ffd1234, NULL);
    if (word == -1 && errno != 0) perror("peek");
    
  |
  
  regs: {
    shape: class
    label: "CPU Registers (Tracer Context)"
    cr3: "0xAAA000 (Tracer Page Dir)"
    rax: "PTRACE_PEEKDATA (0x10)"
    rdi: "200 (Tracee PID)"
    rsi: "0x7ffd1234 (Remote VA)"
  }
}

# --- LAYER 2: KERNEL SPACE (THE BRIDGE) ---
kernel: {
  label: "Linux Kernel"
  direction: down
  style.fill: "#DEE1EB"

  ptrace_logic: {
    label: "arch/x86/kernel/ptrace.c"
    
    walk: |md
      c
      // access_process_vm() walk
      1. target_mm = find_task_by_vpid(200)->mm;
      2. pgd = pgd_offset(target_mm, 0x7ffd1234);
      3. p4d = p4d_offset(pgd, addr);
      4. pud = pud_offset(p4d, addr);
      5. pmd = pmd_offset(pud, addr);
      6. pte = pte_offset_map(pmd, addr);
      7. paddr = pte_pfn(*pte) << PAGE_SHIFT;
      
    |
  }

  mem_copy: {
    shape: rectangle
    label: "Physical Read"
    definition: "data = *(void*)(phys_to_virt(0x1a3000) + offset)"
  }
}

# --- PROCESS 2: TRACEE (TARGET) ---
tracee: {
  label: "Tracee Process (pid 200)"
  direction: down

  stack: {
    shape: sql_table
    label: "Process Address Space (tracee_vm)"
    row1: "0x7ffd1234 | char[8] | '/etc/pas'"
    row2: "0x7ffd123c | char[8] | 'swd\\0...' "
    label_bottom: "Virtual Address 0x7ffd1234 maps to physical 0x1a3000"
  }
  
  mm_struct: {
    shape: class
    label: "struct mm_struct (kernel-side)"
    pgd: "0xBBB000 (Tracee Page Dir)"
    map_count: "42"
    mmap_base: "0x7f..."
  }
}

# --- PHYSICAL MEMORY ---
ram: {
  label: "Physical RAM"
  direction: right
  
  page_1: {
    shape: sql_table
    label: "Page 0x1a3000 (Tracee Data)"
    r1: "0x00 | 2f 65 74 63 2f 70 61 73 | '/etc/pas'"
    r2: "0x08 | 73 77 64 00 ...        | 'swd\0...'"
  }

  page_2: {
    shape: sql_table
    label: "Page 0x8b7000 (Tracer Data)"
    r1: "0x00 | ef be ad de ...        | 0xDEADBEEF"
  }
}

# --- FLOWS ---

# 1. Tracer calls syscall
tracer.code -> kernel.ptrace_logic: "ptrace(PEEKDATA, 200, 0x7ffd1234)" {
  style.stroke: blue
  label: "long | 8 bytes | Syscall Entry"
}

# 2. Kernel ignores Tracer CR3, uses Tracee MM
kernel.ptrace_logic -> tracee.mm_struct: "1. Switch to Tracee MM context"
tracee.mm_struct -> ram.page_1: "2. Resolve VA 0x7ffd1234 to PA 0x1a3000" {
  style.stroke-dash: 3
}

# 3. Kernel reads from physical RAM
ram.page_1 -> kernel.mem_copy: "3. Read 8 bytes" {
  style.stroke: purple
}

# 4. Kernel returns data to Tracer
kernel.mem_copy -> tracer.regs.rax: "4. Return data via RAX" {
  style.stroke: green
  label: "0x7361702f6374652f"
}

# 5. Visual isolation marker
tracer.stack.row1 -- tracee.stack.row1: "SAME VIRTUAL ADDRESS\nDIFFERENT PHYSICAL PAGES" {
  style.stroke: red
  source-arrowhead: diamond
  target-arrowhead: diamond
}

# Annotations
legend: {
  near: bottom-right
  note: "Each process has an independent CR3 / Page Table root."
  timing: "Cost: ~2,500 cycles (Full context switch + PT walk)"
}