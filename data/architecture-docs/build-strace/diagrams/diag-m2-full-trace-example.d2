direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# L0: Complete Trace of open() - Entry to Exit
# This diagram tracks the data transformation from raw registers to formatted log.

# LAYER 1: SYSCALL ENTRY
entry_phase: {
  label: "PHASE 1: SYSCALL_ENTRY STOP"
  direction: down

  wait_event: {
    shape: code
    label: "waitpid(-1, &status, 0)"
    status: "0x8505 | WIFSTOPPED | SIGTRAP | 0x80"
  }

  state_entry: {
    shape: sql_table
    label: "struct ProcessState (tracer.h)"
    row1: "0x00 | pid_t | pid: 1234"
    row2: "0x04 | int   | in_syscall: 0 (ENTRY)"
    row3: "0x08 | regs  | entry_regs (empty)"
    label_bottom: "Total: 248 bytes"
  }

  regs_snapshot: {
    shape: sql_table
    label: "struct user_regs_struct (sys/user.h)"
    orig_rax: "0x80 | uint64 | orig_rax: 2 (open)"
    rdi:      "0x68 | uint64 | rdi: 0x7ffd1234"
    rsi:      "0x70 | uint64 | rsi: 0 (O_RDONLY)"
    rdx:      "0x78 | uint64 | rdx: 0"
    label_bottom: "PTRACE_GETREGS Snapshot"
  }

  wait_event -> state_entry: "Lookup PID 1234"
  state_entry -> regs_snapshot: "PTRACE_GETREGS"
}

# LAYER 2: DECODING ENGINE
decoding_engine: {
  label: "PHASE 2: ARGUMENT RESOLUTION"
  direction: down

  table_lookup: {
    shape: sql_table
    label: "SyscallDesc[2] (table.c)"
    name: "name: 'open'"
    n_args: "num_args: 3"
    t1: "arg_types[0]: ARG_STR"
    t2: "arg_types[1]: ARG_OPEN_FLAGS"
    t3: "arg_types[2]: ARG_UINT"
  }

  peek_logic: {
    label: "read_tracee_string (mem.c)"
    direction: right
    
    ptr: "Pointer: 0x7ffd1234"
    ptr -> kernel: "PTRACE_PEEKDATA"
    kernel: {
      label: "Kernel VM Read"
      shape: cylinder
    }
    kernel -> buffer: "8 bytes | '/etc/pas'"
    buffer: "Result: \"/etc/passwd\""
  }

  flag_logic: {
    label: "decode_flags (flags.c)"
    input: "Value: 0"
    input -> mapping: "Match table[0]"
    mapping: "Result: \"O_RDONLY\""
  }

  entry_phase.regs_snapshot -> table_lookup: "orig_rax=2"
  table_lookup -> peek_logic: "Resolve ARG_STR"
  table_lookup -> flag_logic: "Resolve OPEN_FLAGS"
}

# LAYER 3: SYSCALL EXIT
exit_phase: {
  label: "PHASE 3: SYSCALL_EXIT STOP"
  direction: down

  resume: {
    shape: code
    label: "ptrace(PTRACE_SYSCALL, 1234, ...)"
  }

  wait_exit: {
    shape: code
    label: "waitpid(1234, &status, 0)"
    status: "0x8505 | in_syscall: 1 (EXIT)"
  }

  rax_read: {
    shape: sql_table
    label: "Registers at Exit"
    rax: "0x00 | uint64 | rax: 3 (FD)"
  }

  final_output: {
    shape: code
    label: "fprintf(trace_out, ...)"
    content: |md
      c
      [pid 1234] open("/etc/passwd", O_RDONLY) = 3
      
    |
  }

  resume -> wait_exit: "Process Executes"
  wait_exit -> rax_read: "PTRACE_GETREGS"
  rax_read -> final_output: "Assemble Components"
}

# Global Flow
entry_phase -> decoding_engine: "Cached Entry State"
decoding_engine -> exit_phase: "Formatted Arguments"

# Styling
entry_phase.state_entry.row2.style.fill: "#fff3cd"
exit_phase.wait_exit.style.fill: "#d1ecf1"
exit_phase.final_output.style.stroke: "#28a745"
exit_phase.final_output.style.stroke-width: 3

decoding_engine.peek_logic.kernel.style.fill: "#e2e3e5"
decoding_engine.peek_logic.buffer.style.font-color: "#004085"