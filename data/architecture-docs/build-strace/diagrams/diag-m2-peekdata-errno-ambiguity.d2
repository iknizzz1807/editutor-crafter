direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- LEGEND / GLOBAL CONTEXT ---
explanation: |md
  ### The PTRACE_PEEKDATA Ambiguity (L1 Detail)
  `PTRACE_PEEKDATA` returns a `long` (8 bytes). If the read fails, it returns `-1`.
  However, `0xFFFFFFFFFFFFFFFF` (-1) is also a valid bit pattern in tracee memory.
  **Code Standard:** Must differentiate between "Data is -1" and "Call Failed".
| {
  near: top-center
  shape: text
}

ptrace_api: {
  shape: class
  label: "ptrace(2) Interface (sys/ptrace.h)"
  definition: |md
    c
    long ptrace(enum __ptrace_request request, 
                pid_t pid, 
                void *addr, 
                void *data);
    
  |
  near: top-left
}

# --- BEFORE: NAIVE IMPLEMENTATION (FAILING CASE) ---
before: {
  label: "NAIVE IMPLEMENTATION (tracer_v1.c)"
  direction: down
  style: {
    fill: "#fff5f5"
    stroke: "#ff4d4f"
    stroke-width: 2
  }

  tracee_mem: {
    shape: sql_table
    label: "Tracee Virtual Address Space"
    row1: "0x7ffffffee120 | 0xFFFFFFFFFFFFFFFF | (Valid Application Data)"
    label_bottom: "Region: [Stack]"
  }

  logic: |md
    c
    // DANGEROUS: Ambiguous check
    long data = ptrace(PTRACE_PEEKDATA, pid, addr, NULL);

    if (data == -1) {
        perror("ptrace"); // Falsely triggers on valid -1 data!
        exit(1);
    }
    
  |

  outcome: {
    label: "CRASH: False Positive"
    shape: rectangle
    style: {
      fill: "#ff4d4f"
      font-color: white
      bold: true
      shadow: true
    }
  }

  tracee_mem -> logic: "DataType: long | 8B | -1L"
  logic -> outcome: "Result: (data == -1) is TRUE"
}

# --- AFTER: ROBUST IMPLEMENTATION (PRODUCTION READY) ---
after: {
  label: "ROBUST IMPLEMENTATION (tracer_v2.c)"
  direction: down
  style: {
    fill: "#f6ffed"
    stroke: "#52c41a"
    stroke-width: 2
  }

  code: |md
    c
    // CORRECT: Clear errno before call
    errno = 0; 
    long data = ptrace(PTRACE_PEEKDATA, pid, addr, NULL);

    // Double-gated check
    if (data == -1 && errno != 0) {
        perror("ptrace"); // Actual kernel error (e.g. EIO)
        return -1;
    }
    // SUCCESS: 'data' is valid even if pattern is 0xFF...F
    
  |

  decision_matrix: {
    shape: sql_table
    label: "Kernel State Decoding Matrix"
    h: "ptrace() return | errno value | Interpretation"
    c1: "0x0000...1234  | (any)       | SUCCESS: Data is 0x1234"
    c2: "-1 (0xFF...F)  | 0           | SUCCESS: Data is -1 (Literal)"
    c3: "-1 (0xFF...F)  | EIO (5)     | ERROR: Unmapped / Access Denied"
    
    style: {
      stroke: "#52c41a"
      fill: "#ffffff"
    }
  }

  code -> decision_matrix: "errno validation path"
}

# --- DATA STRUCTURES & OFFSETS ---
memory_word: {
  shape: sql_table
  label: "x86_64 Machine Word (8 Bytes)"
  b0: "0x00 | uint8_t | Byte 0 (LSB) | 0xFF"
  b1: "0x01 | uint8_t | Byte 1       | 0xFF"
  b2: "0x02 | uint8_t | Byte 2       | 0xFF"
  b3: "0x03 | uint8_t | Byte 3       | 0xFF"
  b4: "0x04 | uint8_t | Byte 4       | 0xFF"
  b5: "0x05 | uint8_t | Byte 5       | 0xFF"
  b6: "0x06 | uint8_t | Byte 6       | 0xFF"
  b7: "0x07 | uint8_t | Byte 7 (MSB) | 0xFF"
  label_bottom: "Total: 64-bit Signed long"
  near: bottom-right
}

# --- GLOBAL FLOW ---
before -> after: "Evolution: Error handling logic fix" {
  style: {
    stroke-width: 4
    animated: true
    stroke: "#1890ff"
  }
}

after.decision_matrix -> memory_word: "Refers to pattern" {
  style.stroke-dash: 3
}