direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- 1. DEFINITIONS LAYER ---
definitions: {
  direction: down
  label: "SYSTEM DEFINITIONS (syscall_types.h)"

  types: {
    shape: sql_table
    label: "enum ArgType"
    
    0x00: "ARG_INT         | Signed decimal (int)"
    0x01: "ARG_UINT        | Unsigned decimal (uint32_t)"
    0x02: "ARG_HEX         | Hexadecimal (uint64_t)"
    0x03: "ARG_STR         | Tracee String (char* / PEEKDATA)"
    0x04: "ARG_PTR         | Hex Pointer (void*) / NULL"
    0x05: "ARG_OPEN_FLAGS  | Bitmask (O_RDONLY...)"
    0x06: "ARG_MMAP_PROT   | Bitmask (PROT_READ...)"
    0x07: "ARG_MMAP_FLAGS  | Bitmask (MAP_PRIVATE...)"
    0x08: "ARG_IGNORE      | No-op / Reserved"
    
    label_bottom: "Underlying: uint8_t"
  }

  syscall_desc_struct: {
    shape: sql_table
    label: "struct SyscallDesc"
    
    row1: "0x00 | int         | num_args"
    row2: "0x04 | ArgType[6]  | arg_types"
    row3: "0x0A | uint16_t    | padding"
    row4: "0x10 | const char* | name"
    
    label_bottom: "Total: 24 bytes (x86_64 aligned)"
  }
}

# --- 2. STATIC STORAGE LAYER ---
table_layer: {
  direction: down
  label: "SYSCALL DISPATCH TABLE"

  syscall_table: {
    shape: sql_table
    label: "const struct SyscallDesc desc_table[] (syscall_desc.c)"
    
    idx0: "0 | 'read'  | 3 | {ARG_INT, ARG_PTR, ARG_UINT, ...}"
    idx1: "1 | 'write' | 3 | {ARG_INT, ARG_STR, ARG_UINT, ...}"
    idx2: "2 | 'open'  | 3 | {ARG_STR, ARG_OPEN_FLAGS, ARG_UINT, ...}"
    idx3: "3 | 'close' | 1 | {ARG_INT, ARG_IGNORE, ...}"
    idx9: "9 | 'mmap'  | 6 | {ARG_PTR, ARG_UINT, ARG_MMAP_PROT, ...}"
    
    label_bottom: "Global Table: 335 entries | Size: ~8KB"
  }
}

# --- 3. PROCESSING LAYER ---
decoder_layer: {
  direction: down
  label: "DECODER LOGIC (decoder.c)"

  decoder: {
    shape: class
    label: "ArgumentDecoder"
    
    fields: |md
      c
      pid_t target_pid;
      ProcessState *state;
      
    |
    
    methods: |md
      c
      void decode_args(pid_t pid, ProcessState *state);
      static uint64_t get_reg_by_idx(int idx, struct user_regs_struct *regs);
      void dispatch_render(pid_t pid, uint64_t val, ArgType t);
      
    |
  }

  logic_flow: {
    shape: code
    language: c
    value: |c
      void decode_args(pid_t pid, ProcessState *state) {
          long rax = state->regs.orig_rax;
          const SyscallDesc *d = &desc_table[rax];
          
          for (int i = 0; i < d->num_args; i++) {
              ArgType t = d->arg_types[i];
              uint64_t val = get_reg_by_idx(i, &state->regs);
              dispatch_render(pid, val, t);
          }
      }
    |
  }
}

# --- 4. HARDWARE ABSTRACTION ---
hardware_layer: {
  direction: down
  label: "CPU REGISTER STATE"

  abi_mapping: {
    shape: sql_table
    label: "Register Mapping (x86_64)"
    arg0: "0 | RDI"
    arg1: "1 | RSI"
    arg2: "2 | RDX"
    arg3: "3 | R10 (N.B. not RCX)"
    arg4: "4 | R8"
    arg5: "5 | R9"
  }

  note_alignment: "Architecture: x86_64\nCalling Convention: Syscall ABI\nNote: R10 replaces RCX for kernel entries" {
    shape: rectangle
    style: {
      fill: "#FFF9C9"
      stroke-dash: 2
    }
  }
}

# --- DATA FLOW & RELATIONSHIPS ---

# Decoder fetching metadata from Table
decoder_layer.decoder -> table_layer.syscall_table: "uint64_t | 8B | rax=9"
table_layer.syscall_table -> decoder_layer.decoder: "SyscallDesc | 24B | {6, [...], 'mmap'}"

# Decoder using Enum definitions for Switch case
decoder_layer.decoder -> definitions.types: "ArgType | 1B | ARG_MMAP_PROT"

# Register Access
decoder_layer.decoder -> hardware_layer.abi_mapping: "get_reg_by_idx(2) -> RDX"

# Structural Flow (Ordering)
definitions -> table_layer -> decoder_layer -> hardware_layer: "Implementation Hierarchy" {
  style.stroke-dash: 5
  style.opacity: 0.3
}

# Complex flow for memory maps
table_layer.syscall_table.idx9 -> decoder_layer.decoder: "MMAP Request | 48B Reg State"