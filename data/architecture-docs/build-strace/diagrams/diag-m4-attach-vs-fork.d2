direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- SATELLITE COMPARISON: ENTRY STRATEGIES ---

fork_traceme: {
  label: "TRACEME Flow (Process Birth)"
  direction: down

  init: {
    shape: class
    label: "Initialization (tracer.c)"
    definition: |md
      c
      pid_t pid = fork();
      if (pid == 0) {
          ptrace(PTRACE_TRACEME, 0, NULL, NULL);
          execvp(argv[1], &argv[1]);
      }
      
    |
  }

  post_exec_stop: {
    shape: rectangle
    label: "Post-Exec Stop (Kernel)"
    tooltip: "Kernel automatically sends SIGTRAP after successful exec of traced process"
    style: {
      fill: "#C7F1FF"
      stroke-dash: 3
    }
  }

  config: {
    shape: sql_table
    label: "State Setup"
    row1: "in_syscall = 0 | Guaranteed start at userspace entry"
    row2: "PTRACE_SETOPTIONS | PTRACE_O_TRACESYSGOOD | PTRACE_O_TRACEFORK"
  }

  loop: {
    shape: circle
    label: "SYSCALL Loop"
  }

  init -> post_exec_stop: "execve() syscall"
  post_exec_stop -> config: "waitpid() returns SIGTRAP"
  config -> loop: "PTRACE_SYSCALL"
}

ptrace_attach: {
  label: "ATTACH Flow (Process Adoption)"
  direction: down

  running_target: {
    shape: rectangle
    label: "Target Process (Already Running)"
    style: {
      fill: "#E4DBFE"
      multiple: true
    }
  }

  attach_call: {
    shape: class
    label: "Attachment (tracer.c)"
    definition: |md
      c
      // Requires CAP_SYS_PTRACE or ptrace_scope=0
      ptrace(PTRACE_ATTACH, target_pid, NULL, NULL);
      
    |
  }

  sigstop_delivery: {
    shape: rectangle
    label: "SIGSTOP Intercept (Kernel)"
    tooltip: "Kernel injects SIGSTOP to freeze target for tracer"
    style: {
      fill: "#FE7070"
      stroke: "#ca052b"
    }
  }

  ack_stop: {
    shape: rectangle
    label: "Wait for SIGSTOP"
    tooltip: "Must call waitpid to acknowledge the attachment stop"
  }

  config: {
    shape: sql_table
    label: "State Setup"
    row1: "in_syscall = ? | Ambiguous: may be mid-syscall"
    row2: "PTRACE_SETOPTIONS | All options set here"
  }

  loop: {
    shape: circle
    label: "SYSCALL Loop"
  }

  cleanup: {
    shape: class
    label: "Detach (tracer.c)"
    definition: |md
      c
      ptrace(PTRACE_DETACH, target_pid, NULL, NULL);
      
    |
  }

  running_target -> attach_call: "-p <pid> flag"
  attach_call -> sigstop_delivery: "PTRACE_ATTACH"
  sigstop_delivery -> ack_stop: "SIGSTOP delivered"
  ack_stop -> config: "waitpid() returns status"
  config -> loop: "PTRACE_SYSCALL"
  loop -> cleanup: "SIGINT / Ctrl+C"
}

# --- SHARED KERNEL DATA STRUCTURES ---

kernel_internals: {
  label: "Kernel task_struct (linux/sched.h)"
  shape: sql_table
  
  field1: "0x... | unsigned int | ptrace"
  field2: "0x... | struct task_struct* | parent (Tracer)"
  field3: "0x... | unsigned long | ptrace_message"
  field4: "0x... | struct user_regs_struct | saved_registers"
  
  label_bottom: "ptrace flags: PT_PTRACED | PT_TRACESYSGOOD"
}

# --- CROSS-FLOW COMPARISON ---

comparison_notes: {
  near: top-center
  shape: text
  label: |md
    ### Implementation Divergence
    - **Fork Path**: Predictable. You control the start. `in_syscall` is always 0.
    - **Attach Path**: Disruptive. Target receives asynchronous `SIGSTOP`.
    - **Permission**: Attach often requires `sudo` or YAMA sysctl tweaks.
  |
}

fork_traceme.post_exec_stop -> kernel_internals: "Set PT_PTRACED"
ptrace_attach.attach_call -> kernel_internals: "Reparent to Tracer"

# --- LEGEND ---
legend: {
  near: bottom-right
  entry_stop: "Syscall Entry/Exit Stop" {
    style.fill: "#C7F1FF"
  }
  signal_stop: "Signal Delivery Stop" {
    style.fill: "#FE7070"
  }
}