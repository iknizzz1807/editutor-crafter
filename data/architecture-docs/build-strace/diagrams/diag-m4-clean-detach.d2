direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# -----------------------------------------------------------------------------
# LAYER 0: SIGNAL CAPTURE & FLAG STATE
# -----------------------------------------------------------------------------
signal_subsystem: {
  label: "SIGNAL SUBSYSTEM (tracer.c)"
  direction: down

  global_state: {
    shape: sql_table
    label: "Global Control State"
    row1: "0x00 | volatile sig_atomic_t | g_interrupted"
    row2: "0x04 | pid_t                | g_attached_pid"
    label_bottom: "Total: 8 bytes (Sync Primitives)"
  }

  handler: {
    label: "SIGINT Handler"
    shape: code
    language: c
    content: |md
      c
      void sigint_handler(int sig) {
          g_interrupted = 1; // Atomic write
      }
      
    |
  }

  signal_input: "User: Ctrl+C (SIGINT)"
  signal_input -> handler: "Asynchronous Trigger"
  handler -> global_state.row1: "Update Flag"
}

# -----------------------------------------------------------------------------
# LAYER 1: MAIN LOOP DETECTION
# -----------------------------------------------------------------------------
event_loop: {
  label: "EVENT LOOP (main.c)"
  direction: down

  wait_call: {
    label: "waitpid() Interruption"
    shape: code
    language: c
    content: |md
      c
      pid_t pid = waitpid(-1, &status, 0);
      if (pid == -1 && errno == EINTR) {
          if (g_interrupted) goto cleanup;
      }
      
    |
  }

  check_flag: {
    shape: diamond
    label: "g_interrupted == 1?"
  }

  wait_call -> check_flag: "errno == EINTR"
}

# -----------------------------------------------------------------------------
# LAYER 2: DETACH STATE MACHINE (L2 DETAIL)
# -----------------------------------------------------------------------------
detach_logic: {
  label: "CLEAN DETACH LOGIC (detach.c)"
  direction: down

  process_state_struct: {
    shape: sql_table
    label: "struct ProcessState (tcb.h)"
    row1: "0x00 | pid_t | pid"
    row2: "0x04 | int   | in_syscall (Toggle)"
    row3: "0x08 | struct user_regs_struct | entry_regs (216B)"
    row4: "0xE0 | struct timespec         | entry_time (16B)"
    row5: "0xF0 | int                     | valid"
    label_bottom: "Total Size: 248 bytes"
  }

  decision_node: {
    shape: diamond
    label: "Tracee Status?"
  }

  path_running: {
    label: "CASES: Tracee is RUNNING"
    direction: down
    
    stop_cmd: {
      label: "Interrupt Tracee"
      content: "|md c\nkill(pid, SIGSTOP);\nwaitpid(pid, &s, 0);\n |"
    }
    
    detach_cmd_1: {
      label: "Detach Ptrace"
      content: "|md c\nptrace(PTRACE_DETACH, pid, 0, 0);\n |"
    }
    
    stop_cmd -> detach_cmd_1: "Wait for SIGSTOP ACK"
  }

  path_stopped: {
    label: "CASE: Tracee is STOPPED"
    direction: down
    
    detach_cmd_2: {
      label: "Immediate Detach"
      content: "|md c\nptrace(PTRACE_DETACH, pid, 0, 0);\n |"
    }
  }

  error_path: {
    label: "INVALID STATE"
    style: {
      stroke: red
      fill: "#ffcccc"
    }
    content: "PTRACE_DETACH on Running -> EIO/ESRCH"
  }

  decision_node -> path_running: "in_syscall == 0\n(Running)"
  decision_node -> path_stopped: "in_syscall == 1\n(At Boundary)"
  path_running -> error_path: "Failure to stop first" {
    style.stroke-dash: 5
  }
}

# -----------------------------------------------------------------------------
# LAYER 3: KERNEL & HARDWARE TRANSITION
# -----------------------------------------------------------------------------
kernel_layer: {
  label: "LINUX KERNEL (task_struct)"
  direction: down

  internal_actions: |md
    - Clear **PT_TRACED** bit
    - Reset **real_parent**
    - Wake up process (SIGCONT)
    - Remove from Tracer's child list
  |

  final_state: {
    shape: circle
    label: "Process resumed\nat full speed"
    style.fill: "#ccffcc"
  }

  internal_actions -> final_state: "Scheduler context switch"
}

# -----------------------------------------------------------------------------
# CONNECTIONS (HORIZONTAL FLOW)
# -----------------------------------------------------------------------------
signal_subsystem -> event_loop: "g_interrupted = 1"
event_loop -> detach_logic: "Invoke handle_interrupt()"
detach_logic -> kernel_layer: "ptrace(PTRACE_DETACH, ...)"

# Annotations
event_loop.wait_call -> detach_logic.process_state_struct: "Iterate State Map"
detach_logic.path_running.detach_cmd_1 -> kernel_layer.internal_actions: "Syscall | 8B | {PTRACE_DETACH}"
detach_logic.path_stopped.detach_cmd_2 -> kernel_layer.internal_actions: "Syscall | 8B | {PTRACE_DETACH}"