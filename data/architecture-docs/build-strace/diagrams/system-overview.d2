direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 3
  }
}
title: |md
  # System Call Tracer (strace clone) — Implementation Blueprint
  x86_64 Linux · C · ptrace-based · 4 Milestones
| {near: top-center}
classes: {
  milestone: {
    style: {
      fill: "#E8F4FD"
      stroke: "#2196F3"
      stroke-width: 2
      border-radius: 6
      bold: true
    }
  }
  struct_box: {
    style: {
      fill: "#FFF8E1"
      stroke: "#F57F17"
      stroke-width: 2
      border-radius: 4
      font: mono
    }
  }
  func_box: {
    style: {
      fill: "#F3E5F5"
      stroke: "#7B1FA2"
      stroke-width: 2
      border-radius: 4
      font: mono
    }
  }
  kernel_box: {
    style: {
      fill: "#E8F5E9"
      stroke: "#2E7D32"
      stroke-width: 2
      border-radius: 4
    }
  }
  data_box: {
    style: {
      fill: "#FCE4EC"
      stroke: "#C62828"
      stroke-width: 2
      border-radius: 4
    }
  }
  hw_box: {
    style: {
      fill: "#EFEBE9"
      stroke: "#4E342E"
      stroke-width: 2
      border-radius: 4
    }
  }
  error_path: {
    style: {
      stroke-dash: 5
      stroke: "#E53935"
    }
  }
}
# ═══════════════════════════════════════════════════
# LAYER 0: MILESTONE INDEX
# ═══════════════════════════════════════════════════
milestones: Milestone Map {
  style: {
    fill: "#E3F2FD"
    stroke: "#1565C0"
    stroke-width: 3
    border-radius: 8
  }
  m1: build-strace-m1\nBasic ptrace Intercept {
    class: milestone
  }
  m2: build-strace-m2\nArgument Decoding {
    class: milestone
  }
  m3: build-strace-m3\nMulti-Process Fork {
    class: milestone
  }
  m4: build-strace-m4\nFiltering + Statistics {
    class: milestone
  }
  m1 -> m2: extends
  m2 -> m3: extends
  m3 -> m4: extends
}
# ═══════════════════════════════════════════════════
# LAYER 1: TRACER PROCESS (USER SPACE)
# ═══════════════════════════════════════════════════
tracer: TRACER PROCESS (main.c) {
  style: {
    fill: "#E8EAF6"
    stroke: "#283593"
    stroke-width: 3
    border-radius: 8
  }
  # ── M1: Core Lifecycle ──
  lifecycle: M1 · ptrace Lifecycle (main.c) {
    style: {
      fill: "#C5CAE9"
      stroke: "#3949AB"
      border-radius: 6
    }
    fork_exec: fork() + PTRACE_TRACEME + execvp() {
      class: func_box
      label: |c
        pid_t child = fork();
        // child:
        ptrace(PTRACE_TRACEME,0,NULL,NULL);
        execvp(argv[1], &argv[1]);
        // parent:
        waitpid(child, &status, 0);
      |
    }
    setopts: PTRACE_SETOPTIONS {
      class: func_box
      label: |c
        long opts =
          PTRACE_O_TRACESYSGOOD   // bit7 on syscall stops
          | PTRACE_O_TRACEFORK    // M3
          | PTRACE_O_TRACEVFORK   // M3
          | PTRACE_O_TRACECLONE   // M3
          | PTRACE_O_TRACEEXEC;   // M3
        ptrace(PTRACE_SETOPTIONS,
               child, NULL, opts);
      |
    }
    loop: PTRACE_SYSCALL + waitpid(-1) Loop {
      class: func_box
      label: |c
        // M1: waitpid(child,&st,0)
        // M3: waitpid(-1,&st,0)  ← any child
        ptrace(PTRACE_SYSCALL,pid,NULL,sig);
        pid_t stopped=waitpid(-1,&st,0);
      |
    }
    fork_exec -> setopts: "post-exec\nSIGTRAP"
    setopts -> loop: "start tracing"
  }
  # ── M1: Toggle State Machine ──
  toggle: M1 · Entry/Exit Toggle (main.c) {
    style: {
      fill: "#BBDEFB"
      stroke: "#1565C0"
      border-radius: 6
    }
    entry_state: ENTRY STOP\nin_syscall=0 {
      class: kernel_box
      label: |c
        // sig==(SIGTRAP|0x80)
        // Read orig_rax=syscall#
        // Save entry_regs snapshot
        state->entry_regs = regs;
        clock_gettime(MONO,         // M4
          &state->entry_time);
        state->in_syscall = 1;
      |
    }
    exit_state: EXIT STOP\nin_syscall=1 {
      class: kernel_box
      label: |c
        // rax = return value
        // orig_rax still valid
        long ret=(long)regs.rax;
        // Error: ret in [-4096,-1]
        // M4: compute delta_ns
        stats_record(num,ns,err); // M4
        print_syscall(pid,&entry, // M2
                      ret, out);
        state->in_syscall = 0;
      |
    }
    entry_state -> exit_state: "PTRACE_SYSCALL\nresume | kernel\nexecutes syscall"
    exit_state -> entry_state: "PTRACE_SYSCALL\nnext entry"
  }
  # ── M1: waitpid Status Decode ──
  status_decode: M1 · waitpid Status Decoder {
    style: {
      fill: "#DCEDC8"
      stroke: "#33691E"
      border-radius: 6
    }
    wifexited: WIFEXITED(st)\nbits[7:0]==0 {
      style: { fill: "#F1F8E9"; stroke: "#558B2F"; border-radius: 4 }
      label: |c
        WEXITSTATUS(st)
        → exit code
        active_count--  // M3
        state_map_remove(pid) // M3
      |
    }
    wifsignaled: WIFSIGNALED(st)\nbits[6:0]!=0,bit7==0 {
      style: { fill: "#F1F8E9"; stroke: "#558B2F"; border-radius: 4 }
      label: |c
        WTERMSIG(st)
        → killing signal#
        active_count--  // M3
      |
    }
    wifstopped: WIFSTOPPED(st)\nbits[7:0]==0x7F {
      style: { fill: "#F1F8E9"; stroke: "#558B2F"; border-radius: 4 }
      label: |c
        sig=WSTOPSIG(st) // bits[15:8]
        event=(st>>16)&0xFF // M3
        // SIGTRAP|0x80 → syscall stop
        // event!=0 → fork/exec/etc
        // plain sig → re-inject
      |
    }
    wifexited -> wifsignaled: "status\nbitmask"
    wifsignaled -> wifstopped: "status\nbitmask"
  }
  lifecycle -> toggle: "initial stop\nhandled"
  toggle -> status_decode: "status word\nrouting"
}
# ═══════════════════════════════════════════════════
# LAYER 2: DATA STRUCTURES
# ═══════════════════════════════════════════════════
data_structures: DATA STRUCTURES {
  style: {
    fill: "#FFF3E0"
    stroke: "#E65100"
    stroke-width: 3
    border-radius: 8
  }
  # ── ProcessState ──
  proc_state: ProcessState (state_map.h) · 248 bytes {
    class: struct_box
    label: |c
      typedef struct {
        // Offset 0x00 │ 4B
        pid_t  pid;
        // Offset 0x04 │ 4B
        int    in_syscall;   // toggle 0=entry,1=exit
        // Offset 0x08 │ 216B  (≈3.5 cache lines @ 64B)
        struct user_regs_struct entry_regs;
        //   └─ orig_rax (syscall#), rax (retval)
        //   └─ rdi,rsi,rdx,r10,r8,r9 (args 1-6)
        // Offset 0xE0 │ 16B  (M4)
        struct timespec entry_time; // CLOCK_MONOTONIC
        // Offset 0xF0 │ 4B
        int    valid;  // 0=empty,-1=tombstone,1=active
        // Offset 0xF4 │ 12B padding → total 256B (4 cache lines)
        uint8_t pad[12];
      } ProcessState;
    |
  }
  # ── Hash Map ──
  hash_map: state_map[256] (state_map.c)\n64KB total · fits L2 cache {
    class: struct_box
    label: |c
      #define STATE_MAP_SIZE 256   // power of 2
      #define STATE_MAP_MASK 0xFF
      ProcessState state_map[256]; // 256×248B=63,488B
      // Hash: pid & 0xFF  → O(1) avg
      // Linear probing on collision
      // Tombstone on remove (valid=-1)
      ProcessState* state_map_find(pid_t pid);
      ProcessState* state_map_insert(pid_t pid);
      void          state_map_remove(pid_t pid);
    |
  }
  # ── SyscallStats ──
  stats_arr: SyscallStats[336] (stats.c)\n8,064B · fits L1 cache (32KB) {
    class: data_box
    label: |c
      typedef struct {
        // Offset 0x00 │ 8B
        int64_t total_ns;    // cumulative nanoseconds
        // Offset 0x08 │ 8B
        long    call_count;
        // Offset 0x10 │ 8B
        long    error_count; // ret in [-4096,-1]
      } SyscallStats;        // 24B per entry
      // 336 × 24B = 8,064B
      void stats_record(long num, long long ns, int err);
      void stats_print(FILE *out);  // qsort by total_ns desc
    |
  }
  # ── TracerOptions ──
  options: TracerOptions (options.h) · 40 bytes {
    class: struct_box
    label: |c
      typedef struct {
        // 8B each (pointer/pid_t/int)
        const char *output_file;  // -o filename
        const char *filter_spec;  // -e trace=...
        pid_t       attach_pid;   // -p PID (0=fork mode)
        int         summary_mode; // -c flag
        char      **target_argv;  // program + args
      } TracerOptions;
      TracerOptions parse_options(int argc, char *argv[]);
      // uses getopt(argc,argv,"o:e:p:c")
    |
  }
  proc_state -> hash_map: "256 slots\nopen-addressing"
}
# ═══════════════════════════════════════════════════
# LAYER 3: M2 — ARGUMENT DECODING
# ═══════════════════════════════════════════════════
arg_decode: M2 · ARGUMENT DECODING {
  style: {
    fill: "#F3E5F5"
    stroke: "#6A1B9A"
    stroke-width: 3
    border-radius: 8
  }
  # ── Register Map ──
  reg_map: x86_64 Syscall ABI Register Map {
    class: hw_box
    label: |c
      struct user_regs_struct regs;   // 216B from <sys/user.h>
      // SYSCALL NUMBER (entry & exit):
      long syscall_num = (long)regs.orig_rax;
      // RETURN VALUE (exit only):
      long ret_val     = (long)regs.rax;  // cast unsigned→signed!
      // ARGUMENTS (entry only — save snapshot!):
      unsigned long long args[6] = {
        regs.rdi,   // arg 1
        regs.rsi,   // arg 2
        regs.rdx,   // arg 3
        regs.r10,   // arg 4  ← r10 not rcx (clobbered by syscall insn)
        regs.r8,    // arg 5
        regs.r9     // arg 6
      };
    |
  }
  # ── Syscall Table ──
  syscall_table: syscall_names[] + SyscallDesc[] (syscall_data.c)\nMAX_SYSCALL_NUM=335 {
    class: struct_box
    label: |c
      // C99 designated-init sparse array:
      const char *syscall_names[336] = {
        [0]="read", [1]="write", [2]="open",
        [9]="mmap",  [57]="fork", [59]="execve",
        [60]="exit", [231]="exit_group",
        [257]="openat", /* ... 335 entries */ };
      typedef struct {
        const char *name;
        int         num_args;    // 0..6
        ArgType     arg_types[6];
      } SyscallDesc;
      // ArgType enum:
      // ARG_INT, ARG_UINT, ARG_HEX,
      // ARG_STR, ARG_PTR,
      // ARG_OPEN_FLAGS, ARG_MMAP_PROT,
      // ARG_MMAP_FLAGS, ARG_IGNORE
      const char* syscall_name(long num);     // O(1) array lookup
      int  syscall_num_by_name(const char*);  // O(n) linear scan (startup only)
    |
  }
  # ── PEEKDATA ──
  peekdata: PTRACE_PEEKDATA Word-Walker (mem_reader.c)\nVirtual Address Space Isolation {
    class: func_box
    label: |c
      // WHY: tracee ptr invalid in tracer's CR3/page-table
      // reads 8 bytes/call ≈ 1,500 cycles (TLB miss possible)
      int read_tracee_string(
          pid_t pid,
          unsigned long addr,  // tracee virtual addr
          char *buf,
          int maxlen,          // default 32B truncation
          int *truncated)
      {
        while (i < maxlen) {
          errno = 0;           // MUST clear before call
          long word = ptrace(PTRACE_PEEKDATA,
                             pid,(void*)addr,NULL);
          if (word==-1 && errno!=0) break; // error vs valid -1!
          unsigned char *b=(unsigned char*)&word;
          for(int j=0;j<8;j++){    // little-endian scan
            if(!b[j]){buf[i]=0; return 0;}
            buf[i++]=b[j];
          }
          addr += 8;           // advance one word
        }
        buf[i]=0; *truncated=(i>=maxlen); return 0;
      }
      // Cost: 1 syscall per 8B → 32B path = 4 calls = ~6,000 cycles
    |
  }
  # ── Flag Decode ──
  flag_decode: Flag Bitmask Decoder (formatter.c) {
    class: func_box
    label: |c
      typedef struct { unsigned long value; const char *name; } FlagEntry;
      static const FlagEntry open_flags[] = {
        {O_WRONLY,"O_WRONLY"},{O_RDWR,"O_RDWR"},
        {O_CREAT,"O_CREAT"},{O_EXCL,"O_EXCL"},
        {O_TRUNC,"O_TRUNC"},{O_APPEND,"O_APPEND"},
        {O_CLOEXEC,"O_CLOEXEC"},{O_DIRECTORY,"O_DIRECTORY"},
        {0,NULL} /* sentinel */
      };
      // EDGE CASE: O_RDONLY==0 → if(val==0) printf("O_RDONLY")
      // EDGE CASE: PROT_NONE==0 → same pattern
      void decode_flags(unsigned long val,
                        const FlagEntry *tbl,
                        char *out, int bufsz);
      // Output: "O_RDONLY|O_CLOEXEC" or "0x80" for unknown bits
    |
  }
  # ── Error Detection ──
  err_detect: Error Return Detection (main.c) {
    class: data_box
    label: |c
      // x86_64 kernel error convention:
      // return value in [-4096, -1] = error
      long ret = (long)regs.rax;  // MUST cast unsigned→signed
      if (ret >= -4096L && ret <= -1L) {
        int errnum = (int)(-ret);
        // printf("= -1 ENOENT (No such file or directory)")
        strerrorname_np(errnum); // glibc>=2.32
        strerror(errnum);
      }
      // Why -4096: kernel reserves max 4096 errno values
    |
  }
  reg_map -> syscall_table: "orig_rax\nlookup"
  syscall_table -> peekdata: "ARG_STR\ntype → read"
  syscall_table -> flag_decode: "ARG_OPEN_FLAGS\ntype → decode"
  peekdata -> err_detect: "read complete"
}
# ═══════════════════════════════════════════════════
# LAYER 4: M3 — MULTI-PROCESS
# ═══════════════════════════════════════════════════
multiproc: M3 · MULTI-PROCESS FORK FOLLOWING {
  style: {
    fill: "#E0F7FA"
    stroke: "#006064"
    stroke-width: 3
    border-radius: 8
  }
  # ── ptrace Events ──
  events: ptrace Event Decoder (events.c) {
    class: func_box
    label: |c
      // waitpid status layout for ptrace event stops:
      // bits[7:0]  = 0x7F  (stopped)
      // bits[15:8] = SIGTRAP (5)
      // bits[23:16]= EVENT_CODE
      int event = (status >> 16) & 0xFF;
      // PTRACE_EVENT_FORK  = 1  ← fork()
      // PTRACE_EVENT_VFORK = 2  ← vfork() [parent suspends]
      // PTRACE_EVENT_CLONE = 3  ← clone() / threads
      // PTRACE_EVENT_EXEC  = 4  ← execve() success
      // PTRACE_EVENT_EXIT  = 6  ← pre-exit notification
      // Get new child PID after fork/clone:
      unsigned long new_pid;
      ptrace(PTRACE_GETEVENTMSG, stopped_pid,
             NULL, &new_pid);
    |
  }
  # ── Fork Handler ──
  fork_handler: Fork Event Handler (events.c) {
    class: func_box
    label: |c
      void handle_fork_event(pid_t parent, int event) {
        unsigned long child_pid_ul;
        ptrace(PTRACE_GETEVENTMSG, parent,
               NULL, &child_pid_ul);
        pid_t child = (pid_t)child_pid_ul;
        // Insert new state (child born STOPPED)
        ProcessState *cs = state_map_insert(child);
        cs->in_syscall = 0;  // fresh, not mid-syscall
        active_count++;
        // CRITICAL: must resume child or it hangs forever
        ptrace(PTRACE_SYSCALL, child, NULL, NULL);
        // Resume parent too
        ptrace(PTRACE_SYSCALL, parent, NULL, NULL);
      }
      // Atomicity: PTRACE_O_TRACEFORK ensures child is
      // already STOPPED before tracer learns of fork.
      // No TOCTOU race window exists.
    |
  }
  # ── Exec Handler ──
  exec_handler: Exec Event Handler (events.c) {
    class: func_box
    label: |c
      void handle_exec_event(pid_t pid,
                             ProcessState *state) {
        // Address space COMPLETELY replaced:
        // - all text/heap/stack/mmap gone
        // - any saved pointers are dangling
        // - PID unchanged, ptrace attachment preserved
        state->in_syscall = 0;       // reset toggle
        memset(&state->entry_regs, 0,
               sizeof(state->entry_regs));
        // entry_time implicitly stale → reset too
        memset(&state->entry_time, 0,
               sizeof(state->entry_time));
      }
    |
  }
  # ── Active Count ──
  active_count: active_count Tracker (main.c) {
    class: data_box
    label: |c
      int active_count = 0;
      // Increment: fork event → new child
      // Increment: initial child at startup
      // Decrement: WIFEXITED(status)
      // Decrement: WIFSIGNALED(status)
      // Loop condition: while(active_count > 0)
      // NEVER double-decrement per PID
    |
  }
  events -> fork_handler: "event==FORK\nor CLONE"
  events -> exec_handler: "event==EXEC"
  fork_handler -> active_count: "active_count++"
  exec_handler -> active_count: "state reset"
}
# ═══════════════════════════════════════════════════
# LAYER 5: M4 — FILTERING + STATISTICS
# ═══════════════════════════════════════════════════
filter_stats: M4 · FILTERING + STATISTICS {
  style: {
    fill: "#FFF8E1"
    stroke: "#F57F17"
    stroke-width: 3
    border-radius: 8
  }
  # ── Filter ──
  filter: SyscallFilter (filter.c)\n-e trace=open,read,write {
    class: struct_box
    label: |c
      typedef struct {
        int  enabled;               // 0=no filter
        int  count;                 // # names parsed
        char names[64][32];         // syscall names
        int  nums[64];              // resolved numbers
      } SyscallFilter;
      void filter_parse(const char *spec);
      // "open,read,write" → split on ','
      // resolve each name → O(n) linear scan at startup
      int filter_passes(long syscall_num);
      // O(count) scan: count<=64, negligible
      // Returns 1=display, 0=suppress
      // stats_record() ALWAYS called (filter=display only)
    |
  }
  # ── Timing ──
  timing: CLOCK_MONOTONIC Timing (main.c)\nObserver Effect: measures ptrace overhead too {
    class: func_box
    label: |c
      // MUST use CLOCK_MONOTONIC (never CLOCK_REALTIME)
      // REALTIME can go backwards (NTP step → negative delta)
      // At entry stop (immediately after PTRACE_GETREGS):
      clock_gettime(CLOCK_MONOTONIC, &state->entry_time);
      // At exit stop (before any fprintf):
      struct timespec exit_time;
      clock_gettime(CLOCK_MONOTONIC, &exit_time);
      long long delta_ns =
        (exit_time.tv_sec  - state->entry_time.tv_sec)
          * 1000000000LL
        + exit_time.tv_nsec - state->entry_time.tv_nsec;
      // ~30ns per clock_gettime call (VDSO fast path)
      // delta includes: GETREGS+printf+PTRACE_SYSCALL overhead
      // True syscall latency ≠ delta (10-100x overhead for fast calls)
    |
  }
  # ── Attach ──
  attach: PTRACE_ATTACH (-p PID) (attach.c) {
    class: func_box
    label: |c
      void attach_to_process(pid_t pid) {
        ptrace(PTRACE_ATTACH, pid, NULL, NULL);
        // ATTACH sends SIGSTOP to target (disruptive)
        // MUST waitpid before any further ptrace calls
        int status;
        waitpid(pid, &status, 0);  // wait for SIGSTOP ack
        assert(WIFSTOPPED(status));
        ptrace(PTRACE_SETOPTIONS, pid, NULL, opts);
        // Permission: /proc/sys/kernel/yama/ptrace_scope
        // 0=permissive, 1=restricted, 2=admin-only
        // EPERM → print ptrace_scope help and exit
      }
      // Alternative: PTRACE_SEIZE (Linux 3.4+) — no SIGSTOP sent
    |
  }
  # ── Signal Handler ──
  sigint: SIGINT Clean Detach (signals.c) {
    class: func_box
    label: |c
      volatile sig_atomic_t g_interrupted = 0;
      // Handler: ONLY sets flag (async-signal-safe)
      static void sigint_handler(int sig) {
        g_interrupted = 1;  // no printf/malloc/ptrace here!
      }
      // SA_RESTART must be UNSET so waitpid returns EINTR
      // Main loop checks g_interrupted, then:
      void handle_interrupt(void) {
        if (g_attached_pid != 0) {
          kill(g_attached_pid, SIGSTOP);
          waitpid(g_attached_pid, &st, 0); // ensure stopped
          ptrace(PTRACE_DETACH, g_attached_pid, NULL, NULL);
          // Tracee resumes running; tracer exits
        }
        if (summary_mode) stats_print(stderr);
      }
    |
  }
  # ── Stats Print ──
  stats_print: stats_print() Table (stats.c)\nqsort by total_ns descending {
    class: data_box
    label: |c
      void stats_print(FILE *out) {
        // 1. Build index[] of syscalls where call_count>0
        // 2. qsort(index, count, sizeof(int), cmp_by_ns)
        // 3. Compute grand totals
        // 4. Print header + rows + footer
        // Output columns:
        // % time | seconds | usecs/call | calls | errors | syscall
        // e.g.:
        //  64.32  0.031423          12      2619         0  read
        //  21.17  0.010342          41       252         3  openat
        // NOTE: % values are wall-clock-relative, not CPU time
        // NOTE: call counts are EXACT regardless of filter
      }
    |
  }
  filter -> timing: "display gate\nstats always"
  timing -> stats_print: "delta_ns\naccumulate"
  attach -> sigint: "detach on\nSIGINT"
}
# ═══════════════════════════════════════════════════
# LAYER 6: KERNEL + HARDWARE
# ═══════════════════════════════════════════════════
kernel: KERNEL + HARDWARE {
  style: {
    fill: "#E8F5E9"
    stroke: "#1B5E20"
    stroke-width: 3
    border-radius: 8
  }
  # ── Kernel ABI ──
  kernel_abi: Kernel syscall Dispatch (entry_SYSCALL_64) {
    class: kernel_box
    label: |c
      // x86_64 syscall instruction hardware actions:
      // 1. RIP saved to RCX   (return address)
      // 2. RFLAGS saved to R11
      // 3. CS/SS set to kernel segments
      // 4. Jump to IA32_LSTAR MSR value → entry_SYSCALL_64
      // On PT_TRACED flag set:
      // ENTRY: save rax → orig_rax, deliver SIGTRAP, pause tracee
      // EXIT:  place result in rax, deliver SIGTRAP, pause tracee
      // Why orig_rax exists:
      // Kernel overwrites rax during dispatch; original saved first.
      // Always read orig_rax for syscall number (both entry & exit).
      // Read rax for return value on exit ONLY.
    |
  }
  # ── ptrace cost ──
  ptrace_cost: ptrace Overhead per Syscall {
    class: hw_box
    label: |c
      Per intercepted syscall cost (≈3GHz x86_64):
      ┌─ waitpid return:      ~100  cycles
      ├─ PTRACE_GETREGS:      ~500  cycles (216B copy, 4 cache lines)
      ├─ clock_gettime:        ~30  cycles (VDSO)
      ├─ filter_passes:        ~10  cycles (O(1) scan)
      ├─ fprintf (print):   ~5000  cycles (I/O)
      ├─ PTRACE_SYSCALL:      ~300  cycles
      └─ context switch:    ~3000  cycles
      Total: ~3,000–10,000 cycles ≈ 1–3µs @ 3GHz
      Per PTRACE_PEEKDATA (string arg read):
      ≈ 1,500 cycles per 8-byte word
      32-byte path: 4 calls = ~6,000 cycles = ~2µs
      Tracee slowdown: 2–100× depending on syscall frequency
    |
  }
  # ── Cache Layout ──
  cache_layout: Cache Line Layout (64B lines) {
    class: hw_box
    label: |c
      ProcessState = 248B → spans 4 cache lines
      ├─ Line 0 (0x00–0x3F): pid, in_syscall, entry_regs[0..55]
      ├─ Line 1 (0x40–0x7F): entry_regs[56..119]
      ├─ Line 2 (0x80–0xBF): entry_regs[120..183]
      └─ Line 3 (0xC0–0xFF): entry_regs[184..215], entry_time, valid, pad
      state_map[256] = 63,488B ≈ 63KB → fits L2 cache (256KB–1MB)
      SyscallStats[336] = 8,064B → fits L1 cache (32KB)
      PTRACE_GETREGS touches 4 cache lines per call (writes entry_regs)
    |
  }
  kernel_abi -> ptrace_cost: "stop delivery\ncost"
  ptrace_cost -> cache_layout: "memory\naccess pattern"
}
# ═══════════════════════════════════════════════════
# CROSS-LAYER CONNECTIONS
# ═══════════════════════════════════════════════════
# Milestone references
milestones.m1 -> tracer.lifecycle: "implements"
milestones.m1 -> tracer.toggle: "implements"
milestones.m2 -> arg_decode: "implements"
milestones.m3 -> multiproc: "implements"
milestones.m3 -> data_structures.hash_map: "implements"
milestones.m4 -> filter_stats: "implements"
# Data flow: tracer → data structures
tracer.toggle -> data_structures.proc_state: "entry_regs save\n216B | struct user_regs_struct"
tracer.toggle -> data_structures.stats_arr: "delta_ns | call_count++\n24B per slot" {
  class: error_path
}
data_structures.hash_map -> tracer.toggle: "find(pid)\n→ ProcessState*\nO(1) lookup"
# Data flow: arg decode uses data structures
arg_decode.reg_map -> data_structures.proc_state: "entry_regs.rdi/rsi/rdx/r10/r8/r9\nargs[0..5]"
arg_decode.syscall_table -> data_structures.proc_state: "orig_rax\n→ syscall_name()"
# M3 uses hash map
multiproc.fork_handler -> data_structures.hash_map: "state_map_insert(child)\nactive_count++"
multiproc.exec_handler -> data_structures.proc_state: "memset entry_regs=0\nreset toggle"
# M4 uses filter + stats
filter_stats.filter -> arg_decode.syscall_table: "syscall_num_by_name()\nname→number"
filter_stats.timing -> data_structures.proc_state: "entry_time\n16B timespec"
filter_stats.stats_print -> data_structures.stats_arr: "SyscallStats[336]\nread all"
# Kernel interactions
tracer.lifecycle -> kernel.kernel_abi: "ptrace(PTRACE_SYSCALL)\n→ SIGTRAP delivery"
arg_decode.peekdata -> kernel.kernel_abi: "PTRACE_PEEKDATA\n8B/call cross-AS read"
kernel.kernel_abi -> tracer.status_decode: "waitpid status\n32-bit bitmask"
# Error paths
arg_decode.peekdata -> arg_decode.err_detect: "errno!=0\nor ret==-1" {
  style: {
    stroke-dash: 5
    stroke: "#E53935"
  }
}
filter_stats.attach -> kernel.kernel_abi: "PTRACE_ATTACH\n→ SIGSTOP to target" {
  style: {
    stroke-dash: 5
    stroke: "#E53935"
  }
}