direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

title: |md
  ### Syscall Timing: The Observer Effect Breakdown
  *Tracing the path from hardware instruction to formatted output*
| {near: top-center}

Timeline: {
  1: "1. Tracee Executes `syscall`" {
    shape: rectangle
    style: {
      fill: "#E1F5FE"
      stroke: "#01579B"
    }
    label: |md
      **Layer: Hardware/Application**
      *State:* Tracee: **RUNNING**
      *Activity:* CPU executes `syscall` opcode.
      *Cost:* 100 - 50,000 cycles.
    |
  }

  2: "2. Kernel Interrupt -> Tracer Wakeup" {
    shape: rectangle
    style: {
      fill: "#F3E5F5"
      stroke: "#4A148C"
    }
    label: |md
      **Layer: Kernel Context Switch**
      *State:* Tracee: **STOPPED (ENTRY)**, Tracer: **ACTIVE**
      *Activity:* `waitpid()` returns in Tracer.
      *Cost:* ~2000 cycles.
    |
  }

  3: "3. clock_gettime(ENTRY)" {
    shape: rectangle
    style: {
      fill: "#FFF9C4"
      stroke: "#FBC02D"
      font-color: red
      bold: true
    }
    label: |md
      **Layer: Tracer Userspace**
      *State:* Timestamp **t1 = CAPTURED**
      *Activity:* VDSO call to read `CLOCK_MONOTONIC`.
      *Cost:* ~30 cycles.
    |
  }

  4: "4. PTRACE_GETREGS (Entry)" {
    shape: rectangle
    label: |md
      **Layer: Kernel IPC**
      *State:* Tracer: **READING REGISTERS**
      *Activity:* Copies `orig_rax`, `rdi`, `rsi` into `ProcessState`.
      *Cost:* ~500 cycles.
    |
  }

  5: "5. fprintf(trace_out, ...)" {
    shape: rectangle
    label: |md
      **Layer: I/O Subsystem**
      *State:* Output: **BUFFERED/WRITTEN**
      *Activity:* String formatting + write to file/stderr.
      *Cost:* 500 - 5,000 cycles.
    |
  }

  6: "6. ptrace(PTRACE_SYSCALL)" {
    shape: rectangle
    label: |md
      **Layer: Kernel IPC**
      *State:* Tracee: **READY TO RUN**
      *Activity:* Tells kernel to resume tracee until exit boundary.
      *Cost:* ~300 cycles.
    |
  }

  7: "7. Syscall Execution" {
    shape: rectangle
    style: {
      fill: "#E8F5E9"
      stroke: "#1B5E20"
    }
    label: |md
      **Layer: Kernel Internals**
      *State:* Tracee: **KERNEL MODE**
      *Activity:* `sys_write`, `sys_open`, etc. executes.
      *Cost:* Actual Syscall Latency.
    |
  }

  8: "8. Kernel Exit Stop -> Tracer Wakeup" {
    shape: rectangle
    style: {
      fill: "#F3E5F5"
      stroke: "#4A148C"
    }
    label: |md
      **Layer: Kernel Context Switch**
      *State:* Tracee: **STOPPED (EXIT)**, Tracer: **ACTIVE**
      *Activity:* `waitpid()` returns result in `rax`.
      *Cost:* ~2000 cycles.
    |
  }

  9: "9. PTRACE_GETREGS (Exit)" {
    shape: rectangle
    label: |md
      **Layer: Kernel IPC**
      *State:* Tracer: **READING RESULT**
      *Activity:* Copies return value from `rax`.
      *Cost:* ~500 cycles.
    |
  }

  10: "10. clock_gettime(EXIT)" {
    shape: rectangle
    style: {
      fill: "#FFF9C4"
      stroke: "#FBC02D"
      font-color: red
      bold: true
    }
    label: |md
      **Layer: Tracer Userspace**
      *State:* Timestamp **t2 = CAPTURED**
      *Activity:* VDSO call to read `CLOCK_MONOTONIC`.
      *Cost:* ~30 cycles.
    |
  }

  1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10
}

Measurement_Scope: {
  near: top-right
  label: |md
    ### MEASURED DELTA (Δt)
    Interval: Steps 3 → 10
    Formula: `t2 - t1`
  |
  style.stroke: red
  style.stroke-dash: 5
}

Actual_Work: {
  near: center-right
  label: |md
    ### ACTUAL SYSCALL TIME
    Only Step 7
  |
  style.stroke: green
}

Analysis: |md
  ### The Inflation Analysis
  Example: `getpid()`
  - **Actual Latency:** ~100ns
  - **Measured Latency:** ~10,000ns (10µs)
  - **Overhead Ratio:** **100x Inflation**

  *Conclusion:* ptrace-based timing measures the **Observer Overhead**, not raw kernel speed.
| {
  near: bottom-right
  style.fill: "#ECEFF1"
}

Legend: {
  near: top-left
  Entry_Stop: "Steps 2-6" { style.fill: "#E1F5FE" }
  Exit_Stop: "Steps 8-10" { style.fill: "#FFF9C4" }
}