direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# 3-Level Syscall Flow: x86_64 ptrace Interception
# Intel Manual Quality Reference Diagram

level_1: "Level 1: Application (Userspace)" {
  style.stroke: "#612F74"
  style.stroke-width: 4
  
  tracee: "Tracee Process (CPL 3)" {
    reg_setup: "1. Register Setup (ABI)\nrax=1 (write)\nrdi=1 (stdout)\nrsi=ptr (buf)\nrdx=5 (len)" {
      style.fill: "#D0E2F3" # Blue Data
    }
    instr: "2. Instruction\n'syscall'" {
      shape: parallelogram
      style.bold: true
      style.fill: "#EFEFEF" # Gray Padding/Instruction
    }
    
    reg_setup -> instr
  }
}

level_3: "Level 3: Hardware (CPU)" {
  style.stroke: "#612F74"
  style.stroke-width: 4

  cpu_logic: "CPU Micro-Operations" {
    cpl_switch: "Ring Transition\nCPL 3 -> CPL 0" {
      style.fill: "#D0F3D0" # Green state transition
    }
    save_ctx: "Context Save\nRCX = RIP (Return Addr)\nR11 = RFLAGS" {
      style.fill: "#EFEFEF" # Gray Fixed Data
    }
    msr_jump: "Jump to LSTAR MSR\nRIP = IA32_LSTAR" {
      style.fill: "#FF9900" # Orange Pointer logic
    }
    
    cpl_switch -> save_ctx -> msr_jump
  }
}

level_2: "Level 2: Kernel (Ring 0)" {
  style.stroke: "#612F74"
  style.stroke-width: 4
  
  entry_logic: "entry_SYSCALL_64" {
    pt_check: "3. PT_TRACED Check\nIs process being traced?"
    save_rax: "4. Save State\norig_rax = rax" {
      style.fill: "#D0E2F3"
    }
    trap_entry: "5. Syscall Entry Stop\ndeliver SIGTRAP" {
      style: {
        stroke: "#FF9900" 
        stroke-width: 3
        double-border: true
      }
    }
    
    pt_check -> save_rax -> trap_entry
  }

  execution: "Syscall Dispatch" {
    sys_write: "6. sys_write(fd, buf, count)\nKernel executes logic" {
      style.fill: "#D0F3D0" # Green Free/Success Path
    }
    store_ret: "7. Set Return\nrax = result" {
      style.fill: "#D0E2F3"
    }
    trap_exit: "8. Syscall Exit Stop\ndeliver SIGTRAP" {
      style: {
        stroke: "#FF9900"
        stroke-width: 3
        double-border: true
      }
    }
    
    sys_write -> store_ret -> trap_exit
  }
}

# Cross-Level Sequencing
level_1.tracee.instr -> level_3.cpu_logic.cpl_switch: "Hardware Trigger"
level_3.cpu_logic.msr_jump -> level_2.entry_logic.pt_check: "Vector to entry_SYSCALL_64"

# Tracer Interaction
tracer: "Tracer (strace)" {
  shape: person
  style.fill: "#FF9900"
}

level_2.entry_logic.trap_entry -> tracer: "SIGTRAP (waitpid)"
tracer -> level_2.entry_logic.trap_entry: "PTRACE_SYSCALL"
level_2.entry_logic.trap_entry -> level_2.execution.sys_write: "Resume Execution"

level_2.execution.trap_exit -> tracer: "SIGTRAP (waitpid)"
tracer -> level_2.execution.trap_exit: "PTRACE_SYSCALL"

# Annotations
abi_note: |md
  ### x86_64 ABI Constraint
  The `syscall` instruction clobbers **RCX** to store the return address ($RIP$).
  Consequently, the Linux x86_64 ABI uses **R10** instead of **RCX** for the 
  4th syscall argument.
| {
  near: bottom-right
  style.font-size: 12
}

state_invariants: |md
  **Stop Invariants:**
  - **Entry Stop:** `rax` holds syscall number.
  - **Exit Stop:** `rax` holds return value; `orig_rax` holds syscall number.
| {
  near: top-right
  style.font-size: 11
}

# Global Style Overrides
***.style.font: mono
(level_1.tracee.instr -> level_3.cpu_logic.cpl_switch)[0].style.stroke: "#FF9900"
(level_3.cpu_logic.msr_jump -> level_2.entry_logic.pt_check)[0].style.stroke: "#FF9900"