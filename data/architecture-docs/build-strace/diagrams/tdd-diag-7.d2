layout-engine: elk
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# x86_64 Syscall Error Detection Algorithm: [-4096, -1] Range

info: "sizeof(rax) = 8 bytes" {
  shape: text
  near: top-left
}

total_size: "Total Logic Range: 4096B" {
  shape: text
  near: top-right
}

step_1: {
  label: "1. Raw Register Capture"
  style.fill: "#F3E5F5"
  
  rax_unsigned: {
    label: "rax (uint64_t)"
    style.fill: "#9575CD" # Header=Purple
    
    # Memory Layout: [Offset] | [Data] | [Size]
    b0: { 
      label: "0x00 | 0xFE | 1B"
      style.fill: "#BBDEFB" # Data=Blue
    }
    b1: { 
      label: "0x01 | 0xFF | 1B"
      style.fill: "#BBDEFB" # Data=Blue
    }
    gap: { 
      label: "0x02 | [...] | 5B"
      style.fill: "#E0E0E0" # Padding=Gray
    }
    b7: { 
      label: "0x07 | 0xFF | 1B"
      style.fill: "#BBDEFB" # Data=Blue
    }
  }
  interpretation: "CPU returns raw bit pattern: 0xFF...FE" { shape: text }
}

step_2: {
  label: "2. Sign Interpretation"
  style.fill: "#F3E5F5"
  
  rax_signed: {
    label: "return_val (int64_t)"
    style.fill: "#9575CD" # Header=Purple
    
    # State change: RED + BOLD
    val: "**-2**" {
      style: {
        stroke: red
        font-color: red
        fill: "#FFEBEE"
        bold: true
      }
    }
  }
  action: "Casting to signed (long) invokes\ntwo's complement interpretation." { shape: text }
}

step_3: {
  label: "3. Range Comparison"
  style.fill: "#F3E5F5"
  
  logic: {
    label: "Condition Evaluation"
    style.fill: "#9575CD" # Header=Purple
    range: "Check: [-4096 <= val <= -1]"
    # State change: RED + BOLD
    eval: "**Result: TRUE**" {
      style: {
        stroke: red
        font-color: red
        fill: "#FFEBEE"
        bold: true
      }
    }
  }
}

step_4: {
  label: "4. Errno Normalization"
  style.fill: "#F3E5F5"
  
  recovery: {
    label: "Final state"
    style.fill: "#9575CD" # Header=Purple
    op: "errno = (int)(-return_val)"
    # State change: RED + BOLD
    result: "errno = **2 (ENOENT)**" {
      style: {
        stroke: red
        font-color: red
        fill: "#FFEBEE"
        bold: true
      }
    }
  }
}

step_1 -> step_2: "(long) cast"
step_2 -> step_3: "cmp [rax], -4096"
step_3 -> step_4: "neg rax"

logic_map: {
  label: "Kernel Address Space / Error Mapping"
  style.fill: "#FFFFFF"
  
  number_line: {
    grid-columns: 3
    
    low_success: {
      label: "Success Zone\n(0x0 to 0x...EFFF)"
      style.fill: "#E1F5FE"
    }
    
    error_zone: {
      label: "Kernel Error Zone\n[-4096 to -1]"
      range: "0xFF...F000 to 0xFF...FFFF"
      style: {
        fill: "#FFEBEE"
        stroke: red
        stroke-width: 4
      }
    }
    
    mapping: {
      label: "Mapping Table"
      m1: "-1  (0xFF...FF) -> EPERM (1)"
      m2: "-2  (0xFF...FE) -> ENOENT (2)"
      m3: "-13 (0xFF...F3) -> EACCES (13)"
      style.fill: "#FFFFFF"
    }
  }
}

# Annotation positioned at root level to satisfy D2 'near' constraints
annotation: |md
  ### Hardware/ABI Constraints
  - **x86_64 ABI**: The kernel reserves the top 4096 values of the virtual address space for error codes.
  - **Register**: `rax` holds the syscall result.
  - **Negation**: `errno` in userspace is positive; kernel returns are negated.
| {
  near: bottom-center
}

***.style.font: mono