{
  "title": "Project Valiant: Design Document for an Educational TCP/IP Stack",
  "overview": "This document outlines the design for 'Project Valiant,' a user-space implementation of a TCP/IP network stack. The key architectural challenge is building a reliable, layered data communication system with intricate state management and protocol logic, while providing an educational scaffold for developers to understand core networking principles from the ground up.",
  "sections": [
    {
      "id": "context-and-problem",
      "title": "1. Context and Problem Statement",
      "summary": "Establishes why building a network stack is a valuable learning exercise and defines the core technical challenges of reliable, layered communication.",
      "subsections": [
        {
          "id": "analogy-postal-service",
          "title": "Analogy: The Postal Service of Computing",
          "summary": "Explains the TCP/IP stack using the intuitive model of mailing a letter, translating layers to real-world steps."
        },
        {
          "id": "technical-challenge",
          "title": "The Core Technical Challenge",
          "summary": "Describes the problem of building a system that handles unreliable physical transmission, provides addressing, routing, and reliable data streams, all while maintaining complex state."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches",
          "summary": "Compares kernel-space implementations (Linux, BSD) with user-space educational stacks, highlighting the pedagogical focus of this project."
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "2. Goals and Non-Goals",
      "summary": "Explicitly defines the scope of the project, detailing what must be implemented for learning and what is explicitly out of scope to manage complexity.",
      "subsections": [
        {
          "id": "goals-list",
          "title": "Goals (Must-Haves)",
          "summary": "Lists the core protocol implementations and educational outcomes, aligned with the four milestones."
        },
        {
          "id": "non-goals-list",
          "title": "Non-Goals (Explicitly Out of Scope)",
          "summary": "Clarifies that high performance, security hardening, and advanced protocol features are not the focus."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "3. High-Level Architecture",
      "summary": "Presents the bird's-eye view of the stack's layered components, their responsibilities, and how data flows between them. Includes the recommended file structure.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview & Layered Model",
          "summary": "Describes the five logical layers (Link, Network, Transport, Socket, Application) and their corresponding software components."
        },
        {
          "id": "file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Provides a suggested directory and file layout to organize the codebase cleanly, separating layers and concerns."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core data structures that represent packets, headers, connection state, and routing information used throughout the stack.",
      "subsections": [
        {
          "id": "packet-structures",
          "title": "Packet & Header Structures",
          "summary": "Tables describing the C `struct` layouts for Ethernet, IPv4, TCP, and ICMP headers, with field descriptions and byte ordering notes."
        },
        {
          "id": "state-structures",
          "title": "State Management Structures",
          "summary": "Defines structures for the ARP cache, routing table, TCP connection control block (TCB), and send/receive buffers."
        }
      ]
    },
    {
      "id": "component-link-layer",
      "title": "5. Component Design: Link Layer (Milestone 1)",
      "summary": "Design for the Ethernet frame handler and ARP protocol implementation, responsible for physical network interaction and address resolution.",
      "subsections": [
        {
          "id": "link-responsibility",
          "title": "Responsibility and Scope",
          "summary": "Handles raw frame I/O via TAP, Ethernet frame parsing/construction, and IP-to-MAC address resolution via ARP."
        },
        {
          "id": "link-mental-model",
          "title": "Mental Model: The Neighborhood Mail Carrier",
          "summary": "Analogy comparing MAC addresses to street addresses and ARP to asking \"Who lives at this IP address?\""
        },
        {
          "id": "link-interface",
          "title": "Interface",
          "summary": "Table of key functions: `netif_rx_packet`, `arp_resolve`, `arp_cache_lookup`, etc."
        },
        {
          "id": "link-behavior",
          "title": "Internal Behavior",
          "summary": "Numbered steps for processing an incoming frame and handling an ARP request/reply."
        },
        {
          "id": "link-adr-tap",
          "title": "ADR: Choosing TAP over Raw Sockets",
          "summary": "Decision record for using a TAP device for a simpler, more isolated link layer interface."
        },
        {
          "id": "link-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Byte-order bugs, ARP cache poisoning vulnerability, mishandling broadcast frames."
        },
        {
          "id": "link-implementation",
          "title": "Implementation Guidance",
          "summary": "Starter code for TAP device setup, skeleton for Ethernet/ARP parsers, and milestone 1 checkpoint."
        }
      ]
    },
    {
      "id": "component-network-layer",
      "title": "6. Component Design: Network Layer (Milestone 2)",
      "summary": "Design for the IPv4 packet handler, ICMP protocol, and a simple routing table.",
      "subsections": [
        {
          "id": "net-responsibility",
          "title": "Responsibility and Scope",
          "summary": "IP packet validation, checksum verification, ICMP echo handling, and next-hop routing decisions."
        },
        {
          "id": "net-mental-model",
          "title": "Mental Model: The Sorting Facility & System Monitor",
          "summary": "Compares IP routing to a postal sorting center and ICMP to a system health ping/response tool."
        },
        {
          "id": "net-interface",
          "title": "Interface",
          "summary": "Table of key functions: `ipv4_input`, `ipv4_output`, `icmp_echo_reply`, `route_lookup`."
        },
        {
          "id": "net-behavior",
          "title": "Internal Behavior",
          "summary": "Steps for IP packet forwarding, ICMP echo request processing, and routing table lookup."
        },
        {
          "id": "net-adr-checksum",
          "title": "ADR: On-the-Wire vs. Recalculated Checksums",
          "summary": "Decision record on validating received checksums versus calculating for outgoing packets."
        },
        {
          "id": "net-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Incorrect checksum calculation, forgetting to decrement TTL, ignoring IP fragmentation."
        },
        {
          "id": "net-implementation",
          "summary": "Implementation Guidance",
          "title": "Skeleton code for IP/ICMP handlers and routing table, milestone 2 checkpoint."
        }
      ]
    },
    {
      "id": "component-tcp-connection",
      "title": "7. Component Design: TCP Connection Management (Milestone 3)",
      "summary": "Design for the TCP segment parser, connection state machine, and the handshake processes for connection establishment and teardown.",
      "subsections": [
        {
          "id": "tcp-conn-responsibility",
          "title": "Responsibility and Scope",
          "summary": "Managing TCP connections: parsing segments, maintaining state, executing 3-way handshake and 4-way close."
        },
        {
          "id": "tcp-conn-mental-model",
          "title": "Mental Model: A Telephone Call",
          "summary": "Analogizes SYN/SYN-ACK/ACK to \"Hello?\" / \"Hello, I hear you!\" / \"Great, let's talk.\" and FIN to \"Goodbye.\""
        },
        {
          "id": "tcp-state-machine",
          "title": "TCP State Machine",
          "summary": "Table of state transitions (LISTEN, SYN_SENT, ESTABLISHED, etc.) triggered by events like segment arrival."
        },
        {
          "id": "tcp-conn-interface",
          "title": "Interface",
          "summary": "Table of key functions: `tcp_input`, `tcp_connect`, `tcp_listen`, `tcp_close`."
        },
        {
          "id": "tcp-conn-adr-tcb",
          "title": "ADR: Centralized TCB vs. Per-Socket State",
          "summary": "Decision to use a central TCP Control Block structure to manage all connection state."
        },
        {
          "id": "tcp-conn-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Incorrect state transitions, sequence number initialization/wraparound, not handling RST packets."
        },
        {
          "id": "tcp-conn-implementation",
          "title": "Implementation Guidance",
          "summary": "Skeleton for TCB, TCP input demultiplexer, and state machine handlers. Milestone 3 checkpoint."
        }
      ]
    },
    {
      "id": "component-tcp-data",
      "title": "8. Component Design: TCP Data Transfer (Milestone 4)",
      "summary": "Design for reliable data transfer, including sliding windows, retransmission timers, flow control, and basic congestion control.",
      "subsections": [
        {
          "id": "tcp-data-responsibility",
          "title": "Responsibility and Scope",
          "summary": "Ensuring reliable, in-order data delivery using acknowledgments, retransmissions, and window-based flow/congestion control."
        },
        {
          "id": "tcp-data-mental-model",
          "title": "Mental Model: A Windowed Conveyor Belt with Traffic Control",
          "summary": "Compares the sliding window to a conveyor belt loading area, retransmission to a \"message not received\" timeout, and congestion window to traffic light timing."
        },
        {
          "id": "tcp-data-interface",
          "title": "Interface",
          "summary": "Table of key functions: `tcp_send`, `tcp_receive`, `tcp_ack_received`, `retransmit_timer_callback`."
        },
        {
          "id": "tcp-data-behavior",
          "title": "Internal Behavior",
          "summary": "Steps for sending data with the sliding window, processing ACKs, managing retransmission timers, and adjusting the congestion window."
        },
        {
          "id": "tcp-data-adr-timer",
          "title": "ADR: Timer Management Strategy",
          "summary": "Decision to use a single periodic timer wheel vs. per-segment timers for retransmissions."
        },
        {
          "id": "tcp-data-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Timer management bugs, incorrect window size calculations, mishandling of duplicate ACKs, sequence number arithmetic errors."
        },
        {
          "id": "tcp-data-implementation",
          "title": "Implementation Guidance",
          "summary": "Skeleton for send/receive buffers, timer management, and congestion control logic. Milestone 4 checkpoint."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "9. Interactions and Data Flow",
      "summary": "Describes how components communicate, the lifecycle of a packet through the stack, and key control flows for ARP, Ping, and a TCP connection.",
      "subsections": [
        {
          "id": "packet-lifecycle",
          "title": "Packet Lifecycle: From Wire to Socket",
          "summary": "Step-by-step walkthrough of an incoming TCP packet being processed up the stack."
        },
        {
          "id": "control-flows",
          "title": "Key Control Flows",
          "summary": "Sequence descriptions for ARP resolution, ICMP ping, and TCP connection establishment/data transfer/closure."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "10. Error Handling and Edge Cases",
      "summary": "Catalogues expected failure modes (checksum failures, unknown protocols, connection timeouts) and the stack's strategy for detection and recovery.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "Failure Modes & Detection",
          "summary": "Table of error types (Corrupt Packet, No Route, Connection Reset), how they are detected, and the immediate action (drop, send ICMP error, terminate connection)."
        },
        {
          "id": "robustness",
          "title": "Building Robustness",
          "summary": "Strategies for defensive parsing, resource limits, and handling malicious or malformed packets."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "11. Testing Strategy",
      "summary": "Outlines a multi-faceted approach to verifying the stack's correctness, from unit tests to integration with real network tools.",
      "subsections": [
        {
          "id": "test-approaches",
          "title": "Testing Approaches",
          "summary": "Describes unit testing, integration testing with packet captures, and system testing using standard tools like `ping` and `netcat`."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "For each of the four milestones, a concrete description of the expected behavior and commands to run for verification."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "12. Debugging Guide",
      "summary": "A practical guide for learners to diagnose common implementation bugs, with symptom-cause-fix tables and recommended logging strategies.",
      "subsections": [
        {
          "id": "symptom-table",
          "title": "Common Bugs: Symptom \u2192 Cause \u2192 Fix",
          "summary": "Table listing issues like 'Ping doesn't reply', 'TCP connection hangs at SYN_SENT', 'Data transfer is slow', with diagnosis steps and fixes."
        },
        {
          "id": "techniques-tools",
          "title": "Debugging Techniques & Tools",
          "summary": "Recommendations for using Wireshark/tcpdump, strategic logging (hex dumps, state changes), and building a test harness."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "13. Future Extensions",
      "summary": "Suggests potential advanced features that could be built upon the completed stack, highlighting how the current design accommodates them.",
      "subsections": [
        {
          "id": "extension-ideas",
          "title": "Ideas for Further Learning",
          "summary": "Lists extensions like UDP support, IPv6, TCP SACK, TLS integration, or a simple HTTP server on top of the stack."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "14. Glossary",
      "summary": "Definitions of all key technical terms, acronyms, and domain-specific vocabulary used in this document.",
      "subsections": [
        {
          "id": "terms-table",
          "title": "Terminology Reference",
          "summary": "Alphabetical table of terms from 'ACK' and 'ARP' to 'Sliding Window' and 'TTL', with clear definitions and section references."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "arch-component",
      "title": "High-Level Component Architecture",
      "description": "Shows the layered components (TAP Device, Ethernet/ARP, IP/ICMP, TCP, Socket API) and the flow of data upward (receive path) and downward (send path). Include arrows labeled with packet types (Frame, IP Packet, TCP Segment).",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture"
      ]
    },
    {
      "id": "data-model-relations",
      "title": "Data Model Relationships",
      "description": "A class diagram showing key structures (eth_hdr, ip_hdr, tcp_hdr, tcb, arp_entry, route_entry) and their relationships (e.g., TCB contains send/recv buffers, points to a route_entry).",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "tcp-state-machine",
      "title": "TCP Connection State Machine",
      "description": "A state machine diagram showing the standard TCP states (CLOSED, LISTEN, SYN_SENT, SYN_RCVD, ESTABLISHED, FIN_WAIT_1, etc.) and transitions between them triggered by events like 'send SYN', 'receive SYN', 'send FIN'. Highlight the three-way handshake and four-way close paths.",
      "type": "state-machine",
      "relevant_sections": [
        "component-tcp-connection"
      ]
    },
    {
      "id": "arp-sequence",
      "title": "ARP Request/Reply Sequence",
      "description": "A sequence diagram showing a host sending an ARP request (broadcast), the target host receiving it and sending a unicast ARP reply, and the original host caching the result.",
      "type": "sequence",
      "relevant_sections": [
        "component-link-layer",
        "interactions-data-flow"
      ]
    },
    {
      "id": "tcp-handshake-flow",
      "title": "TCP Three-Way Handshake & Data Flow",
      "description": "A sequence diagram showing the SYN, SYN-ACK, ACK exchange between client and server, followed by a sample data segment and ACK. Include key header fields (SEQ, ACK numbers, flags) on the messages.",
      "type": "sequence",
      "relevant_sections": [
        "component-tcp-connection",
        "interactions-data-flow"
      ]
    },
    {
      "id": "sliding-window-flowchart",
      "title": "Sliding Window Send Algorithm",
      "description": "A flowchart for the sender's logic: Start with data to send, check if within congestion window (cwnd) and receiver window (rwnd), send segment, start timer, wait for ACK. Include branches for 'ACK received' (slide window), 'Timeout' (retransmit), and 'Duplicate ACK'.",
      "type": "flowchart",
      "relevant_sections": [
        "component-tcp-data"
      ]
    },
    {
      "id": "packet-processing-flow",
      "title": "Incoming Packet Processing Flow",
      "description": "A flowchart detailing the dispatch of an incoming Ethernet frame: Check EtherType -> ARP? -> IP? -> Check IP protocol -> ICMP? -> TCP? -> Find TCB -> Process TCP state. Include decision diamonds for checksum validation and 'drop packet' endpoints.",
      "type": "flowchart",
      "relevant_sections": [
        "interactions-data-flow",
        "high-level-architecture"
      ]
    }
  ]
}