{
  "types": {
    "Expr": "Base class for all expression nodes",
    "Stmt": "Base class for all statement nodes",
    "Literal": "fields: value any",
    "BinaryOp": "fields: left Expr, operator str, right Expr",
    "UnaryOp": "fields: operator str, operand Expr",
    "Variable": "fields: name str",
    "Assignment": "fields: name str, value Expr",
    "VarDecl": "fields: name str, initializer Expr",
    "Block": "fields: statements list[Stmt]",
    "IfStmt": "fields: condition Expr, then_branch Stmt, else_branch Stmt|None",
    "WhileStmt": "fields: condition Expr, body Stmt",
    "Compiler": "fields: current_chunk BytecodeChunk, symbol_table SymbolTable, error_reporter ErrorReporter",
    "BytecodeChunk": "fields: code list[int], constants ConstantPool",
    "ConstantPool": "fields: values list[any]",
    "SymbolTable": "fields: scopes list[dict]",
    "ErrorReporter": "fields: had_error bool, error_message str",
    "CompileError": "fields: (inherits from Exception)",
    "VM": "fields: trace_execution bool, stack list, frames list",
    "Lambda": "fields: parameters list[str], body list[Stmt], captures list[str]",
    "Closure": "fields: function_index int, captured_values list",
    "ClassDecl": "fields: name str, superclass str|None, methods list, fields list",
    "Property": "fields: object Expr, name str",
    "MethodCall": "fields: object Expr, name str, arguments list[Expr]",
    "NativeCall": "fields: name str, arguments list[Expr]",
    "Module": "fields: name str, statements list[Stmt], exports list[str]",
    "ClassObject": "fields: name str, methods dict[str, int], superclass ClassObject|None, field_count int",
    "InstanceObject": "fields: klass ClassObject, fields list[any]",
    "BoundMethod": "fields: receiver InstanceObject, method_index int",
    "NativeRegistry": "fields: _functions dict[str, NativeFunction], _index_to_name list[str], _name_to_index dict[str, int]",
    "ConstantFolder": "fields: none",
    "PeepholeOptimizer": "fields: none"
  },
  "methods": {
    "Compiler.compile(statements) returns BytecodeChunk": "Compiles a list of statements into bytecode, raising CompileError on failure",
    "Compiler._compile_expr(expr_node) returns None": "Internal method to compile an expression node",
    "Compiler._compile_stmt(stmt_node) returns None": "Internal method to compile a statement node",
    "BytecodeChunk.add_constant(value) returns int": "Adds a constant value to the pool and returns its index",
    "BytecodeChunk.write_opcode(opcode, operand=None) returns None": "Appends an opcode (and optional operand) to the code list",
    "ConstantPool.add_constant(value) returns int": "Adds a constant value to the pool and returns its index",
    "SymbolTable.enter_scope() returns None": "Begins a new nested scope",
    "SymbolTable.exit_scope() returns None": "Ends the innermost scope, discarding its variable mappings",
    "SymbolTable.declare_variable(name) returns int": "Adds a new variable to the current scope and returns its slot index",
    "SymbolTable.resolve_variable(name) returns Optional[int]": "Looks up a variable by name, searching from innermost to outermost scope",
    "BytecodeChunk.write_opcode(opcode, operand=None) returns": "Appends an opcode (and optional operand) to the code list.",
    "BytecodeChunk.patch_operand(position, operand) returns None": "Overwrites the operand byte at the given code position",
    "ErrorReporter.report(message) returns None": "Report a compilation error and raise CompileError",
    "ErrorReporter.reset() returns None": "Reset error state for new compilation",
    "ErrorReporter.format_error(context) returns str": "Format current error with optional context",
    "disassemble_chunk(chunk, name) returns str": "Disassemble a bytecode chunk into human-readable format",
    "disassemble_instruction(chunk, offset) returns tuple": "Disassemble a single instruction at the given offset",
    "print_disassembly(chunk, name) returns None": "Convenience function to print disassembly to stdout",
    "VM.trace(instruction, offset) returns None": "Print trace of current instruction execution",
    "VM.run(chunk) returns None": "Execute bytecode with optional tracing",
    "NativeRegistry.register(name, func) returns int": "Register a native function and return its index",
    "NativeRegistry.get_index(name) returns int": "Get index of registered native function",
    "NativeRegistry.get_function(index) returns NativeFunction": "Get native function by index",
    "NativeRegistry.get_function_by_name(name) returns NativeFunction": "Get native function by name",
    "ConstantFolder.fold_expression(expr) returns Expr": "Fold constant subexpressions in the given expression",
    "ConstantFolder._fold_unary(operator, operand) returns Any": "Apply unary operator to constant value",
    "ConstantFolder._fold_binary(operator, left, right) returns Any": "Apply binary operator to constant values"
  },
  "constants": {
    "OP_CONSTANT": "Load a constant from the pool. Operand: constant pool index",
    "OP_ADD": "Add the top two values on the stack",
    "OP_SUBTRACT": "Subtract the top value from the second value",
    "OP_MULTIPLY": "Multiply the top two values",
    "OP_DIVIDE": "Divide the second value by the top value",
    "OP_NEGATE": "Negate the top value (unary minus)",
    "OP_NOT": "Logical NOT of the top value",
    "OP_JUMP": "Unconditionally jump to a new instruction offset",
    "OP_JUMP_IF_FALSE": "Pop the top value; if false, jump to offset",
    "OP_LOOP": "Jump backward by a given offset",
    "OP_CALL": "Call a function with N arguments",
    "OP_RETURN": "Return from the current function",
    "OP_LOAD": "Load variable onto stack",
    "OP_STORE": "Store top of stack into variable",
    "OP_EQUAL": "Compare top two values for equality",
    "OP_NOT_EQUAL": "Compare top two values for inequality",
    "OP_LESS": "Check if second value is less than top value",
    "OP_GREATER": "Check if second value is greater than top value",
    "OP_CLOSURE": "Creates a closure from a function and captured values",
    "OP_CAPTURE": "Loads a captured variable onto the stack",
    "OP_CLASS": "Defines a new class",
    "OP_GET_PROPERTY": "Loads a field from an object",
    "OP_SET_PROPERTY": "Stores to a field in an object",
    "OP_INVOKE": "Calls a method on an object",
    "OP_INHERIT": "Sets up inheritance between classes",
    "OP_NATIVE_CALL": "Calls a native (host-language) function"
  },
  "terms": {
    "AST": "Abstract Syntax Tree. The hierarchical representation of a program's structure after parsing",
    "Bytecode": "A linear sequence of low-level instructions for a virtual machine",
    "Stack-based VM": "A virtual machine that uses an operand stack for all computations",
    "Constant Pool": "An array of literal values (numbers, strings) embedded in the bytecode, referenced by index",
    "Symbol Table": "A data structure that maps variable names to their storage location (e.g., stack slot) during compilation",
    "Jump Patching": "Process of filling in forward jump target offsets after target is known",
    "Opcode": "A single bytecode operation code (e.g., ADD, JUMP)",
    "Operand": "An immediate value (like a constant index) that follows an opcode in the bytecode stream",
    "Scope": "A region of source code where a variable name is visible and can be used",
    "Slot Index": "A numerical index representing a variable's position in the stack frame",
    "Semantic Errors": "Errors in program logic detected during compilation, like undefined variables",
    "Lexical Scoping": "Variable resolution based on compile-time nesting of scopes",
    "Shadowing": "When inner scope variable hides outer scope variable with same name",
    "Fail-fast": "Error handling strategy that halts immediately upon first error",
    "Disassembler": "Tool that translates raw bytecode back into human-readable mnemonic form",
    "Execution Tracer": "Tool that shows dynamic runtime behaviorâ€”the stack and frame state as each instruction executes",
    "Jump Validator": "Tool that verifies all jump targets point to valid instruction boundaries",
    "Golden Master": "Hand-verified correct bytecode for simple programs used as reference for testing",
    "Closure": "A function value that captures variables from its surrounding lexical scope",
    "First-class Functions": "Functions that can be assigned to variables, passed as arguments, and returned from other functions",
    "Capture Analysis": "Compile-time analysis to determine which variables a nested function references from outer scopes",
    "Virtual Method Table (VMTable)": "A table of function pointers for dynamic method dispatch in object-oriented languages",
    "Dynamic Dispatch": "Determining which method to call based on the runtime type of an object",
    "Constant Folding": "Compile-time evaluation of constant expressions",
    "Peephole Optimization": "Bytecode optimization by examining small windows of instructions and replacing patterns",
    "Foreign Function Interface (FFI)": "Mechanism for calling functions written in another language (typically the host language)",
    "Type Marshalling": "Converting values between different type systems when crossing language boundaries",
    "Garbage Collection (GC)": "Automatic memory management that reclaims memory occupied by objects no longer in use",
    "Mark-and-Sweep": "A garbage collection algorithm that marks reachable objects then sweeps unmarked ones",
    "Root Set": "The set of directly accessible values from which garbage collection begins tracing",
    "Module System": "Mechanism for organizing code into separate namespaces with controlled visibility",
    "Architecture Decision Record (ADR)": "Documented decision about a significant design choice",
    "Backpatching": "Technique of filling in forward jump target addresses after target is known",
    "Bytecode Chunk": "Container for bytecode instruction stream and constant pool",
    "Control Flow": "Order in which instructions are executed",
    "Frame (Call Frame)": "Data structure representing an active function invocation",
    "Function": "Reusable block of code with parameters and body",
    "Instruction": "Single operation in bytecode stream (opcode + optional operand)",
    "Mental Model": "Intuitive analogy helping understand complex systems"
  }
}