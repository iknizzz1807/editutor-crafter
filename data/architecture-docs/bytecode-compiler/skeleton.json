{
  "title": "Bytecode Compiler: Design Document",
  "overview": "This system transforms an Abstract Syntax Tree (AST) into executable bytecode for a stack-based Virtual Machine (VM). The key architectural challenge is translating the tree-structured program representation into a flat, sequential list of instructions that manage computation via an operand stack, while correctly handling variable scopes, control flow jumps, and function calls.",
  "sections": [
    {
      "id": "context-problem-statement",
      "title": "1. Context and Problem Statement",
      "summary": "Explains the challenge of translating a structured program (AST) into linear instructions (bytecode) for a stack machine, introducing key concepts like tree traversal and stack-based evaluation.",
      "subsections": [
        {
          "id": "analogy-mental-model",
          "title": "Mental Model: The Assembly Line vs. The Recipe",
          "summary": "Uses the analogy of an assembly line (bytecode) following a recipe (AST) to explain the transformation from structure to sequence."
        },
        {
          "id": "technical-problem",
          "title": "The Compilation Challenge",
          "summary": "Defines the core problem: converting a recursive AST into a flat, efficient instruction stream that uses a stack for temporary values."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches & Trade-offs",
          "summary": "Compares stack-based, register-based, and tree-walking VM architectures in a table."
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "2. Goals and Non-Goals",
      "summary": "Clearly defines the scope of the educational compiler, setting expectations for what will and won't be implemented.",
      "subsections": [
        {
          "id": "goals",
          "title": "Goals (What We Must Do)",
          "summary": "Lists core functionalities: expression evaluation, variables, scopes, control flow, and functions."
        },
        {
          "id": "non-goals",
          "title": "Non-Goals (What We Won't Do)",
          "summary": "Explicitly excludes features like type systems, garbage collection, and advanced optimizations to maintain focus."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "3. High-Level Architecture",
      "summary": "Presents the bird's-eye view of the compiler's components (Compiler, Chunk, ConstantPool, SymbolTable) and how data flows between them.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview & Responsibilities",
          "summary": "Describes the role of each major component using a table."
        },
        {
          "id": "file-structure",
          "title": "Recommended File/Module Structure",
          "summary": "Provides a suggested Python package layout to organize the codebase cleanly."
        },
        {
          "id": "arch-diagram",
          "title": "Architecture Diagram Description",
          "summary": "Describes the components and data flow for the system diagram."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "4. Data Model",
      "summary": "Defines the core data structures: the Bytecode Chunk, Constant Pool, Symbol Table, and Instructions.",
      "subsections": [
        {
          "id": "chunk-constant-pool",
          "title": "Bytecode Chunk & Constant Pool",
          "summary": "Describes the structure holding the linear bytecode and its associated literal values."
        },
        {
          "id": "symbol-table",
          "title": "Symbol Table & Scope",
          "summary": "Defines the data structures for tracking variable names, stack slots, and scope nesting."
        },
        {
          "id": "instruction-format",
          "title": "Instruction Format",
          "summary": "Explains the opcode + operand encoding scheme for bytecode instructions."
        }
      ]
    },
    {
      "id": "component-design",
      "title": "5. Component Design",
      "summary": "Detailed breakdown of each major component, including mental models, ADRs, and implementation guidance.",
      "subsections": [
        {
          "id": "compiler-driver",
          "title": "5.1 Compiler Driver & Orchestration",
          "summary": "The main controller that initiates compilation by traversing the AST and delegating to specific compilers."
        },
        {
          "id": "expression-compiler",
          "title": "5.2 Expression Compiler (Milestone 1)",
          "summary": "Compiles AST nodes for literals, arithmetic, and comparisons into stack machine instructions."
        },
        {
          "id": "variable-compiler",
          "title": "5.3 Variable & Scope Compiler (Milestone 2)",
          "summary": "Manages variable declaration, assignment, and lookup using a symbol table with scoping."
        },
        {
          "id": "control-flow-compiler",
          "title": "5.4 Control Flow Compiler (Milestone 3)",
          "summary": "Compiles conditional branches and loops, managing forward/backward jump target resolution."
        },
        {
          "id": "function-compiler",
          "title": "5.5 Function Compiler (Milestone 4)",
          "summary": "Handles function definitions and calls, managing separate bytecode chunks, frames, and argument passing."
        },
        {
          "id": "bytecode-chunk",
          "title": "5.6 Bytecode Chunk & Constant Pool Manager",
          "summary": "The low-level builder for the linear instruction stream and associated constant data."
        },
        {
          "id": "symbol-table-component",
          "title": "5.7 Symbol Table Manager",
          "summary": "Tracks variable names, their stack indices, and scope hierarchy."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "6. Interactions and Data Flow",
      "summary": "Traces the step-by-step journey of compiling a simple program, showing how components interact.",
      "subsections": [
        {
          "id": "sequence-walkthrough",
          "title": "Compilation Sequence Walkthrough",
          "summary": "Walks through the compilation of a sample program, step-by-step."
        },
        {
          "id": "data-flow-table",
          "title": "Data Flow Between Components",
          "summary": "Table showing component inputs and outputs during key operations."
        }
      ]
    },
    {
      "id": "error-handling-edge-cases",
      "title": "7. Error Handling and Edge Cases",
      "summary": "Strategies for detecting and reporting compilation errors, and handling tricky language edge cases.",
      "subsections": [
        {
          "id": "error-types",
          "title": "Error Detection & Reporting",
          "summary": "Categorizes errors (syntax, semantic, runtime) and suggests simple reporting mechanisms."
        },
        {
          "id": "edge-case-handling",
          "title": "Edge Cases and Their Handling",
          "summary": "Discusses how to handle variable shadowing, empty blocks, nested loops, and other edge cases."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "8. Testing Strategy",
      "summary": "Provides a testing approach, including unit tests, integration tests, and milestone verification checkpoints.",
      "subsections": [
        {
          "id": "testing-approach",
          "title": "Testing Approach & Tools",
          "summary": "Recommends a testing pyramid and tools suitable for the primary language (Python)."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "For each milestone, describes what to test and the expected output to confirm correct implementation."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "9. Debugging Guide",
      "summary": "A practical guide to diagnosing and fixing common bugs encountered during compiler implementation.",
      "subsections": [
        {
          "id": "common-bugs-table",
          "title": "Common Bug Table: Symptom \u2192 Cause \u2192 Fix",
          "summary": "Table listing frequent issues like wrong evaluation order, incorrect jump offsets, and scope errors."
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques & Tools",
          "summary": "Suggests techniques like printing the stack, disassembling bytecode, and tracing execution."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "10. Future Extensions",
      "summary": "Ideas for extending the compiler beyond the core project, showing how the design accommodates growth.",
      "subsections": [
        {
          "id": "extension-ideas",
          "title": "Potential Extension Ideas",
          "summary": "Lists advanced features like closures, classes, optimizations (constant folding, peephole), and native functions."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "11. Glossary",
      "summary": "Definitions of key technical terms, acronyms, and domain-specific vocabulary used in this document.",
      "subsections": [
        {
          "id": "terms-table",
          "title": "Glossary of Terms",
          "summary": "Alphabetical table of terms like AST, Bytecode, Constant Pool, Opcode, and Stack Frame."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-component",
      "title": "System Component Diagram",
      "description": "Shows the main components (Compiler, Chunk, ConstantPool, SymbolTable) and their relationships. Arrows indicate data flow (e.g., AST -> Compiler, Compiler writes to Chunk).",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "component-design"
      ]
    },
    {
      "id": "data-model-diagram",
      "title": "Data Model: Chunk & Related Structures",
      "description": "Shows the Chunk containing a list of Instructions and a reference to a ConstantPool. An Instruction has an opcode and optional operand. The SymbolTable contains Scopes, which map names to Slots.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "compile-sequence",
      "title": "Sequence Diagram: Compiling an Expression",
      "description": "Shows the interaction between the Compiler Driver, Expression Compiler, and Bytecode Chunk when compiling '1 + 2 * 3'. Includes steps: visiting nodes, writing LOAD_CONST and ADD/MUL instructions.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "component-design"
      ]
    },
    {
      "id": "scope-state-machine",
      "title": "State Machine: Scope Management",
      "description": "Shows states for the compiler's scope (Global, InFunction, InBlock) and transitions triggered by events like 'enter block', 'declare variable', 'exit block'.",
      "type": "state-machine",
      "relevant_sections": [
        "component-design",
        "variable-compiler"
      ]
    },
    {
      "id": "jump-patching-flowchart",
      "title": "Flowchart: Forward Jump Target Patching",
      "description": "Illustrates the process for handling a forward jump (like in an if statement). Steps: 1. Emit JUMP_IF_FALSE with placeholder operand, 2. Compile then-block, 3. Calculate offset, 4. Patch the placeholder.",
      "type": "flowchart",
      "relevant_sections": [
        "component-design",
        "control-flow-compiler"
      ]
    },
    {
      "id": "function-call-sequence",
      "title": "Sequence Diagram: Function Call & Return",
      "description": "Shows the interaction during a function call: Caller pushes arguments, emits CALL, VM creates new Frame, executes function body, RETURN pops frame and pushes value back to caller's stack.",
      "type": "sequence",
      "relevant_sections": [
        "component-design",
        "function-compiler",
        "interactions-data-flow"
      ]
    }
  ]
}