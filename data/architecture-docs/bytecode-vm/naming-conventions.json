{
  "types": {
    "Byte": "alias for uint8_t",
    "Value": "fields: type ValueType, union as number double, boolean bool",
    "Chunk": "fields: code ByteArray, constants ValueArray",
    "VM": "fields: operand_stack ValueArray, frames CallFrameArray, frame_count int, stack Value*, stack_top int, stack_capacity int, state InterpretResult, error_message char[256], last_error_ip int",
    "CallFrame": "fields: chunk Chunk*, ip Byte*, fp int",
    "Array": "macro-generated struct: count int, capacity int, data pointer",
    "ByteArray": "fields: count int, capacity int, data Byte*",
    "ValueArray": "fields: count int, capacity int, data Value*",
    "CallFrameArray": "fields: count int, capacity int, data CallFrame*",
    "OpCode": "enumeration of instruction types",
    "InterpretResult": "enumeration with values INTERPRET_OK, INTERPRET_RUNTIME_ERROR",
    "Obj": "fields: type ObjType, next Obj*, marked bool",
    "ObjString": "fields: obj Obj, length int, chars char*"
  },
  "methods": {
    "initVM(VM* vm)": "initializes VM state with empty stack",
    "freeVM(VM* vm)": "frees VM resources",
    "interpret(VM* vm, Chunk* chunk) returns InterpretResult": "main entry point, resets error state before execution",
    "run(VM* vm) returns InterpretResult": "core execution loop with error checking after each instruction",
    "push(VM* vm, Value value)": "checks for stack overflow before pushing",
    "pop(VM* vm) returns Value": "checks for stack underflow before popping",
    "peek(VM* vm, int distance) returns Value": "returns a value from the stack at given distance from top",
    "ensureArrayCapacity(void** data, int* count, int* capacity, size_t elementSize)": "ensures a dynamic array has capacity for at least one more element",
    "initChunk(Chunk* chunk)": "initializes a chunk's fields to empty/default",
    "freeChunk(Chunk* chunk)": "frees the dynamically allocated code and constants arrays",
    "writeChunk(Chunk* chunk, Byte byte)": "appends a byte to the chunk's code array, growing it if necessary",
    "addConstant(Chunk* chunk, Value value) returns int": "appends a value to the chunk's constant pool and returns its index",
    "ensureArrayCapacity(void** data, int* count, int* capacity, size_t elementSize, int minCapacity)": "ensures dynamic array has at least minCapacity elements",
    "interpret(VM* vm, const Chunk* chunk) returns InterpretResult": "main entry point to execute a chunk",
    "isFalsey(Value value) returns bool": "helper to determine if a value is falsey (false or nil)",
    "pushFrame(VM* vm, CallFrame frame)": "adds a call frame to the frame stack",
    "popFrame(VM* vm) returns CallFrame": "removes and returns the top call frame",
    "dumpVMState(VM* vm)": "prints complete VM state for debugging",
    "runtimeError(VM* vm, const char* format, ...)": "formats error message and sets VM error state",
    "traceExecution(VM* vm, Byte* ip, const char* opcodeName, int operand)": "logs execution of a single instruction",
    "disassembleInstruction(Chunk* chunk, int offset)": "disassembles instruction at given offset",
    "printValue(Value value)": "prints a Value to stdout",
    "collectGarbage(VM* vm)": "performs mark-and-sweep garbage collection",
    "markObject(Obj* obj)": "marks an object as reachable",
    "markValue(Value value)": "marks a value if it contains an object reference",
    "markRoots(VM* vm)": "marks all roots (stack, frames, globals)",
    "traceReferences(VM* vm)": "traces all references starting from roots",
    "sweep(VM* vm)": "frees unmarked objects",
    "allocateString(VM* vm, const char* chars, int length) returns ObjString*": "allocates a string object",
    "printObject(Value value)": "prints an object value"
  },
  "constants": {
    "OP_CONSTANT": "instruction to load a constant",
    "OP_ADD": "instruction to add two numbers",
    "OP_HALT": "instruction to stop execution",
    "OP_JUMP": "unconditional jump forward",
    "OP_JUMP_IF_FALSE": "conditional jump forward if top of stack is false",
    "OP_CALL": "call a function",
    "OP_RETURN": "return from a function",
    "OP_GET_LOCAL": "load local variable",
    "OP_SET_LOCAL": "store local variable",
    "FRAMES_MAX": "maximum depth of the call frame stack",
    "STACK_INITIAL_CAPACITY": "initial capacity of the operand stack array (not explicitly defined but referenced)",
    "INTERPRET_OK": "VM execution completed successfully",
    "INTERPRET_RUNTIME_ERROR": "VM encountered a runtime error",
    "VAL_NUMBER": "ValueType enum value for number",
    "VAL_BOOL": "ValueType enum value for boolean",
    "VAL_NIL": "ValueType enum value for nil",
    "OP_SUBTRACT": "instruction to subtract",
    "OP_MULTIPLY": "instruction to multiply",
    "OP_DIVIDE": "instruction to divide",
    "OP_NEGATE": "instruction to negate a number",
    "OP_NOT": "instruction to apply logical NOT",
    "OP_EQUAL": "instruction to compare equality",
    "OP_GREATER": "instruction to compare greater than",
    "OP_LESS": "instruction to compare less than",
    "OP_LOOP": "unconditional jump backward (for loops)",
    "TRACE_EXECUTION": "compile-time flag to enable execution tracing",
    "VAL_OBJ": "ValueType enum value for object reference",
    "OBJ_STRING": "ObjType enum value for string object",
    "GC_HEAP_GROW_FACTOR": "multiplier for next GC threshold (e.g., 2)"
  },
  "terms": {
    "Virtual Machine (VM)": "software simulation of a CPU that executes bytecode",
    "Bytecode": "a sequence of instructions for a virtual machine",
    "Opcode": "a single byte identifying an operation",
    "Operand": "data bytes following an opcode that provide its arguments",
    "Operand Stack": "last-in, first-out stack used for intermediate calculations",
    "Fetch-Decode-Execute Cycle": "the core loop of a VM: read an instruction, interpret it, perform it",
    "constant pool": "array of constant values referenced by index in bytecode",
    "call frame": "activation record storing execution state for one function call",
    "frame pointer": "stack index marking the start of a function's local variables",
    "instruction pointer": "pointer to the next bytecode instruction to execute",
    "activation record": "synonym for call frame",
    "Value": "tagged union representing numbers, booleans, and nil",
    "Chunk": "container for bytecode instructions and constant pool",
    "VM": "virtual machine state including operand stack, call frames, and instruction pointer",
    "CallFrame": "activation record for a function call, storing chunk pointer, instruction offset, and frame pointer",
    "dynamic array": "resizable array with count, capacity, and data pointer",
    "tagged union": "struct containing a type tag and a union of possible value types",
    "bytecode": "a sequence of instructions for a virtual machine",
    "opcode": "a single byte identifying an operation",
    "operand": "data bytes following an opcode that provide its arguments",
    "little-endian": "byte order where the least significant byte comes first",
    "operand stack": "last-in, first-out stack used for intermediate calculations",
    "fetch-decode-execute cycle": "the core loop of a VM: read an instruction, interpret it, perform it",
    "stack underflow": "attempting to pop from an empty stack",
    "stack overflow": "exceeding the maximum capacity of the stack",
    "instruction pointer (IP)": "pointer to the next bytecode instruction to execute",
    "relative offset": "signed integer representing how many bytes to move forward or backward from the current instruction position",
    "conditional jump": "jump that occurs only if a runtime condition is met",
    "back-edge": "a jump backward in the bytecode, typically used for loops",
    "falsey": "a value that evaluates to false in a boolean context (in our VM: false boolean and nil)",
    "arity": "number of arguments a function expects",
    "calling convention": "agreed-upon protocol for how arguments are passed and results returned",
    "frame pointer (fp)": "stack index marking the start of a function's local variables",
    "instruction pointer (ip)": "pointer to the next bytecode instruction to execute",
    "data flow": "movement of values between VM components during execution",
    "unified stack architecture": "design where local variables and intermediate values share the same Value array",
    "recursive unwinding": "process of returning from nested function calls in reverse order",
    "runtime error": "error detected during bytecode execution (stack underflow, invalid jump, type mismatch)",
    "error propagation": "process of detecting an error and halting execution with diagnostic information",
    "buffer overflow": "writing more data to a fixed-size buffer than it can hold",
    "type checking": "verifying operand types match instruction expectations at runtime",
    "stack trace": "snapshot of call frames active when an error occurred",
    "graceful degradation": "VM halts execution cleanly with error report instead of crashing",
    "execution tracing": "logging each instruction as it executes, showing opcode and stack state",
    "stack dumping": "printing the current contents of the operand stack and call frames",
    "offset": "byte distance from the start of a chunk's code array",
    "garbage collection": "automatic memory management that reclaims unreachable objects",
    "mark-and-sweep": "GC algorithm that marks reachable objects then sweeps unmarked ones",
    "root set": "directly accessible values (stack, globals) from which all reachable objects are found",
    "stop-the-world": "GC that pauses all program execution during collection",
    "object header": "metadata at start of heap object (type, GC info)",
    "reachable": "object accessible via chain of references from roots",
    "tracing": "following references from roots to find all reachable objects",
    "Byte": "alias for uint8_t",
    "OpCode": "enumeration of instruction types",
    "InterpretResult": "enumeration with values INTERPRET_OK, INTERPRET_RUNTIME_ERROR",
    "Array": "macro-generated struct: count int, capacity int, data pointer",
    "Opcodes": "a single byte identifying an operation",
    "Constant Pool": "array of constant values referenced by index in bytecode",
    "Call Frame": "activation record storing execution state for one function call",
    "Frame Pointer": "stack index marking the start of a function's local variables",
    "Instruction Pointer": "pointer to the next bytecode instruction to execute",
    "Activation Record": "synonym for call frame",
    "Dynamic Array": "resizable array with count, capacity, and data pointer",
    "Tagged Union": "struct containing a type tag and a union of possible value types",
    "Little-endian": "byte order where the least significant byte comes first",
    "Stack Underflow": "attempting to pop from an empty stack",
    "Stack Overflow": "exceeding the maximum capacity of the stack",
    "Relative Offset": "signed integer representing how many bytes to move forward or backward from the current instruction position",
    "Conditional Jump": "jump that occurs only if a runtime condition is met",
    "Back-edge": "a jump backward in the bytecode, typically used for loops",
    "Falsey": "a value that evaluates to false in a boolean context (in our VM: false boolean and nil)",
    "Arity": "number of arguments a function expects",
    "Calling Convention": "agreed-upon protocol for how arguments are passed and results returned",
    "Data Flow": "movement of values between VM components during execution",
    "Unified Stack Architecture": "design where local variables and intermediate values share the same Value array",
    "Recursive Unwinding": "process of returning from nested function calls in reverse order",
    "Runtime Error": "error detected during bytecode execution (stack underflow, invalid jump, type mismatch)",
    "Error Propagation": "process of detecting an error and halting execution with diagnostic information",
    "Type Checking": "verifying operand types match instruction expectations at runtime",
    "Stack Trace": "snapshot of call frames active when an error occurred",
    "Graceful Degradation": "VM halts execution cleanly with error report instead of crashing",
    "Execution Tracing": "logging each instruction as it executes, showing opcode and stack state",
    "Stack Dumping": "printing the current contents of the operand stack and call frames",
    "Offset": "byte distance from the start of a chunk's code array",
    "Garbage Collection": "automatic memory management that reclaims unreachable objects",
    "Mark-and-Sweep": "GC algorithm that marks reachable objects then sweeps unmarked ones",
    "Root Set": "directly accessible values (stack, globals) from which all reachable objects are found",
    "Stop-the-World": "GC that pauses all program execution during collection",
    "Object Header": "metadata at start of heap object (type, GC info)",
    "Reachable": "object accessible via chain of references from roots",
    "Tracing": "following references from roots to find all reachable objects"
  }
}