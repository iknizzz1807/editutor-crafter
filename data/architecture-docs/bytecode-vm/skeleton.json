{
  "title": "Bytecode Virtual Machine: Design Document",
  "overview": "This document outlines the design of a stack-based virtual machine (VM) that interprets and executes a custom bytecode instruction set. The key architectural challenge is designing a simple yet extensible execution model that correctly manages program state (stack, frames, instruction pointer) and control flow, providing a foundational learning experience in low-level program execution.",
  "sections": [
    {
      "id": "context-and-problem-statement",
      "title": "Context and Problem Statement",
      "summary": "Introduces the core problem of executing programs on a software-defined CPU, explaining the need for a virtual machine and contrasting different execution models like interpreters and stack vs. register machines.",
      "subsections": [
        {
          "id": "mental-model-the-toy-factory",
          "title": "Mental Model: The Toy Factory",
          "summary": "Uses the analogy of a factory worker following a punch card recipe to assemble toys, paralleling the VM's fetch-decode-execute cycle and instruction stream."
        },
        {
          "id": "the-core-problem",
          "title": "The Core Problem: Software Execution",
          "summary": "Explains the need to execute a sequence of simple operations in a controlled environment, independent of the host CPU's native instruction set."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches",
          "summary": "Compares tree-walk interpreters, stack-based VMs, and register-based VMs using a structured table of pros and cons."
        }
      ]
    },
    {
      "id": "goals-and-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the explicit scope of the project: what must be implemented (core VM, stack, control flow, functions) and what is out of scope (garbage collection, JIT compilation, complex types).",
      "subsections": [
        {
          "id": "goals-list",
          "title": "Goals",
          "summary": "List of required capabilities, aligned with the project milestones."
        },
        {
          "id": "non-goals-list",
          "title": "Non-Goals",
          "summary": "List of explicit exclusions to keep the project focused and intermediate-level."
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Provides a bird's-eye view of the VM's main components (VM State, Bytecode Chunk, Stack, Call Frame) and how data flows between them during execution. Includes a recommended C file structure.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Describes the responsibility of each major component: VM, Chunk, Stack, Frame."
        },
        {
          "id": "recommended-file-structure",
          "title": "Recommended File Structure",
          "summary": "Suggests a C module structure (vm.h, vm.c, chunk.h, chunk.c, etc.) to organize the codebase logically."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the core data structures (Value, Chunk, VM, CallFrame) as tables, explaining their fields, types, and relationships. Covers Milestone 1.",
      "subsections": [
        {
          "id": "value-type",
          "title": "The Value Type",
          "summary": "Describes the tagged union for representing numbers, booleans, and nil in the VM."
        },
        {
          "id": "bytecode-chunk",
          "title": "Bytecode Chunk Structure",
          "summary": "Details the Chunk struct which holds the instruction byte array and constant pool."
        },
        {
          "id": "vm-state",
          "title": "VM State Structure",
          "summary": "Details the VM struct which holds the operand stack, call frame stack, and runtime state."
        },
        {
          "id": "call-frame",
          "title": "Call Frame Structure",
          "summary": "Details the CallFrame struct for managing function activation records."
        }
      ]
    },
    {
      "id": "component-bytecode-format",
      "title": "Component Design: Bytecode Format & Instruction Set",
      "summary": "Details the design of the bytecode instruction format (opcode + operands) and the constant pool. Covers Milestone 1.",
      "subsections": [
        {
          "id": "mental-model-punch-cards",
          "title": "Mental Model: Punch Cards",
          "summary": "Analogy of instructions as holes in a punch card, where the first hole determines the operation and subsequent holes provide data."
        },
        {
          "id": "opcode-enumeration",
          "title": "Opcodes and Operands",
          "summary": "Defines the instruction set (OP_CONSTANT, OP_ADD, OP_JUMP, etc.) and how operands are encoded in the byte stream."
        },
        {
          "id": "adr-bytecode-format",
          "title": "ADR: Bytecode Instruction Format",
          "summary": "Decision record for choosing a variable-length instruction format over a fixed-length one."
        },
        {
          "id": "common-pitfalls-bytecode",
          "title": "Common Pitfalls",
          "summary": "Lists common mistakes like forgetting the HALT instruction, operand encoding issues, and endianness."
        },
        {
          "id": "implementation-guidance-bytecode",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for a dynamic array utility (infrastructure) and skeleton code with TODOs for writing and reading bytecode chunks."
        }
      ]
    },
    {
      "id": "component-execution-engine",
      "title": "Component Design: Execution Engine & Operand Stack",
      "summary": "Describes the core fetch-decode-execute loop and the design of the operand stack. Covers Milestone 2.",
      "subsections": [
        {
          "id": "mental-model-cafeteria-tray-stack",
          "title": "Mental Model: Cafeteria Tray Stack",
          "summary": "Analogy of the operand stack as a spring-loaded stack of trays, where operations take trays from the top, combine them, and put a new tray back."
        },
        {
          "id": "fetch-decode-execute",
          "title": "The Fetch-Decode-Execute Cycle",
          "summary": "Step-by-step algorithm for the main VM loop."
        },
        {
          "id": "adr-stack-vs-register",
          "title": "ADR: Stack-Based vs. Register-Based VM",
          "summary": "Decision record justifying the choice of a stack-based architecture for simplicity and educational value."
        },
        {
          "id": "common-pitfalls-stack",
          "title": "Common Pitfalls",
          "summary": "Lists stack underflow/overflow, operand order for subtraction/division, and incorrect IP advancement."
        },
        {
          "id": "implementation-guidance-engine",
          "title": "Implementation Guidance",
          "summary": "Provides starter code for a generic Value stack (infrastructure) and skeleton code with TODOs for the VM loop and arithmetic instruction handlers."
        }
      ]
    },
    {
      "id": "component-control-flow",
      "title": "Component Design: Control Flow",
      "summary": "Details the implementation of jumps (conditional and unconditional) for loops and conditionals. Covers Milestone 3.",
      "subsections": [
        {
          "id": "mental-model-choose-your-own-adventure",
          "title": "Mental Model: Choose Your Own Adventure Book",
          "summary": "Analogy of jump instructions as \"turn to page X\" commands, with conditional jumps checking a true/false condition first."
        },
        {
          "id": "jump-mechanics",
          "title": "Jump Instruction Mechanics",
          "summary": "Algorithm for processing jump instructions, including offset calculation and bounds checking."
        },
        {
          "id": "adr-absolute-vs-relative-jumps",
          "title": "ADR: Absolute vs. Relative Jump Offsets",
          "summary": "Decision record for choosing relative jump offsets for position-independent code within a chunk."
        },
        {
          "id": "common-pitfalls-jumps",
          "title": "Common Pitfalls",
          "summary": "Lists infinite loops from incorrect back-edges, forgetting to pop the condition value, and miscalculating jump offsets."
        },
        {
          "id": "implementation-guidance-control-flow",
          "title": "Implementation Guidance",
          "summary": "Skeleton code with TODOs for the jump instruction handlers and IP manipulation logic."
        }
      ]
    },
    {
      "id": "component-functions-frames",
      "title": "Component Design: Functions & Call Frames",
      "summary": "Explains the call frame stack model for managing local variables, arguments, and return addresses. Covers Milestone 4.",
      "subsections": [
        {
          "id": "mental-model-stack-of-notebooks",
          "title": "Mental Model: Stack of Notebooks",
          "summary": "Analogy of each function call as opening a new notebook (frame) on top of a pile. You write in the top notebook, close it when done, and resume in the one below."
        },
        {
          "id": "call-return-mechanics",
          "title": "Call and Return Mechanics",
          "summary": "Step-by-step algorithm for the CALL instruction (pushing a frame) and the RETURN instruction (popping a frame)."
        },
        {
          "id": "local-variable-access",
          "title": "Local Variable Access",
          "summary": "Describes how local variables are indexed relative to a frame's base pointer."
        },
        {
          "id": "adr-call-frame-design",
          "title": "ADR: Call Frame Design",
          "summary": "Decision record for storing local variables and the stack in the same contiguous Value array versus separate arrays."
        },
        {
          "id": "common-pitfalls-functions",
          "title": "Common Pitfalls",
          "summary": "Lists incorrect frame pointer calculation, mishandling return values, and argument passing order issues."
        },
        {
          "id": "implementation-guidance-functions",
          "title": "Implementation Guidance",
          "summary": "Skeleton code with TODOs for the CALL and RETURN instruction handlers, and frame management logic."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Traces the step-by-step flow of executing a simple program (e.g., a function call with arithmetic) through all components, showing how data moves.",
      "subsections": [
        {
          "id": "sequence-example",
          "title": "Example: Executing a Simple Program",
          "summary": "Walks through the execution of a bytecode sequence that includes a function call, showing state changes in the stack and frames."
        }
      ]
    },
    {
      "id": "error-handling-edge-cases",
      "title": "Error Handling and Edge Cases",
      "summary": "Categorizes runtime errors (stack overflow, invalid jump, type errors) and defines strategies for detection and graceful reporting.",
      "subsections": [
        {
          "id": "error-categories",
          "title": "Error Categories",
          "summary": "Lists and describes runtime errors the VM must detect."
        },
        {
          "id": "error-reporting-strategy",
          "title": "Error Reporting Strategy",
          "summary": "Describes a simple error code/enum system to report errors from the VM to the user."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Provides a testing approach, including unit tests for components and integration tests for full programs. Includes a checkpoint table for each milestone.",
      "subsections": [
        {
          "id": "testing-approach",
          "title": "Testing Approach",
          "summary": "Recommends writing small C programs that use the VM API to test specific instructions and sequences."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "A table listing, for each milestone, the command to run and the expected output/behavior to verify correct implementation."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "A symptom-cause-fix table for common bugs learners encounter, along with specific debugging techniques like tracing and stack dumping.",
      "subsections": [
        {
          "id": "symptom-cause-fix-table",
          "title": "Symptom \u2192 Cause \u2192 Fix Table",
          "summary": "Structured table for common issues like \"VM crashes\", \"Wrong calculation result\", \"Infinite loop\"."
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques",
          "summary": "Suggests adding a trace execution flag to log each instruction, and a function to print the current stack state."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Suggests potential enhancements like garbage collection, native function bindings, or a compiler frontend, explaining how the current design accommodates them.",
      "subsections": [
        {
          "id": "extension-ideas",
          "title": "Extension Ideas",
          "summary": "List of possible future features with a brief note on design impact."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key terms used throughout the document (Bytecode, Opcode, Operand Stack, Call Frame, etc.).",
      "subsections": [
        {
          "id": "terms",
          "title": "Term Definitions",
          "summary": "Alphabetical list of terms, their definitions, and the section where they first appear."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "system-component-diagram",
      "title": "System Component Diagram",
      "description": "Shows the main components of the VM system (VM State, Bytecode Chunk, Operand Stack, Call Frame Stack) and their relationships (reads from, writes to).",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture"
      ]
    },
    {
      "id": "data-model-diagram",
      "title": "Data Model / Type Relationship Diagram",
      "description": "Shows the key C structs (VM, Chunk, CallFrame, Value) and their fields, illustrating composition (e.g., VM contains a stack of Values and an array of CallFrames).",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "vm-state-machine",
      "title": "VM Runtime State Machine",
      "description": "Shows the VM's execution states (READY, RUNNING, HALTED, ERROR) and transitions between them (start, fetch/execute, halt instruction, runtime error).",
      "type": "state-machine",
      "relevant_sections": [
        "component-execution-engine"
      ]
    },
    {
      "id": "function-call-sequence",
      "title": "Function Call Sequence Diagram",
      "description": "Sequence diagram showing the interaction between the VM, the operand stack, and the call frame stack during a CALL instruction, execution of the function body, and a RETURN.",
      "type": "sequence",
      "relevant_sections": [
        "component-functions-frames",
        "interactions-data-flow"
      ]
    },
    {
      "id": "fetch-decode-execute-flowchart",
      "title": "Fetch-Decode-Execute Cycle Flowchart",
      "description": "A detailed flowchart of the main VM loop, including steps: fetch opcode, decode, switch on opcode, execute handler (which may manipulate IP/stack), check for HALT/ERROR, loop.",
      "type": "flowchart",
      "relevant_sections": [
        "component-execution-engine"
      ]
    },
    {
      "id": "instruction-encoding-layout",
      "title": "Bytecode Instruction Encoding Layout",
      "description": "Visual representation of how different instruction types are packed into bytes. Shows: 1-byte opcode, variable-length operand bytes (e.g., 1-byte constant index, 2-byte jump offset).",
      "type": "component",
      "relevant_sections": [
        "component-bytecode-format"
      ]
    },
    {
      "id": "stack-frame-memory-layout",
      "title": "Stack and Frame Memory Layout",
      "description": "Diagram showing how the single Value array is partitioned between the operand stack and local variable slots for multiple active call frames.",
      "type": "component",
      "relevant_sections": [
        "component-functions-frames",
        "adr-call-frame-design"
      ]
    }
  ]
}