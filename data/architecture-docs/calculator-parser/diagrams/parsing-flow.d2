title: Parsing Expression Flowchart
direction: right

classes: {
  function: {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  decision: {
    shape: diamond
    style.fill: "#16213e"
    style.stroke: "#e17055"
    style.font-color: "#e6edf3"
  }
  process: {
    shape: rectangle
    style.fill: "#0f3460"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  terminal: {
    shape: rectangle
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.double-border: true
    style.font-color: "#e6edf3"
  }
  error: {
    shape: rectangle
    style.fill: "#2d0f0f"
    style.stroke: "#ff6b6b"
    style.font-color: "#ffcccc"
  }
}

# Main parsing flow
start: "parse_expression(min_precedence=0)" {
  class: function

  parse_primary: "parse_primary()" {
    class: function
  }

  left_node: "left = parse_primary()" {
    class: process
  }

  while_check: "Current token is binary operator?" {
    class: decision
  }

  get_prec: "Get operator precedence" {
    class: process
  }

  prec_check: "op_prec >= min_precedence?" {
    class: decision
  }

  consume_op: "Consume operator token" {
    class: process
  }

  next_min: "next_min = op_prec + (1 if left-assoc else 0)" {
    class: process
  }

  recursive_call: "right = parse_expression(next_min)" {
    class: function
  }

  create_node: "left = BinaryNode(op, left, right)" {
    class: process
  }

  return_left: "Return left node" {
    class: terminal
  }

  parse_primary -> left_node: "First operand"
  left_node -> while_check: "Setup loop"
  while_check -> get_prec: "Yes"
  get_prec -> prec_check
  prec_check -> consume_op: "Yes"
  consume_op -> next_min
  next_min -> recursive_call
  recursive_call -> create_node
  create_node -> while_check: "Loop back"
  while_check -> return_left: "No"
  prec_check -> return_left: "No"
}

# Parse primary implementation
parse_primary_impl: "parse_primary()" {
  id: parse_primary-implementation
  class: function

  token_check: "Token type?" {
    class: decision
  }

  number: "Number token" {
    class: process
    consume_num: "Consume number"
    create_num: "Return NumberNode(value)"
    class: process
  }

  variable: "Variable token" {
    class: process
    consume_var: "Consume variable"
    create_var: "Return VariableNode(name)"
    class: process
  }

  left_paren: "Left parenthesis '('" {
    class: process
    consume_lp: "Consume '('"
    parse_expr: "expr = parse_expression(0)"
    expect_rp: "Expect ')'"
    create_paren: "Return expr"
    class: process
  }

  unary: "Unary operator (- or +)" {
    class: process
    consume_unary: "Consume operator"
    parse_operand: "operand = parse_primary()"
    create_unary: "Return UnaryNode(op, operand)"
    class: process
  }

  error_node: "Unexpected token" {
    class: error
    throw_error: "Throw ParseError"
  }

  token_check -> number: "NUMBER"
  token_check -> variable: "VARIABLE"
  token_check -> left_paren: "LPAREN"
  token_check -> unary: "UNARY_OP"
  token_check -> error_node: "Other"

  number -> consume_num -> create_num
  variable -> consume_var -> create_var
  left_paren -> consume_lp -> parse_expr -> expect_rp -> create_paren
  unary -> consume_unary -> parse_operand -> create_unary
}

# Connections between main flow and parse_primary
start.parse_primary -> parse_primary_impl.token_check: "Calls"
parse_primary_impl.number.create_num -> start.left_node: "Returns"
parse_primary_impl.variable.create_var -> start.left_node
parse_primary_impl.left_paren.create_paren -> start.left_node
parse_primary_impl.unary.create_unary -> start.left_node

# Recursive call note
recursive_note: "Recursive call back to parse_expression" {
  shape: text
  style.font-color: "#8b949e"
}

# Key notes
note: |md
  ## Precedence Climbing Algorithm
  - **Left-associative** (+, -, *, /): `next_min = op_prec + 1`
  - **Right-associative** (^): `next_min = op_prec`
  - Loop continues while `op_prec >= min_precedence`
  - **Base case**: `min_precedence = 0` for top-level
| {
  shape: page
  style.fill: "#1a1a2e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}
