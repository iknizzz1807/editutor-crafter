{
  "types": {
    "ServiceRegistration": "fields: ID string, Name string, Address string, Health string, LastSeen time.Time, Metadata map[string]string",
    "Registry": "fields: services map, mutex sync.RWMutex, done chan",
    "GatewayRouter": "fields: registry *Registry, rateLimiter *RateLimiter, circuitBreaker *CircuitBreaker, routes []CompiledRoute, grpcConns map[string]*grpc.ClientConn",
    "RouteTarget": "fields: ServiceName string, Timeout time.Duration, RetryPolicy RetryConfig",
    "DiscoveryClient": "fields: registryURL string, httpClient *http.Client, registration ServiceRegistration",
    "OrdersHandler": "fields: TBD by learner implementation",
    "SagaOrchestrator": "fields: TBD by learner implementation",
    "User": "fields: ID, Email, PasswordHash, FirstName, LastName, Address, CreatedAt, UpdatedAt, IsActive",
    "Product": "fields: ID, Name, Description, Price, Category, SKU, StockQuantity, ReservedQuantity, CreatedAt, UpdatedAt, IsActive",
    "Order": "fields: ID, UserID, Status, Items, SubTotal, Tax, Shipping, Total, ShippingAddress, PaymentID, CreatedAt, UpdatedAt",
    "Payment": "fields: ID, OrderID, UserID, Amount, Currency, Method, Status, ExternalTransactionID, ProcessedAt, FailureReason, RefundAmount, CreatedAt, UpdatedAt",
    "Address": "fields: Street, City, State, ZipCode, Country",
    "OrderItem": "fields: ProductID, Quantity, UnitPrice, TotalPrice",
    "TokenBucket": "fields: Capacity int, Tokens int, RefillRate int, LastRefill time.Time, Tier string, ClientID string",
    "RateLimiter": "fields: buckets map[string]*TokenBucket, tiers map[string]TierConfig, mutex sync.RWMutex, cleanupInterval time.Duration",
    "CircuitBreaker": "fields: services map[string]*ServiceCircuit, config CircuitBreakerConfig, mutex sync.RWMutex",
    "ServiceCircuit": "fields: serviceName string, state CircuitState, failureCount int, successCount int, lastFailureTime time.Time, nextAttempt time.Time, halfOpenRequests int",
    "CompiledRoute": "fields: Pattern *regexp.Regexp, Method string, Target RouteTarget, ParamNames []string",
    "GatewayConfig": "fields: Server ServerConfig, Discovery DiscoveryConfig, RateLimiting RateLimitConfig, CircuitBreaker CircuitBreakerConfig, Routes []RouteConfig",
    "TierConfig": "fields: RequestsPerMinute int, BurstCapacity int, MonthlyQuota int",
    "SagaStep": "fields: StepID string, StepName string, ServiceName string, Status StepStatus, RetryCount int, StartedAt time.Time, CompletedAt time.Time, ErrorDetails string",
    "Record": "fields: IdempotencyKey string, RequestHash string, Status Status, Response []byte, ErrorDetails string, CreatedAt time.Time, CompletedAt time.Time, ExpiresAt time.Time",
    "Cache": "fields: records map, mutex sync.RWMutex, ttl time.Duration",
    "OrderRequest": "fields: UserID string, Items []OrderItem, ShippingAddress Address, PaymentMethod string",
    "TraceContext": "fields: TraceID string, SpanID string, ParentID string, Flags byte",
    "Span": "fields: TraceID string, SpanID string, ParentID string, ServiceName string, Operation string, StartTime time.Time, EndTime *time.Time, Duration *time.Duration, Status SpanStatus, Tags map[string]interface{}, Events []SpanEvent",
    "SpanEvent": "fields: Timestamp time.Time, Name string, Data map[string]interface{}",
    "LogEntry": "fields: Timestamp time.Time, Level LogLevel, Service string, TraceID string, SpanID string, Message string, Fields map[string]interface{}, Error *ErrorDetails",
    "ErrorDetails": "fields: Code string, Details string, Stack string",
    "Logger": "fields: serviceName string, minLevel LogLevel",
    "ServiceMetrics": "fields: serviceName string, requestCount map[string]int64, errorCount map[string]int64, responseTimeSum map[string]int64, responseTimeBuckets map[string][]int64, mutex sync.RWMutex, startTime time.Time",
    "MetricsCollector": "fields: services map[string]*ServiceMetrics, mutex sync.RWMutex",
    "CanaryController": "fields: serviceName string, imageTag string, currentPhase int, trafficPercent int, startTime time.Time, rollbackTrigger chan bool, metricCollector *MetricsCollector, trafficRouter *TrafficRouter",
    "TrafficPhase": "fields: Percentage int, Duration time.Duration, Thresholds MetricThresholds",
    "MetricThresholds": "fields: ErrorRateMultiplier float64, LatencyIncrease float64, BusinessMetricDrop float64",
    "TrafficRouter": "fields: TBD by learner implementation",
    "RetryConfig": "fields: MaxAttempts int, BaseDelay time.Duration, MaxDelay time.Duration, BackoffMultiplier float64, JitterRange float64, RetryableErrors []string",
    "IdempotencyRecord": "fields: Key string, RequestHash string, Status IdempotencyStatus, Response []byte, ErrorDetails string, CreatedAt time.Time, CompletedAt time.Time, ExpiresAt time.Time",
    "TestDB": "fields: DB *sql.DB, Driver string, DSN string",
    "EventStore": "interface for append-only event persistence",
    "Event": "fields: StreamID string, EventType string, EventData []byte, Version int, Timestamp time.Time, TraceID string, UserID string, Metadata map[string]interface{}",
    "OrderAggregate": "reconstructs state from event stream",
    "ServiceMeshProxy": "replaces direct gRPC with mesh routing",
    "MeshPolicyConfig": "fields: ServiceName string, CircuitBreaker CircuitConfig, RetryPolicy RetryConfig, TimeoutPolicy TimeoutConfig, TrafficSplit []TrafficSplit",
    "TenantContext": "fields: TenantID string, SchemaName string, Permissions []string, Quotas map[string]int, CustomConfig map[string]string",
    "SLOMonitor": "fields: serviceName string, sloTargets map[string]SLOTarget, errorBudgets map[string]ErrorBudget, alertManager AlertManager",
    "SLOTarget": "fields: MetricName string, TargetValue float64, TimeWindow time.Duration, AlertWindows []AlertWindow",
    "ErrorBudget": "fields: TotalBudget float64, ConsumedBudget float64, BurnRate float64, TimeToExhaust time.Duration, LastCalculated time.Time",
    "DisasterRecoveryOrchestrator": "coordinates service restoration",
    "RecoveryPlan": "fields: TriggerConditions []FailureCondition, RecoverySteps []RecoveryStep, ValidationChecks []ValidationCheck, RollbackPlan []RecoveryStep"
  },
  "methods": {
    "Register(ServiceRegistration)": "adds service instance to registry",
    "Resolve(serviceName) []ServiceRegistration": "returns healthy instances of specified service",
    "ServeHTTP(w, r)": "handles HTTP requests and routes to services",
    "DetermineRoute(path) (RouteTarget, error)": "maps request paths to target services",
    "CreateOrder(ctx, req)": "initiates order creation saga",
    "GetOrder(ctx, req)": "retrieves order status and details",
    "ExecuteOrderSaga(ctx, orderID, userID, items)": "runs complete order processing saga",
    "CompensateOrderSaga(ctx, sagaID, lastStep)": "reverses completed saga steps",
    "StartHeartbeat(ctx)": "begins periodic health updates to registry",
    "Deregister()": "removes service instance from registry",
    "StartCleanup()": "begins background cleanup of stale instances",
    "AuthenticateUser(email, password) returns AuthenticateResponse": "validates user credentials and returns user info",
    "GetUser(userID) returns User": "retrieves user profile by ID",
    "CreateUser(userProfile) returns CreateUserResponse": "registers new user account",
    "ValidateUser(userID) returns ValidateUserResponse": "checks if user exists and is active",
    "GetProduct(productID) returns Product": "fetches single product details",
    "ReserveInventory(orderID, items) returns ReserveInventoryResponse": "holds inventory for pending order",
    "ReleaseInventory(orderID) returns ReleaseInventoryResponse": "frees previously reserved inventory",
    "CreateOrder(userID, items, address) returns CreateOrderResponse": "initiates new order saga",
    "ProcessPayment(orderID, amount, paymentMethod) returns ProcessPaymentResponse": "charges payment method for order",
    "IsAllowed(clientID, tier) bool": "checks if client request should be allowed based on rate limits",
    "IsCallAllowed(serviceName) bool": "determines if circuit breaker allows calls to service",
    "RecordSuccess(serviceName)": "updates circuit breaker with successful call metrics",
    "RecordFailure(serviceName)": "updates circuit breaker with failed call metrics",
    "translateRequest(r, route, pathParams) (interface{}, error)": "converts HTTP request to gRPC format",
    "translateResponse(grpcResp, grpcErr) ([]byte, int, error)": "converts gRPC response to HTTP format",
    "refillBucket(bucket)": "adds tokens to rate limit bucket based on elapsed time",
    "getBucket(clientID, tier) *TokenBucket": "retrieves or creates rate limit bucket for client",
    "HashRequest(requestData) string": "generates SHA-256 hash of request data",
    "Check(key, requestHash) (*Record, bool, error)": "examines whether operation has been processed",
    "Start(key, requestHash) error": "marks beginning of idempotent operation",
    "Complete(key, response) error": "marks operation as successfully completed",
    "Fail(key, errorDetails) error": "marks operation as failed",
    "ParseTraceParent(traceparent string) (*TraceContext, error)": "parses W3C traceparent header format",
    "GenerateTraceID() string": "creates new random 128-bit trace ID",
    "GenerateSpanID() string": "creates new random 64-bit span ID",
    "CreateTraceParent() string": "builds W3C traceparent header value",
    "NewSpan(serviceName, operation string) *Span": "creates child span with current context as parent",
    "ExtractTraceContext(ctx context.Context) (*TraceContext, bool)": "retrieves trace context from request context",
    "ExtractCurrentSpan(ctx context.Context) (*Span, bool)": "retrieves active span from request context",
    "InjectTraceHeaders(ctx context.Context, req *http.Request)": "adds W3C trace context headers to outbound requests",
    "WithContext(ctx context.Context) *LogEntry": "creates log entry with trace correlation from context",
    "RecordRequest(serviceName, method, path string)": "increments request count for service operation",
    "RecordError(serviceName, method, path string)": "increments error count for service operation",
    "RecordResponseTime(serviceName, method, path string, duration time.Duration)": "records response time for percentile calculations",
    "GetServiceMetrics(serviceName string) map[string]interface{}": "returns current metrics for a service",
    "StartCanaryDeployment(ctx) error": "initiates gradual traffic shifting with automated monitoring",
    "ShiftTrafficToCanary(percentage) error": "updates load balancer to route specified percentage to new version",
    "MonitorMetrics(ctx)": "continuously checks deployment health and triggers rollback if needed",
    "ExecuteRollback(reason) error": "immediately reverts traffic to previous stable version",
    "ExecuteWithRetry(ctx, operation, config, budget) error": "implements exponential backoff with jitter and budget tracking",
    "RecoverFailedSaga(ctx, sagaID) error": "attempts to recover a saga that failed during execution",
    "CompensateCompletedSteps(ctx, sagaID, completedSteps) error": "executes compensation actions for successfully completed saga steps",
    "NewInMemoryDB(t *testing.T) *TestDB": "creates SQLite in-memory database for fast unit tests",
    "NewPostgresTestDB(t *testing.T) *TestDB": "creates PostgreSQL database for integration tests",
    "RunMigrations(t *testing.T, migrationSQL string)": "applies database schema migrations",
    "AppendEvents(ctx, streamID, expectedVersion, events) error": "atomically appends events to stream",
    "ReadEvents(ctx, streamID, fromVersion) ([]Event, error)": "returns ordered events from stream",
    "HandleCreateOrder(ctx, cmd) error": "processes command and generates events",
    "CreateOrder(ctx, req) (*CreateOrderResponse, error)": "tenant-aware order creation"
  },
  "constants": {
    "HEALTH_CHECK_INTERVAL": "15 seconds for periodic health reporting",
    "SERVICE_TIMEOUT": "30 seconds for service calls",
    "CircuitClosed": "circuit breaker closed state allowing requests",
    "CircuitOpen": "circuit breaker open state blocking requests",
    "CircuitHalfOpen": "circuit breaker half-open state testing service recovery",
    "SagaInitiated": "saga started state",
    "UserValidated": "user validation completed state",
    "InventoryReserved": "inventory reservation completed state",
    "OrderCreated": "order creation completed state",
    "PaymentProcessed": "payment processing completed state",
    "OrderConfirmed": "order confirmation completed state",
    "SagaCompleted": "final success state",
    "SagaFailed": "terminal failure state",
    "StatusInProgress": "operation currently executing",
    "StatusCompleted": "operation finished successfully",
    "StatusFailed": "operation failed",
    "StepPending": "step not yet started",
    "StepInProgress": "step currently executing",
    "StepCompleted": "step finished successfully",
    "StepFailed": "step failed",
    "StepCompensated": "step was reversed during compensation",
    "SpanStatusOK": "span completed successfully",
    "SpanStatusError": "span completed with error",
    "DEBUG": "debug log level",
    "INFO": "info log level",
    "WARN": "warn log level",
    "ERROR": "error log level",
    "TraceContextKey": "context key for trace context",
    "CurrentSpanKey": "context key for current span"
  },
  "terms": {
    "service discovery": "mechanism for services to find each other dynamically",
    "circuit breaker": "pattern preventing cascade failures by blocking calls to unhealthy services",
    "rate limiting": "controlling request frequency per client to prevent abuse",
    "service registry": "central database of available service instances",
    "health checking": "periodic verification of service availability",
    "API gateway": "single entry point for external requests with protocol translation",
    "sidecar proxy": "companion process handling service communication",
    "east-west traffic": "service-to-service internal communication",
    "north-south traffic": "client-to-service external communication",
    "saga pattern": "distributed transaction coordination with compensation",
    "bounded context": "service boundary defining data ownership",
    "eventual consistency": "system reaches consistent state over time",
    "compensation": "reverse operations to undo saga steps on failure",
    "database-per-service": "pattern ensuring each service owns its data completely",
    "monorepo": "single repository containing multiple services with clear boundaries",
    "gRPC": "remote procedure call framework using Protocol Buffers",
    "token bucket": "algorithm for rate limiting using refillable token capacity",
    "HTTP to gRPC translation": "protocol conversion from REST to internal gRPC calls",
    "per-client rate limiting": "individual rate limits based on client identification",
    "service tier": "classification of clients with different access quotas",
    "protocol translation": "conversion between HTTP REST and gRPC message formats",
    "circuit breaker states": "closed, open, and half-open states reflecting service health",
    "idempotent operations": "operations that produce same result regardless of retry count",
    "orchestrator pattern": "centralized coordination of saga steps",
    "forward recovery": "attempt to complete all steps before compensating",
    "semantic compensation": "business-meaningful reversal rather than technical rollback",
    "long-running transaction": "transaction spanning multiple services over extended time",
    "phantom operations": "operations that appear to fail but actually succeed",
    "W3C Trace Context": "standard for propagating trace information across service boundaries",
    "distributed tracing": "following requests across multiple services with trace correlation",
    "centralized logging": "aggregating log entries from all services into searchable central store",
    "log correlation": "linking log entries using trace IDs and span IDs",
    "RED metrics": "Rate, Errors, Duration metrics pattern for service health",
    "service health dashboard": "visual representation of service metrics and system health",
    "trace propagation": "passing trace context across service boundaries",
    "span": "individual operation within a distributed trace",
    "service dependency map": "visualization of service interactions and call relationships",
    "structured logging": "consistent JSON format for log entries with standard fields",
    "blue-green deployment": "zero-downtime deployment using two identical environments",
    "canary release": "gradual traffic shifting to new version with automated rollback",
    "zero-downtime deployment": "deployment strategy ensuring service availability throughout update process",
    "automated rollback": "system-triggered reversion to previous version based on metric thresholds",
    "traffic shifting": "gradual migration of request routing between service versions",
    "per-service CI pipeline": "independent build and deployment process for each microservice",
    "health validation": "comprehensive checking of service readiness before traffic routing",
    "deployment orchestration": "coordinated management of service deployment across environments",
    "cascade failure": "failure propagation through service dependency chains",
    "graceful degradation": "system continues providing value with reduced functionality during failures",
    "bulkheading": "resource isolation preventing failure propagation",
    "retry storm": "synchronized retry attempts overwhelming struggling services",
    "network partition": "network connectivity loss between service groups",
    "unit tests": "verify business logic correctness within single service with mocked dependencies",
    "integration tests": "validate service interactions over real network connections",
    "contract tests": "ensure API compatibility between service boundaries",
    "end-to-end tests": "verify complete user scenarios across full system",
    "chaos tests": "validate system resilience under failure conditions",
    "test doubles": "mock objects replacing real dependencies in tests",
    "dependency isolation": "replacing external dependencies with controllable test doubles",
    "event sourcing": "persisting state changes as immutable events in append-only log",
    "CQRS": "Command Query Responsibility Segregation separating write and read operations",
    "service mesh": "infrastructure layer providing networking capabilities through sidecar proxies",
    "data plane": "sidecar proxies handling actual traffic",
    "control plane": "centralized configuration management for service mesh",
    "zero-trust security": "explicit authentication required for every service interaction",
    "mTLS": "mutual TLS providing cryptographic service authentication",
    "multi-tenancy": "serving multiple customer organizations with data isolation",
    "schema-per-tenant": "separate database schemas for tenant data isolation",
    "SRE": "Site Reliability Engineering approach focused on error budgets",
    "SLO": "Service Level Objectives defining measurable service quality targets",
    "error budget": "allowable service degradation within SLO time window",
    "RTO": "Recovery Time Objective defining acceptable downtime",
    "RPO": "Recovery Point Objective defining acceptable data loss",
    "split-brain scenario": "network partition creating multiple active regions",
    "locality-aware routing": "preferring local service instances over remote ones",
    "adaptive circuit breaker": "threshold adjustment based on historical behavior",
    "bulkhead circuit breaker": "isolation of different failure types",
    "tenant onboarding": "process of provisioning new tenant infrastructure",
    "chaos engineering": "deliberately introducing failures to test system resilience"
  }
}