{
  "types": {
    "CacheDirectives": "fields: s_maxage Optional[int], max_age Optional[int], no_cache bool, no_store bool, must_revalidate bool, proxy_revalidate bool, public bool, private bool, stale_while_revalidate Optional[int], stale_if_error Optional[int]",
    "EdgeRequestHandler": "fields: cache CacheStorage, upstream str",
    "CacheEntry": "fields: key str, url str, vary_headers Dict[str, str], status_code int, headers Dict[str, str], body bytes, fetched_at float, expires_at float, last_used_at float, use_count int, surrogate_keys List[str], etag Optional[str], last_modified Optional[str]",
    "EdgeConfig": "fields: upstream_url str, cache_capacity_mb int, listen_port int, control_plane_url Optional[str], geoip_database_path str",
    "SurrogateKeyIndex": "fields: key_to_tags Dict[str, List[str]], tag_to_keys Dict[str, Set[str]]",
    "BanRule": "fields: pattern str, created_at float, is_soft bool",
    "EdgeMetrics": "fields: total_hits int, total_misses int, total_bandwidth_served int, total_bandwidth_upstream int, hits_by_status Dict[int, int], hits_by_content_type Dict[str, int], current_cache_size int, current_cache_size_bytes int",
    "ShieldMetrics": "fields: collapsed_requests int, origin_request_queue_size int, origin_errors int, negative_cache_hits int",
    "TimeWindowedMetrics": "fields: window_start float, window_duration float, buckets List[Dict], current_bucket_index int",
    "InvalidationMessage": "fields: message_id str, command str, target str, soft bool, timestamp float, parameters Dict[str, Any]",
    "InMemoryPubSubBroker": "fields: _subscribers Dict[str, Set[Callable[[InvalidationMessage], None]]], _lock asyncio.Lock",
    "InvalidationHandler": "fields: cache CacheStorage, key_index SurrogateKeyIndex, ban_rules List[BanRule], control_plane_publisher Optional[Callable]",
    "RequestCoalescingMap": "fields: _futures Dict[str, asyncio.Future], _timeouts Dict[str, float], _default_timeout float, _lock asyncio.Lock, _gc_task Optional[asyncio.Task]",
    "ShieldRequestHandler": "fields: cache CacheStorage, origin_upstream str, coalescing_map RequestCoalescingMap, _origin_semaphore asyncio.Semaphore",
    "EdgeNode": "fields: node_id str, region str, address str, weight int, health_status str",
    "HashRingNode": "fields: node_id str, physical_node EdgeNode, position int",
    "ConsistentHashRing": "fields: replicas_per_node int, hash_bits int, hash_space int, ring Dict[int, HashRingNode], sorted_positions List[int], nodes Dict[str, EdgeNode]",
    "GeoLocation": "fields: country_code Optional[str], country_name Optional[str], region_code Optional[str], region_name Optional[str], city Optional[str], latitude Optional[float], longitude Optional[float], metro_code Optional[int], timezone Optional[str]",
    "HealthMetrics": "fields: cache_hit_ratio float, request_rate float, error_rate float, cpu_utilization float, memory_used_mb int, memory_total_mb int, active_connections int, cache_size_bytes int, cache_capacity_bytes int",
    "NodeHealth": "Enum values: HEALTHY, DEGRADED, UNHEALTHY, MAINTENANCE",
    "CircuitState": "Enum: CLOSED, OPEN, HALF_OPEN",
    "CircuitBreakerConfig": "fields: failure_threshold int, reset_timeout float, half_open_max_requests int, half_open_success_threshold int, max_failure_history int",
    "CircuitBreaker": "fields: name str, config CircuitBreakerConfig, state CircuitState, failure_count int, success_count int, last_failure_time Optional[float], _lock asyncio.Lock",
    "ByteRange": "fields: start int, end Optional[int]",
    "RangeRequestHandler": "fields: cache CacheStorage",
    "TestOriginServer": "fields: port int, request_count int, responses Dict[str, Dict], failure_mode Optional[str]",
    "DiagnosticHeaders": "fields: node_id str",
    "CacheInspector": "fields: cache CacheStorage, key_index Optional[SurrogateKeyIndex], ban_rules Optional[List[BanRule]]",
    "ImageTransformation": "fields: format str, width int, height int, quality int, crop bool, dpr float",
    "DeviceProfile": "fields: dpi int, max_width int, supported_formats List[str], network_type str",
    "OptimizedImageCacheKey": "fields: original_key str, transformation ImageTransformation, variant_hash str",
    "EdgeFunction": "fields: name str, version str, code_hash str, runtime str, memory_limit_mb int, timeout_ms int, env_vars Dict[str, str]",
    "EdgeFunctionRuntime": "fields: (conceptual class, no specific fields)",
    "OriginClient": "fields: (abstract base class)",
    "S3OriginClient": "fields: endpoint str, bucket str, region str, access_key Optional[str], secret_key Optional[str], session_token Optional[str], use_iam_role bool, session aiohttp.ClientSession",
    "HttpOriginConfig": "fields: url str, health_check_path str, timeout_seconds int",
    "S3OriginConfig": "fields: endpoint str, bucket str, region str, access_key Optional[str], secret_key Optional[str], use_iam_role bool, force_path_style bool",
    "OriginConfig": "fields: type OriginType, config Union[HttpOriginConfig, S3OriginConfig, Dict[str, Any]], fallback_to Optional[List[str]]"
  },
  "methods": {
    "CacheDirectives.from_header(cache_control_header) returns CacheDirectives": "Parse a Cache-Control header string into a structured object",
    "parse_http_date(date_str) returns Optional[float]": "Parse an RFC 1123/822 date string into a Unix timestamp",
    "is_response_cacheable(status_code, method, cache_control, vary_header) returns bool": "Determine if a response can be stored in the cache per RFC 9111",
    "EdgeRequestHandler.handle_request(request_headers, request_body) returns Tuple[int, Dict[str, str], bytes]": "Main request handling algorithm for the edge node",
    "_revalidate_in_background(cache_key, cache_entry, request_headers)": "Asynchronously revalidate a stale cache entry",
    "_fetch_from_upstream(headers, body)": "Forward request to upstream (shield or origin)",
    "CacheEntry.is_fresh(current_time) returns bool": "Check if cache entry is still fresh",
    "CacheEntry.is_stale_but_revalidatable(current_time) returns bool": "Check if stale entry can be served during revalidation",
    "EdgeConfig.from_yaml(path) returns EdgeConfig": "Load and validate configuration from YAML file",
    "parse_cache_control_header(header_value) returns Dict[str, Optional[str]]": "Parse Cache-Control header into dictionary of directives",
    "get_header_values(headers, header_name) returns List[str]": "Get all values for a header (handling comma-separated and multiple headers)",
    "format_http_date(timestamp) returns str": "Format a Unix timestamp to RFC 1123 string",
    "SurrogateKeyIndex.add_entry(cache_key, tags)": "Register a cache entry and its tags with the index",
    "SurrogateKeyIndex.remove_entry(cache_key)": "Remove a cache entry from the index, cleaning up tag associations",
    "SurrogateKeyIndex.get_keys_for_tag(tag) returns Set[str]": "Return all cache keys tagged with the given tag",
    "SurrogateKeyIndex.purge_by_tag(tag) returns Set[str]": "Return all cache keys for a given tag and clear the index for that tag",
    "BanRule.matches(url) returns bool": "Check if the given URL matches this ban rule",
    "CacheEntry.from_upstream_response(key, url, vary_headers, status_code, headers, body, surrogate_keys) returns CacheEntry": "Factory method to create a CacheEntry from an upstream HTTP response",
    "InvalidationHandler.handle_purge_request(request_method, request_path, request_headers) returns": "Process HTTP PURGE requests for URL and tag purges",
    "InvalidationHandler._hard_purge_key(cache_key)": "Immediately delete a cache entry by key",
    "InvalidationHandler._soft_purge_key(cache_key)": "Mark a cache entry as stale and trigger background revalidation",
    "InvalidationHandler._purge_by_tag(tag, is_soft) returns": "Purge all cache entries associated with a surrogate key tag",
    "InvalidationHandler.add_ban_rule(pattern, is_soft, ttl_seconds) returns str": "Add a new ban rule and return its ID",
    "InvalidationHandler.check_bans(url) returns Optional[BanRule]": "Check if a URL matches any active ban rule",
    "InvalidationHandler._gc_ban_rules()": "Background task to garbage collect expired ban rules",
    "InMemoryPubSubBroker.subscribe(channel, callback)": "Subscribe a callback function to a channel",
    "InMemoryPubSubBroker.unsubscribe(channel, callback)": "Unsubscribe a callback from a channel",
    "InMemoryPubSubBroker.publish(channel, message)": "Publish a message to all subscribers of a channel",
    "RequestCoalescingMap.get_or_create_future(cache_key) returns asyncio.Future": "Get existing Future for key or create a new one",
    "RequestCoalescingMap.fulfill_future(cache_key, result) returns None": "Set result for Future associated with key",
    "RequestCoalescingMap.fail_future(cache_key, exception) returns None": "Set exception for Future associated with key",
    "RequestCoalescingMap._gc_loop(interval) returns None": "Background cleanup of timed-out entries",
    "ShieldRequestHandler.handle_request(request_headers, request_body) returns Tuple[int, Dict[str, str], bytes]": "Main request handling algorithm for the shield",
    "ShieldRequestHandler._revalidate_in_background(cache_key, stale_entry, request_headers) returns None": "Asynchronously revalidate a stale cache entry",
    "ConsistentHashRing.__init__(replicas_per_node, hash_bits)": "Initialize an empty hash ring",
    "ConsistentHashRing._hash(key) returns int": "Hash a string key to a position on the ring",
    "ConsistentHashRing.add_node(node) returns None": "Add a physical node to the hash ring",
    "ConsistentHashRing.remove_node(node_id) returns Optional[EdgeNode]": "Remove a node from the hash ring",
    "ConsistentHashRing.get_node(key) returns Optional[EdgeNode]": "Get the node responsible for a given cache key",
    "ConsistentHashRing.get_replica_nodes(key, count) returns List[EdgeNode]": "Get the primary node plus replica nodes for a key",
    "ConsistentHashRing.redistribute_keys(old_node, new_node) returns List[Tuple[str, EdgeNode]]": "Calculate which keys need to move when replacing a node",
    "GeoIPLookup.__init__(database_path)": "Initialize GeoIP lookup",
    "GeoIPLookup.lookup(ip_address) returns Optional[GeoLocation]": "Look up geographic location for an IP address",
    "GeoIPLookup.distance_between(loc1, loc2) returns float": "Calculate great-circle distance between two locations",
    "GeoIPLookup.find_nearest_node(client_ip, nodes) returns Optional[EdgeNode]": "Find nearest edge node for a client IP",
    "HealthChecker.__init__(node_id, region, version)": "Initialize health checker",
    "HealthChecker.start() returns None": "Start background health monitoring",
    "HealthChecker.stop() returns None": "Stop health monitoring",
    "HealthChecker.handle_health_request() returns tuple[int, Dict[str, str], bytes]": "Handle HTTP GET /health request",
    "HealthChecker.get_health_status() returns NodeHealth": "Get current health status",
    "CircuitBreaker.execute(func, *args, **kwargs) returns": "Execute function with circuit breaker protection",
    "CircuitBreaker.get_status() returns dict": "Return current circuit status for monitoring",
    "RangeRequestHandler.parse_range_header(range_header, content_length) returns List[ByteRange]": "Parse Range header value into list of ByteRange objects",
    "RangeRequestHandler.handle_range_request(request_headers, request_body, cache_key) returns Tuple[int, dict, bytes]": "Handle HTTP request with Range header",
    "RangeRequestHandler.extract_range_from_body(body, byte_range) returns bytes": "Extract byte range from full response body",
    "TestOriginServer.handler(request) returns web.Response": "Handle incoming request with configurable behavior",
    "TestOriginServer.start() returns": "Start the test origin server",
    "TestOriginServer.set_failure_mode(mode) returns": "Set failure mode for testing circuit breakers",
    "TestOriginServer.get_request_count() returns int": "Get total requests received",
    "TestOriginServer.reset_counter() returns": "Reset request counter",
    "DiagnosticHeaders.add_cache_headers(status, cache_key, cache_entry, response_headers) returns Dict[str, str]": "Add cache-related diagnostic headers to response",
    "DiagnosticHeaders.generate_request_id(existing_id) returns str": "Generate or propagate request ID for tracing",
    "DiagnosticHeaders.add_tracing_headers(request_headers, response_headers) returns Dict[str, str]": "Add distributed tracing headers to response",
    "CacheInspector.handle_debug_request(path, query_params) returns Tuple[int, Dict[str, str], bytes]": "Handle GET /debug/cache[/subpath] requests",
    "CacheInspector._get_cache_entries_summary(limit) returns List[Dict[str, Any]]": "Get summary of cache entries without full bodies",
    "CacheInspector._get_tag_mappings() returns Dict[str, Any]": "Get surrogate key index mappings",
    "ImageOptimizer.transform(image_bytes, transformation) returns bytes": "Apply image transformations",
    "EdgeFunctionRuntime.execute(function, request, context) returns HttpResponse": "Execute edge function in sandbox",
    "OriginClient.fetch(path, method, headers, body) returns Tuple[int, Dict[str, str], bytes]": "Abstract method to fetch from origin",
    "OriginClient.should_cache_response(status_code, headers) returns bool": "Determine if response should be cached",
    "OriginClient.get_cache_key_prefix() returns str": "Get cache key prefix for origin isolation",
    "S3OriginClient._sign_request(method, path, headers) returns Dict[str, str]": "Generate AWS Signature Version 4",
    "S3OriginClient.close() returns": "Cleanup connection pool",
    "ShieldRequestHandler._determine_origin(request_headers) returns str": "Determine which origin to use for request",
    "ShieldRequestHandler._init_origin_clients() returns None": "Initialize origin clients from configuration"
  },
  "constants": {
    "OriginType": "Enum: HTTP, S3, GOOGLE_STORAGE, AZURE_BLOB"
  },
  "terms": {
    "Content Delivery Network (CDN)": "A distributed network of servers that delivers web content to users based on geographic proximity",
    "Origin Server": "The ultimate source of truth for web content",
    "Edge Node/Edge Server/PoP": "A geographically distributed server in a CDN that caches and serves content to nearby users",
    "Cache Hit": "A request served from the edge cache without contacting the origin",
    "Cache Miss": "A request that cannot be served from cache and must be fetched from upstream",
    "Origin Shield/Mid-Tier Cache": "An intermediate caching layer between edge nodes and the origin to reduce load",
    "Control Plane": "The management layer for configuration, analytics, and coordination in a CDN",
    "Data Plane": "The layer that handles actual user traffic (edge nodes)",
    "TTL (Time-To-Live)": "The duration a cached item is considered fresh",
    "Invalidation/Purging": "The active removal of cached content",
    "Geo-Routing": "Directing user requests to the nearest optimal edge node based on geographic location",
    "Request Collapsing": "Deduplicating concurrent identical requests to the origin",
    "Cache Storage": "Abstract interface for cache storage implementations",
    "Cache Key": "Unique identifier for a cached response based on URL and Vary header dimensions",
    "Surrogate Key": "A tag assigned to cache entries for group-based invalidation",
    "Ban": "A pattern-based invalidation rule",
    "Negative Caching": "Caching error responses with a short TTL to protect the origin",
    "Stale-while-revalidate": "A cache directive allowing stale content to be served while it is being revalidated in the background",
    "Eventual Invalidation": "The property where a banned cache entry is only removed when it is next accessed, not immediately",
    "hard purge": "Immediate deletion of a cache entry",
    "soft purge": "Marking a cache entry as stale while serving it and triggering background revalidation",
    "ban rule": "A pattern-based invalidation rule with a TTL",
    "surrogate key": "A tag assigned to cache entries for group-based invalidation",
    "invalidation propagation": "The process of disseminating an invalidation command to all edge nodes",
    "eventual invalidation": "A lazy invalidation strategy where a banned entry is only removed upon next access",
    "pub/sub broker": "A message broker that implements the publish-subscribe pattern",
    "Thundering Herd Problem": "A stampede of concurrent requests overwhelming a resource",
    "Request Coalescing Map": "In-memory data structure tracking in-flight requests for deduplication",
    "Graceful Degradation": "Strategy of serving stale content or failing gracefully when upstream services are impaired",
    "Consistent Hashing": "Hashing technique that minimizes remapping when nodes are added or removed from a distributed system",
    "Hash Ring": "A virtual circle representing the hash space in consistent hashing",
    "Virtual Node": "Multiple hash positions representing a single physical node for better load distribution",
    "Health Checking": "Process of monitoring node availability and performance to ensure reliable routing",
    "DNS TTL": "Time-To-Live value in DNS records controlling how long resolvers cache the response",
    "Anycast": "Network addressing and routing method where the same IP address is announced from multiple locations",
    "GeoIP Database": "Database mapping IP addresses to geographic locations",
    "Haversine Formula": "Equation for calculating great-circle distance between two points on a sphere",
    "Thundering Herd": "Stampede of requests overwhelming a resource during failover",
    "Cold Start": "Performance degradation when a new node starts with empty cache",
    "Node Failover": "Process of redirecting traffic from a failed node to a backup node",
    "cache hit": "A request served from the edge cache without contacting the origin",
    "cache miss": "A request that cannot be served from cache and must be fetched from upstream",
    "request collapsing": "Deduplicating concurrent identical requests to the origin",
    "thundering herd": "Stampede of requests overwhelming a resource",
    "eventual consistency": "Property where updates propagate to all nodes eventually, but not immediately",
    "background revalidation": "Asynchronously fetching updated content while serving stale data",
    "pub/sub channel": "A named message bus topic for publish-subscribe messaging",
    "control plane": "The management layer for configuration, analytics, and coordination in a CDN",
    "data plane": "The layer that handles actual user traffic (edge nodes)",
    "circuit breaker": "Pattern for failing fast when upstream services are unhealthy",
    "graceful degradation": "Strategy of serving stale content or reduced functionality when upstream services fail",
    "range request": "HTTP request for partial content using Range header",
    "byte range": "Specification of start and end bytes for partial content",
    "Vary: *": "HTTP header value indicating response varies on all request headers (never cache)",
    "stale-if-error": "Cache directive allowing stale content to be served when origin errors occur",
    "property-based testing": "Testing method that verifies properties hold for all possible inputs",
    "integration testing": "Testing multiple components together to verify they work correctly",
    "load testing": "Testing system behavior under production-like load",
    "test fixture": "Reusable setup/teardown code for tests",
    "cache hit ratio": "Percentage of requests served from cache vs total requests",
    "race condition": "When behavior depends on sequence/timing of uncontrollable events",
    "GeoIP database": "Database mapping IP addresses to geographic locations",
    "flight data recorders": "Diagnostic headers that document a request's path through caching infrastructure",
    "cache state dump": "JSON representation of all cache entries for inspection",
    "geo simulation": "Techniques to simulate geographic distribution locally",
    "request tracing": "Tracking a request through all CDN layers using unique IDs",
    "propagation delay": "Time for invalidation commands to reach all edge nodes",
    "Predictive Prefetching": "Automatically fetching content before users request it based on access patterns",
    "Image Optimization": "On-the-fly resizing, format conversion, compression of images at edge",
    "WebSocket Proxying": "Extending CDN to proxy WebSocket connections",
    "Object Storage Integration": "Treating cloud object storage as first-class origin",
    "Edge Compute": "Executing lightweight compute functions at edge nodes",
    "Device Pixel Ratio (DPR)": "Ratio between physical pixels and CSS pixels on device",
    "AWS Signature Version 4": "Authentication method for AWS API requests",
    "Visual Regression Testing": "Testing to ensure visual changes are intentional",
    "Connection Pooling": "Reusing connections to origin for efficiency",
    "Origin Routing": "Directing requests to different origins based on rules"
  }
}