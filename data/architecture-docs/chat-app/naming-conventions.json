{
  "types": {
    "ChatMessage": "fields: sender string, content string, timestamp string (ISO), roomId string, id number",
    "User": "fields: username string, passwordHash string, createdAt Date",
    "Room": "fields: id string, name string, createdAt Date, memberIds Set<string>",
    "ClientSession": "fields: connectionId string, socket WebSocket, userId string, ip string, userAgent string, joinedAt string, lastActivity number, roomId string",
    "WebSocketMessage": "fields: type string, payload any, timestamp string (optional)",
    "TestWebSocketClient": "fields: url string, socket WebSocket, messageQueue Array, messageHandlers Map, connectPromise Promise",
    "DebugLogger": "fields: enableConsole boolean, enableFile boolean, logFile string",
    "DirectMessaging": "fields: userConnections Map<string, string>, connectionUsers Map<string, string>, connectionManager ConnectionManager, roomManager RoomManager",
    "FileService": "fields: fileMetadata Map<string, any>"
  },
  "methods": {
    "ConnectionManager.handleMessage(socket, rawMessage) returns void": "Parses, validates, and routes incoming WebSocket messages",
    "ConnectionManager.sendToClient(connectionId, message) returns void": "Sends a JSON message to a specific connected client if socket is open",
    "RoomManager.broadcastToRoom(roomId, message, excludeConnectionId) returns void": "Sends a message to all room members, optionally excluding sender",
    "parseAndValidateWebSocketMessage(rawMessage) returns": "parses and validates raw WebSocket message string",
    "validateChatMessagePayload(payload) returns": "validates ChatMessage payload structure",
    "createServerMessage(type, payload) returns": "creates properly formatted WebSocketMessage for server-originated events",
    "createChatMessage(sender, content, roomId) returns": "creates a new ChatMessage object with server-assigned timestamp",
    "createRoom(name) returns": "creates a new Room object with initial empty member set",
    "createClientSession(socket, userId, ip, userAgent) returns": "creates a ClientSession object linking a WebSocket to a user",
    "ConnectionManager.handleMessage(connectionId, message) returns void": "Main entry point for handling incoming WebSocket messages",
    "ConnectionManager.sendToClient(connectionId, message) returns boolean": "Sends a message to a specific client if socket is open",
    "parseAndValidateWebSocketMessage(rawMessage) returns WebSocketMessage": "Parses and validates raw WebSocket message string",
    "createServerMessage(type, payload) returns WebSocketMessage": "Creates a formatted server message with timestamp",
    "RoomManager.joinRoom(connectionId, roomId, userId) returns Promise<Room>": "Adds a user to a room, fetches history, notifies others",
    "RoomManager.leaveRoom(connectionId, roomId) returns void": "Removes a user from a room and notifies others",
    "RoomManager.leaveAllRooms(connectionId) returns void": "Removes a connection from all rooms (cleanup on disconnect)",
    "RoomManager.setUserTyping(connectionId, roomId, isTyping) returns void": "Updates and broadcasts a user's typing status",
    "RoomManager.getRoomList() returns Array": "Returns a list of active rooms with member counts",
    "createChatMessage(sender, content, roomId) returns ChatMessage": "Creates a new chat message object",
    "createRoom(name) returns Room": "Creates a new room object with a generated ID",
    "authenticateConnection(request) returns": "Validates credentials during HTTP upgrade",
    "registerUser(username, password) returns": "Creates new user with hashed password",
    "loginUser(username, plainPassword) returns": "Authenticates user and creates session",
    "validateSession(sessionToken) returns": "Validates existing session token",
    "createSession(userId, connectionInfo) returns": "Creates new session for authenticated user",
    "invalidateSession(sessionToken) returns": "Removes session (logout)",
    "storeMessage(message) returns": "Stores chat message with metadata",
    "getMessagesForRoom(roomId, options) returns": "Retrieves messages with pagination",
    "getRecentMessagesForRoom(roomId, limit) returns": "Gets most recent messages",
    "getMessageCountForRoom(roomId) returns": "Returns total messages in room",
    "deleteMessagesOlderThan(timestamp) returns": "Cleanup old messages",
    "cleanupExpiredSessions() returns": "Removes expired sessions",
    "ConnectionManager.handleMessage(connectionId, rawMessage) returns void": "Main entry point for handling incoming WebSocket messages with error handling",
    "validateChatMessagePayload(payload) returns ChatMessage": "Validates ChatMessage payload structure",
    "ConnectionManager.removeConnection(connectionId, reason) returns void": "Removes a connection and cleans up associated state",
    "TestWebSocketClient.connect(token) returns Promise": "Connect to server with optional token",
    "TestWebSocketClient.send(type, payload) returns Object": "Send JSON message to server",
    "TestWebSocketClient.waitForMessage(messageType, timeoutMs) returns Promise": "Wait for specific message type with timeout",
    "TestWebSocketClient.getMessagesOfType(messageType) returns Array": "Get all received messages of specific type",
    "DebugLogger.log(event, data, level) returns": "Structured logging method",
    "ConnectionManager.getDebugState() returns Object": "Get current connection state for inspection",
    "ConnectionManager.findProblematicConnections() returns Array": "Find connections with issues",
    "DirectMessaging.registerUserConnection(userId, connectionId) returns void": "Registers a user's current WebSocket connection for direct messaging routing",
    "DirectMessaging.unregisterUserConnection(connectionId) returns void": "Removes connection mapping when user disconnects",
    "DirectMessaging.handleDirectMessage(senderConnectionId, messagePayload) returns Promise<void>": "Processes incoming direct message and routes to recipient",
    "DirectMessaging.isUserOnline(userId) returns boolean": "Checks if a user is currently connected",
    "DirectMessaging.getConnectionForUser(userId) returns string|undefined": "Gets connection ID for online user",
    "FileService.handleUpload(fileData, filename, mimeType, uploaderId) returns Promise<{fileId: string, url: string}>": "Handles file upload, stores on disk, returns metadata",
    "FileService.getFileMetadata(fileId) returns any": "Retrieves metadata for uploaded file",
    "FileService.serveFile(fileId) returns Promise<{data: Buffer, metadata: any}>": "Serves file for download with metadata",
    "FileService.cleanupOldFiles(maxAgeDays) returns Promise<void>": "Cleans up files older than specified days"
  },
  "constants": {
    "EVENT_CHAT_MESSAGE": "'chat_message'",
    "EVENT_USER_JOINED": "'user_joined'",
    "EVENT_USER_TYPING": "'user_typing'",
    "MAX_MESSAGE_LENGTH": "1000",
    "EVENT_USER_LEFT": "'user_left'",
    "sessionTTL": "24 hours in milliseconds",
    "saltRounds": "10 (for bcrypt hashing)",
    "TEST_PORT": "8081 (test server port)",
    "EVENT_DIRECT_MESSAGE": "'direct_message'",
    "EVENT_DIRECT_MESSAGE_DELIVERED": "'direct_message_delivered'",
    "EVENT_DIRECT_MESSAGE_ERROR": "'direct_message_error'",
    "MAX_FILE_SIZE": "10 * 1024 * 1024 (10MB)",
    "ALLOWED_MIME_TYPES": "Array of allowed MIME types for uploads",
    "UPLOAD_DIR": "'./uploads'"
  },
  "terms": {
    "Polling": "Client repeatedly requests updates from the server",
    "Long Polling": "Client request is held open by server until an update is available",
    "Server-Sent Events (SSE)": "HTTP-based technology for server-to-client event streaming",
    "WebSocket": "Protocol providing full-duplex communication channels over a single TCP connection",
    "Connection Lifecycle": "The stages of a WebSocket connection: handshake, connected, messaging, disconnection",
    "Heartbeat": "Periodic messages (ping/pong) to detect if a connection is still alive",
    "Stateful Message Router": "A server component that maintains active connections and routes messages between them based on application state",
    "Message Broker": "Component that routes messages to appropriate recipients based on rules or subscriptions",
    "Room Manager": "Component that manages chat rooms, membership, and presence state",
    "Broadcast": "Sending a message to all current members of a group or room",
    "Presence": "The real-time status information about users (online, offline, typing)",
    "Authentication": "Verifying user identity before granting access",
    "Session": "Temporary authentication state for a user connection",
    "Pagination": "Retrieving data in manageable chunks",
    "Password Hashing": "Cryptographically transforming passwords for secure storage",
    "TTL (Time-To-Live)": "Duration after which data expires",
    "bcrypt": "Password hashing algorithm",
    "JWT (JSON Web Token)": "Compact URL-safe token format",
    "Debouncing": "Delaying execution of a function until after a specified wait time has elapsed since the last time it was invoked",
    "Rate Limiting": "Controlling the frequency of messages a user can send to prevent abuse",
    "Exponential Backoff": "Increasing delay between retry attempts in a pattern (e.g., 1s, 2s, 4s, 8s)",
    "Graceful Degradation": "System continues to operate with reduced functionality when parts fail",
    "Defensive Programming": "Coding style that anticipates and handles potential errors before they occur",
    "Zombie Connection": "Connection that appears open but is actually dead or unresponsive",
    "Clock Skew": "Difference in system time between client and server",
    "Unicode Normalization": "Process of converting text to a standard form for consistent processing",
    "Integration Tests": "Tests that verify components work together",
    "Unit Tests": "Tests that verify individual functions in isolation",
    "Test Harness": "Reusable testing infrastructure",
    "Message Queue": "Collection of received messages in test client",
    "Rubber Duck Debugging": "Explaining code problem out loud to an inanimate object to clarify thinking",
    "Differential Debugging": "Comparing working vs. non-working scenarios to identify differences",
    "State Visualization": "Graphically representing system state to identify issues",
    "Chaos Engineering": "Intentional introduction of failures to test system resilience",
    "Flight Recorder": "Comprehensive logging of system state for post-mortem analysis",
    "Direct Messaging": "Private messaging between individual users outside of chat rooms",
    "End-to-End Encryption": "Encryption where only communicating users can read messages, not the server",
    "Redis Pub/Sub": "Redis Publish/Subscribe pattern for cross-server communication",
    "Sticky Sessions": "Load balancing technique that routes a user's requests to the same server",
    "Middleware Pipeline": "Pattern where messages pass through a series of processing functions",
    "Sliding Window Algorithm": "Rate limiting algorithm that counts requests over a moving time window",
    "Horizontal Scaling": "Adding more servers to handle increased load, as opposed to vertical scaling (upgrading hardware)"
  }
}