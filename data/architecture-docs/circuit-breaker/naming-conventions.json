{
  "types": {
    "State": "enum with StateClosed, StateOpen, StateHalfOpen",
    "CircuitBreaker": "fields: state State, config *Config, failureCount int64, requestCount int64, successCount int64, stateTransitionTime time.Time, recoveryTimer *time.Timer, halfOpenRequests int64, metrics *Metrics",
    "Clock": "interface with Now() time.Time, After(duration) <-chan time.Time",
    "MockClock": "fields: now time.Time, timers []*mockTimer, mu sync.RWMutex",
    "MockServer": "fields: server *httptest.Server, failureRate float64, latency time.Duration, responses map[string]*http.Response, mu sync.RWMutex",
    "Metrics": "RequestCount int64, SuccessCount int64, FailureCount int64, CurrentState State, StateTransitionTime Time",
    "Config": "fields: FailureThreshold int, RecoveryTimeout Duration, RequestTimeout Duration",
    "ClientWrapper": "fields: client *http.Client, registry *ServiceRegistry, serviceExtractor ServiceExtractor, errorClassifier ErrorClassifier, metrics *MetricsCollector",
    "ServiceRegistry": "fields: circuits map[string]*CircuitBreaker, configs map[string]*Config, defaultConfig *Config, mutex sync.RWMutex, metrics *MetricsCollector",
    "FallbackRegistry": "manages fallback chains per service",
    "WindowBucket": "StartTime Time, EndTime Time, RequestCount int32, SuccessCount int32, FailureCount int32, AvgLatency Duration, MaxLatency Duration",
    "MetricsCollector": "circuits map[string]*Metrics, mutex RWMutex",
    "SlidingWindow": "buckets []WindowBucket, bucketSize Duration, windowSize Duration, position int32, mutex RWMutex",
    "ConfigLoader": "defaultConfig *Config, validators []ConfigValidator",
    "ConfigValidator": "interface with Validate method",
    "MetricsSnapshot": "TotalRequests int64, SuccessRequests int64, FailureRequests int64, FailureRate float64, AverageLatency Duration, MaxLatency Duration, WindowStart Time, WindowEnd Time",
    "RingBuffer": "size int, position int, mask int",
    "FallbackFunc": "function type for alternative responses",
    "FallbackChain": "ordered list of fallback functions",
    "Semaphore": "concurrency limiting with permits",
    "BulkheadPool": "resource isolation for service",
    "BulkheadConfig": "resource limits configuration",
    "BulkheadMetrics": "utilization tracking",
    "ServiceExtractor": "interface with ExtractServiceID method",
    "ErrorClassifier": "interface with IsCircuitFailure method, ClassifyError method",
    "HostnameExtractor": "portStripMode bool, normalizeFunc func(string) string",
    "UnaryClientInterceptor": "grpc interceptor function type",
    "StreamClientInterceptor": "grpc streaming interceptor type",
    "DefaultErrorClassifier": "httpStatusRules map, grpcStatusRules map, timeoutPatterns slice",
    "ErrorClassification": "Category ErrorCategory, Severity ErrorSeverity, ShouldRetry bool, CircuitImpact CircuitImpactType",
    "RecoveryManager": "strategies map, eventBus chan, timeouts map",
    "RecoveryStrategy": "interface with Recover method, CanRecover method, EstimateRecoveryTime method",
    "CircuitBreakerRecoveryStrategy": "recovery implementation for circuit breaker",
    "EdgeCaseTestSuite": "mockClock MockClock, failureInjector FailureInjector, loadGenerator ConcurrentLoadGenerator",
    "mockTimer": "fields: expiresAt time.Time, ch chan time.Time, triggered bool",
    "ChaosController": "fields: scenarios map[string]*ChaosScenario, running bool, safetyLimits *SafetyLimits, monitoring *ChaosMonitoring, mu sync.RWMutex",
    "ChaosScenario": "fields: Name string, Duration time.Duration, FailureActions []FailureAction, SafetyChecks []SafetyCheck, SuccessCriteria []SuccessCriterion",
    "FailureInjector": "fields: networkChaos *NetworkChaosInjector, serviceChaos *ServiceChaosInjector, resourceChaos *ResourceChaosInjector, activeFailures map[string]*InjectedFailure, mu sync.RWMutex",
    "CircuitInspector": "registry *ServiceRegistry, collector *MetricsCollector, logger Logger, mutex sync.RWMutex",
    "PerformanceProfiler": "enabled bool, collectors map[string]*performanceCollector, mutex sync.RWMutex",
    "ChaosInjector": "scenarios map[string]*ChaosScenario, activeFailures map[string]*InjectedFailure, safetyLimits *SafetyLimits, mutex sync.RWMutex",
    "ServiceBehaviorPattern": "fields: ServiceID string, TemporalPatterns map[string]float64, LoadCorrelations map[string]float64, FailureClustering ClusteringMetrics, RecoveryCharacteristics RecoveryMetrics, EnvironmentalFactors map[string]float64, LastUpdated time.Time, ConfidenceScore float64",
    "ThresholdOptimizer": "fields: patterns map[string]*ServiceBehaviorPattern, configs map[string]*AdaptiveConfig, mutex sync.RWMutex, updateChannel chan ThresholdUpdate",
    "CoordinationEvent": "fields: ServiceID string, InstanceID string, StateChange StateTransition, Timestamp time.Time, VectorClock map[string]int64, ContextData map[string]interface{}",
    "DistributedCircuitCoordinator": "fields: localInstanceID string, peerInstances map[string]*PeerInstance, eventStream EventStream, stateManager *GlobalStateManager, consensusEngine *ConsensusEngine, mutex sync.RWMutex",
    "ServiceHealthScore": "fields: ServiceID string, OverallScore float64, PerformanceHealth float64, ReliabilityHealth float64, CapacityHealth float64, TrendDirection string, TrendVelocity float64, PredictedHealth map[string]float64, CalculatedAt time.Time",
    "PredictiveAnalyzer": "fields: healthScorers map[string]*HealthScorer, predictors map[string]*FailurePredictor, anomalyDetectors map[string]*AnomalyDetector, alertThresholds map[string]*PredictiveThresholds, mutex sync.RWMutex"
  },
  "methods": {
    "Execute(ctx, fn) (interface{}, error)": "main entry point for circuit-protected operations",
    "State() State": "returns current circuit state",
    "Metrics() *Metrics": "returns current metrics snapshot",
    "Now() time.Time": "returns current mock time",
    "After(duration) <-chan time.Time": "creates controllable timer channel",
    "SetFailureRate(percentage)": "configures mock server failure rate",
    "SetLatency(ms)": "configures mock server response delay",
    "GetOrCreateCircuit(serviceID)": "returns circuit breaker for service",
    "WrapClient(client, registry)": "creates circuit breaker enabled HTTP client",
    "Do(req) (*http.Response, error)": "executes HTTP request through circuit breaker",
    "AdvanceTime(duration)": "moves mock clock forward and triggers timers",
    "String() string": "returns human-readable state name",
    "Validate() error": "validates configuration parameters",
    "Snapshot() *Metrics": "returns point-in-time metrics copy",
    "RecordRequest(success bool, latency Duration)": "updates sliding window with request outcome",
    "FailureRate() (float64, int64)": "calculates current failure rate and request count",
    "LoadConfig(sources ...ConfigSource) (*Config, error)": "loads configuration with hierarchical overrides",
    "RecordFailure(serviceID string, err error)": "updates metrics for failed request",
    "AggregateMetrics() map[string]*Metrics": "returns system-wide metrics summary",
    "canProceed() bool": "determines if request should be allowed",
    "recordSuccess(latency Duration)": "handles successful request outcomes",
    "recordFailure(err error)": "handles failed request outcomes",
    "transitionToOpen()": "changes state to open and starts recovery timer",
    "transitionToHalfOpen()": "changes state to half-open for recovery testing",
    "transitionToClosed()": "changes state to closed for normal operation",
    "Snapshot() *MetricsSnapshot": "returns point-in-time metrics copy",
    "rotateIfNeeded(now Time)": "creates new buckets if time has elapsed",
    "getCurrentBucket(timestamp Time) *WindowBucket": "returns bucket for given timestamp",
    "Execute(ctx, originalError) (interface{}, error)": "runs fallback chain until success",
    "RegisterFallback(serviceID, chain)": "adds fallback chain for service",
    "GetFallbackChain(serviceID) (*FallbackChain, bool)": "retrieves service fallback chain",
    "Acquire(ctx) error": "acquires semaphore permit with timeout",
    "Release()": "returns semaphore permit",
    "Stats() (int64, int64, int)": "returns active, queued, capacity metrics",
    "GetOrCreateCircuit(serviceID) *CircuitBreaker": "retrieves or creates circuit breaker for service",
    "ExtractServiceID(req) string": "determines service identifier from request",
    "IsCircuitFailure(resp, err) bool": "classifies response as circuit failure",
    "SetServiceConfig(serviceID, config)": "updates configuration for specific service",
    "WrapClient(client, registry) *ClientWrapper": "creates circuit breaker enabled HTTP client",
    "canExecuteInHalfOpen() bool": "determines if request should participate in recovery testing",
    "IsCircuitFailure(response, err) bool": "determines if error should affect circuit state",
    "ClassifyError(response, err) ErrorClassification": "provides detailed error classification",
    "Recover(ctx, component) RecoveryResult": "attempts component recovery",
    "CanRecover(failure) bool": "determines if recovery possible",
    "EstimateRecoveryTime(failure) time.Duration": "estimates recovery duration",
    "TestClockJumpScenario(t)": "tests clock change edge cases",
    "TestConcurrentStateTransition(t)": "tests race condition scenarios",
    "NewMockClock(startTime) *MockClock": "creates mock clock with starting time",
    "NewMockServer() *MockServer": "creates configurable mock HTTP server",
    "SetFailureRate(rate)": "configures percentage of requests that fail",
    "SetLatency(duration)": "configures artificial response delay",
    "ExecuteScenario(ctx, scenarioName) error": "runs chaos scenario with monitoring",
    "InjectNetworkFailure(target, failureType, config) error": "introduces network-level failures",
    "SetFailureRate(rate float64)": "configures mock server failure rate",
    "SetLatency(duration time.Duration)": "configures mock server response delay",
    "AdvanceTime(duration time.Duration)": "moves mock clock forward and triggers timers",
    "InspectCircuit(serviceID string) (*CircuitInspection, error)": "returns comprehensive state information",
    "StartProfiling(operationName string)": "begins performance data collection",
    "ExecuteSystematicTests(ctx context.Context, testSuite string) error": "runs comprehensive debugging scenarios",
    "DiagnoseCircuitIssues(serviceID string) *DiagnosisReport": "performs systematic problem analysis",
    "AnalyzePerformanceBottlenecks() *PerformanceAnalysis": "identifies performance optimization opportunities",
    "WrapCircuitBreaker(cb *CircuitBreaker) *DebuggingCircuitBreaker": "adds debugging capabilities to circuit breaker",
    "LearnServiceBehavior(serviceID string, metrics []*ServiceMetrics) *ServiceBehaviorPattern": "analyzes service metrics to identify behavior patterns for threshold optimization",
    "OptimizeThresholds(serviceID string, pattern *ServiceBehaviorPattern) *OptimizedThresholds": "calculates optimal circuit breaker parameters based on learned patterns",
    "SynchronizeCircuitState(serviceID string, stateChange StateTransition) error": "propagates local state changes to distributed instances",
    "ResolveStateConflict(serviceID string, conflicts []*CoordinationEvent) StateTransition": "handles conflicting state changes from multiple instances using consensus",
    "PredictServiceFailure(serviceID string, currentMetrics *ServiceMetrics) *FailurePrediction": "analyzes current metrics to predict potential service failures",
    "CalculateServiceHealthScore(serviceID string, metrics *ServiceMetrics) *ServiceHealthScore": "computes comprehensive real-time health assessment"
  },
  "constants": {
    "StateClosed": "circuit allows normal request flow",
    "StateOpen": "circuit blocks all requests immediately",
    "StateHalfOpen": "circuit allows limited test requests",
    "ErrCircuitOpen": "error returned when circuit is open",
    "ErrTimeout": "error returned when request times out",
    "ErrBulkheadCapacity": "error when resource pool is full",
    "ErrFallbackDepthExceeded": "error when fallback chain too deep",
    "ErrServiceNotFound": "error when service ID cannot be determined",
    "ErrConfigurationInvalid": "error for invalid configuration parameters"
  },
  "terms": {
    "cascade failure": "one service failure causing upstream service failures",
    "failing fast": "rejecting requests immediately instead of waiting for timeout",
    "circuit breaker": "component that monitors service health and blocks requests to failing services",
    "bulkhead isolation": "separating resources to prevent cascade failures",
    "graceful degradation": "providing simplified functionality when primary service fails",
    "state machine": "three-state system managing circuit behavior",
    "failure threshold": "number of failures before opening circuit",
    "recovery testing": "limited request testing in half-open state",
    "thread safety": "safe concurrent access to circuit breaker state",
    "observability": "metrics and monitoring capabilities for operational visibility",
    "sliding window": "time-based failure rate calculation using rolling buckets",
    "fallback patterns": "alternative responses when primary service unavailable",
    "service registry": "mapping services to circuit breaker instances",
    "decorator pattern": "wrapping existing components with additional functionality",
    "consecutive failures": "uninterrupted sequence of failed requests",
    "bucket rotation": "process of creating new buckets and discarding old ones",
    "ring buffer": "circular array for efficient bucket storage",
    "exponential moving average": "weighted average giving more weight to recent samples",
    "time alignment": "rounding timestamps to bucket boundaries",
    "clock skew": "difference in system clocks across distributed systems",
    "resource pool": "isolated allocation of connections/threads per service",
    "semaphore limiting": "controlling maximum concurrent operations",
    "fallback chain": "ordered sequence of alternative response strategies",
    "service isolation": "maintaining independent circuit breakers per service",
    "transparent integration": "adding functionality without changing existing interfaces",
    "service identification": "mapping requests to specific circuit breaker instances",
    "error classification": "determining which errors should affect circuit breaker state",
    "interceptor pattern": "framework-level request/response processing",
    "middleware ordering": "sequence of request processing components",
    "configuration inheritance": "hierarchical configuration with defaults and overrides",
    "edge case scenarios": "unusual conditions that test system robustness",
    "recovery procedures": "systematic approaches to restore system health",
    "failure modes": "ways components can fail and their impacts",
    "race conditions": "timing-dependent bugs in concurrent systems",
    "chaos testing": "systematic failure injection to validate system resilience",
    "failure injection": "controlled introduction of failures into system components",
    "mock clock": "controllable time implementation for deterministic testing",
    "safety boundaries": "limits and controls to prevent chaos testing damage",
    "cascade failure prevention": "validating that failures don't propagate upstream",
    "resource exhaustion testing": "validating behavior under resource constraints",
    "chaos orchestration": "coordinating complex failure scenarios with safety controls",
    "resilience metrics": "measurements of system behavior under adverse conditions",
    "milestone checkpoints": "systematic verification points in development process",
    "integration testing": "end-to-end testing with real clients and mock services",
    "adaptive threshold adjustment": "machine learning-based threshold tuning based on service behavior patterns",
    "distributed coordination": "coordinating circuit breaker state across multiple service instances",
    "predictive failure detection": "identifying potential failures before they manifest as request failures",
    "behavioral pattern learning": "analyzing service behavior to identify patterns affecting optimal thresholds",
    "consensus and conflict resolution": "handling disagreements between distributed circuit breaker instances",
    "leading indicators": "metrics that change before service failures occur",
    "service health scoring": "comprehensive assessment combining performance, reliability, and capacity metrics",
    "operational intelligence": "analytical insights supporting both immediate decisions and strategic improvements"
  }
}