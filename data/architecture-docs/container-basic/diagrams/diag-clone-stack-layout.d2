direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

memory_layout: {
  label: "Stack Allocation & Direction (container_m1.c)"
  
  virtual_memory: {
    shape: sql_table
    label: "mmap'd Memory Region"
    high: "0x101000 | void* | stack_top // Highest Address"
    p1: "↑ | | [RSP] Initial Stack Pointer"
    stack_space: "0x001000 | uint8_t[1MB] | PROT_READ | PROT_WRITE // Grows Downward"
    p2: "↓ | | [Overflow Path]"
    guard: "0x000000 | uint8_t[4KB] | PROT_NONE // Guard Page"
    size: "Total Allocation: 1028 KB (Page Aligned)"
  }
}

implementation_logic: {
  label: "Syscall Execution Context"
  
  clone_call: {
    shape: code
    label: "clone_invocation.c"
    code: |'c
      #define STACK_SIZE (1024 * 1024)
      char *stack = mmap(NULL, STACK_SIZE, PROT_READ|PROT_WRITE, 
                         MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0);
      
      // Protect bottom 4KB to trap stack overflow
      mprotect(stack, 4096, PROT_NONE);

      // x86-64 stacks grow DOWN; provide the TOP address
      char *stack_top = stack + STACK_SIZE;
      pid_t pid = clone(child_fn, stack_top, CLONE_NEWPID | SIGCHLD, &cfg);
    '|
  }
}

memory_layout.virtual_memory.high -> implementation_logic.clone_call: "void* | 8 bytes | stack_top pointer" {
  style: {
    stroke: blue
    stroke-width: 2
    animated: true
  }
}

note: {
  shape: callout
  label: "Memory Corruption Warning: Passing 'stack' instead of 'stack_top' causes the child to write into the guard page immediately, resulting in SIGSEGV."
}
note.near: top-right

legend: {
  shape: sql_table
  label: "Legend"
  l1: "Blue Arrow | Data Pointer | Memory Address"
  l2: "PROT_NONE | 4096 bytes | Page-aligned trap"
}
legend.near: bottom-right