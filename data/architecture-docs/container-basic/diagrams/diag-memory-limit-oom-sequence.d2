direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- STYLES & CLASSES ---
classes: {
  state_node: {
    shape: oval
    style: {
      stroke-width: 2
    }
  }
  kernel_logic: {
    shape: hexagon
    style: {
      fill: "#e1d5e7"
      stroke: "#9673a6"
    }
  }
  danger_zone: {
    style: {
      stroke: red
      fill: "#f8cecc"
      stroke-width: 3
    }
  }
}

# --- COMPONENTS ---

cgroup_v2: {
  shape: sql_table
  label: "Control Group V2 (/sys/fs/cgroup/pod1/)"
  row0: "Offset | Type | File | Description"
  row1: "0x00 | int64 | memory.current | 100 MiB (Current usage)"
  row2: "0x08 | int64 | memory.max | 100 MiB (Hard ceiling)"
  row3: "0x10 | int64 | memory.high | 90 MiB (Throttling trigger)"
  row4: "0x18 | u64   | memory.events | oom_kill counter: 1"
  row5: "0x20 | struct| memory.stat | anon 95M, file 5M"
  sz: "Total: 48 bytes (Internal sysfs representaton)"
}

kernel_oom_subsystem: {
  shape: class
  label: "Kernel OOM Killer (mm/oom_kill.c)"
  definition: |'c
    struct oom_control {
        struct mem_cgroup *memcg;
        gfp_t gfp_mask;
        int order;
    };
  '|
  methods: |'c
    bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg);
    void select_bad_process(struct oom_control *oc);
    long oom_badness(struct task_struct *p);
  '|
}

# --- STATE EVOLUTION ---

state_start: Container Initialized {
  class: state_node
  label: "Initial State"
  info: "memory.current: 10MB / 100MB"
}

state_alloc: Allocation Burst {
  class: state_node
  label: "Active Workload"
  code: |'c
    while(1) {
        ptr = malloc(1024*1024);
        memset(ptr, 0, 1024*1024);
    }
  '|
}

state_pressure: High Pressure {
  class: state_node
  style.fill: "#fff2cc"
  label: "Pressure Alert"
  info: "Usage > memory.high (90MB)"
}

state_reclaim: Direct Reclaim {
  class: kernel_logic
  label: "Kernel: try_to_free_mem_cgroup_pages()"
  code: |'c
    // Kernel tries to drop Page Cache
    // before killing processes
    reclaim_stat = do_try_to_free_pages(memcg);
  '|
}

state_oom_entry: Hard Limit Hit {
  class: [state_node; danger_zone]
  label: "Limit Ceiling"
  info: "memory.current == memory.max (100MB)"
}

state_select: Process Selection {
  class: kernel_logic
  label: "OOM Scoring Algorithm"
  code: |'c
    points = p->mm->rss + get_mm_counter(p->mm, MM_FILEPAGES);
    points += p->signal->oom_score_adj;
    return points; // Victim = max points
  '|
}

state_kill: Execution {
  class: [state_node; danger_zone]
  label: "SIGKILL Delivery"
  info: "Victim: PID 47832 (oom_test)"
}

state_recovery: Recovery {
  class: state_node
  style.fill: "#d5e8d4"
  label: "Post-OOM Clean"
  info: "memory.current -> 2MB"
}

# --- CONNECTIONS ---

state_start -> state_alloc: "Page Faults | +80MB | malloc loop"

state_alloc -> state_pressure: "Threshold Hit | 90MB | memory.high reached"

state_pressure -> state_reclaim: "Kernel Hook | - | Direct Reclaim Scan"

state_reclaim -> state_oom_entry: "Reclaim Fail | 100MB | Usage > Reclaimable" {
  style.stroke: red
  style.stroke-width: 2
}

state_oom_entry -> kernel_oom_subsystem: "gfp_mask | - | mem_cgroup_out_of_memory()"

kernel_oom_subsystem -> state_select: "Task Walk | - | struct task_struct* list"

state_select -> state_kill: "Badness Score | PID 47832 | oom_badness()"

state_kill -> state_recovery: "Release RSS | -98MB | mm_struct cleanup"

state_recovery -> cgroup_v2: "Event Counter | 8 bytes | oom_kill++"

# --- LEGEND/NOTES ---

annotation: {
  label: "TECHNICAL NOTE: Page Cache Trap"
  content: |'md
    Kernel attributes file cache to the cgroup that read it.
    `cat /large_file` can trigger OOM even if heap usage is low
    due to unevictable file pages or high pressure.
  '|
}
annotation.near: bottom-right