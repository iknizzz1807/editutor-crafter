direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- KERNEL INTERNAL STRUCTURES ---

kernel_logic: {
  shape: class
  label: "Kernel Virtual File System (fs/proc/base.c)"
  
  fields: |'c
    struct file_operations proc_pid_operations;
    struct pid_namespace *active_ns;
  '|

  methods: |'c
    int proc_pid_readdir(struct file *file, struct dir_context *ctx);
    static struct dentry* proc_pid_instantiate(struct dentry *dentry);
    struct pid_namespace* task_active_pid_ns(struct task_struct *tsk);
  '|
}

pid_ns_struct: {
  shape: sql_table
  label: "struct pid_namespace (include/linux/pid_namespace.h)"
  f0: "0x00 | unsigned int   | level // Nesting depth"
  f1: "0x08 | struct idr     | idr   // Local PID radix tree"
  f2: "0x40 | struct task*   | child_reaper // PID 1"
  f3: "0x48 | struct ns_common | ns  // Namespace metadata"
  sz: "Total: 128 bytes"
}

# --- CASE 1: ISOLATED PID NAMESPACE (SUCCESS) ---

case_isolated: {
  label: "CASE 1: CLONE_NEWPID (Isolated)"
  style.stroke: green
  style.stroke-width: 4

  container_a: {
    label: "Container Process (PID 1)"
    style.fill: "#E1F5FE"
    
    ps_output: {
      shape: code
      label: "ls /proc output"
      code: |'bash
        1/
        2/
        self/
      '|
    }
  }

  container_a -> kernel_logic: "getdents64() | 0 bytes | fd=3" {
    style.stroke: blue
  }
  
  kernel_logic -> pid_ns_struct: "Lookup local IDR | 8 bytes | level=1" {
    style.stroke: purple
  }

  kernel_logic -> container_a: "dirent[] | 96 bytes | {1, 2, self}" {
    style.stroke: green
  }
}

# --- CASE 2: SHARED PID NAMESPACE (LEAK) ---

case_leaky: {
  label: "CASE 2: NO CLONE_NEWPID (Information Leak)"
  style.stroke: red
  style.stroke-width: 4
  
  container_b: {
    label: "Container Process (Host PID 47832)"
    style.fill: "#FFEBEE"

    ps_output: {
      shape: code
      label: "ls /proc output"
      code: |'bash
        1/      # systemd
        478/    # dbus
        1024/   # sshd
        47832/  # self
      '|
    }
  }

  container_b -> kernel_logic: "getdents64() | 0 bytes | fd=3" {
    style.stroke: red
  }

  kernel_logic -> container_b: "dirent[] | 4KB+ | {1, 478, 1024, ...}" {
    style.stroke: red
    style.stroke-dash: 4
  }
}

# --- EXPLANATION ANNOTATIONS ---

annotation_logic: {
  label: "How it works: proc_pid_readdir()"
  style.fill: "#FFF9C4"
  width: 400
  
  logic: |'c
    // The kernel doesn't look at "files" on disk.
    // It iterates the task list of the CALLER'S namespace.
    struct pid_namespace *ns = task_active_pid_ns(current);
    for (pid = next_tgid(ns, iter); pid; ...) {
        proc_fill_cache(ctx, name, len, ...);
    }
  '|
}

annotation_logic.near: top-center

# --- LEGEND ---
legend: {
  near: bottom-right
  
  c1: "Green: Isolated Path" {
    style.font-color: green
    shape: text
  }
  c2: "Red: Information Leak Path" {
    style.font-color: red
    shape: text
  }
  c3: "Blue: Syscall Invocation" {
    style.font-color: blue
    shape: text
  }
}