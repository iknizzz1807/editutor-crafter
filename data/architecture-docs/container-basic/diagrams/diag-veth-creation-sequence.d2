direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

title: {
  label: "veth Pair Lifecycle: Cross-Namespace Networking (network.c)"
  shape: text
  near: top-center
}

# --- State Legend ---
legend: {
  shape: sql_table
  label: "Kernel State Key"
  near: bottom-right
  v: "Blue | Data Path"
  p: "Purple | Kernel Object"
  r: "Red | Blocking/Pitfall"
}

# --- THE SEQUENCE ---

step1: {
  label: "STEP 1: Atomic Pair Creation"
  info: "syscall: RTM_NEWLINK (type: veth)"
  
  host_ns: {
    label: "Host Net Namespace (struct net*)"
    devs: {
      shape: sql_table
      label: "struct net_device[]"
      d1: "0x00 | char[16] | lo | 127.0.0.1/8 | UP"
      d2: "0x40 | char[16] | eth0 | 192.168.1.50 | UP"
      d3: "0x80 | char[16] | veth-host | (unassigned) | DOWN"
      d4: "0xC0 | char[16] | veth-ctr | (unassigned) | DOWN"
    }
  }
  
  container_ns: {
    label: "Container Net Namespace (Empty)"
    devs: {
      shape: sql_table
      label: "struct net_device[]"
      d1: "0x00 | char[16] | lo | (unmapped) | DOWN"
    }
  }
  
  host_ns.devs.d3 <-> host_ns.devs.d4: "L2 Virtual Wire | veth_priv*"
}

step2: {
  label: "STEP 2: Namespace Migration"
  info: "syscall: RTM_SETLINK (IFLA_NET_NS_PID: 1234)"
  
  host_ns: {
    label: "Host Net Namespace"
    devs: {
      shape: sql_table
      label: "struct net_device[]"
      d1: "0x00 | lo | 127.0.0.1/8 | UP"
      d2: "0x40 | eth0 | 192.168.1.50 | UP"
      d3: "0x80 | veth-host | (unassigned) | DOWN"
      empty: "0xC0 | veth-ctr | MOVED | â†’"
    }
  }
  
  container_ns: {
    label: "Container Net Namespace (PID 1234)"
    devs: {
      shape: sql_table
      label: "struct net_device[]"
      d1: "0x00 | lo | (unmapped) | DOWN"
      d4: "0x40 | veth-ctr | (unassigned) | DOWN"
    }
  }

  host_ns.devs.d3 -> container_ns.devs.d4: "Pointer Migration | task->nsproxy->net_ns" {
    style.stroke: "#B5AFF6"
    style.stroke-width: 3
  }
}

step3: {
  label: "STEP 3: L3 Configuration"
  info: "syscall: RTM_NEWADDR / RTM_NEWROUTE"
  
  host_ns: {
    label: "Host Namespace"
    devs: {
      shape: sql_table
      label: "struct net_device[]"
      d3: "0x00 | veth-host | 172.20.0.1/24 | DOWN"
    }
  }
  
  container_ns: {
    label: "Container Namespace"
    devs: {
      shape: sql_table
      label: "struct net_device[]"
      d4: "0x00 | veth-ctr | 172.20.0.2/24 | DOWN"
    }
    route: "Default Route -> 172.20.0.1"
  }
}

step4: {
  label: "STEP 4: Bridge Integration"
  info: "ip link set veth-host master ctr0"
  
  host_ns: {
    label: "Host Namespace"
    bridge: {
      shape: sql_table
      label: "struct net_device (ctr0)"
      f1: "IP: 172.20.0.1"
      f2: "Master: L2 Switch Hub"
    }
    veth: {
      shape: sql_table
      label: "veth-host (Slave)"
      f1: "Master -> ctr0"
    }
  }
  host_ns.bridge -> host_ns.veth: "Aggregation | netdev_master_upper_dev_get"
}

step5: {
  label: "STEP 5: Activation"
  info: "ip link set up"
  
  status: {
    shape: sql_table
    label: "Final Connectivity"
    s1: "veth-host: UP / LOWER_UP"
    s2: "veth-ctr: UP / LOWER_UP"
    s3: "lo: UP"
  }
  style.fill: "#E1F5FE"
}

# --- PITFALL HIGHLIGHT ---

pitfall_warning: {
  shape: callout
  label: "PITFALL: PID Boundary Hazard"
  content: |'md
    **The Error:** Calling `clone(CLONE_NEWNET)` *after* attempting to move the veth.
    **The Reality:** You cannot call `ip link set netns <pid>` until the container PID is returned by `clone()`.
    **The Fix:** Use a synchronization pipe. Host waits for PID, creates veth, moves end, *then* signals container to continue.
  '|
  style.fill: "#FFEBEE"
  style.stroke: red
}

pitfall_warning.near: bottom-left

# --- CONNECTIONS ---

step1 -> step2: "Move Endpoint | 0 bytes | syscall"
step2 -> step3: "Assign IP | 4 bytes | 172.20.0.2"
step3 -> step4: "Join Bridge | ptr | &bridge_dev"
step4 -> step5: "Set UP | flag | IFF_UP"

# --- KERNEL CODE SNIPPETS ---

host_logic: {
  label: "Parent Process (host.c)"
  code: |'c
    // Phase 1: Create pair
    run("ip link add veth_h0 type veth peer veth_c0");
    // Phase 2: Move endpoint to child
    run("ip link set veth_c0 netns %d", container_pid);
    // Phase 3: Signal sync pipe
    write(sync_pipe[1], "1", 1);
  '|
  width: 400
}

container_logic: {
  label: "Child Process (container.c)"
  code: |'c
    // Phase 4: Wait for move to complete
    read(sync_pipe[0], &ready, 1);
    // Phase 5: Now interface exists here
    run("ip addr add 172.20.0.2/24 dev veth_c0");
    run("ip link set veth_c0 up");
  '|
  width: 400
}

host_logic -> step1
container_logic -> step5