direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}
# ─────────────────────────────────────────────────────────────
# LAYER 0 — DATA STRUCTURES
# ─────────────────────────────────────────────────────────────
layer_data: {
  label: "DATA LAYER — Structs & Kernel Interfaces"
  direction: down
  style.fill: "#F0F4FF"
  style.stroke: "#6B8DD6"
  container_config: {
    shape: sql_table
    label: "struct ContainerConfig  (container.h)  [M1–M5]"
    argv:            "char**       | ptr to execvp args array"
    hostname:        "char[64]     | UTS ns hostname  (64 B)"
    rootfs:          "char*        | abs path to rootfs  [M2+]"
    outbound_iface:  "char*        | host egress iface  [M3+]"
    sync_pipe_read:  "int          | read-end fd for sync  [M3+]"
    host_uid:        "uid_t        | caller real UID  [M5]"
    host_gid:        "gid_t        | caller real GID  [M5]"
    stack_base:      "void*        | mmap base ptr"
    stack_size:      "size_t       | 1 MiB fixed"
    sz:              "Total: 120 bytes  (2 cache lines)"
  }
  cgroup_config: {
    shape: sql_table
    label: "struct CgroupConfig  (cgroup.h)  [M4]"
    memory_limit_bytes: "int64_t  | RAM cap; -1=unlimited"
    cpu_quota_us:       "int64_t  | CFS quota μs per period"
    cpu_period_us:      "int64_t  | CFS period μs (default 100000)"
    pids_max:           "int32_t  | max tasks; -1=unlimited"
    pad:                "uint8_t[4] | alignment padding"
    sz:                 "Total: 32 bytes  (½ cache line)"
  }
  stack_layout: {
    shape: sql_table
    label: "Child Stack Layout  x86-64  [M1]"
    guard_page:    "4096 B    | PROT_NONE  — overflow sentinel"
    usable_stack:  "~1044480 B| PROT_READ|WRITE  — stack frames"
    stack_top:     "base+1MiB | RSP passed to clone()"
    sz:            "Total: 1 MiB  (MAP_STACK | MAP_ANONYMOUS)"
  }
  cap_data: {
    shape: sql_table
    label: "struct __user_cap_data_struct  (capability.h)  [M5]"
    effective_0:   "uint32_t | bits 0-31   (CAP_NET_ADMIN=bit12)"
    effective_1:   "uint32_t | bits 32-63  (CAP_SYS_ADMIN=bit21)"
    permitted_0:   "uint32_t | permitted set word 0"
    permitted_1:   "uint32_t | permitted set word 1"
    sz:            "Total: 16 bytes per struct; 2 structs = 32 B"
  }
  mount_flags: {
    shape: sql_table
    label: "Mount Flag Bitmasks  (sys/mount.h)  [M2]"
    MS_REC:        "0x4000   | recurse entire subtree"
    MS_PRIVATE:    "0x40000  | no propagation in/out"
    MS_BIND:       "0x1000   | bind-mount (needed for pivot)"
    MS_NOSUID:     "0x0002   | ignore setuid bits"
    MS_NOEXEC:     "0x0008   | no exec from this FS"
    MS_RDONLY:     "0x0001   | read-only mount"
    MNT_DETACH:    "0x0002   | lazy umount2 flag"
  }
  ns_flags: {
    shape: sql_table
    label: "Clone Namespace Flags  (sched.h)  [M1–M5]"
    CLONE_NEWUSER: "0x10000000 | user ns — rootless  [M5]"
    CLONE_NEWPID:  "0x20000000 | PID ns  [M1]"
    CLONE_NEWUTS:  "0x04000000 | UTS/hostname ns  [M1]"
    CLONE_NEWNS:   "0x00020000 | mount ns  [M2]"
    CLONE_NEWNET:  "0x40000000 | network ns  [M3]"
    SIGCHLD:       "0x00000011 | notify parent on exit"
    combined:      "All ORed → single atomic clone() call"
  }
  net_constants: {
    shape: sql_table
    label: "Network Constants  (common.h)  [M3]"
    BRIDGE_NAME:   "ctr0             | virtual L2 switch"
    BRIDGE_IP:     "172.20.0.1       | container gateway"
    BRIDGE_CIDR:   "172.20.0.1/24    | bridge subnet"
    CONT_IP:       "172.20.0.2       | container veth IP"
    CONT_CIDR:     "172.20.0.2/24"
    VETH_HOST:     "veth_h0          | host-side veth end"
    VETH_CONT:     "veth_c0          | container-side veth end"
  }
}
# ─────────────────────────────────────────────────────────────
# LAYER 1 — LOGIC MODULES
# ─────────────────────────────────────────────────────────────
layer_logic: {
  label: "LOGIC LAYER — Modules & Algorithms"
  direction: down
  style.fill: "#F5FFF0"
  style.stroke: "#5BAD72"
  # ── M1: Clone Orchestration ──────────────────────────────
  main_mod: {
    shape: class
    label: "main()  (main.c)  [M1–M5]"
    fields: |'c
      // Host-side state
      pid_t  container_pid;   // returned by clone()
      int    sync_pipe[2];    // coordination pipe
      char  *stack;           // mmap base
      int    status;          // waitpid exit status
    '|
    methods: |'c
      int    main(int argc, char** argv);
      void*  prepare_stack(size_t size);
      void   cleanup_network(const char* iface);
      void   cleanup_on_exit(void);
    '|
  }
  clone_seq: {
    label: "clone() Orchestration  [M1]"
    style.fill: "#E8FFE8"
    step1: {
      label: "1. mmap stack (1 MiB)"
      style.fill: white
    }
    step2: {
      label: "2. mprotect guard page"
      style.fill: white
    }
    step3: {
      label: "3. pipe(sync_pipe)"
      style.fill: white
    }
    step4: {
      label: "4. clone(NEWUSER|NEWPID|NEWUTS|NEWNS|NEWNET|SIGCHLD)"
      style.fill: white
    }
    step5: {
      label: "5. write uid_map → setgroups=deny → gid_map"
      style.fill: white
    }
    step6: {
      label: "6. cgroup_setup() + setup_host_network()"
      style.fill: white
    }
    step7: {
      label: "7. write sync_pipe[1] '1'  → unblock child"
      style.fill: white
    }
    step8: {
      label: "8. waitpid → cleanup"
      style.fill: white
    }
    step1 -> step2 -> step3 -> step4 -> step5 -> step6 -> step7 -> step8
  }
  # ── M1: Container Init (PID 1) ────────────────────────────
  init_mod: {
    shape: class
    label: "container_init()  (init.c)  [M1–M5]"
    fields: |'c
      // All fields via ContainerConfig* arg
      // PID inside namespace: getpid() == 1
      // Phase order enforced by sync pipe
    '|
    methods: |'c
      int   container_init(void* arg);
      void  verify_pid_namespace(void);
      void  verify_capabilities(void);
      void  reap_zombies(void);
      int   set_oom_score_adj(int adj);
    '|
  }
  pid1_loop: {
    label: "PID 1 Reaper Loop  (reaper.c)  [M1]"
    style.fill: "#FFFDE8"
    code: |'c
      while (1) {
        pid_t p = waitpid(-1, &st, 0);
        if (p == main_task) {
          reap_zombies(); /* WNOHANG sweep */
          return WEXITSTATUS(st);
        } else if (p > 0)  fprintf(stderr,"reaped %d",p);
        else if (errno==ECHILD) break;
        else if (errno==EINTR)  continue;
      }
    '|
  }
  # ── M2: Filesystem Isolation ──────────────────────────────
  fs_mod: {
    shape: class
    label: "filesystem.c  [M2]"
    fields: |'c
      // No persistent state — all operations
      // are sequenced inside container_init()
    '|
    methods: |'c
      int  set_mounts_private(void);
      int  bind_mount_rootfs(const char* rootfs);
      int  do_pivot_root(const char* rootfs);
      int  mount_pseudofs(void);
      int  create_rootfs_dirs(const char* rootfs);
      void bind_dev_nodes(void);
    '|
  }
  pivot_seq: {
    label: "pivot_root() Sequence  [M2]"
    style.fill: "#FFF8E1"
    p1: { label: "mount(NULL,/,NULL,MS_REC|MS_PRIVATE)"; style.fill: white }
    p2: { label: "mount(rootfs,rootfs,NULL,MS_BIND|MS_REC)"; style.fill: white }
    p3: { label: "mkdir(rootfs/.pivot_old)"; style.fill: white }
    p4: { label: "syscall(SYS_pivot_root,rootfs,old)"; style.fill: white }
    p5: { label: "chdir('/')"; style.fill: white }
    p6: { label: "umount2('/.pivot_old',MNT_DETACH)"; style.fill: white }
    p7: { label: "rmdir('/.pivot_old')"; style.fill: white }
    p8: { label: "mount_pseudofs() — proc/sys/dev"; style.fill: white }
    p1 -> p2 -> p3 -> p4 -> p5 -> p6 -> p7 -> p8
  }
  # ── M3: Networking ────────────────────────────────────────
  net_host_mod: {
    shape: class
    label: "net_host.c  [M3]"
    fields: |'c
      // Cleanup registered via atexit()
    '|
    methods: |'c
      int  setup_host_network(pid_t pid, const char* iface);
      int  setup_bridge(void);
      int  create_veth_pair(void);
      int  attach_veth_to_bridge(void);
      int  move_veth_to_container(pid_t pid);
      int  enable_ip_forwarding(void);
      int  setup_nat(const char* outbound_iface);
      int  write_resolv_conf(const char* rootfs);
    '|
  }
  net_cont_mod: {
    shape: class
    label: "net_container.c  [M3]"
    fields: |'c
      // Executes inside container namespace
    '|
    methods: |'c
      int  setup_container_network(void);
      // 1. ip link set lo up
      // 2. ip addr add CONT_CIDR dev veth_c0
      // 3. ip link set veth_c0 up
      // 4. ip route add default via BRIDGE_IP
    '|
  }
  sync_proto: {
    label: "Two-Phase Sync Protocol  [M3]"
    style.fill: "#E8F4FF"
    s1: { label: "HOST: clone(CLONE_NEWNET)"; style.fill: white }
    s2: { label: "CHILD: read(pipe) → BLOCKS"; style.fill: white }
    s3: { label: "HOST: create veth pair"; style.fill: white }
    s4: { label: "HOST: ip link set veth_c0 netns <pid>"; style.fill: white }
    s5: { label: "HOST: bridge + NAT + forwarding"; style.fill: white }
    s6: { label: "HOST: write(pipe,'1')"; style.fill: white }
    s7: { label: "CHILD: unblocks → setup_container_network()"; style.fill: white }
    s1 -> s2
    s1 -> s3 -> s4 -> s5 -> s6 -> s7
  }
  # ── M4: Cgroup Manager ────────────────────────────────────
  cg_mod: {
    shape: class
    label: "cg_v2.c / cg_v1.c  [M4]"
    fields: |'c
      int   cgroup_version;  // 1 or 2, auto-detected
      char  name[256];       // e.g. "mycontainer"
      char  root[512];       // /sys/fs/cgroup
    '|
    methods: |'c
      int   detect_cgroup_version(void);
      int   enable_controllers_v2(const char* parent);
      int   cg_write_str(const char* dir, const char* f, const char* v);
      int   cg_write_long(const char* dir, const char* f, long v);
      int   cg_read_str(const char* dir, const char* f, char* buf, size_t n);
      int   cgroup_setup(const char* name, pid_t pid, CgroupConfig* cfg);
      int   cgroup_setup_v2(const char* name, pid_t pid, CgroupConfig* cfg);
      int   cgroup_setup_v1(const char* name, pid_t pid, CgroupConfig* cfg);
      void  cgroup_report_v2(const char* name);
      void  cgroup_cleanup(const char* name);
    '|
  }
  cg_seq: {
    label: "Cgroup Setup Sequence  [M4]"
    style.fill: "#FFF0F0"
    c1: { label: "detect_cgroup_version() — stat cgroup.controllers"; style.fill: white }
    c2: { label: "enable_controllers_v2() — write +memory +cpu +pids"; style.fill: white }
    c3: { label: "mkdir /sys/fs/cgroup/<name>"; style.fill: white }
    c4: { label: "write container_pid → cgroup.procs  ← CRITICAL WINDOW"; style.fill: "#FFE0E0" }
    c5: { label: "write memory.max + memory.swap.max=0"; style.fill: white }
    c6: { label: "write cpu.max  '50000 100000'"; style.fill: white }
    c7: { label: "write pids.max  32"; style.fill: white }
    c8: { label: "write sync_pipe[1] '1'  → child exec()s with limits"; style.fill: white }
    c1 -> c2 -> c3 -> c4 -> c5 -> c6 -> c7 -> c8
  }
  # ── M5: User Namespace ────────────────────────────────────
  userns_mod: {
    shape: class
    label: "userns.c  [M5]"
    fields: |'c
      // Operates on /proc/<pid>/ files
      // Mandatory write order enforced by kernel
    '|
    methods: |'c
      int  proc_write(pid_t pid, const char* file, const char* content);
      int  write_uid_gid_maps(pid_t pid, uid_t huid, gid_t hgid);
      void verify_capabilities(void);
      // write order: uid_map → setgroups=deny → gid_map
    '|
  }
  uid_seq: {
    label: "UID Map Write Sequence  [M5] — MANDATORY ORDER"
    style.fill: "#F5E8FF"
    u1: { label: "getuid() / getgid() before clone()"; style.fill: white }
    u2: { label: "clone(CLONE_NEWUSER|...) → child UID=65534(nobody)"; style.fill: white }
    u3: { label: "proc_write(pid,'uid_map','0 1000 1')"; style.fill: white }
    u4: { label: "proc_write(pid,'setgroups','deny')  ← MUST precede gid_map"; style.fill: "#FFE0E0" }
    u5: { label: "proc_write(pid,'gid_map','0 1000 1')"; style.fill: white }
    u6: { label: "kernel: elevates child cap set to FULL effective bits"; style.fill: "#E8FFE8" }
    u1 -> u2 -> u3 -> u4 -> u5 -> u6
  }
}
# ─────────────────────────────────────────────────────────────
# LAYER 2 — KERNEL / HARDWARE INTERFACES
# ─────────────────────────────────────────────────────────────
layer_kernel: {
  label: "KERNEL / HARDWARE LAYER — Syscalls & Subsystems"
  direction: down
  style.fill: "#FFFAF0"
  style.stroke: "#C08040"
  syscall_table: {
    shape: sql_table
    label: "Primary Syscalls  (Linux 5.x)  [M1–M5]"
    clone:       "clone(fn,stack_top,flags,arg) → pid_t | fork+ns creation"
    mmap:        "mmap(NULL,1MiB,PROT_RW,MAP_PRIV|ANON|STACK,-1,0)"
    mprotect:    "mprotect(base,4096,PROT_NONE) | guard page"
    waitpid:     "waitpid(-1,&st,WNOHANG|0)     | zombie reap"
    sethostname: "sethostname(name,len)           | UTS ns  [M1]"
    mount:       "mount(src,dst,type,flags,data)  | VFS  [M2]"
    pivot_root:  "syscall(SYS_pivot_root,new,old) | root swap  [M2]"
    umount2:     "umount2(path,MNT_DETACH)        | lazy unmount  [M2]"
    capget:      "syscall(SYS_capget,hdr,data)    | capability read  [M5]"
  }
  cfs_subsys: {
    shape: sql_table
    label: "CFS Bandwidth Controller  (kernel/sched/)  [M4]"
    cpu_max_v2:      "cpu.max = 'quota_us period_us' | e.g. '50000 100000'"
    throttled_usec:  "cpu.stat:throttled_usec | μs processes spent paused"
    nr_throttled:    "cpu.stat:nr_throttled   | count of throttled periods"
    period_size:     "100ms default  — balance latency vs overhead"
    mechanism:       "runtime_remaining counter; hrtimer refills each period"
  }
  mem_subsys: {
    shape: sql_table
    label: "Memory Cgroup Controller  [M4]"
    memory_max:      "memory.max       = 104857600  (100 MiB)"
    memory_swap_max: "memory.swap.max  = 0  ← prevent swap evasion"
    memory_current:  "memory.current   — live RSS bytes (read-only)"
    oom_path:        "do_page_fault → mem_cgroup_charge → OOM killer"
    oom_signal:      "SIGKILL to selected process — NOT catchable"
    page_fault_cost: "50–200 ns overhead per page fault for accounting"
  }
  pid_subsys: {
    shape: sql_table
    label: "PID Cgroup Controller  [M4]"
    pids_max:     "pids.max     = 32   | hard ceiling"
    pids_current: "pids.current        | live count (read-only)"
    mechanism:    "copy_process() atomic compare — ~5-20 ns overhead"
    on_exceed:    "fork()/clone() returns EAGAIN (ENOENT in userspace)"
  }
  vfs_subsys: {
    shape: sql_table
    label: "VFS Mount Subsystem  [M2]"
    mount_struct:    "struct mount ~200B | kernel slab per mountpoint"
    namespace_lock:  "rwsem namespace_lock | serialises pivot_root"
    pivot_latency:   "2–10 μs  | pointer surgery, no I/O"
    propagation:     "MS_SHARED|MS_SLAVE|MS_PRIVATE|MS_UNBINDABLE"
    proc_mountinfo:  "/proc/<pid>/mountinfo — debug mount ns from host"
  }
  net_subsys: {
    shape: sql_table
    label: "Kernel Network Subsystem  [M3]"
    veth_xmit:     "veth_xmit() — zero-copy sk_buff ptr move"
    bridge_fdb:    "struct net_bridge  — L2 MAC forwarding table"
    conntrack:     "nf_conntrack — stateful NAT for MASQUERADE"
    veth_latency:  "15–40 μs RTT container-to-container"
    masq_cost:     "200–500 ns per packet (conntrack lookup + rewrite)"
    ip_forward:    "/proc/sys/net/ipv4/ip_forward must = 1"
  }
  uid_map_kernel: {
    shape: sql_table
    label: "User Namespace UID Map  (kernel/user_ns.c)  [M5]"
    struct_size:   "struct user_namespace ~400 B in kernel slab"
    map_entries:   "uid_gid_map_entry array; max 340 entries; linear scan"
    translate_ns:  "O(1) for 1-entry map (our case: ~3-10 ns per stat())"
    cap_elevation: "atomic with gid_map close — kernel raises CapEff to 0xFFFF…"
    host_capeff:   "CapEff: 0x0000000000000000 visible in /proc/<pid>/status"
    ns_inode:      "/proc/<pid>/ns/user  → unique inode per namespace"
  }
}
# ─────────────────────────────────────────────────────────────
# LAYER 3 — INTEGRATION / PACKET PATH
# ─────────────────────────────────────────────────────────────
layer_io: {
  label: "I/O & INTEGRATION LAYER — Packet Walk & Observability"
  direction: down
  style.fill: "#F8F0FF"
  style.stroke: "#9060C0"
  packet_walk: {
    shape: sql_table
    label: "Packet Walk: Container → Internet  [M3]"
    step1: "container process: connect(8.8.8.8:443) → SYN src=172.20.0.2"
    step2: "route lookup in container ns: default via 172.20.0.1 dev veth_c0"
    step3: "veth_c0 → veth_xmit() → sk_buff moved to veth_h0 RX queue"
    step4: "veth_h0 is bridge port → ctr0 bridge receives; FDB lookup"
    step5: "ctr0 → host routing table → next hop eth0"
    step6: "netfilter POSTROUTING: MASQUERADE src=172.20.0.2→host_IP"
    step7: "conntrack saves (172.20.0.2:N) ↔ (host_IP:N) translation"
    step8: "response arrives → PREROUTING DNAT via conntrack → container"
  }
  obs_files: {
    shape: sql_table
    label: "Kernel Observability Files  [M4]"
    cpu_stat:       "/sys/fs/cgroup/<n>/cpu.stat  → throttled_usec"
    mem_current:    "/sys/fs/cgroup/<n>/memory.current  → live RSS"
    pids_current:   "/sys/fs/cgroup/<n>/pids.current  → task count"
    nspid:          "/proc/<host_pid>/status  NSpid field"
    ns_mnt:         "/proc/<pid>/ns/mnt  → inode = namespace ID"
    mountinfo:      "/proc/<pid>/mountinfo  → pivot_root verification"
    oom_dmesg:      "dmesg | grep oom-kill → CONSTRAINT_MEMCG events"
  }
  error_matrix: {
    shape: sql_table
    label: "Error Matrix — Top Pitfalls  [M1–M5]"
    e1: "EPERM on clone()    | missing CAP_SYS_ADMIN or NEWUSER disabled"
    e2: "EINVAL on pivot_root| new_root not a mount point — bind first"
    e3: "EINVAL on memory.max| subtree_control not enabled in parent cg"
    e4: "EPERM on gid_map    | setgroups=deny not written first  [M5]"
    e5: "EBUSY on cg rmdir   | waitpid() not called before cleanup"
    e6: "No internet in ctr  | ip_forward=0 or iptables FORWARD missing"
    e7: "Zombie accumulation | PID 1 not calling waitpid(-1,WNOHANG)"
    e8: "stack bottom passed | clone() stack_top must be base+STACK_SIZE"
  }
}
# ─────────────────────────────────────────────────────────────
# MILESTONE INDEX
# ─────────────────────────────────────────────────────────────
milestone_index: {
  shape: sql_table
  label: "Milestone Index"
  m1: "M1 | container-basic-m1 | PID + UTS Namespace Isolation"
  m2: "M2 | container-basic-m2 | Mount Namespace + pivot_root()"
  m3: "M3 | container-basic-m3 | Network Namespace + veth + NAT"
  m4: "M4 | container-basic-m4 | Cgroups v2 Resource Limits"
  m5: "M5 | container-basic-m5 | User Namespace + Rootless Containers"
}
milestone_index.near: bottom-center
# ─────────────────────────────────────────────────────────────
# INTER-LAYER CONNECTIONS
# ─────────────────────────────────────────────────────────────
# Data → Logic connections
layer_data.container_config -> layer_logic.main_mod: "ContainerConfig* | passed to clone() | {argv,rootfs,sync_pipe_read,...}"
layer_data.container_config -> layer_logic.init_mod: "ContainerConfig* | arg in container_init() | child reads after pipe unblocks"
layer_data.cgroup_config -> layer_logic.cg_mod: "CgroupConfig* | resource limits | {100MiB,50ms/100ms,32 pids}"
layer_data.stack_layout -> layer_logic.main_mod: "void* stack_top | passed to clone() | base+1MiB (x86-64 grows down)"
layer_data.ns_flags -> layer_logic.clone_seq: "uint32_t flags bitmask | ORed flags | CLONE_NEWUSER|NEWPID|NEWUTS|NEWNS|NEWNET|SIGCHLD"
layer_data.mount_flags -> layer_logic.pivot_seq: "uint32_t flag | mount() calls | MS_PRIVATE|MS_BIND|MNT_DETACH"
layer_data.net_constants -> layer_logic.net_host_mod: "string constants | ip commands | BRIDGE_NAME ctr0, CONT_IP 172.20.0.2"
layer_data.cap_data -> layer_logic.userns_mod: "capget() struct | capability verify | CapEff bit 21=CAP_SYS_ADMIN"
# Logic internal connections
layer_logic.main_mod -> layer_logic.clone_seq: "orchestrates | sequential steps | clone→maps→cgroup→net→signal"
layer_logic.clone_seq -> layer_logic.init_mod: "pid_t container_pid | clone() return | child executes container_init"
layer_logic.init_mod -> layer_logic.pid1_loop: "fork()+exec() | child_pid | main_task tracked for exit"
layer_logic.init_mod -> layer_logic.pivot_seq: "calls in order | filesystem isolation | [M2] phase before exec"
layer_logic.init_mod -> layer_logic.sync_proto: "read(pipe) blocks | then setup_container_network() | [M3]"
layer_logic.sync_proto -> layer_logic.net_host_mod: "host side | setup_host_network(pid,iface) | before write(pipe)"
layer_logic.sync_proto -> layer_logic.net_cont_mod: "container side | after pipe unblocks | ip cmds inside ns"
layer_logic.main_mod -> layer_logic.cg_seq: "after clone, before pipe signal | cgroup_setup(name,pid,cfg)"
layer_logic.cg_seq -> layer_logic.cg_mod: "delegates | v1 or v2 dispatch | detect_cgroup_version()"
layer_logic.main_mod -> layer_logic.uid_seq: "first action after clone | write maps before pipe signal"
layer_logic.uid_seq -> layer_logic.userns_mod: "proc_write calls | uid_map→setgroups→gid_map | strict order"
# Logic → Kernel connections
layer_logic.clone_seq -> layer_kernel.syscall_table: "clone(2) | CLONE_NEWUSER|…|SIGCHLD | ~20-50μs"
layer_logic.pivot_seq -> layer_kernel.vfs_subsys: "pivot_root(2) + umount2(2) | pointer surgery in mount ns | 2-10μs"
layer_logic.cg_seq -> layer_kernel.mem_subsys: "write memory.max | 104857600 B | OOM kill on exceed"
layer_logic.cg_seq -> layer_kernel.cfs_subsys: "write cpu.max | '50000 100000' | throttle at quota"
layer_logic.cg_seq -> layer_kernel.pid_subsys: "write pids.max | 32 | EAGAIN on fork() at limit"
layer_logic.net_host_mod -> layer_kernel.net_subsys: "veth pair + bridge + iptables | RTM_SETLINK netns move | ~5ms setup"
layer_logic.userns_mod -> layer_kernel.uid_map_kernel: "proc_write uid_map/gid_map | '0 1000 1' | atomic cap elevation"
# Kernel → I/O connections
layer_kernel.net_subsys -> layer_io.packet_walk: "sk_buff forwarding | veth_xmit zero-copy | 15-40μs RTT"
layer_kernel.mem_subsys -> layer_io.obs_files: "memory.current | live RSS bytes | read by cAdvisor"
layer_kernel.cfs_subsys -> layer_io.obs_files: "cpu.stat throttled_usec | growing = throttling | Prometheus metric"
layer_kernel.pid_subsys -> layer_io.obs_files: "pids.current | task count | fork bomb containment check"
layer_kernel.uid_map_kernel -> layer_io.obs_files: "NSpid field | /proc/<pid>/status | host PID ↔ ns PID"
# Logic → I/O (error paths)
layer_logic.main_mod -> layer_io.error_matrix: "EPERM,EINVAL,EBUSY | on failure → kill+cleanup | errno logged"
layer_logic.pivot_seq -> layer_io.error_matrix: "EINVAL pivot_root | bind-mount missing | check /proc/self/mountinfo" {
  style.stroke-dash: 4
}
layer_logic.cg_seq -> layer_io.error_matrix: "EINVAL memory.max | subtree_control not set | EPERM if no root" {
  style.stroke-dash: 4
}
# Layer-to-layer ordering arrows
layer_data -> layer_logic: "structs flow into | module fields & params | compile-time layout"
layer_logic -> layer_kernel: "syscalls issued | kernel enforces invariants | ns/cgroup/cap checks"
layer_kernel -> layer_io: "runtime observability | /proc + /sys/fs/cgroup | debug & metrics"