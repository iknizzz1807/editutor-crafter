{
  "title": "Container (Basic): Design Document",
  "overview": "This system implements a basic container runtime using Linux namespaces and cgroups to achieve process isolation. The key architectural challenge is coordinating multiple kernel isolation mechanisms (PID, mount, network namespaces) with resource controls while handling the subtle timing and lifecycle management issues that arise from namespace interactions.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explores why process isolation is needed and how containers solve the fundamental problem of running untrusted code safely on shared systems.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "Mental Model: Apartment Building",
          "summary": "Introduces containers using the analogy of apartment buildings where tenants need privacy and resource allocation"
        },
        {
          "id": "existing-approaches",
          "title": "Existing Isolation Approaches",
          "summary": "Compares virtual machines, chroot jails, and containers with their trade-offs"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what our basic container will and will not implement, focusing on core isolation primitives.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Core isolation capabilities the container must provide"
        },
        {
          "id": "non-goals",
          "title": "Non-Goals",
          "summary": "Advanced container features explicitly out of scope"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Overview of the container runtime components and their relationships, plus recommended code organization.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Main components: namespace manager, mount manager, network manager, and cgroup manager"
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "How to organize the codebase for maintainability and testing"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Key data structures representing container configuration, namespace handles, and resource limits.",
      "subsections": [
        {
          "id": "container-config",
          "title": "Container Configuration",
          "summary": "Structure defining container parameters and resource limits"
        },
        {
          "id": "namespace-handles",
          "title": "Namespace Handles",
          "summary": "References to active namespaces and their cleanup requirements"
        }
      ]
    },
    {
      "id": "pid-namespace-component",
      "title": "PID Namespace Component",
      "summary": "Implements process isolation using PID namespaces, handling the complexities of becoming PID 1 and zombie reaping.",
      "subsections": [
        {
          "id": "pid-mental-model",
          "title": "Mental Model: Hotel Room Numbers",
          "summary": "Explains PID namespaces using hotel room numbering systems"
        },
        {
          "id": "pid-interface",
          "title": "PID Namespace Interface",
          "summary": "Functions for creating and managing PID namespace isolation"
        },
        {
          "id": "pid-init-process",
          "title": "Init Process Responsibilities",
          "summary": "Handling PID 1 duties including zombie process reaping"
        },
        {
          "id": "pid-adrs",
          "title": "Architecture Decision Records",
          "summary": "Key decisions around clone vs unshare and init process design"
        },
        {
          "id": "pid-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Stack direction issues, zombie processes, and signal handling mistakes"
        }
      ]
    },
    {
      "id": "mount-namespace-component",
      "title": "Mount Namespace Component",
      "summary": "Implements filesystem isolation through mount namespaces and pivot_root, creating a contained filesystem view.",
      "subsections": [
        {
          "id": "mount-mental-model",
          "title": "Mental Model: Stage Sets",
          "summary": "Explains mount namespaces using theater stage set changes"
        },
        {
          "id": "mount-interface",
          "title": "Mount Namespace Interface",
          "summary": "Functions for filesystem isolation and root switching"
        },
        {
          "id": "pivot-root-process",
          "title": "Pivot Root Process",
          "summary": "Step-by-step process for switching container filesystem root"
        },
        {
          "id": "mount-adrs",
          "title": "Architecture Decision Records",
          "summary": "Decisions around pivot_root vs chroot and mount propagation"
        },
        {
          "id": "mount-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Mount propagation leaks, pivot_root requirements, and device node issues"
        }
      ]
    },
    {
      "id": "network-namespace-component",
      "title": "Network Namespace Component",
      "summary": "Implements network isolation using network namespaces and veth pairs for connectivity.",
      "subsections": [
        {
          "id": "network-mental-model",
          "title": "Mental Model: Private Phone Systems",
          "summary": "Explains network namespaces using office phone system analogy"
        },
        {
          "id": "network-interface",
          "title": "Network Namespace Interface",
          "summary": "Functions for network isolation and connectivity setup"
        },
        {
          "id": "veth-setup",
          "title": "Veth Pair Configuration",
          "summary": "Creating and configuring virtual ethernet pairs for container networking"
        },
        {
          "id": "network-adrs",
          "title": "Architecture Decision Records",
          "summary": "Decisions around veth vs macvlan and bridge networking"
        },
        {
          "id": "network-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Namespace timing issues, veth cleanup, and NAT configuration"
        }
      ]
    },
    {
      "id": "cgroups-component",
      "title": "Cgroups Resource Management Component",
      "summary": "Implements resource limits using cgroups to control CPU, memory, and process limits.",
      "subsections": [
        {
          "id": "cgroups-mental-model",
          "title": "Mental Model: Budget Allocation",
          "summary": "Explains cgroups using household budget and allowance analogies"
        },
        {
          "id": "cgroups-interface",
          "title": "Cgroups Interface",
          "summary": "Functions for creating and managing resource limits"
        },
        {
          "id": "resource-controllers",
          "title": "Resource Controllers",
          "summary": "Memory, CPU, and process limit controllers and their configuration"
        },
        {
          "id": "cgroups-adrs",
          "title": "Architecture Decision Records",
          "summary": "Decisions around cgroups v1 vs v2 and controller selection"
        },
        {
          "id": "cgroups-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Controller availability, cleanup order, and OOM behavior"
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "How the namespace and cgroup components coordinate during container creation, execution, and cleanup.",
      "subsections": [
        {
          "id": "startup-sequence",
          "title": "Container Startup Sequence",
          "summary": "Step-by-step process of creating all namespaces and resource limits"
        },
        {
          "id": "cleanup-sequence",
          "title": "Container Cleanup Sequence",
          "summary": "Proper teardown order to avoid resource leaks"
        },
        {
          "id": "error-propagation",
          "title": "Error Propagation",
          "summary": "How errors in one component affect others during setup"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Failure modes in namespace creation, resource exhaustion scenarios, and recovery strategies.",
      "subsections": [
        {
          "id": "namespace-failures",
          "title": "Namespace Creation Failures",
          "summary": "Handling insufficient privileges and kernel feature unavailability"
        },
        {
          "id": "resource-exhaustion",
          "title": "Resource Exhaustion",
          "summary": "OOM conditions, CPU throttling, and process limit enforcement"
        },
        {
          "id": "cleanup-failures",
          "title": "Cleanup Failures",
          "summary": "Handling partial cleanup and resource leak prevention"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Test approaches for verifying isolation, resource limits, and proper cleanup behavior.",
      "subsections": [
        {
          "id": "isolation-testing",
          "title": "Isolation Verification Tests",
          "summary": "Tests to verify that namespaces properly isolate processes"
        },
        {
          "id": "resource-limit-testing",
          "title": "Resource Limit Testing",
          "summary": "Tests to verify cgroup limits are enforced correctly"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "What to verify after each milestone implementation"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common issues encountered when building containers, their symptoms, causes, and fixes.",
      "subsections": [
        {
          "id": "namespace-debugging",
          "title": "Namespace Issues",
          "summary": "Debugging PID, mount, and network namespace problems"
        },
        {
          "id": "cgroups-debugging",
          "title": "Cgroups Issues",
          "summary": "Debugging resource limit and cgroup hierarchy problems"
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools and Techniques",
          "summary": "Tools like nsenter, lsns, and proc filesystem inspection"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Additional container features that could be built on this foundation.",
      "subsections": [
        {
          "id": "additional-namespaces",
          "title": "Additional Namespaces",
          "summary": "User, UTS, and IPC namespace support"
        },
        {
          "id": "image-management",
          "title": "Image Management",
          "summary": "Container image layers and overlay filesystems"
        },
        {
          "id": "container-orchestration",
          "title": "Container Orchestration",
          "summary": "Multi-container coordination and service discovery"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key terms including namespaces, cgroups, and container-specific vocabulary.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-overview",
      "title": "Container System Component Overview",
      "description": "Shows the main components (namespace managers, cgroup manager, container process) and their relationships. Includes the host kernel, namespace isolation boundaries, and resource control flows.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-data-flow"
      ]
    },
    {
      "id": "namespace-isolation",
      "title": "Namespace Isolation Diagram",
      "description": "Illustrates how PID, mount, and network namespaces create isolated views for the container process. Shows the host view vs container view for each namespace type.",
      "type": "component",
      "relevant_sections": [
        "pid-namespace-component",
        "mount-namespace-component",
        "network-namespace-component"
      ]
    },
    {
      "id": "container-startup-flow",
      "title": "Container Startup Sequence",
      "description": "Step-by-step flow showing namespace creation order, cgroup setup, process forking, and error handling paths. Shows the coordination between parent and child processes.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "pid-namespace-component"
      ]
    },
    {
      "id": "mount-namespace-transitions",
      "title": "Mount Namespace and Pivot Root Process",
      "description": "Shows the filesystem view transitions during mount namespace creation and pivot_root operation. Includes old root, new root, and mounted filesystems like /proc.",
      "type": "flowchart",
      "relevant_sections": [
        "mount-namespace-component"
      ]
    },
    {
      "id": "network-topology",
      "title": "Container Network Topology",
      "description": "Shows the network namespace isolation with veth pairs connecting container to host bridge. Includes host networking stack, bridge, and container's isolated network view.",
      "type": "component",
      "relevant_sections": [
        "network-namespace-component"
      ]
    },
    {
      "id": "cgroups-hierarchy",
      "title": "Cgroups Resource Control Hierarchy",
      "description": "Shows the cgroup filesystem hierarchy with memory, CPU, and process controllers. Illustrates how container processes are assigned to cgroups and how limits are enforced.",
      "type": "class",
      "relevant_sections": [
        "cgroups-component"
      ]
    },
    {
      "id": "container-lifecycle-states",
      "title": "Container Lifecycle State Machine",
      "description": "State transitions from creation through running to cleanup, including error states. Shows what triggers each transition and what cleanup is required.",
      "type": "state-machine",
      "relevant_sections": [
        "interactions-data-flow",
        "error-handling"
      ]
    },
    {
      "id": "debugging-inspection-points",
      "title": "Container Debugging Inspection Points",
      "description": "Shows where to inspect container state during debugging: /proc filesystem, namespace files, cgroup files, and network interfaces. Maps symptoms to inspection locations.",
      "type": "component",
      "relevant_sections": [
        "debugging-guide"
      ]
    }
  ]
}