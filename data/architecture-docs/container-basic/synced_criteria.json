[
  {
    "milestone_id": "container-basic-m1",
    "criteria": [
      "Create a new PID namespace using clone(CLONE_NEWPID | SIGCHLD) with a correctly allocated and aligned mmap stack; child function executes as PID 1 inside the namespace (getpid() returns 1)",
      "Parent process receives the child's real host PID as the return value of clone() and verifies it is greater than 1 and different from the child's namespace-local PID",
      "Implement a zombie reaping loop in the container init function using waitpid(-1, &status, WNOHANG) that continuously collects all dead children, not just the direct child",
      "Container init forks the user command as a child (fork+exec pattern) rather than directly exec()-ing, keeping PID 1 alive as the reaper while the user process runs as PID 2+",
      "UTS namespace (CLONE_NEWUTS) is created in the same clone() call; sethostname() inside the container sets a distinct name that does not modify the host hostname",
      "Verify PID namespace isolation by reading /proc/self/status inside the container and confirming NSpid shows 1; from the host, /proc/<host_pid>/status NSpid shows both the host PID and 1",
      "Guard page (PROT_NONE) is applied to the bottom 4096 bytes of the mmap stack to detect stack overflow before silent memory corruption",
      "Container init event loop blocks on waitpid(-1, &status, 0) and handles EINTR (retry) and ECHILD (exit loop) errno values correctly",
      "When container PID 1 exits, verify on the host that all processes in the namespace are terminated (SIGKILL sent by kernel to remaining namespace members)",
      "clone() call includes SIGCHLD flag enabling the parent to use waitpid() on the container PID; absence of SIGCHLD is tested and confirmed to cause ECHILD error"
    ]
  },
  {
    "milestone_id": "container-basic-m2",
    "criteria": [
      "CLONE_NEWNS flag is passed to clone() alongside CLONE_NEWPID and CLONE_NEWUTS; the child process operates in an independent mount namespace where mount/unmount operations do not appear on the host",
      "mount(NULL, '/', NULL, MS_REC | MS_PRIVATE, NULL) is called as the first mount operation inside container_init to recursively set all existing mounts to private propagation, preventing any subsequent mount events from leaking to the host mount namespace",
      "The container rootfs directory is bind-mounted onto itself using mount(rootfs, rootfs, NULL, MS_BIND | MS_REC, NULL) before calling pivot_root(), satisfying pivot_root()'s requirement that new_root be an existing mount point",
      "syscall(SYS_pivot_root, rootfs, put_old) atomically swaps the root filesystem; the old root is staged at a .pivot_old subdirectory inside the new rootfs",
      "chdir('/') is called immediately after pivot_root() to reset the working directory to the new root before the old root is unmounted",
      "umount2('/.pivot_old', MNT_DETACH) is called immediately after pivot_root() and chdir(); after this call, no path inside the container can resolve to any host filesystem entry",
      "The .pivot_old staging directory is removed with rmdir() after unmounting, leaving no artifact of the pivot operation",
      "procfs is mounted at /proc inside the container using mount('proc', '/proc', 'proc', MS_NOSUID|MS_NOEXEC|MS_NODEV, NULL) after pivot_root(); ls /proc/ inside the container shows only container PIDs (1, 2, etc.), not host processes",
      "sysfs is mounted at /sys with MS_RDONLY flag; attempting to write to /sys/kernel/ inside the container returns permission denied",
      "A tmpfs is mounted at /dev and essential device nodes (null, zero, random, urandom) are bind-mounted from the host into the container /dev; programs inside the container can write to /dev/null and read from /dev/urandom",
      "Container processes cannot access host filesystem paths after pivot_root + old root unmount; ls /.pivot_old returns ENOENT; host's /etc/shadow is not readable unless a shadow file exists in the container rootfs",
      "The mount namespace inode visible at /proc/<container_host_pid>/ns/mnt differs from /proc/self/ns/mnt on the host, confirming independent mount namespace creation"
    ]
  },
  {
    "milestone_id": "container-basic-m3",
    "criteria": [
      "CLONE_NEWNET flag is passed to clone() combined with CLONE_NEWPID, CLONE_NEWUTS, and CLONE_NEWNS, creating an isolated network namespace where ip link show inside the container shows only lo and veth_c0, not host interfaces like eth0 or wlan0",
      "veth pair (veth_h0 / veth_c0) is created on the host after clone() returns the container PID; veth_c0 is moved into the container namespace using 'ip link set veth_c0 netns <container_pid>', verified by its disappearance from host's ip link output and appearance inside the container",
      "Host-side veth (veth_h0) is attached to a Linux bridge (ctr0) using 'ip link set veth_h0 master ctr0'; bridge is assigned IP 172.20.0.1/24 and brought up; veth_h0 is brought up as a bridge port",
      "Container-side veth (veth_c0) is assigned IP 172.20.0.2/24 inside the container namespace; 'ip addr show veth_c0' confirms the address assignment",
      "Loopback interface is explicitly brought up with 'ip link set lo up' inside the container; 'ping 127.0.0.1 -c 1' succeeds; ip link show lo confirms UP LOWER_UP state",
      "Default route is configured inside the container: 'ip route add default via 172.20.0.1 dev veth_c0'; 'ip route' shows default via 172.20.0.1 and the container can successfully ping 172.20.0.1 (bridge gateway)",
      "ip_forward sysctl is set to 1 on the host ('sysctl net.ipv4.ip_forward=1'); iptables FORWARD rules allow traffic between bridge and outbound interface; iptables POSTROUTING MASQUERADE rule rewrites container source IPs for outbound traffic; container can ping 8.8.8.8",
      "A sync pipe (pipe() syscall) is used to block container_init() until host-side network setup (veth creation, namespace assignment, bridge configuration) is complete; parent writes one byte to unblock the container",
      "DNS is configured by writing 'nameserver 8.8.8.8' and 'nameserver 1.1.1.1' into <rootfs>/etc/resolv.conf before pivot_root(); 'cat /etc/resolv.conf' inside the container shows nameserver entries; 'nslookup google.com' resolves successfully",
      "Network resources (bridge ctr0, veth pair veth_h0, iptables NAT/FORWARD rules) are cleaned up after container exit using iptables -D and ip link del; running the container again does not fail due to leftover interfaces",
      "Container port isolation is verified: binding a port inside the container (e.g., nc -l 8080) does not cause that port to appear on the host's 0.0.0.0; 'ss -tlnp' on host shows no new listeners after container binds a port",
      "The parent-child setup sequence follows correct ordering: clone() first to get container PID, then host-side veth/bridge/NAT setup, then signal container, then container runs loopback + veth configuration inside the namespace"
    ]
  },
  {
    "milestone_id": "container-basic-m4",
    "criteria": [
      "Detect cgroups v2 by checking existence of /sys/fs/cgroup/cgroup.controllers; fall back to v1 detection by checking /sys/fs/cgroup/memory directory existence; print detected version to confirm correct dispatch",
      "Enable memory, cpu, and pids controllers in the parent cgroup's cgroup.subtree_control file (write '+memory +cpu +pids') before creating child cgroup directories on cgroups v2 systems",
      "Create a cgroup directory under /sys/fs/cgroup/<name> (v2) or under each controller hierarchy (v1: /sys/fs/cgroup/memory/<name>, /sys/fs/cgroup/cpu/<name>, /sys/fs/cgroup/pids/<name>) using mkdir()",
      "Write the container process's host PID to cgroup.procs AFTER clone() returns but BEFORE the sync pipe signals the container to proceed (i.e., before exec() runs inside the container)",
      "Set memory.max (v2) or memory.limit_in_bytes (v1) to a specified byte value (e.g., 104857600 for 100MB); also set memory.swap.max=0 (v2) or memory.memsw.limit_in_bytes (v1) to prevent swap from evading the limit",
      "Verify OOM killer behavior: a process inside the container that allocates memory touching each page with memset() must be killed by SIGKILL before exceeding memory.max; confirm via dmesg showing 'Memory cgroup out of memory' for the container's cgroup",
      "Set cpu.max (v2) with quota and period as a single string (e.g., '50000 100000' for 50ms per 100ms period); set cpu.cfs_quota_us and cpu.cfs_period_us separately for v1",
      "Verify CPU throttling: after running a CPU-intensive workload for ≥30 seconds inside the container, cpu.stat must show nr_throttled > 0 and throttled_usec > 0",
      "Set pids.max to a specified integer (e.g., 32); verify that a fork bomb inside the container fails with EAGAIN ('Resource temporarily unavailable') and that pids.current never exceeds pids.max on the host",
      "After the container process exits (waitpid() returns), remove the cgroup directory with rmdir() for v2 or rmdir each controller subdirectory for v1; verify the directory no longer exists; log EBUSY as a diagnostic if rmdir fails",
      "Report live resource usage by reading and printing memory.current (bytes), cpu.stat (usage_usec, throttled_usec, nr_throttled), and pids.current from the cgroup filesystem while the container is running",
      "Set oom_score_adj on the container process via /proc/self/oom_score_adj (called from container_init before exec) to configure OOM kill priority relative to other processes on the host"
    ]
  },
  {
    "milestone_id": "container-basic-m5",
    "criteria": [
      "clone(CLONE_NEWUSER) is invoked by an unprivileged user (no sudo) and returns a valid container PID; errno is checked and EPERM is handled with a helpful diagnostic about unprivileged_userns_clone",
      "UID/GID maps are written to /proc/<pid>/uid_map and /proc/<pid>/gid_map from the parent process using a single write() call per file, after clone() returns the container PID and before the sync pipe is signaled",
      "The string 'deny' is written to /proc/<pid>/setgroups before writing /proc/<pid>/gid_map; attempting to reverse this order for an unprivileged caller returns EPERM",
      "The container process's effective capability set (readable via capget() or /proc/self/status CapEff) shows a non-zero full capability set inside the user namespace after UID/GID maps are written",
      "The container process's /proc/<pid>/status on the host shows Uid: 1000 1000 1000 1000 (the unprivileged real host UID) and CapEff: 0000000000000000 (no host capabilities)",
      "/proc/<pid>/uid_map read from outside the container shows the mapping '0 <host_uid> 1'; getuid() inside the container returns 0",
      "mount() inside the container's mount namespace succeeds (e.g., mount -t tmpfs tmpfs /tmp returns 0) demonstrating real CAP_SYS_ADMIN scoped to the user namespace",
      "pivot_root() executes successfully from inside the user namespace, completely replacing the container's root filesystem; host filesystem is inaccessible after umount2(MNT_DETACH)",
      "sethostname() inside the UTS namespace succeeds and is isolated from the host hostname (verified by reading /proc/<container_pid>/ns/uts showing a different inode than /proc/self/ns/uts)",
      "/proc/<pid>/ns/user shows a different inode number than /proc/self/ns/user on the host, confirming the container is in a distinct user namespace",
      "The sync pipe correctly enforces ordering: the container blocks at read() until uid_map, gid_map, cgroup setup, and network setup are complete on the host before the container proceeds to mount/pivot_root operations",
      "All five namespace types (PID, UTS, Mount, Network, User) are verified as distinct from host namespaces by comparing /proc/<pid>/ns/* inode numbers",
      "Attempting to mount a host block device from inside the container (e.g., mount /dev/sda1 /mnt) returns EPERM, demonstrating capability scoping — the user namespace does not own the initial network namespace's resources",
      "cgroup resource limits from Milestone 4 are applied (memory.max, cpu.max, pids.max written to /sys/fs/cgroup/mycontainer/) before the sync pipe is signaled; the implementation gracefully degrades when cgroup write permission is unavailable",
      "The container's network configuration (loopback up, veth IP assigned, default route) is applied from within the container after UID mapping grants CAP_NET_ADMIN in the network namespace; the implementation logs a clear message when veth is absent and suggests slirp4netns as the rootless networking alternative"
    ]
  },
  {
    "module_id": "container-basic-m1",
    "criteria": [
      "PID 1 must reap orphans using non-blocking waitpid",
      "clone() must use a manually allocated stack with a guard page",
      "UTS isolation must be verified by changing hostname inside namespace",
      "NSpid field from /proc/self/status must be used for PID verification"
    ]
  },
  {
    "module_id": "container-basic-m2",
    "criteria": [
      "Implement CLONE_NEWNS in clone flags",
      "Implement set_mounts_private with MS_REC|MS_PRIVATE",
      "Perform bind-mount-to-self on new rootfs",
      "Call pivot_root via direct syscall wrapper",
      "Execute umount2(MNT_DETACH) on old root",
      "Mount /proc, /sys, and /dev with security flags",
      "Verify host filesystem inaccessibility after pivot"
    ]
  },
  {
    "module_id": "container-basic-m3",
    "criteria": [
      "Implement CLONE_NEWNET in clone() flags",
      "Establish two-phase sync pipe between parent and child",
      "Create host-side bridge ctr0 and veth pair",
      "Successfully move veth_c0 into container namespace using PID",
      "Configure container IP 172.20.0.2 and default route via 172.20.0.1",
      "Enable host IP forwarding and iptables MASQUERADE NAT",
      "Inject /etc/resolv.conf with 8.8.8.8 before pivot_root",
      "Implement atexit cleanup for bridge and iptables rules"
    ]
  },
  {
    "module_id": "container-basic-m4",
    "criteria": [
      "Implement cgroup version detection via stat()",
      "Enable v2 controllers via subtree_control in parent",
      "Assign container_pid to cgroup.procs before unblocking sync pipe",
      "Set memory.swap.max to 0 to prevent swap evasion",
      "Implement CFS quota/period throttling",
      "Implement pids.max fork-bomb protection",
      "Clean up cgroup directory using rmdir() after waitpid()",
      "Handle v1/v2 filename differences (memory.max vs memory.limit_in_bytes)"
    ]
  },
  {
    "module_id": "container-basic-m5",
    "criteria": [
      "Implement CLONE_NEWUSER in clone call",
      "Implement write_uid_gid_maps with setgroups=deny ordering",
      "Implement verify_capabilities via capget syscall",
      "Demonstrate UID 0 inside vs UID 1000 outside",
      "Verify host-side CapEff is 0 via /proc/<pid>/status"
    ]
  }
]