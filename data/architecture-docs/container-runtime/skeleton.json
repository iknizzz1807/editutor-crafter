{
  "title": "Container Runtime: Design Document",
  "overview": "This system implements a minimal container runtime that provides process isolation using Linux namespaces, resource control through cgroups, and layered filesystem support via overlayfs. The key architectural challenge is orchestrating multiple kernel isolation mechanisms while maintaining clean abstractions and handling complex failure modes across namespace boundaries.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explores what container runtimes do and why building one from scratch helps understand the fundamental isolation primitives that make containerization possible.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "Mental Model: Apartments in a Building",
          "summary": "Uses apartment building analogy to explain container isolation concepts before diving into technical details."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Container Runtime Approaches",
          "summary": "Compares Docker, containerd, runc, and other container runtimes to understand the design space."
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what our minimal container runtime will and will not implement, establishing clear boundaries for the educational project.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Process isolation, resource limits, filesystem layering, and basic networking capabilities."
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Advanced features like image distribution, orchestration, and production-grade security that are out of scope."
        }
      ]
    },
    {
      "id": "architecture-overview",
      "title": "High-Level Architecture",
      "summary": "Component overview showing how the runtime manager orchestrates namespace creation, cgroup setup, filesystem mounting, and network configuration.",
      "subsections": [
        {
          "id": "component-responsibilities",
          "title": "Component Responsibilities",
          "summary": "Defines the role of each major component: runtime manager, namespace handler, cgroup controller, filesystem manager, and network manager."
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "Shows how to organize the codebase into logical modules aligned with component boundaries."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines key data structures for container configuration, runtime state, resource limits, and networking configuration.",
      "subsections": [
        {
          "id": "container-spec",
          "title": "Container Specification",
          "summary": "Structure defining what a container should look like: image, resource limits, network settings, and command to run."
        },
        {
          "id": "runtime-state",
          "title": "Runtime State",
          "summary": "Structures tracking active containers: process IDs, namespace handles, cgroup paths, and cleanup resources."
        }
      ]
    },
    {
      "id": "namespace-isolation",
      "title": "Namespace Isolation Component",
      "summary": "Implements process isolation using Linux namespaces, handling PID, mount, network, UTS, and user namespace creation and management.",
      "subsections": [
        {
          "id": "namespace-mental-model",
          "title": "Mental Model: Separate Worlds",
          "summary": "Explains how namespaces create isolated views of system resources using a parallel universe analogy."
        },
        {
          "id": "namespace-types",
          "title": "Namespace Types and Setup",
          "summary": "Details each namespace type, what it isolates, and the specific setup sequence required."
        },
        {
          "id": "pivot-root-process",
          "title": "Filesystem Pivot Process",
          "summary": "Step-by-step algorithm for switching container root filesystem using pivot_root system call."
        },
        {
          "id": "namespace-pitfalls",
          "title": "Common Namespace Pitfalls",
          "summary": "Typical mistakes when working with namespaces: mount point requirements, /proc mounting, and UID mapping."
        }
      ]
    },
    {
      "id": "resource-control",
      "title": "Resource Control Component",
      "summary": "Implements CPU, memory, and I/O limits using cgroups v2, including resource monitoring and OOM handling.",
      "subsections": [
        {
          "id": "cgroups-mental-model",
          "title": "Mental Model: Resource Budget Manager",
          "summary": "Uses family allowance analogy to explain how cgroups allocate and enforce resource limits."
        },
        {
          "id": "cgroup-controllers",
          "title": "Cgroup Controller Configuration",
          "summary": "Details memory, CPU, and device controllers with their specific configuration parameters and enforcement mechanisms."
        },
        {
          "id": "resource-monitoring",
          "title": "Resource Usage Monitoring",
          "summary": "Algorithm for reading current resource usage from cgroup statistics files and detecting approaching limits."
        },
        {
          "id": "oom-handling",
          "title": "Out-of-Memory Handling",
          "summary": "Strategies for detecting and gracefully handling memory exhaustion in containers."
        }
      ]
    },
    {
      "id": "filesystem-layering",
      "title": "Filesystem Layering Component",
      "summary": "Implements image layering using overlayfs for copy-on-write filesystem support with proper layer management and cleanup.",
      "subsections": [
        {
          "id": "overlayfs-mental-model",
          "title": "Mental Model: Transparent Sheets",
          "summary": "Uses transparent overlay sheets analogy to explain how overlayfs combines multiple filesystem layers."
        },
        {
          "id": "layer-management",
          "title": "Layer Stacking and Management",
          "summary": "Algorithm for combining multiple read-only image layers with a writable upper layer using overlayfs mount options."
        },
        {
          "id": "copy-on-write",
          "title": "Copy-on-Write Semantics",
          "summary": "How overlayfs handles file modifications, ensuring changes stay in the upper layer without affecting base images."
        },
        {
          "id": "overlay-cleanup",
          "title": "Layer Cleanup Process",
          "summary": "Proper unmounting and cleanup of overlay layers when containers are removed."
        }
      ]
    },
    {
      "id": "network-management",
      "title": "Network Management Component",
      "summary": "Implements container networking using veth pairs, bridge networking, and port forwarding for inter-container and external communication.",
      "subsections": [
        {
          "id": "networking-mental-model",
          "title": "Mental Model: Virtual Cable System",
          "summary": "Uses network cable and switch analogy to explain veth pairs, bridges, and how containers connect to networks."
        },
        {
          "id": "veth-bridge-setup",
          "title": "Veth Pair and Bridge Setup",
          "summary": "Step-by-step process for creating virtual ethernet pairs and connecting them through a bridge for container networking."
        },
        {
          "id": "ip-assignment",
          "title": "IP Address Assignment",
          "summary": "Algorithm for assigning unique IP addresses to containers from a configured subnet pool."
        },
        {
          "id": "port-forwarding",
          "title": "Port Forwarding with NAT",
          "summary": "Using iptables NAT rules to forward traffic from host ports to container services."
        }
      ]
    },
    {
      "id": "interactions-dataflow",
      "title": "Interactions and Data Flow",
      "summary": "Describes how components communicate during container lifecycle operations: create, start, stop, and remove.",
      "subsections": [
        {
          "id": "container-creation-flow",
          "title": "Container Creation Sequence",
          "summary": "Step-by-step flow showing how runtime manager coordinates all components to create and start a new container."
        },
        {
          "id": "container-cleanup-flow",
          "title": "Container Cleanup Sequence",
          "summary": "Proper shutdown sequence ensuring all resources are cleaned up in the correct order when stopping containers."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Failure modes across namespace, cgroup, filesystem, and network operations with detection and recovery strategies.",
      "subsections": [
        {
          "id": "partial-failure-recovery",
          "title": "Partial Failure Recovery",
          "summary": "Handling cases where container creation partially succeeds but some components fail, requiring cleanup of successfully created resources."
        },
        {
          "id": "resource-exhaustion",
          "title": "Resource Exhaustion Scenarios",
          "summary": "Detecting and handling cases where system resources (PIDs, memory, network interfaces) are exhausted."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Testing approach for each milestone with specific scenarios to verify isolation, resource limits, filesystem behavior, and networking.",
      "subsections": [
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "After each milestone implementation, specific tests to run and expected behavior to verify progress."
        },
        {
          "id": "integration-scenarios",
          "title": "Integration Test Scenarios",
          "summary": "End-to-end scenarios testing multiple components working together in realistic container use cases."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common issues encountered when building container runtimes with symptom-cause-fix tables and debugging techniques.",
      "subsections": [
        {
          "id": "namespace-debugging",
          "title": "Namespace Debugging Techniques",
          "summary": "Tools and techniques for inspecting namespace state, troubleshooting mount issues, and diagnosing process visibility problems."
        },
        {
          "id": "cgroup-debugging",
          "title": "Cgroup Debugging Techniques",
          "summary": "How to inspect cgroup hierarchy, verify resource limits are applied, and troubleshoot permission issues."
        },
        {
          "id": "network-debugging",
          "title": "Network Debugging Techniques",
          "summary": "Using ip, bridge, and iptables commands to inspect container networking state and diagnose connectivity issues."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Advanced features that could be added later: security policies, volume mounts, multi-host networking, and image management.",
      "subsections": [
        {
          "id": "security-enhancements",
          "title": "Security Enhancements",
          "summary": "Adding seccomp filters, AppArmor/SELinux integration, and capability management for production security."
        },
        {
          "id": "advanced-networking",
          "title": "Advanced Networking Features",
          "summary": "Multi-host networking, overlay networks, and integration with CNI plugins for Kubernetes compatibility."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of container runtime terminology, Linux kernel concepts, and system administration terms used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "Container Runtime System Architecture",
      "description": "Shows the main components (Runtime Manager, Namespace Handler, Cgroup Controller, Filesystem Manager, Network Manager) and their relationships, including external dependencies on Linux kernel features.",
      "type": "component",
      "relevant_sections": [
        "architecture-overview",
        "interactions-dataflow"
      ]
    },
    {
      "id": "namespace-isolation",
      "title": "Namespace Isolation Layers",
      "description": "Illustrates how different namespace types (PID, mount, network, UTS, user) create isolated views of system resources, showing the container process perspective vs host perspective.",
      "type": "component",
      "relevant_sections": [
        "namespace-isolation"
      ]
    },
    {
      "id": "overlayfs-structure",
      "title": "OverlayFS Layer Structure",
      "description": "Shows how multiple read-only image layers combine with a writable upper layer through overlayfs, including lower directories, upper directory, work directory, and merged view.",
      "type": "component",
      "relevant_sections": [
        "filesystem-layering"
      ]
    },
    {
      "id": "container-creation-sequence",
      "title": "Container Creation Sequence",
      "description": "Step-by-step sequence showing interactions between Runtime Manager and all other components during container creation: namespace setup, cgroup creation, filesystem mounting, network configuration, and process start.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-dataflow",
        "namespace-isolation",
        "resource-control"
      ]
    },
    {
      "id": "network-topology",
      "title": "Container Network Topology",
      "description": "Network diagram showing veth pairs connecting containers to a bridge, with host network namespace, container network namespaces, and iptables NAT rules for port forwarding.",
      "type": "component",
      "relevant_sections": [
        "network-management"
      ]
    },
    {
      "id": "container-lifecycle-state",
      "title": "Container Lifecycle State Machine",
      "description": "State transitions for container lifecycle: Created -> Running -> Stopped -> Removed, with events that trigger transitions and cleanup actions performed at each stage.",
      "type": "state-machine",
      "relevant_sections": [
        "interactions-dataflow",
        "error-handling"
      ]
    },
    {
      "id": "cgroup-hierarchy",
      "title": "Cgroup v2 Hierarchy Structure",
      "description": "Shows the cgroup v2 unified hierarchy with container cgroups, enabled controllers (memory, cpu, io), and how processes are assigned to cgroups for resource control.",
      "type": "component",
      "relevant_sections": [
        "resource-control"
      ]
    },
    {
      "id": "error-recovery-flow",
      "title": "Error Recovery and Cleanup Flow",
      "description": "Flowchart showing decision points and cleanup actions when container operations fail partway through, ensuring proper resource cleanup and consistent state.",
      "type": "flowchart",
      "relevant_sections": [
        "error-handling",
        "interactions-dataflow"
      ]
    }
  ]
}