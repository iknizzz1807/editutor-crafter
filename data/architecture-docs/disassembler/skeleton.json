{
  "title": "x86 Disassembler: Design Document",
  "overview": "This system translates x86/x64 machine code bytes from executable files back into human-readable assembly instructions. The key architectural challenge is accurately decoding the complex, variable-length x86 instruction format with its legacy prefixes, multiple addressing modes, and context-dependent opcodes.",
  "sections": [
    {
      "id": "context-and-problem",
      "title": "Context and Problem Statement",
      "summary": "Establishes the complexity of x86 instruction encoding and why disassembly is challenging compared to simpler architectures.",
      "subsections": [
        {
          "id": "problem-mental-model",
          "title": "Mental Model: Machine Code as Compressed Language",
          "summary": "Uses the analogy of compressed text with variable-length encoding to explain x86 instruction complexity."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Disassembler Approaches",
          "summary": "Compares table-driven, recursive descent, and linear sweep disassembly strategies."
        }
      ]
    },
    {
      "id": "goals-and-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the scope of our educational disassembler and explicitly excludes advanced features like control flow analysis.",
      "subsections": []
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Overview of the pipeline architecture from binary parsing through instruction decoding to formatted output.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview and Responsibilities",
          "summary": "Describes the five main components and their interactions in the disassembly pipeline."
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "Organizes the codebase into logical modules matching the component architecture."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the key data structures representing instructions, operands, and decoded state throughout the pipeline.",
      "subsections": [
        {
          "id": "instruction-representation",
          "title": "Instruction Representation",
          "summary": "Core structures for decoded instructions, operands, and addressing modes."
        },
        {
          "id": "binary-metadata",
          "title": "Binary Metadata",
          "summary": "Structures for executable headers, sections, and symbol information."
        }
      ]
    },
    {
      "id": "binary-loader",
      "title": "Binary Loader Component",
      "summary": "Parses executable file formats (ELF/PE) to extract code sections and metadata for disassembly.",
      "subsections": [
        {
          "id": "loader-mental-model",
          "title": "Mental Model: Executable as Container",
          "summary": "Explains executable files as containers with headers, sections, and metadata."
        },
        {
          "id": "format-detection",
          "title": "Format Detection and Header Parsing",
          "summary": "Algorithm for identifying ELF vs PE format and extracting header information."
        },
        {
          "id": "section-extraction",
          "title": "Code Section Extraction",
          "summary": "Locating and extracting the .text section containing executable code."
        },
        {
          "id": "loader-adrs",
          "title": "Architecture Decisions",
          "summary": "Decision records for file format support and address resolution strategies."
        },
        {
          "id": "loader-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Virtual vs physical addresses, endianness handling, and stripped binaries."
        }
      ]
    },
    {
      "id": "prefix-decoder",
      "title": "Prefix Decoder Component",
      "summary": "Decodes x86 instruction prefixes including legacy prefixes and REX in 64-bit mode.",
      "subsections": [
        {
          "id": "prefix-mental-model",
          "title": "Mental Model: Prefixes as Instruction Modifiers",
          "summary": "Explains prefixes as optional modifiers that change instruction behavior."
        },
        {
          "id": "legacy-prefixes",
          "title": "Legacy Prefix Handling",
          "summary": "Decoding operand size, address size, and segment override prefixes."
        },
        {
          "id": "rex-decoding",
          "title": "REX Prefix Decoding",
          "summary": "64-bit mode REX prefix for register extensions and operand size."
        },
        {
          "id": "prefix-adrs",
          "title": "Architecture Decisions",
          "summary": "Decision records for prefix validation and ordering requirements."
        },
        {
          "id": "prefix-pitfalls",
          "title": "Common Pitfalls",
          "summary": "REX positioning requirements, invalid prefix combinations, and mode dependencies."
        }
      ]
    },
    {
      "id": "opcode-decoder",
      "title": "Opcode Decoder Component",
      "summary": "Maps opcode bytes to instruction mnemonics using lookup tables for one-byte and two-byte opcodes.",
      "subsections": [
        {
          "id": "opcode-mental-model",
          "title": "Mental Model: Opcode Tables as Dictionaries",
          "summary": "Explains opcode tables as lookup dictionaries with extensions and special cases."
        },
        {
          "id": "table-organization",
          "title": "Opcode Table Organization",
          "summary": "Structure of primary, extended, and group opcode tables."
        },
        {
          "id": "opcode-extensions",
          "title": "Opcode Extensions via ModRM",
          "summary": "Handling opcodes that use ModRM.reg field for additional instruction selection."
        },
        {
          "id": "opcode-adrs",
          "title": "Architecture Decisions",
          "summary": "Decision records for table representation and extension handling strategies."
        },
        {
          "id": "opcode-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Invalid opcodes, mode-dependent instructions, and table size management."
        }
      ]
    },
    {
      "id": "operand-decoder",
      "title": "Operand Decoder Component",
      "summary": "Decodes ModRM and SIB bytes to determine instruction operands including registers and memory addresses.",
      "subsections": [
        {
          "id": "operand-mental-model",
          "title": "Mental Model: Addressing Modes as Recipes",
          "summary": "Explains addressing modes as recipes for computing memory addresses or selecting registers."
        },
        {
          "id": "modrm-decoding",
          "title": "ModRM Byte Decoding",
          "summary": "Extracting mod, reg, and rm fields and interpreting addressing modes."
        },
        {
          "id": "sib-decoding",
          "title": "SIB Byte Decoding",
          "summary": "Handling scaled-index-base addressing for complex memory operands."
        },
        {
          "id": "displacement-handling",
          "title": "Displacement and Immediate Handling",
          "summary": "Extracting and sizing displacement values and immediate operands."
        },
        {
          "id": "operand-adrs",
          "title": "Architecture Decisions",
          "summary": "Decision records for operand size determination and RIP-relative addressing."
        },
        {
          "id": "operand-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Register extension with REX, RIP-relative calculations, and SIB special cases."
        }
      ]
    },
    {
      "id": "output-formatter",
      "title": "Output Formatter Component",
      "summary": "Formats decoded instructions into human-readable assembly with addresses, hex bytes, and mnemonics.",
      "subsections": [
        {
          "id": "formatter-mental-model",
          "title": "Mental Model: Formatter as Translator",
          "summary": "Explains the formatter as translating internal structures to readable assembly syntax."
        },
        {
          "id": "syntax-support",
          "title": "Assembly Syntax Support",
          "summary": "Supporting both Intel and AT&T assembly syntax with operand ordering differences."
        },
        {
          "id": "symbol-resolution",
          "title": "Symbol Resolution and Labeling",
          "summary": "Replacing addresses with function names and labeling jump targets."
        },
        {
          "id": "formatter-adrs",
          "title": "Architecture Decisions",
          "summary": "Decision records for default syntax choice and symbol lookup strategies."
        },
        {
          "id": "formatter-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Address calculation errors, syntax confusion, and invalid instruction handling."
        }
      ]
    },
    {
      "id": "interactions-and-dataflow",
      "title": "Interactions and Data Flow",
      "summary": "Describes how components communicate and the sequence of operations from binary input to formatted output.",
      "subsections": [
        {
          "id": "pipeline-flow",
          "title": "Disassembly Pipeline Flow",
          "summary": "Step-by-step data transformation through the component pipeline."
        },
        {
          "id": "component-interfaces",
          "title": "Component Interface Contracts",
          "summary": "Input/output contracts and error propagation between components."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Strategies for handling invalid opcodes, malformed binaries, and decoding failures gracefully.",
      "subsections": [
        {
          "id": "failure-modes",
          "title": "Common Failure Modes",
          "summary": "Invalid opcodes, truncated instructions, and unsupported formats."
        },
        {
          "id": "recovery-strategies",
          "title": "Error Recovery Strategies",
          "summary": "Graceful degradation and continuation after decoding errors."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Comprehensive testing approach including unit tests, integration tests, and milestone validation.",
      "subsections": [
        {
          "id": "unit-testing",
          "title": "Component Unit Testing",
          "summary": "Testing individual components with known inputs and expected outputs."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Validation Checkpoints",
          "summary": "Specific tests and expected behaviors after completing each milestone."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common issues learners encounter when building the disassembler and systematic approaches to diagnosis and resolution.",
      "subsections": [
        {
          "id": "symptom-diagnosis",
          "title": "Symptom-Based Debugging",
          "summary": "Mapping common symptoms to likely causes and diagnostic steps."
        },
        {
          "id": "debugging-tools",
          "title": "Debugging Tools and Techniques",
          "summary": "Using hex editors, reference disassemblers, and logging for troubleshooting."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Advanced features that could be added later including VEX/EVEX prefixes, control flow analysis, and optimization detection.",
      "subsections": []
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key technical terms, x86 concepts, and domain-specific vocabulary used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-overview",
      "title": "System Component Overview",
      "description": "Shows the five main components (Binary Loader, Prefix Decoder, Opcode Decoder, Operand Decoder, Output Formatter) and their data flow from executable file input to formatted assembly output",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture"
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model Relationships",
      "description": "Shows the relationships between key structures: Binary, Section, Instruction, Operand, and their component fields and dependencies",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "disassembly-pipeline",
      "title": "Disassembly Pipeline Sequence",
      "description": "Step-by-step sequence showing how a single instruction flows through prefix decoding, opcode lookup, operand decoding, and formatting",
      "type": "sequence",
      "relevant_sections": [
        "interactions-and-dataflow"
      ]
    },
    {
      "id": "instruction-decoding-flow",
      "title": "Instruction Decoding Flowchart",
      "description": "Decision tree for instruction decoding showing prefix detection, opcode table lookups, ModRM/SIB handling, and error paths",
      "type": "flowchart",
      "relevant_sections": [
        "prefix-decoder",
        "opcode-decoder",
        "operand-decoder"
      ]
    },
    {
      "id": "prefix-state-machine",
      "title": "Prefix Processing State Machine",
      "description": "State transitions for processing instruction prefixes showing valid sequences and terminal states",
      "type": "state-machine",
      "relevant_sections": [
        "prefix-decoder"
      ]
    },
    {
      "id": "addressing-mode-decision",
      "title": "Addressing Mode Decision Tree",
      "description": "Decision flowchart for ModRM and SIB decoding showing how mod, reg, rm fields lead to different addressing modes",
      "type": "flowchart",
      "relevant_sections": [
        "operand-decoder"
      ]
    }
  ]
}