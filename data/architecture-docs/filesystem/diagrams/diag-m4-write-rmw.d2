direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- APPLICATION LAYER ---
application: {
  label: "User Space Application"
  write_call: {
    shape: rectangle
    label: "POSIX write() syscall"
    code: |'c
      // Write "XYZ" at offset 1000
      const char *data = "XYZ";
      ssize_t n = write(fd, data, 3);
    '|
  }
}

# --- FILESYSTEM LOGIC LAYER ---
fs_logic: {
  label: "Filesystem Write Path (file.c)"
  direction: down
  
  arithmetic: {
    shape: rectangle
    label: "1. Offset Arithmetic"
    code: |'c
      block_index  = 1000 / 4096; // = 0
      block_offset = 1000 % 4096; // = 1000
      chunk_size   = min(4096 - 1000, 3); // = 3
    '|
  }

  allocation_check: {
    shape: diamond
    label: "2. Block Allocated?"
  }

  rmw_buffer: {
    shape: sql_table
    label: "Kernel Page Cache / RAM Buffer (4096 bytes)"
    row0: "0x000 .. 0x3E7 | 1000 bytes | Existing Data (Unchanged)"
    row1: "0x3E8 .. 0x3EA | 3 bytes    | MODIFIED: 'X', 'Y', 'Z'"
    row2: "0x3EB .. 0xFFF | 3093 bytes | Existing Data (Unchanged)"
    sz: "Total: 4096 bytes (1 Block)"
  }
}

# --- DATA STRUCTURES ---
structs: {
  label: "On-Disk Metadata"
  inode: {
    shape: sql_table
    label: "struct inode_t (inode.h)"
    f0: "0x00 | uint16_t | mode // S_IFREG"
    f1: "0x08 | uint32_t | size // logical size"
    f2: "0x18 | uint32_t | blocks[0] // direct block pointer"
    sz: "Total: 128 bytes"
  }
}

# --- DISK / BLOCK LAYER ---
disk_layer: {
  label: "Block Device (disk.img)"
  block_0: {
    shape: cylinder
    label: "Physical Block N"
    style.fill: "#f3f3f3"
  }
}

# --- PERFORMANCE METRIC (Root level for positioning) ---
amplification_metric: {
  shape: callout
  label: "CRITICAL: Write Amplification"
  code: |'md
    - Payload: 3 bytes
    - Disk Read: 4096 bytes
    - Disk Write: 4096 bytes
    - Total I/O: 8192 bytes
    - **Ratio: 2730.6x**
  '|
  style.stroke: red
}
amplification_metric.near: bottom-right

# --- CONNECTIONS ---
application.write_call -> fs_logic.arithmetic: "void* | 3 bytes | 'XYZ'"

fs_logic.arithmetic -> structs.inode: "uint32_t | 4 bytes | block_index=0"
structs.inode -> fs_logic.allocation_check: "uint32_t | 4 bytes | LBA=500"

fs_logic.allocation_check -> disk_layer.block_0: "READ CMD | 4096 bytes | LBA 500" {
  label: "YES: Start RMW Cycle"
  style.stroke: blue
}

disk_layer.block_0 -> fs_logic.rmw_buffer: "uint8_t[] | 4KB | Raw Page Data" {
  style.stroke: blue
}

fs_logic.rmw_buffer -> disk_layer.block_0: "WRITE CMD | 4096 bytes | LBA 500" {
  label: "Dirty Page Flush"
  style.stroke: red
}

fs_logic.allocation_check -> fs_logic.rmw_buffer: "NO: Zero-fill & new alloc" {
  style.stroke-dash: 4
}

# Connect metric logically to the flow
fs_logic.rmw_buffer -> amplification_metric: "Performance Impact" {
  style.stroke-dash: 2
}