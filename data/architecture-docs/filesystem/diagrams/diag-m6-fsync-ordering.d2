direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

legend: {
  shape: sql_table
  label: "Color Semantics"
  red: "Red | Hot Path / Data Corruption Risk"
  green: "Green | Safe / Barrier Synchronized"
  purple: "Purple | Metadata / Control Record"
  blue: "Blue | Payload / File Data"
}
legend.near: bottom-right

naive_path: {
  label: "UNSAFE: No Barrier Ordering (fsync omitted)"
  
  app_code: {
    shape: class
    label: "Application Logic (fs_write.c)"
    methods: |'c
      write(fd, journal_buf, 4096); // seq=100
      write(fd, commit_buf, 4096);  // seq=100
      write(fd, data_buf, 4096);    // payload
    '|
  }

  kernel_cache: {
    label: "OS Page Cache / Disk Buffer"
    desc: "Reorders writes based on LBA optimization"
    state: {
      shape: sql_table
      row1: "Queue Pos 0 | Data Block (Payload) | HIGHEST PRIORITY (Closest Head)"
      row2: "Queue Pos 1 | Commit Record        | MEDIUM PRIORITY"
      row3: "Queue Pos 2 | Journal Entry       | LOW PRIORITY (Furthest Head)"
    }
  }

  disk_media: {
    label: "Physical Platter / NAND Cells"
    block_state: {
      shape: sql_table
      b0: "0x4000 | commit_t | [VALID MAGIC] [SEQ=100]" {style.fill: "#ff7e79"}
      b1: "0x8000 | data_t   | [NEW PAYLOAD DATA]" {style.fill: "#79ff7e"}
      b2: "0x1000 | journal_t| [STALE GARBAGE / ZEROS]" {style.fill: "#ff7e79"}
    }
    
    crash: "CRASH / POWER LOSS" {
      shape: diamond
      style: {
        fill: red
        stroke-width: 4
      }
    }
  }

  recovery_failure: {
    label: "Recovery Procedure (journal_recover)"
    code: |'c
      if (commit->magic == J_MAGIC) {
        // RECOVERY LOGIC:
        // Commit is found, so we replay...
        // BUT: descriptor/data copies never hit disk!
        replay_to_filesystem(garbage_journal_block);
      }
    '|
    status: "RESULT: SYSTEM CORRUPTION" {
      style.fill: red
    }
  }

  app_code -> kernel_cache: "write() syscalls | 12 KB | {J, C, D}"
  kernel_cache -> disk_media: "Asynchronous Flush | reordered | {D, C} written; J lost"
  disk_media.crash -> recovery_failure: "Remount | state | Inconsistent"
}

safe_path: {
  label: "SAFE: Explicit Barrier Ordering (fsync mandatory)"
  
  app_logic: {
    shape: class
    label: "Journaling Engine (txn_commit.c)"
    methods: |'c
      write(fd, journal_buf, 4096);
      fsync(fd); // BARRIER 1
      write(fd, commit_buf, 4096);
      fsync(fd); // BARRIER 2
      write(fd, data_buf, 4096);
    '|
  }

  barrier_1: {
    label: "FLUSH CACHE BARRIER"
    shape: step
    style.fill: "#79ff7e"
  }

  barrier_2: {
    label: "FLUSH CACHE BARRIER"
    shape: step
    style.fill: "#79ff7e"
  }

  disk_durable: {
    label: "Durable Disk State"
    state: {
      shape: sql_table
      b0: "0x1000 | journal_t| [VALID DATA COPY]" {style.fill: "#79ff7e"}
      b1: "0x4000 | commit_t | [VALID COMMIT]" {style.fill: "#79ff7e"}
      b2: "0x8000 | data_t   | [PENDING / PARTIAL]" {style.fill: "#ffeb3b"}
    }
  }

  recovery_success: {
    label: "Recovery Procedure"
    status: "RESULT: CONSISTENT REPLAY" {
      style.fill: green
    }
  }

  app_logic -> barrier_1: "Metadata Write | 4KB | Journal Descriptor"
  barrier_1 -> app_logic: "ACK | Durable"
  app_logic -> barrier_2: "Commit Write | 4KB | Commit Block"
  barrier_2 -> disk_durable: "Atomic Append"
  disk_durable -> recovery_success: "journal_recover() | committed | Replays Valid Metadata"
}

naive_path -> safe_path: "Solution: fsync() establishes temporal causality" {
  style.stroke-dash: 5
}