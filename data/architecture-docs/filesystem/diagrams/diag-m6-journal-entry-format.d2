direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# 1. THE JOURNAL LOG STREAM (Temporal sequence)
journal_stream: {
  label: "Journal Write-Ahead Log Stream"
  direction: right
  
  rec1: "Tx Begin (ID: 101)" {
    shape: package
    style.fill: "#E1F5FE"
  }
  rec2: "Data: Inode Bmap" {
    shape: package
    style.fill: "#FFF9C4"
  }
  rec3: "Data: Inode Table" {
    shape: package
    style.fill: "#FFF9C4"
  }
  rec4: "Commit (ID: 101)" {
    shape: package
    style.fill: "#C8E6C9"
    style.stroke-width: 3
  }

  rec1 -> rec2 -> rec3 -> rec4: "Append-Only Sequential Writes"
}

# 2. MICROSCOPIC BYTE LAYOUTS
layouts: {
  label: "Record Byte Specifications (journal.h)"
  direction: down

  tx_begin: {
    shape: sql_table
    label: "struct journal_begin_t"
    f0: "0x00 | uint32_t | tx_id // Sequential counter"
    f1: "0x04 | uint8_t  | type  // Constant: 0x01 (BEGIN)"
    f2: "0x05 | uint64_t | timestamp // Unix epoch (nanoseconds)"
    sz: "Total: 13 bytes (unaligned)"
  }

  tx_data: {
    shape: sql_table
    label: "struct journal_data_t"
    f0: "0x00 | uint32_t | tx_id // Matches BEGIN ID"
    f1: "0x04 | uint8_t  | type  // Constant: 0x02 (DATA)"
    f2: "0x05 | uint32_t | target_block // Destination FS block"
    f3: "0x09 | uint32_t | data_length // Typically 4096"
    f4: "0x0D | uint8_t[] | data // Raw block payload"
    sz: "Total: 13 + data_length bytes"
  }

  tx_commit: {
    shape: sql_table
    label: "struct journal_commit_t"
    f0: "0x00 | uint32_t | tx_id // Final closure for ID"
    f1: "0x04 | uint8_t  | type  // Constant: 0x03 (COMMIT)"
    f2: "0x05 | uint32_t | checksum // CRC32 of all DATA entries"
    sz: "Total: 9 bytes"
  }
}

# 3. THE RECOVERY INVARIANT
recovery_decision: {
  label: "Recovery Logic: The Commit Boundary"
  direction: right

  scan: "Journal Scanner" {
    shape: person
  }

  check_commit: "Is Commit Record Valid?" {
    shape: diamond
  }

  action_replay: "REPLAY TRANSACTION" {
    style.fill: "#C8E6C9"
    code: |'c
      // Atomicity is guaranteed
      for (block in txn) {
        write_block(block.target, block.data);
      }
    '|
  }

  action_discard: "DISCARD (Abort)" {
    style.fill: "#FFCDD2"
    code: |'c
      // Treat as if it never happened
      journal_head = next_valid_txn;
      return;
    '|
  }

  scan -> check_commit: "Find next BEGIN"
  check_commit -> action_replay: "Exists + Matches ID"
  check_commit -> action_discard: "Missing OR Partial Write" {
    style.stroke-dash: 4
  }
}

# 4. RELATIONSHIPS
journal_stream.rec1 -> layouts.tx_begin: "implements"
journal_stream.rec2 -> layouts.tx_data: "implements"
journal_stream.rec4 -> layouts.tx_commit: "implements"

layouts.tx_commit -> recovery_decision.check_commit: "Existence determines durability"

# 5. FOOTNOTES
logic_note: {
  label: "Safety Invariant"
  description: |'md
    **Presence/Absence is Binary**: Because the COMMIT record is smaller than a 512B sector, the hardware ensures the write is atomic. If power fails during the COMMIT write, the record will fail checksum or magic-number checks and be ignored.
  '|
}
logic_note.near: bottom-right