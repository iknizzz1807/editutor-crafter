direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- PHYSICAL DISK LAYOUT CONTEXT ---
disk_image: {
  label: "disk.img (Physical Block Map)"
  shape: sql_table
  
  block_0: "Block 0 | Filesystem Superblock"
  block_1: "Block 1 | Block Bitmap"
  block_2: "Block 2 | Inode Bitmap"
  block_table: "Blocks 3..N | Inode Table"
  
  journal_region: "Blocks N+1..M | JOURNAL REGION (Circular Buffer)" {
    style.fill: "#e1f5fe"
    style.stroke-width: 4
  }
  
  data_blocks: "Blocks M+1..End | Data Blocks"
}

# --- JOURNAL INTERNAL STRUCTURES ---
journal_structures: {
  direction: down
  label: "On-Disk Journal Structures (journal.h)"

  journal_super_t: {
    shape: sql_table
    label: "struct journal_super_t"
    f0: "0x00 | uint32_t | j_magic // 0x4A4F5552"
    f1: "0x04 | uint32_t | j_block_type // JB_TYPE_SUPER"
    f2: "0x08 | uint32_t | j_sequence // Next Txn ID"
    f3: "0x0C | uint32_t | j_head // Oldest unapplied txn"
    f4: "0x10 | uint32_t | j_tail // Next write position"
    f5: "0x14 | uint32_t | j_total_blocks // Max capacity"
    f6: "0x18 | uint8_t[4072]| reserved // Padding"
    sz: "Total: 4096 bytes (1 block)"
  }

  journal_desc_t: {
    shape: sql_table
    label: "struct journal_desc_t"
    f0: "0x00 | uint32_t | j_magic"
    f1: "0x04 | uint32_t | j_block_type // JB_TYPE_DESC"
    f2: "0x08 | uint32_t | j_sequence"
    f3: "0x0C | uint32_t | j_nr_blocks // N blocks follow"
    f4: "0x10 | uint64_t[510]| j_blocks // Target block numbers"
    sz: "Total: 4096 bytes (1 block)"
  }
}

# --- CIRCULAR BUFFER DYNAMICS ---
journal_logic: {
  label: "Journal Circular Buffer Mechanics"
  
  buffer_ring: {
    grid-columns: 4
    
    js: "Journal Superblock\n(Block N+1)" {
      style.fill: "#fff9c4"
    }
    
    t1: "Txn A (Committed)\n[DESC][DATA][COMMIT]" {
      style.fill: "#c8e6c9"
    }
    
    t2: "Txn B (In-Flight)\n[DESC][DATA...]" {
      style.fill: "#ffccbc"
    }
    
    free: "Unallocated Space\n(Available for j_tail)" {
      style.fill: "#eeeeee"
      style.stroke-dash: 5
    }
  }

  pointers: {
    direction: right
    head_ptr: "j_head (Consumer)" {
      shape: parallelogram
      style.fill: "#4caf50"
    }
    tail_ptr: "j_tail (Producer)" {
      shape: parallelogram
      style.fill: "#f44336"
    }
  }

  pointers.head_ptr -> buffer_ring.t1: "Points to oldest unapplied"
  pointers.tail_ptr -> buffer_ring.t2: "Points to next free slot"
  buffer_ring.free -> buffer_ring.js: "Wrap-around at j_total_blocks" {
    style.stroke-dash: 3
    style.animated: true
  }
}

# --- IMPLEMENTATION LOGIC ---
constraints: {
  label: "Critical Implementation Constraints"
  
  full_check: {
    label: "Journal Full Condition (txn_commit)"
    width: 400
    code: |'c
      // Check if tail is catching up to head
      uint32_t used = (js->tail >= js->head) ? 
          (js->tail - js->head) : 
          (js->total - js->head + js->tail);
      
      if (needed_blocks > (js->total - used)) {
          journal_checkpoint(fd, sb); // Force flush to main disk
          js->head = js->tail;        // Reclaim space
      }
    '|
  }
  
  order_check: {
    label: "Durability Sequence"
    code: |'md
      1. Write [Descriptor + Data]
      2. fsync()
      3. Write [Commit Record]
      4. fsync() // Atomic boundary
    '|
  }
}

# --- CONNECTIONS ---
disk_image.journal_region -> journal_logic: "Logical Mapping"
journal_logic.buffer_ring.js -> journal_structures.journal_super_t: "Block 0 Format"
journal_logic.buffer_ring.t1 -> journal_structures.journal_desc_t: "Entry Header"

legend: {
  near: bottom-right
  metadata: "Metadata (Journaled)" {
    style.fill: "#c8e6c9"
  }
  data: "In-Flight/Risk" {
    style.fill: "#ffccbc"
  }
}