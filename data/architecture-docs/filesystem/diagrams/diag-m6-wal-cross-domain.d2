direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# LEGEND / COMMON PATTERN
legend: {
  shape: sql_table
  label: "WAL Pattern Components"
  row1: "APPEND-ONLY LOG | Physical sequence of intent"
  row2: "COMMIT MARKER | Atomic boundary of durability"
  row3: "REPLAY ENGINE | Recovery logic via idempotency"
}
legend.near: bottom-center

# COLUMN 1: FILESYSTEM JOURNAL (LOCAL)
filesystem_journal: {
  label: "Milestone 6: FS Journal (myfs.c)"
  direction: down

  log_structure: {
    shape: sql_table
    label: "Journal Region (Circular)"
    header: "0x00 | journal_super_t | head/tail ptrs"
    desc:   "0x01 | journal_desc_t  | txn seq + block list"
    data:   "0x02 | uint8_t[4096]   | raw metadata copy"
    commit: "0x03 | journal_commit_t| magic + checksum"
    sz: "Granularity: 4KB Block"
  }

  commit_logic: {
    label: "Commit Protocol"
    code: |'c
      write(desc); write(data);
      fsync(fd); // Barrier 1
      write(commit_block);
      fsync(fd); // Barrier 2 (Durable)
      apply_inplace(data);
    '|
  }

  recovery: {
    shape: step
    label: "journal_recover()"
    desc: "Scan j_head -> j_tail. If magic + checksum valid, rewrite blocks to table."
  }

  log_structure -> commit_logic: "txn_t | 64 blocks | {seq: 42}"
  commit_logic -> recovery: "Replay | Idempotent | Block Write"
}

# COLUMN 2: DATABASE WAL (POSTGRESQL)
postgres_wal: {
  label: "PostgreSQL WAL (pg_wal)"
  direction: down

  log_structure: {
    shape: sql_table
    label: "WAL Segments (16MB files)"
    header: "XLogRecPtr | LSN (64-bit) | Position"
    record: "XLogRecord | Header + Manager ID"
    data:   "BKP_Block  | Full Page Image (8KB)"
    rmgr:   "ResourceMgr| Type-specific payload"
    sz: "Granularity: XLog Record / 8KB Page"
  }

  commit_logic: {
    label: "Write-Ahead Checkpoint"
    code: |'c
      XLogInsert(record);
      XLogFlush(WriteRqst); // fsync WAL
      // Main heap pages stay dirty in RAM
      // Background writer flushes heap later
    '|
  }

  recovery: {
    shape: step
    label: "Redo Recovery"
    desc: "Read pg_control. Find last Checkpoint LSN. Replay records forward."
  }

  log_structure -> commit_logic: "XLogRecPtr | 8 bytes | 0/1A2B3C4D"
  commit_logic -> recovery: "Redo | State-Based | Page Update"
}

# COLUMN 3: DISTRIBUTED LOG (RAFT)
raft_distributed: {
  label: "Raft Consensus Log (etcd/TiKV)"
  direction: down

  log_structure: {
    shape: sql_table
    label: "Distributed Replicated Log"
    idx:  "Index | uint64 | Sequential ID"
    term: "Term  | uint64 | Leader Era"
    cmd:  "Command| Bytes  | SET Key=Val"
    meta: "CommitIndex | Volatile Marker"
    sz: "Granularity: Logical Command"
  }

  commit_logic: {
    label: "Quorum Commitment"
    code: |'c
      Leader.AppendLocal(Entry);
      RPC.AppendEntries(Followers);
      if (AckCount > ClusterSize / 2) {
        CommitIndex++; // Commit!
      }
    '|
  }

  recovery: {
    shape: step
    label: "Log Consistency"
    desc: "Leader forces Followers to match its log. Re-apply to State Machine."
  }

  log_structure -> commit_logic: "LogEntry | Variable | {Term: 2, Index: 101}"
  commit_logic -> recovery: "Apply | Quorum-Verified | State Transition"
}

# CROSS-DOMAIN ANNOTATIONS
filesystem_journal -> postgres_wal: "Shared Principle: Local Atomic Commit" {
  style.stroke-dash: 5
}
postgres_wal -> raft_distributed: "Shared Principle: Replay Idempotency" {
  style.stroke-dash: 5
}

notes: {
  near: top-right
  local: "Filesystem: Protective. Prevents corruption of pointers."
  db: "Database: Performance. Coalesces random IO into sequential."
  dist: "Distributed: Consistency. Agreement across network partition."
}