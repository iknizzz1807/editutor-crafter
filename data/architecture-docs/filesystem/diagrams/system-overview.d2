direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}
layer_data: {
  direction: down
  label: "DATA STRUCTURES LAYER"
  style.fill: "#F0F4FF"
  style.stroke: "#3A5BD9"
  superblock: {
    shape: sql_table
    label: "struct superblock_t  (superblock.h)  [M1]"
    s_magic:             "uint32_t  | 0xDEADC0DE  | offset 0x00"
    s_version:           "uint32_t  | fs version  | offset 0x04"
    s_block_size:        "uint32_t  | always 4096 | offset 0x08"
    s_total_blocks:      "uint32_t  | image size  | offset 0x0C"
    s_total_inodes:      "uint32_t  | inode cap   | offset 0x10"
    s_free_blocks:       "uint32_t  | free count  | offset 0x14"
    s_free_inodes:       "uint32_t  | free count  | offset 0x18"
    s_inode_bmap_start:  "uint32_t  | blk 1       | offset 0x1C"
    s_block_bmap_start:  "uint32_t  | blk 2       | offset 0x20"
    s_inode_table_start: "uint32_t  | blk 3       | offset 0x24"
    s_inode_table_len:   "uint32_t  | num blocks  | offset 0x28"
    s_journal_start:     "uint32_t  | after table | offset 0x2C"
    s_journal_len:       "uint32_t  | 1024 blks   | offset 0x30"
    s_data_region_start: "uint32_t  | first data  | offset 0x34"
    s_root_inode:        "uint32_t  | always 1    | offset 0x38"
    s_reserved:          "uint8_t[4036] | padding | offset 0x3C"
    sz:                  "Total: 4096 bytes (1 full block)"
  }
  inode: {
    shape: sql_table
    label: "struct inode_t  (inode.h)  [M2]"
    i_mode:        "uint16_t  | S_IFDIR|S_IFREG | offset 0x00"
    i_nlinks:      "uint16_t  | ref count       | offset 0x02"
    i_uid:         "uint16_t  | owner UID       | offset 0x04"
    i_gid:         "uint16_t  | owner GID       | offset 0x06"
    i_size:        "uint32_t  | logical bytes   | offset 0x08"
    i_atime:       "uint32_t  | unix timestamp  | offset 0x0C"
    i_mtime:       "uint32_t  | data mod time   | offset 0x10"
    i_ctime:       "uint32_t  | meta chg time   | offset 0x14"
    i_blocks_0_11: "uint32_t[12] | direct ptrs  | offset 0x18"
    i_single_ind:  "uint32_t  | → 1024 ptrs    | offset 0x48"
    i_double_ind:  "uint32_t  | → 1024 si ptrs | offset 0x4C"
    i_reserved:    "uint8_t[48] | zero-filled   | offset 0x50"
    sz:            "Total: 128 bytes  (32 inodes/block)"
  }
  dirent: {
    shape: sql_table
    label: "struct dirent_t  (dir.h)  [M3]"
    d_inode:     "uint32_t  | target inode | offset 0x00  (0=deleted)"
    d_rec_len:   "uint16_t  | skip bytes   | offset 0x04  (mult of 4)"
    d_name_len:  "uint8_t   | name length  | offset 0x06"
    d_file_type: "uint8_t   | 1=reg 2=dir  | offset 0x07"
    d_name:      "char[255] | NOT null-term| offset 0x08"
    sz:          "Total: 8 + name_len bytes, padded to 4B align"
  }
  txn: {
    shape: sql_table
    label: "struct txn_t  (txn.h)  [M6]"
    sequence:    "uint32_t  | monotonic ID | per transaction"
    nr_blocks:   "uint32_t  | count        | max 64 blocks"
    targets_64:  "uint32_t[64] | fs block nums | where to write"
    data_64:     "uint8_t[64][4096] | new block content | 256KB max"
    sz:          "Total: ~264 KB in-memory transaction buffer"
  }
  journal_super: {
    shape: sql_table
    label: "struct journal_super_t  (journal_types.h)  [M6]"
    j_magic:        "uint32_t  | 0x4A4F5552 | 'JOUR'"
    j_block_type:   "uint32_t  | 0x01=super  | type tag"
    j_sequence:     "uint32_t  | next txn ID | monotonic"
    j_head:         "uint32_t  | oldest live | circular buf"
    j_tail:         "uint32_t  | next write  | circular buf"
    j_total_blocks: "uint32_t  | usable blks | journal_len-1"
    j_reserved:     "uint8_t[4072] | padding| offset 0x18"
    sz:             "Total: 4096 bytes (1 block)"
  }
  journal_desc: {
    shape: sql_table
    label: "struct journal_desc_t  (journal_types.h)  [M6]"
    j_magic:       "uint32_t  | 0x4A4F5552 | magic"
    j_block_type:  "uint32_t  | 0x02=desc  | type"
    j_sequence:    "uint32_t  | txn ID     | must match commit"
    j_nr_blocks:   "uint32_t  | payload cnt| blocks following"
    j_block_map:   "uint64_t[500] | target blk nums | 4000 bytes"
    sz:            "Total: 4096 bytes  max 500 blocks/descriptor"
  }
  journal_commit: {
    shape: sql_table
    label: "struct journal_commit_t  (journal_types.h)  [M6]"
    j_magic:      "uint32_t  | 0x4A4F5552 | magic"
    j_block_type: "uint32_t  | 0x03=commit| atomic sentinel"
    j_sequence:   "uint32_t  | txn ID     | matches descriptor"
    j_checksum:   "uint32_t  | byte sum   | integrity check"
    j_reserved:   "uint8_t[4080] | padding| offset 0x10"
    sz:           "Total: 4096 bytes  single atomic sector write"
  }
  fs_ctx: {
    shape: sql_table
    label: "struct FsCtx  (fuse_context.h)  [M5]"
    fd:          "int           | disk image fd  | offset 0x00"
    sb:          "superblock_t  | in-memory copy | offset 0x04 (4096B)"
    lock:        "pthread_mutex_t | global lock  | offset 0x1004"
    mount_flags: "uint32_t      | direct_io etc  | offset 0x102C"
    image_path:  "char[256]     | path to .img   | offset 0x1030"
    sz:          "Total: ~4400 bytes  (page-aligned recommended)"
  }
  disk_layout: {
    shape: sql_table
    label: "On-Disk Layout  (fs_types.h)  [M1]"
    blk0:    "Block 0       | Superblock           | 4096 bytes"
    blk1:    "Block 1       | Inode Bitmap         | 4096 bytes  (32768 inodes max)"
    blk2:    "Block 2       | Block Bitmap         | 4096 bytes  (32768 data blks)"
    blk3_N:  "Blocks 3..N   | Inode Table          | N = ceil(total_inodes/32)"
    blkN_M:  "Blocks N+1..M | Journal Region       | 1024 blocks = 4MB"
    blkM_end:"Blocks M+1..end| Data Region         | free for files"
    sz:      "Bitmap bit 0 = data_region_start  (NEVER block 0)"
  }
}
layer_logic: {
  direction: down
  label: "LOGIC / MODULE LAYER"
  style.fill: "#FFF8F0"
  style.stroke: "#D96B00"
  block_io: {
    shape: class
    label: "BlockIO  (block_io.c)  [M1]"
    fields: |'c
      /* No persistent state; all I/O is stateless */
      #define BLOCK_SIZE   4096
      #define SECTOR_SIZE  512
    '|
    methods: |'c
      int  read_block(int fd, uint32_t block_num, void *buf);
      int  write_block(int fd, uint32_t block_num, const void *buf);
      int  validate_block_num(uint32_t n, uint32_t total);
    '|
  }
  bitmap_ops: {
    shape: class
    label: "BitmapOps  (bitmap.c)  [M1]"
    fields: |'c
      #define BLOCK_BITMAP_BLOCK  2
      #define INODE_BITMAP_BLOCK  1
      /* 1 bit per block; 0=free, 1=used */
    '|
    methods: |'c
      int  bitmap_find_free(const uint8_t *bmap, uint32_t total);
      void bitmap_set(uint8_t *bmap, uint32_t index);
      void bitmap_clear(uint8_t *bmap, uint32_t index);
      int  bitmap_test(const uint8_t *bmap, uint32_t index);
      int  alloc_data_block(int fd, superblock_t *sb);
      int  free_data_block(int fd, superblock_t *sb, uint32_t blk);
      int  alloc_inode(int fd, superblock_t *sb);
      int  free_inode_bitmap(int fd, superblock_t *sb, uint32_t ino);
    '|
  }
  superblock_mod: {
    shape: class
    label: "SuperblockMod  (superblock.c)  [M1]"
    fields: |'c
      #define FS_MAGIC    0xDEADC0DE
      #define FS_VERSION  1
      #define INODES_PER_BLOCK  (4096/128)  /* 32 */
    '|
    methods: |'c
      void compute_layout(uint32_t total_blks, uint32_t total_inos,
                          superblock_t *sb);
      int  read_superblock(int fd, superblock_t *sb);
      int  write_superblock(int fd, const superblock_t *sb);
      int  validate_magic(const superblock_t *sb);
    '|
  }
  mkfs_tool: {
    shape: class
    label: "mkfs  (mkfs.c)  [M1]"
    fields: |'c
      /* Standalone CLI: mkfs <image> <blocks> <inodes> */
      /* Creates disk image via ftruncate(2)            */
    '|
    methods: |'c
      int mkfs(const char *path, uint32_t total_blks,
               uint32_t total_inos);
      int verify_filesystem(const char *path);
      /* Internally calls: compute_layout, write_superblock, */
      /* zero bitmaps, zero inode table, init root inode     */
    '|
  }
  inode_io: {
    shape: class
    label: "InodeIO  (inode_io.c)  [M2]"
    fields: |'c
      #define INODE_SIZE  128
      #define N_DIRECT    12
      #define PTRS_PER_BLOCK  (4096/4)  /* 1024 */
    '|
    methods: |'c
      int  read_inode(int fd, const superblock_t *sb,
                      uint32_t ino, inode_t *out);
      int  write_inode(int fd, const superblock_t *sb,
                       uint32_t ino, const inode_t *inode);
      void inode_init_file(inode_t *ino, uint16_t mode,
                           uint16_t uid, uint16_t gid);
      void inode_init_dir(inode_t *ino, uint16_t mode,
                          uint16_t uid, uint16_t gid);
    '|
  }
  inode_tree: {
    shape: class
    label: "InodeTree  (inode_tree.c)  [M2]"
    fields: |'c
      /* Direct limit:  12 * 4096 = 49152 bytes  */
      /* Single limit:  1024 * 4096 = 4MB         */
      /* Double limit:  1024^2 * 4096 = 4GB       */
    '|
    methods: |'c
      int inode_get_block(int fd, const inode_t *ino,
                          uint64_t offset, uint32_t *out_blk);
      int inode_set_block(int fd, superblock_t *sb,
                          inode_t *ino, uint64_t offset,
                          uint32_t disk_blk);
      int free_inode_full(int fd, superblock_t *sb,
                          uint32_t ino_num);
    '|
  }
  dir_ops: {
    shape: class
    label: "DirOps  (dir_scan.c dir_write.c dir_op.c)  [M3]"
    fields: |'c
      #define MAX_FILENAME_LEN  255
      #define DIRENT_HEADER_SIZE 8
      /* rec_len always multiple of 4 (4-byte aligned) */
    '|
    methods: |'c
      int  dir_lookup(int fd, const superblock_t *sb,
                      const inode_t *dir, const char *name);
      int  dir_add_entry(int fd, superblock_t *sb,
                         uint32_t dir_ino, const char *name,
                         uint32_t target, uint8_t type);
      int  dir_remove_entry(int fd, superblock_t *sb,
                            uint32_t dir_ino, const char *name);
      int  dir_readdir(int fd, const superblock_t *sb,
                       uint32_t dir_ino, readdir_cb_t cb,
                       void *userdata);
      bool dir_is_empty(int fd, const inode_t *dir_ino);
    '|
  }
  path_res: {
    shape: class
    label: "PathResolver  (dir_path.c)  [M3]"
    fields: |'c
      /* Uses strtok_r (NOT strtok) — thread-safe    */
      /* Current working dir tracked per FUSE context */
    '|
    methods: |'c
      int path_resolve(int fd, const superblock_t *sb,
                       const char *path, uint32_t root_ino,
                       uint32_t cwd_ino);
      int path_resolve_parent(int fd, const superblock_t *sb,
                              const char *path, uint32_t root,
                              uint32_t cwd,
                              uint32_t *parent_ino_out,
                              char *name_out, size_t name_max);
    '|
  }
  posix_dir: {
    shape: class
    label: "POSIXDir  (dir_op.c)  [M3]"
    fields: |'c
      /* Enforces POSIX link-count invariants:        */
      /* mkdir: parent.nlinks++, child.nlinks=2       */
      /* rmdir: parent.nlinks--, requires empty dir   */
    '|
    methods: |'c
      int fs_mkdir(int fd, superblock_t *sb, uint32_t parent_ino,
                   const char *name, uint16_t mode,
                   uint16_t uid, uint16_t gid);
      int fs_rmdir(int fd, superblock_t *sb, uint32_t parent_ino,
                   const char *name);
      int fs_link(int fd, superblock_t *sb, uint32_t target_ino,
                  uint32_t dir_ino, const char *new_name);
      int fs_unlink(int fd, superblock_t *sb, uint32_t dir_ino,
                    const char *name);
    '|
  }
  file_ops: {
    shape: class
    label: "FileOps  (file_create.c file_read.c file_write.c file_truncate.c)  [M4]"
    fields: |'c
      /* RMW triggered when: block_off != 0 || chunk < 4096 */
      /* Sparse holes: disk_block==0 -> memset(0) no disk IO */
    '|
    methods: |'c
      int     fs_create_file(int fd, superblock_t *sb,
                             uint32_t parent_ino, const char *name,
                             uint16_t mode, uint16_t uid, uint16_t gid);
      ssize_t fs_read(int fd, superblock_t *sb, uint32_t ino,
                      uint64_t offset, void *buf, size_t len);
      ssize_t fs_write(int fd, superblock_t *sb, uint32_t ino,
                       uint64_t offset, const void *buf, size_t len);
      ssize_t fs_append(int fd, superblock_t *sb, uint32_t ino,
                        const void *buf, size_t len);
      int     fs_truncate(int fd, superblock_t *sb, uint32_t ino,
                          uint64_t new_size);
    '|
  }
  fuse_bridge: {
    shape: class
    label: "FUSEBridge  (fuse_bridge.c myfs_main.c)  [M5]"
    fields: |'c
      static FsCtx g_fs;   /* global filesystem context */
      /* fi->fh = inode_num  (set in open/create)       */
      /* fi->direct_io = 1   (bypass kernel page cache)  */
      /* entry_timeout = 1.0 (dcache hint to kernel)     */
    '|
    methods: |'c
      void  inode_to_stat(const inode_t *ino, uint32_t ino_num,
                          struct stat *st);
      int   bridge_path_to_inode(const char *path,
                                 uint32_t *out_ino,
                                 inode_t *out_inode);
      void* myfs_init(struct fuse_conn_info *conn,
                      struct fuse_config *cfg);
      void  myfs_destroy(void *private_data);
    '|
  }
  fuse_callbacks: {
    shape: class
    label: "FUSECallbacks  (fuse_ops_meta.c fuse_ops_dir.c fuse_ops_file.c)  [M5]"
    fields: |'c
      /* All callbacks: lock -> work -> unlock -> return */
      /* Global mutex: pthread_mutex_t g_fs.lock         */
    '|
    methods: |'c
      int myfs_getattr(const char *path, struct stat *st,
                       struct fuse_file_info *fi);
      int myfs_readdir(const char *path, void *buf,
                       fuse_fill_dir_t filler, off_t offset,
                       struct fuse_file_info *fi,
                       enum fuse_readdir_flags flags);
      int myfs_open(const char *path, struct fuse_file_info *fi);
      int myfs_create(const char *path, mode_t mode,
                      struct fuse_file_info *fi);
      int myfs_read(const char *path, char *buf, size_t size,
                    off_t offset, struct fuse_file_info *fi);
      int myfs_write(const char *path, const char *buf,
                     size_t size, off_t offset,
                     struct fuse_file_info *fi);
      int myfs_truncate(const char *path, off_t size,
                        struct fuse_file_info *fi);
      int myfs_mkdir(const char *path, mode_t mode);
      int myfs_rmdir(const char *path);
      int myfs_unlink(const char *path);
      int myfs_rename(const char *old_path, const char *new_path,
                      unsigned int flags);
      int myfs_chmod(const char *path, mode_t mode,
                     struct fuse_file_info *fi);
      int myfs_utimens(const char *path,
                       const struct timespec ts[2],
                       struct fuse_file_info *fi);
      int myfs_statfs(const char *path, struct statvfs *stbuf);
    '|
  }
  journal_engine: {
    shape: class
    label: "JournalEngine  (txn.c recovery.c checkpoint.c journal_io.c)  [M6]"
    fields: |'c
      static journal_super_t g_jsuper;  /* in-memory journal super */
      #define MAX_TXN_BLOCKS  64
      /* Protocol: write desc -> write data -> fsync ->  */
      /* write commit -> fsync -> write in-place -> fsync */
    '|
    methods: |'c
      int  journal_load(int fd, const superblock_t *sb);
      int  journal_persist_super(int fd, const superblock_t *sb);
      void txn_begin(txn_t *txn, int fd, superblock_t *sb);
      int  txn_journal_block(txn_t *txn, uint32_t fs_blk,
                             const void *data);
      int  txn_commit(txn_t *txn);
      int  journal_recover(int fd, superblock_t *sb);
      int  journal_checkpoint(int fd, superblock_t *sb);
      uint32_t journal_abs_block(const superblock_t *sb,
                                 uint32_t journal_offset);
    '|
  }
  journal_wrappers: {
    shape: class
    label: "JournalWrappers  (journal_wrappers.c)  [M6]"
    fields: |'c
      /* Every metadata write goes through txn_journal_block */
      /* Data blocks are written directly (ordered mode)     */
    '|
    methods: |'c
      int txn_write_inode(txn_t *txn, uint32_t ino_num,
                          const inode_t *inode);
      int txn_write_block_bitmap(txn_t *txn, uint8_t *bitmap);
      int txn_write_inode_bitmap(txn_t *txn, uint8_t *bitmap);
      int fs_create_file_journaled(int fd, superblock_t *sb,
                                   uint32_t parent_ino,
                                   const char *name,
                                   uint16_t mode,
                                   uint16_t uid, uint16_t gid);
      int fs_write_journaled(int fd, superblock_t *sb,
                             uint32_t ino, uint64_t offset,
                             const void *buf, size_t length);
    '|
  }
}
layer_io: {
  direction: down
  label: "I/O & INTEGRATION LAYER"
  style.fill: "#F0FFF4"
  style.stroke: "#1A7A3A"
  disk_image: {
    shape: cylinder
    label: "disk.img\n(block device simulation)\n[M1–M6]"
    style.fill: "#D0EFD8"
  }
  fuse_kernel: {
    shape: hexagon
    label: "FUSE Kernel Module\n/dev/fuse\n(Linux VFS relay)\n[M5]"
    style.fill: "#D8EAF5"
  }
  user_apps: {
    shape: person
    label: "User Applications\nls, cat, cp, vim\ngrep, find\n[M5]"
    style.fill: "#FFF0D8"
  }
  mkfs_bin: {
    shape: rectangle
    label: "mkfs binary\n(CLI tool)\n./mkfs disk.img 4096 1024\n[M1]"
    style.fill: "#E8F5E9"
  }
  crash_sim: {
    shape: diamond
    label: "Crash Simulation\nSIGKILL mid-txn\nRecovery on remount\n[M6]"
    style.fill: "#FFEEF0"
  }
  page_cache: {
    shape: queue
    label: "Host Kernel\nPage Cache\n(dirty pages buffered)\nfsync() forces flush\n[M1–M6]"
    style.fill: "#FFF9D8"
  }
}
step_mkfs: {
  label: "mkfs() Sequence  [M1]"
  width: 380
  step1: |'c
    /* 1. ftruncate(fd, total_blocks * 4096) */
    /* 2. compute_layout -> fill superblock   */
    /* 3. write_block(0, superblock)          */
    /* 4. write_block(1, zero inode bitmap)   */
    /* 5. write_block(2, zero block bitmap)   */
    /* 6. zero inode table blocks             */
    /* 7. alloc inode 1 (root), nlinks=2      */
    /* 8. write '.' and '..' to data block 0  */
    /* 9. fsync(fd) before close              */
  '|
}
step_write: {
  label: "fs_write() RMW Logic  [M4]"
  width: 380
  code: |'c
    /* For each 4KB chunk in [offset, offset+len): */
    block_off = cur_offset % 4096;
    chunk     = min(4096 - block_off, remaining);
    partial   = (block_off != 0 || chunk < 4096);
    inode_get_block(... , &disk_blk);
    if (disk_blk == 0) {
      disk_blk = alloc_data_block(...);
      inode_set_block(..., disk_blk);
      memset(buf, 0, 4096);          /* zero-init */
    } else if (partial)
      read_block(fd, disk_blk, buf); /* READ in RMW */
    memcpy(buf + block_off, in, chunk);  /* MODIFY */
    write_block(fd, disk_blk, buf);       /* WRITE */
  '|
}
step_txn: {
  label: "txn_commit() 8-Step Protocol  [M6]"
  width: 380
  code: |'c
    /* 1. write_block(desc_abs, descriptor)       */
    /* 2. write_block(data_abs[i], txn->data[i])  */
    /* 3. fsync(fd)   ← Barrier 1: data durable  */
    /* 4. write_block(commit_abs, commit_record)  */
    /* 5. fsync(fd)   ← Barrier 2: COMMITTED      */
    /* 6. write_block(target[i], txn->data[i])    */
    /* 7. fsync(fd)   ← in-place writes durable  */
    /* 8. j_tail++; j_sequence++; persist jsuper  */
  '|
}
step_recover: {
  label: "journal_recover() Algorithm  [M6]"
  width: 380
  code: |'c
    /* pos = j_head; scan to j_tail:              */
    /* Read desc; if j_magic != JOURNAL_MAGIC stop*/
    /* Read nr_blocks data blocks after desc       */
    /* Read commit at pos + 1 + nr_blocks          */
    /* if commit.j_sequence == desc.j_sequence AND */
    /*    checksum matches: REPLAY (write in-place) */
    /* else: DISCARD (incomplete transaction)       */
    /* After loop: journal_checkpoint()            */
  '|
}
milestone_index: {
  shape: sql_table
  label: "Milestone Index"
  m1: "M1 | filesystem-m1 | Block Layer and mkfs"
  m2: "M2 | filesystem-m2 | Inode Management"
  m3: "M3 | filesystem-m3 | Directory Operations"
  m4: "M4 | filesystem-m4 | File Read/Write Operations"
  m5: "M5 | filesystem-m5 | FUSE Integration"
  m6: "M6 | filesystem-m6 | Write-Ahead Journaling"
}
milestone_index.near: bottom-center
layer_data -> layer_logic: "struct definitions | consumed by | e.g. inode_t → read_inode()"
layer_logic -> layer_io: "function calls | produce/consume | e.g. fs_write() → write_block()"
layer_io -> layer_logic: "callbacks | FUSE relay | e.g. /dev/fuse → myfs_read()"
layer_logic.block_io -> layer_io.disk_image: "uint8_t[4096] | read/write block | lseek+read/write(fd)"
layer_logic.block_io -> layer_io.page_cache: "4KB writes | kernel buffers | dirty until fsync"
layer_logic.fuse_callbacks -> layer_io.fuse_kernel: "struct stat, int errno | VFS response | over /dev/fuse"
layer_io.user_apps -> layer_io.fuse_kernel: "POSIX syscalls | open/read/write/stat | e.g. open('/mnt/f')"
layer_io.fuse_kernel -> layer_logic.fuse_callbacks: "path string | dispatch | e.g. myfs_getattr('/home')"
layer_io.mkfs_bin -> layer_logic.mkfs_tool: "CLI args | invokes | mkfs('disk.img', 4096, 1024)"
layer_logic.superblock_mod -> layer_data.superblock: "superblock_t* | read/write | block 0  4096 bytes"
layer_logic.inode_io -> layer_data.inode: "inode_t* | RMW 128 bytes | table block = 3 + (ino-1)/32"
layer_logic.dir_ops -> layer_data.dirent: "dirent_t | scan/write | rec_len chain in dir data blocks"
layer_logic.journal_engine -> layer_data.txn: "txn_t* | accumulate | max 64 blocks per txn"
layer_logic.journal_engine -> layer_data.journal_super: "journal_super_t | head/tail | circular buffer mgmt"
layer_logic.journal_engine -> layer_data.journal_desc: "journal_desc_t | write | before data blocks"
layer_logic.journal_engine -> layer_data.journal_commit: "journal_commit_t | atomic | POINT OF NO RETURN"
layer_logic.fuse_bridge -> layer_data.fs_ctx: "FsCtx* | global state | fd + sb + lock"
layer_logic.bitmap_ops -> layer_logic.block_io: "uint8_t[4096] | RMW bitmap | read→set bit→write"
layer_logic.inode_tree -> layer_logic.bitmap_ops: "uint32_t block_num | alloc on demand | inode_set_block"
layer_logic.inode_io -> layer_logic.block_io: "uint8_t[4096] | inode table RMW | 32 inodes per block"
layer_logic.dir_ops -> layer_logic.inode_io: "inode_t* | read dir inode | verify S_ISDIR"
layer_logic.dir_ops -> layer_logic.block_io: "uint8_t[4096] | scan dir data | rec_len walk"
layer_logic.path_res -> layer_logic.dir_ops: "uint32_t ino | per component | strtok_r on '/'"
layer_logic.posix_dir -> layer_logic.dir_ops: "dir_ino, name | add/remove entry | nlinks managed"
layer_logic.posix_dir -> layer_logic.inode_io: "inode_t* | update nlinks | ctime always updated"
layer_logic.file_ops -> layer_logic.inode_tree: "uint64_t offset | get/set block ptr | up to 4GB"
layer_logic.file_ops -> layer_logic.bitmap_ops: "uint32_t blk | alloc on write | free on truncate"
layer_logic.fuse_callbacks -> layer_logic.path_res: "const char *path | resolve | root_ino + components"
layer_logic.fuse_callbacks -> layer_logic.file_ops: "ino from fi->fh | fs_read/fs_write | offset+len"
layer_logic.fuse_callbacks -> layer_logic.posix_dir: "path + name | mkdir/rmdir/unlink | POSIX semantics"
layer_logic.fuse_bridge -> layer_logic.fuse_callbacks: "FsCtx* g_fs | shared state | global lock guards"
layer_logic.journal_wrappers -> layer_logic.journal_engine: "txn_t* | wrap metadata | txn_begin→commit"
layer_logic.journal_wrappers -> layer_logic.inode_io: "inode_t block | journal before write | ordered mode"
layer_logic.journal_engine -> layer_logic.block_io: "uint8_t[4096] | journal region writes | sequential"
layer_logic.fuse_callbacks -> layer_logic.journal_wrappers: "metadata change | wrap in txn | atomic guarantee"
layer_io.crash_sim -> layer_logic.journal_engine: "SIGKILL | triggers recovery | journal_recover on mount"