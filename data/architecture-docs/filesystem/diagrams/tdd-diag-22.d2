direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
  colors: {
    header: "#E1D5E7"
    data: "#D0E7FF"
    free: "#D5E8D4"
    padding: "#F5F5F5"
    pointer: "#FFE0B2"
    sparse: "#FFF2CC"
  }
}

title: |'md
# fs_read(offset=6000, length=5000)
### Implementation-Grade Data Walk
'| {
  shape: text
  near: top-center
}

# -----------------------------------------------------------------------------
# Logical View: The Request
# -----------------------------------------------------------------------------
request: {
  label: "Logical File Address Space"
  
  block_1: {
    label: "Block Index 1 (4096 - 8191)"
    style.stroke-dash: 3
    
    skipped: "Offset 0 - 1903 (Unread)" {
      style.fill: ${colors.padding}
    }
    target_1: "Read Range: 1904 - 4095 (2192 Bytes)" {
      style.fill: ${colors.data}
      style.font-color: blue
      style.bold: true
    }
  }
  
  block_2: {
    label: "Block Index 2 (8192 - 12287)"
    style.stroke-dash: 3
    
    target_2: "Read Range: 0 - 2807 (2808 Bytes)" {
      style.fill: ${colors.data}
      style.font-color: blue
      style.bold: true
    }
    remainder: "Offset 2808 - 4095 (Unread)" {
      style.fill: ${colors.padding}
    }
  }
}

# -----------------------------------------------------------------------------
# Call Sequence & Translation
# -----------------------------------------------------------------------------
translation: {
  label: "VFS Path to Physical I/O"
  
  step_1: "1. inode_get_block(idx=1)" {
    style.fill: ${colors.header}
    style.border-radius: 20
  }
  
  step_2: "2. read_block(disk_blk_A)" {
    style.fill: ${colors.pointer}
    style.border-radius: 20
  }
  
  step_3: "3. inode_get_block(idx=2)" {
    style.fill: ${colors.header}
    style.border-radius: 20
  }
  
  decision: "4. disk_block == 0?" {
    shape: diamond
    style.fill: ${colors.sparse}
  }
  
  step_5a: "5a. read_block(disk_blk_B)" {
    style.fill: ${colors.pointer}
    style.border-radius: 20
  }
  
  step_5b: "5b. memset(out, 0, 2808)" {
    style.fill: ${colors.sparse}
    style.stroke: red
    style.border-radius: 20
  }
  
  step_1 -> step_2: "disk_blk_A = 0x500"
  step_3 -> decision
  decision -> step_5a: "No (Allocated)"
  decision -> step_5b: "Yes (Sparse)"
}

# -----------------------------------------------------------------------------
# Destination: User Memory Buffer
# -----------------------------------------------------------------------------
user_buffer: {
  label: "User Space Buffer (void *buf)"
  
  chunk_1: "Offset [0 - 2191]\n(From Block 1)" {
    style.fill: ${colors.data}
    width: 300
  }
  
  chunk_2: "Offset [2192 - 4999]\n(From Block 2)" {
    style.fill: ${colors.data}
    width: 300
  }
}

# -----------------------------------------------------------------------------
# Data Movement Arrows
# -----------------------------------------------------------------------------
request.block_1.target_1 -> user_buffer.chunk_1: "memcpy(buf + 0, disk_A + 1904, 2192)" {
  style: {
    stroke: blue
    stroke-width: 2
    animated: true
  }
}

translation.step_5a -> user_buffer.chunk_2: "Physical Read" {
  style.stroke-dash: 5
}

translation.step_5b -> user_buffer.chunk_2: "Zero Fill (No I/O)" {
  style: {
    stroke: red
    stroke-width: 3
  }
}

# -----------------------------------------------------------------------------
# Layout Details (Memory Map)
# -----------------------------------------------------------------------------
memory_map: |'md
### Arithmetic Breakdown
| Variable | Iteration 1 | Iteration 2 |
| :--- | :--- | :--- |
| **block_index** | `6000 / 4096 = 1` | `8192 / 4096 = 2` |
| **block_off** | `6000 % 4096 = 1904` | `8192 % 4096 = 0` |
| **chunk_size** | `min(4096-1904, 5000) = 2192` | `min(4096-0, 2808) = 2808` |
| **I/O Type** | `read_block` | `read_block` OR `memset` |
'| {
  shape: text
  near: bottom-right
}

# Annotations
legend: {
  near: bottom-left
  
  color1: "Metadata/Header" {
    style.fill: ${colors.header}
  }
  color2: "File Data" {
    style.fill: ${colors.data}
  }
  color3: "Sparse Hole" {
    style.fill: ${colors.sparse}
  }
}