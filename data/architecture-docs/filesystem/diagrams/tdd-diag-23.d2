direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# Master Legend for Engineers
Legend: {
  shape: package
  near: top-left
  Input: "Input Variable" {style.fill: "#e3f2fd"}
  Computed: "Computed/Changed" {style: {fill: "#fff9c4"; stroke: red; bold: true}}
  Action: "Hardware I/O" {style: {fill: "#f3e5f5"; stroke: "#6a1b9a"; stroke-dash: 3}}
}

# Loop iteration logic for fs_write
fs_write_iteration: {
  
  Step_1: "1. Boundary Calculation" {
    style.fill: "#f5f5f5"
    State: {
      shape: sql_table
      input_cur_offset: uint64_t {label: "cur_offset: 5000"}
      input_remaining: uint64_t {label: "remaining: 100"}
      calc_block_off: uint32_t {label: "**block_off: 904 (5000 % 4096)**"; style.font-color: red}
      calc_chunk: uint32_t {label: "**chunk: 100 (min(3192, 100))**"; style.font-color: red}
      calc_partial: bool {label: "**partial_write: TRUE (904 != 0)**"; style.font-color: red}
    }
    
    Action: "inode_get_block(cur_offset - block_off)" {
      shape: parallelogram
      style.fill: "#e8eaf6"
    }
    
    State.calc_block_off -> Action
  }

  Step_2: "2. Block Prep (Hole vs Existing)" {
    Decision: "disk_block == 0?" {shape: diamond}
    
    Branch_Hole: "New Allocation (Hole)" {
      alloc: "alloc_data_block()" {style.stroke: "#2e7d32"}
      map: "inode_set_block()"
      zero: "**memset(block_buf, 0, 4096)**" {style.font-color: red}
      
      alloc -> map -> zero
    }
    
    Branch_Existing: "Existing Block" {
      partial_check: "partial_write == TRUE?" {shape: diamond}
      read_op: "**read_block(disk_block, block_buf)**" {
        label: "THE READ (RMW Cycle)"
        style: {fill: "#ffebee"; font-color: red; stroke: red; stroke-width: 2}
      }
      skip_read: "Skip Read (Full Overwrite)"
      
      partial_check -> read_op: Yes
      partial_check -> skip_read: No
    }
    
    Decision -> Branch_Hole: Yes
    Decision -> Branch_Existing: No
  }

  Step_3: "3. Modify & Commit" {
    style.fill: "#f1f8e9"
    
    Modify: "**memcpy(block_buf + block_off, in, chunk)**" {
      label: "THE MODIFY (Apply User Data)"
      style: {font-color: red; bold: true}
    }
    
    Write: "**write_block(disk_block, block_buf)**" {
      label: "THE WRITE (Commit to Disk)"
      style: {fill: "#e1f5fe"; font-color: "#01579b"; stroke: "#01579b"; stroke-width: 2}
    }
    
    Modify -> Write
  }

  Step_4: "4. Advance State" {
    Update: {
      shape: sql_table
      new_offset: uint64_t {label: "**cur_offset += chunk (5100)**"; style.font-color: red}
      new_remaining: uint64_t {label: "**remaining -= chunk (0)**"; style.font-color: red}
    }
  }

  Step_1 -> Step_2 -> Step_3 -> Step_4
}

# Annotations for Intel Manual Quality
fs_write_iteration.Step_2.Branch_Existing.read_op.tooltip: |md
  ### READ-MODIFY-WRITE (RMW)
  Required whenever a write does not align perfectly to a 4KB boundary or is smaller than 4KB. 
  **Cost:** 1 Read I/O + 1 Write I/O.
|
fs_write_iteration.Step_2.Branch_Existing.read_op.tooltip.near: center-left

fs_write_iteration.Step_2.Branch_Hole.zero.tooltip: |md
  ### SECURITY ZEROING
  Freshly allocated blocks from the host OS may contain garbage. 
  We must zero the buffer before `memcpy` to ensure sparse "tails" are clean.
|
fs_write_iteration.Step_2.Branch_Hole.zero.tooltip.near: center-right

fs_write_iteration.Step_3.Write.style.stroke-width: 4
fs_write_iteration.Step_1.State.style.stroke: "#1976d2"