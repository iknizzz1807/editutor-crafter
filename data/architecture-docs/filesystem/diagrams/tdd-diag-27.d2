direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

user_space_apps: "User Applications" {
  ls: "ls -la /mnt/myfs" {
    shape: person
    tooltip: "Blocked waiting for VFS"
  }
  cat: "cat /mnt/myfs/file" {
    shape: person
    tooltip: "Blocked waiting for VFS"
  }
  cp: "cp file /mnt/myfs/" {
    shape: person
    tooltip: "Blocked waiting for VFS"
  }
}

kernel_space: "Linux Kernel Space" {
  style.fill: "#e1d5e7"
  
  vfs: "VFS Layer" {
    shape: rectangle
    style.fill: "#d5e8d4"
    "stat()"
    "open()"
    "read()"
  }

  fuse_kmod: "FUSE Kernel Module" {
    shape: rectangle
    style.fill: "#dae8fc"
    fields: |md
      - request_queue: list<fuse_req>
      - pending_table: hash_map<id, req>
    |
  }

  vfs -> fuse_kmod: "Dispatch Op"
}

ipc_bridge: "/dev/fuse" {
  shape: cylinder
  style.fill: "#fff2cc"
  label: |md
    ### /dev/fuse
    Character Device
    (Communication Channel)
  |
}

myfs_daemon: "myfs Userspace Process" {
  style.fill: "#f8cecc"
  
  libfuse: "libfuse event loop" {
    methods: |md
      + fuse_session_receive_buf()
      + fuse_session_process_buf()
    |
  }

  callbacks: "myfs Implementation" {
    shape: class
    methods: |md
      + getattr(path: const char*, st: struct stat*): int
      + open(path: const char*, fi: fuse_file_info*): int
      + read(path: const char*, buf: char*, size: size_t, off: off_t): int
      + write(path: const char*, buf: const char*, size: size_t, off: off_t): int
    |
  }

  libfuse -> callbacks: "Execute Callback"
}

# Data Flow and Context Switches
user_space_apps.ls -> kernel_space.vfs: "1. stat() Syscall" {
  style.stroke: blue
  style.stroke-width: 2
}

kernel_space.fuse_kmod -> ipc_bridge: "2. Queue Request"
ipc_bridge -> myfs_daemon.libfuse: "3. Read Request" {
  style.stroke-dash: 5
  style.font-color: red
  label: |md
    **Ctx Switch 1**
    Kernel -> User
    Latency: ~1-2µs
  |
}

myfs_daemon.callbacks -> ipc_bridge: "4. Write Response" {
  style.stroke-dash: 5
  style.font-color: red
  label: |md
    **Ctx Switch 2**
    User -> Kernel
    Latency: ~1-2µs
  |
}

ipc_bridge -> kernel_space.fuse_kmod: "5. Signal Completion"
kernel_space.vfs -> user_space_apps.ls: "6. Syscall Return" {
  style.stroke: blue
}

# Multiplexing Note
note: |md
  ### FUSE Multiplexing
  FUSE kernel module manages multiple
  outstanding requests using unique IDs.
  myfs can serve concurrent syscalls
  from **ls**, **cat**, and **cp**
  simultaneously using worker threads.
| {
  near: bottom-center
}

# Legend
legend: {
  near: bottom-right
  s1: "Solid = Blocking Path" {
    style.stroke: blue
  }
  s2: "Dashed = Context Switch" {
    style.stroke-dash: 5
  }
}

# Constraints
user_space_apps.ls -> user_space_apps.cat -> user_space_apps.cp: {style.opacity: 0}