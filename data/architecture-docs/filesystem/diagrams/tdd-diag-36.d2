layout-engine: elk
vars: {
  d2-config: {
    theme-id: 4
  }
  colors: {
    header: "#a855f7"
    data: "#3b82f6"
    free: "#22c55e"
    padding: "#9ca3af"
    pointers: "#f97316"
    recovery_red: "#ef4444"
  }
}

classes: {
  volatile_mem: {
    style: {
      fill: "#f3f4f6"
      stroke-dash: 3
    }
  }
  durable_disk: {
    style: {
      fill: "#3b82f6"
      font-color: white
    }
  }
  replay_node: {
    style: {
      fill: "#ef4444"
      font-color: white
      bold: true
    }
  }
}

legend: {
  near: top-center
  v: "Volatile (Page Cache)" { class: volatile_mem }
  d: "Durable (On Disk)" { class: durable_disk }
  r: "Recovered/Applied" { class: replay_node }
}

scenarios: {
  grid-columns: 3

  scenario_a: "SCENARIO A: Crash Before FSYNC #1" {
    state: {
      ram: "Host RAM / Page Cache" {
        style.fill: white
        desc: "DESC (Seq N)" { class: volatile_mem }
        data: "DATA (Seq N)" { class: volatile_mem }
      }
      disk: "Physical Disk" {
        style.fill: "#e5e7eb"
        journal: "Journal Region" {
          old: "[Stale/Empty]"
        }
        main: "Main FS Region" {
          structs: "Old Inodes / Bitmaps"
        }
      }
    }
    recovery: "Recovery Protocol" {
      step1: "1. Read Journal Head"
      step2: "2. Scan for DESC N"
      step3: "3. DISCARD: No Commit Found"
      step1 -> step2 -> step3
    }
    notes: "Result: Operation never happened.\nState: Consistent (Pre-Op)." {
      shape: callout
    }
  }

  scenario_b: "SCENARIO B: Crash Between FSYNC #1 & #2" {
    state: {
      ram: "Host RAM / Page Cache" {
        style.fill: white
        commit: "COMMIT (Seq N)" { class: volatile_mem }
      }
      disk: "Physical Disk" {
        style.fill: "#e5e7eb"
        journal: "Journal Region" {
          desc: "DESC (Seq N)" { class: durable_disk }
          data: "DATA (Seq N)" { class: durable_disk }
          empty: "[Empty/Commit Missing]"
        }
        main: "Main FS Region" {
          structs: "Old Inodes / Bitmaps"
        }
      }
    }
    recovery: "Recovery Protocol" {
      step1: "1. Read Journal Head"
      step2: "2. DESC N Found"
      step3: "3. DISCARD: Commit Block Missing"
      step1 -> step2 -> step3
    }
    notes: "Result: Transaction aborted.\nState: Consistent (Pre-Op)." {
      shape: callout
    }
  }

  scenario_c: "SCENARIO C: Crash After FSYNC #2" {
    state: {
      disk: "Physical Disk" {
        style.fill: "#e5e7eb"
        journal: "Journal Region" {
          desc: "DESC (Seq N)" { class: durable_disk }
          data: "DATA (Seq N)" { class: durable_disk }
          commit: "COMMIT (Seq N)" { class: durable_disk }
        }
        main: "Main FS Region" {
          structs: "Old Inodes / Bitmaps" {
            style.stroke: red
            style.stroke-width: 4
          }
        }
      }
    }
    recovery: "Recovery Protocol" {
      step1: "1. DESC N Found"
      step2: "2. COMMIT N Valid"
      step3: "3. REPLAY: Copy to Main" {
        class: replay_node
      }
      step1 -> step2 -> step3
    }
    replay_action: "Replay Action" {
      shape: package
      style.stroke: red
      journal_data: "Journaled Data"
      main_fs: "Main FS"
      journal_data -> main_fs: "Overwrites Old Structs" {
        source-arrowhead: diamond
        style.stroke: red
        style.animated: true
      }
    }
    notes: "Result: Operation fully replayed.\nState: Consistent (Post-Op)." {
      shape: callout
    }
  }
}

# Cross-container connections (FQNs used to avoid ambiguity)

scenarios.scenario_a.state.ram.data -> scenarios.scenario_a.state.disk.journal.old: "NEVER FLUSHED"
(scenarios.scenario_a.state.ram.data -> scenarios.scenario_a.state.disk.journal.old)[0].style: {
  stroke: gray
  stroke-dash: 5
}

scenarios.scenario_b.state.ram.commit -> scenarios.scenario_b.state.disk.journal.empty: "LOST IN RAM"
(scenarios.scenario_b.state.ram.commit -> scenarios.scenario_b.state.disk.journal.empty)[0].style: {
  stroke: gray
  stroke-dash: 5
}

scenarios.scenario_c.state.disk.journal.data -> scenarios.scenario_c.state.disk.main.structs: "REPLAY"
(scenarios.scenario_c.state.disk.journal.data -> scenarios.scenario_c.state.disk.main.structs)[0].style: {
  stroke: red
  stroke-width: 3
}