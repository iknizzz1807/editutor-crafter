direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ALGORITHM: bitmap_find_free & index_to_block
# TECHNICAL SPEC: Milestone 1 - Block Layer Allocation

Step 1: "Sequential Byte Scan" {
  explanation: ||md
    ### 1. Sequential Byte Scan
    Iterate through 4KB bitmap buffer (`uint8_t[4096]`).
    Scan byte-by-byte to skip fully-used regions (`0xFF`) using word-aligned loads where possible.
  ||
  
  memory_view: {
    grid-columns: 1
    vertical-gap: 0
    
    b0: "Offset 0x00 | [ 0xFF ] | Size: 1B" {
      style.fill: "#E1D5E7" # Purple (Used/Header)
      style.stroke: "#8265A2"
    }
    b1: "Offset 0x01 | [ 0xFE ] | Size: 1B" {
      style.fill: "#D5E8D4" # Green (Contains Free)
      style.stroke: "#82B366"
      style.stroke-width: 4
    }
    b2: "Offset 0x02 | [ .... ] | Size: 1B" {
      style.fill: "#F5F5F5" # Gray (Padding/Empty)
    }
    
    b0 -> b1: "bitmap[0] == 0xFF (Full)\n**SKIP**" {
      style.stroke-dash: 3
    }
  }
}

Step 2: "Bit Discovery" {
  explanation: ||md
    ### 2. Bit Discovery
    Identify the first '0' bit within the target byte `0xFE` (Binary: `11111110`).
    Ordering: Little-Endian (LSB is index 0).
  ||

  bit_view: {
    grid-columns: 8
    b7: "1"; b6: "1"; b5: "1"; b4: "1"
    b3: "1"; b2: "1"; b1: "1"
    b0: "**0**" {
      style: {
        fill: "#F8CECC"
        stroke: "red"
        font-color: red
        bold: true
      }
    }
  }
  
  calc: ||md
    **Data Index Calculation:**
    `data_idx = (byte_idx << 3) | bit_idx`
    `data_idx = (1 * 8) + 0 = 8`
  ||
}

Step 3: "Disk Address Translation" {
  explanation: ||md
    ### 3. Block Address Translation
    Map the bitmap index to the physical disk block offset.
    `LBA = Region_Start + Index`
  ||

  translation_map: {
    idx: "data_idx: 8" {
      style.fill: "#DAE8FC" # Blue (Data)
    }
    formula: "LBA = s_data_region_start + 8" {
      style.stroke: "#FF8C00" # Orange (Pointer/Logic)
    }
    res: "Result: Block 1067" {
      style: {
        fill: "#FFF2CC"
        stroke: "#D6B656"
        bold: true
      }
    }
    
    idx -> formula -> res
  }
}

Step 4: "Bit Manipulation Primitives" {
  explanation: ||md
    ### 4. Bitwise RMW
    Update bitmap on disk via Read-Modify-Write.
  ||

  ops: {
    grid-columns: 2
    set: "bitmap_set(8)" {
      sub: ||md
        `mask = 1 << (8 % 8)`
        `bitmap[1] |= mask`
        `0xFE -> 0xFF`
      ||
      style.fill: "#DAE8FC" # Blue (Data)
    }
    clear: "bitmap_clear(8)" {
      sub: ||md
        `mask = ~(1 << (8 % 8))`
        `bitmap[1] &= mask`
        `0xFF -> 0xFE`
      ||
      style.fill: "#F5F5F5" # Gray (Padding/Neutral)
    }
  }
}

Step 1 -> Step 2 -> Step 3 -> Step 4