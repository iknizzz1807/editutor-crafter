shape: sequence_diagram

NodeA: Node A {
  style.fill: "#1a1a2e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}

NodeB: Node B {
  style.fill: "#1a1a2e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}

NodeC: Node C {
  style.fill: "#1a1a2e"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}

NodeA -> NodeA: Select random peer (NodeB)
NodeA -> NodeB: PUSH(digest, updates)
NodeB -> NodeB: Process updates\nMerge with local state
NodeB -> NodeA: ACK + local digest
NodeA -> NodeA: Compare digests\nIdentify gaps
NodeA -> NodeB: PULL_REQUEST(missing_keys)
NodeB -> NodeA: PULL_RESPONSE(requested_data)
NodeA -> NodeA: Apply missing data\nResolve conflicts
NodeB -> NodeB: Start own gossip round\nSelect random peer (NodeC)
NodeB -> NodeC: PUSH(digest, updates)
NodeC -> NodeC: Process updates\nMerge with local state
NodeC -> NodeB: ACK + local digest
NodeB -> NodeB: Compare digests\nIdentify gaps
NodeB -> NodeC: PULL_REQUEST(missing_keys)
NodeC -> NodeB: PULL_RESPONSE(requested_data)
NodeC -> NodeC: Start anti-entropy\nSelect peer (NodeA)
NodeC -> NodeA: ANTI_ENTROPY_REQUEST(full_digest)
NodeA -> NodeC: ANTI_ENTROPY_RESPONSE(state_diff)
NodeC -> NodeC: Reconcile state\nEnsure consistency