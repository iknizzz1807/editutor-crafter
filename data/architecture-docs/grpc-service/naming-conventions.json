{
  "types": {
    "UnaryRequest": "fields: id string, data string, metadata map",
    "UnaryResponse": "fields: id string, result string, timestamp int64, status Status",
    "StreamRequest": "fields: stream_id string, payload bytes, sequence int32",
    "Service": "fields: activeStreams map, mutex",
    "StreamResponse": "fields: stream_id string, payload bytes, sequence int32, status Status",
    "Status": "enum: STATUS_UNSPECIFIED=0, STATUS_SUCCESS=1, STATUS_PROCESSING=2, STATUS_FAILED=3, STATUS_TIMEOUT=4",
    "streamState": "fields: streamID string, startTime time, messageCount int32",
    "TokenBucket": "fields: capacity int64, tokens int64, refillRate int64, lastRefill time.Time, mutex sync.Mutex",
    "JWTValidator": "fields: publicKey *rsa.PublicKey, issuer string",
    "UserClaims": "fields: UserID string, Username string, Roles []string, Permissions []string",
    "ConnectionPool": "fields: target string, connections []*grpc.ClientConn, nextIndex int, mutex sync.RWMutex, keepalive keepalive.ClientParameters",
    "RetryPolicy": "fields: MaxAttempts int, BaseDelay time.Duration, MaxDelay time.Duration, BackoffMultiplier float64, RetryableStatusCodes map[codes.Code]bool",
    "Client": "fields: connectionPool *ConnectionPool, retryPolicy *RetryPolicy, defaultTimeout time.Duration, serviceClient pb.ServiceClient",
    "StreamClient": "interface: Send(*pb.StreamRequest) error, Receive() (*pb.StreamResponse, error), Close() error",
    "StatusBuilder": "fields: code codes.Code, message string, details []*anypb.Any",
    "CircuitBreaker": "fields: state CircuitState, failureCount int, successCount int, lastFailureTime time.Time, mutex sync.RWMutex",
    "TestServer": "fields: Server *grpc.Server, Listener *bufconn.Listener, Service *service.Service, ClientConn *grpc.ClientConn, cleanup []func() error",
    "MockServerStream": "fields: sentMessages []*pb.StreamResponse, sendError error, contextValue context.Context, mu sync.RWMutex",
    "MockClientStream": "fields: receivedMessages []*pb.StreamRequest, receiveIndex int, receiveError error, mu sync.RWMutex",
    "DiagnosticInterceptor": "fields: logger *slog.Logger",
    "ResourceMonitor": "system resource monitoring",
    "HealthChecker": "fields: server *health.Server, dependencies map[string]DependencyChecker, mutex sync.RWMutex, checkInterval time.Duration, failureThreshold int, recoveryThreshold int, dependencyState map[string]*DependencyState, overallHealth grpc_health_v1.HealthCheckResponse_ServingStatus",
    "DependencyState": "fields: consecutiveFailures int, consecutiveSuccesses int, lastCheck time.Time, lastError error, isHealthy bool",
    "consulResolver": "fields: target resolver.Target, cc resolver.ClientConn, consulClient *ConsulClient, serviceName string, lastIndex uint64, ctx context.Context, cancel context.CancelFunc, wg sync.WaitGroup",
    "ConsulClient": "fields: address string, datacenter string",
    "WeightedRoundRobinPicker": "fields: server weights, health states, round-robin position",
    "AutoScaler": "fields: metrics collection, scaling thresholds, deployment client",
    "ScalingDecision": "fields: target instance count, rationale",
    "ConnectionMonitor": "fields: conn *grpc.ClientConn, logger *slog.Logger",
    "BackpressureHandler": "fields: windowSize int32, pendingAcks int32, maxBufferSize int, buffer []*pb.StreamResponse, mutex sync.Mutex"
  },
  "methods": {
    "UnaryMethod(context.Context, *pb.UnaryRequest) (*pb.UnaryResponse, error)": "handles simple request-response RPC",
    "ServerStreamingMethod(*pb.StreamRequest, stream) error": "sends multiple responses for single request",
    "BidirectionalStreamingMethod(stream) error": "handles concurrent send and receive operations",
    "NewService() *Service": "constructor for service implementation",
    "ClientStreamingMethod(stream) error": "receives multiple messages and returns single response",
    "UnaryMethod(UnaryRequest) returns (UnaryResponse)": "handles simple request-response RPC",
    "ServerStreamingMethod(StreamRequest) returns (stream StreamResponse)": "sends multiple responses for single request",
    "ClientStreamingMethod(stream StreamRequest) returns (StreamResponse)": "receives multiple messages and returns single response",
    "BidirectionalStreamingMethod(stream StreamRequest) returns (stream StreamResponse)": "handles concurrent send and receive operations",
    "ValidateUnaryRequest(*pb.UnaryRequest) error": "validates unary request fields",
    "ValidateStreamRequest(*pb.StreamRequest) error": "validates streaming request fields",
    "UnaryAuthInterceptor(*JWTValidator) grpc.UnaryServerInterceptor": "validates JWT tokens from gRPC metadata",
    "UnaryRateLimitInterceptor(map[string]*TokenBucket, int64, int64) grpc.UnaryServerInterceptor": "enforces per-user rate limits using token buckets",
    "UnaryLoggingInterceptor(*slog.Logger) grpc.UnaryServerInterceptor": "logs RPC calls with structured data",
    "UnaryRecoveryInterceptor(*slog.Logger) grpc.UnaryServerInterceptor": "recovers from panics and converts to gRPC errors",
    "TryConsume(int64) bool": "attempts to consume tokens from bucket",
    "ValidateToken(string) (*UserClaims, error)": "parses and validates JWT token",
    "NewConnectionPool(string, int) *ConnectionPool": "creates connection pool with target and size",
    "GetConnection(context.Context) (*grpc.ClientConn, error)": "returns healthy connection using round-robin",
    "Close() error": "closes all pooled connections",
    "DefaultRetryPolicy() *RetryPolicy": "returns sensible retry defaults",
    "CalculateBackoff(int) time.Duration": "computes exponential backoff with jitter",
    "IsRetryable(error) bool": "determines if gRPC error should trigger retry",
    "NewClient(string, ...ClientOption) (*Client, error)": "creates robust gRPC client",
    "UnaryCall(context.Context, string, *pb.UnaryRequest) (*pb.UnaryResponse, error)": "executes unary RPC with retries",
    "ServerStreamingCall(context.Context, *pb.StreamRequest) (<-chan *pb.StreamResponse, <-chan error)": "handles server streaming with channels",
    "BidirectionalStreamingCall(context.Context) (StreamClient, error)": "manages bidirectional streaming",
    "RetryableCall(context.Context, func() error) error": "executes operation with intelligent retry logic",
    "NewStatusBuilder(codes.Code, string) *StatusBuilder": "creates builder for gRPC status with details",
    "WithDetail(protoreflect.ProtoMessage) *StatusBuilder": "adds structured error detail",
    "Error() error": "builds final gRPC status error",
    "NewCircuitBreaker(int, time.Duration) *CircuitBreaker": "creates circuit breaker with thresholds",
    "Call(func() error) error": "executes function with circuit breaker protection",
    "allowRequest() bool": "checks if circuit allows request",
    "recordResult(error)": "updates circuit state based on result",
    "NewTestServer(t *testing.T, opts ...TestServerOption) *TestServer": "creates fully configured test server with interceptors",
    "NewMockServerStream(ctx context.Context) *MockServerStream": "creates mock server stream for testing",
    "Send(response *pb.StreamResponse) error": "sends response through mock stream",
    "GetSentMessages() []*pb.StreamResponse": "returns all messages sent through stream",
    "SetSendError(err error)": "configures stream to return error on Send",
    "NewMockClientStream(messages []*pb.StreamRequest) *MockClientStream": "creates mock client stream with predefined messages",
    "Recv() (*pb.StreamRequest, error)": "receives next message from client stream",
    "Close()": "cleans up test server resources",
    "NewResourceMonitor(logger, interval) *ResourceMonitor": "creates resource usage monitor",
    "logResourceUsage()": "collects and logs current resource consumption",
    "NewHealthChecker() *HealthChecker": "creates production-ready health checker",
    "RegisterDependency(DependencyChecker)": "adds dependency to health monitoring",
    "Start(context.Context)": "begins continuous health monitoring",
    "GetServer() *health.Server": "returns gRPC health server for registration",
    "NewConsulResolver(resolver.Target, resolver.ClientConn, ConsulResolverOptions) (resolver.Resolver, error)": "creates Consul-based service discovery resolver",
    "watchService()": "continuously monitors Consul for service instance changes",
    "updateClientConn([]ServiceInstance)": "sends updated server list to gRPC client connection",
    "Pick(balancer.PickInfo) (balancer.PickResult, error)": "selects best available server for next RPC call",
    "UpdateServerList([]ServerInfo)": "handles dynamic server membership changes",
    "EvaluateScaling(context.Context) (*ScalingDecision, error)": "analyzes current metrics and determines scaling action",
    "ExecuteScaling(context.Context, *ScalingDecision) error": "performs actual scaling operation with coordination",
    "TrySend(*pb.StreamResponse) error": "attempts to send message respecting flow control",
    "WatchConnectionState(context.Context)": "monitors gRPC channel health changes",
    "UnaryInterceptor() grpc.UnaryServerInterceptor": "logs detailed request/response information"
  },
  "constants": {
    "codes.Unimplemented": "RPC method not implemented",
    "codes.InvalidArgument": "malformed request data",
    "codes.Unauthenticated": "missing or invalid authentication",
    "codes.ResourceExhausted": "rate limited or server overloaded",
    "codes.Internal": "server-side programming errors",
    "STATUS_UNSPECIFIED": "default enum value 0",
    "STATUS_SUCCESS": "operation completed successfully",
    "STATUS_PROCESSING": "operation in progress",
    "STATUS_FAILED": "operation failed",
    "STATUS_TIMEOUT": "operation exceeded time limits",
    "codes.Unavailable": "temporary service unavailability",
    "codes.Aborted": "operation aborted due to concurrency conflict",
    "codes.DeadlineExceeded": "operation exceeded configured timeout",
    "codes.PermissionDenied": "valid auth but insufficient permissions",
    "codes.NotFound": "requested resource doesn't exist",
    "codes.AlreadyExists": "creation failed, resource already exists",
    "codes.FailedPrecondition": "operation valid but system state prevents execution",
    "CircuitClosed": "normal operation state",
    "CircuitOpen": "failing fast state",
    "CircuitHalfOpen": "testing recovery state",
    "codes.Cancelled": "operation cancelled by client",
    "grpc_health_v1.HealthCheckResponse_SERVING": "healthy service status",
    "grpc_health_v1.HealthCheckResponse_NOT_SERVING": "unhealthy service status",
    "grpc_health_v1.HealthCheckResponse_SERVICE_UNKNOWN": "unknown health status"
  },
  "terms": {
    "backpressure": "condition when message producer generates data faster than consumer can process",
    "flow control": "mechanism to prevent overwhelming slow consumers",
    "bidirectional streaming": "gRPC pattern allowing concurrent send and receive operations",
    "graceful shutdown": "orderly service termination completing in-flight requests",
    "interceptor": "middleware component that wraps RPC calls for cross-cutting concerns",
    "Protocol Buffers": "language-neutral data serialization format optimized for speed and size",
    "stream lifecycle": "sequence of states from establishment through termination of streaming connection",
    "forward compatibility": "old clients can communicate with new servers",
    "backward compatibility": "new clients can communicate with old servers",
    "wire format": "binary representation of messages transmitted over network",
    "field numbers": "unique integer identifiers for fields in proto messages",
    "context cancellation": "mechanism for detecting client disconnection and timeouts",
    "token bucket algorithm": "rate limiting algorithm using bucket metaphor for quota management",
    "context propagation": "passing authenticated user information through request context",
    "panic recovery": "catching Go panics and converting to proper error responses",
    "middleware pattern": "design pattern for composable request/response processing",
    "connection pooling": "reusing gRPC connections across multiple requests for efficiency",
    "exponential backoff": "retry delay algorithm that doubles wait time after each failure",
    "jitter": "random variation in timing to prevent thundering herd",
    "idempotency": "property that operation produces same result when executed multiple times",
    "circuit breaker": "pattern that stops retries when failure rates exceed thresholds",
    "keepalive": "transport-level mechanism to maintain connections",
    "deadline propagation": "transmitting timeout information from client to server",
    "retry budget": "limit on retry attempts to prevent retry storms",
    "error locality": "principle that errors should be handled at the layer best equipped to make recovery decisions",
    "partial failure": "scenario where some operations succeed while others fail in a batch",
    "retry storm": "condition where aggressive retries overwhelm failing servers",
    "thundering herd": "synchronized retry attempts from multiple clients",
    "goroutine leaks": "goroutines that don't terminate properly",
    "production readiness": "operational capabilities needed for production deployment",
    "service discovery": "mechanism for dynamically finding service instances",
    "load balancing": "traffic distribution across multiple service instances",
    "health checks": "monitoring endpoints that report service availability",
    "reflection API": "gRPC capability for runtime service introspection",
    "administrative endpoints": "management interfaces for operational control",
    "client-side load balancing": "load distribution logic implemented in gRPC client",
    "service mesh": "infrastructure layer providing distributed systems capabilities",
    "horizontal scaling": "adding more service instances to handle increased load",
    "connection draining": "graceful termination of existing connections during scaling",
    "auto-scaling": "automatic adjustment of service capacity based on metrics",
    "dependency health": "monitoring of external service availability",
    "observability": "comprehensive monitoring and debugging capabilities",
    "channel": "client-side abstraction representing connection to gRPC server",
    "stub": "client-side proxy object providing strongly-typed methods for calling server RPCs",
    "message ordering": "guarantee that messages arrive in transmission order",
    "heartbeat": "periodic messages to detect connection failures"
  }
}