direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- Title and Metadata ---
title: {
  shape: text
  label: "SHA-256 Padding: The 56-Byte Boundary Case (Double Block Spill)"
  style: {
    font-size: 24
    bold: true
  }
}

# --- Data Walk: Step-by-Step Evolution ---

input_layer: {
  label: "STEP 1: RAW INPUT (msg_len = 56 bytes)"
  direction: down
  
  msg_struct: {
    shape: sql_table
    label: "struct Message (input.bin)"
    
    row_0: "0x00 | uint8_t | 0x41 ('A')"
    row_1: "0x01 | uint8_t | 0x41 ('A')"
    row_dots: "... | ... | ..."
    row_55: "0x37 | uint8_t | 0x41 ('A')"
    label_bottom: "Total: 56 bytes (448 bits)"
  }
}

marker_layer: {
  label: "STEP 2: APPEND MARKER (0x80)"
  direction: down
  
  marker_check: {
    shape: sql_table
    label: "Internal Buffer (sha256.c)"
    
    row_msg: "0x00 - 0x37 | uint8_t[56] | msg_content"
    row_marker: "0x38        | uint8_t    | 0x80 (0b10000000)"
    label_bottom: "Buffer: 57 / 64 bytes"
  }
  
  logic_note: |md
    c
    // Boundary Logic Evaluation:
    // Required space for length: 8 bytes
    // Current offset: 57 bytes
    // Remaining in block: 64 - 57 = 7 bytes
    // (7 < 8) => Cannot fit length field.
    // ACTION: Fill 7 bytes with 0x00, compress Block 0, start Block 1.
    
  |

  annot_1: |md
    ### Implementation Logic
    **Rule:** `L + 1 + k ≡ 448 (mod 512)`
    
    For `L = 448 bits`:
    1. `448 + 1 (marker) = 449`
    2. `449 + k ≡ 448 (mod 512)`
    3. `k = 511 bits` of zero padding.
  |
}

result_layer: {
  label: "STEP 3: PADDED OUTPUT (128 bytes)"
  direction: down
  
  block_0: {
    shape: sql_table
    label: "BLOCK 0 (SHA256_BLOCK_SIZE=64)"
    
    row1: "0x00 - 0x37 | uint8_t[56] | Original Message"
    row2: "0x38        | uint8_t     | 0x80 (0b10000000)"
    row3: "0x39 - 0x3F | uint8_t[7]  | 0x00 (Zero Padding)"
    label_bottom: "64 Bytes | State: Partially Padded"
  }
  
  spacer: {
    shape: text
    label: "== [ BOUNDARY SPILL ] =="
    style: {
        font-color: red
        italic: true
        bold: true
    }
  }
  
  block_1: {
    shape: sql_table
    label: "BLOCK 1 (SHA256_BLOCK_SIZE=64)"
    
    row1: "0x00 - 0x37 | uint8_t[56] | 0x00 (Additional Padding)"
    row2: "0x38 - 0x3F | uint64_t    | 0x00000000000001C0"
    label_bottom: "64 Bytes | Length L=448 bits (Big-Endian)"
  }

  annot_2: |md
    ### Implementation Detail (sha256.c)
    c
    void sha256_finalize(SHA256_CTX *ctx, uint8_t hash[]) {
        uint64_t bit_len = ctx->count << 3; // 448
        sha256_update(ctx, (uint8_t[]){0x80}, 1);
        
        if (ctx->buf_len > 56) {
            // Path for boundary spill
            while (ctx->buf_len < 64) ctx->buf[ctx->buf_len++] = 0x00;
            sha256_compress(ctx, ctx->buf);
            memset(ctx->buf, 0, 56);
        }
        // ... append bit_len and final compress
    }
    
  |
}

# --- Connections and Data Flow ---

input_layer -> marker_layer: "uint8_t[56] | msg_len=448 bits" {
  style.stroke: "#2196F3"
}

marker_layer -> result_layer: "Spill triggered | k=511 zeros" {
  style: {
    stroke: "#F44336"
    stroke-width: 2
  }
}

# --- Styling and Highlights ---

"marker_layer.marker_check.row_marker": {
  style.fill: "#E9B5DB"
}

"result_layer.block_0.row2": {
  style.fill: "#E9B5DB"
}

"result_layer.block_1.row2": {
  style: {
    fill: "#C6E00B"
    bold: true
  }
}

# Explicit container styling
result_layer.block_0.style.fill: "#FFFFFF"
result_layer.block_1.style.fill: "#FFFFFF"