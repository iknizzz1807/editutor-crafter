direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# L2: Data Walk - Empty Input Padding Trace (padding.c)
# Focus: Byte-level memory layout for msg_len = 0

input_source: {
  shape: code
  label: "char* msg = \"\" (sha256.h)"
  value: |md
    c
    // Initial State
    const char* msg = ""; 
    uint64_t bit_len = 0; // 0 * 8
    uint8_t* buffer;      // Target 512-bit block
    
  |
}

padding_process: {
  direction: down
  label: "sha256_pad(SHA256_Context* ctx)"
  
  step_1: "1. Append Separator" {
    tooltip: "Write 0x80 (10000000b) at ctx->buffer[0]"
    style.fill: "#E4DBFE"
  }
  
  step_2: "2. Zero Fill [1..55]" {
    tooltip: "memset(ctx->buffer + 1, 0, 55)"
  }
  
  step_3: "3. Append Length [56..63]" {
    tooltip: "Write bit_len as Big-Endian uint64"
    style.fill: "#C7F1FF"
  }
  
  step_1 -> step_2 -> step_3
}

padded_memory: {
  direction: down
  label: "MEMORY LAYOUT: 512-bit Block (0..63 bytes)"
  
  block_0: {
    shape: sql_table
    label: "struct SHA256_Block (types.h)"
    
    row_0: "0x00 | 0x80 | SEPARATOR ('1' bit + 7 zeros)" {
      style.fill: "#E4DBFE"
    }
    
    row_1: "0x01 | 0x00 | ZERO PADDING [START]"
    row_2: "0x02 | 0x00 | ZERO PADDING"
    row_dots: "...  | .... | ...."
    row_55: "0x37 | 0x00 | ZERO PADDING [END]" {
      style.stroke-dash: 3
    }
    
    row_56: "0x38 | 0x00 | LENGTH_MSB [0]" {
      style.fill: "#C7F1FF"
    }
    row_57_62: "...  | 0x00 | LENGTH_BYTES [1..6]" {
      style.fill: "#C7F1FF"
    }
    row_63: "0x3F | 0x00 | LENGTH_LSB [7]" {
      style.fill: "#C7F1FF"
    }
    
    label_bottom: "Total: 64 Bytes (1 Cache Line) | bit_len = 0"
  }
}

# Data Flow Annotations
input_source -> padding_process: "uint8_t* | size: 0"

padding_process -> padded_memory.block_0: "void* | 64 bytes | transform" {
  style: {
    stroke-width: 2
    animated: true
  }
}

# Explanatory Notes
notes: {
  near: bottom-center
  shape: text
  label: |md
    ### Implementation Invariants:
    1. **Block Alignment**: Even with 0-byte input, the algorithm MUST produce exactly one 512-bit (64-byte) block.
    2. **Separator Necessity**: The `0x80` byte ensures that an empty message `""` results in a different padding pattern than a message containing a null byte `"\0"`.
    3. **Endianness**: The 64-bit length field at the end is stored in **Big-Endian** format per FIPS 180-4.
  |
}

# Precision Pointers
padded_memory.block_0.row_0 -> notes: "Separator Boundary" {
  style.stroke: purple
}
padded_memory.block_0.row_63 -> notes: "Length Suffix" {
  style.stroke: blue
}