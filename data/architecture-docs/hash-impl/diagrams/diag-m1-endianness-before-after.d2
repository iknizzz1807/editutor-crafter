direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# -----------------------------------------------------------------------------
# L1: ENDIANNESS CONVERSION LOGIC
# -----------------------------------------------------------------------------
endianness_logic: {
  direction: down
  label: "L1: 32-bit Word Extraction (sha256_schedule.c)"
  
  flow: {
    direction: right

    host_memory: {
      shape: sql_table
      label: "Host RAM (Little-Endian / x86)"
      
      row0: "0x00 | uint8_t | 0x64 ('d') [LSB]"
      row1: "0x01 | uint8_t | 0x63 ('c')"
      row2: "0x02 | uint8_t | 0x62 ('b')"
      row3: "0x03 | uint8_t | 0x61 ('a') [MSB]"
      
      label_bottom: "Buffer: char buf[4] = \"abcd\""
    }

    extraction_logic: {
      shape: rectangle
      label: |'md
        ### uint32_t read_uint32_be(const uint8_t *p)
        c
        uint32_t read_uint32_be(const uint8_t *p) {
            return ((uint32_t)p[0] << 24) |
                   ((uint32_t)p[1] << 16) |
                   ((uint32_t)p[2] <<  8) |
                   ((uint32_t)p[3] <<  0);
        }
        
      '|
    }

    sha256_register: {
      shape: sql_table
      label: "CPU Register (Big-Endian / SHA-256 View)"
      
      row0: "Bits 31-24 | 0x61 | 'a' [MSB]"
      row1: "Bits 23-16 | 0x62 | 'b'"
      row2: "Bits 15-08 | 0x63 | 'c'"
      row3: "Bits 07-00 | 0x64 | 'd' [LSB]"
      
      label_bottom: "Register Value: 0x61626364"
    }

    host_memory -> extraction_logic: "uint8_t* | 4 bytes | [0x64, 0x63, 0x62, 0x61]"
    extraction_logic -> sha256_register: "uint32_t | 4 bytes | 0x61626364"
  }
}

# -----------------------------------------------------------------------------
# L2: LENGTH ENCODING STRATEGY
# -----------------------------------------------------------------------------
length_encoding: {
  direction: down
  label: "L2: 64-bit Length Field Encoding (sha256_final.c)"

  flow: {
    direction: right

    message_context: {
      shape: class
      label: "struct SHA256_CTX (sha256.h)"
      bit_len: uint64_t
      "buffer[64]": uint8_t
      
      label_bottom: "Current State: bit_len = 24 (0x18)"
    }

    write_logic: {
      shape: rectangle
      label: |'md
        ### void write_uint64_be(uint8_t *p, uint64_t v)
        c
        void write_uint64_be(uint8_t *p, uint64_t v) {
            p[0] = (uint8_t)(v >> 56);
            p[1] = (uint8_t)(v >> 48);
            p[2] = (uint8_t)(v >> 40);
            p[3] = (uint8_t)(v >> 32);
            p[4] = (uint8_t)(v >> 24);
            p[5] = (uint8_t)(v >> 16);
            p[6] = (uint8_t)(v >> 8);
            p[7] = (uint8_t)(v >> 0);
        }
        
      '|
    }

    padded_block_tail: {
      shape: sql_table
      label: "Block Tail (Offset 56-63)"
      
      row0: "0x38 | 0x00 | MSB"
      row1: "0x39 | 0x00 | ..."
      row2: "0x3A | 0x00 | ..."
      row3: "0x3B | 0x00 | ..."
      row4: "0x3C | 0x00 | ..."
      row5: "0x3D | 0x00 | ..."
      row6: "0x3E | 0x00 | 0x00"
      row7: "0x3F | 0x18 | 24 bits (LSB)"
      
      label_bottom: "Total: 64-bit Big-Endian Integer"
    }

    message_context -> write_logic: "uint64_t | 8 bytes | v = 24"
    write_logic -> padded_block_tail: "uint8_t[8] | 64 bits | MSB First"
  }
}

# -----------------------------------------------------------------------------
# GLOBAL RELATIONSHIPS & STYLING
# -----------------------------------------------------------------------------
endianness_logic -> length_encoding: "consistent byte ordering strategy" {
  style: {
    stroke-dash: 5
    stroke: gray
  }
}

# Hot Path labels
endianness_logic.flow.extraction_logic.style.stroke: blue
length_encoding.flow.write_logic.style.stroke: green

# Semantic Highlights via classes
classes: {
  highlight_msb: {
    style.fill: "#C7F1FF"
  }
  highlight_lsb: {
    style.fill: "#ACE1AF"
  }
}

# Note: Styling individual sql_table rows directly via path is not supported in D2.
# Using legend for implementation clarity.
legend: {
  near: bottom-right
  msb_color: "Blue = MSB Data Path" {
    shape: text
    style.font-color: blue
  }
  lsb_color: "Green = LSB/Length Field" {
    shape: text
    style.font-color: green
  }
}