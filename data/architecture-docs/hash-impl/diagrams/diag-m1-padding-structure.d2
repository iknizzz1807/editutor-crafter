direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# 1. LEGEND / IMPLEMENTATION METADATA
legend: {
  shape: sql_table
  near: top-left
  label: "SHA-256 Padding Color Semantics"
  
  row0: "Color | Component | Description"
  row1: "0xD0E7FF | Message   | Raw Input Bytes"
  row2: "0xE4DBFE | 0x80      | Padding Marker (10000000)"
  row3: "0xF2F2F2 | 0x00      | Zero bit alignment"
  row4: "0xD5F5E3 | Length    | 64-bit Bit Count (Big Endian)"
  
  row1.style.fill: "#D0E7FF"
  row2.style.fill: "#E4DBFE"
  row3.style.fill: "#F2F2F2"
  row4.style.fill: "#D5F5E3"
}

# 2. DATA STRUCTURES (L1 Detail)
case_abc: {
  label: "Case 1: 'abc' (3 bytes / 24 bits)"
  direction: down
  
  block0: {
    shape: sql_table
    label: "Block 0 (sha256_pad.c)"
    
    header: "Byte Offset | Hex Value | Description"
    row1: "0x00 - 0x02 | 0x61 62 63 | msg_data"
    row2: "0x03        | 0x80       | pad_marker"
    row3: "0x04 - 0x37 | 0x00...00  | zero_padding (52 bytes)"
    row4: "0x38 - 0x3F | 0x00...18  | bit_length (uint64_t)"
    
    row1.style.fill: "#D0E7FF"
    row2.style.fill: "#E4DBFE"
    row3.style.fill: "#F2F2F2"
    row4.style.fill: "#D5F5E3"
    
    label_bottom: "Buffer: uint8_t[64] | Total: 512 bits"
  }
}

case_55b: {
  label: "Case 2: 55-byte message (Boundary Fit)"
  direction: down
  
  block0: {
    shape: sql_table
    label: "Block 0 (sha256_pad.c)"
    
    header: "Byte Offset | Hex Value | Description"
    row1: "0x00 - 0x36 | [msg...]   | msg_data (55 bytes)"
    row2: "0x37        | 0x80       | pad_marker"
    row3: "0x38 - 0x3F | 0x00...01B8| bit_length (440 bits)"
    
    row1.style.fill: "#D0E7FF"
    row2.style.fill: "#E4DBFE"
    row3.style.fill: "#D5F5E3"
    
    label_bottom: "Note: Marker fits exactly at k=0"
  }
}

case_56b: {
  label: "Case 3: 56-byte message (Block Spill)"
  direction: down
  
  block0: {
    shape: sql_table
    label: "Block 0 (sha256_pad.c)"
    
    header: "Byte Offset | Hex Value | Description"
    row1: "0x00 - 0x37 | [msg...]   | msg_data (56 bytes)"
    row2: "0x38        | 0x80       | pad_marker"
    row3: "0x39 - 0x3F | 0x00...00  | zero_padding (7 bytes)"
    
    row1.style.fill: "#D0E7FF"
    row2.style.fill: "#E4DBFE"
    row3.style.fill: "#F2F2F2"
    
    label_bottom: "Status: Full (Length spills to Block 1)"
  }
  
  block1: {
    shape: sql_table
    label: "Block 1 (sha256_pad.c)"
    
    header: "Byte Offset | Hex Value | Description"
    row1: "0x40 - 0x77 | 0x00...00  | zero_padding (56 bytes)"
    row2: "0x78 - 0x7F | 0x00...01C0| bit_length (448 bits)"
    
    row1.style.fill: "#F2F2F2"
    row2.style.fill: "#D5F5E3"
    
    label_bottom: "Final Padding Block"
  }
  
  block0 -> block1: "Next chunk | 512-bit overflow"
}

# 3. LOGIC TRANSITIONS
case_abc -> case_55b: "Constraint: (L + 1 + k) % 512 == 448"
case_55b -> case_56b: "Trigger: (L % 64) > 55"

# 4. GLOBAL STYLING
***.style.font: mono
(*** -> ***)[*]: {
  style: {
    stroke: "#444444"
    stroke-dash: 2
    font-size: 12
  }
}

# Annotation for Engineers
implementation_note: |md
  c
  // SHA-256 Padding Implementation Check:
  // 1. Append bit '1' (0x80 byte)
  // 2. Append '0' bits until length â‰¡ 448 (mod 512)
  // 3. Append original length as 64-bit BE integer
  void sha256_pad(uint8_t *data, uint64_t len);
  
| {
  near: bottom-right
}