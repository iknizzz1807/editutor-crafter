direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- GLOBAL CLASSES & STYLES ---
classes: {
  high_segment: {
    style: {
      fill: "#C7F1FF"
      stroke: "#007799"
    }
  }
  low_segment: {
    style: {
      fill: "#E4DBFE"
      stroke: "#5533AA"
    }
  }
  zero_fill: {
    style: {
      fill: "#B2B2B2"
      font-color: white
      bold: true
    }
  }
  code_node: {
    style: {
      font-size: 14
    }
  }
}

# --- 1. INPUT LAYER (DATA SOURCE) ---
input_layer: {
  direction: down
  label: "INPUT LAYER: 32-bit Primitive (word.h)"
  
  x_struct: {
    shape: sql_table
    label: "uint32_t x (Initial State)"
    
    row1: "0x00 | MSB [31:7] | High Bits Segment (25 bits)" {class: high_segment}
    row2: "0x04 | LSB [6:0]  | Low Bits Segment (7 bits)" {class: low_segment}
    label_bottom: "Address: Register R0 | Size: 4 Bytes (32-bit)"
  }

  code_defs: |md
    c
    // Value: 0x80636261
    // Bin: [10000000 01100011 01100010 0][1100001]
    uint32_t x = 0x80636261;
    
  |
  code_defs.class: code_node
}

# --- 2. LOGIC LAYER (TRANSFORMATION) ---
logic_layer: {
  direction: down
  label: "TRANSFORMATION LAYER (alu.c)"

  rotr_logic: {
    label: "OP: ROTR(x, 7)"
    direction: right
    
    math: |md
      c
      // Circular Right Rotation
      // (x >> 7) | (x << (32 - 7))
      #define ROTR(x, n) (((x) >> (n)) | ((x) << (32-(n))))
      
    |
    math.class: code_node
    
    desc: {
      label: "N-Bit Wrap-around: Tail bits become Head bits."
      shape: text
      style.italic: true
    }
  }

  shr_logic: {
    label: "OP: SHR(x, 3)"
    direction: right
    
    math: |md
      c
      // Logical Right Shift
      // (x >> 3)
      uint32_t result = x >> 3;
      
    |
    math.class: code_node
    
    desc: {
      label: "Linear Discard: Head filled with 0x0."
      shape: text
      style.font-color: red
    }
  }
}

# --- 3. OUTPUT LAYER (FINAL STATE) ---
output_layer: {
  direction: down
  label: "OUTPUT LAYER: Resulting Registers"

  rotr_result: {
    shape: sql_table
    label: "Register R1 (ROTR Result)"
    
    row1: "0x00 | [31:25] | Low Segment (Wrapped)" {class: low_segment}
    row2: "0x04 | [24:0]  | High Segment (Shifted)" {class: high_segment}
    label_bottom: "Total: 32 bits | Entropy: Preserved"
  }

  shr_result: {
    shape: sql_table
    label: "Register R2 (SHR Result)"
    
    row1: "0x00 | [31:29] | 0x000 (Zero Fill)" {class: zero_fill}
    row2: "0x04 | [28:0]  | High Segment [31:3]" {class: high_segment}
    label_bottom: "Total: 32 bits | Entropy: -3 bits"
  }
}

# --- DATA FLOW & ANNOTATIONS ---

# Input to ROTR (Circular Flow)
input_layer.x_struct.row2 -> output_layer.rotr_result.row1: "Wraparound | 7 bits | {val: 0x61}" {
  style: {
    stroke: "#5533AA"
    stroke-width: 3
    animated: true
  }
}
input_layer.x_struct.row1 -> output_layer.rotr_result.row2: "Right Shift | 25 bits" {
  style: {
    stroke: "#007799"
    stroke-width: 2
  }
}

# Input to SHR (Destructive Flow)
input_layer.x_struct.row1 -> output_layer.shr_result.row2: "Truncated Shift" {
  style: {
    stroke: "#007799"
    stroke-width: 2
    stroke-dash: 3
  }
}

# Structural Flow
input_layer -> logic_layer: "uint32_t | 4 Bytes"
logic_layer -> output_layer: "Commit to Register"

# Warning Annotation
warning: {
  near: logic_layer
  shape: sticky_note
  label: |md
    ### Ïƒ0 (sigma0) Implementation
    `sigma0(x) = ROTR(x,7) ^ ROTR(x,18) ^ SHR(x,3)`
    
    **Implementation Note:**
    In C/C++, `x >> 7` is a **Shift**, not a **Rotate**.
    Use explicitly defined macros for circular operations.
  |
  style: {
    fill: "#FFCCCC"
    stroke: red
    stroke-width: 2
  }
}