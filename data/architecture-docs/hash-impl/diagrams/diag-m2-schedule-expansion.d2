direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SHA-256 Message Schedule Expansion (L1/L2 Detail)
# File: schedule.c

# LAYER 1: Input Data Source
input_layer: {
  label: "INPUT BLOCK (512-bit)"
  direction: down

  raw_block: {
    shape: sql_table
    label: "struct SHA256_Block (sha256.h)"
    
    row0: "0x00 | uint8_t[4] | bytes[0..3]"
    row1: "0x04 | uint8_t[4] | bytes[4..7]"
    row_dots: "... | ... | ..."
    row15: "0x3C | uint8_t[4] | bytes[60..63]"
    
    label_bottom: "Total: 64 bytes"
  }
}

# LAYER 2: Parsing & Initial Buffer
parsing_layer: {
  label: "INITIAL WORDS (W[0..15])"
  direction: down

  initial_words: {
    shape: sql_table
    label: "uint32_t W[64] (Workspace)"
    
    w0: "t=00 | 0x61626380 | W[0]"
    w1: "t=01 | 0x00000000 | W[1]"
    w_dots1: "... | ... | ..."
    w9: "t=09 | 0x00000000 | W[9]"
    w_dots2: "... | ... | ..."
    w14: "t=14 | 0x00000000 | W[14]"
    w15: "t=15 | 0x00000018 | W[15]"
    
    label_bottom: "Source: Big-Endian Load"
  }
}

# LAYER 3: Expansion Logic (Recurrence Relation)
expansion_layer: {
  label: "EXPANSION ENGINE (t=16 to 63)"
  direction: down

  logic_definition: |md
    c
    // FIPS 180-4 Section 6.2
    for (int t = 16; t < 64; t++) {
        W[t] = sigma1(W[t-2]) 
             + W[t-7] 
             + sigma0(W[t-15]) 
             + W[t-16];
    }
    
  |

  expansion_core: {
    direction: right
    
    node_sigma1: {
      label: "σ1 (sigma1)"
      tooltip: "ROTR(x,17) ^ ROTR(x,19) ^ (x >> 10)"
      style.fill: "#E4DBFE"
    }
    
    node_sigma0: {
      label: "σ0 (sigma0)"
      tooltip: "ROTR(x,7) ^ ROTR(x,18) ^ (x >> 3)"
      style.fill: "#E4DBFE"
    }

    addition_node: {
      label: "Σ (MOD 2^32)"
      shape: circle
      style.fill: "#C7F1FF"
    }
  }
}

# LAYER 4: Result Stage
result_layer: {
  label: "EXPANDED SCHEDULE"
  direction: down

  expanded_w: {
    shape: sql_table
    label: "uint32_t W[64]"
    
    w16: "t=16 | 0x61626380 | W[16]"
    w17: "t=17 | 0x000F0000 | W[17]"
    w_dots: "... | ... | ..."
    w63: "t=63 | 0xDEADBEEF | W[63]"
    
    label_bottom: "Total: 256 bytes"
  }
}

# DATA FLOW CONNECTIONS

# 1. Parsing
input_layer.raw_block -> parsing_layer.initial_words: "load_u32_be() | 4 bytes -> 1 word"

# 2. Dependency Web for W[16] (The Prototype Trace)
parsing_layer.initial_words.w14 -> expansion_layer.expansion_core.node_sigma1: "W[t-2] | 4B"
parsing_layer.initial_words.w9 -> expansion_layer.expansion_core.addition_node: "W[t-7] | 4B"
parsing_layer.initial_words.w1 -> expansion_layer.expansion_core.node_sigma0: "W[t-15] | 4B"
parsing_layer.initial_words.w0 -> expansion_layer.expansion_core.addition_node: "W[t-16] | 4B"

expansion_layer.expansion_core.node_sigma1 -> expansion_layer.expansion_core.addition_node: "uint32_t | Mixed"
expansion_layer.expansion_core.node_sigma0 -> expansion_layer.expansion_core.addition_node: "uint32_t | Mixed"

expansion_layer.expansion_core.addition_node -> result_layer.expanded_w.w16: "Final W[t] | 4B"

# 3. Chaining / Recurrence
result_layer.expanded_w.w16 -> expansion_layer.expansion_core: "Feeds next t (as t-2)" {
  style.stroke-dash: 5
  style.animated: true
}

# STYLING
expansion_layer.logic_definition.style.font: mono
result_layer.expanded_w.w16.style.stroke: green
result_layer.expanded_w.w16.style.stroke-width: 3