vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

direction: right

# =============================================================================
# BLOCK TO WORDS: BIG-ENDIAN 32-BIT PARSING (sha256_schedule.c)
# L1-COMPONENT DIAGRAM: Memory Layout and Extraction Logic
# =============================================================================

layer_input: {
  direction: down
  label: "INPUT: 512-BIT DATA BLOCK"

  block_buffer: {
    shape: sql_table
    label: "const uint8_t block[64] (sha256_impl.c)"
    
    b0: "0x00 | 0x61 | Byte 0 ('a') [MSB]"
    b1: "0x01 | 0x62 | Byte 1 ('b')"
    b2: "0x02 | 0x63 | Byte 2 ('c')"
    b3: "0x03 | 0x80 | Byte 3 (1-bit Pad) [LSB]"
    
    b4: "0x04 | 0x00 | Byte 4"
    b5: "0x05 | 0x00 | Byte 5"
    b6: "0x06 | 0x00 | Byte 6"
    b7: "0x07 | 0x00 | Byte 7"
    
    dots: "... | ... | Offset 0x08 - 0x3B"
    
    b60: "0x3C | 0x00 | Byte 60"
    b61: "0x3D | 0x00 | Byte 61"
    b62: "0x3E | 0x00 | Byte 62"
    b63: "0x3F | 0x18 | Byte 63 (Length L=24 bits)"
    
    label_bottom: "Total: 64 bytes (1 Cache Line)"
  }
}

layer_logic: {
  direction: down
  label: "BITWISE EXTRACTION (Big-Endian)"

  # Using escaped block string to handle bitwise OR characters in C code
  c_implementation: |'c
    // Assemble 4 bytes into one 32-bit word
    // uint32_t read_be(uint8_t* block, int i)
    W[i] = ((uint32_t)block[4*i + 0] << 24) |
           ((uint32_t)block[4*i + 1] << 16) |
           ((uint32_t)block[4*i + 2] <<  8) |
           ((uint32_t)block[4*i + 3] <<  0);
  '| {
    style: {
      stroke: "#f4a261"
      stroke-width: 2
    }
  }

  bit_mapping: {
    shape: sql_table
    label: "Big-Endian Register Mapping (W[0])"
    
    h1: "Bit Positions | 31 <--- 24 | 23 <--- 16 | 15 <--- 08 | 07 <--- 00"
    h2: "Source Byte  | block[0]    | block[1]    | block[2]    | block[3]"
    h3: "Shift Amount | << 24       | << 16       | << 8        | << 0"
    h4: "Significance | MSB         |             |             | LSB"
  }
}

layer_output: {
  direction: down
  label: "OUTPUT: INITIAL SCHEDULE WORDS"

  w_array: {
    shape: sql_table
    label: "uint32_t W[64] (sha256_impl.h)"
    
    w0: "0x00 | 0x61626380 | (0x61<<24 | 0x62<<16 | 0x63<<8 | 0x80)"
    w1: "0x04 | 0x00000000"
    w2: "0x08 | 0x00000000"
    w3: "0x0C | 0x00000000"
    w_dots: "... | ..."
    w15: "0x3C | 0x00000018 | (Length in bits)"
    
    label_bottom: "Words W[0..15] populated via extraction."
  }
}

# --- Data Flow Connections ---

layer_input.block_buffer.b0 -> layer_logic.c_implementation: "8 bits | 0x61" {
  style: {
    stroke: blue
    animated: true
  }
}
layer_input.block_buffer.b3 -> layer_logic.c_implementation: "8 bits | 0x80" {
  style: {
    stroke: blue
    animated: true
  }
}

layer_logic.c_implementation -> layer_output.w_array.w0: "32 bits | 0x61626380" {
  style: {
    stroke: blue
    stroke-width: 3
  }
}

layer_logic.c_implementation -> layer_output.w_array.w15: "offset 4*15 | 0x00000018"

# --- Visual Semantics ---

layer_input.style.fill: "#f8f9fa"
layer_logic.style.fill: "#fff4e5"
layer_output.style.fill: "#e7f3ff"

# Highlighting the Hot Path (First word extraction)
layer_input.block_buffer.b0.style.stroke: blue
layer_input.block_buffer.b3.style.stroke: blue
layer_output.w_array.w0.style.stroke: blue
layer_output.w_array.w0.style.bold: true