direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# L1 - INPUT LAYER: PHYSICAL MEMORY
input_layer: {
  label: "INPUT LAYER: 512-bit Block (sha256.c)"
  direction: down
  
  block_struct: {
    shape: sql_table
    label: "struct SHA256_Block"
    
    row0: "0x00 | uint8_t | bytes[0] : 0x61 ('a')"
    row1: "0x01 | uint8_t | bytes[1] : 0x62 ('b')"
    row2: "0x02 | uint8_t | bytes[2] : 0x63 ('c')"
    row3: "0x03 | uint8_t | bytes[3] : 0x80 (Padding)"
    row4: "0x04 | uint8_t | bytes[4] : 0x00"
    row_dots: "... | ... | ..."
    row63: "0x3F | uint8_t | bytes[63] : 0x18 (Len)"
    
    label_bottom: "Size: 64 Bytes / 512 bits"
  }
}

# L2 - LOGIC LAYER: WORD RECONSTRUCTION
logic_layer: {
  label: "LOGIC LAYER: Big-Endian Extraction (sha_utils.h)"
  direction: down

  extraction_code: {
    label: "uint32_t load_be32(const uint8_t *p)"
    # Using block string with backticks to safely contain bitwise '|' operators
    code: |`md
c
// Manual Big-Endian reconstruction
// Prevents host-endianness bugs (x86/ARM)
uint32_t load_be32(const uint8_t *p) {
    return ((uint32_t)p[0] << 24) |
           ((uint32_t)p[1] << 16) |
           ((uint32_t)p[2] <<  8) |
           ((uint32_t)p[3] <<  0);
}

    `|
  }

  w0_register: {
    shape: sql_table
    label: "CPU Register: W[0]"
    
    bits_31_24: "31-24 | 0x61 | MSB"
    bits_23_16: "23-16 | 0x62 | ..."
    bits_15_08: "15-08 | 0x63 | ..."
    bits_07_00: "07-00 | 0x80 | LSB"
    
    label_bottom: "Computed Value: 0x61626380"
  }
}

# L3 - OUTPUT LAYER: MESSAGE SCHEDULE
output_layer: {
  label: "OUTPUT LAYER: Message Schedule"
  direction: down

  w_schedule: {
    shape: sql_table
    label: "uint32_t W[64]"
    
    idx0: "W[0]  | 0x61626380"
    idx1: "W[1]  | 0x00000000"
    idx2: "W[2]  | 0x00000000"
    idx_dots: "...   | ..."
    idx15: "W[15] | 0x00000018"
    
    label_bottom: "Initial 16 words mapped from block"
  }
}

# ENDIANNESS VALIDATION
pitfall_analysis: {
  label: "Endianness Comparison (Warning)"
  style: {
    stroke: "#ff0000"
    stroke-width: 4
    fill: "#fff0f0"
  }

  correct: "BIG-ENDIAN (Network Order)\n[61][62][63][80] -> 0x61626380" {
    style: {
      font-color: "#008000"
      bold: true
    }
  }

  incorrect: "LITTLE-ENDIAN (Host Order)\n[61][62][63][80] -> 0x80636261" {
    style: {
      font-color: "#ff0000"
      bold: true
    }
  }

  direct_cast_warning: "DANGER: Direct casting '(uint32_t*)ptr' on x86/AMD64\narchitectures results in the incorrect byte order." {
    shape: text
  }
}

# DATA FLOW (BLUEPRINT SCALE)
input_layer.block_struct.row0 -> logic_layer.extraction_code: "1 byte | 0x61"
input_layer.block_struct.row1 -> logic_layer.extraction_code: "1 byte | 0x62"
input_layer.block_struct.row2 -> logic_layer.extraction_code: "1 byte | 0x63"
input_layer.block_struct.row3 -> logic_layer.extraction_code: "1 byte | 0x80"

logic_layer.extraction_code -> logic_layer.w0_register: "uint32_t | Bit-Shift Summation"
logic_layer.w0_register -> output_layer.w_schedule.idx0: "0x61626380"

logic_layer -> pitfall_analysis: "Integrity Check" {
  style.stroke-dash: 5
}