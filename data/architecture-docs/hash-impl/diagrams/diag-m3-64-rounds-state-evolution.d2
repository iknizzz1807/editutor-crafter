direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SATELLITE CONTEXT: Milestone 3 - Compression Function Internal State
# PROJECT: SHA-256 Implementation (FIPS 180-4)
# FILE: compress.c

state_and_logic: {
  direction: right
  
  state_evolution: {
    label: "SHA-256 State Evolution: 'abc' Test Vector"
    
    # Layer 1: Initialization
    initial_state: {
      shape: sql_table
      label: "struct h_state (compress.c) | H_INIT"
      
      h0: "0x00 | uint32_t | a = 0x6A09E667"
      h1: "0x04 | uint32_t | b = 0xBB67AE85"
      h2: "0x08 | uint32_t | c = 0x3C6EF372"
      h3: "0x0C | uint32_t | d = 0xA54FF53A"
      h4: "0x10 | uint32_t | e = 0x510E527F"
      h5: "0x14 | uint32_t | f = 0x9B05688C"
      h6: "0x18 | uint32_t | g = 0x1F83D9AB"
      h7: "0x1C | uint32_t | h = 0x5BE0CD19"
      
      label_bottom: "Total: 32 bytes | Source: Fractional parts of sqrt(primes)"
    }

    # Layer 2: Round 0 (Initial Input Mixing)
    round_0: {
      direction: down
      label: "ROUND 0 (Input Injection)"
      
      inputs: {
        shape: sql_table
        w0: "uint32_t | W[0] = 0x61626380"
        k0: "uint32_t | K[0] = 0x428A2F98"
      }
      
      state: {
        shape: sql_table
        label: "Working Vars (t=0)"
        a: "0x5D6AEBB1"
        b: "0x6A09E667"
        c: "0xBB67AE85"
        d: "0x3C6EF372"
        e: "0xFA2A4622"
        f: "0x510E527F"
        g: "0x9B05688C"
        h: "0x1F83D9AB"
      }
      
      inputs -> state: "T1 = h+Σ1(e)+Ch(e,f,g)+K+W | T2 = Σ0(a)+Maj(a,b,c)"
    }

    # Layer 3: Round 1 (Cascading Diffusion)
    round_1: {
      direction: down
      label: "ROUND 1 (Diffusion Starts)"
      
      inputs: {
        shape: sql_table
        w1: "uint32_t | W[1] = 0x00000000"
        k1: "uint32_t | K[1] = 0x71374491"
      }
      
      state: {
        shape: sql_table
        label: "Working Vars (t=1)"
        a: "0xE9B078D1"
        b: "0x5D6AEBB1"
        c: "0x6A09E667"
        d: "0xBB67AE85"
        e: "0x367A8906"
        f: "0xFA2A4622"
        g: "0x510E527F"
        h: "0x9B05688C"
      }
      
      inputs -> state: "a = T1 + T2 | e = d + T1"
    }

    # Layer 4: Round 10 (Full Diffusion Reached)
    round_10: {
      direction: down
      label: "ROUND 10 (Entropy Saturation)"
      style.fill: "#fff3cd"
      
      avalanche_note: "AVALANCHE EFFECT ACHIEVED\nFlipping 1 bit in W[0] changes ~50% of bits here." {
        shape: text
        style.font-color: red
        style.bold: true
      }

      state: {
        shape: sql_table
        label: "Working Vars (t=10)"
        a: "0x367A8906"
        b: "0x... high entropy"
        c: "0x... high entropy"
        d: "0x... high entropy"
        e: "0x0113F89D"
        f: "0x... high entropy"
        g: "0x... high entropy"
        h: "0x... high entropy"
      }
    }

    # Layer 5: Round 63 (Final Transformation)
    round_63: {
      direction: down
      label: "ROUND 63 (Compression End)"
      
      state: {
        shape: sql_table
        label: "Final Working Vars"
        a: "0x1B93B9F3"
        b: "0xA0E03D6D"
        c: "0xE9E91A3E"
        d: "0xD39FF6F8"
        e: "0xA95EBB8E"
        f: "0x50BAACE4"
        g: "0xB0FFFA2F"
        h: "0xD9D86A63"
      }
    }

    # Transitions
    initial_state -> round_0: "Load H_INIT"
    round_0 -> round_1: "Rotate {a..h} | 256 bits"
    round_1 -> round_10: "... 8 Rounds ..."
    round_10 -> round_63: "... 53 Rounds ..."
  }

  details_column: {
    direction: down
    
    logic_specification: {
      label: "Round Logic (compress.c)"
      
      core_math: |md
        c
        // Round t (0..63)
        // Sigma functions and Ch/Maj omitted for brevity
        uint32_t T1 = h + Sigma1(e) + Ch(e, f, g) + K[t] + W[t];
        uint32_t T2 = Sigma0(a) + Maj(a, b, c);
        
        h = g; g = f; f = e; 
        e = d + T1; // Crossover
        d = c; c = b; b = a; 
        a = T1 + T2; // State Mixing
        
      |
    }

    final_accumulation: {
      shape: package
      label: "State Accumulation"
      
      formula: |md
        c
        for (int i = 0; i < 8; i++) {
            h_state->H[i] += working_var[i]; // mod 2^32
        }
        
      |
      result: "H[0] = 0xBA7816BF (abc block result)"
    }
  }
}

# Cross-container flow for engineers
state_and_logic.state_evolution.round_63 -> state_and_logic.details_column.final_accumulation: "Merkle-Damgård Chain Completion" {
  style.stroke-dash: 3
  label: "uint32_t[8] | 32 bytes"
}

state_and_logic.details_column.logic_specification -> state_and_logic.state_evolution.round_0: "Implements" {
  style.stroke: gray
}