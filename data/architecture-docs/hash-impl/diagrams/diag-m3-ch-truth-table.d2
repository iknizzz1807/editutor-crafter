direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

title: "SHA-256 Choice Function: Ch(e, f, g) (sha256.c)" {
  shape: text
  near: top-center
  style: {
    font-size: 18
    bold: true
  }
}

# --- LAYER 1: FORMAL DEFINITION ---
definition_layer: {
  label: "FUNCTION DEFINITION"
  direction: down

  implementation: {
    shape: code
    label: "C Implementation (sha256.c)"
    language: c
    value: |md
      c
      /**
       * Ch(e, f, g) = (e & f) ^ (~e & g)
       * 
       * Behavioral logic: 
       * For each bit position:
       *   if (e_bit == 1) result = f_bit
       *   else result = g_bit
       */
      static inline uint32_t ch(uint32_t e, uint32_t f, uint32_t g) {
          return (e & f) ^ (~e & g);
      }
      
    |
  }

  logic_gate: {
    label: "32-Bit Wide Multiplexer Model"
    direction: right
    
    e_in: "e (Selector)" { shape: circle; style.fill: "#C7F1FF" }
    f_in: "f (Input 1)" { shape: circle; style.fill: "#E4DBFE" }
    g_in: "g (Input 0)" { shape: circle; style.fill: "#E4DBFE" }
    
    mux: "MUX" {
      shape: parallelogram
      label: "2-to-1 MUX\n(32-bit parallel)"
    }
    
    e_in -> mux: "S"
    f_in -> mux: "I₁"
    g_in -> mux: "I₀"
    mux -> output: "uint32_t | 4 Bytes"
  }
}

# --- LAYER 2: TRUTH TABLE (BIT-LEVEL LOGIC) ---
logic_layer: {
  label: "LOGIC TABLE"
  
  truth_table: {
    shape: sql_table
    label: "Ch(e, f, g) Truth Table"
    
    header: "e_bit | f_bit | g_bit | Output"
    row1: "0     | 0     | 0     | 0 (g)"
    row2: "0     | 0     | 1     | 1 (g)"
    row3: "0     | 1     | 0     | 0 (g)"
    row4: "0     | 1     | 1     | 1 (g)"
    row5: "1     | 0     | 0     | 0 (f)"
    row6: "1     | 0     | 1     | 0 (f)"
    row7: "1     | 1     | 0     | 1 (f)"
    row8: "1     | 1     | 1     | 1 (f)"
    
    label_bottom: "Total combinations: 2³ = 8"
  }
}

# --- LAYER 3: WORKED 4-BIT EXAMPLE ---
example_layer: {
  label: "WORKED 4-BIT TRACE"
  direction: down
  
  trace: {
    shape: sql_table
    label: "Example Execution (Slice 0xCA, 0xB7, 0x69)"
    
    row_e: "e | 1 | 1 | 0 | 0 | (Control: Select F if 1, G if 0)"
    row_f: "f | 1 | 0 | 1 | 1 | (Data A)"
    row_g: "g | 0 | 1 | 1 | 0 | (Data B)"
    divider: "-------------------"
    row_o: "OUT | 1 | 0 | 1 | 0 | (Result: 0xA)"
    
    label_bottom: "Logic: (1→f, 1→f, 0→g, 0→g)"
  }

  calculation_steps: {
    shape: code
    label: "Step-by-Step Masking"
    language: text
    value: |md
      1. (e & f)    = 1100 & 1011 = 1000
      2. (~e & g)   = 0011 & 0110 = 0010
      3. (1) ^ (2)  = 1000 ^ 0010 = 1010 (0xA)
    |
  }
}

# --- FLOWS ---
definition_layer -> logic_layer: "governs bit-level behavior"
logic_layer -> example_layer: "applied to concrete values"

# Style overrides
definition_layer.style.stroke: "#88DCF7"
logic_layer.style.stroke: "#B5AFF6"
example_layer.style.stroke: "#ACE1AF"