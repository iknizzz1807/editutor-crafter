direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ------------------------------------------------------------------------------------------
# CLASSES & STYLES
# ------------------------------------------------------------------------------------------
classes: {
  variable: {
    shape: sql_table
    style: {
      fill: "#f8f9fa"
      stroke: "#212529"
      font-size: 14
    }
  }
  logic_block: {
    style: {
      fill: "#e7f1ff"
      stroke: "#0d6efd"
      stroke-width: 2
      bold: true
    }
  }
  accumulator: {
    shape: circle
    label: "+"
    style: {
      fill: "#fff3cd"
      stroke: "#ffc107"
      stroke-width: 2
      bold: true
    }
  }
  external_input: {
    style: {
      fill: "#f3e5f5"
      stroke: "#9c27b0"
      stroke-dash: 3
    }
  }
}

# ------------------------------------------------------------------------------------------
# SATELLITE CONTEXT & TITLE
# ------------------------------------------------------------------------------------------
title: |md
  # SHA-256 Compression Round Anatomy
  **Specification: FIPS 180-4 Section 6.2.2**
  *State transformation for Round t (0 ≤ t < 64)*
| {near: top-center}

# ------------------------------------------------------------------------------------------
# ROUND INPUTS
# ------------------------------------------------------------------------------------------
round_inputs: {
  label: "INPUT STATE (Round t)"
  direction: down
  
  W_t: "0x00 | uint32_t | W[t]" { class: external_input }
  K_t: "0x04 | uint32_t | K[t]" { class: external_input }
  
  state_t: {
    grid-columns: 1
    a: "uint32_t | a" { class: variable }
    b: "uint32_t | b" { class: variable }
    c: "uint32_t | c" { class: variable }
    d: "uint32_t | d" { class: variable }
    e: "uint32_t | e" { class: variable }
    f: "uint32_t | f" { class: variable }
    g: "uint32_t | g" { class: variable }
    h: "uint32_t | h" { class: variable }
  }
}

# ------------------------------------------------------------------------------------------
# COMPUTATION LOGIC
# ------------------------------------------------------------------------------------------
logic_layer: {
  label: "TRANSFORMATION LOGIC"
  direction: down

  # T1 Branch
  t1_logic: {
    direction: right
    sigma_upper_1: "Σ1 (Sigma1)" { 
      class: logic_block
      tooltip: "ROTR(e,6) ^ ROTR(e,11) ^ ROTR(e,25)"
    }
    choice: "Ch (Choice)" { 
      class: logic_block
      tooltip: "(e & f) ^ (~e & g)"
    }
    
    t1_sum: {
      class: accumulator
      label: "T1"
    }
  }

  # T2 Branch
  t2_logic: {
    direction: right
    sigma_upper_0: "Σ0 (Sigma0)" { 
      class: logic_block
      tooltip: "ROTR(a,2) ^ ROTR(a,13) ^ ROTR(a,22)"
    }
    majority: "Maj (Majority)" { 
      class: logic_block
      tooltip: "(a & b) ^ (a & c) ^ (b & c)"
    }
    
    t2_sum: {
      class: accumulator
      label: "T2"
    }
  }
}

# ------------------------------------------------------------------------------------------
# OUTPUT STATE
# ------------------------------------------------------------------------------------------
round_outputs: {
  label: "OUTPUT STATE (Round t+1)"
  direction: down
  
  state_next: {
    grid-columns: 1
    a_next: "uint32_t | a'" { class: variable; style.fill: "#d4edda" }
    b_next: "uint32_t | b'" { class: variable }
    c_next: "uint32_t | c'" { class: variable }
    d_next: "uint32_t | d'" { class: variable }
    e_next: "uint32_t | e'" { class: variable; style.fill: "#d4edda" }
    f_next: "uint32_t | f'" { class: variable }
    g_next: "uint32_t | g'" { class: variable }
    h_next: "uint32_t | h'" { class: variable }
  }
  
  label_bottom: "Total: 256 bits (32 bytes)"
}

# ------------------------------------------------------------------------------------------
# DATA FLOW CONNECTIONS
# ------------------------------------------------------------------------------------------

# Inputs to T1 Logic
round_inputs.state_t.e -> logic_layer.t1_logic.sigma_upper_1: "uint32_t"
round_inputs.state_t.e -> logic_layer.t1_logic.choice: "e"
round_inputs.state_t.f -> logic_layer.t1_logic.choice: "f"
round_inputs.state_t.g -> logic_layer.t1_logic.choice: "g"

# T1 Summation
round_inputs.state_t.h -> logic_layer.t1_logic.t1_sum: "h"
logic_layer.t1_logic.sigma_upper_1 -> logic_layer.t1_logic.t1_sum
logic_layer.t1_logic.choice -> logic_layer.t1_logic.t1_sum
round_inputs.W_t -> logic_layer.t1_logic.t1_sum: "W[t]"
round_inputs.K_t -> logic_layer.t1_logic.t1_sum: "K[t]"

# Inputs to T2 Logic
round_inputs.state_t.a -> logic_layer.t2_logic.sigma_upper_0: "uint32_t"
round_inputs.state_t.a -> logic_layer.t2_logic.majority: "a"
round_inputs.state_t.b -> logic_layer.t2_logic.majority: "b"
round_inputs.state_t.c -> logic_layer.t2_logic.majority: "c"

# T2 Summation
logic_layer.t2_logic.sigma_upper_0 -> logic_layer.t2_logic.t2_sum
logic_layer.t2_logic.majority -> logic_layer.t2_logic.t2_sum

# Next State Assignments (The Rotation)
logic_layer.t1_logic.t1_sum -> logic_layer.t2_logic.t2_sum: "T1"
logic_layer.t2_logic.t2_sum -> round_outputs.state_next.a_next: "a' = T1 + T2"

round_inputs.state_t.a -> round_outputs.state_next.b_next: "b' = a"
round_inputs.state_t.b -> round_outputs.state_next.c_next: "c' = b"
round_inputs.state_t.c -> round_outputs.state_next.d_next: "d' = c"

# The e Injection
round_inputs.state_t.d -> round_outputs.state_next.e_next: "d"
logic_layer.t1_logic.t1_sum -> round_outputs.state_next.e_next: "e' = d + T1"

round_inputs.state_t.e -> round_outputs.state_next.f_next: "f' = e"
round_inputs.state_t.f -> round_outputs.state_next.g_next: "g' = f"
round_inputs.state_t.g -> round_outputs.state_next.h_next: "h' = g"

# Formula Reference
footer: |md
  c
  // Formula Logic
  uint32_t T1 = h + Sigma1(e) + Ch(e, f, g) + K[t] + W[t];
  uint32_t T2 = Sigma0(a) + Maj(a, b, c);
  
  // Re-assignment
  h = g; g = f; f = e; e = d + T1;
  d = c; c = b; b = a; a = T1 + T2;
  
| {near: bottom-center}