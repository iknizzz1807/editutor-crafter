direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SHA-256 Compression Round (sha256.c)
# Based on FIPS 180-4 Section 6.2.2

round_logic: {
  direction: right
  label: "SHA-256 Single Round Transformation | t ∈ [0, 63]"

  # Input Working Variables
  state_t: {
    shape: sql_table
    label: "struct sha256_state (sha256.h)"
    
    a: "0x00 | uint32_t | a"
    b: "0x04 | uint32_t | b"
    c: "0x08 | uint32_t | c"
    d: "0x0C | uint32_t | d"
    e: "0x10 | uint32_t | e"
    f: "0x14 | uint32_t | f"
    g: "0x18 | uint32_t | g"
    h: "0x1C | uint32_t | h"
    
    label_bottom: "Total: 32 bytes (1 cache line)"
  }

  # Computational Primitives
  primitives: {
    label: "Logical Functions (sha256.c)"
    direction: down

    sigma0: "Σ0(a)" {
      tooltip: "ROTR(a,2) ^ ROTR(a,13) ^ ROTR(a,22)"
      style: { fill: "#E4DBFE"; stroke: "#3c00e0" }
    }
    maj: "Maj(a,b,c)" {
      tooltip: "(a & b) ^ (a & c) ^ (b & c)"
      style: { fill: "#E4DBFE"; stroke: "#3c00e0" }
    }
    sigma1: "Σ1(e)" {
      tooltip: "ROTR(e,6) ^ ROTR(e,11) ^ ROTR(e,25)"
      style: { fill: "#C7F1FF"; stroke: "#0072b2" }
    }
    ch: "Ch(e,f,g)" {
      tooltip: "(e & f) ^ (~e & g)"
      style: { fill: "#C7F1FF"; stroke: "#0072b2" }
    }
  }

  # External Inputs
  external: {
    direction: down
    w_t: "W[t]" {
      label: "Message Word W[t] | 4 bytes"
      shape: parallelogram
      style: { fill: "#FFF9C9" }
    }
    k_t: "K[t]" {
      label: "Round Constant K[t] | 4 bytes"
      shape: parallelogram
      style: { fill: "#FFF9C9" }
    }
  }

  # Summation Nodes
  sum_t1: "Σ T1" {
    shape: circle
    label: "+"
    tooltip: "T1 = h + Σ1(e) + Ch(e,f,g) + K[t] + W[t] (mod 2^32)"
    style: { stroke-width: 3 }
  }

  sum_t2: "Σ T2" {
    shape: circle
    label: "+"
    tooltip: "T2 = Σ0(a) + Maj(a,b,c) (mod 2^32)"
    style: { stroke-width: 3 }
  }

  sum_new_a: "Σ a'" {
    shape: circle
    label: "+"
    tooltip: "a' = T1 + T2 (mod 2^32)"
    style: { stroke-width: 3 }
  }

  sum_new_e: "Σ e'" {
    shape: circle
    label: "+"
    tooltip: "e' = d + T1 (mod 2^32)"
    style: { stroke-width: 3 }
  }

  # Output State
  state_next: {
    shape: sql_table
    label: "Working Variables (Round t+1)"
    
    a_next: "0x00 | uint32_t | a'"
    b_next: "0x04 | uint32_t | b'"
    c_next: "0x08 | uint32_t | c'"
    d_next: "0x0C | uint32_t | d'"
    e_next: "0x10 | uint32_t | e'"
    f_next: "0x14 | uint32_t | f'"
    g_next: "0x18 | uint32_t | g'"
    h_next: "0x1C | uint32_t | h'"
  }

  # Internal Connections (Data Flow)
  
  # T1 Calculation
  state_t.h -> sum_t1: "uint32_t | 4B | h"
  state_t.e -> primitives.sigma1: "uint32_t | 4B | e"
  primitives.sigma1 -> sum_t1: "uint32_t | 4B | Σ1(e)"
  
  state_t.e -> primitives.ch: "uint32_t | 4B"
  state_t.f -> primitives.ch: "uint32_t | 4B"
  state_t.g -> primitives.ch: "uint32_t | 4B"
  primitives.ch -> sum_t1: "uint32_t | 4B | Ch(e,f,g)"
  
  external.k_t -> sum_t1: "uint32_t | 4B | K[t]"
  external.w_t -> sum_t1: "uint32_t | 4B | W[t]"

  # T2 Calculation
  state_t.a -> primitives.sigma0: "uint32_t | 4B | a"
  primitives.sigma0 -> sum_t2: "uint32_t | 4B | Σ0(a)"
  
  state_t.a -> primitives.maj: "uint32_t | 4B"
  state_t.b -> primitives.maj: "uint32_t | 4B"
  state_t.c -> primitives.maj: "uint32_t | 4B"
  primitives.maj -> sum_t2: "uint32_t | 4B | Maj(a,b,c)"

  # Final Assignments & Cross-Feeding
  sum_t1 -> sum_new_a: "T1 | 4B | 0x3c...2f"
  sum_t2 -> sum_new_a: "T2 | 4B | 0xa1...02"
  sum_new_a -> state_next.a_next: "uint32_t | a' = T1 + T2"

  state_t.d -> sum_new_e: "uint32_t | 4B | d"
  sum_t1 -> sum_new_e: "T1 | 4B | 0x3c...2f"
  sum_new_e -> state_next.e_next: "uint32_t | e' = d + T1"

  # Shifting Assignments
  state_t.a -> state_next.b_next: "uint32_t | b' = a"
  state_t.b -> state_next.c_next: "uint32_t | c' = b"
  state_t.c -> state_next.d_next: "uint32_t | d' = c"
  state_t.e -> state_next.f_next: "uint32_t | f' = e"
  state_t.f -> state_next.g_next: "uint32_t | g' = f"
  state_t.g -> state_next.h_next: "uint32_t | h' = g"
}

# Fix for "near" constraint in ELK
round_legend: {
  near: top-right
  shape: text
  label: "Logic Reference:\n• All additions: mod 2^32\n• Σ Functions: ROTR diffusion\n• Ch/Maj: Non-linear bitslice mixing"
  style: {
    font-size: 14
    italic: true
  }
}

implementation: {
  label: "Implementation Reference (sha256.c)"
  near: bottom-center
  
  code: |md
    c
    // FIPS 180-4 6.2.2 - Single Round
    uint32_t T1 = h + Sigma1(e) + ch(e, f, g) + K[t] + W[t];
    uint32_t T2 = Sigma0(a) + maj(a, b, c);
    
    h = g; g = f; f = e; 
    e = d + T1;
    d = c; c = b; b = a; 
    a = T1 + T2;
    
  |
}

# Style Globs
round_logic.sum_*: {
  style: {
    fill: "#fce7c6"
    bold: true
  }
}

round_logic.state_t: { style.fill: "#DEE1EB" }
round_logic.state_next: { style.fill: "#DEE1EB" }
round_logic.state_next.a_next: { style.fill: "#ACE1AF" }
round_logic.state_next.e_next: { style.fill: "#ACE1AF" }