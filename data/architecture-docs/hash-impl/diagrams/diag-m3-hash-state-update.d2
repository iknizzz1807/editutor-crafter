direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SECTION 1: INITIAL STATE (BEFORE)
initial_state: {
  direction: down
  label: "Hash State H(i) (sha256.c)"
  
  h_mem: {
    shape: sql_table
    label: "struct Context.H [Initial]"
    
    row0: "0x00 | uint32_t | H[0]"
    row1: "0x04 | uint32_t | H[1]"
    row2: "0x08 | uint32_t | H[2]"
    row3: "0x0C | uint32_t | H[3]"
    row4: "0x10 | uint32_t | H[4]"
    row5: "0x14 | uint32_t | H[5]"
    row6: "0x18 | uint32_t | H[6]"
    row7: "0x1C | uint32_t | H[7]"
    
    label_bottom: "Total: 32 Bytes (Stored State)"
  }

  load_code: |md
    c
    uint32_t a = H[0];
    uint32_t b = H[1];
    // ... load H[2..7] ...
    
  |
}

# SECTION 2: TRANSFORMATION (COMPRESSION)
processing_phase: {
  direction: down
  label: "Iterative Compression"
  
  round_logic: {
    label: "64-Round Engine"
    shape: rectangle
    style: {
      stroke-dash: 3
      fill: "#f8f9fa"
    }
    
    logic_desc: |md
      **Round Function**
      1. T1 = h + Σ1(e) + Ch(e,f,g) + K[t] + W[t]
      2. T2 = Σ0(a) + Maj(a,b,c)
      3. Rotate: h=g, g=f, f=e, e=d+T1, d=c, c=b, b=a, a=T1+T2
    |
  }

  work_vars: {
    shape: sql_table
    label: "Working Variables [After Round 63]"
    
    row0: "var a | uint32_t | 0x1B93B9F3"
    row1: "var b | uint32_t | 0xA0E03D6D"
    row2: "var c | uint32_t | 0xE9E91A3E"
    row3: "var d | uint32_t | 0xD39FF6F8"
    row4: "var e | uint32_t | 0xA95EBB8E"
    row5: "var f | uint32_t | 0x50BAACE4"
    row6: "var g | uint32_t | 0xB0FFFA2F"
    row7: "var h | uint32_t | 0xD9D86A63"
    
    label_bottom: "Values based on 'abc' test vector"
  }
}

# SECTION 3: FINAL ACCUMULATION (AFTER)
final_state: {
  direction: down
  label: "Updated Hash State H(i+1) (sha256.c)"

  update_op: |md
    c
    H[0] += a; H[1] += b; H[2] += c; H[3] += d;
    H[4] += e; H[5] += f; H[6] += g; H[7] += h;
    
  |

  h_mem_final: {
    shape: sql_table
    label: "struct Context.H [Accumulated]"
    
    row0: "0x00 | H[0] | Prev H[0] + a"
    row1: "0x04 | H[1] | Prev H[1] + b"
    row2: "0x08 | H[2] | Prev H[2] + c"
    row3: "0x0C | H[3] | Prev H[3] + d"
    row4: "0x10 | H[4] | Prev H[4] + e"
    row5: "0x14 | H[5] | Prev H[5] + f"
    row6: "0x18 | H[6] | Prev H[6] + g"
    row7: "0x1C | H[7] | Prev H[7] + h"
    
    label_bottom: "Arithmetic: Modular 2^32 Addition"
  }
}

# DATA FLOW CONNECTIONS
initial_state.h_mem -> processing_phase.round_logic: "uint32_t[8] | 32B | Initial State"
processing_phase.round_logic -> processing_phase.work_vars: "Final Scrambled Result"

# The Addition Logic
initial_state.h_mem -> final_state.h_mem_final: "Add to Current State" {
  style: {
    stroke: purple
    stroke-width: 3
  }
}
processing_phase.work_vars -> final_state.h_mem_final: "Mix Round Output" {
  style: {
    stroke: blue
    stroke-width: 3
    stroke-dash: 2
  }
}

legend: {
  near: bottom-right
  note: |md
    **Merkle-Damgård chaining step:**
    The state is NOT replaced, but
    mutated via addition to ensure
    irreversibility.
  |
}