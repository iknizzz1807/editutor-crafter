direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SATELLITE CONTEXT: Milestone 3 - Compression Engine
# Component: Round Constants (K) Derivation

title: |md
  # SHA-256 Round Constants (K) Derivation
  **Nothing-Up-My-Sleeve (NUMS) Construction**
  *Verifiable provenance from the first 64 prime numbers.*
| {near: top-center}

# 1. SOURCE PRIMES LAYER
layer_source: {
  label: "1. SOURCE PRIMES"
  direction: down

  prime_list: {
    shape: sql_table
    label: "Prime Numbers (p)"
    p0: "p[0] | 2"
    p1: "p[1] | 3"
    p2: "p[2] | 5"
    p3: "p[3] | 7"
    p4: "p[4] | 11"
    label_bottom: "... up to p[63] = 311"
  }
}

# 2. MATHEMATICAL TRANSFORMATION LAYER
layer_math: {
  label: "2. TRANSFORMATION (p^(1/3) mod 1)"
  direction: down

  calc_steps: {
    shape: sql_table
    label: "Cube Root & Fractional Extraction"
    
    row0: "p[0] | 1.259921049... | 0.259921049..."
    row1: "p[1] | 1.442249570... | 0.442249570..."
    row2: "p[2] | 1.709975946... | 0.709975946..."
    row3: "p[3] | 1.912931182... | 0.912931182..."
    
    label_bottom: "Formula: f = (p^(1/3)) - floor(p^(1/3))"
  }
}

# 3. BIT-STRING GENERATION LAYER
layer_bits: {
  label: "3. SCALE & TRUNCATE (f * 2^32)"
  direction: down

  bit_gen: {
    shape: sql_table
    label: "Integer Truncation (consts.c)"
    
    k0: "f[0] * 2^32 | 1116352408 | 0x428a2f98"
    k1: "f[1] * 2^32 | 1899115121 | 0x71374491"
    k2: "f[2] * 2^32 | 3049318735 | 0xb5c0fbcf"
    k3: "f[3] * 2^32 | 3920817445 | 0xe9b5dba5"
    
    label_bottom: "K[t] = floor(f * 4294967296)"
  }
}

# 4. FINAL IMPLEMENTATION ARRAY
layer_impl: {
  label: "4. IMPLEMENTATION"
  direction: down

  k_array: {
    shape: class
    label: "static const uint32_t K[64] (sha256.c)"
    
    definition: |md
      c
      static const uint32_t K[64] = {
          0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
          0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
          /* ... 56 more constants ... */
      };
      
    |
    label_bottom: "Total size: 256 Bytes"
  }

  nums_explanation: {
    shape: text
    label: |md
      ### ðŸ›¡ï¸ Nothing-Up-My-Sleeve
      These constants are **verifiably objective**.
      Because they are derived from fundamental 
      mathematical properties (Primes + Cube Roots),
      the designers **cannot hide a backdoor** in the
      values. Any developer can re-calculate and
      verify every bit of the K array.
    |
    style: {
      stroke-dash: 3
      fill: "#f9f9f9"
    }
  }
}

# DATA FLOW CONNECTIONS
layer_source.prime_list.p0 -> layer_math.calc_steps.row0: "âˆ›p"
layer_source.prime_list.p1 -> layer_math.calc_steps.row1: "âˆ›p"

layer_math.calc_steps.row0 -> layer_bits.bit_gen.k0: "Ã— 2^32"
layer_math.calc_steps.row1 -> layer_bits.bit_gen.k1: "Ã— 2^32"
layer_math.calc_steps.row2 -> layer_bits.bit_gen.k2: "Ã— 2^32"
layer_math.calc_steps.row3 -> layer_bits.bit_gen.k3: "Ã— 2^32"

layer_bits.bit_gen -> layer_impl.k_array: "Concatenate to Array"

# LEGEND / SCALE
legend: {
  near: bottom-right
  
  scale: "64 words | 256 bytes total"
  type: "uint32_t | 4 bytes per constant"
}