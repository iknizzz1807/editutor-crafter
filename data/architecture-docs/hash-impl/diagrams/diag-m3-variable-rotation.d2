direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SHA-256 Working Variable Rotation (compress.c)
# Demonstrates transition from State T to State T+1

state_t: {
  label: "ROUND STATE T (Before)"
  direction: down
  
  variables: {
    shape: sql_table
    a: "0x00 | uint32_t | a"
    b: "0x04 | uint32_t | b"
    c: "0x08 | uint32_t | c"
    d: "0x0C | uint32_t | d"
    e: "0x10 | uint32_t | e"
    f: "0x14 | uint32_t | f"
    g: "0x18 | uint32_t | g"
    h: "0x1C | uint32_t | h"
    label_bottom: "Total: 32 bytes"
  }
}

round_logic: {
  label: "TRANSFORMATION LOGIC"
  direction: down
  style.fill: "#f8f9fa"

  t1_calc: {
    label: "T1 Calculation"
    shape: code
    code: |md
      c
      uint32_t T1 = h + Sigma1(e) + Ch(e, f, g) + K[t] + W[t];
      
    |
  }

  t2_calc: {
    label: "T2 Calculation"
    shape: code
    code: |md
      c
      uint32_t T2 = Sigma0(a) + Maj(a, b, c);
      
    |
  }
}

# FIX: Moved implementation warning to root level to allow 'near' positioning
error_warning: "IMPLEMENTATION TRAP" {
  shape: text
  near: bottom-center
  style: {
    font-color: red
    bold: true
    italic: true
  }
  label: "WARNING: d is updated with T1 ONLY.\nT2 is added ONLY to a."
}

state_t_plus_1: {
  label: "ROUND STATE T+1 (After)"
  direction: down

  variables: {
    shape: sql_table
    a: "0x00 | uint32_t | a' = T1 + T2"
    b: "0x04 | uint32_t | b' = a"
    c: "0x08 | uint32_t | c' = b"
    d: "0x0C | uint32_t | d' = c"
    e: "0x10 | uint32_t | e' = d + T1"
    f: "0x14 | uint32_t | f' = e"
    g: "0x18 | uint32_t | g' = f"
    h: "0x1C | uint32_t | h' = g"
    label_bottom: "32-bit Addition (mod 2^32)"
  }
}

# Mapping the Rotation Flow
state_t.variables.a -> state_t_plus_1.variables.b: "Simple Shift"
state_t.variables.b -> state_t_plus_1.variables.c: "Simple Shift"
state_t.variables.c -> state_t_plus_1.variables.d: "Simple Shift"

# The e-group injection
state_t.variables.d -> state_t_plus_1.variables.e: "d + T1" {
  style.stroke: blue
  style.stroke-width: 3
}

state_t.variables.e -> state_t_plus_1.variables.f: "Simple Shift"
state_t.variables.f -> state_t_plus_1.variables.g: "Simple Shift"
state_t.variables.g -> state_t_plus_1.variables.h: "Simple Shift"

# Logical Inputs
state_t.variables.h -> round_logic.t1_calc: "h input"
state_t.variables.e -> round_logic.t1_calc: "e, f, g inputs"
state_t.variables.a -> round_logic.t2_calc: "a, b, c inputs"

# Result Propagation
round_logic.t1_calc -> state_t_plus_1.variables.a: "T1 contribution" {
  style.stroke: purple
}
round_logic.t2_calc -> state_t_plus_1.variables.a: "T2 contribution" {
  style.stroke: purple
}
round_logic.t1_calc -> state_t_plus_1.variables.e: "T1 injection" {
  style.stroke: blue
  style.animated: true
}

# Highlighting critical update registers
state_t_plus_1.variables.a: {
  style.fill: "#e8f5e9"
  style.stroke: green
}

state_t_plus_1.variables.e: {
  style.fill: "#e3f2fd"
  style.stroke: blue
}

# Legend for the engineer
legend: {
  near: bottom-right
  note: |md
    **Data Movement Rules:**
    1.  `a, b, c` shift down to `b, c, d`
    2.  `e, f, g` shift down to `f, g, h`
    3.  `e` is the 'mid-point' injection: `new_e = old_d + T1`
    4.  `a` is the 'head' injection: `new_a = T1 + T2`
  |
}