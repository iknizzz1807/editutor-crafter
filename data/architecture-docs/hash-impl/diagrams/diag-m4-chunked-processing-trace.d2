direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- 1. SHA256_CTX DEFINITION (BLUEPRINT) ---
ctx_definition: {
  shape: sql_table
  label: "struct SHA256_CTX (sha256.h)"
  
  row1: "0x00 | uint32_t[8] | H"
  row2: "0x20 | uint8_t[64] | buf"
  row3: "0x60 | uint32_t    | buf_len"
  row4: "0x68 | uint64_t    | msg_len_bits"
  label_bottom: "Total Size: 112 bytes"
}

# --- 2. THE PROCESSING PIPELINE TRACE ---
trace: {
  direction: right

  # Step 0: Initial State
  init: {
    label: "Step 0: sha256_init()"
    state: {
      shape: sql_table
      h_state: "H | {6A09E667...5BE0CD19}"
      buffer: "buf | [0, 0, ..., 0]"
      meta: "buf_len: 0 | bits: 0"
    }
  }

  # Step 1: First Update
  update_1: {
    label: "Step 1: sha256_update(8 bytes)"
    input: |md `abcdbcde` |
    logic: "Phase 3: memcpy to buf"
    state: {
      shape: sql_table
      h_state: "H | (Unchanged)"
      buffer: "buf[0..7] | \"abcdbcde\""
      meta: "buf_len: 8 | bits: 64"
    }
  }

  # Step 2: Second Update
  update_2: {
    label: "Step 2: sha256_update(40 bytes)"
    input: |md `cdefdefgefghfghighijhijkijkljklmklmnlmno` |
    logic: "Phase 3: append to buf"
    state: {
      shape: sql_table
      h_state: "H | (Unchanged)"
      buffer: "buf[8..47] | \"cdef...lmno\""
      meta: "buf_len: 48 | bits: 384"
    }
  }

  # Step 3: Third Update
  update_3: {
    label: "Step 3: sha256_update(8 bytes)"
    input: |md `mnopnopq` |
    logic: "Phase 3: append to buf"
    state: {
      shape: sql_table
      h_state: "H | (Unchanged)"
      buffer: "buf[48..55] | \"mnopnopq\""
      meta: "buf_len: 56 | bits: 448"
    }
  }

  # Step 4: Finalize
  finalize: {
    label: "Step 4: sha256_finalize()"
    direction: down
    
    analysis: {
      shape: text
      label: "buf_len (56) + 0x80 (1) = 57 bytes\n57 > 56 Threshold\nResult: 2 Blocks Required"
    }

    block_a: {
      shape: sql_table
      label: "Block A (64 Bytes)"
      m: "0x00..0x37 | Message Bytes (56B)"
      p: "0x38       | 0x80 (Separator)"
      z: "0x39..0x3F | 0x00 (7 Bytes Padding)"
    }

    block_b: {
      shape: sql_table
      label: "Block B (64 Bytes)"
      z: "0x00..0x37 | 0x00 (56 Bytes Padding)"
      l: "0x38..0x3F | 0x00000000000001C0 (448 bits)"
    }
  }
}

# --- 3. EXECUTION ENGINE (COMPRESSION) ---
compression_engine: {
  label: "sha256_compress (compress.c)"
  icon: https://icons.terrastruct.com/tech%2F022-server.svg
  
  rounds: {
    shape: code
    label: |md
    c
    for (int t = 0; t < 64; t++) {
        T1 = h + Sigma1(e) + ch(e,f,g) + K[t] + W[t];
        T2 = Sigma0(a) + maj(a,b,c);
        ... // Shift and Update
    }
    
    |
  }
}

# --- 4. DATA FLOW CONNECTIONS ---
trace.init -> trace.update_1: "Call"
trace.update_1 -> trace.update_2: "Call"
trace.update_2 -> trace.update_3: "Call"
trace.update_3 -> trace.finalize: "Call"

trace.finalize.block_a -> compression_engine: "1. sha256_compress(ctx->H, Block_A)" {
  style: {
    stroke: blue
    stroke-width: 2
  }
}

trace.finalize.block_b -> compression_engine: "2. sha256_compress(ctx->H, Block_B)" {
  style: {
    stroke: blue
    stroke-width: 2
  }
}

compression_engine -> output: "Result: 248d6a61...06c1" {
  style: {
    stroke: green
    bold: true
  }
}

output: {
  shape: rectangle
  label: "Final Digest (Hex)"
  style: {
    fill: "#eaffea"
    stroke: green
  }
}

# Annotations
legend: {
  near: bottom-right
  
  c1: "Blue: Execution Flow" {
    style.font-color: blue
  }
  c2: "Green: Correct NIST Result" {
    style.font-color: green
  }
}