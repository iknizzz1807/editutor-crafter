direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# -----------------------------------------------------------------------------
# SHA-256 CONTEXT DEFINITION (Memory Layout)
# -----------------------------------------------------------------------------

sha256_context: {
  shape: sql_table
  label: "struct SHA256_CTX (sha256.h)"

  row_h: "0x00 | uint32_t[8] | H"
  row_buf: "0x20 | uint8_t[64] | buf"
  row_total: "0x60 | uint64_t    | total_len"
  row_buflen: "0x68 | size_t      | buf_len"
  
  label_bottom: "Total Size: 112 bytes (64-bit arch)"

  row_h.tooltip: "Current 256-bit hash state (H0..H7). Initialized to sqrt(primes)."
  row_buf.tooltip: "Partial block buffer. Holds 0-63 bytes awaiting compression."
  row_total.tooltip: "Total message length processed in BYTES. Used for final padding."
  row_buflen.tooltip: "Number of valid bytes currently residing in buf."
}

# -----------------------------------------------------------------------------
# API OPERATIONS (C Method Signatures)
# -----------------------------------------------------------------------------

api: {
  label: "SHA-256 API (sha256.c)"
  direction: down

  init: |md
    c
    void sha256_init(SHA256_CTX *ctx);
    
    - H[0..7] = {0x6A09E667, ...}
    - buf = {0}, buf_len = 0, total_len = 0
  |

  update: |md
    c
    void sha256_update(SHA256_CTX *ctx, 
                      const uint8_t *data, 
                      size_t len);
    
    - Consumes 64-byte chunks
    - Buffers partials in ctx->buf
    - Increments total_len
  |

  finalize: |md
    c
    void sha256_finalize(SHA256_CTX *ctx, 
                        uint8_t out[32]);
    
    - Applies padding/length to buf
    - Performs final compression(s)
    - Zeroes ctx for security hygiene
  |
}

# -----------------------------------------------------------------------------
# LIFECYCLE & STATE TRANSITIONS
# -----------------------------------------------------------------------------

lifecycle: {
  direction: right
  style.stroke-dash: 3
  
  state_uninit: "Uninitialized Memory" {
    style.fill: gray
    style.opacity: 0.5
  }

  state_ready: "Active Context" {
    style.fill: blue
    style.stroke-width: 2
  }

  state_done: "Zeroed / Secure" {
    style.fill: green
  }
}

# -----------------------------------------------------------------------------
# CONNECTIVITY & DATA FLOW
# -----------------------------------------------------------------------------

lifecycle.state_uninit -> api.init: "malloc() / stack alloc"
api.init -> sha256_context: "RESET: H=primes, buf=0, len=0"
sha256_context -> lifecycle.state_ready

lifecycle.state_ready -> api.update: "Data Arrival"
api.update -> sha256_context: "WRITE: Update H, buf, total_len"

lifecycle.state_ready -> api.finalize: "EOF / Stream End"
api.finalize -> sha256_context: "READ: H, total_len | WRITE: Padding"
sha256_context -> api.finalize: "32-byte Digest Out"

api.finalize -> lifecycle.state_done: "MEMSET(ctx, 0, 112)"

# Annotations for Engineers
note: |md
  ### Implementation Notes:
  - **Memory Alignment**: Ensure `SHA256_CTX` is 4-byte aligned for `uint32_t` access.
  - **Endianness**: `H` is host-endian during computation; serialized to Big-Endian in `finalize()`.
  - **Re-use**: Must call `sha256_init()` to transition from `state_done` back to `state_ready`.
| {
  near: bottom-center
}