direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SHA-256 Final Output Encoding: Word to Hex String
# Demonstrating the Big-Endian Byte Extraction path for H[0]

title: {
  shape: text
  label: "DATA WALK: H[0..7] TO HEX STRING ENCODING (v1.0)"
  near: top-center
  style: {
    font-size: 24
    bold: true
  }
}

internal_logic: {
  direction: down
  label: "STEP 1: INTERNAL STATE (LOGIC) - (sha256.c)"
  
  h0_word: {
    shape: sql_table
    label: "uint32_t H[0] (Context State)"
    
    row1: "0x00 | uint32_t | 0xBA7816BF"
    label_bottom: "32-bit Big-Endian Representation"
  }
  
  extraction_code: |md
    c
    // Manual Big-Endian Extraction
    // Ensure order: [BA, 78, 16, BF]
    digest[0] = (uint8_t)(H[0] >> 24); 
    digest[1] = (uint8_t)(H[0] >> 16); 
    digest[2] = (uint8_t)(H[0] >>  8); 
    digest[3] = (uint8_t)(H[0] >>  0); 
    
  |
}

binary_digest: {
  direction: down
  label: "STEP 2: BINARY DIGEST (MEMORY) - (sha256.c)"
  
  digest_bytes: {
    shape: sql_table
    label: "uint8_t digest[32]"
    
    b0: "0x00 | 0xBA | digest[0]"
    b1: "0x01 | 0x78 | digest[1]"
    b2: "0x02 | 0x16 | digest[2]"
    b3: "0x03 | 0xBF | digest[3]"
    gap: "... | ... | H[1..7] data"
    label_bottom: "Big-Endian Byte Array"
  }
  
  lookup_logic: |md
    c
    // Hex Nibble Mapping
    static const char h[] = "0123456789abcdef";
    for (int i = 0; i < 32; i++) {
        hex[i*2+0] = h[digest[i] >> 4];   // High
        hex[i*2+1] = h[digest[i] & 0x0F]; // Low
    }
    
  |
}

hex_output: {
  direction: down
  label: "STEP 3: FINAL HEX STRING (ASCII) - (sha256.c)"
  
  hex_chars: {
    shape: sql_table
    label: "char hex[65]"
    
    c0: "0x00 | 'b' | 0x62"
    c1: "0x01 | 'a' | 0x61"
    c2: "0x02 | '7' | 0x37"
    c3: "0x03 | '8' | 0x38"
    c4: "0x04 | '1' | 0x31"
    c5: "0x05 | '6' | 0x36"
    c6: "0x06 | 'b' | 0x62"
    c7: "0x07 | 'f' | 0x66"
    null: "0x40 | '\\0' | 0x00"
    label_bottom: "64 Hex Chars + Null Terminator"
  }
}

# Critical Warning - Positioning fixed for ELK
endianness_trap: {
  near: top-left
  shape: package
  label: "IMPLEMENTATION WARNING"
  style: {
    stroke: red
    fill: "#FFE5E5"
    stroke-width: 3
  }
  content: |md
    **Naive Memcpy Trap:**
    On Little-Endian (x86/ARM):
    `memcpy(digest, &H[0], 4)`
    Result: `BF 16 78 BA` (INCORRECT)
    
    **Requirement:**
    SHA-256 standard mandates Big-Endian.
    Manual shifting is architecture-agnostic.
  |
}

# Data Flow Connections
internal_logic.h0_word -> binary_digest.digest_bytes: "uint8_t[4] | {0xBA, 0x78, 0x16, 0xBF}" {
  style: {
    stroke: blue
    stroke-width: 2
    animated: true
  }
}

binary_digest.digest_bytes -> hex_output.hex_chars: "char[8] | \"ba7816bf\"" {
  style: {
    stroke: blue
    stroke-width: 2
    animated: true
  }
}

# Implementation References
hex_output.hex_chars -> footer_ref: "char*"
footer_ref: "sha256_hex() in sha256.c" {
  shape: rectangle
  style: {
    italic: true
    fill: "#f5f5f5"
  }
}