direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# Evolution of SHA256_CTX (sha256.h)
# L1 State Evolution: Context Lifecycle

uninitialized: {
  label: "STATE: UNINITIALIZED"
  ctx: {
    shape: sql_table
    label: "struct SHA256_CTX (Garbage State)"
    h: "0x00 | uint32_t[8] | H = ???"
    b: "0x20 | uint8_t[64] | buf = ???"
    bl: "0x60 | uint32_t    | buf_len = ???"
    ml: "0x68 | uint64_t    | msg_len_bits = ???"
  }
}

initialized: {
  label: "STATE: READY"
  ctx: {
    shape: sql_table
    label: "struct SHA256_CTX (Clean State)"
    h: "0x00 | uint32_t[8] | H = {0x6A09E667...0x5BE0CD19}"
    b: "0x20 | uint8_t[64] | buf = {0x00...0x00}"
    bl: "0x60 | uint32_t    | buf_len = 0"
    ml: "0x68 | uint64_t    | msg_len_bits = 0"
    label_bottom: "H loaded from sqrt(Primes 2..19)"
  }
}

processing: {
  label: "STATE: STREAMING"
  direction: down
  
  ctx: {
    shape: sql_table
    label: "struct SHA256_CTX (Accumulating)"
    h: "0x00 | uint32_t[8] | H = Intermediate State"
    b: "0x20 | uint8_t[64] | buf = [Partial Block]"
    bl: "0x60 | uint32_t    | buf_len = [0..63]"
    ml: "0x68 | uint64_t    | msg_len_bits = Current Total"
  }

  logic: |md
    c
    // sha256_update logic
    ctx->msg_len_bits += len * 8;
    while (remaining >= 64) {
      sha256_compress(ctx->H, data, W);
      data += 64;
    }
    // Buffer the trailing bytes
    memcpy(ctx->buf, data, len % 64);
    
  |
}

finalizing: {
  label: "STATE: FINALIZING"
  direction: down

  padding_logic: {
    shape: sql_table
    label: "Padding Construction (FIPS 180-4 ยง5.1.1)"
    m: "Byte [buf_len]    | 0x80 (The '1' bit)"
    p: "Bytes [len+1..55] | 0x00 (Zero Padding)"
    l: "Bytes [56..63]    | uint64_t msg_len_bits (BE)"
    label_bottom: "Triggers 1 or 2 final compressions"
  }
}

completed: {
  label: "STATE: DONE"
  digest: {
    shape: code
    label: "uint8_t digest[32]"
    content: |md
      c
      // Big-endian concatenation
      for(int i=0; i<8; i++) {
          be32_enc(digest + i*4, ctx->H[i]);
      }
      
    |
  }
  hex: "ba7816bf8f01cfea...15ad"
  digest -> hex: "sprintf(%02x)"
}

# State Transitions
uninitialized -> initialized: |md
  c
  void sha256_init(SHA256_CTX *ctx);
  
| {
  style: {
    stroke-width: 2
    font-color: "#2b5b84"
  }
}

initialized -> processing: |md
  c
  void sha256_update(SHA256_CTX *ctx, 
                    const uint8_t *data, 
                    size_t len);
  
| {
  style: {
    stroke-width: 2
    font-color: "#2b5b84"
  }
}

processing -> processing: "Append Chunks\n[Any Size]" {
  style: {
    stroke-dash: 5
    animated: true
  }
}

processing -> finalizing: |md
  c
  void sha256_finalize(SHA256_CTX *ctx, 
                      uint8_t digest[32]);
  
| {
  style: {
    stroke-width: 2
    font-color: "#2b5b84"
  }
}

finalizing -> completed: "Last Block(s) Compressed\nState Cleared (memset 0)" {
  style: {
    stroke-width: 2
    font-color: "#2b5b84"
  }
}

# Annotations for Engineers
processing.ctx -> processing.logic: "Refill Logic"
finalizing.padding_logic -> completed.digest: "H[0..7] Final State"

legend: {
  near: bottom-right
  note: "Data Boundary: 512-bit (64-byte) Blocks"
  h_state: "H-State: 256-bit (32-byte) Intermediate"
}