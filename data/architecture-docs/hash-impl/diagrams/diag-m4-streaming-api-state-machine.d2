direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ---------------------------------------------------------------------------------
# Style Definitions
# ---------------------------------------------------------------------------------
classes: {
  state_node: {
    style: {
      stroke-width: 2
      border-radius: 8
    }
  }
  memory_struct: {
    shape: sql_table
    style: {
      fill: "#f8f9fa"
      stroke: "#202124"
    }
  }
  api_call: {
    style: {
      stroke: "#6772E5"
      font-color: "#6772E5"
      bold: true
      animated: true
    }
  }
  hot_path: {
    style: {
      stroke: "#d93025"
      stroke-width: 3
    }
  }
}

# ---------------------------------------------------------------------------------
# L1 - SATELLITE MAP (Logical Layers)
# ---------------------------------------------------------------------------------
API_LAYER: {
  label: "SHA-256 STREAMING API (sha256.h)"
  direction: down

  INIT_STATE: {
    label: "STATE: INITIALIZED"
    class: state_node
    
    ctx_init: {
      label: "struct SHA256_CTX (Memory At Rest)"
      shape: sql_table
      row1: "0x00 | uint32_t[8] | H = {0x6A09E667, ...}"
      row2: "0x20 | uint8_t[64] | buf = {0x00...}"
      row3: "0x60 | size_t      | buf_len = 0"
      row4: "0x68 | uint64_t    | total_len = 0"
      label_bottom: "Total: 108 bytes"
    }
  }

  UPDATING_STATE: {
    label: "STATE: UPDATING (BUFFERING)"
    class: state_node
    
    ctx_update: {
      label: "struct SHA256_CTX (Active Accumulation)"
      shape: sql_table
      row1: "0x00 | uint32_t[8] | H = {Running State}"
      row2: "0x20 | uint8_t[64] | buf = {Partial Data...}"
      row3: "0x60 | size_t      | buf_len = [1..63]"
      row4: "0x68 | uint64_t    | total_len = [N]"
      label_bottom: "Compressed: (total_len - buf_len) bytes"
    }

    logic: |md
      c
      // Buffer Management logic
      size_t space = 64 - buf_len;
      if (incoming >= space) {
          memcpy(buf + buf_len, data, space);
          sha256_compress(H, buf); // 512-bit trigger
          buf_len = 0;
      }
      
    |
  }

  FINAL_STATE: {
    label: "STATE: FINALIZED (TERMINATED)"
    class: state_node
    
    digest_output: {
      label: "Digest (binary output)"
      shape: code
      content: "0xBA7816BF...F20015AD"
    }

    ctx_cleared: {
      label: "struct SHA256_CTX (Security Wipe)"
      shape: sql_table
      row1: "0x00 | uint32_t[8] | H = {0x00...}"
      row2: "0x20 | uint8_t[64] | buf = {0x00...}"
      row3: "0x60 | size_t      | buf_len = 0"
      row4: "0x68 | uint64_t    | total_len = 0"
      label_bottom: "memset(ctx, 0, 108)"
    }
  }
}

# ---------------------------------------------------------------------------------
# L2 - STATE EVOLUTION TRANSITIONS
# ---------------------------------------------------------------------------------

UNINIT: {
  label: "Stack/Heap Allocation"
  shape: cloud
  style.fill: gray
}

UNINIT -> API_LAYER.INIT_STATE: "void sha256_init(SHA256_CTX*)" {
  class: api_call
}

API_LAYER.INIT_STATE -> API_LAYER.UPDATING_STATE: "void sha256_update(ctx, data, len)" {
  class: api_call
  label: "len < 64 bytes"
}

# Internal loop for large updates
API_LAYER.UPDATING_STATE -> API_LAYER.UPDATING_STATE: "Process Block" {
  label: "buf_len + incoming >= 64"
  class: hot_path
  tooltip: "Trigger sha256_compress when 512-bit boundary is hit"
}

API_LAYER.UPDATING_STATE -> API_LAYER.FINAL_STATE: "void sha256_finalize(ctx, digest)" {
  class: api_call
  label: "Append 0x80, Padding, Length"
}

# Logic Trace for the Buffer Transition
API_LAYER.UPDATING_STATE.ctx_update -> API_LAYER.UPDATING_STATE.logic: "State Read"
API_LAYER.UPDATING_STATE.logic -> API_LAYER.UPDATING_STATE.ctx_update: "State Mutation"

# Legend and Metadata
LEGEND: {
  near: bottom-right
  direction: down
  
  c1: "API Function Call" {
    style.stroke: "#6772E5"
    style.stroke-width: 2
  }
  c2: "Compression Hot Path" {
    style.stroke: "#d93025"
    style.stroke-width: 3
  }
  c3: "Memory State (SHA256_CTX)" {
    shape: sql_table
  }
}

notes: {
  near: top-right
  label: |md
    ### Implementation Rules
    1. **Strict Endianness**: All buffer writes (length field) must be Big-Endian.
    2. **56-Byte Boundary**: Finalize MUST check if `buf_len > 56` to spill into 2nd block.
    3. **Zero-Length Guard**: `update(len=0)` is a NO-OP.
  |
}