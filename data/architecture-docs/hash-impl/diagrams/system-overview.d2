direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}
title: |md
  # SHA-256 Implementation Blueprint — FIPS 180-4
  **Language**: C | **Modules**: 4 | **Milestones**: hash-impl-m1 → hash-impl-m4
| {near: top-center}
pipeline_layer: SHA-256 Processing Pipeline {
  style.fill: "#F0F4FF"
  style.stroke: "#3B5BDB"
  style.stroke-width: 2
  style.border-radius: 8
  style.font-size: 18
  style.bold: true
  raw_input: Raw Input {
    style.fill: "#E8F5E9"
    style.stroke: "#43A047"
    style.border-radius: 6
    label: |md
      **Raw Input**
      `const uint8_t *data`
      `size_t len`
      *Arbitrary length*
      *0 to 2^64-1 bits*
    |
  }
  m1_pad: M1: Padding {
    style.fill: "#FFF3E0"
    style.stroke: "#F57C00"
    style.border-radius: 6
    label: |md
      **sha256_padding.c**
      `sha256_pad()`
      *FIPS 180-4 §5.1.1*
      Output: `SHA256_Block[]`
      *Heap-alloc, caller free()*
    |
  }
  m2_sched: M2: Message Schedule {
    style.fill: "#FCE4EC"
    style.stroke: "#C2185B"
    style.border-radius: 6
    label: |md
      **sha256_schedule.c**
      `sha256_message_schedule()`
      *FIPS 180-4 §6.2*
      Output: `uint32_t W[64]`
      *Stack: 256 bytes*
    |
  }
  m3_comp: M3: Compression {
    style.fill: "#EDE7F6"
    style.stroke: "#6A1B9A"
    style.border-radius: 6
    label: |md
      **sha256_compress.c**
      `sha256_compress()`
      *FIPS 180-4 §6.2.2*
      *64 rounds per block*
      *~2000 instr/block*
    |
  }
  m4_out: M4: Output {
    style.fill: "#E3F2FD"
    style.stroke: "#1565C0"
    style.border-radius: 6
    label: |md
      **sha256.c**
      `sha256_finalize()`
      `sha256_hex()`
      Output: `uint8_t[32]`
      *64-char hex string*
    |
  }
  raw_input -> m1_pad: "bytes | any size\ne.g. \"abc\" = 3B"
  m1_pad -> m2_sched: "SHA256_Block* | 64B/block\ne.g. 1 block for len≤55"
  m2_sched -> m3_comp: "uint32_t W[64] | 256B\nW[0]=0x61626380 (abc)"
  m3_comp -> m4_out: "uint32_t H[8] | 32B\ne.g. 0xBA7816BF..."
}
structs_layer: Data Structures {
  style.fill: "#FFFDE7"
  style.stroke: "#F9A825"
  style.stroke-width: 2
  style.border-radius: 8
  style.font-size: 18
  style.bold: true
  sha256_block: SHA256_Block {
    shape: class
    style.fill: "#FFF9C4"
    style.stroke: "#F9A825"
    "bytes: uint8_t[64]": "+0x00 | 64 bytes total | 512 bits"
  }
  sha256_ctx: SHA256_CTX {
    shape: class
    style.fill: "#FFF9C4"
    style.stroke: "#F9A825"
    "H: uint32_t[8]": "+0x00 | 32B | running hash state"
    "buf: uint8_t[64]": "+0x20 | 64B | partial block buffer"
    "buf_len: uint32_t": "+0x60 | 4B | bytes in buf (0-63)"
    "_pad: uint32_t": "+0x64 | 4B | alignment padding"
    "msg_len_bits: uint64_t": "+0x68 | 8B | cumulative bit count"
  }
  sha256_schedule_t: "SHA256_Schedule (W)" {
    shape: class
    style.fill: "#FFF9C4"
    style.stroke: "#F9A825"
    "W[0..15]: uint32_t[16]": "+0x00 | 64B | parsed from block (big-endian)"
    "W[16..63]: uint32_t[48]": "+0x40 | 192B | σ1(W[t-2])+W[t-7]+σ0(W[t-15])+W[t-16]"
  }
  h_init: "H_INIT[8] (constants)" {
    shape: class
    style.fill: "#FFF9C4"
    style.stroke: "#F9A825"
    "H[0]: 0x6A09E667": "frac(sqrt(2)) × 2^32"
    "H[1]: 0xBB67AE85": "frac(sqrt(3)) × 2^32"
    "H[2]: 0x3C6EF372": "frac(sqrt(5)) × 2^32"
    "H[3]: 0xA54FF53A": "frac(sqrt(7)) × 2^32"
    "H[4]: 0x510E527F": "frac(sqrt(11)) × 2^32"
    "H[5]: 0x9B05688C": "frac(sqrt(13)) × 2^32"
    "H[6]: 0x1F83D9AB": "frac(sqrt(17)) × 2^32"
    "H[7]: 0x5BE0CD19": "frac(sqrt(19)) × 2^32"
  }
  k_const: "K[64] Round Constants" {
    shape: class
    style.fill: "#FFF9C4"
    style.stroke: "#F9A825"
    "K[0]: 0x428A2F98": "cbrt(prime[0]=2) frac"
    "K[1]: 0x71374491": "cbrt(prime[1]=3) frac"
    "K[31]: 0x14292967": "cbrt(prime[31]=127) frac"
    "K[63]: 0xC67178F2": "cbrt(prime[63]=311) frac"
  }
}
m1_detail: "M1: Padding Detail (hash-impl-m1)" {
  style.fill: "#FFF8F0"
  style.stroke: "#F57C00"
  style.stroke-width: 2
  style.border-radius: 8
  style.bold: true
  pad_algo: Padding Algorithm {
    style.fill: "#FFE0B2"
    style.stroke: "#E65100"
    style.border-radius: 6
    label: |c
      /* sha256_padding.c */
      /* FIPS 180-4 §5.1.1 */
      /* k = zero-pad bytes */
      k = (64 - ((L+9) % 64)) % 64
      P = L + 1 + k + 8  /* total bytes */
      num_blocks = P / 64
      /* Use calloc: zero-inits padding */
      buf = calloc(num_blocks, 64)
      memcpy(buf, input, L)
      buf[L] = 0x80        /* '1' bit */
      /* zero pad already set by calloc */
      bit_len = (uint64_t)L * 8
      write_u64_be(buf+P-8, bit_len)
    |
  }
  pad_layout: "Block Layout (55-byte boundary)" {
    style.fill: "#FFE0B2"
    style.stroke: "#E65100"
    style.border-radius: 6
    label: |md
      **Single block** (len ≤ 55 bytes):
      `[msg: 0..L-1][0x80][0x00...][len_be: 56..63]`
      **Two blocks** (len ≥ 56 bytes):
      Block 1: `[msg: 0..55][0x80][0x00..63]`
      Block 2: `[0x00..55][len_be: 56..63]`
      **Empty input** (len = 0):
      `[0x80][0x00 × 55][0x00 × 8]` = 1 block
      **"abc"** (len = 3):
      `[61 62 63 80 00...00 00 00 00 18]`
      length field = 24 bits = 0x0000000000000018
    |
  }
  write_u64be: write_u64_be() {
    style.fill: "#FFE0B2"
    style.stroke: "#E65100"
    style.border-radius: 6
    label: |c
      /* sha256_padding.c — internal */
      static void write_u64_be(
        uint8_t *dst,   /* 8-byte target */
        uint64_t value
      ) {
        dst[0] = (uint8_t)(value >> 56); /* MSB */
        dst[1] = (uint8_t)(value >> 48);
        dst[2] = (uint8_t)(value >> 40);
        dst[3] = (uint8_t)(value >> 32);
        dst[4] = (uint8_t)(value >> 24);
        dst[5] = (uint8_t)(value >> 16);
        dst[6] = (uint8_t)(value >>  8);
        dst[7] = (uint8_t)(value >>  0); /* LSB */
      }
      /* Big-endian: MSB first — FIPS mandate */
      /* x86 is LE: NEVER cast uint64_t* directly */
    |
  }
  pad_algo -> pad_layout: "produces | 64B blocks"
  pad_layout -> write_u64be: "calls | 8B length field"
}
m2_detail: "M2: Message Schedule Detail (hash-impl-m2)" {
  style.fill: "#FFF0F5"
  style.stroke: "#C2185B"
  style.stroke-width: 2
  style.border-radius: 8
  style.bold: true
  rotr32: rotr32() primitive {
    style.fill: "#F8BBD0"
    style.stroke: "#880E4F"
    style.border-radius: 6
    label: |c
      /* Inline — sha256_schedule.c */
      /* Rotate right: wrap bits, no loss */
      static inline uint32_t rotr32(
        uint32_t x,
        unsigned int n  /* must be 1..31 */
      ) {
        return (x >> n) | (x << (32u - n));
      }
      /* vs SHR: (x >> n) destroys bits! */
      /* Compiler emits single ROR instr */
      /* NEVER use >> where ROTR needed  */
    |
  }
  load_u32be: load_u32_be() primitive {
    style.fill: "#F8BBD0"
    style.stroke: "#880E4F"
    style.border-radius: 6
    label: |c
      /* Inline — sha256_schedule.c */
      /* Big-endian parse: NEVER cast ptr */
      static inline uint32_t load_u32_be(
        const uint8_t *p  /* 4-byte src */
      ) {
        return ((uint32_t)p[0] << 24)
             | ((uint32_t)p[1] << 16)
             | ((uint32_t)p[2] <<  8)
             | ((uint32_t)p[3] <<  0);
      }
      /* e.g. {0x61,0x62,0x63,0x80}
         -> 0x61626380               */
    |
  }
  sigma_fns: "σ0 / σ1 Functions (lowercase)" {
    style.fill: "#F8BBD0"
    style.stroke: "#880E4F"
    style.border-radius: 6
    label: |c
      /* sha256_schedule.c — schedule only */
      /* DIFFERENT from Σ0/Σ1 compression */
      /* σ0: ROTR(7,18) + SHR(3) */
      static uint32_t sigma0(uint32_t x) {
        return rotr32(x, 7)   /* wrap */
             ^ rotr32(x, 18)  /* wrap */
             ^ (x >> 3);      /* destroy */
      }
      /* σ1: ROTR(17,19) + SHR(10) */
      static uint32_t sigma1(uint32_t x) {
        return rotr32(x, 17)  /* wrap */
             ^ rotr32(x, 19)  /* wrap */
             ^ (x >> 10);     /* destroy */
      }
      /* KAT: sigma1(0x18) = 0x000F0000 */
    |
  }
  expansion: Schedule Expansion Loop {
    style.fill: "#F8BBD0"
    style.stroke: "#880E4F"
    style.border-radius: 6
    label: |c
      /* sha256_schedule.c */
      void sha256_message_schedule(
        const SHA256_Block *block,
        uint32_t W[64]   /* 256B output */
      ) {
        /* Stage 1: Parse W[0..15] BE */
        for (int t = 0; t < 16; t++)
          W[t] = load_u32_be(
                   block->bytes + t*4);
        /* Stage 2: Expand W[16..63] */
        /* W[t] = σ1(W[t-2]) + W[t-7]
                + σ0(W[t-15]) + W[t-16] */
        for (int t = 16; t < 64; t++)
          W[t] = sigma1(W[t-2])
               + W[t-7]
               + sigma0(W[t-15])
               + W[t-16];
        /* uint32_t wraps at 2^32 auto */
      }
      /* KAT "abc": W[0]=0x61626380
         W[15]=0x00000018
         W[16]=0x61626380
         W[17]=0x000F0000         */
    |
  }
  rotr32 -> sigma_fns: "used by | 32-bit rotate"
  load_u32be -> expansion: "parse bytes | W[0..15]"
  sigma_fns -> expansion: "diffuse | W[16..63]"
}
m3_detail: "M3: Compression Detail (hash-impl-m3)" {
  style.fill: "#F3E5F5"
  style.stroke: "#6A1B9A"
  style.stroke-width: 2
  style.border-radius: 8
  style.bold: true
  nonlinear_fns: "Ch / Maj — Nonlinear Functions" {
    style.fill: "#E1BEE7"
    style.stroke: "#4A148C"
    style.border-radius: 6
    label: |c
      /* sha256_op_primitives.h */
      /* Ch(x,y,z): if x then y else z */
      /* 32-bit-wide 2:1 multiplexer   */
      static inline uint32_t ch(
          uint32_t x, uint32_t y, uint32_t z) {
        return (x & y) ^ (~x & z);
      }
      /* Ch(0xFF,y,z)=y; Ch(0,y,z)=z */
      /* Maj(x,y,z): majority vote     */
      /* bit=1 if ≥2 of x,y,z are 1   */
      static inline uint32_t maj(
          uint32_t x, uint32_t y, uint32_t z) {
        return (x & y) ^ (x & z) ^ (y & z);
      }
      /* Maj(1,1,0)=1; Maj(1,0,0)=0  */
      /* These are minimum nonlinearity */
    |
  }
  sigma_upper: "Σ0 / Σ1 — UPPERCASE (compression only)" {
    style.fill: "#E1BEE7"
    style.stroke: "#4A148C"
    style.border-radius: 6
    label: |c
      /* sha256_op_primitives.h */
      /* WARNING: DIFFERENT from σ0/σ1  */
      /* Three ROTRs, no SHR = invertible*/
      /* Σ0: applied to variable 'a'    */
      static inline uint32_t Sigma0(uint32_t x) {
        return rotr32(x,  2)   /* (2,13,22) */
             ^ rotr32(x, 13)
             ^ rotr32(x, 22);
      }
      /* Σ1: applied to variable 'e'    */
      static inline uint32_t Sigma1(uint32_t x) {
        return rotr32(x,  6)   /* (6,11,25) */
             ^ rotr32(x, 11)
             ^ rotr32(x, 25);
      }
      /* σ constants: (7,18,3)(17,19,10)*/
      /* Σ constants: (2,13,22)(6,11,25)*/
    |
  }
  round_loop: "64-Round Compression Loop" {
    style.fill: "#E1BEE7"
    style.stroke: "#4A148C"
    style.border-radius: 6
    label: |c
      /* sha256_compress.c */
      void sha256_compress(
        uint32_t H[8],            /* in/out */
        const SHA256_Block *block,
        uint32_t W[64]            /* workspace */
      ) {
        sha256_message_schedule(block, W);
        /* Init working vars from H */
        uint32_t a=H[0],b=H[1],c=H[2],d=H[3],
                 e=H[4],f=H[5],g=H[6],h=H[7];
        for (int t = 0; t < 64; t++) {
          uint32_t T1 = h + Sigma1(e)
                      + ch(e,f,g) + K[t] + W[t];
          uint32_t T2 = Sigma0(a) + maj(a,b,c);
          h=g; g=f; f=e; e=d+T1; /* e-group */
          d=c; c=b; b=a; a=T1+T2; /* a-group */
        }
        /* Davies-Meyer feed-forward */
        H[0]+=a; H[1]+=b; H[2]+=c; H[3]+=d;
        H[4]+=e; H[5]+=f; H[6]+=g; H[7]+=h;
      }
      /* Round 0 KAT: a=0x5D6AEBB1 */
      /* Final KAT "abc": H[0]=0xBA7816BF */
    |
  }
  state_after: "Before/After State (abc, Round 0)" {
    style.fill: "#E1BEE7"
    style.stroke: "#4A148C"
    style.border-radius: 6
    label: |md
      **BEFORE** (H_INIT loaded into a..h):
      a=0x6A09E667 b=0xBB67AE85
      c=0x3C6EF372 d=0xA54FF53A
      e=0x510E527F f=0x9B05688C
      g=0x1F83D9AB h=0x5BE0CD19
      **AFTER Round 0** (NIST Appendix B.1):
      a=0x5D6AEBB1 b=0x6A09E667
      c=0xBB67AE85 d=0x3C6EF372
      e=0xFA2A4622 f=0x510E527F
      g=0x9B05688C h=0x1F83D9AB
      **AFTER all 64 rounds + H+=**:
      H[0]=0xBA7816BF H[1]=0x8F01CFEA
      H[2]=0x414140DE H[3]=0x5DAE2223
      H[4]=0xB00361A3 H[5]=0x96177A9C
      H[6]=0xB410FF61 H[7]=0xF20015AD
    |
  }
  nonlinear_fns -> round_loop: "Ch,Maj | per round"
  sigma_upper -> round_loop: "Σ0,Σ1 | per round"
  round_loop -> state_after: "state | 32B × 2"
}
m4_detail: "M4: Streaming API Detail (hash-impl-m4)" {
  style.fill: "#E8F4FD"
  style.stroke: "#1565C0"
  style.stroke-width: 2
  style.border-radius: 8
  style.bold: true
  init_fn: sha256_init() {
    style.fill: "#BBDEFB"
    style.stroke: "#0D47A1"
    style.border-radius: 6
    label: |c
      /* sha256.c */
      void sha256_init(SHA256_CTX *ctx) {
        /* Load FIPS 180-4 §5.3.3 IVs */
        for (int i=0; i<8; i++)
          ctx->H[i] = SHA256_H_INIT[i];
        memset(ctx->buf, 0, 64);
        ctx->buf_len = 0;
        ctx->msg_len_bits = 0;
        /* SECURITY: must call before every */
        /* new message — IV reuse is fatal   */
      }
      /* Post: H=H_INIT, buf_len=0,
         msg_len_bits=0              */
    |
  }
  update_fn: sha256_update() {
    style.fill: "#BBDEFB"
    style.stroke: "#0D47A1"
    style.border-radius: 6
    label: |c
      /* sha256.c — 3-phase buffer mgmt */
      void sha256_update(SHA256_CTX *ctx,
        const uint8_t *data, size_t len) {
        ctx->msg_len_bits += (uint64_t)len*8;
        /* Phase 1: fill partial buffer */
        if (ctx->buf_len > 0) {
          uint32_t sp = 64 - ctx->buf_len;
          uint32_t tk = (len<sp)?len:sp;
          memcpy(ctx->buf+ctx->buf_len,data,tk);
          ctx->buf_len += tk;
          data += tk; len -= tk;
          if (ctx->buf_len == 64) {
            sha256_compress(ctx->H,
              (SHA256_Block*)ctx->buf, W);
            ctx->buf_len = 0;
          }
        }
        /* Phase 2: bulk 64B blocks */
        while (len >= 64) {
          sha256_compress(ctx->H,
            (SHA256_Block*)data, W);
          data += 64; len -= 64;
        }
        /* Phase 3: buffer remainder */
        if (len > 0) {
          memcpy(ctx->buf+ctx->buf_len,data,len);
          ctx->buf_len += len;
        }
      }
      /* Invariant: buf_len ∈ [0,63] always */
    |
  }
  finalize_fn: sha256_finalize() {
    style.fill: "#BBDEFB"
    style.stroke: "#0D47A1"
    style.border-radius: 6
    label: |c
      /* sha256.c */
      void sha256_finalize(SHA256_CTX *ctx,
        uint8_t digest[32]) {
        /* Append 0x80 separator */
        ctx->buf[ctx->buf_len++] = 0x80;
        if (ctx->buf_len <= 56) {
          /* 1-block path: len was ≤55B */
          memset(ctx->buf+ctx->buf_len,
                 0, 56-ctx->buf_len);
        } else {
          /* 2-block path: len was ≥56B */
          memset(ctx->buf+ctx->buf_len,
                 0, 64-ctx->buf_len);
          sha256_compress(ctx->H,
            (SHA256_Block*)ctx->buf, W);
          memset(ctx->buf, 0, 56);
        }
        /* Write 64-bit length BE */
        ctx->buf[56]=(ctx->msg_len_bits>>56);
        /* ... through ctx->buf[63] */
        sha256_compress(ctx->H,
          (SHA256_Block*)ctx->buf, W);
        /* Extract digest: H[] -> BE bytes */
        for (int i=0; i<8; i++) {
          digest[i*4+0]=(ctx->H[i]>>24);
          digest[i*4+1]=(ctx->H[i]>>16);
          digest[i*4+2]=(ctx->H[i]>> 8);
          digest[i*4+3]=(ctx->H[i]>> 0);
        }
        secure_memzero(ctx->buf, 64);
      }
    |
  }
  hex_fn: sha256_hex() {
    style.fill: "#BBDEFB"
    style.stroke: "#0D47A1"
    style.border-radius: 6
    label: |c
      /* sha256.c */
      void sha256_hex(
        const uint8_t digest[32],
        char hex[65]  /* 64 chars + '\0' */
      ) {
        static const char h[] =
          "0123456789abcdef";
        for (int i = 0; i < 32; i++) {
          hex[i*2+0] = h[digest[i] >> 4];
          hex[i*2+1] = h[digest[i] & 0xF];
        }
        hex[64] = '\0';
      }
      /* Each byte → 2 hex chars (nibbles) */
      /* lowercase per NIST convention     */
    |
  }
  init_fn -> update_fn: "state | SHA256_CTX*"
  update_fn -> finalize_fn: "state | buf_len: 0-63B"
  finalize_fn -> hex_fn: "digest | 32B binary"
}
kat_layer: "NIST Known Answer Tests (KATs)" {
  style.fill: "#F1F8E9"
  style.stroke: "#558B2F"
  style.stroke-width: 2
  style.border-radius: 8
  style.bold: true
  kat1: "KAT-1: Empty String" {
    style.fill: "#DCEDC8"
    style.stroke: "#33691E"
    style.border-radius: 6
    label: |md
      **Input**: `""` (0 bytes)
      **Blocks**: 1
      **Pad**: `[0x80][0x00×55][0x00×8]`
      **W[0]**: 0x80000000
      **Expected**:
      `e3b0c44298fc1c14`
      `9afbf4c8996fb924`
      `27ae41e4649b934c`
      `a495991b7852b855`
    |
  }
  kat2: "KAT-2: abc (3 bytes)" {
    style.fill: "#DCEDC8"
    style.stroke: "#33691E"
    style.border-radius: 6
    label: |md
      **Input**: `"abc"` (3 bytes, 24 bits)
      **Blocks**: 1 (len ≤ 55)
      **W[0]**: 0x61626380
      **W[15]**: 0x00000018
      **W[16]**: 0x61626380
      **W[17]**: 0x000F0000
      **Expected**:
      `ba7816bf8f01cfea`
      `414140de5dae2223`
      `b00361a396177a9c`
      `b410ff61f20015ad`
    |
  }
  kat3: "KAT-3: 56-byte string" {
    style.fill: "#DCEDC8"
    style.stroke: "#33691E"
    style.border-radius: 6
    label: |md
      **Input**: `"abcdbcde...nopnopq"`
      *56 bytes = two-block boundary!*
      **len ≥ 56 → 2 padding blocks**
      Length field: 448 bits = 0x1C0
      Block 1: `[msg56][0x80][0x00×7]`
      Block 2: `[0x00×56][0x01C0_BE]`
      **Expected**:
      `248d6a61d20638b8`
      `e5c026930c3e6039`
      `a33ce45964ff2167`
      `f6ecedd419db06c1`
    |
  }
  kat1 -> kat2: "boundary test order"
  kat2 -> kat3: "critical 55↔56 boundary"
}
error_paths: "Error Paths & Security" {
  style.fill: "#FFEBEE"
  style.stroke: "#B71C1C"
  style.stroke-width: 2
  style.border-radius: 8
  style.bold: true
  alloc_fail: "Allocation Failure" {
    style.fill: "#FFCDD2"
    style.stroke: "#C62828"
    style.border-radius: 6
    style.stroke-dash: 5
    label: |md
      `calloc()` returns NULL
      → set `*num_blocks = 0`
      → return NULL to caller
      *Caller checks return value*
    |
  }
  state_leak: "State Contamination" {
    style.fill: "#FFCDD2"
    style.stroke: "#C62828"
    style.border-radius: 6
    style.stroke-dash: 5
    label: |md
      **Risk**: Reuse ctx without init
      → H[] has previous block state
      → Wrong hash, not detectable
      **Fix**: ALWAYS call sha256_init()
      before new message computation
      *Analogous to IV-reuse in AES-GCM*
    |
  }
  secure_zero: "secure_memzero()" {
    style.fill: "#FFCDD2"
    style.stroke: "#C62828"
    style.border-radius: 6
    style.stroke-dash: 5
    label: |c
      /* Prevent compiler elision */
      static void secure_memzero(
        void *p, size_t len) {
        volatile uint8_t *ptr =
          (volatile uint8_t *)p;
        while (len--) *ptr++ = 0;
      }
      /* Called in finalize() on buf,W */
      /* Prevents Heartbleed-class leak */
    |
  }
  overflow_guard: "Integer Overflow Guard" {
    style.fill: "#FFCDD2"
    style.stroke: "#C62828"
    style.border-radius: 6
    style.stroke-dash: 5
    label: |c
      /* WRONG on 32-bit systems: */
      /* input_len * 8  ← overflows! */
      /* CORRECT — cast first: */
      uint64_t bit_length =
        (uint64_t)input_len * 8;
      /* 600MB: 6e8 bytes × 8
         = 4.8e9 bits → needs uint64_t */
    |
  }
}
pipeline_layer -> structs_layer: "uses | SHA256_Block, SHA256_CTX"
pipeline_layer.m1_pad -> m1_detail: "implements"
pipeline_layer.m2_sched -> m2_detail: "implements"
pipeline_layer.m3_comp -> m3_detail: "implements"
pipeline_layer.m4_out -> m4_detail: "implements"
m4_detail -> kat_layer: "validated by | FIPS 180-4 KATs"
m4_detail.finalize_fn -> error_paths.secure_zero: "calls | zero 64B buf"
m1_detail.pad_algo -> error_paths.alloc_fail: "calloc may fail | NULL check"
m4_detail.init_fn -> error_paths.state_leak: "prevents | full reset"
m1_detail.write_u64be -> error_paths.overflow_guard: "uses | (uint64_t)L*8"
structs_layer.sha256_block -> m1_detail: "produced by | 64B each"
structs_layer.sha256_ctx -> m4_detail: "managed by | 112B total"
structs_layer.sha256_schedule_t -> m2_detail: "output of | 256B stack"
structs_layer.h_init -> m3_detail: "initializes | H[0..7]"
structs_layer.k_const -> m3_detail: "feeds | K[t] per round"