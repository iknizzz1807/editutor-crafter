direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- Module: sha256_m3_compression ---
sha256_m3_compression: {
  label: "SHA-256 Compression Module (M3)\nFIPS 180-4 Section 6.2.2"
  style: {
    stroke-width: 2
    fill: "#f8f9fa"
  }

  # --- Public Interface ---
  public_api: {
    sha256_compress: {
      shape: sql_table
      label: "void sha256_compress()"
      H: "uint32_t[8] (In/Out)"
      block: "const SHA256_Block* (In)"
      W: "uint32_t[64] (Workspace)"
      "sizeof": "Stack overhead: ~64B (excluding W)"
    }
  }

  # --- Constant Arrays (Stored in .rodata) ---
  constants: {
    label: "Static Constants"
    K_constants: {
      shape: sql_table
      label: "static const uint32_t K[64]"
      values: "Cube roots of first 64 primes"
      size: "256 bytes"
      style.fill: "#e1d5e7"
    }
    H_INIT: {
      shape: sql_table
      label: "static const uint32_t H_INIT[8]"
      values: "Square roots of first 8 primes"
      size: "32 bytes"
      style.fill: "#e1d5e7"
    }
  }

  # --- Inline Bitwise Primitives ---
  inline_ops: {
    label: "Inline Arithmetic Primitives (32-bit)"
    style.fill: "#dae8fc"

    rotr32: "rotr32(x, n): (x >> n) | (x << (32-n))"
    ch: "ch(x, y, z): (x & y) ^ (~x & z)"
    maj: "maj(x, y, z): (x & y) ^ (x & z) ^ (y & z)"
    Sigma0: "Sigma0(x): ROTR2(x) ^ ROTR13(x) ^ ROTR22(x)"
    Sigma1: "Sigma1(x): ROTR6(x) ^ ROTR11(x) ^ ROTR25(x)"
  }

  # --- Internal Processing Logic ---
  processing_flow: {
    label: "sha256_compress Internal Logic"
    
    init_vars: "1. Load working variables\n[a,b,c,d,e,f,g,h] = H[0..7]"
    
    round_loop: {
      label: "2. Round Execution (64 iterations)"
      style.stroke-dash: 3
      
      calculate_t1: "T1 = h + Sigma1(e) + ch(e,f,g) + K[t] + W[t]"
      calculate_t2: "T2 = Sigma0(a) + maj(a,b,c)"
      shift_state: "Rotate: h=g, g=f, f=e, e=d+T1, d=c, c=b, b=a, a=T1+T2"
      
      calculate_t1 -> calculate_t2 -> shift_state
    }
    
    davies_meyer: "3. Final State Update\nH[i] = H[i] + working_var[i] (mod 2^32)"
    
    init_vars -> round_loop -> davies_meyer
  }
}

# --- External Dependencies ---
m2_module: {
  label: "Message Schedule (M2)"
  sha256_message_schedule: "void sha256_message_schedule(block, W)"
  style.fill: "#fff2cc"
}

# --- Relationships & Call Sequence ---
sha256_m3_compression.public_api.sha256_compress -> m2_module.sha256_message_schedule: "1. Prepare Schedule" {
  style.stroke-width: 2
}

sha256_m3_compression.public_api.sha256_compress -> sha256_m3_compression.processing_flow.init_vars: "2. Execute"

sha256_m3_compression.processing_flow.round_loop.calculate_t1 -- sha256_m3_compression.constants.K_constants: "Read K[t]" {
  style.stroke-dash: 5
}

sha256_m3_compression.processing_flow.round_loop.calculate_t1 -- sha256_m3_compression.inline_ops.Sigma1: "Inlines"
sha256_m3_compression.processing_flow.round_loop.calculate_t1 -- sha256_m3_compression.inline_ops.ch: "Inlines"
sha256_m3_compression.processing_flow.round_loop.calculate_t2 -- sha256_m3_compression.inline_ops.Sigma0: "Inlines"
sha256_m3_compression.processing_flow.round_loop.calculate_t2 -- sha256_m3_compression.inline_ops.maj: "Inlines"

# Legend/Annotations
notes: |md
  ### Implementation Notes
  - **Modular Addition**: All '+' ops are $mod\ 2^{32}$.
  - **Davies-Meyer**: The final $H_i$ update prevents trivial inversion of the compression rounds.
  - **Workspace (W)**: Passed as a pointer to avoid 256B stack allocation in tight loops.
| {
  near: bottom-center
}