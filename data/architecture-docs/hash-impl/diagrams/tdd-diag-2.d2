vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 0
  }
}

SHA256_LAYOUT: {
  shape: sql_table
  label: "SHA-256 Memory Layout: 56-Byte Message Overflow"

  # Byte Offset | Field Name | Size (Constraint)
  "0x00": "Message Data (Payload)" {
    constraint: "56B"
    style: {
      fill: "#dae8fc" # Blue: Data
      bold: true
    }
  }
  
  "0x38": "Separator (0x80)" {
    constraint: "1B"
    style: {
      fill: "#e1d5e7" # Purple: Header/Separator
    }
  }

  "0x39": "Zero Padding Block 0" {
    constraint: "7B"
    style: {
      fill: "#f5f5f5" # Gray: Padding
    }
  }

  # Block Boundary (64B / 512-bit)
  "----": "BLOCK 0 BOUNDARY (64 BYTES / 512 BITS)" {
    style: {
      stroke-dash: 5
    }
  }

  "0x40": "Extended Zero Padding Block 1" {
    constraint: "56B"
    style: {
      fill: "#f5f5f5" # Gray: Padding
    }
  }

  "0x78": "Length Field (64-bit Integer)" {
    constraint: "8B"
    style: {
      fill: "#dae8fc" # Blue: Data
      bold: true
    }
  }

  "-----": "TOTAL ALLOCATED SIZE: 128 BYTES (2 BLOCKS)" {
    style: {
      stroke-width: 4
    }
  }
}

ANNOTATION: |md
  ### Overflow Logic
  A message of **56 bytes** requires two blocks because:
  - Message Length: 56 bytes
  - Separator: 1 byte (0x80)
  - Length Field: 8 bytes
  - **Sum**: 56 + 1 + 8 = **65 bytes**
  - **Single Block Capacity**: 64 bytes
  
  Since **65 > 64**, the length field is pushed into the final 8 bytes of **Block 1**.
| {
  near: bottom-center
  style: {
    stroke-width: 0
    fill: transparent
  }
}