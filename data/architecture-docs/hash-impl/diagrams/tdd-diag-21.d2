layout-engine: elk
vars: {
  d2-config: {
    theme-id: 6
    layout-engine: elk
  }
}

# START POINT
start: "" {
  shape: circle
  style: {
    fill: black
    stroke-width: 0
  }
}

# STATE DEFINITIONS
UNINITIALIZED: "UNINITIALIZED" {
  tooltip: "Memory allocated but not set."
  style.stroke-width: 2
  invariants: |md
    - `H[0..7]` = random
    - `buf_len` = random
    - `msg_len_bits` = random
  |
}

INITIALIZED: "INITIALIZED (Empty)" {
  style.stroke-width: 4
  invariants: |md
    - `H` = `SHA256_H_INIT`
    - `buf_len` = 0
    - `msg_len_bits` = 0
  |
}

ACCUMULATING: "ACCUMULATING" {
  style.stroke-width: 2
  invariants: |md
    - `0 < buf_len < 64`
    - `msg_len_bits` > 0
    - `H` = intermediate state
  |
}

COMPRESSING: "COMPRESSING" {
  tooltip: "Transient state during block processing."
  style: {
    stroke-dash: 5
    fill: "#eef"
  }
  invariants: |md
    - `buf_len` == 64
    - `W[0..63]` = generated
    - `sha256_compress()` active
  |
}

FINALIZED: "FINALIZED" {
  style: {
    stroke-width: 2
    fill: "#dfd"
  }
  invariants: |md
    - `digest` = 32 bytes
    - `SHA256_CTX` = secure_zeroed
  |
}

ERROR_STATE: "ILLEGAL OPERATION" {
  style: {
    fill: "#fdd"
    stroke: red
    stroke-width: 4
  }
}

# TRANSITIONS
start -> UNINITIALIZED: "malloc / stack allocation"

UNINITIALIZED -> INITIALIZED: "sha256_init()" {
  label: "Action: Load H_INIT, Zero buf_len"
}

INITIALIZED -> ACCUMULATING: "sha256_update(data, len < 64)" {
  label: "Guard: total < 64\nAction: memcpy to buf"
}

INITIALIZED -> COMPRESSING: "sha256_update(data, len >= 64)" {
  label: "Guard: len >= 64\nAction: Bypass buf / direct compress"
}

ACCUMULATING -> ACCUMULATING: "sha256_update()" {
  label: "Guard: total < 64\nAction: append to buf"
}

ACCUMULATING -> COMPRESSING: "sha256_update()" {
  label: "Guard: total >= 64\nAction: Fill buf to 64"
}

COMPRESSING -> COMPRESSING: "Bulk processing" {
  label: "Guard: remaining >= 64\nAction: compress(data)"
}

COMPRESSING -> ACCUMULATING: "Remainder" {
  label: "Guard: remaining < 64\nAction: Copy to buf"
}

ACCUMULATING -> FINALIZED: "sha256_finalize()" {
  label: "Action: Pad block(s), Final compress"
}

INITIALIZED -> FINALIZED: "sha256_finalize()" {
  label: "Action: Pad empty block (0x80...00)"
}

FINALIZED -> INITIALIZED: "sha256_init()" {
  label: "Action: Re-load H_INIT"
}

# ILLEGAL TRANSITIONS
FINALIZED -> ERROR_STATE: "sha256_update()" {
  style: {
    stroke: red
    stroke-dash: 3
  }
  label: "ILLEGAL: Update after finalize"
}

UNINITIALIZED -> ERROR_STATE: "sha256_finalize()" {
  style: {
    stroke: red
    stroke-dash: 3
  }
  label: "ILLEGAL: Finalize before init"
}

# LEGEND / ANNOTATIONS
legend: {
  near: bottom-right
  "â—": "Start"
  "--": "Valid Transition"
  "- - ->": "Illegal / Error"
}

notes: |md
  ### SHA256_CTX Streaming Rules
  1. `sha256_init` must be called to transition out of **UNINITIALIZED**.
  2. `COMPRESSING` is a logic loop within `sha256_update` or `sha256_finalize`.
  3. Context is unusable after `finalize` until `init` is called again.
| {
  near: top-right
}