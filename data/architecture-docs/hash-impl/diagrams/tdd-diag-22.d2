direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SHA-256 UPDATE: THREE-PHASE STREAMING LOGIC
# INVARIANT: ctx->buf_len is ALWAYS in range [0, 63] at entry and exit

UpdateRoutine: {
  label: "sha256_update(ctx, data, len)"

  Step1: {
    label: "1. Phase 1: Context Buffer Check"
    ctx_state: |md
      **Input State**:
      - buf_len: `ctx->buf_len`
      - len: `len`
    |
    Decision: "ctx->buf_len > 0?" {
      shape: diamond
    }
  }

  Step2: {
    label: "2. Phase 1: Fill & Partial Compress"
    style: {
      stroke: "#d73a49"
      stroke-width: 4
    }
    Logic: |md
      **Actions**:
      1. space = 64 - buf_len
      2. take = min(len, space)
      3. memcpy(**ctx->buf + buf_len**, data, take)
      4. **ctx->buf_len** += take
      5. **data** += take, **len** -= take
    |
    CheckFull: "buf_len == 64?" {
      shape: diamond
    }
    Compress: "sha256_compress(ctx->h, ctx->buf)\n**ctx->buf_len = 0**" {
      style.font-color: "#d73a49"
      style.bold: true
    }
  }

  Step3: {
    label: "3. Phase 2: Bulk Fast-Path Loop"
    Logic: |md
      **While len >= 64**:
      1. sha256_compress(ctx->h, **data**)
      2. **data** += 64
      3. **len** -= 64
    |
    Annotation: "BYPASSES ctx->buf" {
      style.italic: true
    }
  }

  Step4: {
    label: "4. Phase 3: Remainder Buffering"
    style: {
      stroke: "#d73a49"
      stroke-width: 4
    }
    Decision: "len > 0?" {
      shape: diamond
    }
    FillRemainder: |md
      **Actions**:
      1. memcpy(**ctx->buf**, data, len)
      2. **ctx->buf_len** = len
    |
  }

  Exit: {
    shape: circle
    label: "DONE"
    style.fill: "#28a745"
  }

  # Internal Transitions
  Step1.Decision -> Step2.Logic: "Yes"
  Step1.Decision -> Step3: "No"
  
  Step2.Logic -> Step2.CheckFull
  Step2.CheckFull -> Step2.Compress: "Yes"
  Step2.CheckFull -> Step3: "No"
  Step2.Compress -> Step3

  Step3 -> Step4.Decision
  
  Step4.Decision -> Step4.FillRemainder: "Yes"
  Step4.Decision -> Exit: "No"
  Step4.FillRemainder -> Exit
}

# Global State Annotations (Fixed near reference for ELK)
Annotations: {
  near: bottom-right
  style.stroke: orange
  Invariant: |md
    ### POST-CONDITION INVARIANT
    - **ctx->buf_len** < 64
    - **ctx->msg_len_bits** += original_len * 8
  |
}

# Memory Layout Visualization (Context Buffer)
BufferVisual: {
  label: "sizeof=64 bytes (one cache line)"
  grid-columns: 1
  style.stroke: "#0366d6"
  
  Header: "ctx->buf (64 Bytes Aligned)" {
    style.fill: "#6e42c1"
    style.font-color: white
  }

  Layout: {
    grid-columns: 8
    grid-gap: 0
    
    B0: "0x00"; B1: "0x01"; B2: "0x02"; B3: "0x03"; B4: "0x04"; B5: "0x05"; B6: "0x06"; B7: "..."
    B0.style.fill: "#0366d6" # Data (Blue)
    B1.style.fill: "#0366d6"
    B2.style.fill: "#0366d6"
    B3.style.fill: "#6c757d" # Padding/Free (Gray)
    B4.style.fill: "#6c757d"
    B5.style.fill: "#6c757d"
    B6.style.fill: "#6c757d"
    B7.style.fill: "#6c757d"
  }
  
  Legend: {
    shape: text
    label: "Blue: Data | Gray: Free"
  }
}

# Connections between flow and memory
UpdateRoutine.Step2 -> BufferVisual: "Update ctx->buf_len" {
  style: {
    stroke-dash: 5
    stroke: orange
  }
}

UpdateRoutine.Step4 -> BufferVisual: "Final Copy" {
  style: {
    stroke-dash: 5
    stroke: orange
  }
}