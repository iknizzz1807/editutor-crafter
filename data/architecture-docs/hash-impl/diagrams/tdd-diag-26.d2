direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

title: {
  label: |'md
# NIST KAT Validation Matrix
### SHA-256 Block Counts and Padding Boundaries
  '|
  shape: text
  near: top-center
}

legend: {
  near: top-right
  msg_data: {
    label: "Message Data"
    style.fill: "#b9d1ea"
  }
  separator: {
    label: "0x80 Separator"
    style.fill: "#e0e0e0"
  }
  zero_padding: {
    label: "Zero Padding"
    style.fill: "#d5f5e3"
  }
  length_field: {
    label: "64-bit Length"
    style.fill: "#f5cba7"
  }
}

validation_matrix: {
  shape: rectangle
  style.stroke: "#333333"
  style.stroke-width: 2
  label: |'md
| Input Message | Byte Len | Blocks | Expected Hex (Prefix) | Layout Trace |
| :--- | :---: | :---: | :--- | :--- |
| `""` (Empty) | 0 B | 1 | `e3b0c442...` | See Block_T1 |
| `"abc"` | 3 B | 1 | `ba7816bf...` | See Block_T2 |
| `"abcd...p q"` | 56 B | 2 | `248d6a61...` | See Block_T3 |
  '|
}

thumbnails: {
  grid-columns: 1
  grid-gap: 60

  block_t1: {
    label: "Case 1: Empty String (1 Block Total)"
    
    container: {
      grid-columns: 3
      grid-gap: 0
      
      sep: {
        label: "0x80 (1B)"
        width: 60
        style.fill: "#e0e0e0"
      }
      padding: {
        label: "Zero Padding (55B)"
        width: 340
        style.fill: "#d5f5e3"
      }
      len: {
        label: "Length: 0 (8B)"
        width: 100
        style.fill: "#f5cba7"
      }
    }
    container.sep -> container.padding: "offset 0x01" {
      style.stroke-dash: 3
    }
    container.padding -> container.len: "offset 0x38" {
      style.stroke-dash: 3
    }
  }

  block_t2: {
    label: "Case 2: 'abc' (1 Block Total)"
    
    container: {
      grid-columns: 4
      grid-gap: 0
      
      data: {
        label: "abc (3B)"
        width: 80
        style.fill: "#b9d1ea"
      }
      sep: {
        label: "0x80 (1B)"
        width: 60
        style.fill: "#e0e0e0"
      }
      padding: {
        label: "Zero Padding (52B)"
        width: 260
        style.fill: "#d5f5e3"
      }
      len: {
        label: "Length: 24 (8B)"
        width: 100
        style.fill: "#f5cba7"
      }
    }
  }

  block_t3: {
    label: "Case 3: 56-Byte Boundary (2 Blocks Total)"
    grid-columns: 1
    grid-gap: 20
    
    block_a: {
      label: "Block 1: Overflow Boundary"
      grid-columns: 2
      grid-gap: 0
      data: {
        label: "Message Data (56B)"
        width: 440
        style.fill: "#b9d1ea"
      }
      sep: {
        label: "0x80 (1B)"
        width: 60
        style.fill: "#e0e0e0"
      }
    }
    
    block_b: {
      label: "Block 2: Padding + Length"
      grid-columns: 2
      grid-gap: 0
      padding: {
        label: "Zero Padding (56B)"
        width: 400
        style.fill: "#d5f5e3"
      }
      len: {
        label: "Length: 448 (8B)"
        width: 100
        style.fill: "#f5cba7"
      }
    }
  }
}

boundary_note: {
  label: |'md
### Row 3 Boundary Condition
**Input (56B) + Sep (1B) + Len (8B) = 65B**
Since 65 > 64 (Block Size), the length field 
is forced into Block 2.
  '|
  shape: text
  style.font-color: "#ca052b"
  # near: thumbnails.block_t3  # removed: elk requires constant
}

streaming_logic: {
  label: "Streaming State Consistency"
  
  input: {
    label: "Chunked Stream"
    shape: cylinder
  }
  
  hasher: {
    label: "SHA256_Update"
    shape: circle
  }
  
  state: {
    label: "H[0..7] (256-bit State)"
    style.fill: "#b9d1ea"
    style.multiple: true
  }
  
  input -> hasher: "Any chunk size (1B, 7B, 64B)"
  hasher -> state: "Compress if buffer full"
}

validation_matrix -> thumbnails: "Block Layout Trace"
thumbnails -> streaming_logic: "Final Digest Check"

footer_annotation: {
  label: |'md
**Implementation Grade Diagram**
Fields are exactly sized to 512-bit (64-byte) alignment boundaries.
  '|
  shape: text
  # near: validation_matrix  # removed: elk requires constant
  style.italic: true
}