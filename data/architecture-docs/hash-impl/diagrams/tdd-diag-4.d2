layout-engine: elk
vars: {
  d2-config: {
    theme-id: 4
    pad: 20
  }
}

# LEGEND (Root Level to satisfy 'near' constraint)
Legend: {
  near: top-right
  grid-columns: 2
  grid-gap: 10
  Data: { style.fill: "#B6DDF6" }
  "Message Data": { shape: text }
  Sentinel: { style.fill: "#E1D5E7" }
  "Sentinel (0x80)": { shape: text }
  Padding: { style.fill: "#E5E5E5" }
  "Zero Padding": { shape: text }
  Length: { style.fill: "#FFE6CC" }
  "64-bit Bit Length": { shape: text }
}

SHA256_Memory_Layout: {
  label: "SHA-256 PADDING: 56-BYTE BOUNDARY CASE (SPILL OVER)"
  
  # Block 1 - 64 Bytes (512 bits)
  Block_1: {
    label: "BLOCK 1 (512 bits / 64 Bytes)"
    grid-columns: 3
    horizontal-gap: 40
    vertical-gap: 0
    style: {
      stroke: black
      stroke-width: 4
    }

    # Row 1: Message Data
    m_offset: "0x00" { shape: text }
    m_data: "MESSAGE DATA [0x00 - 0x37]" {
      style.fill: "#B6DDF6"
      width: 400
      height: 100
    }
    m_size: "56 Bytes" { shape: text }

    # Row 2: Sentinel
    s_offset: "0x38" { shape: text }
    sentinel: "SENTINEL (0x80)" {
      style.fill: "#E1D5E7"
      width: 400
      height: 40
    }
    s_size: "1 Byte" { shape: text }

    # Row 3: Padding (Partial fit in Block 1)
    p0_offset: "0x39" { shape: text }
    pad_0: "PADDING [0x00 x 7]" {
      style.fill: "#E5E5E5"
      width: 400
      height: 40
    }
    p0_size: "7 Bytes" { shape: text }
  }

  Boundary: "--- 64B CACHE LINE BOUNDARY ---" {
    style: {
      stroke-dash: 5
      font-size: 16
      bold: true
    }
  }

  # Block 2 - 64 Bytes (512 bits)
  Block_2: {
    label: "BLOCK 2 (512 bits / 64 Bytes)"
    grid-columns: 3
    horizontal-gap: 40
    vertical-gap: 0
    style: {
      stroke: black
      stroke-width: 4
    }

    # Row 1: Continued Padding
    p1_offset: "0x40" { shape: text }
    pad_1: "PADDING [0x00 x 56]" {
      style.fill: "#E5E5E5"
      width: 400
      height: 100
    }
    p1_size: "56 Bytes" { shape: text }

    # Row 2: Message Length (Big-Endian)
    l_offset: "0x78" { shape: text }
    len_field: "LENGTH [0x78 - 0x7F]\n00 00 00 00 00 00 01 C0" {
      style.fill: "#FFE6CC"
      width: 400
      height: 60
    }
    l_size: "8 Bytes" { shape: text }
  }

  # Internal Sequence
  Block_1 -> Boundary -> Block_2: "Linear Memory Growth" {
    style.stroke: orange
    style.stroke-width: 3
  }
}

# ANNOTATION (Root Level to satisfy 'near' constraint)
Logic_Note: |md
  ### Allocation Logic
  - Input: **56 Bytes**
  - Sentinel: **1 Byte**
  - Length Field: **8 Bytes**
  - **Total Metadata Size: 65 Bytes**
  
  Since 65 > 64 (Block Size), the terminal metadata 
  cannot fit in the remaining space of Block 1. 
  The implementation must spill over into a secondary 
  block to preserve the 64-bit alignment of the 
  length field at the end of the message.
| {
  near: bottom-center
}

# Global Styling
***.style.font: mono