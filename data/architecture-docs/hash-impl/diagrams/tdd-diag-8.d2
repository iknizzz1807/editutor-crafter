direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

title: |md
  ### SHA-256 Message Schedule: $\sigma_0$ Function Decomposition
  **Input:** $W[0]$ = `0x61626380`
| {
  near: top-center
  shape: text
}

# -----------------------------------------------------------------------------
# INPUT STAGE
# -----------------------------------------------------------------------------
input: {
  label: "Input Word: W[0]"
  style.fill: "#E1BEE7" # Purple (Header/Input)
  
  word: "01100001 01100010 01100011 10000000" {
    style: {
      font: mono
      fill: "#E3F2FD" # Blue (Data)
      stroke: "#01579B"
      stroke-width: 2
    }
  }
  hex: "0x61626380" {
    shape: text
    style.bold: true
  }
}

# -----------------------------------------------------------------------------
# STEP 1: ROTR(x, 7)
# -----------------------------------------------------------------------------
step1: "1. ROTR(x, 7)" {
  style.stroke: "#01579B"
  
  constant: "7" {
    style: {
      fill: "#FFEBEE"
      stroke: "#B71C1C"
      stroke-width: 3
      bold: true
    }
  }
  
  note: |md
    **Rotate Right 7**
    Bits 0-6 wrap to 31-25
  | {shape: text}

  result: "0000000 01100001 01100010 01100011 1" {
    style: {
      font: mono
      fill: "#E3F2FD" # Blue (Data)
    }
  }
  
  hex_res: "0x00C2C4C7" {shape: text}
}

# -----------------------------------------------------------------------------
# STEP 2: ROTR(x, 18)
# -----------------------------------------------------------------------------
step2: "2. ROTR(x, 18)" {
  style.stroke: "#01579B"
  
  constant: "18" {
    style: {
      fill: "#FFEBEE"
      stroke: "#B71C1C"
      stroke-width: 3
      bold: true
    }
  }
  
  note: |md
    **Rotate Right 18**
    Bits 0-17 wrap to 31-14
  | {shape: text}

  result: "10000000 01100001 01100010 01100011" {
    style: {
      font: mono
      fill: "#E3F2FD" # Blue (Data)
    }
  }
  
  hex_res: "0x80616263" {shape: text}
}

# -----------------------------------------------------------------------------
# STEP 3: SHR(x, 3)
# -----------------------------------------------------------------------------
step3: "3. SHR(x, 3)" {
  style.stroke: "#01579B"
  
  constant: "3" {
    style: {
      fill: "#FFEBEE"
      stroke: "#B71C1C"
      stroke-width: 3
      bold: true
    }
  }
  
  note: |md
    **Logical Shift Right 3**
    3 zeros padded at MSB
  | {shape: text}

  result: "**000**01100 00101100 01001100 01110000" {
    style: {
      font: mono
      fill: "#E3F2FD" # Blue (Data)
    }
  }
  
  hex_res: "0x0C2C4C70" {shape: text}
}

# -----------------------------------------------------------------------------
# STEP 4: XOR COMBINATION
# -----------------------------------------------------------------------------
step4: "4. XOR Accumulation" {
  style.fill: "#FFF3E0"
  
  op: "A ^ B ^ C" {
    shape: parallelogram
    style.fill: "#FFE0B2"
  }
  
  final_bits: "10001100 00101101 11001010 11010010" {
    style: {
      font: mono
      bold: true
      font-color: "#E65100"
    }
  }
  
  final_hex: "Result: 0x8C2DCA92" {
    style: {
      font-size: 18
      bold: true
    }
  }
}

# -----------------------------------------------------------------------------
# WARNING NOTE
# -----------------------------------------------------------------------------
warning: |md
  **IMPORTANT**
  These are $\sigma_0$ constants: (7, 18, 3)
  $\sigma_1$ uses: (17, 19, 10)
  **DO NOT SWAP**
| {
  near: bottom-right
  style: {
    fill: "#FFCDD2"
    stroke: "#B71C1C"
    font-color: "#B71C1C"
  }
}

# -----------------------------------------------------------------------------
# CONNECTIONS
# -----------------------------------------------------------------------------
input -> step1
input -> step2
input -> step3

step1.result -> step4.op
step2.result -> step4.op
step3.result -> step4.op

step4.op -> step4.final_bits
step4.final_bits -> step4.final_hex

# Styling connectors (Orange = Pointers)
(input -> step1)[0].style.stroke: orange
(input -> step2)[0].style.stroke: orange
(input -> step3)[0].style.stroke: orange
(step1.result -> step4.op)[0].style.stroke: orange
(step2.result -> step4.op)[0].style.stroke: orange
(step3.result -> step4.op)[0].style.stroke: orange