direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# Classes for Intel Manual Quality Technical Diagrams
classes: {
  data_byte: {
    shape: square
    width: 60
    height: 60
    style: {
      fill: "#cfe2ff"
      stroke: "#0d6efd"
      stroke-width: 2
      font: mono
    }
  }
  extraction_logic: {
    shape: rectangle
    style: {
      fill: "#fff3e0"
      stroke: "#ef6c00"
      stroke-dash: 3
      border-radius: 4
    }
  }
  word_result: {
    shape: rectangle
    height: 60
    style: {
      fill: "#e8f5e9"
      stroke: "#2e7d32"
      bold: true
      font: mono
    }
  }
  warning: {
    shape: callout
    style: {
      fill: "#f8d7da"
      stroke: "#842029"
      font-color: "#842029"
    }
  }
}

title: "ALGORITHM STEP: Big-Endian 32-bit Word Extraction" {
  shape: text
  style: {
    font-size: 24
    bold: true
  }
}

# Layout Container
extraction_process: {
  
  # Row 1: The Padded Block Input (Bytes 0-11)
  input_block: {
    label: "Padded Block M[i] (Indices 0-11)"
    grid-columns: 12
    grid-gap: 10
    
    b0: "b[0]\n0x61" { class: data_byte }
    b1: "b[1]\n0x62" { class: data_byte }
    b2: "b[2]\n0x63" { class: data_byte }
    b3: "b[3]\n0x80" { class: data_byte }
    b4: "b[4]\n0x00" { class: data_byte }
    b5: "b[5]\n0x00" { class: data_byte }
    b6: "b[6]\n0x00" { class: data_byte }
    b7: "b[7]\n0x00" { class: data_byte }
    b8: "b[8]\n0x00" { class: data_byte }
    b9: "b[9]\n0x00" { class: data_byte }
    b10: "b[10]\n0x00" { class: data_byte }
    b11: "b[11]\n0x00" { class: data_byte }
  }

  # Row 2: Conversion Logic
  parsing_logic: {
    grid-columns: 2
    grid-gap: 50
    
    logic_w0: {
      class: extraction_logic
      label: |'md
        ### Word W[0] Generation
        **Formula:** `(b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3]`
        
        **Shift Operations:**
        - `0x61 << 24` → `0x61000000`
        - `0x62 << 16` → `0x00620000`
        - `0x63 << 8`  → `0x00006300`
        - `0x80 << 0`  → `0x00000080`
      '|
    }

    logic_w1: {
      class: extraction_logic
      label: |'md
        ### Word W[1] Generation
        **Formula:** `(b[4]<<24) | (b[5]<<16) | (b[6]<<8) | b[7]`
        
        **Shift Operations:**
        - `0x00 << 24` → `0x00000000`
        - `0x00 << 16` → `0x00000000`
        - `0x00 << 8`  → `0x00000000`
        - `0x00 << 0`  → `0x00000000`
      '|
    }
  }

  # Row 3: Final Schedule Words
  results: {
    grid-columns: 3
    grid-gap: 20
    
    w0: "W[0] = 0x61626380" { class: word_result }
    w1: "W[1] = 0x00000000" { class: word_result }
    w2: "W[2..15] = 0x0..." { 
      class: word_result
      style: {
        stroke-dash: 5
      }
    }
  }

  # Connections showing extraction flow
  input_block.b0 -> parsing_logic.logic_w0
  input_block.b1 -> parsing_logic.logic_w0
  input_block.b2 -> parsing_logic.logic_w0
  input_block.b3 -> parsing_logic.logic_w0
  
  input_block.b4 -> parsing_logic.logic_w1
  input_block.b5 -> parsing_logic.logic_w1
  input_block.b6 -> parsing_logic.logic_w1
  input_block.b7 -> parsing_logic.logic_w1

  parsing_logic.logic_w0 -> results.w0
  parsing_logic.logic_w1 -> results.w1
}

# Critical Technical Note
endian_warning: {
  class: warning
  label: |md
    ### ⚠️ ENDIANNESS ALERT
    
    **Problematic Cast (Little-Endian Host):**
    `uint32_t w = *(uint32_t*)&block[0];`
    *Memory:* `[61][62][63][80]`
    *Register:* `0x80636261` ❌ **Incorrect**
    
    **Correct (Manual BE Extraction):**
    *Register:* `0x61626380` ✅ **Required**
  |
}

# Positioning and Styling
# endian_warning.near: extraction_process.results  # removed: elk requires constant

extraction_process.input_block.style.stroke: "#0d6efd"
extraction_process.parsing_logic.style.stroke: "#ef6c00"
extraction_process.results.style.stroke: "#2e7d32"