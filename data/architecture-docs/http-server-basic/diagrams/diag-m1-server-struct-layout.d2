direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# LAYER: CONFIGURATION & CONTROL
server_config: {
  shape: sql_table
  label: "struct server_config_t (server.h)"
  
  row1: "0x00 | int    | port"
  row2: "0x04 | int    | backlog"
  row3: "0x08 | char*  | document_root"
  
  label_bottom: "Total: 16 bytes (64-bit Aligned)"
}

# LAYER: DATA BUFFERS
read_buffer: {
  shape: sql_table
  label: "struct network_buffer_t (buffer.h)"
  
  row1: "0x0000 | char[8192] | buf"
  row2: "0x2000 | size_t     | bytes_read"
  row3: "0x2008 | size_t     | buf_capacity"
  
  label_bottom: "Total: 8208 bytes (128.25 Cache Lines)"
}

# LAYER: ARCHITECTURAL ANALYSIS
analysis: {
  label: "Memory Hierarchy Alignment"
  direction: down
  
  os_paging: {
    shape: rectangle
    label: "OS Virtual Memory Mapping"
    
    details: |md
      - **Page Size**: 4096 bytes (x86_64)
      - **Allocation**: 8192 bytes = Exactly 2 Pages
      - **Alignment**: `posix_memalign` recommended at 4KB boundary
      - **Impact**: Zero internal fragmentation across page boundaries.
    |
  }
  
  cache_locality: {
    shape: rectangle
    label: "L1/L2 Cache Locality"
    
    details: |md
      - **Cache Line**: 64 bytes
      - **Coverage**: 128 cache lines per buffer
      - **Pattern**: Sequential `read()` calls populate contiguous lines.
      - **Prefetcher**: HW prefetcher will likely trigger on `strstr()` scan.
    |
  }
}

# DATA FLOW & RELATIONSHIPS
server_config -> read_buffer: "8208 bytes | network_buffer_t* | malloc()"
read_buffer -> analysis.os_paging: "2 x 4096B Pages"
read_buffer -> analysis.cache_locality: "64B Cache Line Alignment"

# ERROR PATHS
read_buffer -> analysis: "EAGAIN / EWOULDBLOCK" {
  style: {
    stroke-dash: 5
    stroke: "#ff0000"
  }
}