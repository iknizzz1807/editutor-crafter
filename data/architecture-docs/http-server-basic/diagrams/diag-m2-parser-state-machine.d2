direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# 1. DATA STRUCTURE DEFINITION
parser_internal: {
  shape: sql_table
  label: "enum http_parser_state_t (parser.c)"
  
  "0x00": "uint8_t | STATE_START        | Initial entry point"
  "0x01": "uint8_t | STATE_METHOD       | Accumulating [A-Z] verb"
  "0x02": "uint8_t | STATE_PATH         | Accumulating URI/Path"
  "0x03": "uint8_t | STATE_VERSION      | Validating HTTP/1.x string"
  "0x04": "uint8_t | STATE_HEADER_NAME  | Parsing key before ':'"
  "0x05": "uint8_t | STATE_HEADER_VALUE | Parsing value after OWS"
  "0x06": "uint8_t | STATE_CRLF         | Line validation (\r\n)"
  "0x07": "uint8_t | STATE_COMPLETE     | Finished \r\n\r\n"
  "0x08": "uint8_t | STATE_BAD_REQUEST  | Terminal Error State"
  
  label_bottom: "Total Size: 1 byte (packed enum)"
}

# 2. STATE EVOLUTION LOGIC
parser_logic: {
  direction: right

  # Phase 1: Request Line Parsing
  request_line: {
    label: "PHASE 1: REQUEST LINE (parser_rl.c)"
    direction: right
    
    START: { shape: circle; style.stroke-width: 3 }
    METHOD: { shape: circle }
    SP1: "SP_AFTER_METHOD" { shape: circle }
    PATH: { shape: circle }
    SP2: "SP_AFTER_PATH" { shape: circle }
    VERSION: { shape: circle }
    RL_CR: "RL_CR" { shape: circle }
    RL_LF: "RL_LF" { shape: circle }

    START -> METHOD: "Char [A-Z] | 1B | 0x41-5A"
    METHOD -> METHOD: "Char [A-Z]"
    METHOD -> SP1: "SP | 1B | 0x20"
    SP1 -> PATH: "Char [^SP] | URI Start"
    PATH -> PATH: "Char [^SP]"
    PATH -> SP2: "SP | 1B | 0x20"
    SP2 -> VERSION: "'H' | 1B | Start 'HTTP/1.x'"
    VERSION -> VERSION: "Chars [T,T,P,/,1,.,x]"
    VERSION -> RL_CR: "CR | 1B | 0x0D"
    RL_CR -> RL_LF: "LF | 1B | 0x0A"
  }

  # Phase 2: Header Block Parsing
  headers: {
    label: "PHASE 2: HEADERS (parser_hdr.c)"
    direction: right
    
    NAME: "HEADER_NAME" { shape: circle }
    COLON: "HEADER_COLON" { shape: circle }
    OWS: "HEADER_OWS" { shape: circle }
    VALUE: "HEADER_VALUE" { shape: circle }
    H_CR: "HEADER_CR" { shape: circle }
    H_LF: "HEADER_LF" { shape: circle }
    END: "END_HEADERS" { 
      shape: circle
      style.double-border: true
      label: "SUCCESS (200)" 
    }

    NAME -> NAME: "Char [a-z0-9-]"
    NAME -> COLON: "':' | 1B | 0x3A"
    COLON -> OWS: "SP/Tab | 1B | 0x20/0x09"
    OWS -> OWS: "SP/Tab | Optional Whitespace"
    OWS -> VALUE: "Char [^SP/Tab]"
    VALUE -> VALUE: "Any Char"
    VALUE -> H_CR: "CR | 1B | 0x0D"
    H_CR -> H_LF: "LF | 1B | 0x0A"
    
    # Recurrence and Terminal Transitions
    H_LF -> NAME: "Char [a-z0-9-] | Next Header"
    H_LF -> END: "CR+LF | 2B | 0x0D0A | Empty Line"
  }

  # Transition between Phase 1 and Phase 2
  request_line.RL_LF -> headers.NAME: "Char [a-z0-9-] | Start Headers"
  request_line.RL_LF -> headers.H_CR: "CR | 0x0D | No Headers Case"

  # Error Sink
  ERROR: "BAD_REQUEST (400)" {
    shape: hexagon
    style: {
      fill: "#ffcccc"
      stroke: red
      bold: true
    }
  }

  # Global Violation Paths
  request_line.METHOD -> ERROR: "Non [A-Z]" { style.stroke: red; style.stroke-dash: 3 }
  request_line.PATH -> ERROR: "Length > 8192B" { style.stroke: red; style.stroke-dash: 3 }
  headers.NAME -> ERROR: "Illegal Char" { style.stroke: red; style.stroke-dash: 3 }
}

# 3. IMPLEMENTATION BINDINGS
parser_logic.request_line.START -> parser_internal: "initializes state"
parser_logic.ERROR -> parser_internal: "updates errno"

# 4. RFC CONSTRAINTS & DOCUMENTATION
rfc_7230: |md
  ### HTTP/1.1 Parser Implementation Notes
  - **Normalization**: Implementation must lowercase all Header Names.
  - **Whitespace**: `OWS` allows optional `SP` or `HTAB`.
  - **Security**: Buffer limits enforced at `STATE_PATH` (8KB) and `STATE_HEADER_VALUE` (4KB).
  - **Termination**: A request block is complete only after double CRLF.
| { 
  near: bottom-right
  style: {
    stroke: "#CBD6E0"
    fill: "#F6F9FC"
  }
}