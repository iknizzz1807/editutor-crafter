direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# Implementation-Ready Blueprint: Complete Connection Handler (worker.c)
# This diagram defines the integration of Milestones 1-4.

connection_handler: {
  label: "Complete Request Handler Loop (worker.c)"
  style.stroke-width: 2
  
  initialization: {
    direction: down
    label: "PHASE 1: SOCKET CONFIGURATION"
    
    timeout_setup: {
      shape: code
      label: |md
        c
        // Set receive timeout to prevent worker hang
        struct timeval tv = { .tv_sec = pool->idle_timeout };
        setsockopt(client_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        
      |
    }
  }

  keep_alive_scope: {
    label: "PHASE 2: PERSISTENT CONNECTION LOOP (HTTP/1.1)"
    direction: down
    style: {
      stroke-dash: 5
      fill: "#f8f9fa"
    }

    read_request: {
      shape: sql_table
      label: "read_http_request (socket.c)"
      row1: "IN  | int client_fd"
      row2: "OUT | char req_buf[8192]"
      row3: "OUT | int header_end"
      row4: "RET | ssize_t bytes_read"
    }

    validate_read: {
      shape: diamond
      label: "bytes_read <= 0?"
    }

    parse_logic: {
      shape: sql_table
      label: "parse_http_request (parser.c)"
      row1: "IN  | char* buf"
      row2: "OUT | http_request_t req"
      row3: "RET | int parse_err"
    }

    validate_parse: {
      shape: diamond
      label: "parse_err != 0?"
    }

    dispatch_serve: {
      shape: sql_table
      label: "serve_static_file (file_server.c)"
      row1: "IN  | http_request_t* req"
      row2: "IN  | int client_fd"
      row3: "IN  | char* root_path"
    }

    check_keep_alive: {
      shape: diamond
      label: "req.keep_alive == 1?"
    }

    # Internal Loop Transitions
    read_request -> validate_read: "ssize_t | 8B"
    validate_read -> parse_logic: "No (Data ready)"
    parse_logic -> validate_parse: "int | 4B"
    validate_parse -> dispatch_serve: "0 (Success)"
    dispatch_serve -> check_keep_alive
    check_keep_alive -> read_request: "Loop (Keep-Alive)" {
      style.stroke: blue
      label: "Reuse Socket"
    }
  }

  cleanup: {
    label: "PHASE 3: RESOURCE RELEASE"
    direction: down
    
    close_fd: {
      shape: code
      label: "close(client_fd);"
    }
    
    dec_stats: {
      shape: code
      label: |md
        c
        pthread_mutex_lock(&pool->lock);
        pool->active_connections--;
        pthread_mutex_unlock(&pool->lock);
        
      |
    }
  }

  error_handling: {
    label: "ERROR HANDLERS"
    send_400: "send_error_response(client_fd, 400)" {
      style.stroke: red
    }
    send_5xx: "send_error_response(client_fd, 501)" {
      style.stroke: red
    }
  }
}

# Global Flow Transitions
connection_handler.initialization -> connection_handler.keep_alive_scope
connection_handler.keep_alive_scope.validate_read -> connection_handler.cleanup: "Yes (Timeout/EOF)" {
  style.stroke: gray
}
connection_handler.keep_alive_scope.validate_parse -> connection_handler.error_handling.send_400: "Yes (Malformed)" {
  style.stroke: red
}
connection_handler.keep_alive_scope.check_keep_alive -> connection_handler.cleanup: "No (Connection: close)"

connection_handler.error_handling.send_400 -> connection_handler.cleanup
connection_handler.error_handling.send_5xx -> connection_handler.cleanup
connection_handler.cleanup.close_fd -> connection_handler.cleanup.dec_stats

# Data Flow Annotations
connection_handler.keep_alive_scope.read_request -> connection_handler.keep_alive_scope.parse_logic: "Raw Buffer | 8KB | GET / HTTP/1.1\\r\\n..."
connection_handler.keep_alive_scope.parse_logic -> connection_handler.keep_alive_scope.dispatch_serve: "http_request_t | 270KB | {method: 0, path: '/'}"

# Scale & Context Markers
legend: {
  near: top-right
  l1: "Max Concurrency: pool->num_threads" {shape: text}
  l2: "Memory per worker: ~280KB stack + buffers" {shape: text}
  l3: "Idle Timeout: SO_RCVTIMEO" {shape: text}
}