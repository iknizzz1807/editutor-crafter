direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 0
  }
}

# L1 - Component Architecture: Thread Pool System (thread_pool.c)

producer_layer: {
  label: "PRODUCER LAYER (main.c)"
  direction: down

  accept_loop: {
    shape: code
    label: "Accept Loop"
    instruction: |md
      c
      while(!shutdown) {
        int fd = accept(...);
        thread_pool_submit(pool, fd);
      }
      
    |
  }
}

pool_controller: {
  label: "THREAD POOL CONTROLLER"
  direction: down

  struct_thread_pool: {
    shape: sql_table
    label: "struct thread_pool_t (thread_pool.h)"
    
    row_0: "0x00 | pthread_mutex_t | lock"
    row_1: "0x28 | pthread_cond_t  | not_empty"
    row_2: "0x58 | pthread_cond_t  | not_full"
    row_3: "0x88 | work_item_t*    | queue (Array)"
    row_4: "0x90 | int             | queue_capacity"
    row_5: "0x94 | int             | queue_head"
    row_6: "0x98 | int             | queue_tail"
    row_7: "0x9C | int             | queue_size"
    row_8: "0xA0 | pthread_t*      | threads (Array)"
    row_9: "0xA8 | int             | num_threads"
    row_10: "0xAC | int             | shutdown_flag"
    
    label_bottom: "Total Size: ~176 bytes (aligned to 3 cache lines)"
  }

  queue_visualization: {
    label: "Circular Task Queue Memory"
    grid-columns: 8
    grid-gap: 0
    
    cell_0: "idx: 0\n[fd: 12]"
    cell_1: "idx: 1\n[fd: 15]"
    cell_2: "idx: 2\n[EMPTY]" { style.fill: "#f5f5f5" }
    cell_3: "idx: 3\n[EMPTY]" { style.fill: "#f5f5f5" }
    cell_4: "idx: 4\n[EMPTY]" { style.fill: "#f5f5f5" }
    cell_5: "idx: 5\n[EMPTY]" { style.fill: "#f5f5f5" }
    cell_6: "idx: 6\n[fd: 8]"
    cell_7: "idx: 7\n[fd: 10]"
    
    head_ptr: "HEAD" { shape: parallelogram; style.fill: "#C7F1FF" }
    tail_ptr: "TAIL" { shape: parallelogram; style.fill: "#E4DBFE" }

    head_ptr -> cell_6: "points to"
    tail_ptr -> cell_2: "next slot"
  }
}

worker_layer: {
  label: "CONSUMER LAYER (Workers)"
  direction: down

  worker_threads: {
    grid-columns: 2
    
    t1: "Thread 1 (IDLE)" { style.fill: "#AFBFDF" }
    t2: "Thread 2 (BUSY)" { style.fill: "#ed800c"; style.animated: true }
    t3: "Thread 3 (IDLE)" { style.fill: "#AFBFDF" }
    tn: "Thread N (IDLE)" { style.fill: "#AFBFDF"; style.multiple: true }
  }

  worker_logic: {
    shape: code
    label: "Worker State Machine"
    instruction: |md
      c
      for(;;) {
        lock(pool->lock);
        while(size == 0 && !shutdown)
          wait(pool->not_empty, pool->lock);
        if(shutdown) { unlock; exit; }
        fd = dequeue();
        unlock(pool->lock);
        handle_connection(fd);
      }
      
    |
  }
}

# Data Flows & Control Signal Path
accept_loop -> pool_controller.struct_thread_pool: "thread_pool_submit(fd) | 4 bytes" {
  style.stroke: blue
}

pool_controller.struct_thread_pool.row_1 -> worker_layer.worker_threads: "pthread_cond_signal() | Wake up" {
  style.stroke: purple
  style.animated: true
}

worker_layer.worker_threads -> pool_controller.queue_visualization: "Dequeue fd | Atomic via Mutex" {
  style.stroke: green
}

worker_layer.worker_threads -> worker_layer.worker_logic: "Execute handle_connection()"

# Constraints/Annotations
pool_controller.queue_visualization: {
  tooltip: "Circular Buffer Logic: (tail + 1) % capacity"
}

legend: {
  near: bottom-right
  mutex: "Locked Resource" { style.fill: red; shape: circle }
  data: "Data Flow" { style.stroke: blue }
  signal: "CondVar Signal" { style.stroke: purple }
}