direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- CLASSES ---
classes: {
  state: {
    shape: rectangle
    style: {
      stroke-width: 2
      border-radius: 8
    }
  }
  memory_struct: {
    shape: sql_table
    style: {
      stroke: "#333333"
      fill: "#F1F1F1"
    }
  }
}

# --- DOCUMENTATION ---
vulnerability_analysis: |md
  ### The Slowloris Vulnerability (CVE-2007-6750)
  - **Attack Vector**: Attacker opens maximum concurrent connections.
  - **Persistence**: Sends partial HTTP headers (e.g., `X-Header: 1\r\n`) every 29s.
  - **Impact**: Exhausts thread pool (e.g., 16 threads) indefinitely.
  - **Defense**: `SO_RCVTIMEO` forces kernel to return `EAGAIN` if no data arrives within the window.
| {
  near: top-left
}

# --- L0 LAYERS ---

attacker_layer: {
  label: "LAYER 1: EXTERNAL NETWORK (ADVERSARIAL)"
  direction: down
  
  slowloris: "Attacker (slowloris.py)" {
    shape: person
    tooltip: "10k Conns | 1 byte/29s"
  }
  
  http_fragment: {
    class: memory_struct
    label: "Incomplete HTTP Header (TCP Payload)"
    row1: "0x00 | char[4] | 'GET '"
    row2: "0x04 | char[1] | 'G' (Stalled Byte)"
    label_bottom: "Total: 5 bytes sent over 30s"
  }
}

kernel_layer: {
  label: "LAYER 2: OS KERNEL SOCKET (net/core/sock.c)"
  direction: down
  
  socket_struct: {
    class: memory_struct
    label: "struct sock (kernel internal)"
    row1: "0x120 | struct timeval | sk_rcvtimeo | 30.0s"
    row2: "0x130 | sk_buff_head    | sk_receive_queue | [ 0x47 ]"
    row3: "0x148 | atomic_t        | sk_rmem_alloc"
    row4: "0x150 | int             | sk_state | TCP_ESTABLISHED"
    label_bottom: "Timer resets only on successful L4 read"
  }
  
  timer_fsm: {
    label: "Socket Timeout State Machine"
    direction: right
    state_idle: "TIMER_RUNNING" { 
      class: state
      style.fill: "#FFF9C9" 
    }
    state_expired: "TIMEOUT_EXPIRED" { 
      class: state
      style.fill: "#FE7070" 
    }
    
    state_idle -> state_expired: "t > sk_rcvtimeo"
  }
}

worker_layer: {
  label: "LAYER 3: SERVER WORKER POOL (worker.c)"
  direction: down
  
  pool_monitor: {
    shape: class
    label: "thread_pool_t (manager.h)"
    fields: |md
      c
      uint16_t max_workers;    // 16
      uint16_t active_workers; // 16 (CRITICAL)
      pthread_cond_t available; 
      
    |
  }
  
  worker_logic: {
    label: "Worker Instance (Blocked)"
    
    implementation: {
      label: "Defense Implementation"
      code_block: |'md
        c
        // Defense Configuration (worker.c)
        struct timeval tv = { .tv_sec = 30, .tv_usec = 0 };
        setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));

        while (reading) {
            // Kernel blocks here until sk_rcvtimeo or data arrives
            ssize_t n = read(sockfd, buf, BUF_SIZE);
            
            if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
                log_debug("Slowloris detected: timing out FD %d", sockfd);
                cleanup_connection(sockfd);
                return; // Thread returns to pool
            }
        }
        
      '|
    }
  }
}

# --- CROSS-LAYER DATA FLOW ---

attacker_layer.slowloris -> kernel_layer.socket_struct: "TCP Segment | 1460B | {Window: 65535}"
attacker_layer.http_fragment -> kernel_layer.socket_struct: "char | 1B | 0x47 ('G')"

kernel_layer.socket_struct -> worker_layer.worker_logic.implementation: "Context Switch | SIGIO / Wakeup"

worker_layer.worker_logic.implementation -> kernel_layer.timer_fsm.state_idle: "syscall: setsockopt(SO_RCVTIMEO)"

kernel_layer.timer_fsm.state_expired -> worker_layer.worker_logic.implementation: "errno = EAGAIN | Return -1"

worker_layer.worker_logic.implementation -> recovery: "close(sockfd)" {
  style: {
    stroke: "#44C7B1"
    stroke-width: 4
    animated: true
  }
}

recovery: {
  label: "RESOURCE RECOVERY"
  shape: circle
  style: {
    fill: "#44C7B1"
    font-color: white
    bold: true
  }
}

recovery -> worker_layer.pool_monitor: "active_workers--"

# --- ANNOTATIONS ---
kernel_layer.timer_fsm.state_idle -> kernel_layer.timer_fsm.state_idle: "Reset on data arrival" {
  style.stroke-dash: 3
}

(attacker_layer.slowloris -> kernel_layer.socket_struct)[0].style.stroke: "#FE7070"