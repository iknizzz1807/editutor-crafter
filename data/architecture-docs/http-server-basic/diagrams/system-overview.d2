direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 3
  }
}
title: |md
  # HTTP Server (Basic) — Implementation Blueprint
  **Language: C** | All 4 Milestones | Socket → Parse → Serve → Concurrent
| {near: top-center}
# ═══════════════════════════════════════════════════════
# LAYER 0: PROCESS ENTRY & CONFIGURATION
# ═══════════════════════════════════════════════════════
L0_config: "Process Entry & Config" {
  style: {
    fill: "#EEF2FF"
    stroke: "#6366F1"
    stroke-width: 2
    border-radius: 8
    font-size: 14
    bold: true
  }
  main_c: "main.c — Entry Point" {
    style.fill: "#DBEAFE"
    style.border-radius: 6
    cli_args: |c
      // CLI: ./http_server [port] [doc_root]
      int port = atoi(argv[1]);       // default 8080
      const char *doc_root = argv[2]; // default "."
    |
    startup_seq: "Startup Sequence" {
      style.fill: "#EFF6FF"
      style.border-radius: 4
      s1: "① signal(SIGPIPE, SIG_IGN)"
      s2: "② sigfillset + pthread_sigmask(SIG_BLOCK)"
      s3: "③ realpath(doc_root, canonical_root) — ONCE"
      s4: "④ thread_pool_init(pool, 16, 256, root, 30)"
      s5: "⑤ socket() → setsockopt() → bind() → listen()"
      s6: "⑥ pthread_create(signal_handler_thread)"
      s7: "⑦ accept_loop() — BLOCKS"
      s8: "⑧ thread_pool_join() on shutdown"
      s1 -> s2 -> s3 -> s4 -> s5 -> s6 -> s7 -> s8
    }
    server_config_t: "server_config_t [16 bytes]" {
      style.fill: "#F0FDF4"
      style.border-radius: 4
      fields: |c
        typedef struct {
          int port;       // 0x00 — TCP port (default 8080)
          int server_fd;  // 0x04 — listening socket FD
          int is_running; // 0x08 — accept loop flag
          char pad[4];    // 0x0C — alignment padding
        } server_config_t; // Total: 16 bytes
      |
    }
  }
  constants: "Global Constants" {
    style.fill: "#FEF3C7"
    style.border-radius: 6
    vals: |c
      #define DEFAULT_PORT       8080
      #define BACKLOG            SOMAXCONN
      #define REQUEST_BUF_SIZE   8192   // 8KB — max URI
      #define MAX_RESPONSE_SIZE  4096   // 4KB headers
      #define POOL_SIZE_DEFAULT  16     // worker threads
      #define QUEUE_SIZE_DEFAULT 256    // circular queue
      #define IDLE_TIMEOUT_SECS  30     // SO_RCVTIMEO
      #define MAX_PATH_SIZE      4096   // PATH_MAX
      #define IO_BUFFER_SIZE     65536  // 64KB I/O chunks
      #define MAX_HEADERS        32
      #define MAX_HEADER_LEN     8192
    |
  }
}
# ═══════════════════════════════════════════════════════
# LAYER 1: MILESTONE 1 — TCP Socket Lifecycle
# ═══════════════════════════════════════════════════════
L1_m1: "M1: TCP Server & HTTP Response\n[http-server-basic-m1]" {
  style: {
    fill: "#FFF7ED"
    stroke: "#F59E0B"
    stroke-width: 2
    border-radius: 8
    font-size: 14
    bold: true
  }
  socket_dance: "socket.c — 7-Step Socket Dance" {
    style.fill: "#FFFBEB"
    style.border-radius: 6
    steps: "Steps in Order" {
      style.fill: "#FEF9C3"
      style.border-radius: 4
      d1: |c
        // Step 1: CREATE
        int server_fd = socket(AF_INET, SOCK_STREAM, 0);
        // AF_INET=IPv4, SOCK_STREAM=TCP, proto=0(auto)
      |
      d2: |c
        // Step 2: REUSE PORT (avoid EADDRINUSE on restart)
        int opt = 1;
        setsockopt(server_fd, SOL_SOCKET,
                   SO_REUSEADDR, &opt, sizeof(opt));
      |
      d3: |c
        // Step 3: BIND — htons() converts port to
        // Network Byte Order (big-endian)
        struct sockaddr_in addr = {0};
        addr.sin_family      = AF_INET;
        addr.sin_addr.s_addr = INADDR_ANY; // all ifaces
        addr.sin_port        = htons(8080);
        bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
      |
      d4: |c
        // Step 4: LISTEN — kernel queues handshakes
        // SOMAXCONN = 128-4096 (OS default max)
        listen(server_fd, SOMAXCONN);
      |
      d5: |c
        // Step 5: ACCEPT — blocks; returns NEW fd per client
        // server_fd stays open; client_fd is temporary
        int client_fd = accept(server_fd,
          (struct sockaddr*)&client_addr, &client_len);
        // EINTR → retry; EMFILE → sleep+retry
      |
      d6: |c
        // Step 6: READ / WRITE (see accumulator below)
      |
      d7: |c
        // Step 7: CLOSE — mandatory; prevents FD leak
        close(client_fd); // triggers TCP FIN
      |
      d1 -> d2 -> d3 -> d4 -> d5 -> d6 -> d7
    }
    fd_table: "Kernel FD Table (per-process)" {
      style.fill: "#ECFDF5"
      style.border-radius: 4
      tbl: |md
        | Slot | Resource | Lifetime |
        |------|----------|----------|
        | 0 | stdin | process |
        | 1 | stdout | process |
        | 2 | stderr | process |
        | 3 | server_fd (listening) | server lifetime |
        | 4..N | client_fd (connection) | per-request |
        **Limit:** ~1024 FDs (ulimit -n)
        **Leak check:** ls /proc/PID/fd | wc -l
      |
    }
  }
  accumulator: "utils.c — Partial Read Accumulator" {
    style.fill: "#FEF2F2"
    style.border-radius: 6
    problem: "TCP Byte Stream Problem" {
      style.fill: "#FEE2E2"
      style.border-radius: 4
      txt: |md
        **TCP delivers BYTES, not messages.**
        One HTTP request may arrive in 1 to N read() calls.
        Causes: MTU ~1500B, Nagle, kernel scheduling.
        Must accumulate until \r\n\r\n found.
      |
    }
    impl: |c
      // utils.c
      // Returns total bytes read on success
      // Returns -1 on error, disconnect, or overflow
      ssize_t read_http_request(
          int client_fd,
          char *buf,         // dest: stack-alloc 8192B
          size_t buf_size,   // 8192
          int *header_end    // OUT: offset after \r\n\r\n
      ) {
          size_t total = 0;
          while (total < buf_size - 1) {
              ssize_t n = read(client_fd,
                               buf + total,
                               buf_size - 1 - total);
              if (n <= 0) return n; // 0=disconnect,-1=err
              total += n;
              buf[total] = '\0';   // null-term for strstr
              char *end = strstr(buf, "\r\n\r\n");
              if (end) {
                  *header_end = (int)(end - buf) + 4;
                  return (ssize_t)total;
              }
          }
          return -1; // buffer full = 414
      }
    |
    write_all: |c
      // utils.c — partial write protection
      int write_all(int fd, const char *buf, size_t len) {
          size_t written = 0;
          while (written < len) {
              ssize_t n = write(fd,
                                buf + written,
                                len - written);
              if (n <= 0) return -1; // EPIPE → -1
              written += n;
          }
          return 0;
      }
      // MSG_NOSIGNAL alternative on Linux:
      // send(fd, buf, len, MSG_NOSIGNAL)
    |
  }
  response_builder: "http.c — Hardcoded Response Builder" {
    style.fill: "#F0FDF4"
    style.border-radius: 6
    impl: |c
      // http.c — build valid HTTP/1.1 200 OK
      // Returns: bytes in buf, or -1 on overflow
      int build_hardcoded_response(char *buf,  // 4096B
                                   size_t buf_size) {
          time_t now = time(NULL);
          struct tm *gmt = gmtime(&now);
          char date[64];
          // RFC 1123 format: "Sat, 28 Feb 2026 12:00:00 GMT"
          strftime(date, sizeof(date),
                   "%a, %d %b %Y %H:%M:%S GMT", gmt);
          const char *body =
            "<html><body><h1>Hello!</h1></body></html>";
          int blen = (int)strlen(body);
          return snprintf(buf, buf_size,
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: text/html; charset=utf-8\r\n"
            "Content-Length: %d\r\n"
            "Date: %s\r\n"
            "Connection: close\r\n"
            "\r\n%s",
            blen, date, body);
      }
    |
    headers_explained: |md
      **Required headers (RFC 7231):**
      - `Content-Type` — browser needs this to render
      - `Content-Length` — client knows when body ends
      - `Date` — required by HTTP/1.1 §7.1.1.2
      - `Connection: close` — no keep-alive in M1
      - Blank line `\r\n` — mandatory header/body separator
    |
  }
  sigpipe: "Signal Safety — SIGPIPE" {
    style.fill: "#FFF1F2"
    style.border-radius: 6
    txt: |md
      **Problem:** Client disconnects mid-write.
      1st write() succeeds (kernel doesn't know yet).
      2nd write() → kernel delivers **SIGPIPE** → default
      handler **kills the process**.
      **Fix at startup:**
      `signal(SIGPIPE, SIG_IGN);`
      Now write() returns -1, errno=EPIPE. Check and close.
    |
  }
  m1_errors: "M1 Error Matrix" {
    style.fill: "#F8FAFC"
    style.border-radius: 6
    tbl: |md
      | errno | syscall | Recovery |
      |-------|---------|----------|
      | EADDRINUSE | bind() | exit(1) |
      | EINTR | accept() | continue loop |
      | EMFILE | accept() | sleep(1)+continue |
      | EPIPE | write() | close(client_fd) |
      | buffer full | read loop | close, no response |
    |
  }
}
# ═══════════════════════════════════════════════════════
# LAYER 2: MILESTONE 2 — HTTP Request Parser
# ═══════════════════════════════════════════════════════
L2_m2: "M2: HTTP Request Parsing\n[http-server-basic-m2]" {
  style: {
    fill: "#F0FDF4"
    stroke: "#22C55E"
    stroke-width: 2
    border-radius: 8
    font-size: 14
    bold: true
  }
  data_model: "http_types.h — Data Structures" {
    style.fill: "#DCFCE7"
    style.border-radius: 6
    header_struct: "http_header_t [8448 bytes each]" {
      style.fill: "#F0FDF4"
      style.border-radius: 4
      fields: |c
        typedef struct {
          char name[256];   // 0x0000 lowercase norm'd name
          char value[8192]; // 0x0100 OWS-stripped value
        } http_header_t;    // Total: 8448 bytes
      |
    }
    request_struct: "http_request_t [~278 KB stack alloc]" {
      style.fill: "#ECFDF5"
      style.border-radius: 4
      fields: |c
        typedef struct {
          // 0x00000 method enum
          int          method;       // METHOD_GET=0,HEAD=1
                                     // POST=2,UNKNOWN=3
          // 0x00004 URI path
          char         path[8192];   // URL-decoded path
          // 0x02004 HTTP minor version
          int          http_minor;   // 0=HTTP/1.0, 1=HTTP/1.1
          // 0x02008 headers array (contiguous, cache-friendly)
          http_header_t headers[32]; // 32 × 8448B = 270,336B
          // 0x44008 header count
          int          header_count; // 0..32
          // 0x4400C content length
          int          content_length; // -1=absent, 0..N
          // 0x44010 keep-alive flag
          int          keep_alive;   // 1=persist, 0=close
          // 0x44018 body pointer (zero-copy into buf)
          const char  *body;         // NULL if no body
        } http_request_t; // ~278,560 bytes total
        // ⚠ Stack alloc: thread stack must be ≥8MB
      |
    }
    method_enum: |c
      typedef enum {
        METHOD_GET     = 0,
        METHOD_HEAD    = 1,
        METHOD_POST    = 2,
        METHOD_UNKNOWN = 3
      } http_method_t;
    |
  }
  parser_core: "http_parser.c — Parsing Logic" {
    style.fill: "#F0FDF4"
    style.border-radius: 6
    states: "Parser State Machine" {
      style.fill: "#DCFCE7"
      style.border-radius: 4
      sm: |md
        STATE_REQ_LINE → STATE_HEADERS → STATE_SEMANTIC → STATE_COMPLETE
                    ↘ (any error) → STATE_ERROR → send 4xx
      |
    }
    parse_request_line: |c
      // http_parser.c
      // Returns: 0=OK, 400=bad, 414=URI long, 501=method
      int parse_request_line(const char *line,
                             http_request_t *req) {
          // "METHOD SP URI SP HTTP/1.X"
          const char *path_start = strchr(line, ' ');
          if (!path_start) return 400;
          size_t method_len = path_start - line;
          path_start++;
          const char *ver_start = strchr(path_start, ' ');
          if (!ver_start) return 400;
          size_t path_len = ver_start - path_start;
          ver_start++;
          // method: memcmp not strcmp (bounded, fast)
          req->method = parse_method(line, method_len);
          if (req->method == METHOD_UNKNOWN) return 501;
          if (path_len == 0)            return 400;
          if (path_len >= MAX_PATH_LEN) return 414; // 8192B
          memcpy(req->path, path_start, path_len);
          req->path[path_len] = '\0';
          req->http_minor = parse_http_version(ver_start,
                              strlen(ver_start));
          if (req->http_minor < 0) return 400;
          return 0;
      }
    |
    parse_header_line: |c
      // http_parser.c — one header line "Name: Value\r\n"
      // Returns: 0=OK, -1=malformed(skip), -2=too many
      int parse_header_line(const char *line,
                            http_request_t *req) {
          if (req->header_count >= MAX_HEADERS) return -2;
          const char *colon = strchr(line, ':');
          if (!colon) return -1;
          size_t name_len = colon - line;
          if (name_len == 0 ||
              name_len >= sizeof(req->headers[0].name))
              return -1;
          http_header_t *h = &req->headers[req->header_count];
          memcpy(h->name, line, name_len);
          h->name[name_len] = '\0';
          str_to_lower(h->name); // 'A'|0x20 → 'a' trick
          strip_ows(colon+1, h->value, sizeof(h->value));
          req->header_count++;
          return 0;
      }
    |
    helpers: |c
      // Case normalization — ASCII only, no locale
      static void str_to_lower(char *s) {
          for (; *s; ++s)
              if (*s >= 'A' && *s <= 'Z') *s |= 0x20;
      }
      // OWS strip: RFC 7230 §3.2.6
      // "  value  " → "value"
      static int strip_ows(const char *s, char *out,
                            size_t out_size) {
          while (*s == ' ' || *s == '\t') s++;
          size_t len = strlen(s);
          while (len > 0 &&
                 (s[len-1]==' '||s[len-1]=='\t')) len--;
          if (len >= out_size) return -1;
          memcpy(out, s, len); out[len] = '\0';
          return 0;
      }
    |
    semantic_extract: |c
      // After all headers parsed, extract control fields
      void extract_semantic_headers(http_request_t *req) {
          // Content-Length: use strtol not atoi (error detect)
          const char *cl = request_get_header(req,
                                              "content-length");
          if (cl) {
              char *end;
              long v = strtol(cl, &end, 10);
              req->content_length =
                (*end=='\0' && v>=0 && v<=(64<<20)) ?
                (int)v : -1; // max 64MB
          } else req->content_length = -1;
          // Connection: keep-alive semantics
          const char *conn = request_get_header(req,
                                                "connection");
          if (req->http_minor == 1)  // HTTP/1.1 default=ka
              req->keep_alive = (!conn ||
                strcasecmp(conn,"close")!=0) ? 1 : 0;
          else                       // HTTP/1.0 default=close
              req->keep_alive = (conn &&
                strcasecmp(conn,"keep-alive")==0) ? 1 : 0;
      }
    |
    lookup: |c
      // O(N) linear search — N≤32, all in L1 cache
      // name MUST be already lowercase
      const char *request_get_header(
          const http_request_t *req,
          const char *name) {
          for (int i=0; i<req->header_count; i++)
              if (strcmp(req->headers[i].name, name)==0)
                  return req->headers[i].value;
          return NULL;
      }
    |
  }
  error_responses: "http_errors.c — Error Responses" {
    style.fill: "#FEF2F2"
    style.border-radius: 6
    impl: |c
      void send_error_response(int client_fd,
          int status, const char *reason,
          const char *body) {
          char buf[2048];
          int blen = (int)strlen(body);
          // must include: Date, Content-Length, Connection
          snprintf(buf, sizeof(buf),
            "HTTP/1.1 %d %s\r\n"
            "Content-Type: text/html; charset=utf-8\r\n"
            "Content-Length: %d\r\n"
            "Connection: close\r\n\r\n%s",
            status, reason, blen, body);
          write_all(client_fd, buf, strlen(buf));
      }
      // Convenience: send_400(), send_414(), send_501()
    |
    codes: |md
      | Code | Trigger | RFC |
      |------|---------|-----|
      | 400 | Bad request line, no Host (1.1) | RFC 7230 §3.1 |
      | 414 | URI > 8192 bytes | RFC 7231 §6.5.12 |
      | 501 | Valid but unsupported method | RFC 7231 §6.6.2 |
    |
  }
  url_decode: "URL Decode (path_utils.c)" {
    style.fill: "#FFFBEB"
    style.border-radius: 6
    impl: |c
      // Converts %XX hex sequences to raw bytes
      // Returns 0=OK, -1=malformed or %00 (null injection)
      int url_decode(const char *src, char *out,
                     size_t out_size) {
          size_t i=0, j=0;
          while (src[i] && j+1<out_size) {
              if (src[i]=='%') {
                  if (!src[i+1]||!src[i+2]) return -1;
                  char hex[3]={src[i+1],src[i+2],0};
                  char *end;
                  long v = strtol(hex, &end, 16);
                  if (*end!='\0') return -1; // bad hex
                  if (v==0) return -1; // %00 null inject!
                  out[j++]=(char)v; i+=3;
              } else { out[j++]=src[i++]; }
          }
          out[j]='\0'; return 0;
      }
    |
  }
}
# ═══════════════════════════════════════════════════════
# LAYER 3: MILESTONE 3 — Static File Serving
# ═══════════════════════════════════════════════════════
L3_m3: "M3: Static File Serving\n[http-server-basic-m3]" {
  style: {
    fill: "#FFF7ED"
    stroke: "#F97316"
    stroke-width: 2
    border-radius: 8
    font-size: 14
    bold: true
  }
  path_security: "path_utils.c — Security Firewall" {
    style.fill: "#FEF9C3"
    style.border-radius: 6
    attack_vectors: "5 Traversal Attack Vectors" {
      style.fill: "#FEF3C7"
      style.border-radius: 4
      attacks: |md
        1. **Classic**: `GET /../../../etc/passwd`
           strncmp("…/html/../../etc/passwd","…/html") = PASS ❌
        2. **URL-Encoded**: `GET /%2e%2e%2fetc%2fpasswd`
           Must decode THEN check (not before)
        3. **Symlink**: `/var/www/secret → /etc`
           `open("/var/www/secret/passwd")` = opens /etc/passwd
        4. **Double-Encoded**: `%252e` → `%2e` → `.`
        5. **Null-byte**: `%00` truncates C string path
      |
    }
    safe_algorithm: "The ONLY Safe Algorithm" {
      style.fill: "#ECFDF5"
      style.border-radius: 4
      steps: |md
        **Step 1:** url_decode(req->path, decoded)
        **Step 2:** snprintf(raw, sizeof(raw), "%s%s", canonical_root, decoded)
        **Step 3:** realpath(raw, resolved) ← OS resolves ALL symlinks, .., .
        **Step 4 (security):** strncmp(resolved, canonical_root, root_len)
        **Step 5 (boundary):** resolved[root_len] must be '/' or '\0'
        ⚠ realpath() requires file EXISTS (ENOENT → 404)
        ⚠ Run realpath(doc_root) ONCE at startup, not per-request
      |
    }
    impl: |c
      // path_utils.c
      // Returns: 0=safe path in resolved_out
      //          400=bad encoding, 403=traversal, 404=missing
      int resolve_safe_path(
          const char *url_path,
          const char *canonical_root, // pre-computed at startup
          char *resolved_out          // PATH_MAX=4096 bytes
      ) {
          char decoded[MAX_PATH_SIZE];
          if (url_decode(url_path, decoded,
                         sizeof(decoded)) < 0) return 400;
          char raw[MAX_PATH_SIZE * 2];
          snprintf(raw, sizeof(raw), "%s%s",
                   canonical_root, decoded);
          char *canon = realpath(raw, resolved_out);
          if (!canon) {
              if (errno==ENOENT) return 404;
              if (errno==EACCES) return 403;
              return 404;
          }
          size_t root_len = strlen(canonical_root);
          if (strncmp(resolved_out, canonical_root,
                      root_len) != 0) return 403;
          char next = resolved_out[root_len];
          if (next != '\0' && next != '/') return 403;
          return 0; // path is safe
      }
    |
  }
  mime_types: "mime_types.h — MIME Lookup Table" {
    style.fill: "#F0F9FF"
    style.border-radius: 6
    table: |md
      | Extension | MIME Type |
      |-----------|-----------|
      | .html/.htm | text/html; charset=utf-8 |
      | .css | text/css |
      | .js | application/javascript |
      | .json | application/json |
      | .png | image/png |
      | .jpg/.jpeg | image/jpeg |
      | .gif | image/gif |
      | .svg | image/svg+xml |
      | .txt | text/plain; charset=utf-8 |
      | .pdf | application/pdf |
      | .ico | image/x-icon |
      | .webp | image/webp |
      | (unknown) | application/octet-stream |
      Lookup: strrchr(path,'.') → lowercase ext → linear scan
      15 entries × 16B struct = 240B — fits in 4 cache lines
    |
  }
  conditional_cache: "date_utils.c — Conditional GETs" {
    style.fill: "#F0FDF4"
    style.border-radius: 6
    impl: |c
      // MUST use timegm() not mktime() — HTTP dates are UTC
      time_t parse_http_date(const char *s) {
          struct tm tm = {0};
          if (!strptime(s,
              "%a, %d %b %Y %H:%M:%S GMT", &tm))
              return (time_t)-1;
          return timegm(&tm); // UTC, not local timezone
      }
      // Returns 1 if 304 should be sent
      int should_send_304(const http_request_t *req,
                          time_t file_mtime) {
          const char *ims =
            request_get_header(req, "if-modified-since");
          if (!ims) return 0;
          time_t client_t = parse_http_date(ims);
          if (client_t == (time_t)-1) return 0;
          // <= not < : 1-second HTTP-date resolution
          return (file_mtime <= client_t) ? 1 : 0;
      }
    |
    flow: |md
      **Caching flow:**
      Client → `If-Modified-Since: <timestamp>`
      Server stat() → st_mtime
      st_mtime ≤ client_t → `304 Not Modified` (no body)
      st_mtime > client_t → `200 OK` + full file
    |
  }
  file_handler: "file_handler.c — 8-Phase Orchestrator" {
    style.fill: "#FEF2F2"
    style.border-radius: 6
    phases: "serve_static_file() — 8 Phases" {
      style.fill: "#FFF1F2"
      style.border-radius: 4
      p1: "① resolve_safe_path() → 400/403/404 on fail"
      p2: "② stat(resolved, &st) → file metadata"
      p3: "③ handle_directory_path() → append /index.html"
      p4: "④ S_ISREG(st.st_mode) check → reject devices"
      p5: "⑤ mime_type_for_path(resolved)"
      p6: "⑥ should_send_304() → 304 if cached"
      p7: "⑦ open(O_RDONLY) + send headers"
      p8: "⑧ 64KB read/write loop (skip for HEAD)"
      p1 -> p2 -> p3 -> p4 -> p5 -> p6 -> p7 -> p8
    }
    io_loop: |c
      // file_handler.c — 64KB I/O transfer loop
      // WHY 64KB: 16 pages × 4KB, fits L2 cache (256-512KB)
      //           2 syscalls per 64KB (read+write) amortized
      //           ~800 MB/s on page-cached files
      char io_buf[65536] __attribute__((aligned(64)));
      // aligned(64): 1 cache line boundary per chunk start
      ssize_t n;
      while ((n = read(file_fd, io_buf,
                       sizeof(io_buf))) > 0) {
          if (write_all(client_fd, io_buf, n) < 0)
              break; // client disconnected (EPIPE)
      }
      close(file_fd); // MANDATORY on all exit paths
      // sendfile() optimization: 0 copies, DMA direct
      // sendfile(client_fd, file_fd, NULL, file_size)
    |
    directory_index: |c
      // handle_directory_path()
      // Returns: 0=regular file, 1=index.html found,
      //         -1=no index.html (→403), -2=stat err
      int handle_directory_path(char *path,
                                 size_t path_buf,
                                 struct stat *st) {
          if (!S_ISDIR(st->st_mode)) return 0;
          size_t len = strlen(path);
          // append /index.html (max 11 bytes)
          if (len+12 > path_buf) return -1;
          strncat(path, "/index.html", path_buf-len-1);
          if (stat(path, st) < 0)
              return (errno==ENOENT) ? -1 : -2;
          return 1;
      }
    |
  }
  m3_errors: "M3 Error Matrix" {
    style.fill: "#F8FAFC"
    style.border-radius: 6
    tbl: |md
      | Condition | Detected By | Response |
      |-----------|-------------|----------|
      | %00 in URL | url_decode | 400 |
      | ../traversal | realpath+strncmp | 403 |
      | symlink outside root | realpath | 403 |
      | file not found | realpath ENOENT | 404 |
      | no index.html | stat ENOENT | 403 |
      | device file | S_ISREG | 403 |
      | client quit mid-file | write_all -1 | close file_fd |
    |
  }
}
# ═══════════════════════════════════════════════════════
# LAYER 4: MILESTONE 4 — Concurrent Thread Pool
# ═══════════════════════════════════════════════════════
L4_m4: "M4: Concurrent Connections\n[http-server-basic-m4]" {
  style: {
    fill: "#F5F3FF"
    stroke: "#8B5CF6"
    stroke-width: 2
    border-radius: 8
    font-size: 14
    bold: true
  }
  pool_data_model: "concurrency_types.h — Data Structures" {
    style.fill: "#EDE9FE"
    style.border-radius: 6
    work_item: "work_item_t [8 bytes]" {
      style.fill: "#F5F3FF"
      style.border-radius: 4
      fields: |c
        typedef struct {
          int  client_fd;  // 0x00 accepted connection FD
          char pad[4];     // 0x04 align to 8-byte boundary
        } work_item_t;     // Total: 8 bytes
      |
    }
    pool_struct: "thread_pool_t [~256 bytes + heap]" {
      style.fill: "#EDE9FE"
      style.border-radius: 4
      fields: |c
        typedef struct {
          // ── Queue Management ──────────────────────
          work_item_t *queue;       // 0x00 heap circular buf
          int  queue_capacity;      // 0x08 default 256
          int  queue_size;          // 0x0C current items
          int  queue_head;          // 0x10 dequeue index
          int  queue_tail;          // 0x14 enqueue index
          // ── Synchronization (cache-line boundary) ─
          pthread_mutex_t lock;     // 0x18 ~40B global lock
          pthread_cond_t  not_empty;// 0x40 work available
          pthread_cond_t  not_full; // 0x70 space available
          // ── Workers & Lifecycle ───────────────────
          pthread_t *threads;       // 0xA0 thread handles
          int  num_threads;         // 0xA8 default 16
          int  shutdown;            // 0xAC 0=run, 1=stop
          // ── Config (read-only, no lock needed) ────
          const char *doc_root;     // 0xB0 canonical path
          int  idle_timeout;        // 0xB8 default 30s
          // ── Stats (low-freq, kept at end) ─────────
          int  active_conns;        // 0xBC active threads
          long total_reqs;          // 0xC0 cumulative count
        } thread_pool_t;
        // NOTE: active_conns/total_reqs at end of struct
        // avoids False Sharing with high-freq queue fields
      |
    }
    queue_viz: "Circular Buffer State" {
      style.fill: "#F3F4F6"
      style.border-radius: 4
      txt: |md
        capacity=8, head=2, tail=5, size=3
        idx: [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
             [ ]  [ ]  [9]  [12] [15] [  ] [  ] [  ]
                        ↑head              ↑tail
        Enqueue: queue[tail] = item; tail=(tail+1)%cap
        Dequeue: item = queue[head]; head=(head+1)%cap
        Full when size==capacity → send 503
      |
    }
  }
  thread_pool_impl: "thread_pool.c — Core Implementation" {
    style.fill: "#DDD6FE"
    style.border-radius: 6
    init: |c
      // thread_pool.c
      int thread_pool_init(thread_pool_t *pool,
          int num_threads, int queue_cap,
          const char *root, int timeout) {
          memset(pool, 0, sizeof(*pool));
          pool->queue = calloc(queue_cap,sizeof(work_item_t));
          pool->queue_capacity = queue_cap;
          pool->num_threads    = num_threads;
          pool->doc_root       = root;  // read-only
          pool->idle_timeout   = timeout;
          pthread_mutex_init(&pool->lock, NULL);
          pthread_cond_init(&pool->not_empty, NULL);
          pthread_cond_init(&pool->not_full, NULL);
          pool->threads = calloc(num_threads,sizeof(pthread_t));
          for (int i=0; i<num_threads; i++) {
              if (pthread_create(&pool->threads[i], NULL,
                  worker_thread_fn, pool) != 0) {
                  // partial creation: shutdown already-created
                  pool->shutdown = 1;
                  pthread_cond_broadcast(&pool->not_empty);
                  for (int j=0;j<i;j++)
                      pthread_join(pool->threads[j], NULL);
                  return -1;
              }
          }
          return 0;
      }
    |
    worker_loop: |c
      // Worker thread — runs forever until shutdown
      static void *worker_thread_fn(void *arg) {
          thread_pool_t *pool = arg;
          for (;;) {
              pthread_mutex_lock(&pool->lock);
              // WHILE not IF: handles spurious wakeups
              while (pool->queue_size==0 && !pool->shutdown)
                  pthread_cond_wait(&pool->not_empty,
                                    &pool->lock);
              if (pool->shutdown && pool->queue_size==0) {
                  pthread_mutex_unlock(&pool->lock);
                  return NULL; // exit cleanly
              }
              // Dequeue
              work_item_t item = pool->queue[pool->queue_head];
              pool->queue_head =
                (pool->queue_head+1) % pool->queue_capacity;
              pool->queue_size--;
              pool->active_conns++;
              pthread_cond_signal(&pool->not_full);
              pthread_mutex_unlock(&pool->lock);
              // ⚠ I/O OUTSIDE lock — critical discipline
              handle_connection(item.client_fd, pool);
              pthread_mutex_lock(&pool->lock);
              pool->active_conns--;
              pthread_mutex_unlock(&pool->lock);
          }
      }
    |
    submit: |c
      // Returns 0=queued, -1=full or shutdown → send 503
      int thread_pool_submit(thread_pool_t *pool,
                             int client_fd) {
          pthread_mutex_lock(&pool->lock);
          if (pool->shutdown ||
              pool->queue_size >= pool->queue_capacity) {
              pthread_mutex_unlock(&pool->lock);
              return -1;
          }
          pool->queue[pool->queue_tail] =
            (work_item_t){.client_fd = client_fd};
          pool->queue_tail =
            (pool->queue_tail+1) % pool->queue_capacity;
          pool->queue_size++;
          pthread_cond_signal(&pool->not_empty);
          pthread_mutex_unlock(&pool->lock);
          return 0;
      }
    |
  }
  keepalive: "connection_handler.c — Keep-Alive Loop" {
    style.fill: "#F3E8FF"
    style.border-radius: 6
    timeout_setup: |c
      // Set recv timeout ONCE per connection (before loop)
      // SO_RCVTIMEO: read() returns EAGAIN after 30s idle
      // → breaks keep-alive loop → close → thread freed
      struct timeval tv = {.tv_sec = pool->idle_timeout};
      setsockopt(client_fd, SOL_SOCKET, SO_RCVTIMEO,
                 &tv, sizeof(tv));
    |
    loop: |c
      // handle_connection() — called by worker thread
      void handle_connection(int client_fd,
                             thread_pool_t *pool) {
          // set SO_RCVTIMEO once here (30s)
          for (;;) { // keep-alive loop
              char req_buf[REQUEST_BUF_SIZE]; // 8192B stack
              int header_end = -1;
              ssize_t n = read_http_request(client_fd,
                req_buf, REQUEST_BUF_SIZE, &header_end);
              if (n<0 || header_end<0) break; // timeout/err
              http_request_t req;
              int err = parse_http_request(req_buf,
                (size_t)n, header_end, &req);
              if (err) { send_error_by_code(client_fd,err);
                         break; }
              // update stats (brief lock)
              pthread_mutex_lock(&pool->lock);
              pool->total_reqs++;
              pthread_mutex_unlock(&pool->lock);
              if (req.method==METHOD_GET ||
                  req.method==METHOD_HEAD)
                  serve_static_file(&req, client_fd,
                                    pool->doc_root);
              else {
                  send_error_response(client_fd, 501,
                    "Not Implemented", "...");
                  break; // no keep-alive after 501
              }
              if (!req.keep_alive) break;
              // else: loop → wait for next request
          }
          close(client_fd); // always close on exit
      }
    |
    slowloris_defense: |md
      **Slowloris Attack:** 10,000 connections, 1 byte/20s
      → thread-per-connection → 80GB virtual memory, OOM
      **Pool defense:**
      - 17th connection → queue (no thread consumed)
      - SO_RCVTIMEO=30s → idle connections closed
      - Queue full (256) → send_503() immediately
    |
  }
  signals: "signals.c — Dedicated Signal Thread" {
    style.fill: "#FEF3C7"
    style.border-radius: 6
    impl: |c
      // signals.c — ONE thread owns all signals
      static void *signal_handler_thread(void *arg) {
          thread_pool_t *pool = arg;
          sigset_t waitset;
          sigemptyset(&waitset);
          sigaddset(&waitset, SIGTERM);
          sigaddset(&waitset, SIGINT);
          signal(SIGPIPE, SIG_IGN); // still ignore SIGPIPE
          int sig;
          sigwait(&waitset, &sig); // BLOCKS until signal
          printf("[%s] Graceful shutdown...\n",
            sig==SIGTERM?"SIGTERM":"SIGINT");
          thread_pool_shutdown(pool);
          close(g_server_fd); // unblocks accept()
          return NULL;
      }
      // thread_pool_shutdown():
      void thread_pool_shutdown(thread_pool_t *pool) {
          pthread_mutex_lock(&pool->lock);
          pool->shutdown = 1;
          pthread_cond_broadcast(&pool->not_empty); // ALL
          pthread_mutex_unlock(&pool->lock);
      }
    |
    graceful_shutdown: "4-Phase Graceful Shutdown" {
      style.fill: "#FFFBEB"
      style.border-radius: 4
      phases: |md
        **Phase 1:** Accept loop checks shutdown flag → stops accept()
        **Phase 2:** close(server_fd) → EBADF unblocks accept()
        **Phase 3:** shutdown=1 + broadcast → workers wake, drain queue
        **Phase 4:** thread_pool_join() → pthread_join all workers → exit(0)
        Kubernetes uses same pattern: SIGTERM → grace period → SIGKILL
      |
    }
  }
  mutex_discipline: "Mutex Rules & Lock Ordering" {
    style.fill: "#FEE2E2"
    style.border-radius: 6
    rules: |md
      **Lock Hierarchy (prevents deadlock):**
      1. `pool->lock` — queue + shutdown + stats
      2. `log_mutex` — stdout access log
      **Rule:** Never acquire log_mutex while holding pool->lock
      **Rule:** NEVER hold pool->lock during I/O (read/write/open)
      **Data Race Prevention:**
      - pool->shutdown: always read/write under pool->lock
        (or use atomic_int with atomic_load_explicit)
      - pool->total_reqs: brief lock acquire/increment/release
      - pool->doc_root: read-only after init → NO lock needed
      **Test:** gcc -fsanitize=thread → zero DATA RACE reports
    |
    mutex_cost: |md
      **Hardware cost of mutex_lock:**
      LOCK CMPXCHG (x86) ≈ 20-50ns uncontested
      Contested → futex syscall → ~2-5µs (kernel sleep)
      Cache coherence: invalidates 64B cache line on all cores
    |
  }
  pool_sizing: "Thread Pool Sizing Formula" {
    style.fill: "#ECFDF5"
    style.border-radius: 6
    formula: |md
      **I/O-bound formula (Little's Law):**
      `pool_size = num_cores × (1 + wait_time / compute_time)`
      Page-cached files: wait≈1µs, compute≈30µs
      → pool_size ≈ cores × 1.03 ≈ **num_cores**
      SSD cold reads: wait≈100µs, compute≈30µs
      → pool_size ≈ cores × 4.3 ≈ **~4× num_cores**
      Default 16 = good for 4-core machine + SSD
    |
  }
  m4_errors: "M4 Error Matrix" {
    style.fill: "#F8FAFC"
    style.border-radius: 6
    tbl: |md
      | Error | Detected By | Recovery |
      |-------|-------------|----------|
      | EAGAIN/EWOULDBLOCK | read() | SO_RCVTIMEO fired → break loop |
      | EMFILE | accept() | usleep(100ms) + continue |
      | Queue full | thread_pool_submit | send_503 + close |
      | pthread_create fail | thread_pool_init | shutdown others + return -1 |
      | EINTR | accept() | continue loop |
    |
  }
}
# ═══════════════════════════════════════════════════════
# CROSS-CUTTING: Hardware & Scale Notes
# ═══════════════════════════════════════════════════════
hardware_notes: "Hardware Soul & Scale Indicators" {
  style: {
    fill: "#F1F5F9"
    stroke: "#94A3B8"
    stroke-width: 1
    border-radius: 8
    font-size: 13
  }
  cache_hierarchy: |md
    **Cache Line = 64 bytes** (x86-64)
    L1 Cache: 32-64KB, ~1ns — entire HTTP req fits here
    L2 Cache: 256-512KB, ~4ns — 64KB IO buf fits here
    L3 Cache: 8-32MB, ~20ns — page cache metadata
    RAM: DDR4 ~20GB/s — 100KB file copy ≈ 5µs
    NVMe SSD: ~100µs — cold file read latency
    Spinning HDD: ~5ms — 50,000× slower than L1
  |
  syscall_costs: |md
    **Syscall overhead:** ~1-2µs (mode switch + TLB flush)
    realpath(): N×lstat() calls, N=path components → ~10µs
    read() cached: memcpy kernel→user, ~1ns/byte
    write() to socket: fill send buffer (~87KB default)
    accept(): TASK_INTERRUPTIBLE sleep → wake on SYN+ACK+ACK
    context switch: ~1-5µs, saves 80 cache lines of register state
  |
  atomic_ops: |md
    **LOCK CMPXCHG** (pthread_mutex on x86):
    - Uncontested: ~20-50 cycles = ~25ns at 2GHz
    - Contested: futex_wait syscall = ~2-5µs
    - False sharing: two vars in same 64B line → unnecessary invalidation
    - Solution: __attribute__((aligned(64))) per hot field
  |
}
# ═══════════════════════════════════════════════════════
# CONNECTIONS — Data Flow Between Layers
# ═══════════════════════════════════════════════════════
L0_config -> L1_m1: "port: int 8080\ndoc_root: char*" {
  style.stroke: "#6366F1"
  style.font-size: 12
}
L1_m1 -> L2_m2: "req_buf: char[8192]\nheader_end: int\nbytes: ssize_t" {
  style.stroke: "#22C55E"
  style.font-size: 12
}
L2_m2 -> L3_m3: "http_request_t*\nmethod: enum\npath: char[8192]\nkeep_alive: int" {
  style.stroke: "#F97316"
  style.font-size: 12
}
L3_m3 -> L4_m4: "serve_static_file()\nfile data: up to 64KB chunks\nContent-Length: long" {
  style.stroke: "#8B5CF6"
  style.font-size: 12
}
L4_m4.thread_pool_impl -> L4_m4.keepalive: "client_fd: int\npool: thread_pool_t*" {
  style.stroke: "#8B5CF6"
  style.font-size: 11
}
L4_m4.signals -> L4_m4.thread_pool_impl: "shutdown=1\nbroadcast not_empty" {
  style.stroke: "#DC2626"
  style.stroke-dash: 5
  style.font-size: 11
}
L1_m1.accumulator -> L1_m1.response_builder: "header_end: int\nbuf: char[8192]" {
  style.stroke: "#F59E0B"
  style.font-size: 11
}
hardware_notes -> L1_m1: "read() ~100ns cached\naccept() ~10-50µs" {
  style.stroke: "#94A3B8"
  style.stroke-dash: 3
  style.font-size: 11
}
hardware_notes -> L3_m3: "64KB = 16 pages\npage cache → ~5µs" {
  style.stroke: "#94A3B8"
  style.stroke-dash: 3
  style.font-size: 11
}
hardware_notes -> L4_m4: "CMPXCHG ~25ns\nfutex ~2-5µs" {
  style.stroke: "#94A3B8"
  style.stroke-dash: 3
  style.font-size: 11
}