direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- STYLES ---
classes: {
  decision: {
    shape: diamond
    style: {
      fill: "#E1F5FE"
      stroke: "#01579B"
    }
  }
  process: {
    shape: rectangle
    style: {
      fill: "#F5F5F5"
      stroke: "#212121"
      border-radius: 3
    }
  }
  error_terminal: {
    shape: parallelogram
    style: {
      fill: "#FFEBEE"
      stroke: "#B71C1C"
      font-color: "#B71C1C"
      bold: true
    }
  }
  success_terminal: {
    shape: parallelogram
    style: {
      fill: "#E8F5E9"
      stroke: "#1B5E20"
      font-color: "#1B5E20"
      bold: true
    }
  }
}

# --- DIAGRAM ---

Parser: "http_parser.c :: parse_http_request()" {
  Input: "RAW BYTE BUFFER\n(from read_http_request)" {
    shape: cylinder
  }

  Logic: {
    entry: "parse_request_line(char *line, http_request_t *req)" {
      class: process
    }

    space1: "strchr(line, ' ') == NULL?" {
      class: decision
    }

    space2: "strchr(path_start, ' ') == NULL?" {
      class: decision
    }

    method: "parse_method() == METHOD_UNKNOWN?" {
      class: decision
    }

    path_empty: "path_len == 0?" {
      class: decision
    }

    path_limit: "path_len >= 8192?" {
      class: decision
    }

    version: "parse_http_version() == -1?" {
      class: decision
    }

    semantic: "extract_semantic_headers()" {
      class: process
    }

    host_check: "minor == 1 && host == NULL?" {
      class: decision
    }

    # Connections
    entry -> space1
    
    space1 -> err400_1: "YES (No Method SP)" {style.stroke: red}
    space1 -> space2: "NO"

    space2 -> err400_2: "YES (No Path SP)" {style.stroke: red}
    space2 -> method: "NO"

    method -> err501: "YES (Valid syntax,\nunsupported verb)" {style.stroke: red}
    method -> path_empty: "NO (GET/HEAD/POST)"

    path_empty -> err400_3: "YES" {style.stroke: red}
    path_empty -> path_limit: "NO"

    path_limit -> err414: "YES (Oversized URI)" {style.stroke: red}
    path_limit -> version: "NO"

    version -> err400_4: "YES (Not HTTP/1.x)" {style.stroke: red}
    version -> semantic: "NO"

    semantic -> host_check
    
    host_check -> err400_5: "YES (RFC 7230 ยง5.4)" {style.stroke: red}
    host_check -> success: "NO"

    # Terminals
    err400_1.class: error_terminal
    err400_2.class: error_terminal
    err400_3.class: error_terminal
    err400_4.class: error_terminal
    err400_5.class: error_terminal
    err414.class: error_terminal
    err501.class: error_terminal
    success.class: success_terminal

    err400_1: "RETURN 400\nsend_error_response(fd, 400, \"Bad Request\", ...)"
    err400_2: "RETURN 400\nsend_error_response(fd, 400, \"Bad Request\", ...)"
    err400_3: "RETURN 400\nsend_error_response(fd, 400, \"Bad Request\", ...)"
    err400_4: "RETURN 400\nsend_error_response(fd, 400, \"Bad Request\", ...)"
    err400_5: "RETURN 400\nsend_error_response(fd, 400, \"Bad Request\", ...)"
    err414: "RETURN 414\nsend_error_response(fd, 414, \"URI Too Long\", ...)"
    err501: "RETURN 501\nsend_error_response(fd, 501, \"Not Implemented\", ...)"
    success: "RETURN 0\n(Proceed to serve_static_file)"
  }

  Input -> Logic.entry
}

# Annotations
Parser.Logic.err414.tooltip: "Protects against large URI buffer overflows"
Parser.Logic.err501.tooltip: "Valid verbs not supported by current server (e.g. DELETE, PATCH)"
Parser.Logic.err400_5.tooltip: "Enforces mandatory Host header for HTTP/1.1 compliance"