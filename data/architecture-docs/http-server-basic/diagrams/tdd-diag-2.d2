direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- STYLING ---
classes: {
  memory_header: {
    style: {
      fill: "#9b59b6"
      font-color: white
      bold: true
    }
  }
  data_segment: {
    style: {
      fill: "#519aba"
      font-color: white
    }
  }
  pointer: {
    style: {
      stroke: "#e67e22"
      stroke-width: 3
      font-color: "#e67e22"
      bold: true
    }
  }
  annotation: {
    shape: text
    style: {
      font-size: 14
      italic: true
    }
  }
}

# --- DIAGRAM ---

client: "HTTP Client" {
  shape: person
}

request: "Logical HTTP Message" {
  shape: sql_table
  style.fill: "#9b59b6"
  header: "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n"
  metadata: "Size: 38 Bytes"
}

network: "TCP Byte Stream (Fragmentation)" {
  seg1: "Segment 1: 10 bytes" { class: data_segment }
  seg2: "Segment 2: 20 bytes" { class: data_segment }
  seg3: "Segment 3: 8 bytes" { class: data_segment }
}

client -> request: "User triggers send()"
request -> network: "Kernel segments stream"

server_memory: "Server Accumulation Buffer (REQUEST_BUF_SIZE=8192)" {
  
  t1: "T1: After read() #1" {
    shape: sql_table
    "00": "GET / HTT (10B)" { class: data_segment }
    "10": " (Empty) (8182B)" { style.fill: "#2ecc71" }
    
    total_read: "total_read = 10" { class: pointer }
    status: "strstr() -> NULL" { style.font-color: red }
  }

  t2: "T2: After read() #2" {
    shape: sql_table
    "00": "GET / HTT (10B)" { class: data_segment }
    "10": "P/1.1\r\nHost: loc (20B)" { class: data_segment }
    "30": " (Empty) (8162B)" { style.fill: "#2ecc71" }
    
    total_read: "total_read = 30" { class: pointer }
    status: "strstr() -> NULL" { style.font-color: red }
  }

  t3: "T3: After read() #3" {
    shape: sql_table
    "00": "GET / HTT (10B)" { class: data_segment }
    "10": "P/1.1\r\nHost: loc (20B)" { class: data_segment }
    "30": "alhost\r\n\r\n (08B)" { style.fill: "#e74c3c"; style.font-color: white }
    "38": " (Empty) (8154B)" { style.fill: "#2ecc71" }
    
    total_read: "total_read = 38" { class: pointer }
    status: "strstr() -> FOUND \r\n\r\n" { style.font-color: "#2ecc71"; style.bold: true }
  }
}

network.seg1 -> server_memory.t1: "syscall read() returns 10"
network.seg2 -> server_memory.t2: "syscall read() returns 20"
network.seg3 -> server_memory.t3: "syscall read() returns 8"

legend: |md
  ### The Partial Read Reality
  1. **TCP is a stream**: The kernel returns available bytes, not full messages.
  2. **Accumulation**: Buffer must persist across `read()` calls.
  3. **Delimiter**: `strstr` is only valid once the full `\r\n\r\n` is resident.
| {
  near: bottom-right
}

# Layout Annotations
server_memory.t1 -> server_memory.t2: "Loop Continue"
server_memory.t2 -> server_memory.t3: "Loop Continue"
server_memory.t3 -> dispatch: "Transition to Parser" {
  style.stroke: "#e67e22"
  style.stroke-width: 4
}

dispatch: "Phase 2: HTTP Parser" {
  shape: diamond
  style.fill: "#f1c40f"
}