layout-engine: elk
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

classes: {
  step: {
    shape: rectangle
    style: {
      stroke-width: 1
      border-radius: 3
    }
  }
  highlight: {
    style: {
      stroke: red
      stroke-width: 3
      font-color: red
      bold: true
    }
  }
  memory: {
    shape: cylinder
    style: {
      fill: "#B6DDF6" # Blue (Data)
    }
  }
  header: {
    style: {
      fill: "#E4DBFE" # Purple (Header)
      bold: true
    }
  }
}

title: |md
  # Shared Counter Increments: Data Race vs. Mutex Logic
  **Target:** `pool->total_requests` (64-bit integer)
| {near: top-center}

"DATA RACE (UNPROTECTED)": {
  class: step
  style.fill: "#f8f9fa"

  T0: "Initial State" {
    mem: "Memory: 100" {class: memory}
  }

  T1: "Parallel Load" {
    reg_a: "Reg A: 100"
    reg_b: "Reg B: 100"
    reg_a -> T0.mem: "load"
    reg_b -> T0.mem: "load"
  }

  T2: "Thread A Write" {
    mem_prime: "Memory: **101**" {
      class: [memory; highlight]
    }
    T1.reg_a -> T2.mem_prime: "increment & store"
  }

  T3: "Thread B Write (Lost Increment)" {
    mem_double_prime: "Memory: **101**" {
      class: [memory; highlight]
    }
    T1.reg_b -> T3.mem_double_prime: "increment & store"
  }

  T2 -> T3: "OVERWRITE" {
    style: {
      stroke: red
      bold: true
    }
  }

  note: |md
    ### CRITICAL FAILURE
    Final Value: **101**
    Expected: **102**
    *Undefined Behavior Triggered*
  |
}

"SERIALIZED (MUTEX LOCK)": {
  class: step
  style.fill: "#f8f9fa"

  T0: "Initial State" {
    mem: "Memory: 100" {class: memory}
    lock: "Mutex: FREE" {style.fill: "#ACE1AF"} # Green (Free)
  }

  T1: "Thread A Acquire" {
    lock_a: "Mutex: **LOCKED (A)**" {class: highlight}
    reg_a: "Reg A: 100"
    lock_a -> T0.lock: "LOCK CMPXCHG"
    reg_a -> T0.mem: "load"
  }

  T2: "Thread B Blocked" {
    thread_b: "Thread B" {shape: person}
    thread_b -> T1.lock_a: "Spin/Wait" {style.stroke: red}
  }

  T3: "Thread A Release / B Acquire" {
    mem_prime: "Memory: **101**" {class: memory}
    lock_b: "Mutex: **LOCKED (B)**" {class: highlight}
    reg_b: "Reg B: **101**" {class: highlight}
    mem_prime -> lock_b: "unlock(A)"
    lock_b -> reg_b: "lock(B) & load"
  }

  T4: "Thread B Final Write" {
    mem_final: "Memory: **102**" {
      class: [memory; highlight]
    }
    T3.reg_b -> T4.mem_final: "increment & store"
  }

  note: |md
    ### CORRECT EXECUTION
    Final Value: **102**
    **Hardware:** LOCK prefix forces cache line 
    invalidation via MESI protocol (~40-100 cycles).
  |
}

"DATA RACE (UNPROTECTED)" -> "SERIALIZED (MUTEX LOCK)": "IMPLEMENTATION FIX" {
  style: {
    stroke-width: 4
    stroke-dash: 5
  }
}