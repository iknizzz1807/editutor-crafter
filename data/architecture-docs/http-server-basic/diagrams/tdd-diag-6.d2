layout-engine: elk
vars: {
  d2-config: {
    theme-id: 0
    pad: 20
  }
}

# --- PROCESS FILE DESCRIPTOR TABLE ---
fd_table: "Per-Process File Descriptor Table (FDT)\nsizeof=8192 bytes (2 pages)" {
  style: {
    stroke-width: 2
  }

  header: "FD TABLE (task_struct->files->fdt)" {
    style: {
      fill: "#8e44ad"
      font-color: white
      bold: true
    }
  }

  # --- Memory Slots ---
  # Slot 0
  offset_0: "0x000" { shape: text; style.font: mono }
  slot_0: "fd[0]: stdin" {
    style.fill: "#3498db"
    style.font-color: white
  }
  size_0: "8B" { shape: text; style.font: mono }

  # Slot 1
  offset_8: "0x008" { shape: text; style.font: mono }
  slot_1: "fd[1]: stdout" {
    style.fill: "#3498db"
    style.font-color: white
  }
  size_8: "8B" { shape: text; style.font: mono }

  # Slot 2
  offset_16: "0x010" { shape: text; style.font: mono }
  slot_2: "fd[2]: stderr" {
    style.fill: "#3498db"
    style.font-color: white
  }
  size_16: "8B" { shape: text; style.font: mono }

  # Slot 3 (Active Pointer - Orange)
  offset_24: "0x018" { shape: text; style.font: mono }
  slot_3: "fd[3]: server_fd (LISTEN)" {
    style.fill: "#e67e22"
    style.font-color: white
  }
  size_24: "8B" { shape: text; style.font: mono }

  # Slot 4 (Freed Slot - Green)
  offset_32: "0x020" { shape: text; style.font: mono }
  slot_4: "fd[4]: client_fd (FREED)" {
    tooltip: "Result of close(4). Slot returned to bitmap allocator."
    style.fill: "#2ecc71"
    style.font-color: white
    style.stroke-dash: 3
  }
  size_32: "8B" { shape: text; style.font: mono }

  # Padding (Gray)
  offset_pad: "0x028" { shape: text; style.font: mono }
  slot_pad: "UNALLOCATED / EMPTY" {
    style.fill: "#95a5a6"
    style.opacity: 0.5
  }
  size_pad: "8B" { shape: text; style.font: mono }

  # --- Cache Line Boundary (64B) ---
  cache_line_1: "----------------------- 64B CACHE LINE BOUNDARY -----------------------" {
    shape: text
    style.stroke-dash: 5
  }

  # --- Hard Limit ---
  offset_limit: "0x1FF8" { shape: text; style.font: mono }
  slot_limit: "fd[1023]: HARD LIMIT" {
    tooltip: "ulimit -n reached. Next accept() returns EMFILE."
    style.fill: "#e74c3c"
    style.font-color: white
  }
  size_limit: "8B" { shape: text; style.font: mono }

  # --- Page Boundary ---
  page_boundary: "======================= 4096B PAGE BOUNDARY =======================" {
    shape: text
    style.bold: true
  }

  # Horizontal Alignment (Row formation)
  offset_0 -> slot_0 -> size_0
  offset_8 -> slot_1 -> size_8
  offset_16 -> slot_2 -> size_16
  offset_24 -> slot_3 -> size_24
  offset_32 -> slot_4 -> size_32
  offset_pad -> slot_pad -> size_pad
  offset_limit -> slot_limit -> size_limit

  # Vertical Alignment (Table flow)
  header -> slot_0
  slot_0 -> slot_1
  slot_1 -> slot_2
  slot_2 -> slot_3
  slot_3 -> slot_4
  slot_4 -> slot_pad
  slot_pad -> cache_line_1
  cache_line_1 -> slot_limit
  slot_limit -> page_boundary
}

# --- KERNEL OBJECTS ---
kernel_memory: "Kernel Space (Virtual Memory)" {
  socket_listen: "struct socket (TCP/Listen)" {
    style.fill: "#3498db"
    style.font-color: white
    fields: |md
      - state: SS_LISTEN
      - type: SOCK_STREAM
      - sk_refcnt: 1
      - sk_rcvbuf: 87380
    |
  }

  socket_conn: "struct socket (TCP/Established)" {
    style.fill: "#3498db"
    style.font-color: white
    style.opacity: 0.4
    fields: |md
      - state: SS_DISCONNECTING
      - sk_refcnt: 0 (DECREMENTED)
    |
  }

  inode_sock: "struct inode (sockfs)" {
    style.fill: "#8e44ad"
    style.font-color: white
    label: "Inode: [Socket Interface]"
  }
}

# --- Pointer Connections ---
fd_table.slot_3 -> kernel_memory.socket_listen: "points to" {
  style.stroke: "#e67e22"
  style.stroke-width: 3
}

fd_table.slot_4 -> kernel_memory.socket_conn: "WAS pointing to" {
  style.stroke: "#95a5a6"
  style.stroke-dash: 5
}

kernel_memory.socket_listen -> kernel_memory.inode_sock
kernel_memory.socket_conn -> kernel_memory.inode_sock

# --- Annotations ---
annotation: |'md
### Kernel Lifecycle Notes
1. **accept()**: Kernel allocates lowest available FD (Slot 4), creates `struct socket`.
2. **close(4)**:
   - `task_struct->files->fdt[4]` is set to `NULL`.
   - `struct file` refcount decremented.
   - If refcount == 0, `struct socket` destruction begins (FIN/RST).
3. **EMFILE**: If `accept()` is called but all 1024 slots are non-NULL, kernel returns `-1` and sets `errno` to `EMFILE`.
'| {
  near: bottom-center
}