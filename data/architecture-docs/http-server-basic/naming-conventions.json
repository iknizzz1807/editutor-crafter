{
  "types": {
    "sockaddr_in": "fields: sin_family AF_INET, sin_port htons(port), sin_addr INADDR_ANY",
    "HTTPRequest": "fields: method[16] char, path[MAX_PATH_LENGTH] char, version[16] char, headers[][2][256] char, header_count int, body char*, body_length size_t",
    "HTTPResponse": "fields: status_code int, status_text[64] char, headers[][2][256] char, header_count int, body char*, body_length size_t",
    "ServerConfig": "fields: port int, document_root char[MAX_PATH_LENGTH], max_threads int, max_connections int, request_timeout_sec int",
    "ConnectionContext": "fields: client_fd int, client_addr sockaddr_in, connect_time time_t, thread_id pthread_t",
    "MimeTypeMapping": "fields: extension const char*, mime_type const char*",
    "ConcurrencyManager": "fields: model ConcurrencyModel, max_connections int, max_threads int, shutdown_requested volatile int, manager_mutex pthread_mutex_t",
    "ConcurrencyModel": "enum: THREAD_PER_CONNECTION, THREAD_POOL, EVENT_DRIVEN",
    "ConnectionQueue": "fields: connections ConnectionContext*, head int, tail int, size int, capacity int, mutex pthread_mutex_t",
    "ResourceCleanupContext": "fields: request HTTPRequest*, response HTTPResponse*, connection ConnectionContext*, client_fd int, cleanup_flags int",
    "RequestContext": "fields: connection ConnectionContext*, request HTTPRequest*, client_ip char[INET_ADDRSTRLEN], start_time time_t",
    "ConnectionState": "enum: CONNECTION_READING_REQUEST, CONNECTION_PARSING_REQUEST, CONNECTION_HANDLING_REQUEST, CONNECTION_SENDING_RESPONSE, CONNECTION_CLEANUP, CONNECTION_ERROR",
    "ErrorCategory": "enum: ERROR_CATEGORY_NETWORK, ERROR_CATEGORY_PROTOCOL, ERROR_CATEGORY_APPLICATION, ERROR_CATEGORY_RESOURCE, ERROR_CATEGORY_SECURITY",
    "SpecificErrorCode": "enum: various specific error codes for each category",
    "ErrorInfo": "fields: category ErrorCategory, specific_code SpecificErrorCode, system_errno int, timestamp time_t, context and message fields",
    "ClientConfig": "fields: server_host char*, server_port int, request_path char*, client_id int, success_count int*, count_mutex pthread_mutex_t*",
    "DebugLevel": "enum: DEBUG_ERROR, DEBUG_WARN, DEBUG_INFO, DEBUG_DEBUG, DEBUG_TRACE",
    "PerfTimer": "fields: start_time struct timespec, operation_name const char*",
    "CacheEntry": "fields: key[CACHE_KEY_LENGTH] char, response_data char*, response_length size_t, created_time time_t, last_access time_t, access_count uint64_t, next CacheEntry*, prev CacheEntry*",
    "CacheManager": "fields: entries[MAX_CACHE_ENTRIES] CacheEntry*, lru_head CacheEntry*, lru_tail CacheEntry*, total_memory size_t, max_memory size_t, hits uint64_t, misses uint64_t, cache_lock pthread_rwlock_t",
    "TLSContext": "fields: ssl_ctx SSL_CTX*, ssl SSL*, socket_fd int, is_server int"
  },
  "methods": {
    "create_server_socket(port) returns int": "creates and configures server socket",
    "read_complete_request(sockfd, buffer, max_size) returns ssize_t": "reads complete HTTP request handling partial reads",
    "validate_and_resolve_path(document_root, request_path, resolved_path, max_path_len) returns int": "validates request path against directory traversal",
    "server_main_loop(server_fd) returns void": "main connection acceptance loop",
    "init_http_request(request) returns void": "initialize HTTPRequest with safe defaults",
    "init_http_response(response) returns void": "initialize HTTPResponse structure with safe defaults",
    "init_server_config(config) returns void": "initialize ServerConfig with sensible defaults",
    "init_connection_context(context, client_fd, addr) returns void": "initialize connection context with client information",
    "cleanup_http_request(request) returns void": "free dynamically allocated request memory",
    "cleanup_http_response(response) returns void": "free dynamically allocated response memory",
    "add_response_header(response, key, value) returns int": "add header to HTTP response with bounds checking",
    "get_request_header(request, key) returns const char*": "find header value by key in HTTP request",
    "parse_http_request(raw_data, data_length, request) returns int": "parses complete HTTP request from raw bytes",
    "parse_request_line(line, request) returns int": "extracts method, path, version from request line",
    "parse_header_line(line, request) returns int": "parses single header and adds to collection",
    "parse_message_body(body_start, available_bytes, request) returns int": "process HTTP message body based on Content-Length",
    "get_request_header(request, header_name) returns const char*": "retrieve header value by name case-insensitively",
    "find_line_end(start, buffer_end, line_length) returns const char*": "finds CRLF or LF line ending",
    "safe_string_copy(dest, dest_size, src, src_length) returns int": "safely copies string with bounds checking",
    "trim_whitespace(str) returns char*": "trims leading and trailing whitespace",
    "strcasecmp_http(s1, s2) returns int": "case-insensitive string comparison",
    "detect_mime_type(file_path, mime_type, max_mime_len) returns int": "determines MIME type based on file extension",
    "serve_file_content(resolved_path, response) returns int": "read file contents into response body",
    "handle_directory_request(resolved_path, response) returns int": "generates directory listing HTML",
    "generate_error_response(status_code, error_message, response) returns void": "creates standardized HTTP error response",
    "check_file_permissions(file_path) returns int": "verifies server has read permissions",
    "url_decode(path) returns int": "converts percent-encoded characters in-place",
    "normalize_path(input, output, output_size) returns int": "removes . and .. path components",
    "get_mime_type(file_path) returns const char*": "returns MIME type for file extension",
    "serve_static_file(request, response, config) returns int": "main file serving function",
    "read_file_content(file_path, response) returns int": "reads file with streaming support",
    "generate_directory_listing(dir_path, url_path, response) returns int": "creates HTML directory listing",
    "init_concurrency_manager(config, model) returns ConcurrencyManager*": "initializes concurrency manager with specified model",
    "start_connection_handler(manager, client_fd, client_addr) returns int": "dispatches new client connection to available handler",
    "wait_for_completion(manager) returns void": "blocks until all active connections complete",
    "get_active_connection_count(manager) returns int": "returns number of currently active connections",
    "shutdown_concurrency_manager(manager, graceful) returns void": "initiates shutdown sequence with optional graceful waiting",
    "cleanup_concurrency_manager(manager) returns void": "releases all manager resources",
    "cleanup_connection_context(context) returns void": "cleanup connection context and close socket",
    "handle_client_connection(arg) returns void*": "thread entry point for processing client connections",
    "increment_connection_count() returns int": "thread-safe increment of active connection counter",
    "decrement_connection_count() returns int": "thread-safe decrement of active connection counter",
    "enqueue_connection(queue, context) returns int": "adds connection to work queue for thread pool",
    "dequeue_connection(queue) returns ConnectionContext*": "removes connection from work queue",
    "pthread_create(thread, attr, start_routine, arg) returns int": "creates new thread with specified entry point",
    "pthread_detach(thread) returns int": "marks thread for automatic cleanup on termination",
    "pthread_join(thread, retval) returns int": "waits for thread completion and retrieves return value",
    "pthread_mutex_lock(mutex) returns int": "acquires exclusive lock on mutex",
    "pthread_mutex_unlock(mutex) returns int": "releases exclusive lock on mutex",
    "init_connection_context(context, client_fd, addr)": "initialize connection context with client information",
    "read_complete_request(sockfd, buffer, max_size)": "reads complete HTTP request handling partial reads",
    "parse_http_request(raw_data, data_length, request)": "parses complete HTTP request from raw bytes",
    "serve_static_file(request, response, config)": "main file serving function",
    "generate_error_response(status_code, error_message, response)": "creates standardized HTTP error response",
    "cleanup_http_request(request)": "free dynamically allocated request memory",
    "cleanup_http_response(response)": "free dynamically allocated response memory",
    "cleanup_connection_context(context)": "cleanup connection context and close socket",
    "handle_client_connection(arg)": "thread entry point for processing client connections",
    "log_security_event(event_type, client_ip, request_path, details)": "logs security events with context",
    "init_request_context(ctx, conn, req)": "initialize request context for error tracking",
    "cleanup_request_resources(cleanup)": "cleanup all resources using cleanup context",
    "create_error_info(category, code, context) returns ErrorInfo*": "create comprehensive error information",
    "classify_error(errno, context) returns ErrorCategory": "classify errors by source and severity",
    "send_http_request(host, port, path, response, max_response) returns int": "sends HTTP request and receives response",
    "client_thread(arg) returns void*": "thread entry point for concurrent testing",
    "monitor_resources(duration, interval) returns void": "monitors server resource usage",
    "test_connection_limits(max_connections) returns void": "tests server connection handling limits",
    "get_server_pid() returns pid": "retrieves server process ID",
    "run_milestone_tests(milestone) returns int": "executes tests for specified milestone",
    "test_server_startup() returns int": "verifies server starts and binds correctly",
    "test_connection_acceptance() returns int": "tests basic TCP connection handling",
    "test_concurrent_requests() returns int": "validates concurrent request processing",
    "test_resource_limits() returns int": "checks resource limit enforcement",
    "setup_test_environment() returns void": "prepares test environment and dependencies",
    "cleanup_test_environment() returns void": "cleans up test files and processes",
    "generate_test_report() returns void": "creates comprehensive test results report",
    "init_debug_system(log_file, level) returns void": "initializes debugging system with file and level",
    "log_request_processing(request, context) returns void": "logs HTTP request details with client info",
    "log_response_generation(response, context) returns void": "logs HTTP response details and timing",
    "debug_connection_state(context, state) returns void": "logs connection state transitions",
    "monitor_server_health(server_pid) returns void": "monitors server resource usage",
    "start_perf_timer(timer, operation) returns void": "begins performance timing measurement",
    "end_perf_timer(timer) returns void": "ends performance timing and logs results",
    "debug_malloc(size, file, line) returns void*": "debug wrapper for malloc with tracking",
    "debug_free(ptr, file, line) returns void": "debug wrapper for free with tracking",
    "dump_http_request(request) returns void": "prints detailed HTTP request structure",
    "dump_http_response(response) returns void": "prints detailed HTTP response structure",
    "log_connection_event(context, event) returns void": "logs connection lifecycle events",
    "init_cache_manager(max_memory_bytes) returns CacheManager*": "initialize cache manager with memory limits",
    "cache_store_response(cache, key, response_data, response_length) returns int": "store response in cache with automatic eviction",
    "cache_get_response(cache, key, response_length) returns char*": "retrieve cached response or NULL if not found",
    "generate_cache_key(file_path, query_string, cache_key, key_length) returns void": "generate cache key from request path and headers",
    "handle_basic_authentication(request, response) returns int": "process HTTP Basic authentication",
    "verify_user_credentials(username, password) returns int": "verify credentials against user database",
    "init_tls_server_context(cert_file, key_file) returns TLSContext*": "initialize TLS context with certificate and key",
    "tls_accept_connection(server_ctx, client_fd, client_ctx) returns int": "accept TLS connection on server socket",
    "tls_read(ctx, buffer, length) returns ssize_t": "TLS-aware socket read operation",
    "tls_write(ctx, buffer, length) returns ssize_t": "TLS-aware socket write operation",
    "htons(port) returns int": "converts port to network byte order"
  },
  "constants": {
    "AF_INET": "IPv4 address family",
    "SOCK_STREAM": "TCP socket type",
    "SO_REUSEADDR": "socket option to reuse addresses",
    "INADDR_ANY": "bind to all available interfaces",
    "MAX_REQUEST_SIZE": "8192 maximum request size",
    "MAX_PATH_LENGTH": "1024 maximum path length",
    "DEFAULT_PORT": "8080 default server port",
    "MAX_HEADERS": "32 maximum number of headers",
    "MAX_CONNECTIONS": "100 default maximum concurrent connections",
    "MAX_THREADS": "10 default thread pool size",
    "PTHREAD_CREATE_DETACHED": "thread attribute for automatic cleanup",
    "O_NONBLOCK": "file descriptor flag for non-blocking I/O",
    "CLEANUP_REQUEST": "cleanup flag for HTTP request",
    "CLEANUP_RESPONSE": "cleanup flag for HTTP response",
    "CLEANUP_CONNECTION": "cleanup flag for connection context",
    "CLEANUP_SOCKET": "cleanup flag for socket file descriptor",
    "PATH_ERROR_TRAVERSAL": "directory traversal security error",
    "PATH_ERROR_TOO_LONG": "path length limit exceeded",
    "FILE_ERROR_NOT_FOUND": "requested file not found",
    "FILE_ERROR_PERMISSION": "file access permission denied",
    "PARSE_ERROR_INVALID_METHOD": "unsupported HTTP method",
    "PARSE_ERROR_MALFORMED_HEADER": "invalid header format",
    "CAPACITY_ERROR_THREAD_POOL": "thread pool exhaustion",
    "INET_ADDRSTRLEN": "IP address string buffer size",
    "MAX_RESPONSE_SIZE": "8192 maximum HTTP response buffer",
    "MAX_CONCURRENT_CLIENTS": "100 maximum concurrent test clients",
    "DEBUG_ERROR": "error level logging",
    "DEBUG_WARN": "warning level logging",
    "DEBUG_INFO": "info level logging",
    "DEBUG_DEBUG": "debug level logging",
    "DEBUG_TRACE": "trace level logging",
    "PTHREAD_MUTEX_INITIALIZER": "static mutex initializer",
    "MAX_CACHE_ENTRIES": "1000 maximum cache entries",
    "MAX_CACHED_FILE_SIZE": "1MB maximum cached file size",
    "CACHE_KEY_LENGTH": "256 cache key buffer length"
  },
  "terms": {
    "directory traversal": "security attack using ../ to access files outside root",
    "partial read": "network read returning fewer bytes than requested",
    "file descriptor leak": "failure to close file descriptors causing resource exhaustion",
    "thread-per-connection": "concurrency model creating dedicated thread for each client",
    "event-driven": "concurrency model using single thread with I/O multiplexing",
    "scope creep": "uncontrolled addition of features beyond defined requirements",
    "graceful degradation": "system continues functioning with reduced capability under stress",
    "production-quality": "code suitable for real-world deployment with proper error handling",
    "buffer overflow protection": "preventing writes beyond allocated memory",
    "memory ownership": "clear responsibility for allocating and freeing memory",
    "network byte order": "big-endian byte ordering used in network protocols",
    "thread pool": "concurrency model with fixed number of worker threads sharing connections",
    "graceful shutdown": "shutdown process that completes in-flight requests before stopping",
    "connection context": "per-connection state tracking structure",
    "resource exhaustion": "system running out of threads, memory, or file descriptors",
    "race condition": "concurrent access to shared data without proper synchronization",
    "deadlock": "circular waiting condition where threads block each other",
    "non-blocking I/O": "I/O operations that return immediately rather than waiting",
    "thread safety": "property that code works correctly when accessed by multiple threads",
    "mutex": "mutual exclusion primitive for protecting shared data",
    "detached thread": "thread that automatically cleans up resources when it terminates",
    "error propagation": "flow of error information between system components",
    "partial write": "network write sending fewer bytes than requested",
    "cleanup sequence": "ordered resource deallocation process",
    "error classification": "categorizing errors by source and severity",
    "security event logging": "recording security-relevant events for monitoring",
    "request-response cycle": "complete processing flow from client request to server response",
    "load testing": "testing system behavior under high concurrent load",
    "stress testing": "testing system limits and failure modes",
    "connection multiplexing": "single thread handling multiple simultaneous connections",
    "keep-alive": "HTTP connection reuse mechanism for multiple requests",
    "chunked encoding": "HTTP transfer encoding for streaming responses without Content-Length",
    "connection pooling": "reusing TCP connections across multiple HTTP requests",
    "asynchronous I/O": "non-blocking I/O operations with event notification",
    "TLS handshake": "cryptographic negotiation process establishing secure connection",
    "certificate management": "handling X.509 certificates and private keys for HTTPS",
    "authentication": "identity verification process for user credentials",
    "authorization": "access control based on verified user identity",
    "security headers": "HTTP headers providing client-side security policies",
    "rate limiting": "restricting request frequency to prevent abuse",
    "cache hit": "successful retrieval of data from cache storage",
    "cache eviction": "removal of entries from cache due to memory limits",
    "LRU eviction": "least recently used cache replacement policy"
  }
}