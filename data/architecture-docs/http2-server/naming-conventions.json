{
  "types": {
    "Frame": "fields: Length uint32, Type uint8, Flags uint8, StreamID uint32, Payload []byte",
    "Connection": "fields: conn net.Conn, reader *bufio.Reader, writer *bufio.Writer, mu sync.RWMutex, closed bool",
    "ProtocolError": "fields: Code ErrorCode, Message string, StreamID uint32, FrameType uint8, Fatal bool",
    "ErrorCode": "uint32",
    "ScopeValidator": "fields: enabledFeatures map[string]bool, resourceLimits ResourceLimits",
    "ResourceLimits": "fields: MaxConnections int, MaxStreamsPerConn int, MaxFrameSize uint32, DynamicTableSize uint32, ConnectionWindow uint32",
    "Stream": "fields: sendWindow int64, recvWindow int64",
    "DynamicTable": "fields: entries []HeaderEntry, size uint32, maxSize uint32",
    "HeaderEntry": "fields: Name string, Value string, Size uint32",
    "StreamState": "int enum for stream lifecycle states",
    "HuffmanDecoder": "fields: accumulator uint64, bitCount int",
    "IntegerDecoder": "fields: prefixBits int, maxBytes int",
    "StreamManager": "fields: streams map[uint32]*Stream, maxConcurrentStreams uint32, currentStreamCount uint32, nextClientStreamID uint32, nextServerStreamID uint32",
    "StreamPriority": "fields: Weight uint8, DependsOn uint32, Exclusive bool",
    "WindowManager": "fields: connectionSendWindow int64, connectionRecvWindow int64, streamWindows map[uint32]*StreamWindows, initialWindowSize uint32, maxWindowSize int64",
    "StreamWindows": "fields: sendWindow int64, recvWindow int64, lastActivity time.Time",
    "QueuedFrame": "fields: frame *Frame, timestamp time.Time, streamID uint32, originalSize uint32, retryCount int",
    "BackpressureQueue": "fields: streamQueues map[uint32][]QueuedFrame, blockedOnConnection []uint32, blockedOnStream []uint32, totalQueuedBytes int64, maxQueueSize int64",
    "PriorityScheduler": "fields: streamWeights map[uint32]uint8, streamDeficits map[uint32]int64, quantumSize int64",
    "ScheduledStream": "fields: streamID uint32, weight uint8, deficit int64, queueSize int64",
    "RequestProcessor": "fields: frameRouter *FrameRouter, streamManager *StreamManager, hpackEngine *HpackEngine, flowController *WindowManager, connHandler *Connection, headerQueue chan *HeaderBlock, errorChan chan error, shutdownChan chan struct{}, wg sync.WaitGroup",
    "HeaderBlock": "fields: StreamID uint32, Headers []byte, EndStream bool, Priority *StreamPriority, Assembly time.Time",
    "FrameRouter": "fields: streamStates map[uint32]StreamState, statesMutex sync.RWMutex, connHandler *Connection, streamManager *StreamManager, flowController *WindowManager, frameCount map[uint8]uint64, errorCount map[ErrorCode]uint64, statsMutex sync.RWMutex",
    "HeaderAssembler": "fields: assemblyBuffers map[uint32]*AssemblyBuffer, buffersMutex sync.RWMutex, maxBufferSize uint32, maxBuffers int, timeout time.Duration",
    "AssemblyBuffer": "fields: streamID uint32, fragments [][]byte, totalSize uint32, expectingCont bool, created time.Time, lastUpdate time.Time",
    "ErrorTracker": "fields: mu sync.RWMutex, connectionErrors map[ErrorCode]uint64, streamErrors map[ErrorCode]uint64",
    "ErrorHandler": "fields: conn *Connection, frameRouter *FrameRouter, streamManager *StreamManager, tracker *ErrorTracker",
    "TestServerConfig": "fields: TLS bool, Port int, MaxStreams uint32, WindowSize uint32, FrameSize uint32",
    "TestClient": "fields: client *http.Client, transport *http2.Transport, baseURL string",
    "ResponseMetrics": "fields: StreamID uint32, StatusCode int, ResponseTime time.Duration, BytesRead int64, Headers http.Header, Error error",
    "ProtocolLogger": "structured logging for HTTP/2 protocol events",
    "FrameValidator": "comprehensive HTTP/2 frame validation",
    "HPACKDebugger": "detailed HPACK compression/decompression logging",
    "ConnectionMonitor": "connection health and diagnostics tracking",
    "FrameFuzzer": "generates malformed HTTP/2 frames for testing",
    "StreamMetrics": "per-stream diagnostic information",
    "HealthReport": "comprehensive connection diagnostic report",
    "Anomaly": "unusual patterns indicating potential bugs",
    "PushCandidate": "fields: URL string, Method string, Headers http.Header, Priority uint8, EstimatedSize int64, CacheControl string",
    "PushPolicy": "fields: MaxConcurrentPushes int, MaxResourceSize int64, AllowedContentTypes []string, CacheAwareStrategy bool",
    "PushManager": "fields: policy *PushPolicy, streamManager *StreamManager, connectionState *Connection, activePromises map[uint32]*PushedStream, mu sync.RWMutex",
    "PushedStream": "fields: StreamID uint32, ParentStreamID uint32, Resource PushCandidate, State StreamState, CreatedAt time.Time, PromiseSent bool, ResponseSent bool",
    "CertificateManager": "fields: certificates map[string]*x509.Certificate, coalescable map[string][]string, mu sync.RWMutex",
    "CoalescingPool": "fields: connections map[string]*Connection, hostMapping map[string]string, certManager *CertificateManager, mu sync.RWMutex",
    "BufferPool": "fields: small sync.Pool, medium sync.Pool, large sync.Pool, stats PoolStats, mu sync.Mutex",
    "PoolStats": "fields: SmallHits uint64, SmallMisses uint64, MediumHits uint64, MediumMisses uint64, LargeHits uint64, LargeMisses uint64",
    "ObjectPool": "fields: pool sync.Pool, new func() T, reset func(T)",
    "VectoredWriter": "fields: conn net.Conn, buffers [][]byte, pending []*Frame, maxBatch int, timeout time.Duration",
    "ZeroCopyTransmitter": "fields: conn net.Conn, file *os.File"
  },
  "methods": {
    "ParseFrame(r io.Reader) (*Frame, error)": "reads and parses HTTP/2 frame from reader",
    "SerializeFrame(w io.Writer, f *Frame) (int, error)": "writes frame in HTTP/2 wire format",
    "ValidateFrame(f *Frame) error": "checks frame protocol compliance",
    "NewConnection(conn net.Conn) *Connection": "creates buffered connection wrapper",
    "NewProtocolError(code ErrorCode, message string) *ProtocolError": "creates protocol error with code and message",
    "ValidateFeatureRequest(feature string) error": "checks if feature request aligns with goals",
    "ValidateResourceUsage(usage ResourceUsage) error": "checks if current usage meets non-functional goals",
    "Add(name, value string)": "inserts header entry with FIFO eviction",
    "Lookup(index uint32) (HeaderEntry, bool)": "retrieves entry by HPACK index",
    "Resize(newSize uint32)": "adjusts table size with eviction",
    "DecodeHuffman(encoded []byte) (string, error)": "decodes Huffman-compressed string",
    "DecodeInteger(reader io.Reader, prefixBits int) (uint32, error)": "decodes variable-length integer",
    "calculateEntrySize(name, value string) uint32": "returns HPACK entry size including overhead",
    "NewDynamicTable(maxSize uint32) *DynamicTable": "creates dynamic table with size limit",
    "TransitionState(newState StreamState, frameType uint8) error": "validates and executes stream state transitions",
    "AllocateStreamID(isClientInitiated bool) (uint32, error)": "allocates next available stream ID with odd/even separation",
    "ScheduleStreams(availableWindow int64) map[uint32]int64": "distributes bandwidth among streams based on priority weights",
    "HandleRSTStream(streamID uint32, errorCode uint32) error": "processes stream reset and cleanup",
    "CreateStream(streamID uint32, isClientInitiated bool) (*Stream, error)": "creates new stream with validation",
    "CanSendData(streamID uint32, dataSize uint32) (bool, error)": "checks if DATA frame transmission is allowed given current windows",
    "ConsumeWindows(streamID uint32, dataSize uint32) error": "decrements both stream and connection send windows",
    "ProcessWindowUpdate(streamID uint32, increment uint32) error": "applies WINDOW_UPDATE frame to appropriate windows",
    "QueueFrame(frame *Frame, streamID uint32, priority uint8) error": "adds DATA frame to backpressure queue",
    "ProcessQueues(wm *WindowManager) ([]QueuedFrame, error)": "attempts transmission of queued frames",
    "GenerateWindowUpdates() ([]*Frame, error)": "creates WINDOW_UPDATE frames for low windows",
    "SetStreamPriority(streamID uint32, weight uint8)": "configures stream scheduling weight",
    "ScheduleTransmission(availableWindow int64, queuedStreams map[uint32]int64) []uint32": "performs deficit round-robin scheduling",
    "ProcessConnection(ctx context.Context) error": "runs main request processing loop",
    "processNextFrame(ctx context.Context) error": "handles one complete frame processing cycle",
    "RouteFrame(frame *Frame) error": "dispatches parsed frame to appropriate component handler",
    "AssembleHeaders(frame *Frame) (*HeaderBlock, error)": "collects HEADERS and CONTINUATION frames into complete header blocks",
    "headerDecompressionWorker(ctx context.Context)": "processes sequential header decompression queue",
    "errorCoordinator(ctx context.Context)": "handles error propagation and recovery across components",
    "validateStreamTransition(streamID uint32, frameType uint8) error": "checks if frame is valid for current stream state",
    "updateStreamState(streamID uint32, newState StreamState)": "synchronizes router stream state cache with stream manager",
    "NewRequestProcessor(conn net.Conn, limits ResourceLimits) *RequestProcessor": "creates processor coordinating all HTTP/2 components",
    "NewFrameRouter(conn *Connection, limits ResourceLimits) *FrameRouter": "creates router dispatching frames to appropriate handlers",
    "NewHeaderAssembler(maxBuffers int, maxSize uint32, timeout time.Duration) *HeaderAssembler": "creates assembler for fragmented header blocks",
    "HandleError(err error) error": "processes detected errors and generates appropriate responses",
    "ValidateFrame(frame *Frame) error": "performs comprehensive frame validation",
    "ValidateStreamTransition(streamID uint32, frameType uint8, flags uint8) error": "checks if frame is valid for current stream state",
    "SendGOAWAY(errorCode ErrorCode, lastStreamID uint32, debugData string) error": "generates and sends connection termination frame",
    "SendRSTStream(streamID uint32, errorCode ErrorCode) error": "terminates individual stream with error code",
    "RecordError(err *ProtocolError)": "tracks error statistics for monitoring",
    "StartTestServer(t *testing.T, config TestServerConfig) (*server.Server, net.Addr)": "creates and starts HTTP/2 server for testing",
    "NewTestClient(serverAddr string, tlsConfig *tls.Config) *TestClient": "creates HTTP/2 client configured for testing",
    "SendFrameSequence(ctx context.Context, frames []Frame) error": "sends custom HTTP/2 frame sequence for protocol testing",
    "TestMultiplexing(ctx context.Context, requestCount int) ([]ResponseMetrics, error)": "creates multiple concurrent streams for multiplexing tests",
    "LogFrameEvent(streamID uint32, event string, frame *Frame)": "logs frame processing events",
    "ValidateFrameStructure(frame *Frame) error": "performs comprehensive frame structure validation",
    "ValidateStreamContext(frame *Frame, streamID uint32) error": "checks if frame is valid for current stream state",
    "LogTableOperation(operation string, index uint32, entry HeaderEntry)": "records HPACK table modifications for debugging",
    "ValidateTableState() []error": "performs consistency checks on HPACK tables",
    "GenerateHealthReport() *HealthReport": "creates comprehensive connection diagnostic report",
    "DetectAnomalies() []Anomaly": "identifies unusual patterns that may indicate bugs",
    "GenerateMalformedFrame(corruption CorruptionType) *Frame": "creates systematically corrupted frames",
    "EvaluatePushCandidates(parentStreamID uint32, responseHeaders http.Header, body []byte) ([]PushCandidate, error)": "analyzes response content and identifies resources suitable for pushing",
    "CreatePushPromise(parentStreamID uint32, candidate PushCandidate) (*Frame, uint32, error)": "constructs PUSH_PROMISE frame and allocates promised stream ID",
    "ValidateHostnameCoalescing(primary, secondary string) (bool, error)": "checks if two hostnames can share a connection based on certificate coverage",
    "FindCoalescableConnection(hostname string) (*Connection, bool)": "attempts to find existing connection suitable for hostname coalescing",
    "AcquireBuffer(size int) []byte": "gets appropriately sized buffer from pool with size-based classification",
    "ReleaseBuffer(buffer []byte)": "returns buffer to appropriate pool for reuse with statistics tracking",
    "WriteFrameVector(frames []*Frame) (int, error)": "writes multiple frames in single syscall using vectored I/O",
    "SendFileData(streamID uint32, file *os.File, offset, size int64) error": "transmits file content without user-space copying using sendfile",
    "ValidateFrameType(frameType uint8) error": "checks if frame type is known and supported",
    "ValidateStreamID(streamID uint32, frameType uint8) error": "checks stream ID constraints and reserved bit handling",
    "String() string": "returns human-readable representation for debugging",
    "CanReceiveFrame(frameType uint8) bool": "checks if frame type is valid for current stream state"
  },
  "constants": {
    "FrameTypeDATA": "0x0",
    "FrameTypeHEADERS": "0x1",
    "FrameTypeSETTINGS": "0x4",
    "FlagEndStream": "0x1",
    "FlagEndHeaders": "0x4",
    "MaxFrameSize": "16777215",
    "DefaultFrameSize": "16384",
    "InitialWindowSize": "65535",
    "ErrorCodeProtocolError": "0x1",
    "ErrorCodeFlowControlError": "0x3",
    "EOS_SYMBOL": "30-bit End-of-String symbol for Huffman padding",
    "StateIdle": "0",
    "StateOpen": "3",
    "StateHalfClosedLocal": "5",
    "StateHalfClosedRemote": "4",
    "StateClosed": "6",
    "FrameTypeWINDOWUPDATE": "0x8",
    "ErrorCodeCompressionError": "0x9",
    "ErrorCodeEnhanceYourCalm": "0xb",
    "ErrorCodeCancel": "0x8",
    "ErrorCodeRefusedStream": "0x7",
    "ErrorCodeStreamClosed": "0x5",
    "ErrorCodeFrameSizeError": "0x6",
    "CategoryFrame": "frame-level logging category",
    "CategoryHPACK": "HPACK-related logging category",
    "CategoryStream": "stream lifecycle logging category",
    "CategoryFlowControl": "flow control logging category",
    "CategoryError": "error condition logging category",
    "CorruptionInvalidLength": "frame length corruption type",
    "CorruptionReservedBits": "reserved bit corruption type",
    "CorruptionInvalidType": "invalid frame type corruption",
    "CorruptionRandomPayload": "random payload corruption",
    "FrameTypePUSH_PROMISE": "0x5",
    "SETTINGS_ENABLE_PUSH": "HTTP/2 setting parameter for push enable/disable",
    "SETTINGS_MAX_CONCURRENT_STREAMS": "HTTP/2 setting parameter for stream limits including pushed streams",
    "StateReservedLocal": "stream state for server-initiated promised streams",
    "FrameTypeWINDOW_UPDATE": "0x8",
    "StaticTableSize": "61",
    "DefaultTableSize": "4096",
    "HuffmanEOSSymbol": "256",
    "HeaderEntryOverhead": "32"
  },
  "terms": {
    "multiplexing": "concurrent streams over single connection",
    "head-of-line blocking": "sequential processing delay in HTTP/1.1",
    "binary framing": "structured binary protocol format",
    "HPACK": "HTTP/2 header compression algorithm",
    "stream": "independent request-response sequence",
    "flow control": "backpressure management system using credit-based windows",
    "server push": "proactive resource delivery mechanism",
    "scope creep": "gradual expansion beyond defined goals",
    "static table": "predefined 61-entry HPACK table",
    "dynamic table": "connection-specific HPACK entries",
    "stream state machine": "lifecycle management for individual streams",
    "connection state": "overall connection configuration and active streams",
    "Huffman coding": "variable-length character encoding for compression",
    "integer encoding": "variable-length numeric representation",
    "FIFO eviction": "first-in-first-out removal strategy",
    "continuation bytes": "multi-byte integer encoding extension",
    "stream ID allocation": "monotonic numbering scheme for stream identification",
    "priority scheduling": "weight-based bandwidth distribution among streams",
    "RST_STREAM": "immediate stream termination frame",
    "half-closed": "stream state where one direction is closed",
    "backpressure handling": "data queueing when windows exhausted",
    "window management": "connection and stream window tracking",
    "credit-based system": "receiver-driven flow control using transmission permission tokens",
    "hierarchical windows": "dual-level flow control with both connection and stream windows",
    "deficit round-robin": "fair scheduling algorithm with priority weights and deficit tracking",
    "window exhaustion": "condition where flow control windows reach zero credit",
    "priority inversion": "lower priority streams blocking higher priority transmission",
    "window overflow": "arithmetic overflow when adding WINDOW_UPDATE increments",
    "protocol errors": "violations of HTTP/2 specification",
    "connection errors": "failures compromising entire connection integrity",
    "stream errors": "failures affecting individual streams",
    "GOAWAY frame": "mechanism for graceful connection termination",
    "fault isolation": "limiting error impact to minimum necessary scope",
    "error escalation": "incorrectly promoting stream errors to connection level",
    "blast radius": "scope of impact from error conditions",
    "graceful degradation": "maintaining service for unaffected components during errors",
    "protocol fuzzing": "systematic generation of malformed HTTP/2 traffic",
    "milestone checkpoints": "concrete verification steps after each implementation phase",
    "endianness": "byte order in multi-byte values",
    "reserved bits": "protocol bits that must remain zero",
    "flow control deadlock": "condition where all streams are blocked by window exhaustion",
    "table corruption": "HPACK dynamic table inconsistency",
    "state machine violation": "invalid stream state transition",
    "PUSH_PROMISE": "HTTP/2 frame type for server push promises",
    "connection coalescing": "reusing single HTTP/2 connection for multiple hostnames with compatible certificates",
    "alternative services": "mechanism to advertise different protocol endpoints for same service",
    "certificate coverage": "validation that TLS certificate authorizes multiple hostnames via SAN or wildcards",
    "Subject Alternative Names": "certificate extension listing additional hostnames covered by certificate",
    "zero-copy operations": "I/O techniques that avoid copying data between kernel and user space",
    "vectored I/O": "system call pattern that transmits multiple buffers in single operation",
    "object pooling": "reuse strategy for expensive objects to reduce garbage collection pressure",
    "buffer classification": "size-based categorization of buffers for efficient pool management",
    "push candidate": "resource identified as beneficial for proactive server push",
    "push policy": "rules governing which resources should be pushed and under what conditions",
    "promised stream": "server-initiated stream declared via PUSH_PROMISE frame",
    "synthetic request": "artificial request headers representing client request for pushed resource"
  }
}