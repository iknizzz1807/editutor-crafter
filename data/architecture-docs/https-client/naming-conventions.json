{
  "types": {
    "TCPTransport": "socket: Optional[socket.socket], remote_address: Optional[Tuple[str, int]]",
    "BinaryParser": "static utility methods for binary parsing",
    "HTTPSClient": "connection: Optional[TLSConnection], transport: Optional[TCPTransport]",
    "ContentType": "TLS content type constants",
    "TLSVersion": "TLS version constants",
    "HandshakeType": "TLS handshake message type constants",
    "CipherSuite": "TLS cipher suite constants",
    "ExtensionType": "TLS extension type constants",
    "NamedGroup": "ECDHE named group constants",
    "AlertLevel": "WARNING = 1, FATAL = 2",
    "AlertDescription": "close_notify = 0, bad_certificate = 42, etc.",
    "TLSConnection": "transport: TCPTransport, state_machine: TLSStateMachine, crypto_engine: Optional[CryptoEngine]",
    "HandshakeEngine": "negotiate 0-RTT capability and handle rejection",
    "CryptoEngine": "derive early traffic keys from PSK",
    "CertificateValidator": "trusted_roots: List[bytes]",
    "RecordLayer": "distinguish early data from handshake messages",
    "TLSRecord": "content_type: int, legacy_version: int, length: int, payload: bytes",
    "Extension": "extension_type: int, extension_data: bytes",
    "ClientHello": "legacy_version: int, random: bytes, legacy_session_id: bytes, cipher_suites: List[int], legacy_compression_methods: List[int], extensions: List[Extension]",
    "ServerHello": "legacy_version: int, random: bytes, legacy_session_id_echo: bytes, cipher_suite: int, legacy_compression_method: int, extensions: List[Extension]",
    "ConnectionState": "connection state enumeration",
    "TrafficKeys": "key: bytes, iv: bytes",
    "KeyScheduleState": "early_secret: bytes, handshake_secret: bytes, master_secret: bytes, client_handshake_traffic_secret: bytes, server_handshake_traffic_secret: bytes, client_application_traffic_secret: bytes, server_application_traffic_secret: bytes",
    "CryptographicState": "connection_state, tls_version, cipher_suite, client_random, server_random, handshake_context, key_schedule, sequence_numbers, traffic_keys",
    "X25519KeyExchange": "private_key: Optional[x25519.X25519PrivateKey], public_key: Optional[x25519.X25519PublicKey]",
    "HKDF": "HMAC-based Key Derivation Function",
    "SequenceNumbers": "send_seq: int, recv_seq: int, max_seq: int",
    "AEADCipher": "cipher: AESGCM",
    "HTTPProcessor": "static methods for HTTP processing",
    "EncryptedDataHandler": "crypto_state: CryptographicState, sequence_numbers: SequenceNumbers, send_cipher: AEADCipher, recv_cipher: AEADCipher, response_buffer: bytes",
    "HandshakeContext": "messages: List[bytes], hash_func: hashlib.sha256",
    "TLSStateMachine": "current_state: ConnectionState, state_lock: threading.Lock, state_callbacks: Dict[ConnectionState, List[Callable]]",
    "AlertProcessor": "connection_state, alert_handlers: Dict, logger",
    "ConnectionError": "error_type: ConnectionErrorType, original_exception: Exception, retry_recommended: bool, security_implications: str",
    "CryptoError": "message: str, security_impact: str, should_terminate: bool",
    "TLSLogger": "component: str, connection_id: str, logger: logging.Logger",
    "TLSStateInspector": "connection: TLSConnection, inspection_history: List",
    "TLSProtocolAnalyzer": "logger: TLSLogger, message_history: List, known_issues: List",
    "SessionTicket": "ticket_data: bytes, resumption_secret: bytes, cipher_suite: int, server_name: str, issued_time: float, lifetime_seconds: int, usage_count: int",
    "SessionCache": "max_tickets: int, cleanup_interval: int, tickets: Dict[str, SessionTicket], lock: threading.RWLock, last_cleanup: float",
    "PooledConnection": "connection: TLSConnection, created_time: float, last_used_time: float, usage_count: int, is_healthy: bool",
    "ConnectionPool": "max_connections_per_host: int, max_idle_time: int, health_check_interval: int, pools: Dict[str, queue.Queue], pool_locks: Dict[str, threading.Lock], connection_counts: Dict[str, int], global_lock: threading.Lock, active_connections: Set[TLSConnection], health_monitor_thread: threading.Thread, shutdown_event: threading.Event",
    "AsyncTLSConnection": "hostname: str, port: int, reader: Optional[asyncio.StreamReader], writer: Optional[asyncio.StreamWriter], tls_connection: Optional[TLSConnection], connection_lock: asyncio.Lock",
    "AsyncHTTPSClient": "connection_pool: ConnectionPool, session_stats: Dict[str, int]",
    "CPUFeatureDetector": "features: Dict[str, bool]",
    "EarlyDataHandler": "encrypt/decrypt 0-RTT application data",
    "AEADCipherFactory": "support multiple cipher algorithms",
    "HashFunctionProvider": "multiple hash algorithms for different suites",
    "CipherSuiteNegotiator": "preference ordering and compatibility checking",
    "HardwareAcceleration": "platform-specific optimizations",
    "ConnectionHealthMonitor": "detect and remove stale connections",
    "PoolingStrategy": "determine connection allocation and eviction",
    "ConnectionFactory": "create new connections when needed",
    "AccelDetector": "runtime CPU feature detection",
    "CryptoProvider": "dynamic dispatch to best implementation",
    "PerformanceProfiler": "benchmark different implementations",
    "SecurityValidator": "ensure acceleration maintains security properties",
    "TLS": "Transport Layer Security protocol",
    "HTTPS": "HTTP over TLS",
    "ECDHE": "Elliptic Curve Diffie-Hellman Ephemeral key exchange",
    "X25519": "elliptic curve for ECDH",
    "X.509": "certificate standard format",
    "AEAD": "Authenticated Encryption with Associated Data",
    "AES-GCM": "Advanced Encryption Standard in Galois/Counter Mode"
  },
  "methods": {
    "connect(hostname: str, port: int, timeout: float) -> None": "establish TCP connection with error handling",
    "send_bytes(data: bytes) -> int": "send raw bytes with error handling",
    "receive_bytes(max_bytes: int) -> bytes": "receive raw bytes from TCP connection",
    "receive_exact(num_bytes: int) -> bytes": "receive exactly specified bytes with timeout",
    "parse_uint8(data: bytes, offset: int) -> Tuple[int, int]": "parse single byte as unsigned integer",
    "parse_uint16(data: bytes, offset: int) -> Tuple[int, int]": "parse 2 bytes as unsigned 16-bit integer",
    "parse_uint24(data: bytes, offset: int) -> Tuple[int, int]": "parse 3 bytes as unsigned 24-bit integer",
    "parse_variable_bytes(data: bytes, offset: int, length_bytes: int) -> Tuple[bytes, int]": "parse variable-length byte array with length prefix",
    "hex_dump(data: bytes, width: int, show_ascii: bool) -> str": "create hex dump representation of binary data",
    "request(method: str, url: str, headers: Dict, body: bytes) -> Tuple[int, Dict, bytes]": "make HTTPS request to server",
    "to_bytes() -> bytes": "serialize data structure to binary format",
    "from_bytes(data: bytes, offset: int) -> Tuple[object, int]": "parse data structure from binary format",
    "add_server_name_extension(hostname: str) -> None": "add SNI extension to ClientHello",
    "add_supported_versions_extension(versions: List[int]) -> None": "add supported versions extension",
    "add_key_share_extension(key_shares: List[Tuple[int, bytes]]) -> None": "add key share extension",
    "derive_handshake_secrets(ecdhe_shared_secret: bytes) -> None": "derive handshake traffic secrets from ECDHE shared secret",
    "derive_application_secrets(handshake_context: bytes) -> None": "derive application traffic secrets",
    "derive_nonce(sequence_number: int) -> bytes": "derive AEAD nonce from IV and sequence number",
    "update_handshake_context(message: bytes) -> None": "add handshake message to transcript",
    "get_current_handshake_context_hash() -> bytes": "get SHA-256 hash of handshake transcript",
    "add_tcp_data(data: bytes) -> None": "add newly received TCP data to processing buffer",
    "get_next_record() -> Optional[TLSRecord]": "get next complete record if available",
    "generate_key_pair() -> None": "generate ephemeral X25519 key pair",
    "get_public_key_bytes() -> bytes": "get public key as 32-byte value for transmission",
    "compute_shared_secret(peer_public_key_bytes: bytes) -> bytes": "compute ECDHE shared secret with validation",
    "extract(salt: bytes, ikm: bytes) -> bytes": "HKDF-Extract pseudorandom key from input key material",
    "expand(prk: bytes, info: bytes, length: int) -> bytes": "HKDF-Expand pseudorandom key to desired length",
    "derive_application_secrets() -> None": "derive application traffic secrets from handshake secret",
    "derive_traffic_keys(traffic_secret: bytes) -> TrafficKeys": "derive encryption key and IV from traffic secret",
    "compute_finished_verify_data(traffic_secret: bytes, handshake_context_hash: bytes) -> bytes": "compute verify data for Finished message",
    "validate_certificate_chain(cert_chain: List[bytes], hostname: str) -> bool": "comprehensive certificate validation",
    "verify_certificate_signature(cert: x509.Certificate, issuer_cert: x509.Certificate) -> bool": "verify certificate signature using issuer's public key",
    "validate_hostname(cert: x509.Certificate, hostname: str) -> bool": "validate hostname against certificate SAN extension",
    "get_send_nonce(iv: bytes) -> bytes": "generate nonce for outgoing records",
    "get_recv_nonce(iv: bytes) -> bytes": "generate nonce for incoming records",
    "encrypt(plaintext: bytes, nonce: bytes, additional_data: bytes) -> bytes": "AES-GCM encryption",
    "decrypt(ciphertext: bytes, nonce: bytes, additional_data: bytes) -> bytes": "AES-GCM decryption",
    "build_request(method: str, path: str, hostname: str, headers: Dict, body: bytes) -> bytes": "construct HTTP request",
    "parse_response(data: bytes) -> Tuple[int, Dict, bytes]": "parse HTTP response",
    "encrypt_application_data(plaintext: bytes) -> bytes": "encrypt into TLS record",
    "decrypt_application_data(encrypted_record: bytes) -> bytes": "decrypt TLS record",
    "send_http_request(method: str, path: str, hostname: str, headers: Dict, body: bytes) -> None": "send HTTP over TLS",
    "receive_http_response(timeout: float) -> Tuple[int, Dict, bytes]": "receive HTTP over TLS",
    "send_close_notify() -> None": "send TLS close alert",
    "handle_close_notify(alert_record: bytes) -> None": "process close alert",
    "perform_handshake(hostname: str, port: int) -> bool": "execute complete TLS handshake sequence",
    "send_application_data(data: bytes) -> int": "send application data over established TLS connection",
    "receive_application_data(max_bytes: int) -> bytes": "receive and decrypt application data",
    "transition_to(new_state: ConnectionState, context: Dict) -> None": "thread-safe state transition with callback notification",
    "add_message(message: bytes) -> None": "add handshake message to transcript and update hash",
    "get_hash() -> bytes": "get current handshake context hash",
    "register_callback(state: ConnectionState, callback: Callable) -> None": "register callback for state transitions",
    "_process_handshake_message(record: TLSRecord) -> bool": "process incoming handshake message based on current state",
    "_validate_state_transition(from_state: ConnectionState, to_state: ConnectionState, trigger_message: bytes) -> bool": "validate that state transition is valid given current context",
    "process_alert(alert_record: bytes) -> bool": "process TLS alert and return continuation decision",
    "send_alert(level: AlertLevel, description: AlertDescription) -> None": "send TLS alert with proper handling",
    "clear_bytes(data: bytearray) -> None": "securely clear sensitive memory",
    "log_binary_data(description: str, data: bytes, max_bytes: int)": "log binary data with hex dump, limiting size for security",
    "log_state_transition(from_state: str, to_state: str, trigger: str)": "log state machine transitions for debugging",
    "log_crypto_operation(operation: str, algorithm: str, success: bool, details: str)": "log cryptographic operations without exposing sensitive material",
    "dump_connection_state() -> Dict[str, Any]": "create comprehensive state snapshot without sensitive data",
    "validate_state_consistency() -> List[str]": "cross-validate component states for consistency issues",
    "analyze_handshake_sequence(messages: List[bytes]) -> List[str]": "analyze handshake message sequence for protocol compliance",
    "analyze_record_structure(record_data: bytes) -> Dict[str, Any]": "analyze TLS record structure for format compliance",
    "is_expired() -> bool": "check if session ticket has exceeded lifetime",
    "derive_psk(ticket_nonce: bytes) -> bytes": "derive PSK from resumption secret and nonce",
    "store_ticket(server_name: str, ticket: SessionTicket) -> None": "store session ticket with automatic cleanup",
    "get_ticket(server_name: str) -> Optional[SessionTicket]": "retrieve valid session ticket for server",
    "get_connection(hostname: str, port: int, timeout: float) -> TLSConnection": "get connection from pool or create new",
    "return_connection(hostname: str, connection: TLSConnection) -> None": "return connection to pool or close if unhealthy",
    "close_all() -> None": "close all connections and shutdown pool",
    "connect(timeout: float) -> None": "establish async TLS connection with timeout",
    "send_request(data: bytes) -> None": "send data over async TLS connection",
    "receive_response(max_bytes: int) -> bytes": "receive data from async TLS connection",
    "request(method: str, url: str, headers: Dict, body: bytes, timeout: float) -> Tuple[int, Dict, bytes]": "make async HTTPS request with connection management",
    "has_aes_acceleration() -> bool": "check if AES hardware acceleration available",
    "has_sha_acceleration() -> bool": "check if SHA hardware acceleration available",
    "analyze_handshake_failure(error_context: Dict) -> str": "analyze handshake failures using TLS terminology",
    "validate_terminology_consistency() -> None": "ensure consistent use of TLS terminology"
  },
  "constants": {
    "CHANGE_CIPHER_SPEC": "20",
    "ALERT": "21",
    "HANDSHAKE": "22",
    "APPLICATION_DATA": "23",
    "TLS_1_3": "0x0304",
    "CLIENT_HELLO": "1",
    "SERVER_HELLO": "2",
    "TLS_AES_128_GCM_SHA256": "0x1301",
    "SERVER_NAME": "0",
    "SUPPORTED_VERSIONS": "43",
    "KEY_SHARE": "51",
    "X25519": "0x001D",
    "MAX_RECORD_PAYLOAD_LENGTH": "16384",
    "RECORD_HEADER_LENGTH": "5",
    "FINISHED": "20 - Handshake message type for Finished message",
    "close_notify": "0",
    "START": "1",
    "WAIT_SH": "2",
    "WAIT_EE": "3",
    "WAIT_CERT_CR": "4",
    "WAIT_CV": "5",
    "WAIT_FINISHED": "6",
    "CONNECTED": "7",
    "CLOSED": "8",
    "bad_certificate": "42",
    "certificate_expired": "45",
    "unknown_ca": "48",
    "expired": "45",
    "TLS_AES_256_GCM_SHA384": "0x1302",
    "TLS_CHACHA20_POLY1305_SHA256": "0x1303",
    "TLS_AES_128_CCM_SHA256": "0x1304"
  },
  "terms": {
    "TLS": "Transport Layer Security protocol",
    "HTTPS": "HTTP over TLS",
    "ECDHE": "Elliptic Curve Diffie-Hellman Ephemeral key exchange providing forward secrecy",
    "AEAD": "Authenticated Encryption with Associated Data",
    "HKDF": "HMAC-based Key Derivation Function for cryptographically strong key derivation",
    "SNI": "Server Name Indication extension",
    "X.509": "certificate standard format",
    "network byte order": "big-endian byte ordering used in network protocols",
    "record layer": "TLS framing and message classification layer",
    "handshake messages": "TLS negotiation and key exchange messages",
    "cryptographic state": "TLS connection security context and key material",
    "binary parsing": "extracting structured data from byte streams",
    "fragmentation": "splitting large messages across multiple records",
    "key derivation": "generating encryption keys from shared secrets",
    "sequence numbers": "counters for nonce construction and replay protection",
    "X25519": "Elliptic curve designed for ECDH key exchange",
    "forward secrecy": "protection ensuring past sessions remain secure even if keys compromised",
    "handshake context": "SHA-256 hash of all handshake messages providing cryptographic binding",
    "certificate chain": "Sequence of X.509 certificates from server certificate to trusted root",
    "Subject Alternative Name": "X.509 extension listing hostnames and IP addresses covered by certificate",
    "verify data": "HMAC-computed authentication value proving possession of correct traffic keys",
    "AES-GCM": "Advanced Encryption Standard in Galois/Counter Mode",
    "nonce": "number used once for encryption",
    "authentication tag": "AEAD integrity verification data",
    "close_notify": "TLS alert for graceful connection closure",
    "truncation attack": "attack cutting off data transmission prematurely",
    "replay protection": "preventing reuse of captured messages",
    "TLS handshake sequence": "step-by-step message flow from ClientHello to application data",
    "connection state machine": "TLS connection states and valid transitions",
    "component coordination": "synchronized interaction between TLS components",
    "state transition": "movement between connection states triggered by message processing",
    "ECDHE shared secret": "computed from client and server public keys",
    "key derivation cascade": "HKDF-based generation of traffic keys from shared secret",
    "atomic state transitions": "ensuring all components update consistently",
    "TLS alerts": "protocol error reporting mechanism",
    "fatal alerts": "errors requiring immediate connection termination",
    "warning alerts": "non-fatal conditions allowing continuation",
    "certificate validation": "X.509 certificate verification process",
    "cryptographic errors": "failures in cryptographic operations",
    "network-level errors": "TCP transport layer failures",
    "test vectors": "predetermined inputs and expected outputs for cryptographic validation",
    "integration testing": "testing component coordination and real-world scenarios",
    "wire format": "byte-level protocol message format",
    "binary protocol parsing": "extracting structured data from byte streams",
    "state machine transitions": "movement between connection states triggered by message processing",
    "hex dump": "hexadecimal representation of binary data for debugging",
    "Wireshark": "network protocol analyzer for capturing and examining TLS traffic",
    "session resumption": "mechanism to reuse cryptographic state from previous TLS sessions using PSK",
    "0-RTT data": "zero round-trip time early data transmission in first message to server",
    "connection pooling": "maintaining pool of reusable TLS connections to amortize handshake costs",
    "async I/O": "non-blocking input/output operations using event-driven programming",
    "hardware acceleration": "CPU-specific instructions for optimized cryptographic operations",
    "PSK": "Pre-Shared Key derived from previous session for resumption",
    "session tickets": "encrypted tokens containing session state for resumption",
    "ChaCha20-Poly1305": "stream cipher with polynomial authenticator providing AEAD functionality",
    "AES-NI": "Advanced Encryption Standard New Instructions for hardware acceleration",
    "event loop": "programming construct for handling asynchronous operations and callbacks",
    "backpressure": "flow control mechanism to prevent buffer overflow under load",
    "LRU eviction": "Least Recently Used policy for removing items from cache when full",
    "coroutines": "cooperative multitasking functions that can pause and resume execution",
    "side-channel attacks": "cryptographic attacks exploiting implementation characteristics like timing",
    "constant-time operation": "execution that takes same time regardless of input values",
    "record framing": "standardized format for packaging TLS communication"
  }
}