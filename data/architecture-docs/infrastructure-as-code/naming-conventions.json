{
  "types": {
    "Resource": "fields: id string, type string, name string, attributes map[string]any",
    "StateRecord": "fields: resource_id string, resource_type string, resource_name string, attributes map[string]any, dependencies list[string]",
    "PlanAction": "fields: action_type enum(CREATE, UPDATE, DELETE, NOOP), resource Resource, prior_state StateRecord (optional), new_state StateRecord (optional)",
    "DependencyGraphNode": "fields: resource_id string, depends_on list[string], required_by list[string]",
    "BaseProvider": "interface with create, read, update, delete, validate_credentials methods",
    "JsonSerializable": "mixin class with to_dict, from_dict, to_json, from_json methods",
    "LockHandle": "fields: lock_path Path, process_id int, lock_id str, heartbeat_thread Optional[Thread], stop_event Event",
    "ApplyResult": "fields: resource_address str, success bool, new_state Optional[Resource], error Optional[str], retries int",
    "ProviderConfig": "fields: provider_type str, config dict",
    "IaCError": "base class for all IaC errors",
    "ConfigurationError": "subclass of IaCError for config parsing errors",
    "StateError": "subclass for state file errors",
    "ProviderError": "base class for provider errors",
    "TransientProviderError": "subclass for retryable provider errors",
    "PermanentProviderError": "subclass of ProviderError for non-retryable provider errors",
    "PartialApplyError": "exception for partial apply failures with succeeded resources dict",
    "CircuitOpenError": "exception for circuit breaker open state",
    "StateReport": "fields: total_resources int, resources_by_type Dict[str, int], orphaned_resources List[str], duplicate_addresses List[str], validation_errors List[str]",
    "GraphExporter": "methods: to_dot, to_mermaid, find_cycles",
    "StateInspector": "methods: load_state, analyze, compare",
    "ActionType": "enum: CREATE, UPDATE, DELETE, NOOP",
    "CircuitBreaker": "class with __init__(failure_threshold, reset_timeout) and call(func, *args, **kwargs) returns Any methods"
  },
  "methods": {
    "plan_command(config_path Path, state_path Path, var_file Optional[Path]) returns None": "CLI command to generate and show an execution plan",
    "apply_command(config_path Path, state_path Path, var_file Optional[Path], auto_approve bool) returns None": "CLI command to apply changes to reach desired state",
    "write_atomic_json(filepath Path, data Any) returns None": "Write JSON data to a file atomically to prevent corruption",
    "read_json_with_backup(filepath Path) returns Any": "Read JSON file, with automatic fallback to a backup if present",
    "parse_file(file_path: Path) returns dict": "Parse a single config file into a raw AST dict",
    "resolve_variables(ast: dict, variable_files: List[Path], cli_vars: dict) returns dict": "Resolve variable interpolations within an AST",
    "load_module(module_call: dict, parent_dir: Path) returns List[Resource]": "Load and fully resolve a module, returning its resources",
    "process_configuration(root_file: Path, variable_files: List[Path], cli_vars: dict) returns List[Resource]": "Main entry point: parse a root configuration and all its modules",
    "read_state(state_path Path) returns Dict[str, StateRecord]": "Loads the state file from the given path into a dictionary keyed by resource address",
    "write_state(state_path Path, state_data Dict[str, StateRecord]) returns None": "Persists the in-memory state dictionary to disk atomically",
    "acquire_lock(lock_path Path, timeout_seconds int = 30, heartbeat_interval int = 10) returns LockHandle": "Attempts to acquire an exclusive lock for the state with stale detection and heartbeat",
    "release_lock(lock_handle LockHandle) returns None": "Releases the lock represented by the given handle",
    "compute_diff(current_state Dict[str, StateRecord], desired_resources List[Resource]) returns Dict[str, PlanAction]": "Compares current deployed state with desired state to determine needed changes",
    "get_resource_address(resource Resource) returns str": "Generates a unique address string for a resource (type.name)",
    "build_graph(resources: List[Resource], state_records: Dict[str, StateRecord]) returns Dict[str, DependencyGraphNode]": "Constructs a dependency graph from the provided resources and existing state",
    "validate_acyclic(graph: Dict[str, DependencyGraphNode]) returns bool": "Validates that the dependency graph contains no cycles",
    "topological_sort(graph: Dict[str, DependencyGraphNode]) returns List[str]": "Performs a topological sort on the validated DAG",
    "generate_plan(sorted_resources: List[str], desired_resources: Dict[str, Resource], current_state: Dict[str, StateRecord]) returns Dict[str, PlanAction]": "Generates a PlanAction for each resource based on desired vs current state",
    "apply_plan(plan, providers, max_concurrency) returns": "Applies execution plan using providers, returns ApplyResult dict",
    "refresh_state(resource, provider) returns": "Calls provider.read to get current cloud state",
    "_execute_action(action, provider) returns": "Internal method to execute single PlanAction with retry logic",
    "validate_credentials(config) returns": "Validates provider configuration and credentials",
    "create(resource) returns": "Creates cloud resource, returns Resource with actual attributes",
    "read(resource_id, resource_type) returns": "Reads current resource state from cloud",
    "update(resource_id, resource) returns": "Updates existing cloud resource",
    "delete(resource_id, resource_type) returns": "Deletes cloud resource, returns bool success",
    "retry_with_backoff(max_attempts, base_delay, max_delay, jitter, exceptions) returns decorator": "decorator for exponential backoff retry logic",
    "CircuitBreaker.__init__(failure_threshold, reset_timeout)": "initialize circuit breaker",
    "CircuitBreaker.call(func, *args, **kwargs) returns Any": "execute function with circuit breaker protection",
    "_execute_action(action, provider) returns ApplyResult": "internal method to execute single PlanAction with error handling",
    "inspect_state_command(state_path Path, output_format str) returns": "CLI command for state inspection",
    "setup_logging(level str, json_format bool) returns": "Configure logging for the IaC engine",
    "log_operation(operation str, **extra Any) returns": "Start a new operation with a correlation ID and log its beginning"
  },
  "constants": {
    "ActionType.CREATE": "The resource must be created",
    "ActionType.UPDATE": "The resource must be updated in-place",
    "ActionType.DELETE": "The resource must be destroyed",
    "ActionType.NOOP": "No operation is needed"
  },
  "terms": {
    "IaC": "Infrastructure as Code",
    "HCL": "HashiCorp Configuration Language",
    "DSL": "Domain-Specific Language",
    "DAG": "Directed Acyclic Graph",
    "CRUD": "Create, Read, Update, Delete operations",
    "state file": "File persistently storing the known state of deployed infrastructure",
    "execution plan": "Ordered list of PlanAction objects specifying changes needed",
    "diff": "Comparison between desired state (Resource) and known state (StateRecord) to determine needed changes",
    "Directed Acyclic Graph (DAG)": "A directed graph with no cycles",
    "topological sort": "A linear ordering of nodes in a DAG such that for every directed edge u -> v, u comes before v",
    "dependency graph": "A graph where nodes are resources and edges represent dependencies",
    "cycle detection": "Algorithm to find circular dependencies in a graph",
    "Provider": "Plugin that translates CRUD operations to specific cloud APIs",
    "Executor": "Component that orchestrates plan execution",
    "Idempotent": "Operation that can be applied multiple times without changing result",
    "Rate Limiting": "Cloud API restrictions on request frequency",
    "Eventual Consistency": "Cloud property where changes take time to propagate",
    "Zombie Resources": "Resources created in cloud but not recorded in state file",
    "fail-fast": "stop immediately on error rather than continuing",
    "exponential backoff": "retry strategy with increasing delays between attempts",
    "jitter": "random variation added to retry delays to avoid thundering herd",
    "circuit breaker": "pattern to fail fast after repeated failures",
    "eventual consistency": "cloud property where changes take time to propagate",
    "state drift": "difference between recorded state and actual cloud state",
    "zombie resource": "resource that exists in cloud but not recorded in state",
    "partial apply": "apply operation where some resources succeeded and others failed",
    "correlation ID": "Unique identifier for tracing requests across components",
    "state inspection": "Analysis and validation of state file contents",
    "graph visualization": "Creating visual representations of dependency graphs",
    "structured logging": "Logging in machine-parsable format with consistent fields",
    "Atomic Operation": "An operation that either completes fully or not at all",
    "Correlation ID": "Unique identifier for tracing requests across components",
    "Declarative Configuration": "Specifying desired end state, not steps",
    "Dependency Graph": "Graph representation of resource dependencies",
    "Diff": "Comparison between desired and current state",
    "Execution Plan": "Ordered list of PlanAction objects",
    "Exponential Backoff": "Retry strategy with increasing delays",
    "Fail-fast": "stop immediately on error",
    "Graph Visualization": "Creating visual representations of dependency graphs",
    "Jitter": "random variation added to retry delays",
    "Partial Apply": "apply operation where some resources succeeded and others failed",
    "Planner": "Component that builds dependency graph and plan",
    "State Drift": "difference between recorded state and actual cloud state",
    "State File": "File persistently storing known infrastructure state",
    "State Inspection": "Analysis and validation of state file contents",
    "Structured Logging": "Logging in machine-parsable format with consistent fields",
    "Topological Sort": "Linear ordering of nodes in a DAG respecting edges"
  }
}