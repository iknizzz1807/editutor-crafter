{
  "title": "Infrastructure as Code Engine: Design Document",
  "overview": "This system parses declarative infrastructure configurations, computes the difference from the current state, builds a safe execution plan, and applies changes to cloud resources. The key architectural challenge is managing state, dependencies, and idempotent operations across distributed, eventually consistent cloud APIs.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explores the challenge of managing infrastructure programmatically and why building an IaC engine is complex.",
      "subsections": [
        {
          "id": "analogy-mental-model",
          "title": "Mental Model: The Master Blueprint and Site Manager",
          "summary": "Uses the analogy of a construction blueprint, a site manager, and a log of what's built to explain IaC core concepts."
        },
        {
          "id": "problem-deep-dive",
          "title": "The Core Problem: Declarative to Imperative with State",
          "summary": "Details the technical challenges of reconciling desired state with actual state, handling dependencies, and ensuring safe, concurrent operations."
        },
        {
          "id": "existing-approaches",
          "title": "Existing Approaches and Trade-offs",
          "summary": "Compares existing tools (Terraform, Pulumi, CloudFormation) to highlight different design philosophies and their implications."
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the scope of the project: what the IaC engine will and will not do.",
      "subsections": [
        {
          "id": "goals",
          "title": "Goals",
          "summary": "List of required features: declarative config, state management, dependency planning, provider plugins, and safe apply."
        },
        {
          "id": "non-goals",
          "title": "Non-Goals",
          "summary": "Explicitly out-of-scope items like a full HCL parser, built-in providers for all services, or a web UI."
        }
      ]
    },
    {
      "id": "high-level-arch",
      "title": "High-Level Architecture",
      "summary": "Bird's-eye view of the system components, their responsibilities, and how data flows between them.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview and Responsibilities",
          "summary": "Describes the five core components: Parser, State Manager, Planner, Executor, and Provider SDK."
        },
        {
          "id": "file-structure",
          "title": "Recommended File and Module Structure",
          "summary": "Provides a suggested Python project layout to organize the codebase logically."
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the core data structures that flow through the system: resources, state, plans, and dependencies.",
      "subsections": [
        {
          "id": "key-types",
          "title": "Key Types and Structures",
          "summary": "Tables describing Resource, StateRecord, PlanAction, and DependencyGraphNode types."
        },
        {
          "id": "relationships",
          "title": "Type Relationships and Lifecycle",
          "summary": "Explains how data structures transform from configuration to state via planning and execution."
        }
      ]
    },
    {
      "id": "component-parser",
      "title": "Component Design: Configuration Parser",
      "summary": "Design of the component that reads HCL/YAML, resolves variables and modules, and produces a normalized resource graph. (Milestone 1)",
      "subsections": [
        {
          "id": "parser-mental-model",
          "title": "Mental Model: The Interpreter and Expander",
          "summary": "Analogy of a translator expanding a template with variables and combining multiple book chapters."
        },
        {
          "id": "parser-interface",
          "title": "Interface and Public Methods",
          "summary": "Table of methods like `parse_file`, `resolve_variables`, `load_module`."
        },
        {
          "id": "parser-behavior",
          "title": "Internal Behavior and Algorithm",
          "summary": "Step-by-step algorithm for parsing, interpolation, and module resolution."
        },
        {
          "id": "parser-adr-ast",
          "title": "ADR: Abstract Syntax Tree vs. Direct Dict",
          "summary": "Decision to use a lightweight dict-based AST for simplicity over a full-fledged AST."
        },
        {
          "id": "parser-pitfalls",
          "title": "Common Pitfalls: Circular References and Interpolation",
          "summary": "Covers infinite loops in variable resolution and the count/for_each interpolation problem."
        },
        {
          "id": "parser-implementation",
          "title": "Implementation Guidance",
          "summary": "Technology table, starter code for a safe file loader, and skeleton code for the core parsing logic with TODOs."
        }
      ]
    },
    {
      "id": "component-state",
      "title": "Component Design: State Manager",
      "summary": "Design of the component that persists the last known infrastructure state, handles locking, and computes diffs. (Milestone 2)",
      "subsections": [
        {
          "id": "state-mental-model",
          "title": "Mental Model: The Ledger and Lock",
          "summary": "Analogy of a bank ledger (state file) and a safety deposit box lock (state lock) to manage shared access."
        },
        {
          "id": "state-interface",
          "title": "Interface and Public Methods",
          "summary": "Table of methods like `read_state`, `write_state`, `acquire_lock`, `compute_diff`."
        },
        {
          "id": "state-behavior",
          "title": "Internal Behavior and Algorithm",
          "summary": "Step-by-step algorithm for atomic file writes, lock acquisition with heartbeats, and diff calculation."
        },
        {
          "id": "state-adr-locking",
          "title": "ADR: Pessimistic File Locking vs. Optimistic Concurrency",
          "summary": "Decision to use a pessimistic file-based lock for simplicity in an educational context."
        },
        {
          "id": "state-pitfalls",
          "title": "Common Pitfalls: Corruption, Stale Locks, and Remote Races",
          "summary": "Covers partial writes, orphaned lock files, and S3 eventual consistency issues."
        },
        {
          "id": "state-implementation",
          "title": "Implementation Guidance",
          "summary": "Technology table, starter code for atomic file operations and a simple lockfile, skeleton code for state diff logic."
        }
      ]
    },
    {
      "id": "component-planner",
      "title": "Component Design: Planner (Dependency Graph & Planning)",
      "summary": "Design of the component that builds a dependency graph, performs a topological sort, and generates a safe execution plan. (Milestone 3)",
      "subsections": [
        {
          "id": "planner-mental-model",
          "title": "Mental Model: The Project Manager and Gantt Chart",
          "summary": "Analogy of a project manager figuring out task order (dependencies) and creating a work plan (execution plan)."
        },
        {
          "id": "planner-interface",
          "title": "Interface and Public Methods",
          "summary": "Table of methods like `build_graph`, `generate_plan`, `validate_acyclic`."
        },
        {
          "id": "planner-behavior",
          "title": "Internal Behavior and Algorithm",
          "summary": "Step-by-step algorithm for dependency extraction, DAG construction, cycle detection, and topological sort."
        },
        {
          "id": "planner-adr-graph",
          "title": "ADR: Implicit vs. Explicit Dependency Detection",
          "summary": "Decision to implement both implicit (reference-based) and explicit (`depends_on`) dependency detection."
        },
        {
          "id": "planner-pitfalls",
          "title": "Common Pitfalls: Cycles, Missed Dependencies, and Destroy Order",
          "summary": "Covers circular dependencies, complex interpolation patterns, and the need for reverse order on destroy."
        },
        {
          "id": "planner-implementation",
          "title": "Implementation Guidance",
          "summary": "Technology table, starter code for a generic graph class, skeleton code for dependency resolution and plan generation."
        }
      ]
    },
    {
      "id": "component-provider",
      "title": "Component Design: Provider Abstraction & Executor",
      "summary": "Design of the plugin interface for cloud APIs and the component that executes the plan by calling CRUD operations. (Milestone 4)",
      "subsections": [
        {
          "id": "provider-mental-model",
          "title": "Mental Model: The Universal Remote Control",
          "summary": "Analogy of a universal remote (Provider interface) with specific device codes (provider implementations) for different clouds."
        },
        {
          "id": "provider-interface",
          "title": "Interface and Public Methods",
          "summary": "Table of the `BaseProvider` CRUD interface and the `Executor`'s `apply_plan` method."
        },
        {
          "id": "provider-behavior",
          "title": "Internal Behavior and Algorithm",
          "summary": "Step-by-step algorithm for executing a plan with concurrency control, retries, and state refresh."
        },
        {
          "id": "provider-adr-retry",
          "title": "ADR: Retry Logic Strategy",
          "summary": "Decision to implement exponential backoff with jitter for API call retries."
        },
        {
          "id": "provider-pitfalls",
          "title": "Common Pitfalls: Rate Limits, Eventually Consistency, and Zombie Resources",
          "summary": "Covers API throttling, read-after-write failures, and handling resources stuck in transient states."
        },
        {
          "id": "provider-implementation",
          "title": "Implementation Guidance",
          "summary": "Technology table, starter code for a retry decorator and a mock provider, skeleton code for the executor and a sample AWS provider."
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Describes the sequence of operations for key workflows like `plan` and `apply`, including component communication.",
      "subsections": [
        {
          "id": "plan-flow",
          "title": "Sequence: The Planning Workflow",
          "summary": "Step-by-step walkthrough of the `plan` command, from parsing config to displaying the plan."
        },
        {
          "id": "apply-flow",
          "title": "Sequence: The Apply Workflow",
          "summary": "Step-by-step walkthrough of the `apply` command, including locking, execution, and state updates."
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Systematic approach to detecting, classifying, and recovering from failures at different stages.",
      "subsections": [
        {
          "id": "error-classification",
          "title": "Error Classification and Recovery Strategy",
          "summary": "Table categorizing errors (Config, State, Provider, Transient) and recommended recovery actions."
        },
        {
          "id": "edge-cases",
          "title": "Key Edge Cases and Mitigations",
          "summary": "Covers partial apply failures, external resource modification, and schema drift."
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "How to verify the system works correctly, including unit, integration, and end-to-end tests, plus milestone checkpoints.",
      "subsections": [
        {
          "id": "test-approaches",
          "title": "Testing Approaches and Tools",
          "summary": "Recommended testing pyramid and tools for mocking cloud APIs."
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints and Verification",
          "summary": "For each milestone, describes the expected behavior and commands to verify progress."
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Helps learners diagnose and fix common issues encountered during implementation.",
      "subsections": [
        {
          "id": "symptom-cause-fix",
          "title": "Common Bugs: Symptom \u2192 Cause \u2192 Fix",
          "summary": "Table of common issues like 'Plan shows no changes', 'Lock never released', or 'Cycle detected'."
        },
        {
          "id": "debugging-techniques",
          "title": "Debugging Techniques and Tools",
          "summary": "Recommendations for strategic logging, state file inspection, and graph visualization."
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements to the system that the current architecture can accommodate.",
      "subsections": [
        {
          "id": "enhancements",
          "title": "Possible Enhancements",
          "summary": "Ideas like a validation webhook, policy-as-code integration, or a drift detection scheduler."
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key terms, acronyms, and domain-specific vocabulary used in the document.",
      "subsections": [
        {
          "id": "terms",
          "title": "Term Definitions",
          "summary": "Table of terms like Idempotency, Declarative, Provider, State Drift, etc."
        }
      ]
    }
  ],
  "diagrams": [
    {
      "id": "sys-component",
      "title": "System Component Diagram",
      "description": "Shows the five main components (Parser, State Manager, Planner, Executor, Provider SDK) and their interactions. Include arrows for data flow: Config -> Parser -> Planner; State Manager <-> Planner/Executor; Planner -> Executor -> Provider.",
      "type": "component",
      "relevant_sections": [
        "high-level-arch"
      ]
    },
    {
      "id": "data-model-class",
      "title": "Data Model Relationships",
      "description": "Shows key classes: Resource, StateRecord, PlanAction, DependencyGraphNode. Illustrate relationships: Resource has attributes; StateRecord is a snapshot of a Resource; PlanAction proposes a change to a Resource; DependencyGraphNode links Resources.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "plan-sequence",
      "title": "Sequence Diagram: Plan Command",
      "description": "Shows the sequence of calls between User, CLI, Parser, State Manager, and Planner for generating an execution plan. Include steps: parse config, read state, build graph, compute diff, output plan.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "component-parser",
        "component-state",
        "component-planner"
      ]
    },
    {
      "id": "apply-sequence",
      "title": "Sequence Diagram: Apply Command",
      "description": "Shows the sequence for applying a plan: User, CLI, State Manager (lock), Executor, Provider, State Manager (write). Include loop for concurrent resource execution and retry logic.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "component-state",
        "component-provider"
      ]
    },
    {
      "id": "state-machine-resource",
      "title": "State Machine: Resource Lifecycle",
      "description": "Shows the states a resource goes through during apply: Pending -> Creating -> Created (or Error). Also transitions for Updating and Deleting. Include events like 'create started', 'create succeeded', 'create failed'.",
      "type": "state-machine",
      "relevant_sections": [
        "component-provider"
      ]
    },
    {
      "id": "flowchart-parser",
      "title": "Flowchart: Configuration Parsing and Resolution",
      "description": "Illustrates the multi-step process of loading a root config, resolving variables, recursively loading modules, and building the final resource collection. Include decision diamonds for 'variable found?' and 'module block?'.",
      "type": "flowchart",
      "relevant_sections": [
        "component-parser"
      ]
    },
    {
      "id": "flowchart-graph",
      "title": "Flowchart: Dependency Graph and Topological Sort",
      "description": "Shows the algorithm for building the graph: extract references, create nodes, add edges. Then, the topological sort process: find nodes with zero in-degree, remove, repeat. Highlight cycle detection.",
      "type": "flowchart",
      "relevant_sections": [
        "component-planner"
      ]
    }
  ]
}