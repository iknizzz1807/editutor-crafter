{
  "types": {
    "struct io_uring": "fields: sq_ring submission queue ring, cq_ring completion queue ring, fd file descriptor for io_uring instance",
    "struct io_uring_sqe": "fields: opcode operation type, fd target file descriptor, addr buffer address, len buffer length, offset file offset, user_data user-defined token",
    "struct io_uring_cqe": "fields: res result code, user_data user-defined token from corresponding SQE",
    "struct io_uring_ctx": "fields: ring io_uring instance, config engine_config, stats engine_stats, fixed_buffers iovec array, fixed_buffer_count unsigned int",
    "struct io_uring_engine": "fields: ctx io_uring_ctx pointer (opaque)",
    "struct engine_config": "fields: sq_entries unsigned int, cq_entries unsigned int, flags unsigned int, enable_sqpoll bool, sqpoll_cpu unsigned int",
    "struct engine_stats": "fields: sqe_submitted uint64_t, cqe_processed uint64_t, io_enter_calls uint64_t, batches_submitted uint64_t",
    "struct event_loop": "fields: engine io_uring_engine pointer, config loop_config, cbs event_callbacks, user_data void pointer, stop_requested volatile bool",
    "struct event_callbacks": "fields: on_setup function pointer, on_pre_submit function pointer, should_stop function pointer, on_cleanup function pointer",
    "struct loop_config": "fields: max_batch_size int, min_complete int, flags unsigned int, busy_wait bool, busy_wait_usec unsigned int",
    "struct io_op_context": "fields: id uint64_t, op_type uint8_t, connection pointer, buffer pointer, file pointer, chain_next pointer, aux_data union",
    "struct io_buffer": "fields: data void pointer, capacity size_t, in_use bool, is_fixed bool, fixed_index uint16_t, zc_refcount int, next pointer",
    "struct connection_state": "fields: fd int, remote_addr sockaddr_in, state conn_state_t, read_buffer struct io_buffer*, write_buffer struct io_buffer*, pending_ops int, last_active time_t, user_data uint64_t, user_ctx void*",
    "struct file_context": "fields: fd int, path char pointer, file_size off_t, ref_count int, last_access time_t",
    "struct context_table": "fields: slots io_op_context pointer pointer, mask uint64_t, count uint64_t",
    "struct buffer_pool": "fields: buffers io_buffer pointer, count size_t, fixed_count size_t, iovs iovec pointer, free_list io_buffer pointer, lock pthread_mutex_t",
    "struct connection_table": "fields: slots struct connection_state**, mask uint64_t, count uint64_t",
    "struct network_server": "fields: engine struct io_uring_engine*, conn_table struct connection_table*, listen_fd int, listen_addr struct sockaddr_in, running bool",
    "test_validator": "fields: expectations test_expectation pointer, count size_t, completed_count size_t",
    "test_expectation": "fields: user_data uint64_t, expected_result int, completed int, expected_buffer void pointer, expected_len size_t",
    "benchmark_result": "fields: server_type const char pointer, concurrency int, requests_per_second double, mb_per_second double, cpu_percent double",
    "thread_worker": "fields: thread_id pthread_t, worker_index int, engine io_uring_engine pointer, conn_table connection_table pointer, event_fd int, running volatile bool, pending_work work_queue pointer, queue_lock pthread_mutex_t",
    "worker_pool": "fields: workers thread_worker pointer, worker_count int, next_worker int, assignment_lock pthread_mutex_t",
    "http_request_t": "fields: method http_method_t, uri char[1024], version char[16], content_length size_t, keep_alive bool, headers_raw char[4096], headers_len size_t",
    "http_parser_t": "fields: req http_request_t, bytes_parsed size_t, content_received size_t, state enum {STATE_START_LINE, STATE_HEADERS, STATE_BODY, STATE_COMPLETE}",
    "wal": "fields: fd int, write_offset off_t, commit_offset off_t, lock pthread_mutex_t, engine io_uring_engine pointer",
    "wal_record": "fields: seq uint64_t, op_type uint8_t, timestamp uint64_t, path char[256], union { struct { off_t offset; size_t len; } write; struct { char new_path[256]; } rename; }, checksum uint8_t",
    "udp_session": "fields: remote_addr sockaddr_in, last_active time_t, packets_received uint64_t, packets_sent uint64_t, protocol_ctx void pointer",
    "http_context": "fields: state enum {HTTP_READING_HEADERS, HTTP_READING_BODY, HTTP_SENDING_RESPONSE}, req http_request, resp http_response, bytes_received size_t, bytes_sent size_t, keep_alive bool",
    "backend_server": "fields: host char[64], port int, active_connections int, avg_latency_ms double, last_health_check time_t, healthy bool",
    "load_balancer": "fields: backends backend_server pointer, backend_count int, algorithm enum {RR, LEAST_CONN, LATENCY}, rr_index int"
  },
  "methods": {
    "io_uring_setup(entries, params) returns fd": "creates a new io_uring instance",
    "io_uring_enter(fd, to_submit, min_complete, flags, sigmask) returns count": "submits SQEs and/or waits for CQEs",
    "io_uring_register(fd, opcode, arg, nr_args) returns status": "registers resources like buffers or files",
    "io_uring_get_sqe(ring) returns *sqe": "gets a free SQE from the submission queue (helper)",
    "io_uring_submit(ring) returns count": "submits all prepared SQEs to the kernel (helper)",
    "io_uring_wait_cqe(ring, cqe) returns status": "waits for a completion (helper)",
    "io_uring_peek_batch_cqe(ring, cqes, count) returns count": "peeks at multiple CQEs without consuming them",
    "io_uring_cqe_seen(ring, cqe)": "marks a CQE as consumed (helper)",
    "engine_create(cfg) returns *io_uring_engine": "create new io_uring engine instance",
    "engine_destroy(eng) returns void": "destroy engine and free resources",
    "engine_get_sqe(eng) returns *io_uring_sqe": "get free submission queue entry",
    "engine_submit(eng) returns int": "submit prepared SQEs to kernel",
    "engine_submit_and_wait(eng, min_complete) returns int": "submit and wait for completions",
    "engine_process_completions(eng) returns int": "process available completions",
    "engine_wait_and_process(eng) returns int": "wait for and process completions",
    "engine_get_stats(eng, out) returns void": "retrieve engine statistics",
    "engine_get_ring(eng) returns *io_uring": "get underlying io_uring instance",
    "event_loop_create(eng, config, cbs, user_data) returns *event_loop": "create event loop instance",
    "event_loop_run(loop) returns int": "run main event loop",
    "event_loop_destroy(loop) returns void": "destroy event loop",
    "event_loop_request_stop(loop) returns void": "request event loop to stop",
    "create_context_table(size) returns context_table pointer": "create a context lookup table",
    "destroy_context_table(table) returns void": "destroy context table and all contexts",
    "allocate_op_context(table) returns io_op_context pointer": "allocate and register new operation context",
    "lookup_op_context(table, user_data) returns io_op_context pointer": "find context by user_data token",
    "free_op_context(table, ctx) returns void": "free context and remove from table",
    "create_buffer_pool(buffer_size, buffer_count, register_fixed, ring) returns buffer_pool pointer": "initialize buffer pool with optional fixed registration",
    "acquire_buffer(pool) returns io_buffer pointer": "get available buffer from pool",
    "release_buffer(pool, buffer) returns void": "return buffer to pool after use",
    "conn_table_create(size) returns struct connection_table*": "create connection table with power-of-two size",
    "conn_table_destroy(table) returns void": "destroy connection table and all connections",
    "conn_create(fd, addr) returns struct connection_state*": "create new connection state",
    "conn_destroy(table, conn) returns void": "destroy single connection",
    "conn_lookup(table, user_data) returns struct connection_state*": "lookup connection by user_data token",
    "conn_register(table, conn) returns bool": "register connection in table",
    "conn_unregister(table, conn) returns void": "unregister connection from table",
    "submit_accept_multishot(server) returns int": "submit multishot accept SQE",
    "submit_connection_read(server, conn) returns int": "submit read SQE for connection",
    "submit_connection_write(server, conn, data, len) returns int": "submit write SQE for connection",
    "network_server_run(server) returns int": "main network event processing loop",
    "network_server_create(port, engine) returns struct network_server*": "create network server instance",
    "submit_zero_copy_send(ring, sock_fd, buf, len, user_data) returns": "submit zero-copy send operation with buffer reference tracking",
    "submit_linked_accept_read_write_chain(server, accept_sqe, read_sqe, write_sqe, conn) returns": "set up linked chain for accept→read→write operations",
    "handle_linked_chain_completion(server, accept_cqe, read_cqe, write_cqe, conn) returns": "process completion of three-operation linked chain",
    "engine_process_completions_with_zc(eng) returns": "process CQEs including zero-copy notifications",
    "acquire_buffer_zc(pool) returns": "acquire buffer only if no kernel references",
    "release_buffer_after_zc(pool, buf, is_notification) returns": "release buffer after zero-copy operation or notification",
    "prepare_async_file_read(ring, file_fd, buf, offset, len, user_data) returns int": "prepares an SQE for an asynchronous file read",
    "submit_linked_echo_chain(server, conn) returns int": "submits a linked READ->WRITE chain for echoing data",
    "handle_io_error(cqe, ctx, server_context) returns int": "main error dispatch function",
    "classify_error(error_code) returns error_category_t": "classify error code into category",
    "error_register_handler(op_type, handler) returns void": "register subsystem-specific error handler",
    "handle_network_error(cqe, ctx, server_context) returns int": "network-specific error handler implementation",
    "test_validator_create(count) returns test_validator pointer": "create validator with specified number of expected completions",
    "test_validator_add_expectation(validator, index, user_data, expected_result, expected_buffer, expected_len) returns void": "add expected completion to validator",
    "test_validator_record_completion(validator, user_data, actual_result, actual_buffer, actual_len) returns int": "record actual completion, verify against expectations",
    "test_validator_all_completed(validator) returns int": "check if all expected completions received",
    "test_validator_destroy(validator) returns void": "free validator resources",
    "benchmark_file_server(server_host, server_port, test_file, file_size, concurrency, total_requests, result) returns void": "benchmark file server performance",
    "compare_with_sync_baseline() returns int": "compare io_uring file server with synchronous baseline",
    "dump_ring_state(ring) returns void": "prints current state of io_uring rings for debugging",
    "encode_user_data(conn_id, op_type, seq, buffer_id) returns uint64_t": "encodes debugging information into user_data field",
    "decode_user_data(user_data, conn_id, op_type, seq, buffer_id) returns void": "decode debugging information from user_data field",
    "event_loop_run_debug(loop, dump_interval) returns int": "runs event loop with periodic debugging output",
    "worker_pool_create(worker_count) returns worker_pool pointer": "create thread worker pool with specified or CPU count workers",
    "worker_thread_main(arg) returns void pointer": "main loop for each worker thread",
    "assign_connection_to_worker(pool, client_fd, addr) returns int": "assign new connection to worker using load balancing strategy",
    "try_steal_work(thief, thief_idx) returns void": "attempt to steal work from other workers when idle",
    "setup_ktls(sockfd, cert_path, key_path) returns int": "configure kernel TLS on socket",
    "http_parser_init(parser) returns void": "initialize HTTP parser state",
    "http_parser_feed(parser, data, len) returns parse_status_t": "feed data to incremental HTTP parser",
    "http_parser_reset(parser) returns void": "reset parser for new request",
    "adaptive_tune(engine) returns void": "adjust server parameters based on observed metrics"
  },
  "constants": {
    "IORING_OP_READ": "asynchronous read operation",
    "IORING_OP_WRITE": "asynchronous write operation",
    "IORING_OP_ACCEPT": "asynchronous accept operation",
    "IORING_ACCEPT_MULTISHOT": "flag for multishot accept",
    "IORING_OP_SEND_ZC": "zero-copy send operation",
    "IOSQE_IO_LINK": "flag to link SQEs into a chain",
    "IOSQE_IO_DRAIN": "flag to serialize execution",
    "IORING_ENTER_GETEVENTS": "flag to wait for completions when calling io_uring_enter",
    "IORING_REGISTER_BUFFERS": "opcode to register fixed buffers",
    "CONN_ACCEPTING": "Connection state: waiting for accept",
    "CONN_READING": "Connection state: waiting for read",
    "CONN_WRITING": "Connection state: waiting for write",
    "CONN_CLOSING": "Connection state: cleaning up",
    "CONN_CLOSED": "Connection state: fully closed",
    "IORING_CQE_F_NOTIF": "Completion flag for zero-copy notifications",
    "IORING_SETUP_SQPOLL": "flag for kernel-side submission queue polling",
    "IORING_CQ_F_OVERFLOW": "flag indicating completion queue overflow occurred",
    "EBUSY": "error code indicating ring is full",
    "EAGAIN": "error code indicating operation would block",
    "EINVAL": "error code indicating invalid argument",
    "OP_TYPE_READ": "internal constant for file read operation",
    "OP_TYPE_ACCEPT_MULTI": "internal constant for multishot accept operation",
    "OP_TYPE_READ_LINKED": "internal constant for linked read operation",
    "OP_TYPE_WRITE_LINKED": "internal constant for linked write operation",
    "ERR_CATEGORY_APPLICATION": "0 - Application error category",
    "ERR_CATEGORY_TRANSIENT": "1 - Transient error category",
    "ERR_CATEGORY_FATAL": "2 - Fatal error category",
    "ERR_CATEGORY_RESOURCE": "3 - Resource error category",
    "IORING_OP_ASYNC_CANCEL": "io_uring operation for canceling pending operations",
    "ECONNRESET": "error code indicating connection reset by peer",
    "ENOBUFS": "error code indicating no buffer space available",
    "EFAULT": "error code indicating bad memory access",
    "LOG_TRACE": "0 - most verbose log level",
    "LOG_DEBUG": "1 - debug log level",
    "LOG_INFO": "2 - informational log level",
    "LOG_WARN": "3 - warning log level",
    "LOG_ERROR": "4 - error log level",
    "LOG_FATAL": "5 - fatal error log level",
    "OP_CONTEXT_MAGIC": "0xDEADC0DE - magic number for detecting corruption in io_op_context",
    "HTTP_METHOD_GET": "HTTP GET method constant",
    "HTTP_METHOD_POST": "HTTP POST method constant",
    "HTTP_METHOD_HEAD": "HTTP HEAD method constant",
    "HTTP_METHOD_UNKNOWN": "Unknown HTTP method",
    "PARSE_INCOMPLETE": "Parser needs more data",
    "PARSE_COMPLETE": "Parser completed successfully",
    "PARSE_ERROR": "Parser encountered error",
    "STATE_START_LINE": "HTTP parser state: parsing request line",
    "STATE_HEADERS": "HTTP parser state: parsing headers",
    "STATE_BODY": "HTTP parser state: reading body",
    "STATE_COMPLETE": "HTTP parser state: request complete",
    "HTTP_READING_HEADERS": "HTTP context state: reading headers",
    "HTTP_READING_BODY": "HTTP context state: reading body",
    "HTTP_SENDING_RESPONSE": "HTTP context state: sending response",
    "RR": "Round-robin load balancing algorithm",
    "LEAST_CONN": "Least connections load balancing algorithm",
    "LATENCY": "Latency-based load balancing algorithm"
  },
  "terms": {
    "SQE": "Submission Queue Entry - describes one I/O operation to perform",
    "CQE": "Completion Queue Entry - reports the result of a completed operation",
    "SQ": "Submission Queue - ring buffer of SQEs",
    "CQ": "Completion Queue - ring buffer of CQEs",
    "fixed buffers": "pre-registered buffers that can be referenced by index, reducing per-operation overhead",
    "multishot": "operation that automatically re-submits itself after completion, useful for accepts and receives",
    "zero-copy": "data transfer without copying between kernel and user space",
    "linked operations": "chain of SQEs that execute sequentially",
    "user_data": "a user-defined token passed from SQE to CQE to correlate requests with completions",
    "event-driven architecture": "architecture where flow is determined by events from I/O operations",
    "single-threaded": "runs in one thread, avoiding locking overhead",
    "submission queue (SQ)": "ring buffer of SQEs submitted to kernel",
    "completion queue (CQ)": "ring buffer of CQEs returned from kernel",
    "fixed buffer registration": "preregistering buffers with kernel to reduce per-operation overhead",
    "user_data token": "Unique identifier encoding connection ID and operation type",
    "busy-wait": "actively polling for completions instead of blocking on syscall",
    "correlation tokens": "user_data values that match completions to their originating context",
    "state machines": "Models tracking progression through defined states (like connection lifecycle)",
    "inventory system": "Analogy for data model tracking in-flight operations",
    "claim ticket": "Analogy for user_data token returned with completion",
    "memory barriers": "synchronization operations ensuring memory access ordering",
    "linear probing": "Hash collision resolution by checking subsequent slots",
    "zero-copy reference counting": "Tracking kernel references to buffers for zero-copy operations",
    "object pooling": "Reusing allocated objects to avoid allocation overhead",
    "liburing": "helper library for io_uring operations",
    "opportunistic batching": "submitting SQEs when batch is full or when waiting for completions",
    "multishot accept": "Single SQE that produces multiple accept completions",
    "connection state machine": "Model tracking connection through ACCEPTING, READING, WRITING, CLOSING, CLOSED states",
    "buffer rotation": "Alternating between two buffers to prevent read/write conflicts",
    "reference counting": "tracking active references to buffers for zero-copy operations",
    "notification CQE": "completion entry signaling kernel buffer release for zero-copy",
    "chain atomicity": "property where linked chain succeeds or fails as a whole",
    "Library Book Retrieval System": "Mental model for async file I/O",
    "Assembly Line with a Concierge Desk": "Mental model for network echo with linked operations",
    "error classification": "Process of categorizing errors by severity and recoverability",
    "linked chain partial failure": "When a linked SQE chain stops due to an error in a middle operation",
    "CQ overflow": "when completion queue becomes full and kernel drops completions",
    "zero-copy notification": "special completion entry signaling kernel buffer release for zero-copy operations",
    "transient error": "Temporary error that may resolve if operation is retried",
    "application error": "Error caused by client behavior or invalid request parameters",
    "fatal error": "Critical error indicating system cannot continue normal operation",
    "user_data correlation": "matching completion entries to their originating operations using user-defined tokens",
    "buffer pool load factor": "Ratio of buffers in use to total buffers in pool",
    "concurrency level": "Number of simultaneous clients or operations in benchmark",
    "hash collision resolution": "Method for handling multiple keys mapping to same hash table slot",
    "refcount bugs": "Errors in reference counting leading to use-after-free or memory leaks",
    "tight loops": "Code loops without yielding that consume excessive CPU",
    "completion ordering": "Sequence in which completed operations become available, not guaranteed to match submission order",
    "linked chain atomicity": "property where linked chain succeeds or fails as a whole",
    "work stealing": "load balancing technique where idle threads take work from busy threads",
    "connection affinity": "practice of routing related connections to the same worker thread",
    "incremental parser": "parser that can process partial input and resume when more data arrives",
    "write-ahead log": "durability technique where operations are logged before execution",
    "kernel TLS": "Linux kernel feature that offloads TLS encryption/decryption",
    "load balancing": "distributing workload across multiple backend servers",
    "health checking": "periodically verifying backend servers are operational",
    "zero-copy splicing": "transferring data between file descriptors without copying to userspace",
    "adaptive tuning": "automatically adjusting server parameters based on runtime metrics",
    "prometheus metrics": "standard format for exposing system metrics",
    "circuit breaker": "design pattern that fails fast when dependent service is unavailable",
    "NUMA awareness": "optimizing memory and CPU usage for Non-Uniform Memory Access architectures",
    "thread-local storage": "data specific to each thread, not shared between threads",
    "Application error": "Error caused by client behavior or invalid request parameters",
    "Buffer pool load factor": "Ratio of buffers in use to total buffers in pool",
    "Buffer rotation": "Alternating between two buffers to prevent read/write conflicts",
    "Busy-wait": "actively polling for completions instead of blocking on syscall",
    "Chain atomicity": "property where linked chain succeeds or fails as a whole",
    "Completion ordering": "Sequence in which completed operations become available, not guaranteed to match submission order",
    "Connection affinity": "practice of routing related connections to the same worker thread",
    "Connection state machine": "Model tracking connection through ACCEPTING, READING, WRITING, CLOSING, CLOSED states",
    "Correlation tokens": "user_data values that match completions to their originating context",
    "Error classification": "Process of categorizing errors by severity and recoverability",
    "Event-driven architecture": "architecture where flow is determined by events from I/O operations",
    "Fatal error": "Critical error indicating system cannot continue normal operation",
    "Fixed buffer registration": "preregistering buffers with kernel to reduce per-operation overhead",
    "Fixed buffers": "pre-registered buffers that can be referenced by index, reducing per-operation overhead",
    "Hash collision resolution": "Method for handling multiple keys mapping to same hash table slot",
    "Incremental parser": "parser that can process partial input and resume when more data arrives",
    "Inventory system": "Analogy for data model tracking in-flight operations",
    "Liburing": "helper library for io_uring operations",
    "Linked chain partial failure": "When a linked SQE chain stops due to an error in a middle operation",
    "Linked operations": "chain of SQEs that execute sequentially",
    "Memory barriers": "synchronization operations ensuring memory access ordering",
    "Multishot": "operation that automatically re-submits itself after completion, useful for accepts and receives",
    "Multishot accept": "Single SQE that produces multiple accept completions",
    "Notification CQE": "special completion entry signaling kernel buffer release for zero-copy operations",
    "Object pooling": "Reusing allocated objects to avoid allocation overhead",
    "Opportunistic batching": "submitting SQEs when batch is full or when waiting for completions",
    "Refcount bugs": "Errors in reference counting leading to use-after-free or memory leaks",
    "Reference counting": "tracking active references to buffers for zero-copy operations",
    "Single-threaded": "runs in one thread, avoiding locking overhead",
    "State machines": "Models tracking progression through defined states (like connection lifecycle)",
    "Submission queue (SQ)": "ring buffer of SQEs submitted to kernel",
    "Tight loops": "Code loops without yielding that consume excessive CPU",
    "Transient error": "Temporary error that may resolve if operation is retried",
    "User_data": "a user-defined token passed from SQE to CQE to correlate requests with completions",
    "User_data correlation": "matching completion entries to their originating operations using user-defined tokens",
    "User_data token": "Unique identifier encoding connection ID and operation type",
    "Work stealing": "load balancing technique where idle threads take work from busy threads",
    "Zero-copy": "data transfer without copying between kernel and user space",
    "Zero-copy notification": "special completion entry signaling kernel buffer release for zero-copy operations",
    "Zero-copy reference counting": "Tracking kernel references to buffers for zero-copy operations"
  }
}