{
  "types": {
    "MetricPoint": "fields: Timestamp time.Time, ResponseTime time.Duration, StatusCode int, Success bool, BytesSent int64, BytesReceived int64, WorkerID string, VirtualUserID string, ScenarioName string, StepName string",
    "VirtualUser": "fields: ID string, client *http.Client, scenario *Scenario, session *SessionManager, metrics *MetricsCollector, thinkTime ThinkTimeGenerator, stopCh <-chan struct{}",
    "MetricsCollector": "fields: mu sync.RWMutex, points []MetricPoint, subscribers []chan<- MetricPoint, batchSize int, flushInterval time.Duration",
    "RealisticThinkTime": "fields: baseDelays map[string]time.Duration, random *rand.Rand",
    "ConnectionStats": "fields: ActiveConnections int, IdleConnections int, TotalRequests int64",
    "CoordinatorState": "fields: ActiveTests map[string]*TestExecution, ConnectedWorkers map[string]*WorkerNode, MetricsAggregator *MetricsAggregator, LoadBalancer *LoadBalancer",
    "WorkerNode": "fields: WorkerID string, VirtualUsers map[string]*VirtualUser, CoordinatorConnection *grpc.ClientConn, LocalMetrics *MetricsCollector, LoadProfile *LoadProfile, HealthReporter *HealthReporter",
    "MetricsAggregator": "fields: ResponseTimeHistogram *hdrhistogram.Histogram, ThroughputWindows *SlidingWindow, ErrorCounters map[int]*ErrorCounter, TimeSeriesBuffer *CircularBuffer, LiveSubscribers []chan<- *AggregatedResults",
    "Dashboard": "fields: WebSocketConnections map[string]*websocket.Conn, ChartDataBuffers *TimeSeriesBuffers, TestSessions map[string]*TestSession, ReportGenerator *ReportGenerator",
    "HealthStatus": "fields: Status string, Timestamp time.Time, Uptime time.Duration, Version string, Metrics map[string]interface{}, Errors []string",
    "TestConfiguration": "fields: TestID string, Name string, TargetURL string, Scenario *Scenario, LoadProfile *LoadProfile",
    "Scenario": "fields: Name string, Steps []ScenarioStep, Weight int, SetupActions []SetupAction",
    "ScenarioStep": "fields: Name string, Method string, Path string, Headers map[string]string, Body string",
    "LoadProfile": "fields: VirtualUsers int, RampUpDuration time.Duration, SteadyStateDuration time.Duration, RampDownDuration time.Duration",
    "TestExecution": "fields: TestID string, Configuration *TestConfiguration, Status TestStatus, StartTime time.Time, WorkerAssignments map[string]*WorkerAssignment",
    "WorkerAssignment": "fields: WorkerID string, VirtualUserCount int, RampUpSchedule *RampUpSchedule, ScenarioDistribution map[string]int",
    "AggregatedResults": "fields: Timestamp time.Time, WindowStart time.Time, TotalRequests int64, Throughput float64, ResponseTimePercentiles map[string]time.Duration, ErrorRate float64",
    "SessionManager": "fields: UserID string, Cookies map[string]*http.Cookie, Variables map[string]string, AuthTokens map[string]string, RequestCount int64, SessionStart time.Time, LastActivity time.Time, MaxVariables int",
    "ThinkTimeGenerator": "interface with NextThinkTime method",
    "HistogramSnapshot": "fields: hist *hdrhistogram.Histogram, mu sync.RWMutex",
    "CircularBuffer": "fields: buffer []*AggregatedResults, head int, size int, count int64, resolution time.Duration, mu sync.RWMutex",
    "MetricStreamer": "fields: connections map[string]*websocket.Conn, mu sync.RWMutex, updateCh chan *AggregatedResults",
    "ReportGenerator": "fields: TestMetadata *TestConfiguration, RawMetrics []MetricPoint, AggregatedData []*AggregatedResults, TemplateEngine *template.Template, ChartGenerator *ChartGenerator, ExportFormats []string, ReportConfig *ReportConfiguration",
    "ConnectionManager": "fields: connections map[string]*websocket.Conn, mu sync.RWMutex, upgrader websocket.Upgrader, pingInterval time.Duration, pongTimeout time.Duration",
    "TimeSeriesBuffers": "fields: buffers for different metric types and time windows with retention policies",
    "CircuitBreakerState": "enum: CircuitClosed, CircuitHalfOpen, CircuitOpen",
    "CircuitBreaker": "fields: state, failureThreshold, recoveryTimeout, halfOpenMaxRequests, counters",
    "ResourceMonitor": "fields: limits, memoryPressure, connectionStats, callbacks",
    "MemoryPressureLevel": "enum: MemoryNormal, MemoryModerate, MemoryHigh, MemoryCritical, MemoryEmergency",
    "ErrorType": "enum: ErrorTransientNetwork, ErrorRateLimiting, ErrorServerOverload, ErrorClientError, ErrorAuthentication, ErrorTargetFailure",
    "ClassifiedError": "fields: Original error, Type ErrorType, Retryable bool, RetryAfter time.Duration, Severity int",
    "ProtocolAdapter": "interface with CreateVirtualUser, ValidateScenario, GetSupportedMetrics, CreateMetricsCollector methods",
    "ProtocolVirtualUser": "interface extending VirtualUser with protocol-specific capabilities",
    "WebSocketVirtualUser": "extends VirtualUser for persistent WebSocket connections",
    "WebSocketScenario": "defines WebSocket interaction sequences",
    "WebSocketMetrics": "captures bidirectional communication metrics",
    "LoadController": "implements feedback-based dynamic load adjustment",
    "ChaosExperiment": "defines controlled failure injection during testing",
    "ChaosController": "manages chaos engineering experiments",
    "AdjustmentPolicy": "configuration for dynamic load control",
    "ControlHistory": "tracks load adjustment effectiveness",
    "SafetyLimits": "boundaries for load adjustment and chaos experiments",
    "PerformanceTargets": "target metrics for adaptive control",
    "LoadAdjustment": "structured load change with reasoning",
    "FailureType": "enum for chaos experiment failure categories",
    "ExperimentScope": "defines which components affected by chaos",
    "SafetyCheck": "condition that can abort experiment",
    "ImpactPrediction": "expected results from chaos experiment",
    "ExperimentResults": "outcomes and measurements from chaos experiment"
  },
  "methods": {
    "Run(ctx context.Context) error": "main virtual user execution loop",
    "executeRequest(step ScenarioStep, intendedTime time.Time) (*http.Response, error)": "single HTTP request with measurement",
    "NextThinkTime(actionType string) time.Duration": "generate realistic pause duration",
    "RecordResponse(point MetricPoint)": "store measurement and notify subscribers",
    "RealisticHTTPClient() *http.Client": "create browser-like HTTP client",
    "Subscribe() <-chan MetricPoint": "get real-time metric updates",
    "StartTest(config TestConfiguration) (testID string, error)": "initiates new load test with worker coordination",
    "StopTest(testID string) error": "gracefully terminates running test across all workers",
    "RegisterWorker(worker *WorkerNode) error": "adds new worker to available pool",
    "DistributeLoad(testID string, totalUsers int) map[string]int": "calculates virtual user allocation per worker",
    "ExecuteLoadProfile(profile *LoadProfile) error": "starts assigned virtual users with ramp-up schedule",
    "StreamMetrics(batchSize int) <-chan MetricBatch": "returns channel of raw measurement batches",
    "ReportHealth() error": "sends worker status to coordinator",
    "ProcessMetricBatch(batch []MetricPoint) error": "incorporates worker measurements into aggregates",
    "GetCurrentStats(windowSize time.Duration) *AggregatedResults": "returns latest percentiles and throughput",
    "StreamMetrics(conn *websocket.Conn, testID string) error": "establishes real-time metric streaming to browser",
    "NewMetricPoint(workerID, virtualUserID, scenarioName, stepName string) *MetricPoint": "creates properly initialized MetricPoint with current timestamp",
    "RecordResponse(response *http.Response, responseTime time.Duration, bytesReceived int64)": "updates MetricPoint with HTTP response data",
    "RecordError(err error, errorType string)": "captures error information when request fails",
    "NewCoordinatorState() *CoordinatorState": "initializes coordinator with empty state",
    "DistributeLoad(testID string, totalUsers int) (map[string]int, error)": "calculates virtual user allocation across workers",
    "ValidateTestConfiguration(config *TestConfiguration) error": "validates test configuration completeness",
    "MarshalTimeField(t time.Time) ([]byte, error)": "consistent timestamp serialization",
    "UnmarshalTimeField(data []byte) (time.Time, error)": "consistent timestamp parsing",
    "ApplyToRequest(req *http.Request) error": "add session state to HTTP request",
    "ProcessResponse(resp *http.Response, extractors map[string]string) error": "extract data from response and update session",
    "RecordValue(value time.Duration) error": "safely records a measurement in HDR histogram",
    "Percentile(percentile float64) time.Duration": "safely retrieves a percentile value from histogram",
    "Merge(other *HistogramSnapshot) error": "combines this histogram with another histogram",
    "Add(result *AggregatedResults)": "inserts a new measurement snapshot into circular buffer",
    "GetRange(start, end time.Time) []*AggregatedResults": "returns snapshots within time range",
    "BroadcastUpdate(result *AggregatedResults)": "sends metric updates to all connected clients",
    "HandleWebSocket(w http.ResponseWriter, r *http.Request)": "upgrades HTTP connections to WebSocket",
    "HandleWebSocket(w http.ResponseWriter, r *http.Request) error": "upgrades HTTP connections to WebSocket",
    "GenerateHTMLReport(testID string) ([]byte, error)": "creates comprehensive performance report in HTML format",
    "GenerateJSONReport(testID string) ([]byte, error)": "creates machine-readable test results for automation",
    "AllowRequest() bool": "determines if circuit breaker allows request through",
    "RecordSuccess()": "records successful request outcome for circuit breaker",
    "RecordFailure()": "records failed request outcome for circuit breaker",
    "StartMonitoring()": "begins continuous resource monitoring",
    "RegisterMemoryCallback(func(MemoryPressureLevel))": "adds callback for memory pressure changes",
    "ClassifyError(error, *http.Response) *ClassifiedError": "analyzes and classifies errors with handling guidance",
    "HandleVirtualUserError(error, *http.Response, ScenarioStep) error": "processes virtual user execution errors",
    "HandleWorkerFailure(string) error": "processes worker disconnection and redistribution",
    "HandleResourceExhaustion(MemoryPressureLevel) error": "implements resource exhaustion protection",
    "CreateVirtualUser(id, scenario, sessionManager) (ProtocolVirtualUser, error)": "creates protocol-specific virtual user instance",
    "ValidateScenario(scenario) error": "checks scenario validity for protocol",
    "GetSupportedMetrics() []string": "returns metric types protocol can produce",
    "CreateMetricsCollector(config) (*MetricsCollector, error)": "creates protocol-specific metrics collector",
    "ExecuteStep(step, intendedTime) error": "performs single scenario step with metrics",
    "GetSessionState() map[string]interface{}": "returns protocol-specific session info",
    "Cleanup() error": "releases protocol-specific resources",
    "StartAdaptiveControl(ctx, testID) error": "begins dynamic load adjustment",
    "CalculateLoadAdjustment(current, target) (*LoadAdjustment, error)": "determines optimal load change",
    "ExecuteChaosExperiment(ctx, experiment, testID) (*ExperimentResults, error)": "runs controlled failure injection"
  },
  "constants": {
    "MaxIdleConnsPerHost": "6 connections to match Chrome browser",
    "IdleConnTimeout": "90 seconds for connection reuse",
    "TLSHandshakeTimeout": "10 seconds for SSL negotiation",
    "TimeFormat": "RFC3339Nano format for consistent timestamps",
    "MaxConnectionsPerWorker": "limits per-worker connections for protocols",
    "MinLoadAdjustmentInterval": "minimum time between load changes",
    "DefaultChaosExperimentTimeout": "maximum experiment duration",
    "SafetyCheckInterval": "frequency of safety condition evaluation"
  },
  "terms": {
    "virtual user": "simulated user executing realistic interaction patterns",
    "think time": "realistic pauses between user actions to simulate reading/decision time",
    "coordinated omission": "timing measurement error from measuring send time instead of intended time",
    "connection pooling": "reusing TCP connections across requests to match browser behavior",
    "session management": "maintaining cookies and authentication state across requests",
    "percentile aggregation": "mathematically combining percentile metrics from multiple sources",
    "coordinator-worker pattern": "architectural pattern where coordinator orchestrates distributed load generation across worker nodes",
    "metric streaming": "high-throughput delivery of performance measurements from workers to aggregator",
    "load distribution": "partitioning virtual users across available worker nodes",
    "backpressure": "flow control when consumers cannot process data as fast as producers",
    "metrics aggregation": "combining performance measurements from multiple sources",
    "coordination state": "distributed system awareness and synchronization data",
    "load profile": "specification of user count and ramp-up over time",
    "worker assignment": "allocation of virtual users to specific worker nodes",
    "scenario DSL": "domain-specific language for defining user interaction sequences",
    "template substitution": "dynamic variable replacement in scenario definitions",
    "action profile": "timing patterns specific to different types of user actions",
    "HDR histogram": "High Dynamic Range histogram for accurate percentile calculation",
    "streaming aggregation": "real-time metric combination across multiple worker nodes",
    "time series data management": "windowing, downsampling, and storage of historical metric data",
    "metric collection pipeline": "response time tracking, throughput measurement, and error categorization",
    "circular buffer": "fixed-memory storage that automatically discards oldest data",
    "WebSocket streaming": "real-time delivery of metric updates to dashboard browsers",
    "live dashboard": "real-time visualization interface showing test progress and metrics",
    "report generation": "creation of comprehensive post-test analysis documents",
    "metric visualization": "graphical representation of performance data",
    "chart export capabilities": "ability to extract visualizations and data for external use",
    "responsive chart design": "visualization adaptation to different screen sizes and contexts",
    "performance anomaly highlighting": "automatic identification and emphasis of unusual patterns",
    "connection management": "handling of WebSocket lifecycle and client registry",
    "circuit breaker": "protection mechanism that stops requests to failing services",
    "graceful degradation": "reducing functionality rather than failing completely",
    "resource exhaustion": "depletion of system resources like memory or connections",
    "network partition": "network failure that splits distributed system into isolated groups",
    "load redistribution": "moving virtual users from failed to healthy workers",
    "adaptive flow control": "automatically adjusting data transmission rate based on conditions",
    "cascading failure": "failure in one component triggering failures in dependent components",
    "recovery confidence": "algorithm to detect sustained target system recovery",
    "clock skew": "time difference between distributed system clocks",
    "memory pressure": "high memory usage approaching system limits",
    "protocol adapter": "plugin that implements protocol-specific testing capabilities",
    "bidirectional communication": "protocols where messages flow in both directions simultaneously",
    "dynamic load adjustment": "automatic modification of load patterns based on system behavior",
    "chaos engineering integration": "controlled failure injection during load testing",
    "AI-driven scenario generation": "machine learning-based creation of realistic test scenarios",
    "feedback control system": "closed-loop system that adjusts behavior based on measured outcomes",
    "resilience validation": "testing system behavior under combined stress and failures",
    "adaptive testing system": "framework that modifies test parameters based on real-time observations",
    "control theory principles": "mathematical approaches to stable system adjustment",
    "dual-timeline scenario": "test pattern with both scripted and reactive behaviors",
    "performance cliff effects": "sudden performance degradation at specific load levels",
    "coordinated omission correction": "timing measurement that accounts for intended vs actual request timing"
  }
}