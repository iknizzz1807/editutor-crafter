title: Memory Ordering State Machine

classes: {
  state_style: {
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  initial_state: {
    style.fill: "#3fb950"
    style.stroke: "#3fb950"
    style.font-color: "#1a1a2e"
    style.bold: true
  }
  final_state: {
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.double-border: true
    style.bold: true
  }
  transition_label: {
    style.font-color: "#8b949e"
    style.font-size: 12
  }
  memory_container: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
}

init: {
  shape: circle
  class: initial_state
  label: ""
}

relaxed: Relaxed Ordering {
  shape: circle
  class: state_style
}

acquire: Acquire Ordering {
  shape: circle
  class: state_style
}

release: Release Ordering {
  shape: circle
  class: state_style
}

seq_cst: Sequential Consistency {
  shape: circle
  class: state_style
}

synchronized: Full Synchronization {
  shape: circle
  class: final_state
}

memory_effects: Memory Visibility Effects {
  class: memory_container
  
  no_sync: No Synchronization\n• Operations can be reordered\n• No visibility guarantees
  
  acquire_barrier: Acquire Barrier\n• Prevents later reads/writes\n  from moving before this operation\n• Synchronizes with release operations
  
  release_barrier: Release Barrier\n• Prevents earlier reads/writes\n  from moving after this operation\n• Makes all prior operations visible
  
  full_barrier: Full Memory Barrier\n• No reordering across this point\n• Total ordering of all operations\n• Maximum synchronization overhead
}

init -> relaxed: atomic_load/store\n(memory_order_relaxed)

relaxed -> acquire: atomic_load\n(memory_order_acquire)

relaxed -> release: atomic_store/RMW\n(memory_order_release)

acquire -> seq_cst: atomic_operation\n(memory_order_seq_cst)

release -> seq_cst: atomic_operation\n(memory_order_seq_cst)

seq_cst -> synchronized: fence()\nmemory_order_seq_cst

relaxed -> relaxed: RMW operations\n(CAS, fetch_add, etc.)

acquire -> release: acq_rel ordering\n(atomic RMW operations)

release -> acquire: release-acquire pair\n(producer-consumer sync)

relaxed -> memory_effects.no_sync
acquire -> memory_effects.acquire_barrier
release -> memory_effects.release_barrier
seq_cst -> memory_effects.full_barrier