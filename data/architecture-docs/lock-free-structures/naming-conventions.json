{
  "types": {
    "AtomicReference": "fields: value, lock",
    "TaggedPointer": "fields: pointer, tag",
    "Node": "fields: data Any, next AtomicReference",
    "MemoryOrdering": "constants: RELAXED, ACQUIRE, RELEASE, SEQ_CST",
    "Operation": "fields: type OperationType, timestamp float, thread_id int, invocation bool, args Tuple, result Any, operation_id str",
    "LinearizabilityChecker": "fields: operations List, operation_lock threading.Lock, operation_counter int, verification_cache Dict",
    "TreiberStack": "fields: top atomic pointer",
    "MichaelScottQueue": "fields: head AtomicReference, tail AtomicReference",
    "SplitOrderedHashMap": "fields: buckets array, size AtomicReference, bucket_mask AtomicReference, resize_in_progress AtomicReference",
    "HazardPointer": "fields: protected_pointers per thread, thread_registry",
    "RetirementList": "fields: retired_nodes, scan_threshold",
    "OperationType": "enum: PUSH, POP, ENQUEUE, DEQUEUE, INSERT, LOOKUP, DELETE",
    "ThreadRecord": "fields: thread_id, hazard_slots, next_record, active",
    "BucketNode": "fields: key Any, value Any, hash integer, is_sentinel boolean, next AtomicReference, deleted AtomicReference",
    "BucketInitializer": "fields: buckets array, max_bucket_count integer, initializing set, init_lock Lock",
    "FailureMode": "enum with ABA_PROBLEM, LIVELOCK, MEMORY_RACE, PROGRESS_VIOLATION, INVARIANT_VIOLATION",
    "FailureReport": "fields: failure_mode FailureMode, thread_id int, timestamp float, operation_type str, details Dict, stack_trace Optional[str]",
    "InvariantChecker": "fields: enable_checking bool, violation_count int, last_check_time float",
    "PerformanceMonitor": "fields: operation_times Dict, cas_attempts Dict, success_rates Dict, history_size int",
    "BackoffStrategy": "fields: initial_delay int, max_delay int, multiplier float, jitter float, current_delay int, consecutive_failures int",
    "RetryLoop": "fields: max_attempts int, thread_backoff Dict",
    "StressTestConfig": "fields: num_threads int, operations_per_thread int, test_duration_seconds Optional[float], operation_mix Dict, contention_level str, backoff_strategy str",
    "StressTestResults": "fields: total_operations int, successful_operations int, failed_operations int, total_duration float, throughput_ops_per_sec float, average_latency_ms float, p95_latency_ms float, p99_latency_ms float, cas_success_rate float, thread_results List",
    "StressTestFramework": "fields: data_structure Any, config StressTestConfig, results StressTestResults, operation_times List[float], cas_attempts int, cas_successes int, results_lock threading.Lock, should_stop threading.Event"
  },
  "methods": {
    "compare_and_swap(expected, new_value)": "atomic CAS returning success boolean and observed value",
    "fetch_and_add(increment)": "atomic increment returning previous value",
    "load(ordering)": "atomic load with memory ordering",
    "store(value, ordering)": "atomic store with memory ordering",
    "record_operation(op)": "thread-safe operation recording for linearizability verification",
    "stress_test_data_structure": "concurrent correctness and performance testing",
    "stress_test_data_structure()": "execute comprehensive stress test and return detailed results",
    "push(data)": "lock-free stack push operation",
    "pop()": "lock-free stack pop operation",
    "enqueue(data)": "lock-free queue enqueue operation",
    "dequeue()": "lock-free queue dequeue operation",
    "protect(pointer)": "announce hazard pointer protection",
    "release()": "clear hazard pointer protection",
    "retire(node)": "add node to retirement list",
    "cas_retry_loop(atomic_ref, update_function, max_attempts)": "generic CAS retry with backoff returning (success, final_value, attempts)",
    "is_empty()": "check if queue contains no data elements",
    "size_hint()": "approximate count of queue elements",
    "release(slot_index)": "clear hazard pointer protection",
    "scan_and_reclaim()": "scan hazard pointers and free unprotected nodes",
    "protect_and_verify(atomic_ref)": "safely load and protect pointer using hazard pointers",
    "insert(key, value) -> bool": "insert key-value pair, return true if new entry",
    "lookup(key) -> Optional[Any]": "find value for key, return None if not found",
    "delete(key) -> Optional[Any]": "remove key, return deleted value or None",
    "ensure_bucket_exists(bucket_index) -> BucketNode": "initialize bucket if needed, return sentinel node",
    "size_hint() -> int": "approximate count of elements",
    "is_empty() -> bool": "check if container contains no elements",
    "reverse_bits(value, bit_count) -> int": "reverse lower bits for split-ordered placement",
    "calculate_bucket_index(hash_value, bucket_mask) -> int": "determine target bucket index",
    "mark_deleted() -> bool": "attempt logical deletion of node",
    "check_invariants(data_structure)": "validates all invariants and returns (is_valid, violation_description)",
    "record_operation(operation_type, duration, cas_attempts, success)": "track performance metrics for operation",
    "_validate_structure_specific_invariants(data_structure)": "implement structure-specific invariant checks",
    "wait()": "execute backoff delay with jitter",
    "on_failure()": "increase backoff delay after failed operation",
    "on_success()": "reset backoff delay after successful operation",
    "execute(operation, operation_name)": "execute operation with retry and backoff",
    "verify_history(start_time, end_time)": "check if operations in time window have valid sequential ordering",
    "_worker_thread(thread_id)": "execute operations for a single worker thread",
    "_execute_operation(operation_type, rng, thread_id)": "execute a single operation on the data structure",
    "verify_milestone_1_atomic_operations()": "verify atomic operations foundation correctness and performance",
    "verify_milestone_2_treiber_stack()": "verify Treiber stack functional correctness and linearizability",
    "verify_milestone_3_michael_scott_queue()": "verify Michael-Scott queue FIFO ordering and helping mechanism",
    "verify_milestone_4_hazard_pointers()": "verify hazard pointer memory safety and reclamation correctness",
    "verify_milestone_5_lock_free_hashmap()": "verify hash map operations and incremental resizing correctness",
    "record_operation(operation_type, is_invocation, args, result) -> str": "record operation for linearizability checking",
    "verify_history(start_time, end_time) -> Tuple[bool, List[str]]": "check operation ordering validity",
    "get_statistics(operation_type) -> Dict[str, float]": "return comprehensive operation statistics",
    "detect_contention(threshold) -> List[str]": "identify high-contention operations",
    "stress_test_data_structure() -> StressTestResults": "execute comprehensive concurrent testing",
    "_worker_thread(thread_id) -> Dict": "execute operations for single thread",
    "_execute_operation(operation_type, rng, thread_id) -> Tuple[bool, float, int]": "execute single operation with metrics",
    "ensure_bucket_exists(bucket_index)": "initialize bucket if needed, return sentinel node",
    "insert(key, value)": "insert key-value pair, return true if new entry",
    "lookup(key)": "find value for key, return None if not found",
    "delete(key)": "remove key, return deleted value or None"
  },
  "constants": {
    "RELAXED": "no ordering constraints",
    "ACQUIRE": "acquire semantics for loads",
    "RELEASE": "release semantics for stores",
    "SEQ_CST": "sequential consistency ordering",
    "ABA_PROBLEM": "failure mode for incorrect CAS success due to pointer reuse",
    "LIVELOCK": "failure mode for threads actively retrying but making no progress",
    "MEMORY_RACE": "failure mode for memory reclamation timing issues",
    "PROGRESS_VIOLATION": "failure mode for lock-free progress guarantee violations",
    "INVARIANT_VIOLATION": "failure mode for data structure invariant violations",
    "PUSH": "stack push operation",
    "POP": "stack pop operation",
    "ENQUEUE": "queue enqueue operation",
    "DEQUEUE": "queue dequeue operation",
    "INSERT": "hash map insert operation",
    "LOOKUP": "hash map lookup operation",
    "DELETE": "hash map delete operation"
  },
  "terms": {
    "ABA problem": "incorrect CAS success due to pointer reuse between read and update",
    "compare-and-swap": "fundamental atomic read-modify-write operation",
    "memory ordering": "constraints on instruction reordering and visibility",
    "linearizability": "correctness condition where operations appear atomic at linearization points",
    "lock-free": "non-blocking progress guarantee where at least one thread progresses",
    "wait-free": "stronger guarantee where every thread progresses within bounded steps",
    "hazard pointers": "memory reclamation scheme preventing premature deallocation",
    "tagged pointer": "pointer with version counter to detect ABA conditions",
    "Treiber stack": "lock-free stack algorithm using single CAS on top pointer",
    "Michael-Scott queue": "lock-free FIFO queue with dual pointers and helping mechanism",
    "split-ordered list": "hash map technique maintaining logical order in physical linked list",
    "helping mechanism": "threads assist each other to complete interrupted operations",
    "sentinel node": "permanent marker nodes that define bucket boundaries",
    "retirement list": "deferred deletion queue for nodes awaiting reclamation",
    "protect-then-verify pattern": "safe sequence for protecting loaded pointers with hazard pointers",
    "scan threshold": "retirement list size triggering global hazard pointer scan",
    "thread registry": "global list of all threads' hazard pointer slots",
    "reverse bit ordering": "bit reversal technique ensuring correct bucket splitting behavior",
    "incremental resizing": "gradual migration without blocking concurrent operations",
    "bucket initialization": "lazy creation of bucket sentinel nodes when first accessed",
    "logical deletion": "marking nodes as deleted without immediate physical removal",
    "physical deletion": "unlinking deleted nodes from the list structure",
    "load factor threshold": "ratio triggering resize operation",
    "bucket chain": "linked list of entries within a single hash bucket",
    "exponential backoff": "delay strategy that increases wait time after each failure",
    "livelock": "condition where threads continuously retry but make no collective progress",
    "memory reclamation races": "timing-dependent failures in deallocation of shared nodes",
    "progress guarantee violations": "conditions where lock-free algorithms fail to ensure forward progress",
    "invariant violation detection": "continuous monitoring of data structure consistency properties",
    "helping protocols": "mechanisms where threads assist each other to complete stuck operations",
    "graceful degradation": "fallback strategies that maintain correctness under extreme conditions",
    "linearizability checking": "verification that operations appear atomic at some execution point",
    "stress testing": "subjecting data structure to high concurrent contention to expose race conditions",
    "model checking": "exhaustive exploration of thread interleavings within bounded parameters",
    "randomized testing": "property-based verification using random operation sequences",
    "progress guarantees": "ensuring at least one thread makes forward progress within finite steps",
    "memory safety": "preventing use-after-free errors in manual memory management",
    "functional correctness": "data structure satisfies its specific semantic requirements",
    "false sharing": "performance degradation from unrelated variables sharing cache lines",
    "contention hotspot": "memory location accessed by multiple threads causing performance bottlenecks",
    "universal construction": "technique for building wait-free implementations from lock-free foundations",
    "flat combining": "hybrid approach with exclusive access periods for batched operations",
    "epoch-based reclamation": "memory reclamation using time periods instead of individual pointer tracking",
    "NUMA-aware allocation": "memory placement considering non-uniform memory access costs",
    "hardware transactional memory": "CPU support for atomic execution of code blocks",
    "linearization point": "specific instant when concurrent operation appears to take effect atomically"
  }
}