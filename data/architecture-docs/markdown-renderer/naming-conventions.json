{
  "types": {
    "ASTNode": "fields: node_type NodeType, children List[ASTNode], parent Optional[ASTNode], line_number int",
    "BlockNode": "extends ASTNode, fields: block_type BlockType, inline_content str, block_attributes Dict[str, Any]",
    "InlineNode": "fields: inline_type InlineType, text_content str, formatting_attributes Dict[str, Any]",
    "MarkdownParser": "fields: preprocessor, block_parser, inline_parser, html_generator",
    "LineInfo": "fields: content str, line_number int, is_blank bool, indent_level int",
    "Preprocessor": "fields: none specified",
    "NodeType": "enum: DOCUMENT, BLOCK, INLINE, TEXT",
    "BlockType": "enum: PARAGRAPH, HEADING, CODE_BLOCK, BLOCKQUOTE, HORIZONTAL_RULE, LIST, LIST_ITEM, TABLE, TABLE_HEADER, TABLE_BODY, TABLE_ROW, TABLE_CELL",
    "InlineType": "enum: STRONG, EMPHASIS, CODE, LINK, IMAGE, LINE_BREAK",
    "BlockParserState": "enum: LOOKING_FOR_BLOCK, IN_PARAGRAPH, IN_FENCED_CODE, IN_INDENTED_CODE, IN_BLOCKQUOTE",
    "DelimiterStack": "fields: stack List[Delimiter]",
    "Delimiter": "fields: delimiter_type DelimiterType, position int, can_open bool, can_close bool, is_active bool",
    "DelimiterType": "enum: ASTERISK, UNDERSCORE, BACKTICK, LEFT_BRACKET, EXCLAMATION_BRACKET",
    "EscapeProcessor": "fields: escape_pattern re.Pattern",
    "LinkImageParser": "fields: url_pattern re.Pattern, title_pattern re.Pattern",
    "ListContext": "fields: list_node BlockNode, marker_type MarkerType, base_indentation int, content_indentation int, is_ordered bool, state ListState, start_number Optional[int], item_count int, current_item Optional[BlockNode], has_blank_lines bool",
    "ListContextStack": "fields: contexts List[ListContext]",
    "ListMarkerInfo": "fields: marker_type MarkerType, is_ordered bool, marker_width int, content_indent int, start_number Optional[int]",
    "MarkerType": "enum: UNORDERED_DASH, UNORDERED_ASTERISK, UNORDERED_PLUS, ORDERED_PERIOD, ORDERED_PAREN",
    "ListState": "enum: TIGHT, LOOSE, UNDETERMINED",
    "HtmlRenderer": "fields: pretty_print bool, custom_renderers Dict, escaper HtmlEscaper, pretty_printer HtmlPrettyPrinter",
    "HtmlEscaper": "fields: content_pattern re.Pattern, attr_pattern re.Pattern",
    "HtmlPrettyPrinter": "fields: indent_size int, max_line_length Optional[int], inline_elements set, void_elements set",
    "NodeRenderer": "protocol with render method",
    "RendererPlugin": "abstract base class with get_supported_types and render_node methods",
    "PluginManager": "fields: plugins Dict, node_renderers Dict, plugin_states Dict, plugin_configs Dict, logger",
    "ErrorSeverity": "enum: WARNING, ERROR, CRITICAL",
    "ParseError": "fields: line_number int, column Optional[int], severity ErrorSeverity, error_type str, message str, original_text str, recovery_action str, suggested_fix Optional[str], context Dict[str, Any]",
    "ErrorCollector": "fields: errors List[ParseError], max_errors int, collect_warnings bool",
    "PipelineOrchestrator": "coordinates data flow between phases",
    "RecoveryStrategy": "enum: COMPLETE_BLOCK, CONVERT_TO_PARAGRAPH, PRESERVE_CONTENT, SKIP_MALFORMED",
    "BlockRecoveryContext": "fields: current_block_type Optional[BlockType], lines_in_block int, expected_closing Optional[str], fallback_strategy RecoveryStrategy",
    "DelimiterRecoveryInfo": "fields: original_position int, delimiter_char str, recovery_action str, matched_with Optional[int], converted_to_literal bool",
    "ErrorTestCase": "fields: name str, markdown_input str, expected_html str, expected_errors List[Dict[str, Any]], recovery_actions List[str], edge_case_type str",
    "ValidationError": "fields: node_id str, error_type str, description str, severity str, suggested_fix str",
    "PipelineEvent": "fields: timestamp datetime, stage str, event_type str, input_summary str, output_summary str, state_changes Dict[str, Any], performance_metrics Dict[str, float], debug_context Dict[str, Any]",
    "RegexTestCase": "fields: name str, input_text str, should_match bool, expected_groups Optional[List[str]], expected_span Optional[Tuple[int, int]], edge_case_category str",
    "PerformanceMetrics": "fields: operation_name str, execution_time float, memory_peak int, memory_current int, input_size int, complexity_factors Dict[str, int]",
    "ASTValidator": "fields: errors List, visited_nodes Set, node_ids Dict",
    "PipelineTracer": "fields: events List, detailed_tracing bool, stage_timers Dict, current_context Dict",
    "MarkdownRegexTester": "fields: test_cases List, pattern_performance Dict",
    "MarkdownParserProfiler": "fields: metrics List, memory_tracking bool, operation_counters Dict, timing_stack List",
    "RenderContext": "fields: plugin_manager, config, depth, current_list_context, html_escaper",
    "PluginState": "enum: UNLOADED, LOADING, LOADED, ACTIVE, ERROR, UNLOADING",
    "TableAlignment": "fields: left bool, right bool, center bool",
    "TableExtension": "fields: TABLE_ROW_PATTERN, DELIMITER_ROW_PATTERN",
    "TerminologyValidator": "validates code terminology consistency"
  },
  "methods": {
    "parse_to_html(markdown_text) -> str": "main parsing entry point",
    "parse_file(file_path) -> str": "file-based parsing",
    "normalize_line_endings(text) -> str": "convert line endings to Unix format",
    "split_into_lines(text) -> list": "split text preserving line numbers",
    "is_blank_line(line) -> bool": "check if line contains only whitespace",
    "get_indentation_level(line) -> int": "count leading spaces in line",
    "escape_html(text) -> str": "escape HTML special characters",
    "debug_print_ast(node, indent) -> None": "display AST structure for debugging",
    "process_input(text) -> List[LineInfo]": "process raw markdown into analyzed lines",
    "add_child(child) -> None": "add child node and set parent",
    "set_content(content) -> None": "set raw text content for block",
    "set_attribute(key, value) -> None": "set element-specific attribute",
    "get_attribute(key, default) -> Any": "get element-specific attribute",
    "depth_first_walk(node, visitor) -> None": "visit all nodes in depth-first order",
    "find_nodes_by_type(root, target_type) -> List[ASTNode]": "find all descendant nodes of specified type",
    "get_text_content(node) -> str": "extract all text from node and descendants",
    "parse_blocks(markdown_text) -> ASTNode": "main entry point for block parsing",
    "process_line_sequence(lines) -> None": "process lines through state machine",
    "peek_next_line() -> Optional[LineInfo]": "look ahead at next line without consuming",
    "can_current_block_continue(line) -> bool": "check if current block can accept line",
    "try_start_heading_block(line) -> bool": "attempt to start ATX or Setext heading",
    "try_start_code_block(line) -> bool": "attempt to start fenced or indented code block",
    "try_start_blockquote(line) -> bool": "attempt to start blockquote block",
    "try_start_horizontal_rule(line) -> bool": "attempt to create horizontal rule",
    "start_paragraph_block(line) -> None": "start new paragraph with given line",
    "continue_current_block(line) -> None": "add line to active block",
    "finalize_current_block() -> None": "complete current block and add to document",
    "parse_inline_elements(text) -> List[InlineNode]": "main entry point for parsing inline elements",
    "detect_flanking_properties(text, pos, delimiter_len) -> Tuple[bool, bool]": "detect if delimiter can open/close based on flanking rules",
    "process_escapes(text) -> Tuple[str, List[int]]": "process escape sequences and return processed text",
    "find_matching_opener(closer) -> Optional[Tuple[int, Delimiter]]": "find matching opener for given closer delimiter",
    "can_open_emphasis(char, left_flanking, right_flanking, before_char, after_char) -> bool": "determine if delimiter can open emphasis",
    "can_close_emphasis(char, left_flanking, right_flanking, before_char, after_char) -> bool": "determine if delimiter can close emphasis",
    "parse_list_sequence(lines, start_index) -> tuple[List[BlockNode], int]": "parse sequence of list items from given starting index",
    "process_line_for_lists(line) -> bool": "process single line in list parsing context",
    "handle_list_item(line, marker_info) -> None": "handle line containing list marker",
    "try_list_continuation(line) -> bool": "try to continue current list item with line",
    "create_list_context(marker_info, base_indent) -> ListContext": "create new list context for marker and indentation",
    "check_marker_compatibility(current_marker, new_marker) -> bool": "check if markers can be in same list",
    "extract_item_content(line, marker_info) -> str": "extract content after list marker",
    "finalize_all_contexts() -> List[BlockNode]": "finalize all contexts and return root nodes",
    "handle_blank_line_in_lists() -> None": "handle blank lines within list structures",
    "detect_list_marker(line) -> Optional[ListMarkerInfo]": "detect and parse list marker information",
    "can_lazy_continue(line, required_indent) -> bool": "check if line can be lazy continuation",
    "expand_tabs_to_spaces(text, tab_width) -> str": "expand tabs to spaces using tab width",
    "render_to_html(ast_root) -> str": "main HTML generation entry point",
    "render_node(node) -> str": "render single AST node to HTML",
    "render_block_node(node) -> str": "render block-level elements",
    "render_inline_node(node) -> str": "render inline elements",
    "render_text_node(node) -> str": "render plain text with escaping",
    "render_children(node) -> str": "render all child nodes",
    "generate_tag(tag_name, attributes, self_closing) -> tuple[str, str]": "create opening and closing HTML tags",
    "escape_html_attribute(value) -> str": "escape attribute values",
    "format_html(html, indent_size) -> str": "pretty print HTML output",
    "register_plugin(plugin)": "register renderer plugin",
    "register_node_renderer(node_type, renderer)": "register simple node renderer",
    "has_renderer(node_type) -> bool": "check for custom renderer",
    "render_ast_to_html(ast_root, pretty_print) -> str": "convenience function for AST to HTML conversion",
    "execute_complete_pipeline(raw_text, preprocessor, block_parser, inline_parser, html_generator) -> str": "execute complete parsing pipeline with error recovery",
    "process_block_inline_content(block_node, inline_parser) -> None": "process inline content within a single block node",
    "validate_pipeline_state(ast_root) -> List[str]": "validate AST structure before HTML generation",
    "add_error(line_number, error_type, message, original_text, recovery_action, severity, column, suggested_fix, **context)": "Add a parsing error with recovery information",
    "has_errors(min_severity) -> bool": "Check if any errors of specified severity or higher exist",
    "get_errors_by_line(line_number) -> List[ParseError]": "Get all errors that occurred on a specific line",
    "format_error_report() -> str": "Generate human-readable error report",
    "recover_incomplete_fenced_code(block_node, error_collector, line_number)": "Recover from unclosed fenced code block at end of document",
    "recover_malformed_atx_heading(line, line_number, error_collector) -> BlockNode": "Recover from invalid ATX heading syntax by converting to paragraph",
    "recover_inconsistent_blockquote(lines, line_numbers, error_collector) -> BlockNode": "Recover from blockquote with inconsistent > prefixes",
    "recover_unmatched_delimiters(delimiter_stack, text, error_collector) -> List[DelimiterRecoveryInfo]": "Recover from unmatched emphasis delimiters in delimiter stack",
    "handle_intraword_underscore_conflict(text, start_pos, end_pos, error_collector) -> str": "Handle underscore emphasis that would violate intraword rules",
    "recover_broken_link_syntax(text, bracket_pos, error_collector) -> Tuple[str, bool]": "Recover from malformed link syntax by treating as literal text",
    "normalize_edge_case_whitespace(text, preserve_semantic_breaks) -> Tuple[str, List[str]]": "Normalize whitespace while handling edge cases consistently",
    "detect_emphasis_precedence_conflict(delimiters) -> List[Tuple[int, int, str]]": "Detect potential emphasis delimiter precedence conflicts",
    "handle_list_marker_inconsistency(current_marker, new_marker, context) -> Tuple[bool, str]": "Handle inconsistent list markers according to CommonMark rules",
    "create_error_test_cases() -> List[ErrorTestCase]": "Create comprehensive test cases for error handling scenarios",
    "validate_tree(root) -> List[ValidationError]": "perform comprehensive AST validation",
    "check_parent_child_consistency(node) -> None": "verify bidirectional parent-child relationships",
    "find_parsing_divergence(expected_ast, actual_ast) -> List[str]": "compare AST structures and identify differences",
    "trace_stage_entry(stage_name, input_data, initial_state) -> None": "record entry into parsing stage",
    "trace_state_change(stage_name, change_description, old_state, new_state, triggering_input) -> None": "record significant state changes during parsing",
    "generate_execution_report() -> str": "generate comprehensive pipeline execution report",
    "test_pattern_comprehensive(pattern, pattern_name) -> Dict[str, Any]": "test regex pattern against comprehensive edge cases",
    "create_emphasis_edge_cases() -> List[RegexTestCase]": "create comprehensive edge cases for emphasis delimiter testing",
    "create_list_marker_edge_cases() -> List[RegexTestCase]": "create comprehensive edge cases for list marker detection",
    "profile_parsing_operation(operation_name, operation_func, input_data, complexity_factors) -> Any": "profile parsing operation with comprehensive performance measurement",
    "generate_performance_report(min_operation_time) -> str": "generate comprehensive performance analysis report",
    "create_performance_test_suite() -> List[Tuple[str, str, Dict[str, int]]]": "create systematic performance test cases with varying complexity",
    "register_plugin(name, plugin, config) -> bool": "register renderer plugin with manager",
    "get_renderer(node_type) -> Optional[RendererPlugin]": "get best renderer for node type",
    "render_with_fallback(node, context) -> str": "render node with automatic fallback",
    "escape_for_format(text, format_type) -> str": "escape text for output format",
    "get_supported_types() -> List[str]": "return supported NodeType values",
    "render_node(node, context) -> str": "render AST node to output format",
    "initialize(config) -> bool": "initialize plugin with configuration",
    "finalize() -> None": "clean up plugin resources",
    "can_start_table(current_line, next_line) -> bool": "determine if lines start table",
    "parse_table_block(lines, start_index) -> Tuple[BlockNode, int]": "parse complete table block",
    "parse_table_row(line, expected_columns) -> List[str]": "parse single table row",
    "extract_alignments(delimiter_line) -> List[TableAlignment]": "extract column alignments",
    "from_delimiter(delimiter) -> TableAlignment": "parse alignment from delimiter cell",
    "validate_variable_names(source_code) -> List[str]": "validate variable names use standard terminology",
    "validate_ast_terminology(root) -> List[ValidationError]": "validate AST structure uses standard terminology",
    "generate_terminology_report(codebase_path) -> str": "generate report on terminology usage consistency"
  },
  "constants": {
    "HTML_ESCAPE_TABLE": "mapping of characters to HTML entities",
    "ATX_HEADING_PATTERN": "regex for # style headings",
    "SETEXT_H1_UNDERLINE": "regex for === underlines",
    "SETEXT_H2_UNDERLINE": "regex for --- underlines",
    "FENCED_CODE_START": "regex for opening code fences",
    "FENCED_CODE_END": "regex for closing code fences",
    "HORIZONTAL_RULE_PATTERN": "regex for horizontal rules",
    "BLOCKQUOTE_PATTERN": "regex for blockquote lines",
    "ESCAPABLE_CHARS": "characters that can be escaped in CommonMark",
    "UNORDERED_MARKER_PATTERN": "regex for unordered list markers",
    "ORDERED_MARKER_PATTERN": "regex for ordered list markers",
    "ATTRIBUTE_ESCAPE_TABLE": "mapping for attribute value escaping",
    "VOID_ELEMENTS": "set of self-closing HTML element names",
    "MIXED_LINE_ENDING_PATTERN": "regex for detecting mixed line endings",
    "TRAILING_WHITESPACE_PATTERN": "regex for detecting trailing whitespace",
    "UNICODE_WHITESPACE_PATTERN": "regex for detecting Unicode whitespace characters",
    "EMPHASIS_DELIMITER_CHARS": "characters that can be emphasis delimiters",
    "LIST_MARKER_PATTERNS": "regex patterns for list marker detection",
    "TABLE_ROW_PATTERN": "regex for table row recognition",
    "DELIMITER_ROW_PATTERN": "regex for table delimiter row",
    "PluginState": "enum values for plugin lifecycle"
  },
  "terms": {
    "two-phase parsing": "block parsing followed by inline parsing approach",
    "AST": "Abstract Syntax Tree representing parsed document structure",
    "block-level elements": "structural elements like paragraphs, headings, lists",
    "inline elements": "formatting elements like emphasis, links, code spans",
    "CommonMark": "standardized markdown specification",
    "graceful degradation": "handling plugin failures without system crashes",
    "delimiter matching": "finding pairs of formatting markers like ** for bold",
    "context-dependent parsing": "parsing rules that depend on surrounding content",
    "pipeline architecture": "unidirectional data flow through transformation stages",
    "component isolation": "clear separation between parsing logic components",
    "state machine": "parser that transitions between states based on input",
    "lookahead": "examining future input without consuming it",
    "Setext headings": "underline-style headings with === or --- markers",
    "ATX headings": "hash-prefix style headings with # markers",
    "lazy continuation": "continuing blocks without required prefix markers in certain contexts",
    "delimiter stack": "data structure for tracking nested formatting delimiters",
    "flanking detection": "algorithm for determining when characters can act as delimiters",
    "emphasis delimiter precedence": "rules for matching competing emphasis delimiters",
    "intraword underscore": "underscore within word that shouldn't trigger emphasis formatting",
    "depth-first traversal": "tree traversal pattern visiting children before siblings",
    "HTML entity escaping": "converting special characters to HTML entities for safety",
    "self-closing tags": "HTML elements that don't have closing tags like hr and img",
    "pretty printing": "formatting HTML output with indentation and line breaks",
    "visitor pattern": "design pattern for traversing and operating on tree structures",
    "double-escaping": "applying HTML escaping multiple times to the same content",
    "plugin interface": "extensibility mechanism for custom rendering behavior",
    "void elements": "HTML5 elements that cannot have content or closing tags",
    "semantic whitespace": "spaces and line breaks that affect content meaning and display",
    "attribute value escaping": "special escaping rules for HTML attribute content",
    "parser error recovery": "strategies for handling invalid markdown syntax and continuing parsing",
    "edge case handling": "consistent behavior for ambiguous input patterns",
    "continuation-based recovery": "recovery approach where errors in one block don't prevent parsing subsequent blocks",
    "delimiter balancing recovery": "recovery approach for mismatched or ambiguous formatting markers",
    "semantic whitespace preservation": "preserving whitespace that affects document meaning while normalizing insignificant whitespace",
    "delimiter precedence conflicts": "situations where multiple emphasis markers compete for same text spans",
    "state machine debugging": "systematic debugging approach for parser state transitions",
    "pipeline stage isolation": "debugging technique isolating individual parsing components",
    "delimiter balance and nesting debugging": "specialized debugging for inline formatting delimiter matching",
    "tree structure validation": "comprehensive checking of AST parent-child relationships",
    "performance debugging": "specialized debugging focused on algorithmic complexity and resource usage",
    "whitespace and character encoding issues": "debugging invisible characters and encoding problems",
    "context dependency debugging": "debugging context-dependent parsing rules and behaviors",
    "plugin architecture": "extensibility system for custom functionality",
    "extension points": "defined integration points for plugins",
    "compositional extensions": "extensions through composition rather than inheritance",
    "renderer plugins": "plugins that generate custom output formats",
    "plugin lifecycle": "managed states for plugin loading and cleanup",
    "CommonMark extensions": "standardized extensions to CommonMark specification",
    "verbatim content blocks": "regions preserving exact content without markdown parsing",
    "extension integration strategy": "approach for adding functionality without core modifications",
    "plugin manager": "component coordinating plugin registration and execution",
    "Abstract Syntax Tree (AST)": "hierarchical tree data structure representing parsed document structure"
  }
}