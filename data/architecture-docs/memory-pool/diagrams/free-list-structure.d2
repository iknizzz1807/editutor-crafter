title: Free List Data Structure {
  style.font-size: 20
  style.bold: true
  style.font-color: "#e6edf3"
  near: top-center
}

classes: {
  memory_block: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  free_block: {
    style.fill: "#0f3460"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  allocated_block: {
    style.fill: "#d63031"
    style.stroke: "#e17055"
    style.font-color: "#ffffff"
  }
  pointer: {
    style.stroke: "#ffeaa7"
    style.stroke-width: 3
  }
  metadata: {
    style.fill: "#16213e"
    style.stroke: "#74b9ff"
    style.font-color: "#e6edf3"
  }
}

pool: Pool Descriptor {
  class: metadata
  + "block_size: size_t"
  + "total_blocks: size_t" 
  + "free_count: size_t"
  + "free_head: void*"
  shape: class
}

memory_area: Memory Pool Area {
  class: memory_block
  
  block1: Block 1 (FREE) {
    class: free_block
    header1: Block Header {
      + "magic: 0xDEADBEEF"
      + "status: FREE"
      shape: class
      class: metadata
    }
    data1: Data Area {
      next_ptr: "next -> Block 3*" {
        class: free_block
        style.italic: true
      }
      unused: "unused bytes..." {
        style.font-color: "#636e72"
        style.italic: true
      }
    }
  }
  
  block2: Block 2 (ALLOCATED) {
    class: allocated_block
    header2: Block Header {
      + "magic: 0xDEADBEEF"
      + "status: ALLOCATED"
      shape: class
      class: metadata
    }
    data2: User Data {
      user_data: "application data" {
        style.font-color: "#ffffff"
      }
    }
  }
  
  block3: Block 3 (FREE) {
    class: free_block
    header3: Block Header {
      + "magic: 0xDEADBEEF"
      + "status: FREE"
      shape: class
      class: metadata
    }
    data3: Data Area {
      next_ptr3: "next -> Block 5*" {
        class: free_block
        style.italic: true
      }
      unused3: "unused bytes..." {
        style.font-color: "#636e72"
        style.italic: true
      }
    }
  }
  
  block4: Block 4 (ALLOCATED) {
    class: allocated_block
    header4: Block Header {
      + "magic: 0xDEADBEEF"
      + "status: ALLOCATED"
      shape: class
      class: metadata
    }
    data4: User Data {
      user_data4: "application data" {
        style.font-color: "#ffffff"
      }
    }
  }
  
  block5: Block 5 (FREE) {
    class: free_block
    header5: Block Header {
      + "magic: 0xDEADBEEF"
      + "status: FREE"
      shape: class
      class: metadata
    }
    data5: Data Area {
      next_ptr5: "next -> NULL" {
        class: free_block
        style.italic: true
      }
      unused5: "unused bytes..." {
        style.font-color: "#636e72"
        style.italic: true
      }
    }
  }
}

operations: Free List Operations {
  class: metadata
  
  allocate: "allocate() -> O(1)" {
    + "1. result = free_head"
    + "2. free_head = *((void**)free_head)"
    + "3. mark block as ALLOCATED"
    + "4. return result"
    shape: class
    class: free_block
  }
  
  deallocate: "deallocate(ptr) -> O(1)" {
    + "1. mark block as FREE"
    + "2. *((void**)ptr) = free_head"
    + "3. free_head = ptr"
    + "4. increment free_count"
    shape: class
    class: free_block
  }
}

aliasing_note: |md
  **Key Concept**: Free blocks reuse their data area
  to store the next pointer, eliminating separate
  metadata storage overhead.
  
  **Requirements**:
  - block_size >= sizeof(void*)
  - Proper alignment for pointer storage
  - Thread-safe pointer updates
| {
  shape: page
  class: metadata
  near: bottom-left
}

null_marker: {
  shape: circle
  style.fill: "#636e72"
  style.stroke: "#636e72"
  label: "âˆ…"
}

pool -> memory_area.block1: free_head points to {
  class: pointer
}

memory_area.block1.data1.next_ptr -> memory_area.block3: threads to {
  class: pointer
}

memory_area.block3.data3.next_ptr3 -> memory_area.block5: threads to {
  class: pointer
}

memory_area.block5.data5.next_ptr5 -> null_marker: NULL (end of list) {
  class: pointer
}