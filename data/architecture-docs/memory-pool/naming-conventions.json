{
  "types": {
    "memory_pool_t": "fields: chunk_list chunk_header_t*, free_list void*, block_size size_t, stats pool_stats_t",
    "pool_stats_t": "fields: total_blocks size_t, allocated_blocks size_t, peak_allocated size_t, allocation_count size_t, free_count size_t, chunk_count size_t",
    "chunk_header_t": "fields: next_chunk chunk_header_t*, block_count size_t, base_address void*",
    "threadsafe_memory_pool_t": "fields: chunk_list chunk_header_t*, free_list void*, block_size size_t, stats pool_stats_t, thread_mode pool_thread_mode_t, pool_mutex pthread_mutex_t, thread_count size_t, thread_pools memory_pool_t*",
    "pool_thread_mode_t": "enum: POOL_THREAD_UNSAFE, POOL_THREAD_MUTEX, POOL_THREAD_PER_THREAD",
    "deferred_free_node_t": "fields: block void*, origin_thread_id size_t, next struct deferred_free_node*",
    "thread_test_data_t": "fields: pool threadsafe_memory_pool_t*, thread_id int, allocated_blocks void**",
    "pool_debug_config_t": "fields: enable_poisoning int, enable_double_free_detection int, enable_statistics int, enable_performance_monitoring int",
    "pool_debug_stats_t": "fields: extends pool_stats_t with poison_violations, double_free_attempts, corruption_detected, performance metrics",
    "bitmap_t": "fields: bits uint32_t*, bit_count size_t, word_count size_t",
    "timer_t": "fields: start_time struct timespec",
    "flow_context_t": "fields: pool memory_pool_t*, operation_start_ns uint64_t, blocks_before size_t, chunks_before size_t, last_error flow_result_t",
    "flow_error_context_t": "fields: error_code flow_result_t, operation_name const char*, failing_address void*, context_value size_t, file const char*, line int",
    "flow_result_t": "enum: FLOW_SUCCESS, FLOW_ERROR_NULL_PARAM, FLOW_ERROR_LIMIT_EXCEEDED, FLOW_ERROR_ALLOCATION_FAILED, FLOW_ERROR_CORRUPTION_DETECTED",
    "test_results_t": "fields: tests_run int, tests_passed int, tests_failed int, last_failure char[256]",
    "test_case_t": "fields: name const char*, function test_function_t",
    "variable_pool_manager_t": "fields: size_classes memory_pool_t*, class_count size_t, min_size size_t, max_size size_t, class_stats pool_stats_t*",
    "persistent_memory_pool_t": "fields: mapped_region void*, mapped_size size_t, file_descriptor int, filename char*, magic_number uint64_t",
    "advanced_pool_monitor_t": "fields: detailed_stats pool_stats_t*, allocation_histogram uint64_t*, timing_samples uint64_t*, sample_count size_t, stats_mutex pthread_mutex_t",
    "offset_t": "file offset type for persistent addressing"
  },
  "methods": {
    "pool_init(pool, block_size, initial_blocks) returns int": "initializes pool with specified parameters",
    "pool_alloc(pool) returns void*": "allocates block from free list in O(1) time",
    "pool_free(pool, block) returns void": "returns block to free list in O(1) time",
    "align_size(size, alignment) returns size_t": "rounds up size to alignment boundary",
    "is_aligned(ptr, alignment) returns int": "checks if pointer meets alignment requirements",
    "record_allocation(stats)": "atomically updates allocation statistics",
    "init_stats(stats)": "initializes statistics structure",
    "pool_destroy(pool) returns void": "frees all chunks and resets pool",
    "init_free_list(pool, chunk_start, chunk_size, block_size, block_count) returns int": "threads blocks into free list",
    "allocate_new_chunk(pool) returns int": "orchestrates new chunk allocation and integration",
    "create_chunk(block_size, block_count) returns chunk_header_t*": "allocates and initializes chunk memory",
    "check_growth_limits(pool) returns int": "verifies resource limits before growth",
    "link_chunk_to_pool(pool, chunk) returns int": "adds chunk to pool's chunk list",
    "calculate_chunk_memory_footprint(block_size, block_count) returns size_t": "computes total memory for chunk",
    "update_growth_statistics(pool, blocks_added) returns void": "updates pool stats after growth",
    "record_allocation(stats) returns void": "updates allocation counters",
    "init_stats(stats) returns void": "initializes statistics structure",
    "pool_init_threadsafe(pool, block_size, initial_blocks, mode) returns int": "initializes thread-safe pool with specified synchronization mode",
    "pool_alloc_threadsafe(pool) returns void*": "thread-safe block allocation using configured synchronization strategy",
    "pool_free_threadsafe(pool, block) returns void": "thread-safe block deallocation with cross-thread support",
    "get_thread_local_pool(parent) returns memory_pool_t*": "retrieves or creates thread-local pool instance",
    "defer_cross_thread_free(block, origin_thread_id) returns void": "handles freeing blocks allocated by different threads",
    "process_deferred_frees(pool) returns void": "batch processes cross-thread freed blocks",
    "pool_debug_init(pool, config) returns int": "initialize debugging features for memory pool",
    "pool_debug_poison_block(block, block_size, is_allocation) returns void": "fill block with poison pattern",
    "pool_debug_verify_poison(block, block_size) returns int": "check poison pattern integrity",
    "pool_debug_check_double_free(pool, block) returns int": "detect double-free attempts using bitmap",
    "pool_debug_update_stats(stats, is_allocation, operation_time_ns) returns void": "atomically update statistics counters",
    "pool_debug_report_violation(violation_type, block, details) returns void": "report debugging violations with context",
    "pool_alloc_debug(pool) returns void*": "allocation with debugging instrumentation",
    "pool_free_debug(pool, block) returns void": "deallocation with debugging checks",
    "bitmap_init(bitmap, bit_count) returns int": "initialize bitmap for block tracking",
    "bitmap_set(bitmap, index) returns void": "set bit for allocated block",
    "bitmap_clear(bitmap, index) returns void": "clear bit for freed block",
    "bitmap_test(bitmap, index) returns int": "test block allocation state",
    "timer_start(timer) returns void": "begin high-resolution timing",
    "timer_end_ns(timer) returns uint64_t": "end timing and return nanoseconds elapsed",
    "flow_context_init(ctx, pool) returns void": "initialize flow context for operation",
    "flow_validate_pool_state(pool) returns int": "validates pool structure integrity",
    "flow_check_corruption_indicators(pool) returns int": "detects pool corruption signs",
    "pool_alloc_with_error_handling(pool) returns void*": "allocation with comprehensive error handling and recovery",
    "pool_free_with_corruption_detection(pool, block) returns void": "deallocation with corruption detection and double-free prevention",
    "pool_validate_integrity(pool) returns int": "comprehensive pool consistency validation",
    "pool_cleanup_after_error(pool, error_type) returns int": "resource cleanup and recovery after error conditions",
    "flow_set_error(code, operation, address, value, file, line) returns void": "detailed error context recording",
    "pool_get_last_error() returns flow_error_context_t*": "retrieve last error information",
    "retry_with_backoff(operation, context, max_retries, base_delay_ms) returns int": "retry logic with exponential backoff",
    "verify_poison_pattern(block, size, expected_pattern) returns int": "check poison pattern integrity",
    "verify_alignment(ptr, alignment) returns int": "check alignment requirements",
    "count_free_list_blocks(free_list_head) returns int": "count blocks in free list",
    "run_test_suite(suite_name, tests, test_count) returns void": "execute test suite with reporting",
    "print_test_summary() returns void": "display test execution summary",
    "variable_pool_init(manager, min_size, max_size, initial_blocks) returns int": "initialize variable size pool with size classes",
    "variable_pool_alloc(manager, requested_size) returns void*": "allocate from appropriate size class",
    "persistent_pool_init(pool, filename, pool_size, block_size) returns int": "initialize memory-mapped persistent pool",
    "persistent_pool_sync(pool, sync_mode) returns int": "synchronize changes to storage",
    "monitor_init(monitor, enable_timing, enable_patterns, enable_leak_detection) returns int": "initialize advanced monitoring",
    "monitor_record_allocation(monitor, requested_size, allocated_size, allocation_time_ns, block_address) returns void": "record allocation event with monitoring data"
  },
  "constants": {
    "MIN_ALIGNMENT": "sizeof(void*) minimum alignment requirement",
    "WORD_SIZE": "sizeof(void*) platform word size",
    "DEADBEEF_PATTERN": "0xDEADBEEF sentinel value for freed blocks",
    "ALLOCATION_PATTERN": "0xABADCAFE sentinel value for allocated blocks",
    "MAX_CHUNKS": "maximum number of chunks per pool",
    "MAX_BLOCKS": "maximum total blocks across all chunks",
    "MAX_MEMORY_BYTES": "maximum memory footprint limit",
    "NUM_THREADS": "8 test thread count",
    "ALLOCATIONS_PER_THREAD": "1000 allocations per test thread",
    "__thread": "GCC/Clang thread-local storage specifier",
    "POOL_THREAD_UNSAFE": "0 no synchronization mode",
    "POOL_THREAD_MUTEX": "1 mutex-protected shared pool mode",
    "POOL_THREAD_PER_THREAD": "2 per-thread isolated pools mode",
    "BLOCKS_PER_CHUNK": "standard number of blocks per chunk",
    "FLOW_SUCCESS": "0 successful operation result",
    "FLOW_ERROR_NULL_PARAM": "-1 null parameter error",
    "FLOW_ERROR_LIMIT_EXCEEDED": "-2 resource limit exceeded",
    "FLOW_ERROR_ALLOCATION_FAILED": "-3 memory allocation failed",
    "FLOW_ERROR_CORRUPTION_DETECTED": "-4 data corruption detected",
    "MIN_SIZE_CLASS": "minimum allocation size class",
    "MAX_SIZE_CLASS": "maximum allocation size class",
    "POWER_OF_TWO_CLASSES": "size class organization strategy",
    "MS_ASYNC": "asynchronous memory sync mode",
    "MS_SYNC": "synchronous memory sync mode",
    "MAP_SHARED": "shared memory mapping mode"
  },
  "terms": {
    "free list": "singly-linked list threading through unused blocks",
    "chunk": "contiguous memory region divided into fixed-size blocks",
    "block": "fixed-size allocation unit within chunk",
    "memory pool": "pre-allocated collection of fixed-size blocks",
    "external fragmentation": "unusable free space between allocations",
    "internal fragmentation": "wasted space within allocated blocks",
    "pointer aliasing": "using block data area to store next pointer in free list",
    "memory poisoning": "filling blocks with sentinel patterns to detect use-after-free",
    "chunk list": "linked list of chunk headers for administration",
    "unified free list": "single free list spanning multiple chunks",
    "pool growth": "dynamic allocation of additional chunks",
    "resource limits": "bounds on chunk count, block count, or memory usage",
    "chunk header": "metadata structure at beginning of each chunk",
    "uniform chunk sizing": "all chunks contain same number of blocks",
    "critical section": "code region requiring exclusive access to shared data",
    "mutex protection": "using mutexes to serialize access to shared resources",
    "per-thread pools": "thread-local memory pools to eliminate contention",
    "lock-free": "synchronization without blocking using atomic operations",
    "deferred freeing": "batched processing of cross-thread block returns",
    "thread-local storage": "per-thread data storage mechanism",
    "contention": "multiple threads competing for the same resource",
    "false sharing": "cache line interference between independent data",
    "ownership transfer": "mechanism for handling blocks allocated by one thread and freed by another",
    "double-free detection": "preventing same block from being freed multiple times",
    "use-after-free": "accessing memory after it has been freed",
    "poison pattern": "distinctive bit pattern used to detect unauthorized memory access",
    "sentinel value": "recognizable data pattern indicating special memory state",
    "block state bitmap": "bit array tracking allocated/free status of each block",
    "atomic counters": "thread-safe statistics using atomic operations",
    "defensive programming": "designing code to detect and handle client errors gracefully",
    "memory corruption": "unauthorized modification of memory pool data structures",
    "statistics aggregation": "combining per-chunk metrics into pool-level summaries",
    "allocation operation flow": "step-by-step sequence from alloc request to block return",
    "pool growth operation flow": "how chunk allocation integrates with ongoing allocations",
    "pool destruction flow": "cleanup sequence ensuring all chunks and resources are freed",
    "fast path": "common case allocation when free list has available blocks",
    "slow path": "allocation requiring pool growth when free list is empty",
    "chunk list traversal": "walking through linked list of chunk headers during cleanup",
    "flow context": "operation state tracking for monitoring and debugging",
    "chunk integration": "process of linking new chunk into existing pool structure",
    "atomic integration": "thread-safe linking of new chunks into pool structure",
    "allocation failure": "condition when memory request cannot be satisfied",
    "graceful degradation": "reducing functionality while maintaining operation during resource pressure",
    "corruption detection": "mechanisms to identify when pool data structures have been compromised",
    "resource cleanup": "process of freeing all allocated resources during error recovery",
    "transactional rollback": "restoring pool to previous consistent state after operation failure",
    "invariant validation": "checking that data structures maintain expected properties",
    "sentinel value monitoring": "using distinctive patterns to detect memory access violations",
    "error propagation": "how error information flows through system layers",
    "size classes": "discrete categories for different allocation sizes",
    "buddy allocation": "recursive subdivision memory management system",
    "memory mapping": "mapping files into process address space",
    "offset-based addressing": "file offsets instead of memory pointers for persistence",
    "allocation pattern analysis": "studying allocation behavior over time and space",
    "heat mapping": "visual representation of allocation activity",
    "leak detection": "identifying memory that is allocated but not freed",
    "synchronization policies": "strategies for when to persist in-memory changes",
    "inter-process sharing": "multiple processes accessing same memory pool",
    "power-of-two size classes": "size classes organized as powers of two",
    "coalescing": "merging adjacent free blocks",
    "splitting": "dividing large blocks for smaller requests"
  }
}