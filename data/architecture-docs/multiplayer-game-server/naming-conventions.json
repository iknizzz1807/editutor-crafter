{
  "types": {
    "Message": "ID uint32, Type MessageType, Payload interface{}, Reliable bool, Timestamp time.Time",
    "Transport": "conn *net.UDPConn, clients map[string]*ClientConnection, messageHandlers map[MessageType]MessageHandler",
    "ClientConnection": "Address *net.UDPAddr, LastSeen time.Time, SequenceNumber uint32, AckNumber uint32, PendingMessages map[uint32]*Message, RTT time.Duration",
    "GameLoop": "tickRate int, tickDuration time.Duration, accumulator time.Duration, currentTime time.Time",
    "World": "entities map[EntityID]*Entity, tick uint64, lastUpdate time.Time",
    "Entity": "ID EntityID, Position Vector2, Velocity Vector2",
    "EntityID": "unique identifier for entities",
    "Vector2": "X float64, Y float64",
    "WorldSnapshot": "Entities map[EntityID]*Entity, Tick uint64, Time time.Time",
    "MessageType": "string enum for message types",
    "InputCommand": "SequenceNumber uint32, Timestamp time.Time, Commands []string, Values map[string]float64",
    "PredictionEngine": "localState *Entity, inputBuffer *CircularBuffer, nextSequence uint32, lastAckedSeq uint32, reconcileThreshold float64",
    "VisualSmoother": "isSmoothing bool, startPos Vector2, targetPos Vector2, startTime time.Time, duration time.Duration, interpFunc InterpolationFunc",
    "StateReconciler": "predictionEngine *PredictionEngine, visualSmoother *VisualSmoother",
    "CircularBuffer": "items []InputCommand, head int, size int, capacity int",
    "InterpolationFunc": "func(start, end, progress float64) float64",
    "HistoryBuffer": "snapshots []WorldSnapshot, head int, size int, capacity int, maxAge time.Duration, mutex sync.RWMutex",
    "LatencyTracker": "smoothedRTT time.Duration, lastPingTime time.Time, smoothingAlpha float64, measurements []time.Duration, mutex sync.RWMutex",
    "LagCompensator": "historyBuffer *HistoryBuffer, latencyTrackers map, maxRewindTime time.Duration, world *World",
    "TimeSync": "clockOffset time.Duration, offsetHistory []time.Duration, lastSyncTime time.Time, adjustmentRate time.Duration",
    "CombatAction": "client combat action data",
    "CombatResult": "hit validation result",
    "ShotAction": "projectile combat action",
    "DeltaEncoder": "clientBaselines map, compressionConfig *CompressionConfig, mutex sync.RWMutex",
    "BandwidthTracker": "clientID string, rttSamples []time.Duration, packetLosses int, totalPackets int, estimatedBandwidth float64, lastUpdate time.Time, mutex sync.RWMutex",
    "SpatialIndex": "cellSize float64, cells map[CellID]map[EntityID]*Entity, entities map[EntityID]CellID, mutex sync.RWMutex",
    "CellID": "X int, Y int",
    "InterestCalculator": "spatialIndex *SpatialIndex, interestConfig *InterestConfig",
    "PriorityScheduler": "clientTrackers map[string]*BandwidthTracker, priorityQueues map[string]*PriorityQueue, stalenessTrackers map[string]map[EntityID]*StalenessTracker",
    "AdaptiveRateLimiter": "clientLimits map[string]*ClientLimits, congestionDetector *CongestionDetector",
    "FieldChange": "EntityID uint32, FieldID uint8, ValueType uint8, Value []byte",
    "ConnectionHealthMonitor": "clients map[string]*ClientHealthMetrics, timeoutThresholds map[string]time.Duration, mutex sync.RWMutex, alertCallback func(string, HealthEvent)",
    "ClientHealthMetrics": "ClientID string, LastSeen time.Time, ConsecutiveMissed int, RTTHistory []time.Duration, PacketLossRate float64, ReconnectionCount int, ConnectionQuality float64, GracePeriodExpiry time.Time",
    "HealthEvent": "string enum for connection events",
    "DesyncDetector": "world *World, tolerances ValidationTolerances, checksumFrequency time.Duration, lastChecksumTick uint64, clientChecksums map[string]StateChecksum",
    "ValidationTolerances": "PositionTolerance float64, VelocityTolerance float64, SequenceTolerance uint32, ChecksumMismatchMax int",
    "StateChecksum": "Tick uint64, Hash [32]byte, Computed time.Time",
    "ValidationResult": "ClientID string, ValidationOK bool, ErrorType ValidationError, Severity ErrorSeverity, Details string",
    "AntiCheatValidator": "rateLimit *RateLimiter, movementValidator *MovementValidator, patternAnalyzer *BehaviorAnalyzer, responseEscalator *ResponseEscalator",
    "RateLimiter": "clientBuckets map[string]*TokenBucket, windowLimits map[time.Duration]int",
    "TokenBucket": "tokens int, maxTokens int, refillRate float64, lastRefill time.Time, violationLog *list.List",
    "MovementValidator": "speedLimits map[string]float64, accelerationMax float64, collisionChecker CollisionChecker",
    "BehaviorAnalyzer": "playerProfiles map[string]*PlayerBehaviorProfile, detectionRules []BehaviorDetectionRule, statisticsEngine *StatisticalAnalyzer, alertQueue chan *CheatAlert, mutex sync.RWMutex",
    "PlayerProfile": "ReactionTimes []time.Duration, AccuracyHistory []float64, MovementPatterns []MovementSignature, CreatedAt time.Time, UpdatedAt time.Time",
    "TestClock": "currentTime time.Time, autoAdvance bool, tickDuration time.Duration",
    "NetworkSimulator": "latency time.Duration, jitter time.Duration, packetLoss float64, bandwidth int, messageQueue chan",
    "DelayedMessage": "Message []byte, DeliverAt time.Time, Dropped bool",
    "TimingMonitor": "targetInterval time.Duration, tolerancePercent float64, measurements []time.Duration, maxSamples int, mutex sync.RWMutex, violationCount int, lastViolation time.Time",
    "NetworkDiagnostics": "clients map[string]*ClientNetworkStats, mutex sync.RWMutex, packetLossThreshold float64, latencyThreshold time.Duration",
    "ClientNetworkStats": "ClientID string, PacketsSent int, PacketsReceived int, PacketLossRate float64, SmoothedRTT time.Duration, RTTVariance time.Duration, LastUpdate time.Time, ConsecutiveTimeouts int",
    "StateValidator": "predictionErrors []PredictionError, maxErrors int, mutex sync.RWMutex, errorStats map[string]int",
    "PredictionError": "ClientID string, Timestamp time.Time, PredictedPos Vector2, AuthorativePos Vector2, ErrorMagnitude float64, SequenceNumber uint32, ReconcileAction string",
    "DebugServer": "timingMonitor *TimingMonitor, networkDiags *NetworkDiagnostics, stateValidator *StateValidator, server *http.Server",
    "TimingStats": "SampleCount int, Average time.Duration, Minimum time.Duration, Maximum time.Duration, Target time.Duration, ViolationCount int, LastViolation time.Time",
    "ServerInfo": "ID string, Address string, Port int, ServerType, Region *RegionBounds, LoadMetrics *LoadMetrics, LastSeen time.Time, Status ServerStatus",
    "ServerRegistry": "servers map[string]*ServerInfo, mutex sync.RWMutex, healthCheck chan string, callbacks map[ServerStatus][]func(*ServerInfo)",
    "RegionManager": "regions map[RegionID]*RegionInfo, boundaries *SpatialIndex, handoffQueue chan *HandoffRequest, activeHandoffs map[string]*HandoffState, mutex sync.RWMutex",
    "HandoffRequest": "PlayerID string, CurrentRegion RegionID, TargetRegion RegionID, PlayerState *PlayerTransferState, InitiatedAt time.Time, CompletedAt *time.Time",
    "PlayerBehaviorProfile": "PlayerID string, ReactionTimes *StatisticalDistribution, AccuracyMetrics *AccuracyProfiler, MovementPatterns *MovementAnalyzer, SuspicionScore float64, ProfileConfidence float64, LastUpdated time.Time",
    "ObjectPool": "pools map[reflect.Type]*TypedPool, metrics *PoolMetrics, mutex sync.RWMutex",
    "TypedPool": "objectType reflect.Type, available chan interface{}, resetFunc func(interface{}), createFunc func() interface{}, totalCreated int64, totalReused int64",
    "RegionID": "unique identifier for spatial regions",
    "RegionBounds": "spatial boundary definition",
    "LoadMetrics": "server performance measurements",
    "ServerType": "enum for server specialization",
    "ServerStatus": "enum for server health status",
    "PlayerTransferState": "complete player state for handoffs",
    "HandoffState": "tracking information for active transfers",
    "BehaviorDetectionRule": "pattern matching rule definition",
    "StatisticalAnalyzer": "behavioral statistics processor",
    "CheatAlert": "suspicious behavior notification",
    "PlayerAction": "player input action data",
    "SuspicionAssessment": "behavioral analysis result",
    "StatisticalDistribution": "behavioral metric distribution",
    "AccuracyProfiler": "accuracy pattern analyzer",
    "MovementAnalyzer": "movement pattern detector",
    "PoolMetrics": "object pool performance data"
  },
  "methods": {
    "NewTransport(listenAddr string) (*Transport, error)": "creates UDP transport",
    "RegisterHandler(msgType MessageType, handler MessageHandler)": "registers message handler",
    "SendMessage(clientAddr *net.UDPAddr, message *Message) error": "sends message to client",
    "NewGameLoop(tickRate int) *GameLoop": "creates fixed timestep loop",
    "Start() error": "starts game loop execution",
    "Update(deltaTime time.Duration) error": "advances world state one tick",
    "AddEntity(entity *Entity) EntityID": "adds entity to world",
    "CreateSnapshot() *WorldSnapshot": "captures current world state",
    "ProcessLocalInput(commands []string, values map[string]float64) *InputCommand": "applies player input immediately",
    "ReconcileWithServer(serverSnapshot *WorldSnapshot, ackedSequence uint32) bool": "corrects client predictions",
    "StartCorrection(from, to Vector2)": "begins smooth transition",
    "Update() Vector2": "advances smoothing interpolation",
    "HandleServerUpdate(snapshot *WorldSnapshot, ackedSeq uint32)": "processes authoritative state and applies corrections",
    "Add(item InputCommand)": "adds input to circular buffer",
    "GetFromSequence(seq uint32) []InputCommand": "retrieves inputs from sequence",
    "NewHistoryBuffer(capacity int, maxAge time.Duration) *HistoryBuffer": "creates historical state buffer",
    "AddSnapshot(snapshot WorldSnapshot)": "stores new game state snapshot",
    "GetSnapshot(timestamp time.Time) (*WorldSnapshot, error)": "retrieves historical state with interpolation",
    "NewLatencyTracker() *LatencyTracker": "creates RTT measurement tracker",
    "RecordRTT(rtt time.Duration)": "records round-trip time measurement",
    "GetEstimatedLatency() time.Duration": "returns one-way latency estimate",
    "ProcessCombatAction(clientID string, action CombatAction, receivedAt time.Time) (*CombatResult, error)": "validates combat action with lag compensation",
    "ValidateHitGeometry(shot ShotAction, historicalState *WorldSnapshot) bool": "checks hit against historical positions",
    "ProcessTimeSyncResponse(serverSentTime, clientRecvTime, clientSendTime, serverRecvTime time.Time)": "handles client sync response",
    "GetServerTime(clientTime time.Time) time.Time": "converts client to server timestamp",
    "EncodeDelta(clientID string, currentState *WorldSnapshot) ([]byte, error)": "creates compressed delta packet",
    "UpdateBaseline(clientID string, snapshot *WorldSnapshot, ackedSequence uint32)": "updates client baseline when delta acknowledged",
    "CalculateInterestSet(clientID string, playerPos Vector2, viewDir Vector2) ([]*Entity, error)": "returns entities relevant to specified client",
    "ScheduleUpdates(clientID string, candidateEntities []*Entity) ([]*Entity, error)": "selects entities for transmission within bandwidth limits",
    "ApplyRateLimit(clientID string, packet []byte) ([]byte, time.Duration, error)": "adjusts packet parameters for network conditions",
    "NewBandwidthTracker(clientID string) *BandwidthTracker": "creates network capacity monitor",
    "GetEstimatedBandwidth() float64": "returns current bandwidth estimate",
    "NewSpatialIndex(cellSize float64) *SpatialIndex": "creates proximity query system",
    "Insert(entity *Entity)": "adds entity to spatial index",
    "Remove(entityID EntityID)": "removes entity from spatial index",
    "QueryRadius(center Vector2, radius float64) []*Entity": "finds entities within specified distance",
    "NewConnectionHealthMonitor(alertCallback func(string, HealthEvent)) *ConnectionHealthMonitor": "creates health monitoring system",
    "UpdateClientHealth(clientID string, rtt time.Duration)": "records successful client message",
    "CheckTimeouts() []string": "identifies clients exceeding timeout thresholds",
    "NewDesyncDetector(world *World, tolerances ValidationTolerances) *DesyncDetector": "creates state consistency validator",
    "ValidateClientPosition(clientID string, reported Vector2, timestamp time.Time) ValidationResult": "checks if position is physically possible",
    "GenerateStateChecksum(tick uint64) StateChecksum": "creates cryptographic hash of world state",
    "NewAntiCheatValidator() *AntiCheatValidator": "creates comprehensive input validation system",
    "ValidateInputCommand(clientID string, cmd *InputCommand) ValidationResult": "performs multi-stage input validation",
    "DetectSpeedHacking(clientID string, oldPos, newPos Vector2, deltaTime time.Duration) bool": "checks if movement exceeds speed limits",
    "AnalyzeBehaviorPattern(clientID string, actionType ActionType, metrics ActionMetrics) float64": "updates player profile and detects anomalies",
    "NewTestClock(startTime time.Time) *TestClock": "creates controllable test time source",
    "Now() time.Time": "returns current test time with optional auto-advance",
    "Advance(duration time.Duration)": "manually advances test clock",
    "NewNetworkSimulator(latency, jitter time.Duration, packetLoss float64) *NetworkSimulator": "creates network condition simulator",
    "AssertFloatEqual(t *testing.T, expected, actual, tolerance float64, message string)": "validates float equality within epsilon",
    "AssertTimingConsistency(t *testing.T, intervals []time.Duration, targetInterval, maxVariance time.Duration)": "validates timing sequence consistency",
    "TestGameLoopTickConsistency(t *testing.T)": "validates fixed timestep consistency",
    "TestPredictionAccuracy(t *testing.T)": "validates client prediction accuracy",
    "TestReconciliationCorrection(t *testing.T)": "validates server reconciliation logic",
    "NewTimingMonitor(targetInterval time.Duration, tolerancePercent float64) *TimingMonitor": "creates timing consistency monitor",
    "RecordInterval(actual time.Duration)": "records actual tick interval for analysis",
    "GetStats() TimingStats": "returns timing statistics and violations",
    "NewNetworkDiagnostics() *NetworkDiagnostics": "creates network health monitoring system",
    "RecordPacketSent(clientID string)": "records outbound packet for loss tracking",
    "RecordPacketReceived(clientID string, rtt time.Duration)": "records successful packet reception with RTT",
    "NewStateValidator() *StateValidator": "creates state consistency debugging system",
    "RecordPredictionError(clientID string, predicted, authoritative Vector2, sequence uint32)": "logs prediction accuracy issue",
    "StartDebugServer(port int) error": "launches HTTP server for diagnostic endpoints",
    "DiagnoseTimingIssues(stats TimingStats, tolerance time.Duration) []TimingDiagnostic": "analyzes timing patterns for problems",
    "AnalyzeNetworkHealth(stats *ClientNetworkStats) NetworkDiagnostic": "evaluates client network quality",
    "ValidatePredictionAccuracy(errors []PredictionError, clientID string) PredictionDiagnostic": "checks prediction system health",
    "NewServerRegistry() *ServerRegistry": "creates cluster server registry",
    "RegisterServer(info *ServerInfo) error": "adds new server to cluster",
    "UpdateServerLoad(serverID string, metrics *LoadMetrics) error": "records server performance metrics",
    "InitiatePlayerHandoff(playerID string, newPosition Vector2) error": "begins player authority transfer",
    "CompletePlayerHandoff(handoffID string, success bool) error": "finalizes authority transfer",
    "AnalyzePlayerAction(playerID string, action *PlayerAction) *SuspicionAssessment": "analyzes behavior for cheating patterns",
    "UpdateDetectionRules(rules []BehaviorDetectionRule) error": "modifies anti-cheat detection parameters",
    "Get() interface{}": "retrieves recycled object from pool",
    "Put(obj interface{})": "returns object to pool for reuse"
  },
  "constants": {
    "MessageTypePlayerInput": "player_input",
    "MessageTypeGameState": "game_state",
    "MessageTypePlayerJoin": "player_join",
    "MessageTypePlayerLeave": "player_leave",
    "reconcileThreshold": "0.1 unit position tolerance",
    "inputBufferSize": "240 commands buffer size",
    "maxSmoothingTime": "400ms maximum correction duration",
    "minSmoothingTime": "50ms minimum correction duration",
    "maxRewindTime": "maximum historical rewind duration",
    "smoothingAlpha": "0.125 for exponential RTT smoothing",
    "HealthEventWarning": "connection_warning",
    "HealthEventDisconnected": "client_disconnected",
    "HealthEventReconnected": "client_reconnected",
    "HealthEventDegraded": "service_degraded",
    "packetLossThreshold": "0.05 acceptable packet loss rate",
    "latencyThreshold": "100ms warning threshold for RTT",
    "maxErrors": "1000 maximum stored prediction errors",
    "ServerStatusOnline": "server healthy and accepting connections",
    "ServerStatusOffline": "server unavailable",
    "ServerStatusDegraded": "server experiencing performance issues"
  },
  "terms": {
    "client-server architecture": "centralized authoritative server model",
    "peer-to-peer architecture": "direct client connections without central server",
    "hybrid architecture": "combination of client-server and peer-to-peer approaches",
    "network latency": "time delay for data transmission",
    "packet loss": "network packets that fail to reach destination",
    "jitter": "variation in packet arrival timing",
    "lag compensation": "server-side delay accounting for fair hit detection",
    "client prediction": "local state advancement for responsiveness",
    "state reconciliation": "correcting predictions with server authority",
    "tick rate": "server simulation update frequency",
    "fixed timestep": "consistent time advancement independent of frame rate",
    "authoritative server": "server maintains canonical game state",
    "accumulator pattern": "collecting time debt and paying in fixed increments",
    "deterministic simulation": "identical results from identical inputs",
    "visual smoothing": "gradual interpolation between states",
    "replay-based reconciliation": "method of correcting predictions by replaying inputs from corrected server state",
    "input sequencing": "numbering system for input order",
    "discrepancy threshold": "minimum difference required between predicted and server state to trigger reconciliation",
    "interpolation function": "mathematical function defining transition curve for visual smoothing",
    "historical state rewind buffer": "storage of past game states for temporal validation",
    "client latency estimation": "measuring network delay for each connected client",
    "round-trip time": "total time for message to travel client to server and back",
    "exponential moving average": "smoothing technique for noisy measurements",
    "temporal interpolation": "calculating intermediate values between historical snapshots",
    "clock offset": "difference between client and server time references",
    "rewind window": "maximum time period for historical state validation",
    "delta encoding": "transmitting only changed fields",
    "baseline snapshots": "reference points for delta calculation",
    "area of interest filtering": "sending only relevant updates based on spatial proximity",
    "spatial partitioning": "dividing world into regions for efficient queries",
    "priority scoring": "numeric relevance calculation for update scheduling",
    "bandwidth estimation": "measuring client network capacity",
    "adaptive rate limiting": "adjusting transmission based on network conditions",
    "quality adaptation": "reducing detail when bandwidth constrained",
    "staleness counter": "tracking time since last entity update",
    "hysteresis": "preventing oscillation at boundaries",
    "congestion detection": "identifying network saturation",
    "weighted fair queuing": "bandwidth allocation across priority levels",
    "graceful degradation": "maintaining reduced functionality during failures",
    "desynchronization": "when clients and server disagree about game state",
    "anti-cheat": "systems for detecting and preventing cheating",
    "connection health monitoring": "tracking network quality metrics per client",
    "state validation": "verifying client reported state matches server expectations",
    "behavioral analysis": "pattern detection for anti-cheat",
    "rate limiting": "preventing excessive input command frequency",
    "checksum verification": "cryptographic validation of state consistency",
    "escalation framework": "graduated response system for handling violations",
    "component unit testing": "testing individual systems in isolation with mocked dependencies",
    "network integration testing": "end-to-end testing with simulated network conditions and multiple clients",
    "milestone verification": "systematic validation that each milestone meets acceptance criteria",
    "emergent behaviors": "complex behaviors arising from interaction of multiple system components",
    "tick consistency": "maintaining fixed timestep intervals regardless of processing load",
    "prediction accuracy": "how closely client predictions match authoritative server state",
    "reconciliation correction": "process of correcting client predictions with server authority",
    "compression efficiency": "ratio of compressed to original data size",
    "bandwidth adaptation": "adjusting quality based on available network capacity",
    "automated verification pipeline": "continuous testing system for milestone validation",
    "timing consistency": "maintaining fixed timestep intervals regardless of load",
    "network diagnostics": "systematic monitoring of connection health metrics",
    "authority conflicts": "disagreements about canonical game state ownership",
    "temporal desynchronization": "client-server disagreement about event timing",
    "exponential smoothing": "filtering technique for noisy network measurements",
    "packet loss detection": "identifying failed message transmission",
    "reconciliation debugging": "analyzing prediction correction system behavior",
    "systematic bias": "consistent prediction errors indicating logic differences",
    "multi-server architecture": "distributed system with specialized server roles",
    "regional world partitioning": "dividing game world into server-managed zones",
    "inter-server communication": "coordination protocols between servers",
    "server specialization": "dedicated servers for specific functions",
    "client connection management": "gateway-based connection abstraction",
    "handoff protocol": "authority transfer between servers",
    "spectator mode": "observer clients with different update requirements",
    "replay system": "recording and playback of game sessions",
    "object pooling": "memory recycling for performance",
    "SIMD optimization": "vectorized mathematical operations",
    "adaptive quality": "network-based fidelity adjustment",
    "read replica scaling": "distributed database query handling",
    "cache invalidation": "maintaining data consistency in caches"
  }
}