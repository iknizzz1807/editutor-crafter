vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Microscopic View: Lock-Free Circular Buffer" {
  near: top-center
  style: {
    font-size: 32
    bold: true
    underline: true
  }
}

ring_buffer: "Ring Buffer (Shared Memory)" {
  shape: rectangle
  style: {
    fill: "#E8F4F8"
    stroke: "#2E86AB"
    stroke-width: 3
    font-size: 24
    bold: true
  }

  buffer_array: "Packet Buffer Array\n[0..BUFFER_SIZE-1]" {
    shape: cylinder
    style: {
      fill: "#B8E6F0"
      stroke: "#1A5F7A"
      stroke-width: 2
      font-size: 18
    }
  }

  write_ptr: "write_ptr (atomic_size_t)\nProducer Position" {
    shape: diamond
    style: {
      fill: "#90EE90"
      stroke: "#228B22"
      stroke-width: 2
      font-size: 16
    }
  }

  read_ptr: "read_ptr (atomic_size_t)\nConsumer Position" {
    shape: diamond
    style: {
      fill: "#FFB6C1"
      stroke: "#DC143C"
      stroke-width: 2
      font-size: 16
    }
  }

  overflow_flag: "overflow_flag (atomic_bool)\nBuffer Full Indicator" {
    shape: hexagon
    style: {
      fill: "#FFD700"
      stroke: "#FF8C00"
      stroke-width: 2
      font-size: 16
    }
  }
}

producer: "Producer Thread\n(Packet Capture)" {
  shape: rectangle
  style: {
    fill: "#C8E6C9"
    stroke: "#388E3C"
    stroke-width: 3
    font-size: 20
    bold: true
  }

  capture_op: "1. Capture Packet" {
    shape: step
    style: {
      fill: "#A5D6A7"
      stroke: "#2E7D32"
    }
  }

  atomic_load: "2. atomic_load(write_ptr)" {
    shape: step
    style: {
      fill: "#A5D6A7"
      stroke: "#2E7D32"
    }
  }

  check_space: "3. Check Space\n(write_ptr + 1) % SIZE != read_ptr" {
    shape: diamond
    style: {
      fill: "#81C784"
      stroke: "#1B5E20"
    }
  }

  write_packet: "4. Write Packet\nbuffer[write_ptr] = packet" {
    shape: step
    style: {
      fill: "#66BB6A"
      stroke: "#1B5E20"
    }
  }

  memory_barrier: "5. atomic_thread_fence\n(memory_order_release)" {
    shape: hexagon
    style: {
      fill: "#4CAF50"
      stroke: "#1B5E20"
      font-color: white
    }
  }

  atomic_store: "6. atomic_store(write_ptr,\n(write_ptr + 1) % SIZE)" {
    shape: step
    style: {
      fill: "#43A047"
      stroke: "#1B5E20"
    }
  }

  set_overflow: "Set overflow_flag = true" {
    shape: step
    style: {
      fill: "#FF6B6B"
      stroke: "#C62828"
    }
  }
}

consumer: "Consumer Thread\n(Packet Parser)" {
  shape: rectangle
  style: {
    fill: "#FFCCBC"
    stroke: "#D84315"
    stroke-width: 3
    font-size: 20
    bold: true
  }

  atomic_load_read: "1. atomic_load(read_ptr)" {
    shape: step
    style: {
      fill: "#FFAB91"
      stroke: "#BF360C"
    }
  }

  check_data: "2. Check Data Available\nread_ptr != write_ptr" {
    shape: diamond
    style: {
      fill: "#FF8A65"
      stroke: "#BF360C"
    }
  }

  read_packet: "3. Read Packet\npacket = buffer[read_ptr]" {
    shape: step
    style: {
      fill: "#FF7043"
      stroke: "#BF360C"
    }
  }

  memory_barrier_consume: "4. atomic_thread_fence\n(memory_order_acquire)" {
    shape: hexagon
    style: {
      fill: "#FF5722"
      stroke: "#BF360C"
      font-color: white
    }
  }

  atomic_store_read: "5. atomic_store(read_ptr,\n(read_ptr + 1) % SIZE)" {
    shape: step
    style: {
      fill: "#F4511E"
      stroke: "#BF360C"
    }
  }

  parse_packet: "6. Parse Packet" {
    shape: step
    style: {
      fill: "#E64A19"
      stroke: "#BF360C"
    }
  }

  wait_state: "Wait/Sleep" {
    shape: step
    style: {
      fill: "#D3D3D3"
      stroke: "#808080"
    }
  }
}

synchronization: "Synchronization Primitives" {
  shape: rectangle
  style: {
    fill: "#FFF9C4"
    stroke: "#F57F17"
    stroke-width: 3
    font-size: 20
    bold: true
  }

  atomic_ops: "Atomic Operations\n(C11 stdatomic.h)" {
    shape: rectangle
    style: {
      fill: "#FFF59D"
      stroke: "#F9A825"
    }
  }

  memory_order: "Memory Ordering\n- acquire: Consumer reads\n- release: Producer writes\n- seq_cst: Overflow flag" {
    shape: rectangle
    style: {
      fill: "#FFF176"
      stroke: "#F9A825"
    }
  }
}

overflow_handling: "Overflow Handling" {
  shape: rectangle
  style: {
    fill: "#FFCDD2"
    stroke: "#C62828"
    stroke-width: 3
    font-size: 20
    bold: true
  }

  detect: "Detect: (write_ptr + 1) % SIZE == read_ptr" {
    shape: step
    style: {
      fill: "#EF9A9A"
      stroke: "#B71C1C"
    }
  }

  action: "Action: Set overflow_flag\nDrop packet or block" {
    shape: step
    style: {
      fill: "#E57373"
      stroke: "#B71C1C"
    }
  }

  recovery: "Recovery: Consumer drains buffer\nClear overflow_flag" {
    shape: step
    style: {
      fill: "#EF5350"
      stroke: "#B71C1C"
    }
  }
}

producer.capture_op -> producer.atomic_load: {
  style: {
    stroke: "#388E3C"
    stroke-width: 2
    animated: true
  }
}

producer.atomic_load -> producer.check_space: {
  style: {
    stroke: "#388E3C"
    stroke-width: 2
  }
}

producer.check_space -> producer.write_packet: "Space Available" {
  style: {
    stroke: "#4CAF50"
    stroke-width: 2
  }
}

producer.check_space -> producer.set_overflow: "Buffer Full" {
  style: {
    stroke: "#F44336"
    stroke-width: 2
    stroke-dash: 3
  }
}

producer.write_packet -> producer.memory_barrier: {
  style: {
    stroke: "#388E3C"
    stroke-width: 2
  }
}

producer.memory_barrier -> producer.atomic_store: {
  style: {
    stroke: "#388E3C"
    stroke-width: 2
  }
}

producer.atomic_store -> ring_buffer.write_ptr: "Update" {
  style: {
    stroke: "#228B22"
    stroke-width: 3
    animated: true
  }
}

producer.write_packet -> ring_buffer.buffer_array: "Write" {
  style: {
    stroke: "#1A5F7A"
    stroke-width: 2
    animated: true
  }
}

producer.set_overflow -> ring_buffer.overflow_flag: "Set" {
  style: {
    stroke: "#FF8C00"
    stroke-width: 2
    stroke-dash: 3
  }
}

consumer.atomic_load_read -> consumer.check_data: {
  style: {
    stroke: "#D84315"
    stroke-width: 2
  }
}

consumer.check_data -> consumer.read_packet: "Data Available" {
  style: {
    stroke: "#FF5722"
    stroke-width: 2
  }
}

consumer.check_data -> consumer.wait_state: "Buffer Empty" {
  style: {
    stroke: "#9E9E9E"
    stroke-width: 2
    stroke-dash: 3
  }
}

consumer.read_packet -> consumer.memory_barrier_consume: {
  style: {
    stroke: "#D84315"
    stroke-width: 2
  }
}

consumer.memory_barrier_consume -> consumer.atomic_store_read: {
  style: {
    stroke: "#D84315"
    stroke-width: 2
  }
}

consumer.atomic_store_read -> consumer.parse_packet: {
  style: {
    stroke: "#D84315"
    stroke-width: 2
  }
}

consumer.atomic_store_read -> ring_buffer.read_ptr: "Update" {
  style: {
    stroke: "#DC143C"
    stroke-width: 3
    animated: true
  }
}

ring_buffer.buffer_array -> consumer.read_packet: "Read" {
  style: {
    stroke: "#1A5F7A"
    stroke-width: 2
    animated: true
  }
}

ring_buffer.write_ptr -> producer.atomic_load: "Load" {
  style: {
    stroke: "#228B22"
    stroke-width: 2
    stroke-dash: 3
  }
}

ring_buffer.read_ptr -> consumer.atomic_load_read: "Load" {
  style: {
    stroke: "#DC143C"
    stroke-width: 2
    stroke-dash: 3
  }
}

ring_buffer.read_ptr -> producer.check_space: "Check" {
  style: {
    stroke: "#DC143C"
    stroke-width: 1
    stroke-dash: 5
  }
}

ring_buffer.write_ptr -> consumer.check_data: "Check" {
  style: {
    stroke: "#228B22"
    stroke-width: 1
    stroke-dash: 5
  }
}

synchronization.atomic_ops -> producer.atomic_load: {
  style: {
    stroke: "#F9A825"
    stroke-width: 1
    stroke-dash: 3
  }
}

synchronization.atomic_ops -> producer.atomic_store: {
  style: {
    stroke: "#F9A825"
    stroke-width: 1
    stroke-dash: 3
  }
}

synchronization.atomic_ops -> consumer.atomic_load_read: {
  style: {
    stroke: "#F9A825"
    stroke-width: 1
    stroke-dash: 3
  }
}

synchronization.atomic_ops -> consumer.atomic_store_read: {
  style: {
    stroke: "#F9A825"
    stroke-width: 1
    stroke-dash: 3
  }
}

synchronization.memory_order -> producer.memory_barrier: {
  style: {
    stroke: "#F9A825"
    stroke-width: 1
    stroke-dash: 3
  }
}

synchronization.memory_order -> consumer.memory_barrier_consume: {
  style: {
    stroke: "#F9A825"
    stroke-width: 1
    stroke-dash: 3
  }
}

overflow_handling.detect -> producer.check_space: {
  style: {
    stroke: "#C62828"
    stroke-width: 1
    stroke-dash: 5
  }
}

overflow_handling.action -> producer.set_overflow: {
  style: {
    stroke: "#C62828"
    stroke-width: 1
    stroke-dash: 5
  }
}

overflow_handling.recovery -> consumer.parse_packet: {
  style: {
    stroke: "#C62828"
    stroke-width: 1
    stroke-dash: 5
  }
}

legend: "Legend" {
  near: bottom-right
  shape: rectangle
  style: {
    fill: "#F5F5F5"
    stroke: "#757575"
    stroke-width: 2
    font-size: 14
  }

  producer_flow: "Producer Flow (Green)" {
    shape: text
    style: {
      font-color: "#388E3C"
    }
  }

  consumer_flow: "Consumer Flow (Orange)" {
    shape: text
    style: {
      font-color: "#D84315"
    }
  }

  atomic_update: "Atomic Update (Solid)" {
    shape: text
    style: {
      font-color: "#1976D2"
    }
  }

  check_operation: "Check Operation (Dashed)" {
    shape: text
    style: {
      font-color: "#757575"
    }
  }

  overflow_path: "Overflow Path (Red Dashed)" {
    shape: text
    style: {
      font-color: "#F44336"
    }
  }
}

notes: |md
  ## Key Synchronization Points:
  
  1. **Atomic Pointers**: write_ptr and read_ptr use atomic operations
  2. **Memory Barriers**: Ensure visibility across threads
     - Release barrier: Producer commits write
     - Acquire barrier: Consumer sees committed data
  3. **Overflow Detection**: (write_ptr + 1) % SIZE == read_ptr
  4. **Lock-Free**: No mutexes, only atomic CAS operations
  
  ## Performance Characteristics:
  - **Latency**: O(1) enqueue/dequeue
  - **Throughput**: ~10M ops/sec (single producer/consumer)
  - **Memory**: Fixed size, no dynamic allocation
| {
  near: bottom-left
  shape: rectangle
  style: {
    fill: "#FFFDE7"
    stroke: "#F57F17"
    stroke-width: 2
    font-size: 12
  }
}