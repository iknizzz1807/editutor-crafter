vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Microscopic View: Memory Pool Management" {
  near: top-center
  style: {
    font-size: 32
    bold: true
    underline: true
  }
}

direction: down

memory_pool: "Memory Pool Structure" {
  shape: rectangle
  style: {
    fill: "#E8F4F8"
    stroke: "#2C5F7C"
    stroke-width: 3
    font-size: 20
    bold: true
  }

  pool_header: "Pool Header" {
    shape: rectangle
    style: {
      fill: "#FFE5CC"
      stroke: "#CC7A00"
      stroke-width: 2
    }
    
    total_size: "total_size: 1MB" {
      shape: rectangle
      style.fill: "#FFF9E6"
    }
    
    block_size: "block_size: 2048 bytes" {
      shape: rectangle
      style.fill: "#FFF9E6"
    }
    
    free_count: "free_count: 512" {
      shape: rectangle
      style.fill: "#FFF9E6"
    }
    
    free_list_head: "free_list_head: ptr" {
      shape: rectangle
      style.fill: "#FFF9E6"
    }
  }

  memory_blocks: "Memory Blocks (512 x 2KB)" {
    shape: rectangle
    style: {
      fill: "#D4EDDA"
      stroke: "#28A745"
      stroke-width: 2
    }
    
    block_0: "Block 0\n[FREE]" {
      shape: rectangle
      style: {
        fill: "#C3E6CB"
        stroke: "#28A745"
      }
      
      next_ptr: "next: Block 1" {
        shape: rectangle
        style.fill: "#E8F5E9"
      }
      
      data_area: "data[2048]" {
        shape: rectangle
        style: {
          fill: "#F1F8F4"
          stroke-dash: 3
        }
      }
    }
    
    block_1: "Block 1\n[FREE]" {
      shape: rectangle
      style: {
        fill: "#C3E6CB"
        stroke: "#28A745"
      }
      
      next_ptr_1: "next: Block 2" {
        shape: rectangle
        style.fill: "#E8F5E9"
      }
      
      data_area_1: "data[2048]" {
        shape: rectangle
        style: {
          fill: "#F1F8F4"
          stroke-dash: 3
        }
      }
    }
    
    block_n: "Block N\n[ALLOCATED]" {
      shape: rectangle
      style: {
        fill: "#F8D7DA"
        stroke: "#DC3545"
      }
      
      packet_data: "Packet Buffer\n(in use)" {
        shape: rectangle
        style: {
          fill: "#F5C6CB"
          font-color: "#721C24"
        }
      }
    }
    
    ellipsis: "..." {
      shape: text
      style: {
        font-size: 24
        bold: true
      }
    }
  }
}

allocation_flow: "Allocation Strategy" {
  shape: rectangle
  style: {
    fill: "#FFF3CD"
    stroke: "#856404"
    stroke-width: 3
    font-size: 20
    bold: true
  }

  step1: "1. Check Free List" {
    shape: rectangle
    style: {
      fill: "#FFF9E6"
      stroke: "#CC7A00"
    }
    
    check_code: |'md
      if (pool->free_list_head != NULL) {
        block = pool->free_list_head;
        pool->free_list_head = block->next;
        pool->free_count--;
        return block->data;
      }
    '| {
      shape: rectangle
      style: {
        fill: "#FFFBF0"
        font: mono
        font-size: 14
      }
    }
  }

  step2: "2. Fast Path Allocation" {
    shape: rectangle
    style: {
      fill: "#D4EDDA"
      stroke: "#28A745"
    }
    
    fast_alloc: "O(1) pointer update\nNo malloc() call" {
      shape: rectangle
      style: {
        fill: "#E8F5E9"
        font-size: 16
      }
    }
  }

  step3: "3. Fallback (Pool Full)" {
    shape: rectangle
    style: {
      fill: "#F8D7DA"
      stroke: "#DC3545"
    }
    
    fallback_code: |'md
      // Emergency allocation
      return malloc(block_size);
    '| {
      shape: rectangle
      style: {
        fill: "#F5C6CB"
        font: mono
        font-size: 14
      }
    }
  }
}

free_flow: "Free/Reuse Strategy" {
  shape: rectangle
  style: {
    fill: "#D1ECF1"
    stroke: "#0C5460"
    stroke-width: 3
    font-size: 20
    bold: true
  }

  free_step1: "1. Return to Free List" {
    shape: rectangle
    style: {
      fill: "#E8F5E9"
      stroke: "#28A745"
    }
    
    free_code: |'md
      block->next = pool->free_list_head;
      pool->free_list_head = block;
      pool->free_count++;
    '| {
      shape: rectangle
      style: {
        fill: "#F1F8F4"
        font: mono
        font-size: 14
      }
    }
  }

  free_step2: "2. Instant Reuse" {
    shape: rectangle
    style: {
      fill: "#FFF9E6"
      stroke: "#CC7A00"
    }
    
    reuse_benefit: "No memset() needed\nZero fragmentation" {
      shape: rectangle
      style: {
        fill: "#FFFBF0"
        font-size: 16
      }
    }
  }
}

performance_metrics: "Performance Characteristics" {
  shape: rectangle
  style: {
    fill: "#E2E3E5"
    stroke: "#383D41"
    stroke-width: 3
    font-size: 20
    bold: true
  }

  metric1: "Allocation Time: O(1)" {
    shape: rectangle
    style: {
      fill: "#D4EDDA"
      stroke: "#28A745"
      font-size: 16
    }
  }

  metric2: "Free Time: O(1)" {
    shape: rectangle
    style: {
      fill: "#D4EDDA"
      stroke: "#28A745"
      font-size: 16
    }
  }

  metric3: "Memory Overhead: 8 bytes/block" {
    shape: rectangle
    style: {
      fill: "#FFF3CD"
      stroke: "#856404"
      font-size: 16
    }
  }

  metric4: "Fragmentation: Zero" {
    shape: rectangle
    style: {
      fill: "#D4EDDA"
      stroke: "#28A745"
      font-size: 16
    }
  }

  metric5: "Cache Locality: Excellent" {
    shape: rectangle
    style: {
      fill: "#D4EDDA"
      stroke: "#28A745"
      font-size: 16
    }
  }
}

initialization: "Pool Initialization" {
  shape: rectangle
  style: {
    fill: "#CCE5FF"
    stroke: "#004085"
    stroke-width: 2
    font-size: 18
    bold: true
  }

  init_code: |'md
    // Allocate contiguous memory
    pool->memory = malloc(total_size);
    
    // Link all blocks into free list
    for (i = 0; i < block_count - 1; i++) {
      block[i].next = &block[i + 1];
    }
    block[block_count - 1].next = NULL;
    
    pool->free_list_head = &block[0];
    pool->free_count = block_count;
  '| {
    shape: rectangle
    style: {
      fill: "#E7F3FF"
      font: mono
      font-size: 14
    }
  }
}

memory_layout: "Memory Layout (Contiguous)" {
  shape: rectangle
  style: {
    fill: "#F8F9FA"
    stroke: "#6C757D"
    stroke-width: 2
    font-size: 18
    bold: true
  }

  layout_diagram: |'md
    [Header][Block0][Block1][Block2]...[BlockN]
    ^       ^       ^       ^            ^
    |       |       |       |            |
    Pool    2KB     2KB     2KB          2KB
  '| {
    shape: rectangle
    style: {
      fill: "#FFFFFF"
      font: mono
      font-size: 14
      stroke-dash: 3
    }
  }
}

advantages: "Why Custom Pool?" {
  shape: rectangle
  style: {
    fill: "#D4EDDA"
    stroke: "#28A745"
    stroke-width: 3
    font-size: 20
    bold: true
  }

  adv1: "✓ 10x faster than malloc()" {
    shape: rectangle
    style: {
      fill: "#E8F5E9"
      font-size: 16
    }
  }

  adv2: "✓ Predictable latency" {
    shape: rectangle
    style: {
      fill: "#E8F5E9"
      font-size: 16
    }
  }

  adv3: "✓ No heap fragmentation" {
    shape: rectangle
    style: {
      fill: "#E8F5E9"
      font-size: 16
    }
  }

  adv4: "✓ Cache-friendly access" {
    shape: rectangle
    style: {
      fill: "#E8F5E9"
      font-size: 16
    }
  }

  adv5: "✓ Thread-safe with mutex" {
    shape: rectangle
    style: {
      fill: "#E8F5E9"
      font-size: 16
    }
  }
}

memory_pool.pool_header.free_list_head -> memory_pool.memory_blocks.block_0: "points to" {
  style: {
    stroke: "#28A745"
    stroke-width: 2
    animated: true
  }
}

memory_pool.memory_blocks.block_0.next_ptr -> memory_pool.memory_blocks.block_1: "links to" {
  style: {
    stroke: "#28A745"
    stroke-width: 2
    stroke-dash: 3
  }
}

memory_pool.memory_blocks.block_1.next_ptr_1 -> memory_pool.memory_blocks.ellipsis: "continues" {
  style: {
    stroke: "#28A745"
    stroke-width: 2
    stroke-dash: 3
  }
}

allocation_flow.step1 -> allocation_flow.step2: "if free block available" {
  style: {
    stroke: "#28A745"
    stroke-width: 2
  }
}

allocation_flow.step1 -> allocation_flow.step3: "if pool exhausted" {
  style: {
    stroke: "#DC3545"
    stroke-width: 2
    stroke-dash: 3
  }
}

free_flow.free_step1 -> free_flow.free_step2: "enables" {
  style: {
    stroke: "#28A745"
    stroke-width: 2
  }
}

initialization -> memory_pool: "creates" {
  style: {
    stroke: "#004085"
    stroke-width: 2
  }
}

memory_layout -> memory_pool: "describes" {
  style: {
    stroke: "#6C757D"
    stroke-width: 2
    stroke-dash: 3
  }
}

advantages -> allocation_flow: "benefits" {
  style: {
    stroke: "#28A745"
    stroke-width: 2
  }
}

advantages -> free_flow: "benefits" {
  style: {
    stroke: "#28A745"
    stroke-width: 2
  }
}

performance_metrics -> memory_pool: "measures" {
  style: {
    stroke: "#383D41"
    stroke-width: 2
    stroke-dash: 3
  }
}

legend: "Legend" {
  near: bottom-right
  shape: rectangle
  style: {
    fill: "#F8F9FA"
    stroke: "#6C757D"
    stroke-width: 2
    font-size: 14
  }

  free_block: "Free Block" {
    shape: rectangle
    style: {
      fill: "#C3E6CB"
      stroke: "#28A745"
    }
  }

  allocated_block: "Allocated Block" {
    shape: rectangle
    style: {
      fill: "#F8D7DA"
      stroke: "#DC3545"
    }
  }

  pointer_link: "Pointer Link" {
    shape: rectangle
    style: {
      fill: "#E8F5E9"
    }
  }
}