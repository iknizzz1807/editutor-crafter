vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: right

title: "Multi-threaded Architecture" {
  shape: text
  near: top-center
  style: {
    font-size: 32
    bold: true
    underline: true
  }
}

network: "Network Interface" {
  shape: cloud
  style: {
    fill: "#E3F2FD"
    stroke: "#1976D2"
    font-size: 18
    bold: true
  }
}

capture_thread: "Capture Thread" {
  shape: rectangle
  style: {
    fill: "#FFF3E0"
    stroke: "#F57C00"
    font-size: 16
    bold: true
    multiple: true
  }
  
  pcap_loop: "pcap_loop()" {
    shape: step
    style: {
      fill: "#FFE0B2"
      stroke: "#E65100"
    }
  }
}

raw_queue: "Raw Packet Queue\n(Lock-free Ring Buffer)" {
  shape: queue
  style: {
    fill: "#F3E5F5"
    stroke: "#7B1FA2"
    font-size: 14
    bold: true
  }
  label: "Raw Packet Queue\n(Lock-free Ring Buffer)\nCapacity: 10,000"
}

parser_pool: "Parser Thread Pool" {
  shape: rectangle
  style: {
    fill: "#E8F5E9"
    stroke: "#388E3C"
    font-size: 16
    bold: true
    multiple: true
  }
  
  parser_1: "Parser Thread 1" {
    shape: rectangle
    style: {
      fill: "#C8E6C9"
      stroke: "#2E7D32"
    }
  }
  
  parser_2: "Parser Thread 2" {
    shape: rectangle
    style: {
      fill: "#C8E6C9"
      stroke: "#2E7D32"
    }
  }
  
  parser_n: "Parser Thread N" {
    shape: rectangle
    style: {
      fill: "#C8E6C9"
      stroke: "#2E7D32"
      stroke-dash: 3
    }
  }
}

parsed_queue: "Parsed Packet Queue\n(Thread-safe)" {
  shape: queue
  style: {
    fill: "#FFF9C4"
    stroke: "#F57F17"
    font-size: 14
    bold: true
  }
  label: "Parsed Packet Queue\n(Thread-safe)\nCapacity: 5,000"
}

analysis_thread: "Analysis Thread" {
  shape: rectangle
  style: {
    fill: "#FFEBEE"
    stroke: "#C62828"
    font-size: 16
    bold: true
  }
  
  detector: "Anomaly Detector" {
    shape: rectangle
    style: {
      fill: "#FFCDD2"
      stroke: "#B71C1C"
    }
  }
}

alert_queue: "Alert Queue" {
  shape: queue
  style: {
    fill: "#FCE4EC"
    stroke: "#AD1457"
    font-size: 14
    bold: true
  }
}

storage_thread: "Storage Thread" {
  shape: rectangle
  style: {
    fill: "#E0F2F1"
    stroke: "#00695C"
    font-size: 16
    bold: true
  }
  
  writer: "Disk Writer" {
    shape: cylinder
    style: {
      fill: "#B2DFDB"
      stroke: "#004D40"
    }
  }
}

output_thread: "Output Thread" {
  shape: rectangle
  style: {
    fill: "#E1F5FE"
    stroke: "#0277BD"
    font-size: 16
    bold: true
  }
  
  logger: "Alert Logger" {
    shape: rectangle
    style: {
      fill: "#B3E5FC"
      stroke: "#01579B"
    }
  }
}

backpressure: "Backpressure Handler" {
  shape: diamond
  style: {
    fill: "#FFF59D"
    stroke: "#F57F17"
    font-size: 14
    bold: true
  }
}

network -> capture_thread.pcap_loop: "Raw packets" {
  style: {
    stroke: "#1976D2"
    stroke-width: 3
    animated: true
  }
}

capture_thread.pcap_loop -> raw_queue: "Enqueue" {
  style: {
    stroke: "#F57C00"
    stroke-width: 2
    animated: true
  }
}

raw_queue -> parser_pool.parser_1: "Dequeue" {
  style: {
    stroke: "#7B1FA2"
    stroke-width: 2
  }
}

raw_queue -> parser_pool.parser_2: "Dequeue" {
  style: {
    stroke: "#7B1FA2"
    stroke-width: 2
  }
}

raw_queue -> parser_pool.parser_n: "Dequeue" {
  style: {
    stroke: "#7B1FA2"
    stroke-width: 2
    stroke-dash: 3
  }
}

parser_pool.parser_1 -> parsed_queue: "Enqueue" {
  style: {
    stroke: "#388E3C"
    stroke-width: 2
  }
}

parser_pool.parser_2 -> parsed_queue: "Enqueue" {
  style: {
    stroke: "#388E3C"
    stroke-width: 2
  }
}

parser_pool.parser_n -> parsed_queue: "Enqueue" {
  style: {
    stroke: "#388E3C"
    stroke-width: 2
    stroke-dash: 3
  }
}

parsed_queue -> analysis_thread.detector: "Dequeue" {
  style: {
    stroke: "#F57F17"
    stroke-width: 2
    animated: true
  }
}

analysis_thread.detector -> alert_queue: "Alerts" {
  style: {
    stroke: "#C62828"
    stroke-width: 3
    animated: true
  }
}

alert_queue -> storage_thread.writer: "Persist" {
  style: {
    stroke: "#AD1457"
    stroke-width: 2
  }
}

alert_queue -> output_thread.logger: "Log" {
  style: {
    stroke: "#AD1457"
    stroke-width: 2
  }
}

raw_queue -> backpressure: "Queue full?" {
  style: {
    stroke: "#F57F17"
    stroke-width: 2
    stroke-dash: 5
  }
}

backpressure -> capture_thread.pcap_loop: "Drop packets" {
  style: {
    stroke: "#D32F2F"
    stroke-width: 2
    stroke-dash: 5
  }
}

legend: "Legend" {
  near: bottom-right
  shape: rectangle
  style: {
    fill: "#FAFAFA"
    stroke: "#757575"
    font-size: 12
  }
  
  hot_path: "Hot Path (High Throughput)" {
    shape: text
    style: {
      font-color: "#F57C00"
      bold: true
    }
  }
  
  cold_path: "Cold Path (Low Latency)" {
    shape: text
    style: {
      font-color: "#0277BD"
      bold: true
    }
  }
  
  backpressure_path: "Backpressure Control" {
    shape: text
    style: {
      font-color: "#D32F2F"
      bold: true
    }
  }
}

notes: |md
  **Thread Coordination Strategy:**
  
  1. **Lock-free Raw Queue**: Capture thread never blocks
  2. **Parser Pool**: N threads scale with CPU cores
  3. **Single Analysis Thread**: Stateful detection requires serialization
  4. **Async I/O Threads**: Storage and output don't block analysis
  5. **Backpressure**: Drop packets when queues saturate (fail-safe)
  
  **Performance Targets:**
  - Capture: 1M pps (limited by NIC)
  - Parsing: 500K pps (4 threads Ã— 125K pps each)
  - Analysis: 100K pps (single-threaded bottleneck)
  - Storage: 10K alerts/sec (disk I/O bound)
| {
  near: bottom-left
  shape: text
  style: {
    font-size: 11
    font-color: "#424242"
  }
}