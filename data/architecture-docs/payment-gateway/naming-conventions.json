{
  "types": {
    "PaymentIntent": "fields: id str, amount int, currency str, status PaymentIntentStatus, idempotency_key str, metadata dict, created_at datetime, expires_at datetime, client_secret str, last_payment_error dict",
    "Charge": "fields: id str, payment_intent_id str, amount int, status ChargeStatus, payment_method_token str, failure_code str, failure_message str, network_transaction_id str, authorization_code str, created_at datetime, settled_at datetime",
    "Refund": "fields: id str, charge_id str, amount int, status RefundStatus, reason str, network_transaction_id str, failure_code str, failure_message str, created_at datetime, processed_at datetime",
    "WebhookEvent": "fields: id str, event_type str, payload dict, signature str, processed_at datetime, processing_attempts int, last_processing_error str, source_ip str, created_at datetime, deduplication_key str",
    "PaymentIntentStatus": "enum: created, requires_action, processing, succeeded, canceled",
    "ChargeStatus": "enum: pending, succeeded, failed",
    "RefundStatus": "enum: pending, succeeded, failed",
    "DisputeStatus": "enum: warning_needs_response, under_review, charge_refunded, won, lost",
    "IdempotencyKey": "fields: idempotency_key str, request_hash str, payment_intent_id str, response_body dict, response_status int, created_at datetime, completed_at datetime, expires_at datetime, client_ip str",
    "PaymentMethodToken": "tokenized payment method reference",
    "ReconciliationRun": "fields: id str, run_type str, started_at datetime, completed_at datetime, processed_count int, discrepancy_count int, error_count int, status str, error_message str",
    "ReconciliationDiscrepancy": "fields: id str, reconciliation_run_id str, payment_intent_id str, entity_type str, field_name str, local_value dict, provider_value dict, resolution_action str, resolved_at datetime, created_at datetime",
    "WebhookProcessingStatus": "enum: pending, processing, processed, failed, retrying, deferred",
    "RetryConfig": "configuration for retry strategies",
    "CircuitBreakerConfig": "configuration for circuit breaker behavior",
    "RetryExhaustedException": "exception when all retry attempts exhausted",
    "CircuitBreakerOpenException": "exception when circuit breaker blocks calls",
    "PaymentProvider": "interface with create_payment_intent, create_charge, confirm_payment, create_refund, get_payment_status, verify_webhook_signature, parse_webhook_event methods",
    "ProviderConfig": "fields: provider_name str, api_endpoint str, api_key str, webhook_secret str, supported_currencies set, capabilities set, fee_structure dict, processing_delay int, max_amount int, min_amount int",
    "ProviderPaymentIntent": "fields: provider_id str, provider_payment_id str, status str, client_secret str, next_action dict, charges list, metadata dict, created_at datetime",
    "Subscription": "fields: id str, customer_id str, plan_id str, status SubscriptionStatus, current_period_start datetime, current_period_end datetime, payment_method_token str",
    "SubscriptionPlan": "fields: id str, amount int, currency str, interval BillingInterval, interval_count int, trial_period_days int",
    "BillingCycle": "fields: id str, subscription_id str, period_start datetime, period_end datetime, amount_due int, status str",
    "ConnectedAccount": "fields: id str, marketplace_id str, account_holder_id str, status str, capabilities set, verification_status str",
    "TransferGroup": "fields: id str, payment_intent_id str, total_amount int, platform_fee int, status str",
    "Transfer": "fields: id str, transfer_group_id str, destination_account_id str, amount int, description str, status str",
    "PlatformFee": "fields: id str, transfer_id str, fee_type str, amount int, description str",
    "ProviderScore": "fields: provider_name str, total_score float, cost_score float, reliability_score float, performance_score float, capability_score float, disqualification_reason str",
    "ProviderCapability": "enum: CARD_PAYMENTS, BANK_TRANSFERS, DIGITAL_WALLETS, RECURRING_BILLING, MARKETPLACE_TRANSFERS, INSTANT_PAYOUTS",
    "SubscriptionStatus": "enum: TRIAL, ACTIVE, PAST_DUE, CANCELED, UNPAID",
    "BillingInterval": "enum: DAY, WEEK, MONTH, YEAR",
    "SelectionCriteria": "enum: LOWEST_COST, HIGHEST_SUCCESS_RATE, FASTEST_PROCESSING, GEOGRAPHIC_ROUTING, LOAD_BALANCING"
  },
  "methods": {
    "validate_amount(amount) -> int": "converts monetary amount to cents with validation",
    "validate_currency(currency) -> str": "validates ISO 4217 currency code",
    "validate_idempotency_key(key) -> str": "validates idempotency key format",
    "get_db() -> Session": "database session dependency injection",
    "can_transition_to(new_status) -> bool": "validates payment intent state transitions",
    "is_terminal_status() -> bool": "checks if payment status allows no further transitions",
    "create_charge(payment_method_token, amount, currency, return_url, metadata) -> ChargeResponse": "initiates payment with provider",
    "confirm_payment(provider_charge_id, authentication_token) -> ChargeResponse": "completes 3DS authentication",
    "process_payment_intent(payment_intent_id, payment_method_token, db) -> Charge": "core charge processing flow",
    "handle_three_ds_return(query_params, db) -> Charge": "processes 3DS authentication return",
    "generate_return_url(payment_intent_id, session_id) -> str": "creates secure 3DS return URL",
    "validate_return_params(query_params) -> bool": "validates 3DS return parameters",
    "verify_signature(payload, signature_header)": "verify webhook HMAC signature",
    "process_webhook(payload, signature_header, source_ip)": "main webhook processing entry point",
    "_store_webhook_event(event_data, signature, source_ip, db)": "store webhook with deduplication",
    "_process_event_by_type(webhook_event, db)": "route events to type-specific handlers",
    "_handle_payment_intent_event(event_data, db)": "process payment intent webhook events",
    "_handle_charge_event(event_data, db)": "process charge webhook events",
    "_handle_refund_event(event_data, db)": "process refund webhook events",
    "run_scheduled_reconciliation(lookback_days)": "execute scheduled reconciliation",
    "reconcile_single_payment(payment_intent_id)": "reconcile specific payment",
    "_reconcile_payment_batch(payment_intent_ids, reconciliation_run_id, db)": "reconcile batch of payments",
    "_compare_payment_states(local_payment, provider_payment)": "compare local vs provider state",
    "_resolve_discrepancy(discrepancy, db)": "apply discrepancy resolution",
    "create_payment_intent(amount, currency, idempotency_key, metadata)": "Creates new payment intent with idempotency checking",
    "process_payment_intent(payment_intent_id, payment_method_token, db)": "Main entry point for payment processing",
    "handle_three_ds_return(query_params, db)": "Processes 3D Secure authentication return",
    "create_charge(payment_method_token, amount, currency, return_url, metadata)": "Submits payment to external provider",
    "confirm_payment(provider_charge_id, authentication_token)": "Completes 3D Secure authentication flow",
    "validate_amount(amount)": "Converts monetary amount to cents with validation",
    "validate_currency(currency)": "Validates ISO 4217 currency code",
    "can_transition_to(new_status)": "Validates payment intent state transitions",
    "generate_return_url(payment_intent_id, session_id)": "Creates secure 3D Secure return URL",
    "validate_return_params(query_params)": "Validates 3D Secure return parameters",
    "process_webhook_event(event_type, payload, signature, source_ip)": "processes webhook with retry protection",
    "reconcile_payment_state(payment_intent_id)": "reconciles local vs provider state",
    "execute_compensation_transaction(failed_operation, context)": "executes compensation for failed operations",
    "calculate_delay(attempt, config) -> float": "calculates retry delay with jitter",
    "retry_with_config(config)": "decorator factory for retry logic",
    "circuit_breaker(config)": "decorator factory for circuit breaker protection",
    "generate_request_hash(amount, currency, payment_method_token, metadata, return_url)": "generate deterministic hash of payment parameters",
    "capture_webhook(raw_payload, headers, signature_header)": "Capture webhook for debugging analysis",
    "reconcile_payment_intent(payment_intent_id)": "Reconcile single payment intent with provider state",
    "create_payment_intent(amount, currency, metadata, idempotency_key) -> ProviderPaymentIntent": "creates payment intent with provider",
    "create_charge(payment_intent_id, payment_method_token, return_url) -> dict": "processes charge against payment intent",
    "verify_webhook_signature(payload, signature_header) -> bool": "verifies webhook signature using provider method",
    "select_provider(available_providers, amount, currency, payment_method, customer_country) -> PaymentProvider": "selects optimal provider for transaction",
    "create_subscription(customer_id, plan, payment_method_token, trial_end) -> Subscription": "creates new subscription with trial handling",
    "process_billing_cycle(subscription) -> BillingCycleResult": "processes subscription billing for current cycle",
    "calculate_proration(subscription, plan_change, effective_date) -> int": "calculates prorated amount for plan changes",
    "handle_failed_payment(subscription, failure_reason) -> PaymentRetryResult": "handles subscription payment failures with retry logic",
    "supports_capability(capability) -> bool": "checks if provider supports specific capability",
    "calculate_total_cost(amount, currency) -> int": "calculates total processing cost including fees"
  },
  "constants": {
    "SAQ_A": "PCI compliance self-assessment questionnaire A",
    "SAQ_A_EP": "PCI compliance SAQ A with e-commerce",
    "SAQ_D": "PCI compliance full merchant assessment",
    "TLS_1_2": "minimum required TLS version",
    "SUPPORTED_CURRENCIES": "set of allowed ISO 4217 currency codes",
    "DATABASE_URL": "PostgreSQL connection string",
    "PAYMENT_INTENT_RETRY": "retry configuration for payment intent operations",
    "CHARGE_PROCESSING_RETRY": "retry configuration for charge processing",
    "WEBHOOK_PROCESSING_RETRY": "retry configuration for webhook processing",
    "PROVIDER_API_BREAKER": "circuit breaker configuration for provider APIs",
    "DATABASE_BREAKER": "circuit breaker configuration for database connections",
    "ProviderCapability": "enum: CARD_PAYMENTS, BANK_TRANSFERS, DIGITAL_WALLETS, RECURRING_BILLING, MARKETPLACE_TRANSFERS, INSTANT_PAYOUTS",
    "SubscriptionStatus": "enum: TRIAL, ACTIVE, PAST_DUE, CANCELED, UNPAID",
    "BillingInterval": "enum: DAY, WEEK, MONTH, YEAR",
    "SelectionCriteria": "enum: LOWEST_COST, HIGHEST_SUCCESS_RATE, FASTEST_PROCESSING, GEOGRAPHIC_ROUTING, LOAD_BALANCING"
  },
  "terms": {
    "payment intent": "customer commitment to pay before money moves",
    "idempotency key": "unique identifier preventing duplicate operations",
    "3D Secure": "Strong Customer Authentication protocol for card payments",
    "webhook reconciliation": "synchronizing local state with payment provider",
    "tokenization": "replacing sensitive payment data with secure tokens",
    "chargeback": "forced payment reversal initiated by customer bank",
    "PCI DSS": "Payment Card Industry Data Security Standard",
    "terminal state": "payment status allowing no further transitions",
    "request parameter hash": "fingerprint of essential payment operation parameters",
    "circuit breaker": "failure protection preventing cascading failures",
    "exponential backoff": "retry delay strategy with exponentially increasing intervals",
    "compensation transaction": "inverse operation to maintain consistency after partial failures",
    "reconciliation": "process of synchronizing local state with external provider state",
    "idempotency": "property ensuring duplicate operations produce identical results",
    "jitter": "random variance added to retry delays to prevent synchronized retries",
    "thundering herd": "problem where many clients retry simultaneously",
    "eventual consistency": "consistency model where systems converge to consistent state over time",
    "provider abstraction layer": "translation boundary between domain model and provider-specific implementations",
    "provider selection strategy": "decision engine for routing transactions to optimal providers",
    "connected accounts": "seller accounts in marketplace with verification and capabilities",
    "transfer groups": "group of related transfers from single marketplace payment",
    "subscription billing engine": "orchestration system for recurring payment processing",
    "billing cycle": "individual billing period with payment tracking",
    "proration": "proportional billing adjustment for mid-cycle changes",
    "risk scoring pipeline": "fraud detection system analyzing transaction patterns",
    "provider health monitoring": "continuous tracking of provider performance metrics"
  }
}