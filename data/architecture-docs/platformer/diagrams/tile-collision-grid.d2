classes: {
  system_style: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  entity_style: {
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  process_style: {
    style.fill: "#0f3460"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  data_style: {
    style.fill: "#2d3748"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
}

collision_system: Tile-based Collision System {
  class: system_style

  entity: Entity {
    class: entity_style
    shape: class
    - "position: Vector2"
    - "velocity: Vector2"
    - "bounds: AABB"
    - "on_ground: boolean"
    + "update_position()"
    + "get_collision_bounds(): AABB"
  }

  collision_manager: Collision Manager {
    class: process_style
    
    tile_lookup: Tile Lookup {
      class: process_style
      shape: class
      + "world_to_tile(pos: Vector2): TileCoord"
      + "get_tiles_in_bounds(bounds: AABB): Tile list"
      + "is_solid_tile(coord: TileCoord): boolean"
    }

    aabb_tester: AABB Tester {
      class: process_style
      shape: class
      + "test_collision(a: AABB, b: AABB): CollisionInfo"
      + "get_overlap(a: AABB, b: AABB): Vector2"
      + "resolve_collision(entity: Entity, tile: AABB): void"
    }

    platform_handler: One-way Platform Handler {
      class: process_style
      shape: class
      - "was_above: boolean"
      + "check_platform_collision(entity: Entity, tile: AABB): boolean"
      + "handle_platform_passthrough(): void"
    }
  }

  tile_grid: Tile Grid {
    class: data_style
    
    tilemap: Tilemap Data {
      class: data_style
      shape: class
      - "tiles: int matrix"
      - "tile_size: int"
      - "width: int"
      - "height: int"
      + "get_tile(x: int, y: int): int"
    }

    tile_geometry: Tile Geometry {
      class: data_style
      shape: class
      - "solid_tiles: Set<int>"
      - "platform_tiles: Set<int>"
      - "collision_shapes: Map<int, CollisionShape>"
      + "get_tile_bounds(coord: TileCoord): AABB"
      + "is_one_way_platform(tile_id: int): boolean"
    }
  }

  spatial_hash: Spatial Hash {
    class: data_style
    shape: class
    - "grid_size: int"
    - "buckets: Map of int to Tile list"
    + "get_nearby_tiles(bounds: AABB): Tile list"
    + "hash_position(pos: Vector2): int"
  }
}

entity -> collision_manager.tile_lookup: request collision check
collision_manager.tile_lookup -> tile_grid.tilemap: get tiles in bounds
collision_manager.tile_lookup -> tile_grid.tile_geometry: check tile properties
collision_manager.tile_lookup -> spatial_hash: optimize tile queries

collision_manager.aabb_tester -> collision_manager.tile_lookup: get collision candidates
collision_manager.aabb_tester -> entity: resolve position

collision_manager.platform_handler -> collision_manager.aabb_tester: platform collision test
collision_manager.platform_handler -> entity: check previous position

tile_grid.tilemap -> tile_grid.tile_geometry: tile ID lookup
spatial_hash -> tile_grid.tilemap: cached tile access

collision_flow: |md
  ## Collision Detection Flow
  1. Entity requests collision check
  2. Convert world position to tile coordinates
  3. Query spatial hash for nearby tiles
  4. Test AABB collision with solid tiles
  5. Handle one-way platform logic
  6. Resolve collision and update entity
| {
  shape: page
  class: data_style
  near: top-right
}