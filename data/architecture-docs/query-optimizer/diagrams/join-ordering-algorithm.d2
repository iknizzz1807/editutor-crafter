title: Dynamic Programming Join Ordering {
  near: top-center
  style.font-size: 18
  style.bold: true
  style.font-color: "#e6edf3"
}

classes: {
  process: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  decision: {
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  data: {
    style.fill: "#0f3460"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  important: {
    style.fill: "#d63031"
    style.stroke: "#e17055"
    style.font-color: "#ffffff"
    style.bold: true
  }
}

start: Start {
  shape: circle
  class: important
}

init_tables: Initialize\nTable Set {
  class: process
}

size_2: Generate Size-2\nSubsets {
  class: process
}

enumerate_joins: Enumerate All\nJoin Pairs {
  class: process
}

calc_cost: Calculate\nJoin Cost {
  class: process
}

store_plan: Store Optimal\nPlan for Subset {
  class: process
}

size_check: More\nSizes? {
  shape: diamond
  class: decision
}

next_size: Increment\nSubset Size {
  class: process
}

enumerate_subsets: Enumerate\nSize-k Subsets {
  class: process
}

split_subset: Split Subset\ninto Left/Right {
  class: process
}

lookup_plans: Lookup Best Plans\nfor Sub-problems {
  class: process
}

compare_cost: Current Cost <\nBest Cost? {
  shape: diamond
  class: decision
}

update_best: Update Best\nPlan & Cost {
  class: important
}

prune_check: Pruning\nCondition Met? {
  shape: diamond
  class: decision
}

prune_plan: Prune\nSub-optimal Plan {
  class: data
}

more_splits: More\nSplits? {
  shape: diamond
  class: decision
}

more_subsets: More\nSubsets? {
  shape: diamond
  class: decision
}

final_plan: Return Optimal\nJoin Plan {
  class: important
}

memo_table: Memoization\nTable {
  shape: cylinder
  class: data
}

cost_model: Cost Model\n(I/O, CPU, Memory) {
  shape: page
  class: data
}

start -> init_tables
init_tables -> size_2
size_2 -> enumerate_joins
enumerate_joins -> calc_cost
calc_cost -> store_plan
store_plan -> size_check
size_check -> next_size: Yes
size_check -> final_plan: No
next_size -> enumerate_subsets
enumerate_subsets -> split_subset
split_subset -> lookup_plans
lookup_plans -> calc_cost
calc_cost -> compare_cost
compare_cost -> update_best: Yes
compare_cost -> prune_check: No
update_best -> prune_check
prune_check -> prune_plan: Yes
prune_check -> more_splits: No
prune_plan -> more_splits
more_splits -> split_subset: Yes
more_splits -> more_subsets: No
more_subsets -> enumerate_subsets: Yes
more_subsets -> size_check: No

calc_cost -> cost_model: uses
store_plan -> memo_table: updates
lookup_plans -> memo_table: reads
update_best -> memo_table: updates