classes: {
  entity: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  important: {
    style.fill: "#0f3460"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
}

title: Statistics and Cost Model {
  near: top-center
  style.font-size: 20
  style.bold: true
  style.font-color: "#e6edf3"
}

statistics: Statistics Components {
  class: entity
  
  table_stats: TableStatistics {
    shape: class
    class: important
    - "table_name: string"
    - "row_count: int64"
    - "page_count: int64"
    - "avg_row_size: int"
    - "last_updated: timestamp"
    + "get_cardinality(): int64"
    + "estimate_scan_cost(): CostEstimate"
  }
  
  column_stats: ColumnStatistics {
    shape: class
    class: important
    - "column_name: string"
    - "distinct_values: int64"
    - "null_count: int64"
    - "min_value: Value"
    - "max_value: Value"
    - "histogram: Histogram"
    + "get_selectivity(predicate: Predicate): double"
    + "estimate_range_selectivity(min: Value, max: Value): double"
  }
  
  histogram: Histogram {
    shape: class
    class: entity
    - "bucket_count: int"
    - "buckets: Bucket[]"
    - "total_rows: int64"
    + "estimate_equality(value: Value): double"
    + "estimate_range(min: Value, max: Value): double"
    + "get_bucket_for_value(value: Value): Bucket"
  }
  
  bucket: Bucket {
    shape: class
    class: entity
    - "range_start: Value"
    - "range_end: Value"
    - "frequency: int64"
    - "distinct_count: int64"
    + "contains(value: Value): bool"
    + "get_selectivity(): double"
  }
}

estimation: Selectivity Estimation {
  class: entity
  
  selectivity_estimator: SelectivityEstimator {
    shape: class
    class: important
    - "column_stats: Map<string, ColumnStatistics>"
    - "correlation_matrix: double[][]"
    + "estimate_predicate(pred: Predicate): double"
    + "estimate_conjunction(preds: Predicate[]): double"
    + "estimate_join_selectivity(left_table: Table, right_table: Table): double"
  }
  
  cardinality_estimator: CardinalityEstimator {
    shape: class
    class: important
    - "table_stats: Map<string, TableStatistics>"
    + "estimate_scan_cardinality(table: string, predicates: Predicate[]): int64"
    + "estimate_join_cardinality(left_rel: Relation, right_rel: Relation): int64"
    + "apply_selectivity(base_cardinality: int64, selectivity: double): int64"
  }
}

costing: Cost Components {
  class: entity
  
  cost_estimate: CostEstimate {
    shape: class
    class: important
    - "cpu_cost: double"
    - "io_cost: double"
    - "network_cost: double"
    - "memory_cost: double"
    - "startup_cost: double"
    + "total_cost(): double"
    + "add(other: CostEstimate): CostEstimate"
    + "multiply(factor: double): CostEstimate"
  }
  
  cost_model: CostModel {
    shape: class
    class: important
    - "cpu_cost_per_tuple: double"
    - "io_cost_per_page: double"
    - "memory_cost_per_kb: double"
    - "network_cost_per_byte: double"
    + "estimate_scan_cost(stats: TableStatistics, selectivity: double): CostEstimate"
    + "estimate_join_cost(left_card: int64, right_card: int64, join_type: JoinType): CostEstimate"
    + "estimate_sort_cost(cardinality: int64, sort_keys: int): CostEstimate"
  }
}

statistics.table_stats -> statistics.column_stats: contains
statistics.column_stats -> statistics.histogram: uses
statistics.histogram -> statistics.bucket: composed of

estimation.selectivity_estimator -> statistics.column_stats: reads from
estimation.cardinality_estimator -> statistics.table_stats: reads from
estimation.cardinality_estimator -> estimation.selectivity_estimator: uses

costing.cost_model -> estimation.cardinality_estimator: uses estimates from
costing.cost_model -> statistics.table_stats: reads from
costing.cost_model -> costing.cost_estimate: produces