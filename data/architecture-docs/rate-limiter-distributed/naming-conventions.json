{
  "types": {
    "RedisConfig": "fields: addresses []string, password string, db int, pool_size int, read_timeout time.Duration, write_timeout time.Duration, dial_timeout time.Duration",
    "RedisStorage": "fields: client redis.UniversalClient, config RedisConfig",
    "RateLimitRule": "fields: id string, name string, key_pattern string, algorithm string, limit int64, window time.Duration, burst_limit int64, enabled bool, priority int",
    "RuleManager": "fields: rules map[string]*RateLimitRule",
    "RateLimitResult": "fields: allowed bool, remaining int64, retry_after time.Duration, reset_time time.Time, rule_id string, algorithm string",
    "RateLimitRequest": "fields: user_id string, ip_address string, api_endpoint string, user_agent string, tokens int64",
    "DistributedLimiter": "fields: storage Storage, ruleManager *config.RuleManager, localFallback Limiter",
    "TokenBucketConfig": "fields: capacity int64, refill_rate int64, window time.Duration",
    "TokenBucketState": "fields: tokens int64, lastRefillTime int64, capacity int64, refillRate int64",
    "TokenBucket": "config TokenBucketConfig, storage Storage",
    "SlidingWindowConfig": "limit int64, window time.Duration, buckets int",
    "SlidingWindowCounter": "config SlidingWindowConfig, storage Storage, timeProvider TimeProvider",
    "SlidingWindowLog": "config SlidingWindowConfig, storage Storage, timeProvider TimeProvider",
    "KeyComposer": "fields: patternCache map[string]*regexp.Regexp",
    "MultiTierLimiter": "fields: storage Storage, ruleManager *RuleManager, keyComposer *KeyComposer, algorithms map[string]Algorithm, localFallback Limiter",
    "HealthChecker": "fields: mu sync.RWMutex, nodes map[string]*NodeHealth, circuitBreakers map[string]*CircuitBreaker, config HealthConfig",
    "HashRing": "fields: mu sync.RWMutex, ring []uint32, nodes map[uint32]string, nodeWeights map[string]int, virtualNodes int",
    "CircuitBreaker": "fields: mu sync.RWMutex, state CircuitState, failureCount int, lastFailureTime time.Time, nextRetryTime time.Time, failureThreshold int, recoveryTimeout time.Duration",
    "HotKeyDetector": "fields: mu sync.RWMutex, keyStats map[string]*KeyStats, clusterStats *ClusterStats, config HotKeyConfig",
    "KeyStats": "fields: RequestCount1Min int64, RequestCount5Min int64, RequestCount15Min int64, LastUpdate time.Time, WindowBuckets []int64",
    "NodeHealth": "fields: NodeID string, Address string, LastSeen time.Time, ConsecutiveFailures int, AverageLatency time.Duration, IsHealthy bool, MemoryUsage float64, ConnectionCount int",
    "FlowCoordinator": "fields: storage Storage, ruleManager *RuleManager, keyComposer *KeyComposer, algorithms map[string]Algorithm, localFallback Limiter, metricsCollector *MetricsCollector, circuitBreaker *CircuitBreaker",
    "RequestContext": "fields: UserID string, IPAddress string, APIEndpoint string, UserAgent string, Headers map[string]string, Tokens int64, Timestamp time.Time",
    "TierEvaluation": "RuleID string, TierName string, Result *RateLimitResult, Duration time.Duration, Algorithm string, RedisKey string",
    "FlowResult": "Allowed bool, TierResults []*TierEvaluation, BlockingTier string, TotalDuration time.Duration, UsedFallback bool, Headers map[string]string, RetryAfter time.Duration",
    "ConfigurationWatcher": "redisClient redis.UniversalClient, ruleManager *RuleManager, changeChannel string, subscription *redis.PubSub, localVersion int64, updateCallback func([]*RateLimitRule)",
    "MetricsCollector": "keyStats sync.Map, globalStats *GlobalStats, hotKeyDetector *HotKeyDetector, exportChan chan *MetricsBatch, windowSize time.Duration",
    "MetricsBatch": "Timestamp time.Time, RequestMetrics map[string]*RequestMetrics, PerformanceMetrics *PerformanceMetrics, HotKeys []string, SystemHealth *SystemHealth",
    "RequestMetrics": "TotalRequests int64, AllowedRequests int64, DeniedRequests int64, ErrorRequests int64, LastSeen time.Time",
    "TimeProvider": "fields: mu sync.RWMutex, redisClient redis.UniversalClient, clockSkew time.Duration, lastSync time.Time, syncInterval time.Duration",
    "FallbackLimiter": "fields: mu sync.RWMutex, tokenBuckets map[string]*TokenBucketState, windowCounters map[string]*WindowCounterState, defaultConfig *TokenBucketConfig, cleanupInterval time.Duration",
    "RedisTestHelper": "fields: miniRedis *miniredis.Miniredis, containers map[string]testcontainers.Container, clients map[string]*redis.Client",
    "LoadGenerator": "fields: config LoadGeneratorConfig, limiter ratelimit.DistributedLimiter, results *LoadTestResults, ctx context.Context, cancelFn context.CancelFunc",
    "LoadGeneratorConfig": "fields: Pattern LoadPattern, RequestsPerSecond int, Duration time.Duration, ClientCount int, KeyPattern string, BurstSize int, BurstInterval time.Duration",
    "LoadTestResults": "fields: TotalRequests int64, AllowedRequests int64, DeniedRequests int64, ErrorRequests int64, AverageLatency time.Duration, P95Latency time.Duration, P99Latency time.Duration, StartTime time.Time, EndTime time.Time, LatencyHistogram []time.Duration, mutex sync.RWMutex",
    "MockTimeProvider": "fields: mu sync.RWMutex, currentTime time.Time, clockSkew time.Duration",
    "CorrelationContext": "fields: TraceID string, RequestID string, UserID string, SessionID string, Metadata map[string]string, StartTime time.Time",
    "CorrelationLogger": "fields: logger *logrus.Logger, component string",
    "RedisDebugger": "fields: client redis.UniversalClient, logger *CorrelationLogger",
    "KeyDiagnostics": "fields: Key string, Exists bool, TTL time.Duration, MemoryUsage int64, AccessLatency time.Duration, NodeLocations []string",
    "ClusterHealth": "fields: TotalNodes int, HealthyNodes int, NodeStatuses map[string]*NodeStatus, AverageLatency time.Duration, KeyDistribution map[string]int",
    "PerformanceAnalysis": "fields: SlowOperations []SlowOperation, MemoryIssues []string, HotKeys []string, RecommendedActions []string",
    "NodeStatus": "fields: Address string, Reachable bool, Latency time.Duration, MemoryUsage float64, Role string, LastError error",
    "AdaptiveController": "fields: mu sync.RWMutex, config AdaptiveConfig, pidController *PIDController, ruleManager *config.RuleManager, metricsCollector *metrics.Collector, adjustmentTimer *time.Timer, ctx context.Context, cancelFn context.CancelFunc",
    "PIDController": "fields: mu sync.RWMutex, config AdaptiveConfig, previousError float64, integralError float64, lastUpdate time.Time, adjustmentHistory []AdjustmentRecord",
    "GeographicSyncManager": "fields: mu sync.RWMutex, config RegionConfig, localStorage storage.Storage, peerConnections map[string]*redis.Client, usageBuffer []UsageReport, conflictResolver *ConflictResolver, syncTicker *time.Ticker, ctx context.Context, cancelFn context.CancelFunc",
    "EnvoyRateLimitService": "fields: limiter ratelimit.DistributedLimiter, contextExtractor *RequestContextExtractor, policyManager *PolicyManager, metricsCollector *ServiceMeshMetrics",
    "PerformanceMetrics": "fields: P50Latency time.Duration, P95Latency time.Duration, P99Latency time.Duration, ErrorRate float64, CPUUtilization float64, MemoryUsage float64, QueueDepth int64, Timestamp time.Time",
    "UsageReport": "fields: RegionID string, Timestamp time.Time, WindowStart time.Time, WindowEnd time.Time, KeyUsage map[string]int64, Sequence int64",
    "ServiceMeshPolicy": "fields: Name string, Namespace string, Services []string, Routes []RouteMatch, RateLimiting RateLimitingSpec, Priority int, Enabled bool"
  },
  "methods": {
    "NewRedisStorage(config RedisConfig) (*RedisStorage, error)": "creates Redis storage with connection pooling",
    "CheckAndUpdate(ctx context.Context, key string, limit int64, window time.Duration) (bool, int64, time.Time, error)": "atomically checks and updates rate limit counters",
    "LoadRules(configPath string) error": "loads rate limit rules from YAML configuration",
    "GetMatchingRules(userID, ipAddress, apiEndpoint string) []*RateLimitRule": "returns rules matching request context",
    "Check(ctx context.Context, req RateLimitRequest) (*RateLimitResult, error)": "performs rate limit check and updates counters",
    "Preview(ctx context.Context, req RateLimitRequest) (*RateLimitResult, error)": "checks rate limit status without updating",
    "Reset(ctx context.Context, req RateLimitRequest) error": "clears rate limit counters",
    "NewDistributedLimiter(storage Storage, ruleManager *config.RuleManager) *DistributedLimiter": "creates distributed rate limiter instance",
    "Check(ctx context.Context, key string, tokens int64) (*RateLimitResult, error)": "performs rate limit check and updates counters",
    "Preview(ctx context.Context, key string) (*RateLimitResult, error)": "checks rate limit status without updating",
    "Reset(ctx context.Context, key string) error": "clears rate limit counters",
    "ExecuteLua(ctx context.Context, script string, keys []string, args []interface{}) (interface{}, error)": "executes Redis Lua script atomically",
    "ComposeKey(rule *RateLimitRule, req *RateLimitRequest) (string, error)": "generates Redis key from rule pattern and request context",
    "NewHashRing(virtualNodes int) *HashRing": "creates consistent hash ring with virtual nodes",
    "AddNode(nodeID string, weight int)": "adds physical node to ring with virtual nodes",
    "GetNode(key string) (string, bool)": "returns responsible node for key",
    "GetNodes(key string, count int) []string": "returns N nodes for replication",
    "Execute(ctx context.Context, fn func() error) error": "executes function with circuit breaker protection",
    "DetectHotKeys() []string": "analyzes key statistics and identifies hot keys",
    "RecordKeyAccess(key string)": "increments access counters for rate limit key",
    "CheckNodeHealth(ctx context.Context, nodeID string) (*NodeHealth, error)": "performs comprehensive health check on Redis node",
    "HandleNodeFailure(nodeID string) error": "coordinates response to detected node failure",
    "ProcessRequest(ctx context.Context, reqCtx *RequestContext) (*FlowResult, error)": "coordinates complete request flow from context to result",
    "evaluateAllTiers(ctx context.Context, reqCtx *RequestContext, rules []*RateLimitRule) ([]*TierEvaluation, error)": "performs multi-tier rate limit checking",
    "Start(ctx context.Context) error": "begins configuration change monitoring",
    "processChangeNotifications()": "handles incoming configuration change events",
    "performHealthCheck(ctx context.Context) error": "compares local vs remote configuration versions",
    "RecordRequest(key string, result *RateLimitResult, duration time.Duration)": "updates metrics for rate limit request",
    "ExportMetrics() *MetricsBatch": "produces metrics batch for external consumption",
    "MeasureClockSkew(ctx context.Context) (time.Duration, error)": "compares local time with Redis server time",
    "CheckLocal(ctx context.Context, key string, tokens int64, rule *RateLimitRule) (*RateLimitResult, error)": "performs rate limiting using local state only",
    "NewRedisTestHelper() *RedisTestHelper": "creates Redis test helper for various testing scenarios",
    "StartEmbeddedRedis() (*redis.Client, func(), error)": "starts lightweight Redis for unit testing",
    "StartRedisCluster(ctx context.Context, nodeCount int) ([]*redis.Client, func(), error)": "starts Redis cluster for integration testing",
    "SimulateNetworkPartition(ctx context.Context, nodeIDs []string) error": "simulates network partition by isolating nodes",
    "NewLoadGenerator(config LoadGeneratorConfig, limiter ratelimit.DistributedLimiter) *LoadGenerator": "creates load generator with traffic patterns",
    "Start() *LoadTestResults": "begins load generation according to configured pattern",
    "generateConstantLoad()": "produces steady request rate",
    "executeRequest()": "performs single rate limit check with timing",
    "recordResult(result *ratelimit.RateLimitResult, err error, latency time.Duration)": "safely updates load test results",
    "NewMockTimeProvider(startTime time.Time) *MockTimeProvider": "creates controllable time provider for testing",
    "AdvanceTime(duration time.Duration)": "moves mock clock forward by specified duration",
    "SetClockSkew(skew time.Duration)": "simulates time difference between nodes",
    "NewCorrelationContext(userID string) *CorrelationContext": "creates correlation context with unique identifiers",
    "WithMetadata(key, value string) *CorrelationContext": "adds metadata to correlation context",
    "PropagateToHeaders() map[string]string": "converts correlation context to HTTP headers",
    "NewCorrelationLogger(component string) *CorrelationLogger": "creates correlation-aware logger",
    "LogRateLimitDecision(ctx *CorrelationContext, result *RateLimitResult, duration time.Duration, redisKey string)": "logs rate limiting decisions with context",
    "LogRedisOperation(ctx *CorrelationContext, operation string, key string, duration time.Duration, err error)": "logs Redis operations for debugging",
    "NewRedisDebugger(client redis.UniversalClient) *RedisDebugger": "creates Redis debugging utilities",
    "DiagnoseKeyState(ctx context.Context, key string) (*KeyDiagnostics, error)": "provides comprehensive analysis of rate limiting key",
    "MeasureClusterHealth(ctx context.Context) (*ClusterHealth, error)": "assesses overall Redis cluster health",
    "AnalyzePerformanceIssues(ctx context.Context) (*PerformanceAnalysis, error)": "identifies common Redis performance problems",
    "NewAdaptiveController(config AdaptiveConfig, ruleManager *config.RuleManager, metricsCollector *metrics.Collector) *AdaptiveController": "creates adaptive rate limiting controller",
    "EvaluateAdjustments(ctx context.Context) error": "analyzes performance and determines rate limit changes",
    "CalculatePIDOutput(current, target PerformanceMetrics) float64": "computes adjustment using PID control",
    "SynchronizeUsage(ctx context.Context) error": "sends usage reports and processes peer reports",
    "ProcessPeerReport(report UsageReport) error": "incorporates remote region usage data",
    "ShouldRateLimit(ctx context.Context, req *envoy_service_ratelimit_v3.RateLimitRequest) (*envoy_service_ratelimit_v3.RateLimitResponse, error)": "implements Envoy rate limiting interface",
    "ExtractRequestContext(req *envoy_service_ratelimit_v3.RateLimitRequest) (*ratelimit.RequestContext, error)": "converts Envoy metadata to rate limiting context"
  },
  "constants": {
    "DEFAULT_POOL_SIZE": "10 Redis connections",
    "DEFAULT_TIMEOUT": "5ms for Redis operations",
    "PRIORITY_HIGH": "100 for high priority rules",
    "PRIORITY_LOW": "1 for low priority rules",
    "ALGORITHM_TOKEN_BUCKET": "token_bucket algorithm identifier",
    "ALGORITHM_SLIDING_WINDOW_LOG": "sliding_window_log algorithm identifier",
    "ALGORITHM_SLIDING_COUNTER": "sliding_window_counter algorithm identifier",
    "CircuitClosed": "normal operation state",
    "CircuitOpen": "all requests rejected state",
    "CircuitHalfOpen": "limited test requests allowed state",
    "ConstantLoad": "steady request rate load pattern",
    "BurstLoad": "periodic bursts of requests load pattern",
    "GradualRamp": "linearly increasing load pattern",
    "SpikeLoad": "sudden traffic spikes load pattern",
    "RandomLoad": "random request timing load pattern"
  },
  "terms": {
    "distributed rate limiting": "coordinating request quotas across multiple application instances",
    "local fallback": "switching to per-instance rate limiting when shared storage unavailable",
    "atomic operations": "indivisible check-and-update operations preventing race conditions",
    "graceful degradation": "maintaining reduced functionality during component failures",
    "circuit breaker": "preventing cascading failures through intelligent failure detection",
    "consistent hashing": "distributing data across nodes with minimal redistribution during topology changes",
    "hot key detection": "identifying disproportionately accessed rate limit keys",
    "multi-tier rate limiting": "hierarchical limits across user, IP, API, and global dimensions",
    "short-circuit evaluation": "stopping tier evaluation immediately when a limit is exceeded",
    "token bucket": "rate limiting algorithm allowing controlled bursts above sustained rate",
    "sliding window counter": "memory-efficient approximate rate limiting with time-based buckets",
    "sliding window log": "precise rate limiting storing individual request timestamps",
    "burst handling": "allowing short traffic spikes above sustained rate limits",
    "boundary condition": "edge cases where algorithms face greatest challenges like window transitions",
    "refill rate": "steady rate at which tokens are added to bucket",
    "tier precedence hierarchy": "ordered evaluation from most specific to most general limits",
    "rule pattern matching": "identifying applicable rules based on request context",
    "key composition": "systematic construction of Redis keys for rate limit storage",
    "virtual nodes": "multiple hash positions per physical node for load balancing",
    "hash ring": "circular hash space for consistent key distribution",
    "failover": "automatic redirection of traffic from failed nodes",
    "rebalancing": "redistributing load across nodes for optimal performance",
    "split-brain prevention": "ensuring consistent cluster state during network partitions",
    "configuration propagation": "distributing rule changes to all application instances",
    "metrics aggregation": "collecting and combining usage statistics for monitoring",
    "clock skew": "time difference between distributed system nodes",
    "optimistic concurrency": "assume conflicts are rare and handle through retries",
    "algorithm unit testing": "testing individual rate limiting algorithms in isolation for correctness and boundary conditions",
    "distributed integration testing": "multi-instance testing scenarios to verify cluster-wide rate limiting behavior",
    "milestone verification checkpoints": "quality gates confirming implementation meets acceptance criteria before advancing",
    "chaos and failure testing": "systematic failure injection to validate recovery mechanisms and identify weaknesses",
    "load pattern": "synthetic traffic generation strategy for testing system behavior",
    "network partition simulation": "controlled isolation of components to test split-brain scenarios",
    "clock skew testing": "validating time synchronization requirements across distributed nodes",
    "correlation IDs": "unique identifiers that follow requests through distributed system components",
    "structured logging": "logging with consistent format and fields for automated analysis",
    "distributed tracing": "tracking request flow across multiple system components",
    "symptom-based diagnosis": "mapping observable problems to likely root causes",
    "Redis debugging": "using Redis-specific tools and commands for troubleshooting",
    "multi-node log aggregation": "collecting and correlating logs from multiple system instances",
    "adaptive rate limiting": "automatically adjusting limits based on system performance",
    "geographic distribution": "multi-region deployment with eventual consistency",
    "service mesh integration": "transparent rate limiting through infrastructure",
    "eventual consistency": "global accuracy achieved over time with local decisions",
    "PID controller": "proportional-integral-derivative control algorithm",
    "cross-region synchronization": "sharing rate limit state between geographic regions",
    "transparent policy enforcement": "rate limiting without application code changes",
    "conflict resolution": "handling inconsistencies in distributed state",
    "oscillation prevention": "avoiding rapid limit fluctuations",
    "bounded staleness": "consistency guarantees with maximum staleness limits"
  }
}