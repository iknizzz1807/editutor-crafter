{
  "types": {
    "Authorizer": "main authorization interface",
    "AuthzRequest": "UserID, TenantID, Action, Resource",
    "AuthzDecision": "Allowed, Reason, Method, AppliedPolicies, EvaluationTime, CacheHit",
    "Resource": "ID, Type, TenantID, OwnerID, Attributes, CreatedAt, UpdatedAt, ShareSettings",
    "Role": "ID, Name, TenantID, ParentRoles, Permissions, CreatedAt, UpdatedAt",
    "Permission": "ID, Resource, Action",
    "UserRoleAssignment": "UserID, RoleID, TenantID, ValidFrom, ValidTo, AssignedBy, AssignedAt",
    "Policy": "ID, Name, TenantID, Effect, Conditions, Resources, Actions, Priority, CreatedBy, CreatedAt, UpdatedAt",
    "Condition": "And, Or, Not, Attribute, Operator, Value",
    "PolicyDecision": "Allowed, AppliedPolicies, DenyingPolicy",
    "RoleEngine": "RBAC evaluation engine",
    "PolicyEngine": "ABAC policy evaluation engine",
    "EvaluationMethod": "enum type for tracking decision source",
    "User": "UserID, TenantMemberships, GlobalRoles, CreatedAt, LastActiveAt",
    "TenantMembership": "TenantID, RoleIDs, JoinedAt, Status",
    "ShareSettings": "SharedWith, ShareLink, ExpiresAt, RequiresApproval, MaxShares, AllowedDomains",
    "ShareGrant": "GranteeType, GranteeID, Permissions, GrantedBy, GrantedAt, ExpiresAt, LastAccessed, CrossTenant, AuthorizedBy, BusinessJustification, ReviewRequired, NextReviewDate, MaxUsageCount, CurrentUsageCount",
    "PermissionBitmap": "bitmap for efficient permission storage",
    "PermissionRegistry": "global permission to bit position mapping",
    "RoleStorage": "thread-safe role hierarchy storage",
    "TemplateEngine": "role template instantiation system",
    "RoleTemplate": "role definition within template",
    "TemplateParam": "template customization parameter",
    "EvaluationContext": "UserAttributes, ResourceAttributes, EnvironmentAttributes, ActionAttributes",
    "PolicyStore": "interface for policy persistence",
    "AttributeResolver": "attribute value resolution interface",
    "TenantContext": "TenantID, UserID, Memberships, CrossTenant",
    "ResourceEvaluator": "handles resource-based authorization decisions",
    "CrossTenantShareManager": "handles cross-tenant resource sharing",
    "AuditRecord": "comprehensive audit information with integrity",
    "AuditLogger": "immutable audit logging with integrity verification",
    "PolicyTestFramework": "policy testing in isolated environment",
    "TestScenario": "Name, Request, Expected, Description",
    "TestResult": "Scenario, Actual, Passed, ErrorMessage, ExecutedAt",
    "ComplianceReporter": "generates regulatory compliance reports",
    "AnomalyDetector": "security pattern detection",
    "Anomaly": "represents detected unusual behavior",
    "SimulationReport": "contains policy testing results",
    "ComplianceReport": "formatted compliance evidence",
    "PermissionResult": "RBAC evaluation outcome with HasPermission, EffectiveRoles fields",
    "ResourceAccessResult": "Resource check outcome with AccessGranted, AccessType fields",
    "CacheManager": "multi-level caching coordination",
    "RequestValidator": "handles authorization request validation",
    "ValidationError": "structured validation error with Field, Message, Code",
    "CacheEntry": "cache value with metadata",
    "CacheMetrics": "cache performance statistics",
    "CircuitBreaker": "name, failureThreshold, recoveryTimeout, state, failures",
    "SystemHealth": "component health status",
    "DegradationManager": "currentLevel, transitionTime, recoveryMetrics",
    "HealthChecker": "system component monitoring fields",
    "TestFramework": "authorizer, engines, audit logger, test database, fixtures",
    "TestScenarioRunner": "fields: framework *TestFramework, scenarios []TestScenario, results []TestResult",
    "TestDatabase": "fields: connectionString string, currentTx *Transaction, initialized bool",
    "TestFixtures": "fields: users map[string]*User, roles map[string]*Role, resources map[string]*Resource, policies map[string]*Policy, tenants map[string]*TenantContext",
    "MilestoneCheckpointer": "fields: framework *TestFramework, milestone string, results map[string]bool",
    "PolicyTestEnvironment": "fields: snapshotID string, policies map[string]*Policy, testData *TestFixtures, simulator *PolicySimulator",
    "AuthorizationDebugger": "fields: traceEnabled bool, logBuffer []string",
    "MilestoneReport": "contains milestone validation results",
    "DebugTrace": "fields: RequestID string, UserID string, TenantID string, Resource string, Action string, StartTime time.Time, EndTime time.Time, Steps []TraceStep, Decision *AuthzDecision, Performance PerformanceMetrics, CacheStats CacheMetrics",
    "TraceStep": "fields: Component string, Operation string, StartTime time.Time, Duration time.Duration, Input map[string]interface{}, Output map[string]interface{}, CacheHit bool, Errors []string",
    "PerformanceMetrics": "fields: TotalDuration time.Duration, DatabaseQueries int, CacheOperations int, PolicyEvaluations int, MemoryAllocated int64",
    "AuthzMetrics": "authorization performance tracking",
    "LoadTestFramework": "load testing infrastructure",
    "LoadTestResults": "performance test outcomes",
    "SecurityAnomaly": "detected security threats",
    "ExtensionRegistry": "attributeResolvers, policyEvaluators, decisionEnhancers, auditProcessors",
    "AttributeEnhancer": "interface for extending attribute resolution",
    "PolicyFederator": "interface for external policy integration",
    "DecisionEnhancer": "interface for post-processing authorization decisions",
    "StreamingPolicyManager": "interface for real-time policy updates",
    "MLAttributeEnhancer": "riskModel, behaviorModel, attributeCache, trainingPipeline, metrics",
    "RiskModel": "interface for ML risk scoring",
    "UserFeatures": "fields: UserID string, RecentAccessPattern []AccessEvent, PeerGroupBehavior *PeerGroupStats, GeographicContext *GeographicInfo, TimeContext *TemporalInfo, DeviceContext *DeviceInfo, CustomAttributes map[string]interface{}",
    "FederationManager": "samlHandler, oidcHandler, attributeMapper, trustManager, sessionStore",
    "SAMLHandler": "fields: trustedIdPs map[string]*TrustedIdentityProvider, assertionCache *AssertionCache, validator *AssertionValidator",
    "AttributeMapper": "fields: mappingRules map[string]*MappingRule, defaultValues map[string]interface{}, validator *AttributeValidator",
    "FederatedIdentity": "external identity with mapped attributes",
    "SAMLAssertion": "parsed SAML assertion structure",
    "MappingRule": "attribute transformation rule",
    "BehaviorMetrics": "ML behavior analysis results",
    "ModelInfo": "ML model metadata",
    "EnhancementInfo": "attribute enhancer metadata",
    "ExternalDecision": "external policy evaluation result",
    "PolicySource": "external policy store information",
    "PolicyUpdate": "real-time policy change notification",
    "PolicyUpdateHandler": "callback for policy updates",
    "AttributeCache": "caching for ML attributes",
    "TrainingPipeline": "ML model training infrastructure",
    "MLMetrics": "ML integration performance metrics",
    "TrustedIdentityProvider": "SAML IdP configuration",
    "AssertionCache": "SAML assertion caching",
    "AssertionValidator": "SAML assertion validation",
    "SessionStore": "federated session storage",
    "AttributeValidator": "attribute validation rules",
    "AccessEvent": "user access history event",
    "PeerGroupStats": "behavioral comparison data",
    "GeographicInfo": "geographic context data",
    "TemporalInfo": "time context data",
    "DeviceInfo": "device security context"
  },
  "methods": {
    "IsAuthorized(ctx context.Context, req *AuthzRequest) (*AuthzDecision, error)": "main authorization check method",
    "HasPermission(ctx context.Context, userID, tenantID, resource, action string) (bool, error)": "RBAC permission check",
    "GetUserPermissions(ctx context.Context, userID, tenantID string) ([]Permission, error)": "get all user permissions",
    "Evaluate(ctx context.Context, req *AuthzRequest) (*PolicyDecision, error)": "evaluates ABAC policies against authorization request",
    "ValidateRoleHierarchy(ctx context.Context, tenantID string) error": "ensures role hierarchy DAG validity",
    "EvaluateCondition(condition *Condition, context map[string]interface{}) (bool, error)": "recursively evaluates condition tree",
    "computeTransitiveClosure(ctx context.Context, role *Role) (*PermissionBitmap, error)": "calculates inherited permissions",
    "InstantiateTemplate(ctx context.Context, templateID, tenantID string, params map[string]interface{}) error": "creates roles from template",
    "EvaluateCondition(condition *Condition, context *EvaluationContext) (bool, error)": "recursively evaluates condition tree against context",
    "ResolveUserAttributes(ctx context.Context, userID, tenantID string) (map[string]interface{}, error)": "resolves user attributes for policy evaluation",
    "ResolveResourceAttributes(ctx context.Context, resourceID string) (map[string]interface{}, error)": "resolves resource attributes for policy evaluation",
    "ResolveEnvironmentAttributes(ctx context.Context, req *AuthzRequest) (map[string]interface{}, error)": "resolves environment attributes from request context",
    "EvaluateResourceAccess(ctx context.Context, req *AuthzRequest) (*AuthzDecision, error)": "determines if user can perform action on resource",
    "ValidateTenantAccess(ctx context.Context, userID, tenantID string) (bool, error)": "checks if user can access resources in specified tenant",
    "EvaluateHierarchicalPermissions(ctx context.Context, resource *Resource, userID, action string) (bool, error)": "walks resource hierarchy to determine inherited permissions",
    "CreateCrossTenantShare(ctx context.Context, grant *ShareGrant) error": "creates new cross-tenant sharing grant",
    "ValidateCrossTenantAccess(ctx context.Context, userID, sourceTenant, targetTenant, resourceID, action string) (bool, *ShareGrant, error)": "checks if cross-tenant access is authorized",
    "WithTenantContext(ctx context.Context, tc *TenantContext) context.Context": "propagates tenant context through request chains",
    "GetTenantContext(ctx context.Context) (*TenantContext, bool)": "retrieves tenant context from request context",
    "LogAuthzDecision(ctx context.Context, req *AuthzRequest, decision *AuthzDecision) error": "records authorization decision with complete audit context",
    "VerifyIntegrityChain(ctx context.Context, startTime time.Time, endTime time.Time) error": "validates audit log integrity using hash chains",
    "CreateSnapshot(ctx context.Context, name string) error": "captures complete authorization state for testing",
    "RunSimulation(ctx context.Context, snapshotID string, scenarios []TestScenario) (*SimulationReport, error)": "executes test scenarios against modified policies",
    "GenerateComplianceReport(ctx context.Context, framework string, startTime time.Time, endTime time.Time) (*ComplianceReport, error)": "creates regulatory compliance reports from audit data",
    "DetectAnomalies(ctx context.Context, record *AuditRecord) []Anomaly": "identifies unusual access patterns in real-time",
    "computeIntegrityHash(record *AuditRecord) string": "computes cryptographic hash for tamper detection",
    "ValidateAuthzRequest(req *AuthzRequest) error": "performs comprehensive request validation",
    "Get(ctx context.Context, key string) (interface{}, bool)": "attempts to retrieve value from cache hierarchy",
    "Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error": "stores value in appropriate cache levels",
    "InvalidatePattern(ctx context.Context, pattern string) error": "removes cache entries matching pattern",
    "Execute(ctx context.Context, fn func() error) error": "executes function with circuit breaker protection",
    "CheckSystemHealth(ctx context.Context) (*SystemHealth, error)": "performs comprehensive health assessment",
    "EvaluateDegradationLevel(health *SystemHealth) DegradationLevel": "determines degradation based on health",
    "DetectSecurityAnomaly(ctx context.Context, req *AuthzRequest) []SecurityAnomaly": "identifies potential security attacks",
    "NewTestFramework(t *testing.T) *TestFramework": "creates isolated testing environment with fresh database and clean state",
    "CreateStandardFixtures(ctx context.Context) error": "generates realistic test data covering common authorization patterns",
    "AssertAccessGranted(t *testing.T, decision *AuthzDecision, message string)": "validates that authorization decision allows access",
    "AssertAccessDenied(t *testing.T, decision *AuthzDecision, message string)": "validates that authorization decision denies access",
    "AssertAuditLogged(t *testing.T, logger *AuditLogger, req *AuthzRequest, decision *AuthzDecision)": "verifies that authorization decision was properly audited",
    "CreateTestSnapshot(ctx context.Context, name string) error": "captures complete authorization state for testing",
    "SimulatePolicyChanges(ctx context.Context, changes []PolicyChange) (*SimulationReport, error)": "tests policy modifications against captured state",
    "ExecuteCheckpoint(ctx context.Context, milestone string) (*MilestoneReport, error)": "runs comprehensive validation for specified milestone",
    "TraceAuthorizationDecision(ctx context.Context, req *AuthzRequest) (*DebugTrace, error)": "provides step-by-step evaluation details for debugging",
    "RecordDecision(decision *AuthzDecision)": "updates metrics after each authorization decision",
    "RunSteadyStateLoad(ctx context.Context, targetRPS int, duration time.Duration) (*LoadTestResults, error)": "simulates normal operational load",
    "RunBurstLoad(ctx context.Context, baseRPS int, burstMultiplier int, burstDuration time.Duration) (*LoadTestResults, error)": "simulates sudden traffic spikes",
    "EnhanceContext(ctx context.Context, base *EvaluationContext, req *AuthzRequest) (*EvaluationContext, error)": "adds enhanced attributes to evaluation context",
    "GetEnhancementInfo() EnhancementInfo": "describes enhancer capabilities",
    "ValidateConfiguration() error": "validates enhancer configuration",
    "EvaluateExternalPolicies(ctx context.Context, req *AuthzRequest, context *EvaluationContext) ([]ExternalDecision, error)": "consults external policy stores",
    "SynchronizePolicies(ctx context.Context) error": "updates from external policies",
    "GetPolicyProvenance() []PolicySource": "returns external policy source info",
    "EnhanceDecision(ctx context.Context, decision *AuthzDecision, enhancedContext *EvaluationContext) (*AuthzDecision, error)": "post-processes authorization decisions",
    "ShouldEnhance(decision *AuthzDecision) bool": "determines if enhancement needed",
    "SubscribeToPolicyUpdates(ctx context.Context, handler PolicyUpdateHandler) error": "subscribes to real-time policy changes",
    "PublishPolicyUpdate(ctx context.Context, update *PolicyUpdate) error": "broadcasts policy changes",
    "GetCurrentPolicyVersion(ctx context.Context) (string, error)": "returns current policy version",
    "ProcessSAMLAssertion(ctx context.Context, assertion []byte) (*FederatedIdentity, error)": "processes SAML assertion",
    "extractUserFeatures(ctx context.Context, userID string, req *AuthzRequest) (*UserFeatures, error)": "gathers ML model features",
    "computeRiskScoreWithTimeout(ctx context.Context, features *UserFeatures) (float64, error)": "computes ML risk score with timeout",
    "extractUserAttributes(assertion *SAMLAssertion) map[string]interface{}": "extracts attributes from SAML",
    "TransformAttributes(ctx context.Context, external map[string]interface{}, source string) (map[string]interface{}, error)": "transforms external to internal attributes",
    "PredictRisk(ctx context.Context, features *UserFeatures) (float64, error)": "predicts user risk score",
    "GetModelInfo() ModelInfo": "returns ML model metadata",
    "IsAuthorized(ctx, req)": "main authorization check method",
    "HasPermission(ctx, userID, tenantID, resource, action)": "RBAC permission check",
    "Evaluate(ctx, req)": "evaluates ABAC policies",
    "ValidateRoleHierarchy(ctx, tenantID)": "ensures role hierarchy DAG validity",
    "EvaluateCondition(condition, context)": "recursively evaluates condition tree",
    "computeTransitiveClosure(ctx, role)": "calculates inherited permissions",
    "InstantiateTemplate(ctx, templateID, tenantID, params)": "creates roles from template",
    "ResolveUserAttributes(ctx, userID, tenantID)": "resolves user attributes",
    "EvaluateResourceAccess(ctx, req)": "determines resource access",
    "ValidateTenantAccess(ctx, userID, tenantID)": "checks tenant access",
    "CreateCrossTenantShare(ctx, grant)": "creates cross-tenant sharing",
    "LogAuthzDecision(ctx, req, decision)": "records authorization decision",
    "VerifyIntegrityChain(ctx, startTime, endTime)": "validates audit log integrity",
    "RunSimulation(ctx, snapshotID, scenarios)": "executes test scenarios",
    "GenerateComplianceReport(ctx, framework, startTime, endTime)": "creates compliance reports",
    "DetectAnomalies(ctx, record)": "identifies unusual access patterns",
    "ValidateAuthzRequest(req)": "performs request validation",
    "CheckSystemHealth(ctx)": "performs health assessment",
    "NewTestFramework(t)": "creates testing environment",
    "TraceAuthorizationDecision(ctx, req)": "provides debugging traces"
  },
  "constants": {
    "PolicyEffectAllow": "allow access policy effect",
    "PolicyEffectDeny": "deny access policy effect",
    "EvaluationRBAC": "role-based evaluation method",
    "EvaluationABAC": "attribute-based evaluation method",
    "EvaluationOwnership": "resource ownership evaluation method",
    "EvaluationCached": "cached result evaluation method",
    "PermissionScope": "enum for permission scope (owned, tenant, global)",
    "MembershipStatus": "enum for tenant membership status",
    "ScopeOwned": "permission applies to owned resources",
    "ScopeTenant": "permission applies to tenant resources",
    "ScopeGlobal": "permission applies across tenants",
    "MembershipActive": "full tenant member",
    "MembershipSuspended": "temporarily disabled",
    "MembershipPending": "awaiting approval",
    "MembershipRevoked": "permanently removed",
    "CircuitClosed": "normal operation",
    "CircuitOpen": "failing fast",
    "CircuitHalfOpen": "testing recovery",
    "DatabaseUnavailable": "database failure mode",
    "PolicyEvaluationTimeout": "policy timeout failure",
    "FullFunctionality": "no degradation",
    "EmergencyMode": "maximum degradation"
  },
  "terms": {
    "RBAC": "Role-Based Access Control through organizational roles",
    "ABAC": "Attribute-Based Access Control through dynamic evaluation",
    "ACL": "Access Control List with explicit permissions",
    "ReBAC": "Relationship-Based Access Control",
    "tenant isolation": "complete data separation between organizations",
    "deny-overrides": "deny policies override allow policies",
    "role hierarchy": "parent-child role relationships with inheritance",
    "policy evaluation": "dynamic assessment of attribute conditions",
    "fail-safe defaults": "deny access when uncertain",
    "scope creep": "natural expansion pressure where related security concerns want to creep into authorization scope",
    "decision pipeline": "authorization flow through evaluation stages",
    "transitive closure computation": "algorithm to determine all permissions available through role inheritance",
    "directed acyclic graph": "DAG structure for role hierarchies preventing circular dependencies",
    "permission inheritance": "child roles inherit parent permissions",
    "attribute resolution": "gathering attribute values for evaluation",
    "cross-tenant sharing": "controlled collaboration between tenants",
    "role templates": "preconfigured role bundles",
    "bitmap encoding": "high-performance permission storage",
    "condition tree": "recursive logical condition structure",
    "policy combining logic": "algorithm for resolving conflicts between multiple matching policies",
    "resource ownership": "creator control over resource access",
    "hierarchical resource access": "parent-child resource relationships with inherited permissions",
    "resource hierarchy": "parent-child relationships between resources enabling permission inheritance",
    "inheritance rules": "configuration determining how permissions flow from parent to child resources",
    "ownership transfer": "changing resource owner while maintaining security boundaries",
    "share links": "URLs that provide controlled anonymous access to resources",
    "audit trail": "immutable decision record",
    "decision provenance": "complete reasoning chain",
    "integrity verification": "cryptographic tampering proof",
    "hash chain": "linked sequence of cryptographic hashes preventing audit log tampering",
    "snapshot-based testing": "policy testing using captured point-in-time authorization state",
    "compliance reporting": "transformation of audit logs into regulatory evidence",
    "anomaly detection": "identification of unusual access patterns indicating potential threats",
    "policy simulation": "safe testing of policy changes",
    "differential analysis": "comparison of authorization behavior between policy versions",
    "immutable audit log": "append-only audit storage preventing modification or deletion",
    "regulatory framework": "specific compliance requirements like SOX, GDPR, HIPAA",
    "access pattern analysis": "statistical analysis of user behavior for optimization and threat detection",
    "multi-level caching": "hierarchical cache strategy",
    "cache invalidation": "process of removing stale cache entries when source data changes",
    "structured message passing": "components exchange immutable data structures through defined interfaces",
    "temporal locality": "recently accessed data is likely to be accessed again",
    "spatial locality": "related data is likely to be accessed together",
    "computational locality": "avoiding repeated calculation of the same derived data",
    "cache coherence": "maintaining consistency across distributed cache nodes",
    "conservative decision algorithm": "authorization synthesis where any uncertainty results in deny",
    "evaluation context": "complete set of attributes available for policy evaluation",
    "circuit breaker": "fault tolerance pattern",
    "graceful degradation": "maintaining core functionality during failures",
    "cache poisoning": "attack injecting false data into cache to cause incorrect decisions",
    "timing attacks": "inferring sensitive information by measuring response times",
    "permission elevation": "attack attempting to gain higher privileges than authorized",
    "unit testing": "testing individual components with mock dependencies and edge cases",
    "end-to-end testing": "full authorization flow testing with realistic scenarios",
    "milestone validation": "verification steps after each implementation milestone",
    "test isolation": "ensuring tests don't interfere with each other through clean state management",
    "performance benchmarking": "measuring authorization system latency and throughput under load",
    "regression testing": "re-running earlier tests to ensure new changes don't break existing functionality",
    "test fixtures": "realistic test data that mirrors production complexity",
    "acceptance criteria": "specific requirements that must be met for milestone completion",
    "automated validation": "scripted testing that provides consistent and repeatable verification",
    "machine learning policies": "ML-enhanced authorization decisions",
    "dynamic attributes": "real-time context-based attributes",
    "advanced delegation": "sophisticated privilege delegation patterns with hierarchical chains, conditions, and audit trails",
    "distributed evaluation": "horizontal authorization scaling",
    "streaming updates": "real-time policy change propagation without service disruption",
    "horizontal scaling": "independent scaling of authorization components based on specific performance characteristics",
    "SAML federation": "enterprise identity provider integration",
    "OIDC integration": "OpenID Connect integration for modern identity federation",
    "external policy stores": "integration with existing policy management systems and compliance frameworks",
    "multi-system federation": "coordinated authorization across multiple organizational systems",
    "attribute enhancement": "extending basic attributes with ML-derived, dynamic, or external data sources",
    "policy federation": "coordinated policy evaluation across multiple policy management systems",
    "claim-based attribute resolution": "using external identity assertions as attribute sources for policy evaluation",
    "risk-augmented evaluation": "combining traditional authorization with ML-derived risk assessments",
    "evaluation locality optimization": "routing requests to nodes with relevant cached data for performance",
    "version-aware evaluation": "ensuring authorization requests evaluate against consistent policy snapshots",
    "plugin architecture": "extension framework enabling advanced features without core system modification",
    "ecosystem-aware authorization": "authorization decisions that consider context from multiple organizational systems",
    "context correlation": "intelligently combining information from multiple external sources",
    "federated session lifecycle": "managing authentication sessions across multiple identity providers",
    "behavioral analysis": "ML analysis of user access patterns for anomaly detection",
    "delegation provenance": "complete audit trail of privilege delegation chains"
  }
}