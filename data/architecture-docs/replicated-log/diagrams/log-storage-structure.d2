title: Log Storage Structure

classes: {
  storage: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  memory: {
    style.fill: "#0f3460"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  file: {
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  process: {
    style.fill: "#2d3748"
    style.stroke: "#f6ad55"
    style.font-color: "#e6edf3"
    style.bold: true
  }
}

log_storage: Log Storage Engine {
  class: storage
  
  memory_layer: Memory Layer {
    class: memory
    
    memtable: MemTable {
      shape: rectangle
      class: memory
    }
    
    wal: Write-Ahead Log {
      shape: page
      class: memory
    }
  }
  
  disk_layer: Disk Layer {
    class: file
    
    segments: Segment Files {
      class: file
      
      segment_1: segment_001.log {
        shape: page
        class: file
      }
      
      segment_2: segment_002.log {
        shape: page
        class: file
      }
      
      segment_n: segment_N.log {
        shape: page
        class: file
      }
    }
    
    indexes: Index Files {
      class: file
      
      index_1: segment_001.idx {
        shape: page
        class: file
      }
      
      index_2: segment_002.idx {
        shape: page
        class: file
      }
      
      index_n: segment_N.idx {
        shape: page
        class: file
      }
    }
  }
  
  compaction: Compaction Process {
    shape: hexagon
    class: process
  }
}

client_write: Client Write {
  shape: circle
  style.fill: "#3fb950"
  style.font-color: "#ffffff"
}

client_read: Client Read {
  shape: circle
  style.fill: "#74b9ff"
  style.font-color: "#ffffff"
}

client_write -> log_storage.memory_layer.memtable: 1. Append entry
log_storage.memory_layer.memtable -> log_storage.memory_layer.wal: 2. Write to WAL
log_storage.memory_layer.wal -> log_storage.disk_layer.segments.segment_n: 3. Flush to segment
log_storage.disk_layer.segments.segment_n -> log_storage.disk_layer.indexes.index_n: 4. Update index

client_read -> log_storage.disk_layer.indexes.index_n: 1. Lookup offset
log_storage.disk_layer.indexes.index_n -> log_storage.disk_layer.segments.segment_n: 2. Read at offset
log_storage.disk_layer.segments.segment_n -> client_read: 3. Return entry

log_storage.compaction -> log_storage.disk_layer.segments: Merge segments
log_storage.compaction -> log_storage.disk_layer.indexes: Rebuild indexes

flow_note: |md
  **Data Flow:**
  - Writes go through MemTable + WAL for durability
  - Periodic flush creates new segment files
  - Index files enable O(1) lookups by sequence number
  - Compaction merges old segments to reclaim space
| {
  shape: page
  near: bottom-center
  style.fill: "#2d3748"
  style.stroke: "#f6ad55"
  style.font-color: "#e6edf3"
}