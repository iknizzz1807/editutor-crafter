{
  "types": {
    "RPCError": "message str, error_code int, error_data any",
    "RPCProtocolError": "raw_data bytes, parse_stage str",
    "RPCTransportError": "host str, port int, operation str",
    "RPCTimeoutError": "timeout_seconds float, elapsed_seconds float",
    "RPCMethodError": "method_name str, params list, execution_phase str",
    "ErrorCode": "constants for standard JSON-RPC error codes",
    "SocketHelper": "utility class for socket operations",
    "RPCServer": "host str, port int, registry MethodRegistry, server_socket socket, running bool",
    "RPCClient": "host str, port int, default_timeout float, _socket Optional[socket], _pending_requests Dict[str, Dict]",
    "MethodRegistry": "methods Dict[str, Callable], lock RLock, descriptions Dict[str, str]",
    "RPCProxy": "_client RPCClient, _timeout Optional[float], _method_cache Dict[str, Callable]",
    "RetryConfig": "max_attempts int, base_delay float, max_delay float, backoff_multiplier float",
    "RetryHandler": "config RetryConfig, _attempt_lock Lock",
    "TestServerHelper": "host str, port int, server RPCServer, methods Dict",
    "TestClientHelper": "host str, port int, client RPCClient, call_history List",
    "RPCDebugger": "static methods for debugging RPC issues",
    "SocketDiagnosticsHelper": "diagnostic tracking for socket connections",
    "SerializationDebugger": "static methods for JSON debugging",
    "RequestTrackingDiagnostics": "request correlation debugging",
    "ConnectionDiagnostics": "socket connection diagnostic info",
    "LatencyTracker": "RPC call performance monitoring",
    "ConnectionPool": "host str, port int, max_size int, connections List[socket], pool_lock threading.RLock",
    "AsyncRPCClient": "_event_loop asyncio.AbstractEventLoop, _connection_pool AsyncConnectionPool, _pending_requests Dict[str, asyncio.Future], _response_handler_task asyncio.Task, _request_semaphore asyncio.Semaphore",
    "AuthMiddleware": "jwt_secret str, permission_store PermissionStore, validation_options Dict",
    "CircuitState": "CLOSED, OPEN, HALF_OPEN enum values",
    "CircuitBreaker": "state CircuitState, failure_threshold float, window_size int, timeout_seconds float, sliding_window deque, state_lock threading.RLock",
    "JWTValidator": "secret str, algorithms List[str], options Dict",
    "PermissionStore": "user_permissions Dict[str, Set[str]], method_requirements Dict[str, Set[str]]"
  },
  "methods": {
    "generate_request_id() -> str": "generate unique request identifier",
    "create_request_message(method, params, request_id) -> Dict": "create JSON-RPC request",
    "create_response_message(request_id, result) -> Dict": "create JSON-RPC success response",
    "create_error_message(request_id, code, message, data) -> Dict": "create JSON-RPC error response",
    "serialize_message(message) -> bytes": "convert message dict to bytes",
    "deserialize_message(data) -> Dict": "parse bytes to message dict",
    "send_all(sock, data, timeout)": "send complete message handling partial sends",
    "recv_all(sock, size, timeout) -> bytes": "receive exact byte count",
    "recv_message(sock, timeout) -> bytes": "receive length-prefixed message",
    "register_method(name, method)": "register callable function in server",
    "start_server()": "start TCP server listening loop",
    "handle_connection(client_sock)": "process single client connection",
    "process_request(request) -> Dict": "dispatch request to registered method",
    "send_message(sock, message_bytes, timeout)": "send length-prefixed message",
    "call(method_name, *args, timeout, **kwargs) -> Any": "async RPC call returning awaitable future",
    "_ensure_connected(timeout) -> None": "establish connection if needed",
    "_track_request(request_id, timeout) -> None": "register request for tracking",
    "_wait_for_response(request_id) -> Dict": "block until response or timeout",
    "_cleanup_request(request_id) -> None": "remove request from tracking",
    "_disconnect() -> None": "close connection and cleanup",
    "__getattr__(method_name) -> Callable": "create proxy method for attribute access",
    "_create_method_proxy(method_name) -> Callable": "create callable for RPC method",
    "validate_request_message(message)": "check JSON-RPC request format",
    "validate_response_message(message)": "check JSON-RPC response format",
    "execute_with_retry(operation, operation_name) -> Any": "run operation with retry logic",
    "calculate_delay(attempt) -> float": "exponential backoff calculation",
    "is_retryable_error(error) -> bool": "check if error should trigger retry",
    "handle_socket_error(error, operation, host, port) -> RPCTransportError": "convert socket exceptions to RPC errors",
    "start() -> int": "start test server and return port",
    "stop()": "stop test server and cleanup",
    "call_with_timing(method, params, timeout) -> Dict": "make RPC call with metrics",
    "validate_message_format(message) -> List[str]": "check JSON-RPC format compliance",
    "trace_rpc_call(host, port, method, params)": "debug RPC call with tracing",
    "test_server_connectivity(host, port, timeout) -> Dict": "test basic server connection",
    "test_connectivity(host, port, timeout) -> Dict": "test basic server connectivity",
    "validate_serializable(data, path) -> List[str]": "check data for serialization issues",
    "safe_serialize(data) -> Optional[bytes]": "attempt JSON serialization with error reporting",
    "register_connection(sock) -> None": "register socket for diagnostic tracking",
    "record_send(sock, byte_count) -> None": "record bytes sent on socket",
    "record_receive(sock, byte_count) -> None": "record bytes received on socket",
    "register_request(request_id, method, timeout) -> None": "register request for tracking",
    "mark_response_received(request_id) -> bool": "mark request as completed",
    "mark_timeout(request_id) -> bool": "mark request as timed out",
    "get_diagnostics_summary() -> Dict": "get request tracking summary",
    "start_request(request_id, method) -> None": "record request start time",
    "end_request(request_id, method) -> None": "record request completion time",
    "get_latency_stats(method) -> Dict": "get latency statistics",
    "borrow_connection(timeout) contextmanager": "thread-safe connection borrowing from pool",
    "_create_connection() -> socket": "establish new TCP connection to server",
    "_health_check_worker()": "background thread for connection health monitoring",
    "_ensure_connected() -> None": "establish asyncio connection if needed",
    "_response_handler()": "background coroutine processing responses",
    "process_request(request_message) -> Optional[Dict]": "validate authentication and return error if unauthorized",
    "_validate_jwt_token(token) -> Optional[Dict]": "decode and validate JWT token",
    "_check_method_permission(user_claims, method_name) -> bool": "verify user permissions for method",
    "call(func, *args, **kwargs) -> Any": "execute function with circuit breaker protection",
    "_update_circuit_state()": "transition circuit state based on failure rate",
    "_record_result(success)": "add success/failure to sliding window"
  },
  "constants": {
    "PARSE_ERROR": "-32700",
    "INVALID_REQUEST": "-32600",
    "METHOD_NOT_FOUND": "-32601",
    "INVALID_PARAMS": "-32602",
    "INTERNAL_ERROR": "-32603",
    "TRANSPORT_ERROR": "-32000",
    "TIMEOUT_ERROR": "-32001",
    "CONNECTION_ERROR": "-32002",
    "MAX_MESSAGE_SIZE": "1048576 bytes maximum message size",
    "CLOSED": "circuit breaker normal operation state",
    "OPEN": "circuit breaker failure prevention state",
    "HALF_OPEN": "circuit breaker recovery testing state"
  },
  "terms": {
    "JSON-RPC": "lightweight remote procedure call protocol using JSON",
    "message framing": "technique to delimit messages in byte streams",
    "length prefix": "4-byte header indicating message size",
    "request ID": "unique identifier for correlating requests and responses",
    "method registry": "mapping of function names to callable handlers",
    "proxy object": "client-side object that converts method calls to RPC requests",
    "wire format": "serialized message format sent over network",
    "method proxying": "converting method calls to RPC requests transparently",
    "connection management": "handling TCP socket lifecycle and reuse",
    "request dispatch": "routing requests to registered methods",
    "thread-per-connection": "threading model with one thread per client",
    "receptionist pattern": "server as message router to appropriate handlers",
    "request tracking": "correlating responses with originating requests",
    "timeout handling": "preventing infinite blocking on unresponsive servers",
    "secretary pattern": "client as intermediary handling communication complexity",
    "connection reuse": "using single persistent connection for multiple requests",
    "response correlation": "matching incoming responses to pending requests",
    "connection health check": "detecting dead or broken network connections",
    "error propagation": "transmitting error information from server back to client",
    "exponential backoff": "retry delay strategy that increases delay between attempts",
    "structured errors": "error objects with consistent fields and diagnostic information",
    "retry logic": "automatic re-execution of failed operations",
    "error categorization": "classifying errors by type and appropriate handling",
    "graceful degradation": "system continues operating with reduced functionality during errors",
    "integration testing": "testing component interactions under realistic conditions",
    "stress testing": "validating performance under high load conditions",
    "load testing": "measuring system behavior under expected traffic patterns",
    "end-to-end testing": "complete workflow validation from client to server",
    "deadlock": "circular waiting condition between threads",
    "race condition": "timing-dependent bug in concurrent code",
    "connection pooling": "maintaining reusable TCP connections to avoid handshake overhead",
    "asyncio integration": "non-blocking RPC calls using Python's async/await syntax",
    "binary serialization": "efficient message encoding using formats like MessagePack",
    "JWT authentication": "stateless token-based authentication with embedded claims",
    "TLS transport security": "encryption of all network traffic using Transport Layer Security",
    "circuit breaker": "failure prevention pattern that stops calls to unresponsive services",
    "method-level authorization": "fine-grained permission control over individual RPC methods",
    "sliding window": "moving time-based sample of recent success/failure rates",
    "connection health checking": "periodic validation that pooled connections are still usable"
  }
}