{
  "title": "RPC Framework: Design Document",
  "overview": "This system implements a simple Remote Procedure Call (RPC) framework that allows clients to invoke functions on remote servers as if they were local method calls. The key architectural challenge is transparently handling network communication, serialization, and error propagation while maintaining the illusion of local function invocation.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Defines the core RPC problem using postal service analogy and compares different approaches to distributed function calls.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "Mental Model: The Postal Service Analogy",
          "summary": "Explains RPC concepts using familiar postal service operations"
        },
        {
          "id": "existing-approaches",
          "title": "Existing RPC Approaches",
          "summary": "Compares REST APIs, gRPC, JSON-RPC, and message queues for remote communication"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Clearly defines what this educational RPC framework will and will not implement.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Core RPC features this system must support"
        },
        {
          "id": "non-goals",
          "title": "Non-Goals",
          "summary": "Advanced features explicitly excluded from this implementation"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Overview of the three main components: message protocol, server, and client with their interactions.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "Responsibilities of protocol, server, and client components"
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "How to organize the Python codebase across modules"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Message Protocol Design",
      "summary": "Defines the JSON-RPC inspired message format for requests, responses, and errors with serialization strategy.",
      "subsections": [
        {
          "id": "message-formats",
          "title": "Message Formats",
          "summary": "Request, response, and error message structure definitions"
        },
        {
          "id": "serialization-strategy",
          "title": "Serialization Strategy",
          "summary": "JSON encoding choices and parameter type handling"
        }
      ]
    },
    {
      "id": "server-design",
      "title": "Server Component Design",
      "summary": "The RPC server that registers methods, accepts connections, and dispatches requests to registered functions.",
      "subsections": [
        {
          "id": "server-mental-model",
          "title": "Mental Model: The Receptionist Pattern",
          "summary": "Understanding the server as a receptionist routing calls to departments"
        },
        {
          "id": "method-registry",
          "title": "Method Registry",
          "summary": "How functions are registered and looked up by name"
        },
        {
          "id": "request-dispatch",
          "title": "Request Dispatch Algorithm",
          "summary": "Step-by-step process for handling incoming RPC requests"
        },
        {
          "id": "server-architecture-decisions",
          "title": "Architecture Decision Records",
          "summary": "Key decisions about threading, connection handling, and error responses"
        },
        {
          "id": "server-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Typical mistakes when implementing the server component"
        }
      ]
    },
    {
      "id": "client-design",
      "title": "Client Component Design",
      "summary": "The RPC client that provides method proxying and manages network communication with timeout handling.",
      "subsections": [
        {
          "id": "client-mental-model",
          "title": "Mental Model: The Secretary Pattern",
          "summary": "Understanding the client as a secretary making calls on your behalf"
        },
        {
          "id": "method-proxying",
          "title": "Method Proxying",
          "summary": "How to create a proxy object that converts method calls to RPC requests"
        },
        {
          "id": "connection-management",
          "title": "Connection Management",
          "summary": "TCP socket lifecycle and connection reuse strategies"
        },
        {
          "id": "timeout-handling",
          "title": "Timeout and ID Tracking",
          "summary": "Managing request IDs and handling call timeouts"
        },
        {
          "id": "client-architecture-decisions",
          "title": "Architecture Decision Records",
          "summary": "Key decisions about blocking vs async calls and connection pooling"
        },
        {
          "id": "client-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Typical mistakes when implementing the client component"
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Interactions and Data Flow",
      "summary": "Complete walkthrough of a typical RPC call from client method invocation to response handling.",
      "subsections": [
        {
          "id": "call-sequence",
          "title": "RPC Call Sequence",
          "summary": "Step-by-step flow of a successful remote procedure call"
        },
        {
          "id": "error-flow",
          "title": "Error Flow",
          "summary": "How errors propagate from server back to client"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Comprehensive error handling strategy covering network failures, method errors, and serialization issues.",
      "subsections": [
        {
          "id": "error-categories",
          "title": "Error Categories",
          "summary": "Types of errors and their appropriate handling strategies"
        },
        {
          "id": "network-failures",
          "title": "Network Failure Handling",
          "summary": "Connection drops, timeouts, and socket errors"
        },
        {
          "id": "serialization-errors",
          "title": "Serialization Error Handling",
          "summary": "Invalid JSON, type conversion failures, and encoding issues"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Testing approach for each milestone with checkpoint verification and integration test scenarios.",
      "subsections": [
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "What behavior to verify after implementing each milestone"
        },
        {
          "id": "integration-scenarios",
          "title": "Integration Test Scenarios",
          "summary": "End-to-end scenarios to test the complete RPC framework"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common symptoms, causes, and fixes for issues learners encounter when building the RPC framework.",
      "subsections": [
        {
          "id": "connection-issues",
          "title": "Connection and Network Issues",
          "summary": "Diagnosing TCP connection problems and socket errors"
        },
        {
          "id": "serialization-debugging",
          "title": "Serialization and Protocol Issues",
          "summary": "Debugging JSON encoding problems and message format errors"
        },
        {
          "id": "timing-issues",
          "title": "Timing and Concurrency Issues",
          "summary": "Debugging timeouts, blocking calls, and race conditions"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Possible enhancements like authentication, load balancing, and async support that build on this foundation.",
      "subsections": [
        {
          "id": "performance-extensions",
          "title": "Performance Extensions",
          "summary": "Connection pooling, async support, and binary serialization"
        },
        {
          "id": "reliability-extensions",
          "title": "Reliability Extensions",
          "summary": "Authentication, encryption, and retry mechanisms"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of key RPC and networking terms used throughout this document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-overview",
      "title": "RPC Framework System Overview",
      "description": "Shows the three main components (Client, Network, Server) and their relationships. Include client proxy, network transport, server registry, and registered methods.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-data-flow"
      ]
    },
    {
      "id": "message-formats",
      "title": "Message Protocol Structure",
      "description": "Illustrates the structure of request messages, response messages, and error messages with their required fields and relationships.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "rpc-call-sequence",
      "title": "RPC Call Sequence",
      "description": "Shows the complete flow of an RPC call from client method invocation through network transport to server execution and response. Include all message exchanges and error paths.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-data-flow",
        "server-design",
        "client-design"
      ]
    },
    {
      "id": "server-state-machine",
      "title": "Server Connection State Machine",
      "description": "Depicts the states a server connection goes through: listening, connected, processing request, sending response, and error states.",
      "type": "state-machine",
      "relevant_sections": [
        "server-design",
        "error-handling"
      ]
    },
    {
      "id": "client-state-machine",
      "title": "Client Request State Machine",
      "description": "Shows client request states: connecting, sending request, waiting for response, receiving response, timeout, and error handling.",
      "type": "state-machine",
      "relevant_sections": [
        "client-design",
        "error-handling"
      ]
    },
    {
      "id": "request-dispatch-flow",
      "title": "Server Request Dispatch Flowchart",
      "description": "Flowchart showing the server's request processing algorithm: parse message, lookup method, validate parameters, execute, handle errors, send response.",
      "type": "flowchart",
      "relevant_sections": [
        "server-design",
        "error-handling"
      ]
    },
    {
      "id": "error-handling-flow",
      "title": "Error Handling Flowchart",
      "description": "Decision tree for handling different types of errors: network errors, serialization errors, method not found, execution errors, and timeout errors.",
      "type": "flowchart",
      "relevant_sections": [
        "error-handling",
        "debugging-guide"
      ]
    }
  ]
}