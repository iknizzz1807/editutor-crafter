{
  "types": {
    "ServiceInstance": "fields: Name string, Host string, Port int, Tags []string, HealthEndpoint string",
    "HealthStatus": "fields: Status string, LastCheck time.Time, FailureCount int, ResponseTime time.Duration, LastError string",
    "ServiceRegistry": "fields: services map, health_checker component, config Config",
    "Config": "fields: Port, Host, HealthCheckInterval, HealthTimeout, MaxFailures, TTL, CleanupInterval",
    "RegistryEntry": "fields: Instance ServiceInstance, Health HealthStatus, RegisteredAt time.Time, InstanceID string",
    "ServiceList": "fields: ServiceName string, Instances []ServiceInstance, TotalCount int, HealthyCount int",
    "ErrorResponse": "fields: error string, error_code string, details map",
    "SuccessResponse": "fields: success bool, data interface{}, message string",
    "RegistryStats": "fields: TotalServices int, TotalInstances int, HealthyInstances int, HealthBreakdown map, LastCleanup time.Time",
    "HealthChecker": "fields: scheduler, client, config, stats, running",
    "HealthCheckScheduler": "fields: registry, client, checkInterval, maxFailures, scheduledChecks",
    "HealthCheckClient": "fields: client, timeout",
    "ScheduledCheck": "fields: InstanceID, ServiceName, NextCheck, Interval, FailureCount",
    "HealthStats": "fields: TotalChecksPerformed, TotalFailures, TotalSuccesses, AverageResponseTime, LastCheckTime, CurrentlyHealthy, CurrentlyUnhealthy",
    "Server": "fields: registry, healthChecker, config, httpServer",
    "FlowCoordinator": "fields: registry, healthChecker, config, logger",
    "FlowContext": "fields: RequestID, StartTime, ClientAddr, Metadata, ErrorDetails",
    "RegistrationResult": "fields: InstanceID string, HealthEndpoint string, NextHealthCheck time.Time, RegistrationTime time.Time, TTLExpiration time.Time",
    "LookupResult": "fields: ServiceName string, Instances []ServiceInstance, TotalCount int, HealthyCount int, LastUpdated time.Time, CacheHit bool, LookupDuration time.Duration",
    "HealthCheckCycleResult": "fields: ChecksPerformed, SuccessfulChecks, FailedChecks, AverageLatency, CycleDuration, ErrorDetails",
    "HealthCheckWorker": "fields: id, workChan, registry, checker, results",
    "HealthCheckResult": "fields: InstanceID string, ServiceName string, Success bool, ResponseTime time.Duration, StatusCode int, Error string, CheckTime time.Time",
    "FailurePattern": "fields: FailureType, Count, FirstOccurred, LastOccurred, RecoveryTime",
    "OverloadEvent": "fields: Timestamp, ResourceType, Utilization, Duration",
    "RecoveryState": "fields: Phase, StartTime, ComponentStates, OverallProgress",
    "ComponentState": "fields: Status, Progress, LastUpdated, ErrorCount",
    "PartitionInfo": "fields: SegmentID, Services, PartitionTime, RecoveryTime",
    "ConnectionPool": "fields: activeConns, maxConns, idleConns, healthyConns",
    "ErrorClassifier": "fields: networkTimeouts, serviceFailures, systemOverloads",
    "RateLimiter": "fields: tokens, capacity, refillRate, lastRefill, requestCounts, globalLimit",
    "SystemMonitor": "fields: cpuThreshold, memoryThreshold, degradationLevel, lastCheck",
    "RecoveryCoordinator": "fields: registry, healthChecker, server, recoveryState, mutex",
    "NetworkFailureHandler": "fields: timeoutThresholds, partitionedSegments, connectionPools",
    "MockService": "fields: server, healthy, delay, statusCode, mutex",
    "TestConfig": "configuration structure for testing",
    "RegistryDebugInfo": "fields: Timestamp time.Time, TotalServices int, TotalInstances int, HealthyInstances int, Services map, SystemStats SystemStats",
    "ServiceInfo": "fields: InstanceID string, Host string, Port int, HealthStatus string, LastCheck time.Time, FailureCount int, RegisteredAt time.Time, ResponseTime time.Duration",
    "SystemStats": "fields: UptimeSeconds int64, MemoryUsageMB float64, GoroutineCount int, LastCleanupTime time.Time",
    "HealthCheckTracer": "fields: logger",
    "ServiceDiscoveryLogger": "fields: logger",
    "ClusterNode": "fields: NodeID string, Address string, Role string, Status string, LastSeen time.Time",
    "ClusterConfig": "fields: Nodes []ClusterNode, ReplicationFactor int, ConsensusTimeout time.Duration",
    "ReplicationEntry": "fields: Operation string, Data interface{}, Timestamp time.Time, NodeID string",
    "ConsensusResult": "fields: Success bool, LeaderID string, Term int64, CommittedIndex int64",
    "ServiceIdentity": "fields: ServiceName string, Credentials string, Permissions []string, ExpiresAt time.Time",
    "AccessToken": "fields: TokenID string, ServiceID string, Permissions []string, IssuedAt time.Time, ExpiresAt time.Time",
    "SecurityPolicy": "fields: AllowedServices []string, RequiredPermissions map[string][]string, TokenTTL time.Duration",
    "AuditLogEntry": "fields: Timestamp time.Time, ServiceID string, Operation string, Resource string, Success bool, ClientIP string",
    "HealthCheckProtocol": "interface for different health check protocols",
    "ClusterManager": "component for coordinating cluster communication",
    "ConsensusEngine": "component for distributed consensus decisions",
    "DistributedHealthChecker": "extension of HealthChecker for clustered environments",
    "TermDefinition": "fields: Term string, Definition string, Category string, Aliases []string, SeeAlso []string, Examples []string",
    "GlossaryManager": "fields: terms map, categories map",
    "DocumentationGenerator": "fields: glossary *GlossaryManager, templates map"
  },
  "methods": {
    "Register(instance) returns": "adds service instance to registry with unique ID",
    "Deregister(serviceId) returns": "removes service instance from registry",
    "Lookup(serviceName) returns": "finds healthy instances of service",
    "HealthCheck(instance) returns": "performs health verification",
    "LoadConfig() returns": "reads configuration from multiple sources",
    "UpdateHealth(serviceName, instanceID, status) returns": "updates health status for instance",
    "GetAllServices() returns": "returns complete registry snapshot",
    "WriteJSONResponse(w, statusCode, data)": "sends JSON HTTP response",
    "WriteErrorResponse(w, statusCode, message)": "sends standardized error",
    "WriteSuccessResponse(w, data)": "sends standardized success response",
    "ValidateServiceInstance(instance) returns": "checks all input constraints",
    "NewServiceRegistry(config) returns": "creates initialized registry",
    "Deregister(instanceID) returns": "removes service instance from registry",
    "CheckServiceHealth(instance) returns": "performs health verification on service instance",
    "NewHealthChecker(registry, config) returns": "creates health checker with configuration",
    "Start(ctx) returns": "begins health checking background process",
    "Stop() returns": "gracefully shuts down health checking",
    "UpdateCheckInterval(serviceName, interval) returns": "modifies check frequency for service",
    "GetHealthStats() returns": "returns aggregate health statistics",
    "ScheduleHealthCheck(instanceID, instance)": "adds instance to checking schedule",
    "UnscheduleHealthCheck(instanceID)": "removes instance from checking schedule",
    "NewServer(registry, healthChecker, config) returns": "creates configured HTTP server",
    "Start() returns": "begins serving HTTP requests",
    "Stop(ctx) returns": "gracefully shuts down HTTP server",
    "setupRoutes(mux)": "configures all API endpoints",
    "handleServices(w, r)": "routes between POST register and GET list all",
    "handleServiceRegistration(w, r)": "processes POST /services requests",
    "handleListAllServices(w, r)": "processes GET /services requests",
    "handleServicesWithPath(w, r)": "routes requests to specific services",
    "handleServiceLookup(w, r, serviceName)": "processes GET /services/{name} requests",
    "handleServiceDeregistration(w, r, serviceName, instanceID)": "processes DELETE requests",
    "handleSystemHealth(w, r)": "processes GET /health requests",
    "ExecuteRegistrationFlow(ctx, instance) returns": "orchestrates complete service registration",
    "ExecuteLookupFlow(ctx, serviceName) returns": "handles service discovery with caching",
    "ExecuteHealthCheckFlow(ctx) returns": "runs single health check cycle",
    "RollbackRegistration(instanceID) returns": "removes partially registered service",
    "AllowRequest(clientID) returns": "checks if request should be allowed based on rate limits",
    "CheckSystemHealth() returns": "evaluates system health and returns degradation level",
    "ExecuteRecovery(ctx) returns": "coordinates recovery of all system components",
    "HandleNetworkPartition(segmentID, affectedServices)": "manages registry state during network partitions",
    "DetectPartitionRecovery(segmentID) returns": "monitors for network partition recovery",
    "NewErrorClassifier() returns": "creates initialized error classifier",
    "NewRateLimiter(capacity, refillRate, globalLimit) returns": "creates rate limiter with specified parameters",
    "NewSystemMonitor(cpuThreshold, memoryThreshold) returns": "creates system monitor with thresholds",
    "NewRecoveryCoordinator(registry, healthChecker, server) returns": "creates recovery coordinator for components",
    "NewMockService() returns": "creates controllable mock service for testing",
    "SetHealthy(healthy bool)": "controls mock service health status",
    "SetDelay(delay time.Duration)": "adds artificial delay to mock responses",
    "TestConfig() returns": "returns configuration suitable for testing",
    "WaitForHealthCheck(interval)": "waits for health checking cycle completion",
    "CreateTestServiceInstance(name, host, port) returns": "creates valid ServiceInstance for testing",
    "NewDebugServer(registry, healthChecker, port) returns": "creates HTTP server for debugging endpoints",
    "TraceHealthCheck(ctx, instanceID, serviceInstance) returns": "logs comprehensive information about health check execution",
    "LogHealthTransition(instanceID, serviceName, oldStatus, newStatus, failureCount)": "logs when service health status changes",
    "NewServiceDiscoveryLogger() returns": "creates logger with service discovery specific configuration",
    "LogServiceRegistration(ctx, instance, result, success)": "logs service registration with comprehensive details",
    "LogHealthCheck(instanceID, result)": "logs health check execution with timing and result details",
    "LogServiceLookup(serviceName, result)": "logs service discovery requests and results",
    "ValidateTerminology(text) returns": "checks terminology consistency",
    "GetDefinition(term) returns": "retrieves term definition",
    "GenerateAPIDocumentation(endpoints) returns": "creates API docs with terminology",
    "GenerateGlossaryHTML(categories) returns": "creates interactive glossary"
  },
  "constants": {
    "TTL": "time-to-live for service registrations",
    "HEALTH_CHECK_INTERVAL": "frequency of health verification",
    "CleanupInterval": "frequency of expired registration cleanup",
    "MaxFailures": "consecutive failures before marking unhealthy",
    "HealthTimeout": "timeout for health check requests"
  },
  "terms": {
    "service discovery": "mechanism for services to find and communicate with each other",
    "health checking": "monitoring service availability and responsiveness",
    "service registry": "central database of available service instances",
    "sidecar proxy": "auxiliary process deployed alongside main service",
    "service mesh": "infrastructure layer handling service communication",
    "service instance": "single running instance of a service",
    "health status": "current availability state of service instance",
    "registry core": "central component managing service data",
    "health checker": "background component monitoring service health",
    "HTTP API layer": "REST interface for registry operations",
    "instance identity": "unique identifier for each service registration",
    "concurrent access": "multiple operations accessing shared data simultaneously",
    "TTL handling": "automatic cleanup of expired service registrations",
    "failure threshold": "number of consecutive failures before marking unhealthy",
    "check scheduling": "timing coordination of health verification operations",
    "health endpoint": "HTTP endpoint that reports service health status",
    "failure count": "number of consecutive failed health checks",
    "check interval": "time between health verification attempts",
    "REST API": "representational state transfer application programming interface",
    "JSON serialization": "converting data structures to JavaScript Object Notation",
    "request validation": "verifying input data meets requirements",
    "error handling": "managing and responding to failure conditions",
    "concurrent requests": "multiple simultaneous API operations",
    "middleware": "software components that process requests before handlers",
    "graceful shutdown": "orderly termination of server with cleanup",
    "cascade failure": "failure of one service triggering failures in dependent services",
    "network partition": "loss of network connectivity between system components",
    "graceful degradation": "selective reduction of service quality",
    "false positive": "incorrectly identifying healthy service as failed",
    "failure isolation": "preventing problems from spreading to other system components",
    "progressive timeout handling": "graduated response to timeouts based on failure patterns",
    "adaptive rate limiting": "dynamic request limiting based on system performance",
    "recovery coordination": "orchestrated restoration of system functionality after failures",
    "token bucket algorithm": "rate limiting technique using token consumption model",
    "circuit breaker": "pattern for preventing calls to failing services",
    "system overload": "condition where system resources are overwhelmed by demand",
    "error classification": "categorization of different types of failures for appropriate handling",
    "unit testing": "testing individual components in isolation with mocks and test data",
    "integration testing": "end-to-end workflows and component interaction testing",
    "milestone validation": "comprehensive checkpoints verifying complete milestone functionality",
    "test doubles": "mock objects and stubs used to replace dependencies in testing",
    "component isolation": "testing strategy that focuses on single components without external dependencies",
    "concurrent operation testing": "verification that multiple simultaneous operations work correctly",
    "network failure simulation": "testing system behavior under various network failure conditions",
    "load testing": "verification of system performance under high volume conditions",
    "data consistency validation": "ensuring data remains accurate across system components",
    "automated validation": "test suites that run milestone checkpoints automatically",
    "test infrastructure": "reusable testing utilities and mock services",
    "failure injection": "deliberately causing failures to test error handling",
    "boundary condition testing": "testing behavior at configuration limits and edge cases",
    "mock service": "controllable test service that simulates real service behavior",
    "structured logging": "logging with consistent formats and fields",
    "distributed tracing": "tracking request flows across multiple services",
    "registry state": "current data about all registered services and their health",
    "health check tracing": "detailed logging of health verification operations",
    "race conditions": "timing-dependent bugs in concurrent operations",
    "cascading failures": "failure of one service triggering failures in dependent services",
    "log aggregation": "collecting and centralizing log data from multiple sources",
    "observability": "ability to understand system internal state from external outputs",
    "correlation ID": "unique identifier linking related operations across components",
    "clustering": "distributing registry data across multiple nodes for high availability",
    "consensus protocol": "algorithm for ensuring distributed nodes agree on data changes",
    "split-brain scenario": "situation where multiple partitions believe they're authoritative",
    "mutual TLS": "authentication where both parties verify each other's certificates",
    "composite health status": "health reporting with multiple dimensions per service",
    "adaptive health checking": "adjusting check frequency based on service behavior patterns",
    "weighted load balancing": "traffic distribution based on instance capacity",
    "canary deployment": "gradual rollout strategy using traffic splitting",
    "hot configuration updates": "runtime configuration changes without service restart"
  }
}