{
  "title": "Signal Handler: Design Document",
  "overview": "This system implements robust Unix signal handling that integrates asynchronously delivered signals with synchronous event loops. The key architectural challenge is bridging the gap between the unsafe, limited context of signal handlers and the full processing capabilities of the main application loop.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains why signal handling is complex and compares different approaches to managing asynchronous signals in Unix systems.",
      "subsections": [
        {
          "id": "signal-analogy",
          "title": "Mental Model: Emergency Interruptions",
          "summary": "Uses the analogy of emergency interruptions in daily life to explain signal delivery"
        },
        {
          "id": "signal-challenges",
          "title": "Core Challenges",
          "summary": "Why signals are difficult: async-signal-safety, reentrancy, and timing issues"
        },
        {
          "id": "existing-approaches",
          "title": "Existing Signal Handling Approaches",
          "summary": "Comparison table of signal(), sigaction(), signalfd(), and self-pipe approaches"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what the signal handler system must accomplish and explicitly excludes out-of-scope features.",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Requirements",
          "summary": "Signal capture, graceful shutdown, and event loop integration"
        },
        {
          "id": "non-functional-goals",
          "title": "Quality Requirements",
          "summary": "Reliability, portability, and performance characteristics"
        },
        {
          "id": "explicit-non-goals",
          "title": "Non-Goals",
          "summary": "Real-time guarantees, signal queuing, and advanced IPC features"
        }
      ]
    },
    {
      "id": "architecture",
      "title": "High-Level Architecture",
      "summary": "Overview of the three-layer architecture: signal capture, signal-to-event translation, and event processing.",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Responsibilities",
          "summary": "Signal handler, signal mask manager, self-pipe mechanism, and event dispatcher"
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "How to organize signal handling code across modules and headers"
        },
        {
          "id": "data-flow",
          "title": "Signal Processing Flow",
          "summary": "Step-by-step flow from signal delivery to application response"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Defines the key data structures for signal information, handler state, and event loop integration.",
      "subsections": [
        {
          "id": "signal-info",
          "title": "Signal Information Types",
          "summary": "Signal numbers, handler functions, and signal-specific metadata"
        },
        {
          "id": "handler-state",
          "title": "Handler State Management",
          "summary": "Registered handlers, signal masks, and pending signal tracking"
        },
        {
          "id": "pipe-communication",
          "title": "Self-Pipe Data Structures",
          "summary": "Pipe descriptors and signal notification format"
        }
      ]
    },
    {
      "id": "signal-registration",
      "title": "Signal Registration Component",
      "summary": "Handles installing signal handlers using sigaction() with proper flags and error handling. Corresponds to Milestone 1.",
      "subsections": [
        {
          "id": "registration-mental-model",
          "title": "Mental Model: Emergency Contact Registration",
          "summary": "Analogy of registering emergency contacts who know how to reach you"
        },
        {
          "id": "sigaction-interface",
          "title": "Sigaction Interface Design",
          "summary": "Function signatures and parameter tables for signal registration"
        },
        {
          "id": "registration-algorithm",
          "title": "Registration Algorithm",
          "summary": "Step-by-step process for installing signal handlers safely"
        },
        {
          "id": "registration-adrs",
          "title": "Architecture Decisions",
          "summary": "Why sigaction() over signal(), SA_RESTART flag usage, and handler function design"
        },
        {
          "id": "registration-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Non-reentrant functions, race conditions, and missing flags"
        },
        {
          "id": "registration-implementation",
          "title": "Implementation Guidance",
          "summary": "C code structure, technology choices, and skeleton functions"
        }
      ]
    },
    {
      "id": "signal-masking",
      "title": "Signal Masking Component",
      "summary": "Manages blocking and unblocking signals during critical sections using sigprocmask(). Corresponds to Milestone 2.",
      "subsections": [
        {
          "id": "masking-mental-model",
          "title": "Mental Model: Do Not Disturb Mode",
          "summary": "Analogy of temporarily blocking interruptions during important tasks"
        },
        {
          "id": "mask-operations",
          "title": "Mask Operation Interface",
          "summary": "Functions for blocking, unblocking, and querying signal masks"
        },
        {
          "id": "critical-sections",
          "title": "Critical Section Protection",
          "summary": "Algorithm for safely protecting code sections from signal interruption"
        },
        {
          "id": "masking-adrs",
          "title": "Architecture Decisions",
          "summary": "sigprocmask() vs pthread_sigmask(), nested blocking strategy, and pending signal handling"
        },
        {
          "id": "masking-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Forgetting to unblock, deadlock scenarios, and thread safety issues"
        },
        {
          "id": "masking-implementation",
          "title": "Implementation Guidance",
          "summary": "Mask manipulation utilities and critical section wrappers"
        }
      ]
    },
    {
      "id": "self-pipe",
      "title": "Self-Pipe Integration Component",
      "summary": "Implements the self-pipe trick to safely integrate signals with event loops. Corresponds to Milestone 3.",
      "subsections": [
        {
          "id": "self-pipe-mental-model",
          "title": "Mental Model: Emergency Notification System",
          "summary": "Analogy of converting urgent interruptions into regular message delivery"
        },
        {
          "id": "pipe-setup",
          "title": "Pipe Creation and Configuration",
          "summary": "Creating non-blocking pipe pairs and integrating with file descriptors"
        },
        {
          "id": "signal-to-pipe",
          "title": "Signal-to-Pipe Translation",
          "summary": "Algorithm for safely writing signal notifications from handler to pipe"
        },
        {
          "id": "event-loop-integration",
          "title": "Event Loop Integration",
          "summary": "Monitoring pipe alongside other descriptors using select() or poll()"
        },
        {
          "id": "self-pipe-adrs",
          "title": "Architecture Decisions",
          "summary": "Pipe vs eventfd, notification format, and signal coalescing strategy"
        },
        {
          "id": "self-pipe-pitfalls",
          "title": "Common Pitfalls",
          "summary": "Pipe buffer overflow, blocking writes, and signal loss"
        },
        {
          "id": "self-pipe-implementation",
          "title": "Implementation Guidance",
          "summary": "Event loop structure and signal integration utilities"
        }
      ]
    },
    {
      "id": "interactions-dataflow",
      "title": "Interactions and Data Flow",
      "summary": "Describes how components communicate and the complete sequence from signal delivery to application response.",
      "subsections": [
        {
          "id": "component-communication",
          "title": "Component Communication Patterns",
          "summary": "How signal handlers, mask managers, and event loops interact"
        },
        {
          "id": "signal-delivery-sequence",
          "title": "Signal Delivery Sequence",
          "summary": "Step-by-step walkthrough of signal processing from kernel to application"
        },
        {
          "id": "event-loop-integration-flow",
          "title": "Event Loop Integration Flow",
          "summary": "How signals are multiplexed with other I/O events"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Covers failure modes in signal handling, detection strategies, and recovery mechanisms.",
      "subsections": [
        {
          "id": "signal-handler-errors",
          "title": "Signal Handler Error Cases",
          "summary": "Handler registration failures and runtime signal delivery issues"
        },
        {
          "id": "mask-operation-errors",
          "title": "Mask Operation Failures",
          "summary": "sigprocmask() errors and mask state inconsistencies"
        },
        {
          "id": "pipe-communication-errors",
          "title": "Pipe Communication Failures",
          "summary": "Pipe creation, write failures, and buffer overflow scenarios"
        },
        {
          "id": "recovery-strategies",
          "title": "Recovery and Fallback Strategies",
          "summary": "How to handle failures gracefully and maintain system stability"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Defines testing approaches for signal handling behavior and milestone verification checkpoints.",
      "subsections": [
        {
          "id": "unit-testing",
          "title": "Unit Testing Approach",
          "summary": "Testing individual components with mock signals and controlled environments"
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing",
          "summary": "End-to-end signal handling with real signal delivery and timing"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification Checkpoints",
          "summary": "Expected behavior and verification steps after each milestone implementation"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common problems encountered when implementing signal handling and systematic debugging approaches.",
      "subsections": [
        {
          "id": "symptom-diagnosis",
          "title": "Symptom-Based Debugging Table",
          "summary": "Maps common symptoms to likely causes and diagnostic steps"
        },
        {
          "id": "debugging-tools",
          "title": "Signal Debugging Tools and Techniques",
          "summary": "Using strace, gdb, and logging to debug signal handling issues"
        },
        {
          "id": "race-condition-debugging",
          "title": "Race Condition Detection",
          "summary": "Identifying and debugging timing-related signal handling bugs"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements like real-time signals, advanced IPC integration, and performance optimizations.",
      "subsections": [
        {
          "id": "advanced-signals",
          "title": "Advanced Signal Features",
          "summary": "Real-time signals, signal queuing, and signal-specific data"
        },
        {
          "id": "performance-optimizations",
          "title": "Performance Enhancements",
          "summary": "signalfd(), eventfd() integration, and multi-threaded signal handling"
        },
        {
          "id": "framework-integration",
          "title": "Framework Integration",
          "summary": "Integration with async frameworks and higher-level abstractions"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of technical terms, acronyms, and domain-specific vocabulary used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "System Component Architecture",
      "description": "Shows the main components (Signal Handler Registry, Signal Mask Manager, Self-Pipe Mechanism, Event Loop) and their relationships. Includes data flow arrows showing signal delivery path from kernel to application.",
      "type": "component",
      "relevant_sections": [
        "architecture",
        "interactions-dataflow"
      ]
    },
    {
      "id": "signal-delivery-sequence",
      "title": "Signal Delivery Sequence",
      "description": "Sequence diagram showing the complete flow: Kernel delivers signal \u2192 Signal handler executes \u2192 Write to pipe \u2192 Event loop detects \u2192 Application processes. Shows timing and async nature.",
      "type": "sequence",
      "relevant_sections": [
        "interactions-dataflow",
        "self-pipe"
      ]
    },
    {
      "id": "signal-handler-state",
      "title": "Signal Handler State Machine",
      "description": "State transitions for signal handlers: Unregistered \u2192 Registered \u2192 Blocked \u2192 Pending \u2192 Delivered. Shows state changes based on registration, masking, and delivery events.",
      "type": "state-machine",
      "relevant_sections": [
        "signal-registration",
        "signal-masking"
      ]
    },
    {
      "id": "data-model",
      "title": "Signal Handling Data Structures",
      "description": "Class diagram showing key data structures: SignalHandler, SignalMask, PipeNotification, and EventDescriptor. Shows relationships and key fields for each structure.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "self-pipe-flow",
      "title": "Self-Pipe Trick Flow",
      "description": "Flowchart showing decision tree in signal handler: Check if pipe available \u2192 Write signal byte \u2192 Handle EAGAIN \u2192 Continue. Parallel flow showing event loop reading pipe.",
      "type": "flowchart",
      "relevant_sections": [
        "self-pipe"
      ]
    },
    {
      "id": "critical-section-flow",
      "title": "Critical Section Signal Masking",
      "description": "Flowchart showing the algorithm for protecting critical sections: Save current mask \u2192 Block signals \u2192 Execute critical code \u2192 Check pending \u2192 Restore mask \u2192 Handle pending.",
      "type": "flowchart",
      "relevant_sections": [
        "signal-masking"
      ]
    },
    {
      "id": "event-loop-integration",
      "title": "Event Loop Integration Architecture",
      "description": "Component diagram showing how signal pipe integrates with existing event loop infrastructure: Socket descriptors, Timer descriptors, Signal pipe, and select/poll multiplexer.",
      "type": "component",
      "relevant_sections": [
        "self-pipe",
        "interactions-dataflow"
      ]
    },
    {
      "id": "error-handling-flow",
      "title": "Signal Error Handling Flowchart",
      "description": "Decision tree for handling various error conditions: Handler registration failure \u2192 Mask operation failure \u2192 Pipe write failure. Shows recovery paths and fallback strategies.",
      "type": "flowchart",
      "relevant_sections": [
        "error-handling"
      ]
    }
  ]
}