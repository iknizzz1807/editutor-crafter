direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  hardware_reg: {
    shape: rectangle
    width: 120
    style: {
      fill: "#f0f0f0"
      stroke: "#333"
      border-radius: 4
      shadow: true
    }
  }
  logic_gate: {
    shape: diamond
    width: 150
    style: {
      fill: "#e6fffa"
      stroke: "#2c7a7b"
      font-size: 14
    }
  }
  os_check: {
    shape: step
    style: {
      fill: "#fff5f5"
      stroke: "#c53030"
      font-size: 14
    }
  }
  state_block: {
    shape: class
    style: {
      fill: "#ebf8ff"
      stroke: "#2b6cb0"
    }
  }
}

Entry: "Application Startup" {
  shape: rectangle
  style.border-radius: 99
  link: "#anchor-foundation"
}

Instruction: "CPUID Instruction (Leaf 1)" {
  shape: package
  link: "#anchor-foundation"
  style.stroke-width: 2
}

Entry -> Instruction: "Invokes detection"

Registers: "Register Bank" {
  link: "#anchor-foundation"
  grid-rows: 1
  # Hardware registers returning feature bits
  ECX: "ECX Register" {
    class: hardware_reg
    link: "#anchor-foundation"
    "Bit 20: SSE4.2"
    "Bit 28: AVX"
  }
  EDX: "EDX Register" {
    class: hardware_reg
    link: "#anchor-foundation"
    "Bit 26: SSE2"
  }
  EBX: "EBX Register (Leaf 7)" {
    class: hardware_reg
    link: "#anchor-foundation"
    "Bit 5: AVX2"
    "Bit 16: AVX-512"
  }
}

Instruction -> Registers: "Populates"

Analysis: "Feature Validation Logic" {
  link: "#anchor-foundation"
  style.fill: transparent
  style.stroke-width: 0

  SSE_Check: "Is SSE4.2 bit set?" {
    class: logic_gate
    link: "#anchor-foundation"
  }

  AVX_Check: "Is AVX bit set?" {
    class: logic_gate
    link: "#anchor-foundation"
  }

  OS_Verify: "XGETBV (Check OS)" {
    class: os_check
    link: "#anchor-foundation"
    tooltip: "Verifies OS supports YMM register saving during context switches"
  }

  AVX2_Check: "Is AVX2 bit set?" {
    class: logic_gate
    link: "#anchor-foundation"
  }
}

Registers.ECX -> Analysis.SSE_Check
Registers.ECX -> Analysis.AVX_Check
Registers.EBX -> Analysis.AVX2_Check

Analysis.AVX_Check -> Analysis.OS_Verify: "Yes"
Analysis.OS_Verify -> Analysis.AVX2_Check: "OS Supported"

GlobalContext: "Global Capability Context" {
  class: state_block
  link: "#anchor-foundation"
  
  "instruction_flags": "uint32_t active_isas"
  "func_ptr": "void (*dot_product_impl)()"
  "cache_topology": "L1/L2/L3 Sizes"
}

Analysis.SSE_Check -> GlobalContext: "Enable SSE Path"
Analysis.OS_Verify -> GlobalContext: "Enable AVX Path"
Analysis.AVX2_Check -> GlobalContext: "Enable AVX2 Path"

CacheDiscovery: "Cache Topology Discovery" {
  shape: step
  link: "#anchor-foundation"
  label: "CPUID (Leaf 4) Loop"
}

Instruction -> CacheDiscovery: "Next Instruction"
CacheDiscovery -> GlobalContext: "Populate Sizes"