vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "SIMD Function Dispatch: Dynamic ISA Selection" {
  shape: text
  style: {
    font-size: 28
    bold: true
  }
}

# --- CPU FEATURE DETECTION (MICRO-VIEW) ---
cpu_detection: "Step 1: CPUID Feature Probing" {
  link: "#cpu-probing"
  style: {
    fill: "#1a1c2c"
    stroke: "#4a4e69"
    stroke-width: 4
  }

  register_view: "CPUID Leaf 0x07 (Structured Extended Features)" {
    shape: sql_table
    style: {
      stroke: "#5d2f27"
    }
    EAX: "0x00000007" {style: {fill: "#2d5a27"}}
    EBX: "Bit 16: AVX512F | Bit 5: AVX2"
    ECX: "Bit 0: PREFETCHWT1"
    EDX: "Bit 2: AVX512_4VNNIW"
  }

  bitmask: "Internal ISA Bitfield" {
    shape: rectangle
    label: "| 1 | 1 | 0 | 1 | 1 | 0 | 0 | 1 |"
    tooltip: "Resulting mask stored in global library state"
    style: {
      font: mono
      fill: "#2b2d42"
    }
  }

  register_view.EBX -> bitmask: "Mask & Shift"
}

# --- THE RUNTIME RESOLVER (LOGIC GATE) ---
dispatcher: "Step 2: Runtime Resolver (VTable Binding)" {
  link: "#vtable-resolver"
  style: {
    fill: "#243b55"
    double-border: true
  }

  logic: "Resolver Sequence" {
    shape: step
    1: "Library __init__"
    2: "Query CPUID Bitmask"
    3: "Priority Sort (AVX512 > AVX2 > SSE)"
    4: "Update VTable Pointers"
  }

  vtable_memory: "VTable Memory Layout" {
    shape: sql_table
    style: {
      stroke: "#00d2ff"
    }
    "Symbol: simd_add" : "PTR: 0x7FFF_A100" {link: "#avx512-impl"}
    "Symbol: simd_mul" : "PTR: 0x7FFF_B200" {link: "#avx2-impl"}
    "Symbol: simd_div" : "PTR: 0x7FFF_C300" {link: "#sse-impl"}
  }

  logic -> vtable_memory: "Atomic Pointer Swap" {
    style: {
      stroke: "#39ff14"
      animated: true
      stroke-width: 3
    }
  }
}

# --- ISA IMPLEMENTATION BANK (STATE TRANSITION) ---
kernels: "Step 3: ISA Implementation Kernels" {
  link: "#isa-kernels"
  style: {
    fill: "#2c3e50"
  }

  avx512_path: "AVX-512 Implementation" {
    link: "#avx512-impl"
    style: {
      fill: "#003366"
      multiple: true
    }
    zmm_regs: "ZMM0...ZMM31 (512-bit)" {
      style.font: mono
    }
    perf: "Op: 16x f32 / cycle"
  }

  avx2_path: "AVX2 Implementation" {
    link: "#avx2-impl"
    style: {
      fill: "#1e3d2f"
    }
    ymm_regs: "YMM0...YMM15 (256-bit)" {
      style.font: mono
    }
    perf: "Op: 8x f32 / cycle"
  }

  sse4_path: "SSE4.2 Implementation" {
    link: "#sse-impl"
    style: {
      fill: "#4b3b24"
    }
    xmm_regs: "XMM0...XMM15 (128-bit)" {
      style.font: mono
    }
    perf: "Op: 4x f32 / cycle"
  }

  fallback: "C++ Scalar Fallback" {
    style: {
      stroke-dash: 5
      opacity: 0.8
    }
    reg: "ALU / GPR"
    perf: "Op: 1x f32 / cycle"
  }
}

# --- GLOBAL INTERCONNECTIONS ---
"User Application" -> dispatcher.vtable_memory: "Indirect Call" {
  style: {
    stroke-width: 4
    stroke: "#ffffff"
  }
}

dispatcher.vtable_memory -> kernels.avx512_path: "Resolved Jump (Tier 0)" {
  source-arrowhead: diamond
  style: {
    stroke: "#00d2ff"
    animated: true
  }
}

dispatcher.vtable_memory -> kernels.fallback: "Fallback Jump" {
  style: {
    stroke: "#8e9aaf"
    stroke-dash: 3
  }
}

# --- TECHNICAL METADATA ---
microscope_view: |md
  ### Micro-Architecture Dispatch Context
  1. **Detection Overhead**: Executed exactly once per process lifetime via library constructors.
  2. **Indirection Penalty**: Modern branch predictors (BTB) alias the VTable pointer after ~3 calls, reducing overhead to < 2 cycles.
  3. **Binary Bloat**: "Fat binaries" contain all compiled kernels; only the optimal path is resident in the instruction cache.
| {
  near: top-right
  style: {
    fill: "#121212"
    stroke: "#39ff14"
    font-color: "#39ff14"
    font: mono
  }
}

# Styles
***.style.font: mono
(*** -> ***)[*].style.stroke: "#bdc3c7"