vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

# -----------------------------------------------------------------------------
# GLOBAL CLASSES
# -----------------------------------------------------------------------------
classes: {
  vector_reg: {
    style: {
      fill: "#1e1e2e"
      stroke: "#89b4fa"
      stroke-width: 3
      font-color: "#89b4fa"
      3d: true
      font: mono
    }
  }
  memory_byte: {
    width: 35
    height: 35
    style: {
      fill: "#313244"
      stroke: "#cba6f7"
      font-color: "#cba6f7"
      font: mono
    }
  }
  hit: {
    style: {
      fill: "#f38ba8"
      stroke: "#f38ba8"
      font-color: "#1e1e2e"
      bold: true
    }
  }
  operator: {
    shape: parallelogram
    style: {
      fill: "#45475a"
      font-color: "#f5e0dc"
      stroke: "#f5e0dc"
    }
  }
}

# -----------------------------------------------------------------------------
# SATELLITE VIEW (HIGH-LEVEL ABSTRACTION)
# -----------------------------------------------------------------------------
Satellite: "AVX2 String Search: System Pipeline" {
  Memory: "L1 Cache\n(32-Byte Aligned)" {
    shape: cylinder
    link: "#MemoryLayout"
  }

  SIMD_Core: "Vector Execution Stage" {
    VLOAD: "VMOVDQU\nUnaligned Load" { link: "#VectorOp" }
    VCMP: "VPCMPEQB\nEquality Logic" { link: "#VectorOp" }
    VMASK: "VPMOVMSKB\nMask Extraction" { link: "#VectorOp" }
    
    VLOAD -> VCMP -> VMASK
  }

  PostProc: "Scalar Resolution" {
    BITSCAN: "TZCNT\nTrailing Zeroes" { link: "#FinalScalar" }
    INDEX: "Result Index" { link: "#FinalScalar" }
    
    BITSCAN -> INDEX
  }

  Memory -> SIMD_Core.VLOAD: "256-bit Stream"
  SIMD_Core.VMASK -> PostProc.BITSCAN: "32-bit Integer"
}

# -----------------------------------------------------------------------------
# MEMORY LAYOUT (MICROSCOPE VIEW)
# -----------------------------------------------------------------------------
MemoryLayout: "Memory View: 32-Byte Haystack Buffer" {
  link: "#Satellite"
  
  Grid: {
    grid-columns: 16
    grid-gap: 4
    
    # Haystack: "SIMD_STRINGS_ARE_VERY_FAST_SIMD"
    b0: "S"; b1: "I"; b2: "M"; b3: "D"; b4: "_"; b5: "S"; b6: "T"; b7: "R"
    b8: "I"; b9: "N"; b10: "G"; b11: "S"; b12: "_"; b13: "A"; b14: "R"; b15: "E"
    b16: "_"; b17: "V"; b18: "E"; b19: "R"; b20: "Y"; b21: "_"; b22: "F"; b23: "A"
    b24: "S"; b25: "T"; b26: "_"; b27: "S"; b28: "I"; b29: "M"; b30: "D"; b31: "!"
    
    **.class: memory_byte
    # Target character is 'S'
    b0.class: hit
    b5.class: hit
    b11.class: hit
    b24.class: hit
    b27.class: hit
  }
  
  Label: "Base Address: 0x7fffffffd000" {
    shape: text
    style.font-color: "#cba6f7"
  }
}

# -----------------------------------------------------------------------------
# VECTOR OPERATIONS (STATE TRANSITION)
# -----------------------------------------------------------------------------
VectorOp: "Microscope View: Vector State Transitions" {
  link: "#Satellite"

  InputState: "Before Comparison" {
    YMM0_Haystack: "YMM0: Loaded Data" {
      class: vector_reg
      Bytes: {
        grid-columns: 8
        h0: "S"; h1: "I"; h2: "M"; h3: "D"; h4: "_"; h5: "S"; h6: "T"; h7: "R"
      }
    }

    YMM1_Needle: "YMM1: Broadcast 'S'" {
      class: vector_reg
      Bytes: {
        grid-columns: 8
        n0: "S"; n1: "S"; n2: "S"; n3: "S"; n4: "S"; n5: "S"; n6: "S"; n7: "S"
      }
    }
  }

  LogicGate: "VPCMPEQB Logic" {
    class: operator
    label: "Parallel Byte-wise Compare\n(Haystack[i] == Needle[i])"
  }

  OutputState: "After Comparison" {
    YMM2_Result: "YMM2: Match Result" {
      class: vector_reg
      Bytes: {
        grid-columns: 8
        r0: "FF" { class: hit }; r1: "00"; r2: "00"; r3: "00"; r4: "00"; r5: "FF" { class: hit }; r6: "00"; r7: "00"
      }
    }
  }

  InputState -> LogicGate -> OutputState
}

# -----------------------------------------------------------------------------
# FINAL SCALAR RESOLUTION
# -----------------------------------------------------------------------------
FinalScalar: "Microscope View: Mask to Index" {
  link: "#Satellite"

  BitmaskExtraction: "VPMOVMSKB: Extract MSB" {
    YMM2_In: "Register YMM2" { class: vector_reg }
    EAX_Out: "Register EAX (32-bit)" {
      shape: sql_table
      bits: "0..31"
      val: "0b...00000000000000000000000000100001"
    }
    YMM2_In -> EAX_Out
  }

  Calculation: "Index Calculation" {
    TZCNT: "TZCNT(EAX)" {
      class: operator
    }
    Result: "Index: 0" {
      shape: square
      style.fill: "#a6e3a1"
    }
    EAX_Out -> TZCNT -> Result: "Yields first bit set"
  }
}

# -----------------------------------------------------------------------------
# CODE BLOCK & IMPLEMENTATION
# -----------------------------------------------------------------------------
Implementation: |'md
### AVX2 Intrinsics Implementation
cpp
// 1. Load 32 bytes unaligned
__m256i haystack = _mm256_loadu_si256((__m256i*)ptr);

// 2. Create needle vector (Broadcast 'S')
__m256i needle = _mm256_set1_epi8('S');

// 3. Compare all bytes in parallel
__m256i result = _mm256_cmpeq_epi8(haystack, needle);

// 4. Create 32-bit mask from high-bits
uint32_t mask = _mm256_movemask_epi8(result);

// 5. Find trailing zero count (index of first match)
if (mask != 0) {
    return _tzcnt_u32(mask);
}

| {
  near: bottom-center
}

# -----------------------------------------------------------------------------
# LEGEND
# -----------------------------------------------------------------------------
Legend: "Visual Guide" {
  near: top-right
  Match: "Character Match" { class: hit }
  SIMD: "YMM (256-bit)" { class: vector_reg }
  RAM: "L1 Cache Byte" { class: memory_byte }
}

# -----------------------------------------------------------------------------
# INTER-DIAGRAM LINKS
# -----------------------------------------------------------------------------
(Satellite.SIMD_Core -> VectorOp)[0]: "Detailed Step" {
  style.stroke-dash: 5
  style.animated: true
}

(VectorOp -> FinalScalar)[0]: "Scalar Handover" {
  style.stroke: "#fab387"
}

# GLOBAL STYLING
***.style.font-size: 16
(*** -> ***)[*]: {
  style.stroke: "#94e2d5"
}