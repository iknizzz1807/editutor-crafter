vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}
direction: down

Title: "SSE2 Character Scan Algorithm" {
  shape: text
  style.font-size: 32
  near: top-center
}

# --- Data Sources ---
Inputs: {
  link: "#anchor-sse-core"
  style.stroke-width: 0
  style.fill: transparent
  
  Memory: {
    label: "System RAM\n[String Buffer]"
    shape: cylinder
    style.fill: "#2d2d2d"
    style.stroke: "#88c0d0"
  }

  Target: {
    label: "Target Char\n['x']"
    shape: square
    style.fill: "#bf616a"
  }
}

# --- The Pipeline ---
Pipeline: {
  link: "#anchor-sse-core"
  style.fill: transparent
  style.stroke: "#4c566a"
  style.stroke-dash: 3
  label: "CPU SIMD Pipeline"

  # Step 1: Load
  Load_Op: {
    label: "MOVDQU"
    shape: step
    tooltip: "Move Double Quadword Unaligned"
    style.fill: "#5e81ac"
  }

  XMM_Data: {
    label: "XMM0 Register\n[16 Bytes Loaded]"
    shape: parallelogram
    style.fill: "#81a1c1"
    style.font-color: "#eceff4"
  }

  # Step 2: Prepare Target
  XMM_Broadcast: {
    label: "XMM1 Register\n[Target 'x' Broadcasted]"
    shape: parallelogram
    style.fill: "#d08770"
    style.font-color: "#eceff4"
  }

  # Step 3: Compare
  Compare_Op: {
    label: "PCMPEQB"
    shape: diamond
    tooltip: "Packed Compare Equal Byte"
    style.fill: "#ebcb8b"
    style.font-color: "#2e3440"
  }

  XMM_Mask: {
    label: "XMM0 (Result)\n[0xFF, 0x00, 0x00, ...]"
    shape: parallelogram
    style.fill: "#a3be8c"
    style.font-color: "#2e3440"
  }

  # Step 4: Extract Mask
  Extract_Op: {
    label: "PMOVMSKB"
    shape: step
    tooltip: "Packed Move Mask Byte"
    style.fill: "#b48ead"
  }

  GPR_Mask: {
    label: "EAX Register\n[16-bit Integer Mask]"
    shape: hexagon
    style.fill: "#b48ead"
    style.font-color: "#eceff4"
  }

  # Step 5: Scan
  Scan_Op: {
    label: "TZCNT / BSF"
    shape: step
    tooltip: "Count Trailing Zeros"
    style.fill: "#88c0d0"
  }
}

Result: {
  label: "Index (Offset)"
  shape: circle
  style.fill: "#a3be8c"
  style.font-color: "#2e3440"
  style.stroke: "#8fbcbb"
  style.stroke-width: 2
  link: "#anchor-sse-core"
}

# --- Connections ---
Inputs.Memory -> Pipeline.Load_Op: "1. Fetch 16 Bytes"
Pipeline.Load_Op -> Pipeline.XMM_Data

Inputs.Target -> Pipeline.XMM_Broadcast: "2. Broadcast"

Pipeline.XMM_Data -> Pipeline.Compare_Op: "Operand A"
Pipeline.XMM_Broadcast -> Pipeline.Compare_Op: "Operand B"

Pipeline.Compare_Op -> Pipeline.XMM_Mask: "3. Generate Byte Mask"
Pipeline.XMM_Mask -> Pipeline.Extract_Op: "Input"

Pipeline.Extract_Op -> Pipeline.GPR_Mask: "4. Compress to Bits"
Pipeline.GPR_Mask -> Pipeline.Scan_Op: "5. Find First '1'"

Pipeline.Scan_Op -> Result: "6. Return Position"

# --- Visual Aid (Microscope) ---
Microscope: {
  link: "#anchor-sse-core"
  shape: package
  label: "Bitwise Logic Detail"
  style.stroke-dash: 3
  
  Logic_Flow: |md
    **Comparison Logic:**
    `Byte[i] == Target ? 0xFF : 0x00`

    **Compression Logic:**
    Take MSB (Most Significant Bit) of each byte.
    `0xFF` -> `1`
    `0x00` -> `0`
    
    Result is a 16-bit integer representing matches.
  |
}

Pipeline.XMM_Mask -> Microscope: "Explains" {
  style.stroke-dash: 3
  style.opacity: 0.5
}