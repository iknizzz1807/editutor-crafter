vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  fast_path: {
    style: {
      fill: "#1a472a"
      stroke: "#2ecc71"
      stroke-width: 4
      font-color: "#ffffff"
    }
  }
  fallback_path: {
    style: {
      fill: "#4c1d1d"
      stroke: "#e74c3c"
      stroke-dash: 5
      font-color: "#ffffff"
    }
  }
  hardware_reg: {
    style: {
      fill: "#1c2833"
      stroke: "#3498db"
      font-color: "#d6dbdf"
      font: mono
    }
  }
  instruction: {
    shape: step
    style: {
      fill: "#283747"
      font-color: "#f7f9f9"
    }
  }
}

Memcpy_Module: "SIMD Memcpy Module Architecture" {
  API_Entry: "sim_memcpy(void* dst, void* src, size_t len)" {
    shape: rectangle
    link: "#api-entry-spec"
    style: {
      bold: true
      fill: "#2e4053"
      font-color: white
    }
  }

  Dispatcher: "ISA Dispatcher" {
    shape: diamond
    link: "#dispatch-logic"
    
    Feat_Check: "CPUID Feature Discovery" {
      shape: rectangle
      link: "#cpuid-check"
      style.fill: "#1b2631"
    }

    Feat_Check -> AVX512_Strategy: "AVX512F | AVX512BW" {class: fast_path; link: "#avx512-dispatch"}
    Feat_Check -> AVX2_Strategy: "AVX2" {style.stroke-width: 2; link: "#avx2-dispatch"}
    Feat_Check -> Scalar_Fallback: "No SIMD" {class: fallback_path; link: "#scalar-dispatch"}
  }

  AVX512_Strategy: "AVX-512 Execution Strategy" {
    link: "#avx512-impl"
    style.fill: "#0b1622"
    
    Alignment: "Boundary Alignment" {
      tooltip: "Align pointers to 64-byte boundary"
      class: instruction
      link: "#alignment-logic"
    }
    
    Unroll_Loop: "8x ZMM Unrolled Loop" {
      tooltip: "512 bytes per iteration"
      class: instruction
      link: "#loop-unroll"
    }
    
    Masked_Tail: "k-Register Masked Store" {
      tooltip: "Handles remaining len % 64 bytes"
      class: instruction
      link: "#masked-tail"
    }

    Alignment -> Unroll_Loop -> Masked_Tail
  }

  AVX2_Strategy: "AVX2 256-bit Path" {
    link: "#avx2-impl"
    YMM_Bulk: "VMOVDQU YMM x 4" {
      class: instruction
      link: "#ymm-bulk"
    }
  }

  Scalar_Fallback: "Scalar Fallback Path" {
    link: "#scalar-impl"
    Rep_Mov: "rep movsb (ERMS)" {
      class: instruction
      link: "#erms-optimization"
    }
  }
}

# Microscope View: ZMM Register layout (Moved to root to fix 'near' error)
ZMM_Microscope: "Register Layout: ZMM0 (512-bit)" {
  near: top-right
  link: "#zmm-register-layout"
  
  Lanes: {
    shape: sql_table
    class: hardware_reg
    "0x00": "uint64: Lane 0 [bits 0-63]"
    "0x08": "uint64: Lane 1 [bits 64-127]"
    "0x10": "uint64: Lane 2 [bits 128-191]"
    "0x18": "uint64: Lane 3 [bits 192-255]"
    "0x20": "uint64: Lane 4 [bits 256-319]"
    "0x28": "uint64: Lane 5 [bits 320-383]"
    "0x30": "uint64: Lane 6 [bits 384-447]"
    "0x38": "uint64: Lane 7 [bits 448-511]"
  }
}

# Pipeline Sequence (Moved to root for layout clarity)
Data_Flow: "Load/Store Pipeline" {
  shape: sequence_diagram
  link: "#pipeline-sequence"
  near: center-right
  
  SRC: "Src RAM" { link: "#src-mem" }
  L1: "L1 Cache" { link: "#l1-cache" }
  ZMM: "SIMD Regs" { link: "#simd-regs" }
  DST: "Dst RAM" { link: "#dst-mem" }

  SRC -> L1: "HW Prefetcher" { link: "#prefetch" }
  L1 -> ZMM: "VMOVDQU64 (Load)" { link: "#vmov-load" }
  ZMM -> DST: "VMOVDQU64 (Store)" { link: "#vmov-store" }
  
  DST."Note: Temporal stores used for < L3 size"
}

# State Transition Visualization (Moved to root)
Copy_State: "State Transition: 128-bit Segment Move" {
  near: bottom-left
  link: "#state-logic"
  
  Before: "T=0 (Initial)" {
    link: "#state-t0"
    Source_Mem: {
      shape: sql_table
      link: "#src-t0"
      "0x1000": "0xDEADBEEF"
      "0x1008": "0xCAFEBABE"
    }
    Dest_Mem: {
      shape: sql_table
      link: "#dst-t0"
      "0x2000": "0x00000000"
      "0x2008": "0x00000000"
    }
  }
  
  After: "T=1 (Post-Instruction)" {
    link: "#state-t1"
    Source_Mem: {
      shape: sql_table
      link: "#src-t1"
      "0x1000": "0xDEADBEEF"
      "0x1008": "0xCAFEBABE"
    }
    Dest_Mem: {
      shape: sql_table
      link: "#dst-t1"
      "0x2000": "0xDEADBEEF"
      "0x2008": "0xCAFEBABE"
    }
  }
  
  Before -> After: "vmovdqu64 [rdx], zmm0" {
    style.animated: true
    style.stroke: "#2ecc71"
    link: "#asm-instruction"
  }
}

# Technical Specification Block
Technical_Spec: |md
  ### SIMD Architecture Implementation Notes
  - **Unaligned Access**: AVX-512 supports unaligned loads across page boundaries with minor penalty.
  - **ERMS**: Enhanced REP MOVSB is triggered for very large scalar buffers on Ice Lake+.
  - **Cache Pollution**: Non-temporal stores (`VMOVNTDQ`) bypass L1/L2 to avoid cache eviction on large copies.
  - **Loop Unrolling**: 8-way unrolling reduces branch misprediction overhead in the hot path.
| {
  near: bottom-center
  link: "#technical-doc"
}

# Legend
Legend: "Architecture Key" {
  near: bottom-right
  Optimized: "SIMD Fast Path" {class: fast_path; link: "#legend-fast"}
  Safety: "Scalar Fallback" {class: fallback_path; link: "#legend-safety"}
  HW_Layout: "Memory/Register" {class: hardware_reg; link: "#legend-hw"}
}

# Global Connections for the Atlas
Memcpy_Module.API_Entry -> Memcpy_Module.Dispatcher
Memcpy_Module.AVX512_Strategy -> Data_Flow: "Execution Flow" {
  style.stroke-width: 2
  link: "#flow-to-pipeline"
}
Memcpy_Module.AVX512_Strategy -> ZMM_Microscope: "Register Mapping" {
  style.stroke-dash: 3
  link: "#mapping-to-zmm"
}