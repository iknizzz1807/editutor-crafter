vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

# SATELLITE VIEW: The Checksum Dispatcher
"Checksum Module": {
  link: "#checksum-module-root"
  style: {
    stroke-width: 4
    fill: "#121212"
  }

  "Public API Gateway": {
    link: "#public-api"
    shape: package
    "New(Algo)": { link: "#api-new" }
    "Update(data)": { link: "#api-update" }
    "Digest()": { link: "#api-digest" }
  }

  "Runtime CPU Dispatcher": {
    link: "#runtime-dispatcher"
    "CPUID Check": {
      shape: diamond
      link: "#cpuid-logic"
    }

    "SIMD Backend Selector": {
      link: "#backend-selector"
      "AVX-512": { 
        link: "#backend-avx512"
        style.fill: "#1b4332" 
      }
      "AVX2": { 
        link: "#backend-avx2"
        style.fill: "#084c61" 
      }
      "SSE4.2": { 
        link: "#backend-sse"
        style.fill: "#4d1919" 
      }
      "Scalar": { 
        link: "#backend-scalar"
        style.fill: "#333333" 
      }
    }

    "CPUID Check" -> "SIMD Backend Selector"."AVX-512": "Feature: AVX512F"
    "CPUID Check" -> "SIMD Backend Selector"."AVX2": "Feature: AVX2"
    "CPUID Check" -> "SIMD Backend Selector"."SSE4.2": "Feature: SSE4.2"
  }

  "Public API Gateway" -> "Runtime CPU Dispatcher": "Hot-Path Call"
}

# STREET VIEW: Algorithm Implementations
"Algorithm Registry": {
  link: "#algo-registry"
  grid-columns: 2

  "CRC32C Engine": {
    link: "#crc32c-impl"
    "Polynomial": "0x1EDC6F41" { link: "#poly-castagnoli" }
    "Hardware Op": "_mm_crc32_u64" { link: "#sse-op" }
    "SIMD Strategy": "3-way Sliced-by-8" { link: "#sliced-strategy" }
  }

  "Adler-32 Engine": {
    link: "#adler32-impl"
    "Horizontal Add": "vpsadbw" { link: "#avx-psadbw" }
    "Vector Width": "256-bit / 512-bit" { link: "#vector-width" }
    "SIMD Strategy": "Vertical Summation" { link: "#vertical-sum" }
  }
}

# MICROSCOPE VIEW: Memory Alignment & Register Mapping
"Hardware Execution Layer": {
  link: "#hardware-layer"
  
  "L1 Cache / Memory Buffer": {
    shape: sql_table
    link: "#memory-alignment"
    "Offset 0x00": "0xAA 0xBB 0xCC 0xDD" { constraint: "ALIGNED 64B"; link: "#align-ok" }
    "Offset 0x04": "0x11 0x22 0x33 0x44" { constraint: "ALIGNED"; link: "#align-ok" }
    "Offset 0x08": "0x55 0x66 0x77 0x88" { constraint: "ALIGNED"; link: "#align-ok" }
    "Tail Bits": "0x99 0x00" { constraint: "UNALIGNED (MASKED)"; link: "#align-tail" }
  }

  "SIMD Load Unit": {
    shape: step
    link: "#load-unit"
    "VMOVDQA64": "Aligned Move" { link: "#vmovdqa" }
    "VMOVDQU64": "Unaligned Move" { link: "#vmovdqu" }
    "K-Masking": "Opmask (k1)" { link: "#opmask" }
  }

  "ZMM0: 512-bit Register": {
    link: "#zmm0-details"
    grid-columns: 8
    grid-gap: 2
    "QWord 0": { shape: square; link: "#qw0" }
    "QWord 1": { shape: square; link: "#qw1" }
    "QWord 2": { shape: square; link: "#qw2" }
    "QWord 3": { shape: square; link: "#qw3" }
    "QWord 4": { shape: square; link: "#qw4" }
    "QWord 5": { shape: square; link: "#qw5" }
    "QWord 6": { shape: square; link: "#qw6" }
    "QWord 7": { shape: square; link: "#qw7" }
  }

  "L1 Cache / Memory Buffer" -> "SIMD Load Unit": "DDR4/5 Bus"
  "SIMD Load Unit" -> "ZMM0: 512-bit Register": "Vector Fill"
}

# STATE TRANSITION: CRC32 Vectorized Step
"Execution Pipeline": {
  link: "#pipeline-state"
  direction: right

  "Before (T-0)": {
    link: "#state-t0"
    "Current CRC": "0x00000000" { link: "#crc-init" }
    "ZMM1": "New Data Chunk" { link: "#zmm1-pre" }
  }

  "Transformation Unit": {
    link: "#transform-logic"
    shape: rectangle
    style.fill: "#2d2d2d"
    "VPCLMULQDQ": "Carry-less Mul" { link: "#vpclmul" }
    "VPXORD": "Vector XOR" { link: "#vpxor" }
    "VPCLMULQDQ" -> "VPXORD": "Reduction"
  }

  "After (T+1)": {
    link: "#state-t1"
    "Current CRC": "0x4F2A11BC" { link: "#crc-updated" }
    "ZMM1": "Processed" { link: "#zmm1-post" }
  }

  "Before (T-0)" -> "Transformation Unit": "Register Input"
  "Transformation Unit" -> "After (T+1)": "Commit State"
}

# Implementation Notes
"Technical Specifications": |'md
  ### SIMD Optimization Matrix
  - **Memory Alignment**: 64-byte alignment required for `VMOVDQA64` to prevent penalty cycles.
  - **PCLMULQDQ**: Performs carry-less multiplication of two 64-bit polynomials.
  - **Loop Unrolling**: Architecture unrolls 4x ZMM registers per iteration to maximize ILP.
  - **Tail Handling**: Uses `K-mask` registers in AVX-512 to avoid reading past buffer boundaries.
'| {
  near: top-right
  link: "#spec-notes"
}

# Inter-module Connections
"Checksum Module"."Runtime CPU Dispatcher"."SIMD Backend Selector"."AVX-512" -> "Hardware Execution Layer"."ZMM0: 512-bit Register": "Target ISA"
"Algorithm Registry"."CRC32C Engine" -> "Execution Pipeline"."Transformation Unit": "Op Configuration"
"Execution Pipeline"."After (T+1)" -> "Checksum Module"."Public API Gateway"."Digest()": "Final Result"