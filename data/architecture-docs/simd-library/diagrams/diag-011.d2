vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  hw_register: {
    shape: rectangle
    style: {
      fill: "#1e1e1e"
      stroke: "#00ffcc"
      stroke-width: 2
      font-color: "#00ffcc"
      font: mono
      shadow: true
    }
  }
  memory_byte: {
    width: 40
    height: 40
    style: {
      fill: "#2d2d2d"
      stroke: "#ffffff"
      font-size: 10
    }
  }
  instruction: {
    style: {
      fill: "#004d40"
      stroke: "#80cbc4"
      stroke-width: 2
      bold: true
      font-color: "#e0f2f1"
    }
  }
  logic_gate: {
    style: {
      fill: "#311b92"
      stroke: "#b39ddb"
      stroke-dash: 2
    }
  }
}

# SATELLITE VIEW: CRC32 SSE4.2 ATLAS
atlas: "CRC32 SIMD Acceleration Atlas (SSE4.2)" {
  link: "#atlas"
  
  memory: "RAM: Input Buffer" {
    link: "#alignment_view"
    shape: sql_table
    word_0: "64-bit Word [0..7]"
    word_1: "64-bit Word [8..15]"
    word_2: "64-bit Word [16..23]"
  }

  cpu: "Execution Engine" {
    link: "#interleaving_view"
    alu: "ALU Port 1/5" {
      crc_unit: "_mm_crc32_u64" {
        class: instruction
      }
    }
  }

  regs: "State Accumulators" {
    link: "#transition_view"
    rax: "RAX: Stream A" { class: hw_register }
    r10: "R10: Stream B" { class: hw_register }
    r11: "R11: Stream C" { class: hw_register }
  }

  memory -> cpu: "LDDQU (128-bit load)"
  cpu -> regs: "Galois Field division result"
}

# STREET VIEW: MEMORY ALIGNMENT
alignment_view: "Memory Alignment & 64-bit Chunking" {
  link: "#alignment_view"
  
  layout: {
    grid-columns: 8
    grid-gap: 2
    
    b0: "B0" { class: memory_byte; style.fill: "#b71c1c" }
    b1: "B1" { class: memory_byte }
    b2: "B2" { class: memory_byte }
    b3: "B3" { class: memory_byte }
    b4: "B4" { class: memory_byte }
    b5: "B5" { class: memory_byte }
    b6: "B6" { class: memory_byte }
    b7: "B7" { class: memory_byte; style.fill: "#1b5e20" }
  }

  pointer: "RSI + offset" {
    shape: step
  }

  pointer -> layout.b0: "Fetch 8 bytes"
}

alignment_notes: |'md
  ### Alignment Requirements
  SSE4.2 instructions benefit from **8-byte alignment**. 
  Crossing a cache line boundary (64 bytes) results 
  in a **12 cycle penalty**.
'| {
  near: alignment_view
}

# MICROSCOPE VIEW: 3-WAY INTERLEAVING
interleaving_view: "3-Way Instruction Interleaving" {
  link: "#interleaving_view"
  direction: right

  stream_a: "Pipeline Alpha" {
    i1: "CRC32 RAX, [RSI]" { class: instruction }
    i4: "CRC32 RAX, [RSI+24]" { class: instruction }
    i1 -> i4: "Latency: 3 Cycles"
  }

  stream_b: "Pipeline Beta" {
    i2: "CRC32 R10, [RSI+8]" { class: instruction }
    i5: "CRC32 R10, [RSI+32]" { class: instruction }
    i2 -> i5
  }

  stream_c: "Pipeline Gamma" {
    i3: "CRC32 R11, [RSI+16]" { class: instruction }
    i6: "CRC32 R11, [RSI+40]" { class: instruction }
    i3 -> i6
  }
}

interleaving_notes: |'md
  ### Latency Hiding
  `CRC32` has a **3-cycle latency** but **1-cycle throughput**.
  By interleaving 3 independent registers, we saturate 
  the ALU and achieve **1 word/cycle** performance.
'| {
  near: interleaving_view
}

# MICROSCOPE VIEW: STATE TRANSITION
transition_view: "CRC32 Hardware Logic: GF(2) Transition" {
  link: "#transition_view"
  
  state_before: "Before (T=0)" {
    acc: "RAX: 0x8A23..." { class: hw_register }
    val: "MEM: 0xFF00..." { class: hw_register }
  }

  hardware_logic: "SSE4.2 Circuitry" {
    shape: package
    poly: "Polynomial: 0x1EDC6F41" {
      class: logic_gate
    }
    xor_gate: "XOR Accumulator" {
      class: logic_gate
      shape: diamond
    }
    
    poly -> xor_gate: "GF(2) Division"
  }

  state_after: "After (T+3)" {
    result: "RAX: 0x4B91..." {
      class: hw_register
      style.stroke: "#ffff00"
      style.stroke-width: 4
    }
  }

  state_before.acc -> hardware_logic.xor_gate
  state_before.val -> hardware_logic.poly
  hardware_logic.xor_gate -> state_after.result: "Final XOR"
}

# LEGEND
legend: "SIMD Legend" {
  near: atlas
  reg: "CPU Register" { class: hw_register }
  ins: "SIMD Instruction" { class: instruction }
  mem: "RAM Byte" { class: memory_byte }
}