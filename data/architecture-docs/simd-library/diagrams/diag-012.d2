vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

classes: {
  register_xmm: {
    shape: sql_table
    style: {
      fill: "#1e1e2e"
      stroke: "#89b4fa"
      stroke-width: 2
      font-color: "#cdd6f4"
    }
  }
  instruction: {
    shape: step
    style: {
      fill: "#313244"
      stroke: "#f38ba8"
      font-color: "#cdd6f4"
      bold: true
    }
  }
  gf2_logic: {
    shape: diamond
    style: {
      fill: "#45475a"
      stroke: "#fab387"
      font-color: "#cdd6f4"
    }
  }
}

# --- HIGH LEVEL ARCHITECTURE ---

CRC32_Pipeline: "SIMD PCLMULQDQ CRC32 Pipeline" {
  link: "#crc32-top"

  Memory_Buffer: "Source Data (Aligned)" {
    shape: queue
    style.fill: "#181825"
    "Chunk N"
    "Chunk N+1"
    "Chunk N+2"
    "Chunk N+3"
  }

  Folding_Stage: "4-Way Interleaved Folding" {
    link: "#folding-logic"
    grid-columns: 2
    
    XMM0: "Accumulator 0" { class: register_xmm }
    XMM1: "Accumulator 1" { class: register_xmm }
    XMM2: "Accumulator 2" { class: register_xmm }
    XMM3: "Accumulator 3" { class: register_xmm }
  }

  Reduction_Stage: "Barrett Reduction Unit" {
    link: "#barrett-reduction"
    shape: package
    style.fill: "#313244"
  }

  Memory_Buffer -> Folding_Stage: "VMOVDQU (64B Blocks)"
  Folding_Stage -> Reduction_Stage: "Horizontal PXOR"
  Reduction_Stage -> CRC_Final: "32-bit Result"
}

# --- MICROSCOPE: THE FOLDING OPERATION ---

Folding_Microscope: "Microscope: Fold Step (GF(2) Multiplication)" {
  link: "#folding-logic"

  State_Before: {
    shape: sql_table
    label: "XMM Register (T)"
    high: "Upper 64-bits (D1)" { style.fill: "#585b70" }
    low: "Lower 64-bits (D0)" { style.fill: "#585b70" }
  }

  Folding_Constants: {
    shape: sql_table
    label: "Precomputed Constants"
    k1: "k1 = x^(128+64) mod P(x)" { style.fill: "#b4befe"; style.font-color: "#11111b" }
    k2: "k2 = x^(128) mod P(x)" { style.fill: "#b4befe"; style.font-color: "#11111b" }
  }

  ALU: "Carryless Multipliers" {
    Fold_High: "PCLMULQDQ (0x11)" { class: instruction }
    Fold_Low: "PCLMULQDQ (0x01)" { class: instruction }
    Combine: "PXOR" { class: gf2_logic }
  }

  State_After: {
    shape: sql_table
    label: "XMM Register (T+1)"
    folded: "128-bit Residue" { style.fill: "#a6e3a1"; style.font-color: "#11111b" }
  }

  State_Before.high -> ALU.Fold_High: "Data"
  Folding_Constants.k1 -> ALU.Fold_High: "Constant"
  
  State_Before.low -> ALU.Fold_Low: "Data"
  Folding_Constants.k2 -> ALU.Fold_Low: "Constant"

  ALU.Fold_High -> ALU.Combine
  ALU.Fold_Low -> ALU.Combine
  ALU.Combine -> State_After.folded
}

# --- MICROSCOPE: BARRETT REDUCTION ---

Barrett_Reduction: "Microscope: Barrett Reduction (128b to 32b)" {
  link: "#barrett-reduction"

  Algorithm: |'md
  ### Barrett Method for CRC
  Since GF(2) has no carries, reduction is:
  1. $T_1 = (Residue_{high} \cdot \mu) >> 64$
  2. $T_2 = (T_1 \cdot P)$
  3. $CRC = Residue \oplus T_2$
  '|

  Execution_Flow: {
    Input: "128-bit Folding Result" { shape: parallelogram }
    
    Step_1: "PCLMULQDQ [Residue.High, Î¼]" { class: instruction }
    Step_2: "PCLMULQDQ [Step_1.Low, Poly]" { class: instruction }
    
    Output: {
      shape: sql_table
      label: "Final CRC Register"
      unused: "Upper 96-bits (Zero)"
      result: "32-bit CRC Value" { style.fill: "#f9e2af"; style.font-color: "#11111b" }
    }

    Input -> Step_1 -> Step_2 -> Output.result
  }
}

# --- MEMORY LAYOUT & LATENCY HIDING ---

Hardware_Efficiency: "Hardware Resource Mapping" {
  
  L1_Cache_Line: "64-Byte Alignment" {
    grid-columns: 4
    b0: "Chunk 0 (16B)" { style.fill: "#89dceb"; style.font-color: "#11111b" }
    b1: "Chunk 1 (16B)" { style.fill: "#89dceb"; style.font-color: "#11111b" }
    b2: "Chunk 2 (16B)" { style.fill: "#89dceb"; style.font-color: "#11111b" }
    b3: "Chunk 3 (16B)" { style.fill: "#89dceb"; style.font-color: "#11111b" }
  }

  Latency_Explanation: |'md
  ### Latency Hiding
  PCLMULQDQ has a latency of ~7 cycles but a throughput of 1/cycle.
  By interleaving 4 registers, we process 64 bytes per iteration,
  ensuring the CPU pipeline never stalls waiting for a GF(2) product.
  '|

  XMM_Map: {
    shape: sql_table
    label: "Register Interleaving"
    reg0: "XMM0: Offsets 0, 64, 128..."
    reg1: "XMM1: Offsets 16, 80, 144..."
    reg2: "XMM2: Offsets 32, 96, 160..."
    reg3: "XMM3: Offsets 48, 112, 176..."
  }

  L1_Cache_Line.b0 -> XMM_Map.reg0
  L1_Cache_Line.b1 -> XMM_Map.reg1
  L1_Cache_Line.b2 -> XMM_Map.reg2
  L1_Cache_Line.b3 -> XMM_Map.reg3
}

# --- CROSS-DIAGRAM INTERCONNECTIONS ---

# Connecting Satellite to Microscope
CRC32_Pipeline.Folding_Stage -> Folding_Microscope: "Internal Logic" {
  style: {
    stroke-dash: 5
    animated: true
  }
}

CRC32_Pipeline.Reduction_Stage -> Barrett_Reduction: "Final Reduction" {
  style.stroke-dash: 5
}

Folding_Microscope.State_After -> Barrett_Reduction: "128b Residue" {
  style.opacity: 0.4
}

# Global Legend / Header
Header: |'md
# PCLMULQDQ Optimized CRC32
Interleaved Folding & Barrett Reduction Logic
'| {
  near: top-center
}

Legend: {
  near: bottom-right
  register: "XMM Register" { class: register_xmm }
  op: "AVX/SSE Instruction" { class: instruction }
  logic: "GF(2) Logic" { class: gf2_logic }
}