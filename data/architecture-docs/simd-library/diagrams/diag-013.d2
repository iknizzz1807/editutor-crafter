vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Unaligned Copy Strategy: The Peel Loop" {
  shape: text
  near: top-center
  style: {
    font-size: 32
    bold: true
  }
}

# -------------------------------------------------------------------------
# VISUALIZATION: The Alignment Problem
# -------------------------------------------------------------------------
Visuals: {
  style: {
    fill: transparent
    stroke-width: 0
  }

  # Source is misaligned (e.g., ends in 0x...01)
  Source_Memory: {
    shape: package
    label: "Source RAM (0x...01)"
    style: {
        fill: "#fff1e6"
        stroke: "#333"
    }

    # Representation of bytes
    s_head: "Head (Unsafe)" {
        shape: square
        width: 40
        style.fill: "#e76f51"
        style.font-size: 10
    }
    s_vec1: "Vector Block 1" {
        shape: rectangle
        width: 120
        style.fill: "#2a9d8f"
    }
    s_vec2: "Vector Block 2" {
        shape: rectangle
        width: 120
        style.fill: "#2a9d8f"
    }

    s_head -> s_vec1 -> s_vec2
  }

  # Dest needs to be aligned for AVX store (e.g., ends in 0x...00)
  Dest_Memory: {
    shape: package
    label: "Dest RAM (0x...00)"
    style: {
        fill: "#e0fbfc"
        stroke: "#333"
    }

    # Representation of bytes
    d_head: "Peel (Aligning)" {
        shape: square
        width: 40
        style.fill: "#e76f51"
        style.font-size: 10
    }
    d_vec1: "Aligned Block 1" {
        shape: rectangle
        width: 120
        style.fill: "#2a9d8f"
    }
    d_vec2: "Aligned Block 2" {
        shape: rectangle
        width: 120
        style.fill: "#2a9d8f"
    }

    d_head -> d_vec1 -> d_vec2
  }

  # Mapping operations
  Source_Memory.s_head -> Dest_Memory.d_head: "Scalar Copy" {
    style: {
        stroke: "#e76f51"
        stroke-dash: 3
    }
  }
  Source_Memory.s_vec1 -> Dest_Memory.d_vec1: "vmovups -> vmovaps" {
    style: {
        stroke: "#2a9d8f"
        stroke-width: 2
    }
  }
}

# -------------------------------------------------------------------------
# ALGORITHM: The Decision Tree
# -------------------------------------------------------------------------
Algorithm: {
  link: "#anchor-memcpy-engine"
  style: {
    fill: "#f8f9fa"
    stroke: "#ced4da"
    stroke-dash: 3
    border-radius: 8
  }
  
  Input: "Function Call\nmemcpy(src, dst, n)" {
    shape: parallelogram
    style.fill: "#e9c46a"
  }

  Align_Check: "Is Dest Aligned?\n((size_t)dst % 32 == 0)" {
    shape: diamond
    style.fill: "#fff"
  }

  # Phase 1: The Peel Loop
  Peel_Loop: "Peel Loop (Scalar)" {
    shape: rectangle
    style.fill: "#e76f51"
    style.font-color: white
    label: |md
      while (dst % 32 != 0) {
        *dst++ = *src++;
        n--;
      }
    |
  }

  Size_Check: "Is n >= 32?" {
    shape: diamond
    style.fill: "#fff"
  }

  # Phase 2: The Main Body
  SIMD_Body: "Main Loop (AVX)" {
    shape: rectangle
    style.fill: "#2a9d8f"
    style.font-color: white
    label: |md
      **Unroll 4x**
      reg = _mm256_loadu_ps(src)
      _mm256_store_ps(dst, reg)
      src += 32; dst += 32;
    |
  }

  Tail_Check: "Is n > 0?" {
    shape: diamond
    style.fill: "#fff"
  }

  # Phase 3: The Tail
  Tail_Loop: "Tail Loop (Scalar)" {
    shape: rectangle
    style.fill: "#e76f51"
    style.font-color: white
    label: |md
       while (n--) {
         *dst++ = *src++;
       }
    |
  }

  End: "Return" {
    shape: oval
    style.fill: "#264653"
    style.font-color: white
  }

  # Logic Connections
  Input -> Align_Check
  
  Align_Check -> Peel_Loop: "No (Misaligned)"
  Align_Check -> Size_Check: "Yes (Aligned)"
  
  Peel_Loop -> Size_Check: "Now Aligned"
  
  Size_Check -> SIMD_Body: "Yes"
  SIMD_Body -> Size_Check: "n -= 32"
  
  Size_Check -> Tail_Check: "No (< 32 bytes)"
  
  Tail_Check -> Tail_Loop: "Yes"
  Tail_Check -> End: "No"
  
  Tail_Loop -> End
}

# Connect visuals to logic for context
Visuals.Source_Memory -> Algorithm.Input: "Memory Context" {
    style: {
        stroke-dash: 3
        opacity: 0.3
    }
}