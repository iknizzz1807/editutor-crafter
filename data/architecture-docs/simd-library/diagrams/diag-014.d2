vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

benchmark_framework: "Benchmark Framework (v2.1)" {
  link: "#benchmark-framework"
  tooltip: "High-precision performance measurement infrastructure"
  style: {
    stroke-width: 4
  }

  orchestrator: "Benchmark Orchestrator" {
    link: "#orchestrator"
    shape: rectangle
    warmup_controller: "Warmup Controller"
    iteration_manager: "Iteration Manager"
    outlier_detector: "Outlier Detector"
    
    warmup_controller -> iteration_manager: "Thermal Equilibrium Reached"
    iteration_manager -> outlier_detector: "Raw Latency Stream"
  }

  timing_unit: "Precision Timing Subsystem" {
    link: "#timing-subsystem"
    rdtsc: "RDTSC / Instruction Counter" {
      shape: cylinder
      style.fill: "#1a1a1a"
    }
    fence: "Memory Fence (LFENCE/SFENCE)" {
      shape: step
    }
    overhead_calibration: "Calibration Offset" {
      tooltip: "Measurement of the cost of the measurement itself"
    }

    rdtsc -> fence: "Serialization"
    fence -> overhead_calibration: "Subtract Base Cost"
  }

  memory_environment: "Memory State Management" {
    link: "#memory-env"
    cache_clobber: "Cache Clobberer" {
      tooltip: "Ensures cold starts if requested"
    }
    alignment_validator: "SIMD Alignment Validator" {
      style.stroke-dash: 3
    }
  }

  statistical_engine: "Statistical Engine" {
    link: "#stats-engine"
    shape: sql_table
    sample_size: "uint64" {constraint: "N=1,000,000"}
    min_latency: "double" {constraint: "cycles"}
    median: "double" {constraint: "cycles"}
    p95: "double" {constraint: "cycles"}
    p99: "double" {constraint: "cycles"}
    std_dev: "double"
    variance: "double"
  }

  measurement_loop: {
    shape: sequence_diagram
    link: "#runner-loop"
    
    Harness: "Runner"
    CPU: "Target Logic"
    Stats: "Accumulator"

    Harness -> CPU: "Warmup (10k iterations)"
    Harness -> CPU: "Iteration Start (Fence)"
    Harness -> CPU: "Execute SIMD Kernel"
    Harness <- CPU: "Iteration End (Fence)"
    Harness -> Stats: "Record Cycles"
    Stats -> Stats: "Update Histogram"
  }

  result_exporter: "Result Exporter" {
    json: "JSON Manifest"
    csv: "Raw CSV Data"
    flamegraph: "Visual Profile"
  }

  # Connections
  orchestrator.iteration_manager -> timing_unit.rdtsc: "Trigger"
  timing_unit.overhead_calibration -> statistical_engine: "Adjusted Samples"
  statistical_engine -> result_exporter: "Final Metrics"
  memory_environment.alignment_validator -> orchestrator: "Pre-flight Check"
}

memory_layout: "Internal Benchmarking Buffer" {
  link: "#memory-layout"
  grid-columns: 1
  
  header: "Cache Line Alignment (64-byte blocks)" {
    grid-columns: 8
    grid-gap: 2
    
    b0: "Pad" {style.fill: grey}
    b1: "Pad" {style.fill: grey}
    b2: "Pad" {style.fill: grey}
    b3: "Pad" {style.fill: grey}
    b4: "Pad" {style.fill: grey}
    b5: "Pad" {style.fill: grey}
    b6: "Pad" {style.fill: grey}
    b7: "Pad" {style.fill: grey}
  }

  data_segment: "Active Metric Accumulators" {
    grid-columns: 4
    grid-gap: 10
    
    counter_v: "Cycle Counter" {
      style: {
        fill: "#2b5a2b"
        stroke: "#00ff00"
      }
    }
    counter_i: "Instruction Counter" {
      style: {
        fill: "#2b5a2b"
        stroke: "#00ff00"
      }
    }
    state_flag: "Atomic State" {
      style.double-border: true
    }
    tsc_ref: "TSC Reference"
  }
}

benchmark_framework.orchestrator -> memory_layout: "Synchronize Thread State" {
  style: {
    stroke-dash: 5
    animated: true
  }
}

legend: "Benchmark State Glossary" {
  near: bottom-right
  warmup: "Warmup: CPU Frequency Scaling / Branch Prediction training" {
    shape: text
    style.font-color: "#888888"
  }
  steady: "Steady: Converged performance samples" {
    shape: text
    style.font-color: "#00ff00"
  }
}