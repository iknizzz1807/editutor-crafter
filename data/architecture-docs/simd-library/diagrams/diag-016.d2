vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: CRC32C Hardware Acceleration (PCLMULQDQ) {
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
  }
}

Pipeline: {
  link: "#anchor-checksum-core"
  
  # Register View
  XMM_Register: {
    tooltip: "128-bit Input Data held in XMM register"
    style.fill: "#e3f2fd"
    style.stroke: "#1565c0"
    
    High_64: Data[127:64] {
      shape: rectangle
      width: 150
      style.fill: "#bbdefb"
    }
    Low_64: Data[63:0] {
      shape: rectangle
      width: 150
      style.fill: "#90caf9"
    }
  }

  Constants: {
    tooltip: "Precomputed Polynomials derived from CRC32C Poly"
    style.stroke-dash: 3
    style.fill: transparent
    style.stroke-width: 0
    
    Fold_Const: K_Fold {
      shape: parallelogram
      label: "x^64 mod P(x)"
      style.fill: "#fff9c4"
    }
  }

  # Folding Step
  Folding: {
    style.fill: transparent
    style.stroke-width: 0
    
    Mul_Hi: PCLMULQDQ {
      shape: hexagon
      style.fill: "#ffecb3"
      style.stroke: "#ff6f00"
      tooltip: "Carry-less Multiplication"
    }
    
    Xor_Fold: XOR {
      shape: circle
      width: 50
      style.fill: "#ffcc80"
      style.stroke: "#e65100"
    }
  }
  
  XMM_Register.High_64 -> Folding.Mul_Hi: "Input A"
  Constants.Fold_Const -> Folding.Mul_Hi: "Input B"
  
  Folding.Mul_Hi -> Folding.Xor_Fold: "Product (128-bit)"
  XMM_Register.Low_64 -> Folding.Xor_Fold: "Input C"
  
  # Result of Fold
  Folded_State: Folded Remainder {
    shape: rectangle
    style.fill: "#c8e6c9"
    style.stroke: "#2e7d32"
    tooltip: "The 128-bit input is now reduced to 64 bits"
  }
  
  Folding.Xor_Fold -> Folded_State: "Result (64-bit)"

  # Reduction Steps (Barrett)
  Barrett_Reduction: {
    label: "Barrett Reduction (Modulo P(x))"
    style.fill: "#f3e5f5"
    style.stroke: "#6a1b9a"
    
    # Q = floor(R / P) approximated by R * InverseP
    Estimate_Quotient: PCLMULQDQ {
        label: "Mul by 1/P(x)"
        shape: hexagon
        style.fill: "#e1bee7"
    }
    
    # R' = Q * P
    Recalc_Product: PCLMULQDQ {
        label: "Mul by P(x)"
        shape: hexagon
        style.fill: "#e1bee7"
    }
    
    Final_Xor: XOR {
        shape: circle
        width: 50
        style.fill: "#ce93d8"
    }
  }
  
  Folded_State -> Barrett_Reduction.Estimate_Quotient
  Barrett_Reduction.Estimate_Quotient -> Barrett_Reduction.Recalc_Product: "Quotient Estimate"
  Barrett_Reduction.Recalc_Product -> Barrett_Reduction.Final_Xor: "Subtract (XOR)"
  Folded_State -> Barrett_Reduction.Final_Xor: "Original"
  
  Final_CRC: CRC32 Checksum {
    shape: cylinder
    style.fill: "#b2dfdb"
    style.stroke: "#00695c"
  }
  
  Barrett_Reduction.Final_Xor -> Final_CRC: "Final Remainder"
}

Explanation: |md
  # The Math
  1. **Folding**: We compress 128 bits into 64 bits. The High 64 bits are treated as coefficients of a polynomial $H(x)$. We multiply $H(x)$ by $x^{64} \pmod{P(x)}$ (the folding constant) to "shift" it down, then XOR with the Low 64 bits.
  2. **Reduction**: We need $R(x) \pmod{P(x)}$. Division is slow. Instead, we multiply by the inverse $1/P(x)$ to estimate the quotient, then subtract (XOR) the quotient times $P(x)$ from the original to get the remainder.
| {
    near: bottom-center
    shape: text
}