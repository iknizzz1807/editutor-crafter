title: SIMD Library Architecture {
  style.font-size: 24
  style.bold: true
  style.font-color: "#e6edf3"
}

classes: {
  container: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  module: {
    style.fill: "#16213e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  core: {
    style.fill: "#0f3460"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
  data: {
    style.fill: "#2d3748"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
}

runtime_detection: Runtime Detection {
  class: core
  cpu_caps: CPU Capabilities {
    class: module
  }
  feature_flags: Feature Flags {
    class: module
  }
  dispatch: Dynamic Dispatch {
    class: module
  }
  
  cpu_caps -> feature_flags: detects
  feature_flags -> dispatch: configures
}

memory_ops: Memory Operations {
  class: container
  memcpy: SIMD memcpy {
    class: module
  }
  memset: SIMD memset {
    class: module
  }
  compare: Memory Compare {
    class: module
  }
  alignment: Alignment Utils {
    class: module
  }
  
  alignment -> memcpy: ensures
  alignment -> memset: ensures
  alignment -> compare: ensures
}

string_ops: String Operations {
  class: container
  strlen: SIMD strlen {
    class: module
  }
  search: String Search {
    class: module
  }
  transform: Case Transform {
    class: module
  }
  validate: UTF-8 Validation {
    class: module
  }
}

math_ops: Mathematical Operations {
  class: container
  vectormath: Vector Math {
    class: module
  }
  reduction: Reductions {
    class: module
  }
  transcendental: Transcendental {
    class: module
  }
  stats: Statistics {
    class: module
  }
  
  vectormath -> reduction: uses
  stats -> reduction: uses
}

benchmarking: Benchmarking Framework {
  class: container
  timer: High-Res Timer {
    class: module
  }
  profiler: Performance Profiler {
    class: module
  }
  comparison: Scalar vs SIMD {
    class: module
  }
  reporter: Results Reporter {
    class: module
  }
  
  timer -> profiler: feeds
  profiler -> comparison: measures
  comparison -> reporter: outputs
}

data_flow: Data Flow {
  class: data
  input: Input Buffers {
    class: data
  }
  aligned: Aligned Data {
    class: data
  }
  output: Output Buffers {
    class: data
  }
}

runtime_detection.dispatch -> memory_ops: selects implementation
runtime_detection.dispatch -> string_ops: selects implementation
runtime_detection.dispatch -> math_ops: selects implementation

data_flow.input -> memory_ops: processes
data_flow.input -> string_ops: processes
data_flow.input -> math_ops: processes

memory_ops.alignment -> data_flow.aligned: creates
data_flow.aligned -> data_flow.output: transforms

benchmarking.timer -> memory_ops: measures
benchmarking.timer -> string_ops: measures
benchmarking.timer -> math_ops: measures

memory_ops -> benchmarking.comparison: performance data
string_ops -> benchmarking.comparison: performance data
math_ops -> benchmarking.comparison: performance data