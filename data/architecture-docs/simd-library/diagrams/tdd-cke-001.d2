direction: right
vars: {
  d2-config: {
    theme-id: 200
    layout-engine: elk
  }
}

classes: {
  struct: {
    shape: class
    style: {
      fill: "#e1f5fe"
      stroke: "#01579b"
    }
  }
  kernel: {
    shape: class
    style: {
      fill: "#f3e5f5"
      stroke: "#4a148c"
    }
  }
  logic: {
    shape: class
    style: {
      fill: "#e8f5e9"
      stroke: "#1b5e20"
    }
  }
}

ComputeKernelEngine: {
  label: Compute Kernel Engine (CKE)
  
  Context: {
    class: struct
    label: KernelContext
    src_a: "const float* __restrict"
    src_b: "const float* __restrict"
    out: "float* __restrict"
    length: size_t
    prefetch_distance: uint32_t
    
    metrics: {
      row_stride: size_t
      col_stride: size_t
    }
  }

  AbstractKernel: {
    class: kernel
    label: "<<interface>>\nIMicroKernel"
    +Initialize(): void
    +Step(a, b): void
    +StepMasked(a, b, mask): void
    +Finalize(): T
  }

  ConcreteKernels: {
    DotProductKernel: {
      class: kernel
      -acc0: Vector<T, N>
      -acc1: Vector<T, N>
      -acc2: Vector<T, N>
      -acc3: Vector<T, N>
      
      +Initialize(): void
      +Step(a, b): void
      +Finalize(): float
    }
    
    ConvolutionKernel: {
      class: kernel
      -weights: Vector<T, N>
      +Step(input, weights): void
    }
  }

  ConcreteKernels.DotProductKernel -> AbstractKernel: is-a
  ConcreteKernels.ConvolutionKernel -> AbstractKernel: is-a

  ExecutionLogic: {
    IterationEngine: {
      class: logic
      +PeelLoop(ptr): void
      +ExecuteUnrolled(ctx): void
      +HandleTail(ctx): void
    }

    PipelineOrchestrator: {
      class: logic
      -active_kernels: List<IMicroKernel>
      +Compose(k1, k2): void
      +Run(ctx): void
    }
  }

  ExecutionLogic.PipelineOrchestrator -> ExecutionLogic.IterationEngine: delegates to
  ExecutionLogic.IterationEngine -> Context: reads state
  ExecutionLogic.IterationEngine -> AbstractKernel: executes steps
}

# External Module Links
HDDE: Hardware Detection & Dispatch {
  link: "mod-hardware-dispatch"
}

AMBM: Aligned Memory Manager {
  link: "mod-memory-management"
}

UVI: Unified Vector Interface {
  link: "mod-unified-vector-interface"
}

ComputeKernelEngine.ExecutionLogic.IterationEngine -> HDDE: queries optimal width
ComputeKernelEngine.Context -> AMBM: validated by
ComputeKernelEngine.ConcreteKernels.DotProductKernel -> UVI: uses SIMD registers