vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Allocation Strategy Comparison" {
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
    underline: true
  }
}

# First-Fit Strategy
first_fit: "First-Fit Strategy" {
  shape: rectangle
  style: {
    fill: "#e8f4f8"
    stroke: "#2c5aa0"
    stroke-width: 2
  }

  heap_before: "Heap Before (128 bytes)" {
    shape: rectangle
    style.fill: "#fff"
    
    block1: "Used\n32B" {
      width: 80
      height: 60
      style.fill: "#ffcccc"
    }
    
    free1: "Free\n16B" {
      width: 40
      height: 60
      style.fill: "#ccffcc"
    }
    
    block2: "Used\n48B" {
      width: 120
      height: 60
      style.fill: "#ffcccc"
    }
    
    free2: "Free\n32B" {
      width: 80
      height: 60
      style.fill: "#ccffcc"
    }
  }

  request: "Request: 24 bytes" {
    shape: rectangle
    style: {
      fill: "#ffffcc"
      stroke: "#ff9900"
      stroke-width: 2
    }
  }

  heap_after: "Heap After" {
    shape: rectangle
    style.fill: "#fff"
    
    block1_a: "Used\n32B" {
      width: 80
      height: 60
      style.fill: "#ffcccc"
    }
    
    free1_a: "Free\n16B" {
      width: 40
      height: 60
      style.fill: "#ccffcc"
    }
    
    block2_a: "Used\n48B" {
      width: 120
      height: 60
      style.fill: "#ffcccc"
    }
    
    new_block: "NEW\n24B" {
      width: 60
      height: 60
      style: {
        fill: "#ffff99"
        stroke: "#ff9900"
        stroke-width: 2
      }
    }
    
    free2_a: "Free\n8B" {
      width: 20
      height: 60
      style.fill: "#ccffcc"
    }
  }

  result: "Result: Uses first free block â‰¥ 24B" {
    shape: rectangle
    style: {
      fill: "#d4edda"
      stroke: "#28a745"
    }
  }

  heap_before -> request
  request -> heap_after
  heap_after -> result
}

# Best-Fit Strategy
best_fit: "Best-Fit Strategy" {
  shape: rectangle
  style: {
    fill: "#f0e8f4"
    stroke: "#6f42c1"
    stroke-width: 2
  }

  heap_before_b: "Heap Before (128 bytes)" {
    shape: rectangle
    style.fill: "#fff"
    
    block1_b: "Used\n32B" {
      width: 80
      height: 60
      style.fill: "#ffcccc"
    }
    
    free1_b: "Free\n16B" {
      width: 40
      height: 60
      style.fill: "#ccffcc"
    }
    
    block2_b: "Used\n48B" {
      width: 120
      height: 60
      style.fill: "#ffcccc"
    }
    
    free2_b: "Free\n32B" {
      width: 80
      height: 60
      style.fill: "#ccffcc"
    }
  }

  request_b: "Request: 24 bytes" {
    shape: rectangle
    style: {
      fill: "#ffffcc"
      stroke: "#ff9900"
      stroke-width: 2
    }
  }

  scan: "Scan all free blocks:\n16B (too small)\n32B (best fit!)" {
    shape: rectangle
    style: {
      fill: "#e7f3ff"
      stroke: "#0066cc"
    }
  }

  heap_after_b: "Heap After" {
    shape: rectangle
    style.fill: "#fff"
    
    block1_ba: "Used\n32B" {
      width: 80
      height: 60
      style.fill: "#ffcccc"
    }
    
    free1_ba: "Free\n16B" {
      width: 40
      height: 60
      style.fill: "#ccffcc"
    }
    
    block2_ba: "Used\n48B" {
      width: 120
      height: 60
      style.fill: "#ffcccc"
    }
    
    new_block_b: "NEW\n24B" {
      width: 60
      height: 60
      style: {
        fill: "#ffff99"
        stroke: "#ff9900"
        stroke-width: 2
      }
    }
    
    free2_ba: "Free\n8B" {
      width: 20
      height: 60
      style.fill: "#ccffcc"
    }
  }

  result_b: "Result: Minimizes leftover space" {
    shape: rectangle
    style: {
      fill: "#d4edda"
      stroke: "#28a745"
    }
  }

  heap_before_b -> request_b
  request_b -> scan
  scan -> heap_after_b
  heap_after_b -> result_b
}

# Worst-Fit Strategy
worst_fit: "Worst-Fit Strategy" {
  shape: rectangle
  style: {
    fill: "#f8e8e8"
    stroke: "#dc3545"
    stroke-width: 2
  }

  heap_before_w: "Heap Before (128 bytes)" {
    shape: rectangle
    style.fill: "#fff"
    
    block1_w: "Used\n32B" {
      width: 80
      height: 60
      style.fill: "#ffcccc"
    }
    
    free1_w: "Free\n16B" {
      width: 40
      height: 60
      style.fill: "#ccffcc"
    }
    
    block2_w: "Used\n48B" {
      width: 120
      height: 60
      style.fill: "#ffcccc"
    }
    
    free2_w: "Free\n48B" {
      width: 120
      height: 60
      style.fill: "#ccffcc"
    }
  }

  request_w: "Request: 24 bytes" {
    shape: rectangle
    style: {
      fill: "#ffffcc"
      stroke: "#ff9900"
      stroke-width: 2
    }
  }

  scan_w: "Scan all free blocks:\n16B (too small)\n48B (worst fit!)" {
    shape: rectangle
    style: {
      fill: "#e7f3ff"
      stroke: "#0066cc"
    }
  }

  heap_after_w: "Heap After" {
    shape: rectangle
    style.fill: "#fff"
    
    block1_wa: "Used\n32B" {
      width: 80
      height: 60
      style.fill: "#ffcccc"
    }
    
    free1_wa: "Free\n16B" {
      width: 40
      height: 60
      style.fill: "#ccffcc"
    }
    
    block2_wa: "Used\n48B" {
      width: 120
      height: 60
      style.fill: "#ffcccc"
    }
    
    new_block_w: "NEW\n24B" {
      width: 60
      height: 60
      style: {
        fill: "#ffff99"
        stroke: "#ff9900"
        stroke-width: 2
      }
    }
    
    free2_wa: "Free\n24B" {
      width: 60
      height: 60
      style.fill: "#ccffcc"
    }
  }

  result_w: "Result: Leaves larger free blocks" {
    shape: rectangle
    style: {
      fill: "#d4edda"
      stroke: "#28a745"
    }
  }

  heap_before_w -> request_w
  request_w -> scan_w
  scan_w -> heap_after_w
  heap_after_w -> result_w
}

# Fragmentation Analysis
fragmentation: "Fragmentation Analysis" {
  shape: rectangle
  style: {
    fill: "#fff8e1"
    stroke: "#ff6f00"
    stroke-width: 2
  }

  table: |'md
    | Strategy | Time | Fragmentation | Use Case |
    |----------|------|---------------|----------|
    | First-Fit | O(n) | Medium | General purpose |
    | Best-Fit | O(n) | Low | Memory-constrained |
    | Worst-Fit | O(n) | High | Large allocations |
  '|
}

# Layout connections
first_fit -> fragmentation
best_fit -> fragmentation
worst_fit -> fragmentation