vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Microscopic: Cache-Friendly Traversal" {
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
    underline: true
  }
}

subtitle: "Memory Layout Optimization for Mark Phase" {
  near: top-center
  shape: text
  style: {
    font-size: 16
    italic: true
  }
}

# Memory Layout Comparison
memory_layout: "Memory Layout Comparison" {
  bfs_layout: "Breadth-First Layout (Cache-Friendly)" {
    shape: rectangle
    style.fill: "#e8f5e9"
    style.stroke: "#4caf50"
    style.stroke-width: 3
    
    cache_line_1: |'md
      **Cache Line 1 (64 bytes)**
      | Offset | Object | Size | Next |
      |--------|--------|------|------|
      | 0x00   | Root   | 128B | 0x80 |
      | 0x40   | Child1 | 128B | 0x100|
    '| {
      shape: rectangle
      style.fill: "#c8e6c9"
      style.font-size: 11
    }
    
    cache_line_2: |'md
      **Cache Line 2 (64 bytes)**
      | Offset | Object | Size | Next |
      |--------|--------|------|------|
      | 0x80   | Child2 | 128B | 0x180|
      | 0xC0   | Child3 | 128B | 0x200|
    '| {
      shape: rectangle
      style.fill: "#c8e6c9"
      style.font-size: 11
    }
    
    metrics_bfs: |'md
      **Performance Metrics**
      - Cache hit rate: **92%**
      - L1 misses: 8 per 100 objects
      - Mark time: **5.2 ms** (100K objects)
      - Memory bandwidth: 1.2 GB/s
    '| {
      shape: rectangle
      style.fill: "#a5d6a7"
      style.font-size: 12
      style.bold: true
    }
  }
  
  dfs_layout: "Depth-First Layout (Cache-Hostile)" {
    shape: rectangle
    style.fill: "#ffebee"
    style.stroke: "#f44336"
    style.stroke-width: 3
    
    scattered_1: |'md
      **Cache Line 1 (64 bytes)**
      | Offset | Object | Size | Next |
      |--------|--------|------|------|
      | 0x00   | Root   | 128B | 0x5000|
      | 0x40   | (empty)| -    | -    |
    '| {
      shape: rectangle
      style.fill: "#ffcdd2"
      style.font-size: 11
    }
    
    scattered_2: |'md
      **Cache Line 75 (64 bytes)**
      | Offset | Object | Size | Next |
      |--------|--------|------|------|
      | 0x5000 | Child1 | 128B | 0xA000|
      | 0x5040 | (empty)| -    | -    |
    '| {
      shape: rectangle
      style.fill: "#ffcdd2"
      style.font-size: 11
    }
    
    metrics_dfs: |'md
      **Performance Metrics**
      - Cache hit rate: **34%**
      - L1 misses: 66 per 100 objects
      - Mark time: **18.7 ms** (100K objects)
      - Memory bandwidth: 4.8 GB/s
    '| {
      shape: rectangle
      style.fill: "#ef9a9a"
      style.font-size: 12
      style.bold: true
    }
  }
  
  bfs_layout -> dfs_layout: "3.6x slower" {
    style.stroke: "#ff5722"
    style.stroke-width: 3
    style.font-color: "#d32f2f"
    style.bold: true
  }
}

# Cache Line Utilization
cache_utilization: "Cache Line Utilization" {
  bfs_cache: "BFS: Sequential Access" {
    shape: rectangle
    style.fill: "#e3f2fd"
    
    access_pattern: |'md
      **Access Pattern**
      
      Time →
      0ns:  Load Root      [Cache MISS]
      5ns:  Load Child1    [Cache HIT]  ← Same line!
      10ns: Load Child2    [Cache HIT]  ← Same line!
      15ns: Load Child3    [Cache HIT]  ← Same line!
      
      
      **Cache Line State**
      
      [Root|Child1|Child2|Child3] ← All in L1
      
    '| {
      shape: rectangle
      style.fill: "#bbdefb"
      style.font-size: 11
    }
  }
  
  dfs_cache: "DFS: Random Access" {
    shape: rectangle
    style.fill: "#fce4ec"
    
    access_pattern: |'md
      **Access Pattern**
      
      Time →
      0ns:   Load Root      [Cache MISS]
      100ns: Load Child1    [Cache MISS] ← Different line!
      200ns: Load Child2    [Cache MISS] ← Different line!
      300ns: Load Child3    [Cache MISS] ← Different line!
      
      
      **Cache Line State**
      
      [Root|?|?|?] [Child1|?|?|?] [Child2|?|?|?]
      ↑ Evicted    ↑ Evicted      ↑ Evicted
      
    '| {
      shape: rectangle
      style.fill: "#f8bbd0"
      style.font-size: 11
    }
  }
  
  bfs_cache -> dfs_cache: "20x more cache misses" {
    style.stroke: "#e91e63"
    style.stroke-width: 2
    style.font-color: "#c2185b"
  }
}

# Implementation Strategy
implementation: "Implementation Strategy" {
  allocator: "Custom Allocator" {
    shape: rectangle
    style.fill: "#fff3e0"
    
    code: |'c
      // Allocate objects sequentially
      void* gc_alloc(GC* gc, size_t size) {
          // Round up to cache line (64B)
          size_t aligned = (size + 63) & ~63;
          
          void* ptr = gc->heap_ptr;
          gc->heap_ptr += aligned;
          
          return ptr;  // Sequential!
      }
    '| {
      shape: rectangle
      style.fill: "#ffe0b2"
      style.font-size: 10
    }
  }
  
  mark_queue: "BFS Mark Queue" {
    shape: rectangle
    style.fill: "#f3e5f5"
    
    code: |'c
      // Process objects in allocation order
      void mark_bfs(GC* gc) {
          Queue* q = queue_create();
          
          // Enqueue roots
          for (Root* r = gc->roots; r; r = r->next) {
              queue_push(q, r->ptr);
          }
          
          // BFS traversal
          while (!queue_empty(q)) {
              Object* obj = queue_pop(q);
              
              if (is_marked(obj)) continue;
              mark_object(obj);
              
              // Enqueue children
              for (int i = 0; i < obj->ref_count; i++) {
                  queue_push(q, obj->refs[i]);
              }
          }
      }
    '| {
      shape: rectangle
      style.fill: "#e1bee7"
      style.font-size: 10
    }
  }
  
  prefetch: "Hardware Prefetching" {
    shape: rectangle
    style.fill: "#e0f2f1"
    
    code: |'c
      // Hint to CPU to prefetch next object
      void mark_with_prefetch(GC* gc) {
          Queue* q = queue_create();
          
          while (!queue_empty(q)) {
              Object* obj = queue_pop(q);
              
              // Prefetch next 2 objects
              if (q->size >= 2) {
                  __builtin_prefetch(q->items[0]);
                  __builtin_prefetch(q->items[1]);
              }
              
              mark_object(obj);
              
              for (int i = 0; i < obj->ref_count; i++) {
                  queue_push(q, obj->refs[i]);
              }
          }
      }
    '| {
      shape: rectangle
      style.fill: "#b2dfdb"
      style.font-size: 10
    }
  }
  
  allocator -> mark_queue: "Sequential layout" {
    style.stroke-dash: 3
  }
  mark_queue -> prefetch: "Optimize further" {
    style.stroke-dash: 3
  }
}

# Performance Comparison
performance: "Performance Comparison (100K Objects)" {
  chart: |'md
    **Mark Phase Time (ms)**
    
    DFS (Random):  ████████████████████ 18.7 ms
    BFS (Basic):   ███████ 7.2 ms
    BFS (Prefetch):█████ 5.2 ms  ← 3.6x faster!
    
    
    **Cache Hit Rate**
    
    DFS (Random):  ████████ 34%
    BFS (Basic):   ████████████████████ 85%
    BFS (Prefetch):██████████████████████ 92%
    
    
    **Memory Bandwidth (GB/s)**
    
    DFS (Random):  ████████████ 4.8 GB/s
    BFS (Basic):   ████ 1.6 GB/s
    BFS (Prefetch):███ 1.2 GB/s  ← 4x less!
    
  '| {
    shape: rectangle
    style.fill: "#f1f8e9"
    style.font-size: 12
  }
}

# Hardware Details
hardware: "CPU Cache Hierarchy" {
  l1: "L1 Cache (32 KB)" {
    shape: rectangle
    style.fill: "#c5e1a5"
    
    details: |'md
      - Latency: **4 cycles** (~1.3 ns)
      - Bandwidth: 64 GB/s
      - Line size: 64 bytes
      - Associativity: 8-way
    '| {
      style.font-size: 11
    }
  }
  
  l2: "L2 Cache (256 KB)" {
    shape: rectangle
    style.fill: "#aed581"
    
    details: |'md
      - Latency: **12 cycles** (~4 ns)
      - Bandwidth: 32 GB/s
      - Line size: 64 bytes
      - Associativity: 4-way
    '| {
      style.font-size: 11
    }
  }
  
  l3: "L3 Cache (8 MB)" {
    shape: rectangle
    style.fill: "#9ccc65"
    
    details: |'md
      - Latency: **40 cycles** (~13 ns)
      - Bandwidth: 16 GB/s
      - Line size: 64 bytes
      - Shared across cores
    '| {
      style.font-size: 11
    }
  }
  
  ram: "Main Memory (16 GB)" {
    shape: rectangle
    style.fill: "#ffab91"
    
    details: |'md
      - Latency: **200 cycles** (~67 ns)
      - Bandwidth: 12 GB/s
      - **50x slower than L1!**
    '| {
      style.font-size: 11
      style.bold: true
    }
  }
  
  l1 -> l2: "Miss" {
    style.stroke-dash: 3
  }
  l2 -> l3: "Miss" {
    style.stroke-dash: 3
  }
  l3 -> ram: "Miss (expensive!)" {
    style.stroke: "#f44336"
    style.stroke-width: 3
  }
}

# Key Insight
insight: |'md
  **Key Insight: Memory is the Bottleneck**
  
  Modern CPUs are **starved for data**:
  - CPU can execute 4 instructions/cycle
  - RAM can deliver 1 cache line every 200 cycles
  - **Cache misses dominate GC performance!**
  
  **Solution**: Allocate objects sequentially and traverse breadth-first.
  
  **Result**: 3.6x speedup with zero algorithmic changes!
'| {
  shape: rectangle
  style.fill: "#fff9c4"
  style.stroke: "#fbc02d"
  style.stroke-width: 3
  style.font-size: 13
  style.bold: true
}

# Layout
memory_layout -> cache_utilization
cache_utilization -> implementation
implementation -> performance
performance -> hardware
hardware -> insight

title -> memory_layout
subtitle -> memory_layout