vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Street View: Fragmentation Patterns" {
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
    underline: true
  }
}

# ============================================================================
# SECTION 1: Fragmentation Timeline
# ============================================================================

fragmentation_timeline: "Fragmentation Timeline" {
  shape: rectangle
  style: {
    fill: "#1a1a2e"
    stroke: "#16213e"
    stroke-width: 3
  }

  t0: "T=0: Fresh Heap" {
    shape: rectangle
    style.fill: "#0f3460"
    
    heap_t0: |'md
      | **Heap State** | **Free Space** |
      |----------------|----------------|
      | [████████████] | 1024 KB (100%) |
      | Contiguous     | Max alloc: 1024 KB |
    '|
  }

  t1: "T=1: After Allocations" {
    shape: rectangle
    style.fill: "#16213e"
    
    heap_t1: |'md
      | **Heap State** | **Free Space** |
      |----------------|----------------|
      | [A][B][C][D]   | 512 KB (50%) |
      | 4 objects      | Max alloc: 128 KB |
    '|
  }

  t2: "T=2: After Partial Sweep" {
    shape: rectangle
    style.fill: "#533483"
    
    heap_t2: |'md
      | **Heap State** | **Free Space** |
      |----------------|----------------|
      | [A][░][C][░]   | 512 KB (50%) |
      | Fragmented     | Max alloc: 256 KB |
      | **External Fragmentation: 50%** |
    '|
  }

  t3: "T=3: After More Allocations" {
    shape: rectangle
    style.fill: "#e94560"
    
    heap_t3: |'md
      | **Heap State** | **Free Space** |
      |----------------|----------------|
      | [A][E][C][F][G]| 128 KB (12.5%) |
      | Highly fragmented | Max alloc: 64 KB |
      | **External Fragmentation: 87.5%** |
    '|
  }

  t0 -> t1: "alloc(A,B,C,D)"
  t1 -> t2: "sweep(B,D)"
  t2 -> t3: "alloc(E,F,G)"
}

# ============================================================================
# SECTION 2: Fragmentation Metrics
# ============================================================================

metrics: "Fragmentation Metrics" {
  shape: rectangle
  style: {
    fill: "#2d4059"
    stroke: "#ea5455"
    stroke-width: 2
  }

  external_frag: "External Fragmentation" {
    shape: rectangle
    style.fill: "#ea5455"
    
    formula: |'latex
      \text{External Frag} = \frac{\text{Total Free} - \text{Largest Block}}{\text{Total Free}} \times 100\%
    '|
    
    example: |'md
      **Example:**
      - Total free: 512 KB
      - Largest block: 64 KB
      - External frag: (512-64)/512 = **87.5%**
    '|
  }

  internal_frag: "Internal Fragmentation" {
    shape: rectangle
    style.fill: "#f07b3f"
    
    formula: |'latex
      \text{Internal Frag} = \frac{\text{Allocated} - \text{Used}}{\text{Allocated}} \times 100\%
    '|
    
    example: |'md
      **Example:**
      - Allocated: 128 bytes (power-of-2)
      - Used: 100 bytes
      - Internal frag: (128-100)/128 = **21.9%**
    '|
  }

  utilization: "Heap Utilization" {
    shape: rectangle
    style.fill: "#2ed573"
    
    formula: |'latex
      \text{Utilization} = \frac{\text{Live Objects}}{\text{Total Heap}} \times 100\%
    '|
    
    example: |'md
      **Example:**
      - Live objects: 768 KB
      - Total heap: 1024 KB
      - Utilization: 768/1024 = **75%**
    '|
  }
}

# ============================================================================
# SECTION 3: Fragmentation Patterns
# ============================================================================

patterns: "Common Fragmentation Patterns" {
  shape: rectangle
  style: {
    fill: "#1a1a2e"
    stroke: "#16213e"
    stroke-width: 3
  }

  swiss_cheese: "Swiss Cheese Pattern" {
    shape: rectangle
    style.fill: "#ffa502"
    
    visual: |'md
      
      [A][░][B][░][C][░][D][░][E]
      
      **Cause:** Alternating alloc/free
      **Impact:** High external fragmentation
      **Solution:** Compaction or bump allocator
    '|
  }

  end_fragmentation: "End Fragmentation" {
    shape: rectangle
    style.fill: "#ff6348"
    
    visual: |'md
      
      [A][B][C][D][░][░][░][░][░]
      
      **Cause:** Objects allocated at start
      **Impact:** Wasted space at end
      **Solution:** Bump pointer allocation
    '|
  }

  size_mismatch: "Size Mismatch Pattern" {
    shape: rectangle
    style.fill: "#ff4757"
    
    visual: |'md
      
      [A:1KB][░:64B][B:512B][░:32B]
      
      **Cause:** Free blocks too small
      **Impact:** Allocation failures
      **Solution:** Segregated free lists
    '|
  }
}

# ============================================================================
# SECTION 4: Allocation Failure Scenarios
# ============================================================================

failure_scenarios: "Allocation Failure Scenarios" {
  shape: rectangle
  style: {
    fill: "#2d4059"
    stroke: "#ea5455"
    stroke-width: 2
  }

  scenario1: "Scenario 1: Sufficient Total Space" {
    shape: rectangle
    style.fill: "#e74c3c"
    
    details: |'md
      **Heap State:**
      
      [A:256KB][░:128KB][B:256KB][░:128KB]
      
      **Request:** alloc(256KB)
      **Total Free:** 256 KB
      **Largest Block:** 128 KB
      **Result:** ❌ ALLOCATION FAILS
      
      **Why?** No single contiguous block large enough
    '|
  }

  scenario2: "Scenario 2: Fragmented Free List" {
    shape: rectangle
    style.fill: "#e67e22"
    
    details: |'md
      **Heap State:**
      
      [A][░:64][B][░:64][C][░:64][D][░:64]
      
      **Request:** alloc(128KB)
      **Total Free:** 256 KB
      **Largest Block:** 64 KB
      **Result:** ❌ ALLOCATION FAILS
      
      **Why?** All free blocks too small
    '|
  }

  scenario3: "Scenario 3: Compaction Needed" {
    shape: rectangle
    style.fill: "#f39c12"
    
    details: |'md
      **Before Compaction:**
      
      [A][░][B][░][C][░] → alloc(256KB) fails
      
      **After Compaction:**
      
      [A][B][C][░░░░░░░] → alloc(256KB) succeeds
      
      **Cost:** O(n) time to move objects
    '|
  }
}

# ============================================================================
# SECTION 5: Mitigation Strategies
# ============================================================================

mitigation: "Fragmentation Mitigation Strategies" {
  shape: rectangle
  style: {
    fill: "#1a1a2e"
    stroke: "#16213e"
    stroke-width: 3
  }

  compaction: "Compaction" {
    shape: rectangle
    style.fill: "#2ecc71"
    
    strategy: |'md
      **Approach:** Move live objects together
      
      **Pros:**
      - Eliminates external fragmentation
      - Enables bump allocation
      
      **Cons:**
      - O(n) time complexity
      - Requires updating pointers
      - Pauses application
      
      **When to use:** Low fragmentation tolerance
    '|
  }

  segregated_lists: "Segregated Free Lists" {
    shape: rectangle
    style.fill: "#3498db"
    
    strategy: |'md
      **Approach:** Separate free lists by size class
      
      **Size Classes:**
      - 16B, 32B, 64B, 128B, 256B, 512B, 1KB+
      
      **Pros:**
      - O(1) allocation
      - Reduces size mismatch
      
      **Cons:**
      - Internal fragmentation
      - More complex bookkeeping
      
      **When to use:** Predictable object sizes
    '|
  }

  best_fit: "Best-Fit Allocation" {
    shape: rectangle
    style.fill: "#9b59b6"
    
    strategy: |'md
      **Approach:** Choose smallest sufficient block
      
      **Algorithm:**
      c
      for each free block:
        if size >= requested:
          if size < best_size:
            best = block
      
      
      **Pros:**
      - Minimizes wasted space
      
      **Cons:**
      - O(n) search time
      - Creates tiny unusable blocks
      
      **When to use:** Memory-constrained systems
    '|
  }

  generational: "Generational Collection" {
    shape: rectangle
    style.fill: "#e74c3c"
    
    strategy: |'md
      **Approach:** Separate young/old objects
      
      **Young Generation:**
      - Frequent collection
      - Bump allocation
      - Low fragmentation
      
      **Old Generation:**
      - Infrequent collection
      - Free list allocation
      - Higher fragmentation tolerated
      
      **When to use:** Most applications
    '|
  }
}

# ============================================================================
# SECTION 6: Fragmentation Over Time
# ============================================================================

time_series: "Fragmentation Over Time" {
  shape: rectangle
  style: {
    fill: "#2d4059"
    stroke: "#ea5455"
    stroke-width: 2
  }

  graph: "Fragmentation Growth" {
    shape: rectangle
    style.fill: "#34495e"
    
    chart: |'md
      
      External Frag (%)
      100 |                    ╱─────
          |                 ╱
       75 |              ╱
          |           ╱
       50 |        ╱
          |     ╱
       25 |  ╱
          |╱
        0 +─────────────────────────→ Time
          0   10  20  30  40  50  60 (GC cycles)
      
      Without compaction: Grows to 80-90%
      With compaction: Stays below 20%
      
    '|
  }

  phases: "Fragmentation Phases" {
    shape: rectangle
    style.fill: "#2c3e50"
    
    lifecycle: |'md
      **Phase 1: Startup (0-10 cycles)**
      - Low fragmentation (< 10%)
      - Bump allocation dominates
      
      **Phase 2: Steady State (10-50 cycles)**
      - Moderate fragmentation (20-40%)
      - Mix of alloc/free patterns
      
      **Phase 3: Degradation (50+ cycles)**
      - High fragmentation (60-90%)
      - Allocation failures increase
      - **Compaction required**
    '|
  }
}

# ============================================================================
# SECTION 7: Real-World Example
# ============================================================================

real_world: "Real-World Example: Web Server" {
  shape: rectangle
  style: {
    fill: "#1a1a2e"
    stroke: "#16213e"
    stroke-width: 3
  }

  workload: "Workload Characteristics" {
    shape: rectangle
    style.fill: "#16a085"
    
    details: |'md
      **Request Pattern:**
      - 1000 requests/sec
      - Each request allocates:
        - 10 small objects (16-64 bytes)
        - 2 medium objects (256-512 bytes)
        - 1 large object (4-8 KB)
      
      **Object Lifetime:**
      - 90% die within 1 GC cycle
      - 9% survive 2-5 cycles
      - 1% live forever (caches)
    '|
  }

  fragmentation_impact: "Fragmentation Impact" {
    shape: rectangle
    style.fill: "#c0392b"
    
    impact: |'md
      **Without Mitigation:**
      - External frag: 75% after 100 cycles
      - Allocation failures: 5% of requests
      - Latency p99: 500ms (due to GC pauses)
      
      **With Generational GC:**
      - External frag: 15% (young gen)
      - Allocation failures: < 0.01%
      - Latency p99: 50ms
      
      **10x improvement in tail latency!**
    '|
  }
}

# ============================================================================
# SECTION 8: Debugging Fragmentation
# ============================================================================

debugging: "Debugging Fragmentation" {
  shape: rectangle
  style: {
    fill: "#2d4059"
    stroke: "#ea5455"
    stroke-width: 2
  }

  tools: "Diagnostic Tools" {
    shape: rectangle
    style.fill: "#8e44ad"
    
    toolset: |'md
      **1. Heap Visualizer**
      c
      void print_heap_map(GC* gc) {
        for (Block* b = gc->heap_start; b < gc->heap_end; b++) {
          printf(is_free(b) ? "░" : "█");
        }
      }
      
      
      **2. Fragmentation Metrics**
      c
      double external_frag = 
        (total_free - largest_block) / total_free;
      
      
      **3. Allocation Heatmap**
      - Track allocation success rate by size
      - Identify problematic size classes
    '|
  }

  symptoms: "Fragmentation Symptoms" {
    shape: rectangle
    style.fill: "#e74c3c"
    
    signs: |'md
      **Red Flags:**
      
      ❌ Allocation failures despite free space
      ❌ GC frequency increases over time
      ❌ Heap utilization < 50%
      ❌ Large variance in GC pause times
      ❌ Memory usage grows unbounded
      
      **Root Cause:**
      - External fragmentation > 50%
      - No compaction strategy
      - Poor size class distribution
    '|
  }
}

# ============================================================================
# SECTION 9: Performance Characteristics
# ============================================================================

performance: "Performance Characteristics" {
  shape: rectangle
  style: {
    fill: "#1a1a2e"
    stroke: "#16213e"
    stroke-width: 3
  }

  table: |'md
    | **Strategy** | **Alloc Time** | **Frag Overhead** | **GC Pause** |
    |--------------|----------------|-------------------|--------------|
    | **No mitigation** | O(n) | 80-90% | 10-50ms |
    | **Best-fit** | O(n) | 40-60% | 10-50ms |
    | **Segregated lists** | O(1) | 20-30% | 10-50ms |
    | **Compaction** | O(1) | 5-10% | 50-200ms |
    | **Generational** | O(1) | 10-20% | 5-20ms |
    
    **Recommendation:** Generational GC with compaction
  '|
}

# ============================================================================
# CONNECTIONS
# ============================================================================

fragmentation_timeline -> metrics: "measure"
metrics -> patterns: "identify"
patterns -> failure_scenarios: "cause"
failure_scenarios -> mitigation: "solve with"
mitigation -> time_series: "track over"
time_series -> real_world: "apply to"
real_world -> debugging: "diagnose with"
debugging -> performance: "optimize for"