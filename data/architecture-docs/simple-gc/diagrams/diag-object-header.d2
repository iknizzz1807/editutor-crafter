vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Microscopic View: Object Header Structure (64-bit)" {
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
    underline: true
  }
}

# Main container for the object header
object_header: "ObjectHeader (16 bytes)" {
  shape: rectangle
  style: {
    fill: "#2E3440"
    stroke: "#88C0D0"
    stroke-width: 3
    font-color: "#ECEFF4"
  }

  # Byte 0-7: Size and mark bit
  bytes_0_7: "Bytes 0-7: size (63 bits) + mark (1 bit)" {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#88C0D0"
      font-color: "#D8DEE9"
    }

    bit_layout: |'md
      | Bits | Field | Description |
      |------|-------|-------------|
      | 63   | mark  | Mark bit (0=white, 1=black) |
      | 62-0 | size  | Object size in bytes (max 8 PB) |
    '| {
      shape: rectangle
      style: {
        fill: "#434C5E"
        stroke: "#5E81AC"
        font-color: "#ECEFF4"
      }
    }

    example: |'md
      **Example**: 128-byte object, marked
      
      0x8000000000000080
      │└─────────────────┴─ size = 128 (0x80)
      └─ mark = 1
      
    '| {
      shape: rectangle
      style: {
        fill: "#4C566A"
        stroke: "#81A1C1"
        font-color: "#ECEFF4"
      }
    }
  }

  # Byte 8-15: Type pointer
  bytes_8_15: "Bytes 8-15: type (pointer to TypeInfo)" {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#88C0D0"
      font-color: "#D8DEE9"
    }

    type_info: |'md
      | Bits | Field | Description |
      |------|-------|-------------|
      | 63-0 | type  | Pointer to TypeInfo struct |
    '| {
      shape: rectangle
      style: {
        fill: "#434C5E"
        stroke: "#5E81AC"
        font-color: "#ECEFF4"
      }
    }

    example: |'md
      **Example**: Pointer to TypeInfo
      
      0x00007f8a4c001000
      └─ Points to TypeInfo for "MyClass"
      
    '| {
      shape: rectangle
      style: {
        fill: "#4C566A"
        stroke: "#81A1C1"
        font-color: "#ECEFF4"
      }
    }
  }
}

# Memory layout visualization
memory_layout: "Memory Layout (16-byte aligned)" {
  shape: rectangle
  style: {
    fill: "#2E3440"
    stroke: "#A3BE8C"
    stroke-width: 3
    font-color: "#ECEFF4"
  }

  layout_diagram: |'md
    
    Offset  │ Field          │ Size │ Alignment
    ────────┼────────────────┼──────┼──────────
    +0      │ size + mark    │ 8 B  │ 8-byte
    +8      │ type           │ 8 B  │ 8-byte
    +16     │ [user data]    │ ...  │ 16-byte
    
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#A3BE8C"
      font-color: "#ECEFF4"
    }
  }

  padding_note: "⚠️ Total header = 16 bytes (ensures 16-byte alignment)" {
    shape: rectangle
    style: {
      fill: "#4C566A"
      stroke: "#EBCB8B"
      font-color: "#ECEFF4"
    }
  }
}

# Bit manipulation operations
bit_ops: "Bit Manipulation Operations" {
  shape: rectangle
  style: {
    fill: "#2E3440"
    stroke: "#BF616A"
    stroke-width: 3
    font-color: "#ECEFF4"
  }

  get_size: |'c
    // Extract size (clear mark bit)
    size_t get_size(ObjectHeader* h) {
        return h->size_and_mark & ~1ULL;
    }
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#BF616A"
      font-color: "#D8DEE9"
    }
  }

  is_marked: |'c
    // Check mark bit
    bool is_marked(ObjectHeader* h) {
        return h->size_and_mark & 1;
    }
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#BF616A"
      font-color: "#D8DEE9"
    }
  }

  set_mark: |'c
    // Set mark bit (atomic)
    void set_mark(ObjectHeader* h) {
        __atomic_or_fetch(
            &h->size_and_mark, 1, 
            __ATOMIC_RELEASE
        );
    }
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#BF616A"
      font-color: "#D8DEE9"
    }
  }

  clear_mark: |'c
    // Clear mark bit
    void clear_mark(ObjectHeader* h) {
        h->size_and_mark &= ~1ULL;
    }
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#BF616A"
      font-color: "#D8DEE9"
    }
  }
}

# Example object in memory
example_object: "Example: 128-byte Object in Memory" {
  shape: rectangle
  style: {
    fill: "#2E3440"
    stroke: "#B48EAD"
    stroke-width: 3
    font-color: "#ECEFF4"
  }

  memory_dump: |'md
    
    Address         │ Hex Value          │ Interpretation
    ────────────────┼────────────────────┼─────────────────
    0x7f8a4c002000  │ 0x8000000000000080 │ size=128, mark=1
    0x7f8a4c002008  │ 0x00007f8a4c001000 │ type=0x7f8a4c001000
    0x7f8a4c002010  │ 0x4142434445464748 │ [user data...]
    0x7f8a4c002018  │ 0x494a4b4c4d4e4f50 │ [user data...]
    ...             │ ...                │ ...
    0x7f8a4c002078  │ 0x7172737475767778 │ [user data...]
    
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#B48EAD"
      font-color: "#ECEFF4"
    }
  }

  calculation: "Total size = 16 (header) + 128 (data) = 144 bytes" {
    shape: rectangle
    style: {
      fill: "#4C566A"
      stroke: "#B48EAD"
      font-color: "#ECEFF4"
    }
  }
}

# Alignment constraints
alignment: "Alignment Constraints" {
  shape: rectangle
  style: {
    fill: "#2E3440"
    stroke: "#D08770"
    stroke-width: 3
    font-color: "#ECEFF4"
  }

  why_16_bytes: |'md
    **Why 16-byte alignment?**
    
    1. **SIMD**: AVX-512 requires 64-byte, but 16-byte is common
    2. **Cache lines**: 64-byte cache lines, 16-byte sub-blocks
    3. **malloc**: Most allocators return 16-byte aligned memory
    4. **Performance**: Reduces false sharing, improves prefetch
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#D08770"
      font-color: "#ECEFF4"
    }
  }

  padding_example: |'md
    **Example**: 100-byte allocation
    
    Requested: 100 bytes
    Header:     16 bytes
    Padding:     4 bytes (to reach 120, next multiple of 16)
    Allocated: 120 bytes total
    
  '| {
    shape: rectangle
    style: {
      fill: "#4C566A"
      stroke: "#D08770"
      font-color: "#ECEFF4"
    }
  }
}

# Performance implications
performance: "Performance Implications" {
  shape: rectangle
  style: {
    fill: "#2E3440"
    stroke: "#A3BE8C"
    stroke-width: 3
    font-color: "#ECEFF4"
  }

  overhead: |'md
    **Memory Overhead**
    - Small objects (16 bytes): 100% overhead
    - Medium objects (128 bytes): 12.5% overhead
    - Large objects (1 KB): 1.6% overhead
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#A3BE8C"
      font-color: "#ECEFF4"
    }
  }

  cache_efficiency: |'md
    **Cache Efficiency**
    - Header fits in 1 cache line (64 bytes)
    - Prefetching: `__builtin_prefetch(obj, 0, 3)`
    - False sharing: Avoided by 16-byte alignment
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#A3BE8C"
      font-color: "#ECEFF4"
    }
  }

  atomic_ops: |'md
    **Atomic Operations**
    - Mark bit: Single atomic OR (`__atomic_or_fetch`)
    - No ABA problem (mark bit is monotonic during GC)
    - Lock-free marking in parallel GC
  '| {
    shape: rectangle
    style: {
      fill: "#3B4252"
      stroke: "#A3BE8C"
      font-color: "#ECEFF4"
    }
  }
}

# Connections
object_header -> memory_layout: "Laid out as" {
  style.stroke: "#88C0D0"
  style.stroke-width: 2
}

object_header -> bit_ops: "Manipulated by" {
  style.stroke: "#BF616A"
  style.stroke-width: 2
}

memory_layout -> example_object: "Example" {
  style.stroke: "#B48EAD"
  style.stroke-width: 2
}

memory_layout -> alignment: "Constrained by" {
  style.stroke: "#D08770"
  style.stroke-width: 2
}

bit_ops -> performance: "Affects" {
  style.stroke: "#A3BE8C"
  style.stroke-width: 2
}

alignment -> performance: "Impacts" {
  style.stroke: "#A3BE8C"
  style.stroke-width: 2
}