vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: "Street View: Performance Critical Paths" {
  near: top-center
  shape: text
  style: {
    font-size: 28
    bold: true
    underline: true
  }
}

subtitle: "Annotated system diagram highlighting performance-critical sections" {
  near: top-center
  shape: text
  style: {
    font-size: 16
    italic: true
  }
}

legend: |md
  ## Legend
  ðŸ”¥ **Critical Path** - Executed millions of times per second
  âš¡ **Hot Loop** - Dominates CPU time
  ðŸŽ¯ **Optimization Target** - High impact/effort ratio
| {
  near: top-right
  style: {
    font-size: 14
    stroke: "#FFD700"
    fill: "#FFFACD"
  }
}

# ============================================================================
# ALLOCATION FAST PATH (CRITICAL)
# ============================================================================

allocation_fast_path: "ðŸ”¥ Allocation Fast Path" {
  shape: rectangle
  style: {
    fill: "#FF6B6B"
    stroke: "#C92A2A"
    stroke-width: 4
    bold: true
  }
  link: "#anchor-performance"

  bump_pointer: "Bump Pointer Allocation" {
    shape: step
    style: {
      fill: "#FFE5E5"
      stroke: "#C92A2A"
    }
    
    check_space: "1. Check: heap_ptr + size < heap_end?" {
      style.font-size: 13
    }
    
    allocate: "2. ptr = heap_ptr" {
      style.font-size: 13
    }
    
    advance: "3. heap_ptr += size" {
      style.font-size: 13
    }
    
    return: "4. return ptr" {
      style.font-size: 13
    }
  }

  perf_note: |md
    âš¡ **Performance:**
    - 3-5 CPU instructions
    - No locks, no syscalls
    - ~1-2 nanoseconds
    
    ðŸŽ¯ **Optimization:**
    - Keep heap_ptr in register
    - Inline in hot paths
    - Prefetch next cache line
  | {
    shape: text
    style: {
      font-size: 12
      fill: "#FFF5F5"
      stroke: "#C92A2A"
    }
  }
}

# ============================================================================
# MARK PHASE (HOT LOOP)
# ============================================================================

mark_phase: "âš¡ Mark Phase (Hot Loop)" {
  shape: rectangle
  style: {
    fill: "#FFA94D"
    stroke: "#D9480F"
    stroke-width: 4
    bold: true
  }
  link: "#anchor-performance"

  mark_queue: "Mark Queue (BFS)" {
    shape: queue
    style: {
      fill: "#FFE8CC"
      stroke: "#D9480F"
    }
  }

  mark_loop: "Mark Loop" {
    shape: step
    style: {
      fill: "#FFE8CC"
      stroke: "#D9480F"
    }
    
    dequeue: "1. obj = dequeue()" {
      style.font-size: 13
    }
    
    check_marked: "2. if (is_marked(obj)) continue" {
      style.font-size: 13
    }
    
    set_bit: "3. set_bit(bitmap, obj)" {
      style.font-size: 13
    }
    
    scan_children: "4. for each child: enqueue(child)" {
      style.font-size: 13
    }
  }

  bitmap_ops: "Bitmap Operations" {
    shape: cylinder
    style: {
      fill: "#FFE8CC"
      stroke: "#D9480F"
    }
    
    set_bit_impl: |'md
      c
      // ðŸ”¥ CRITICAL: Executed per object
      static inline void set_bit(uint64_t* bitmap, size_t index) {
          size_t word = index / 64;
          size_t bit = index % 64;
          bitmap[word] |= (1ULL << bit);  // âš¡ Single instruction
      }
      
    '| {
      style.font-size: 11
    }
  }

  perf_note: |md
    âš¡ **Performance:**
    - Dominates GC time (60-80%)
    - Cache-sensitive (bitmap + objects)
    - Branch-heavy (marked check)
    
    ðŸŽ¯ **Optimizations:**
    - Prefetch next object
    - Batch bitmap updates
    - SIMD for child scanning
    - Lock-free queue for parallel marking
  | {
    shape: text
    style: {
      font-size: 12
      fill: "#FFF4E6"
      stroke: "#D9480F"
    }
  }
}

# ============================================================================
# SWEEP PHASE (ITERATION HEAVY)
# ============================================================================

sweep_phase: "âš¡ Sweep Phase (Iteration Heavy)" {
  shape: rectangle
  style: {
    fill: "#51CF66"
    stroke: "#2B8A3E"
    stroke-width: 4
    bold: true
  }
  link: "#anchor-performance"

  sweep_loop: "Sweep Loop" {
    shape: step
    style: {
      fill: "#D3F9D8"
      stroke: "#2B8A3E"
    }
    
    iterate: "1. for (ptr = heap_start; ptr < heap_end; ptr += size)" {
      style.font-size: 13
    }
    
    check_marked: "2. if (!is_marked(ptr)) {" {
      style.font-size: 13
    }
    
    free: "3.     free_object(ptr)" {
      style.font-size: 13
    }
    
    update_stats: "4.     freed_bytes += size" {
      style.font-size: 13
    }
  }

  parallel_sweep: "Parallel Sweep (4 threads)" {
    shape: rectangle
    style: {
      fill: "#D3F9D8"
      stroke: "#2B8A3E"
      multiple: true
    }
    
    thread_1: "Thread 1: [0, 25%)" {
      style.font-size: 12
    }
    thread_2: "Thread 2: [25%, 50%)" {
      style.font-size: 12
    }
    thread_3: "Thread 3: [50%, 75%)" {
      style.font-size: 12
    }
    thread_4: "Thread 4: [75%, 100%)" {
      style.font-size: 12
    }
  }

  perf_note: |md
    âš¡ **Performance:**
    - Linear scan of entire heap
    - Cache-friendly (sequential access)
    - Embarrassingly parallel
    
    ðŸŽ¯ **Optimizations:**
    - 4-8 threads for large heaps
    - Atomic counter for freed_bytes
    - Skip large marked regions (bitmap scan)
    - Lazy sweep (sweep on next alloc)
  | {
    shape: text
    style: {
      font-size: 12
      fill: "#EBFBEE"
      stroke: "#2B8A3E"
    }
  }
}

# ============================================================================
# MEMORY LAYOUT (CACHE OPTIMIZATION)
# ============================================================================

memory_layout: "ðŸŽ¯ Memory Layout (Cache Optimization)" {
  shape: rectangle
  style: {
    fill: "#748FFC"
    stroke: "#364FC7"
    stroke-width: 4
    bold: true
  }
  link: "#anchor-performance"

  cache_line: "Cache Line (64 bytes)" {
    shape: rectangle
    style: {
      fill: "#E5DBFF"
      stroke: "#364FC7"
    }
    
    object_header: "Object Header (16 bytes)" {
      style: {
        font-size: 12
        fill: "#D0BFFF"
      }
    }
    
    object_data: "Object Data (48 bytes)" {
      style: {
        font-size: 12
        fill: "#D0BFFF"
      }
    }
  }

  bitmap_layout: "Bitmap Layout" {
    shape: cylinder
    style: {
      fill: "#E5DBFF"
      stroke: "#364FC7"
    }
    
    bitmap_structure: |'md
      
      Heap:   [Obj1][Obj2][Obj3][Obj4]...
      Bitmap: [0001][0010][0011][0100]...
               â†‘     â†‘     â†‘     â†‘
               64B   64B   64B   64B per cache line
      
    '| {
      style.font-size: 11
    }
  }

  perf_note: |md
    âš¡ **Cache Behavior:**
    - L1 hit: ~1 ns
    - L2 hit: ~3 ns
    - L3 hit: ~10 ns
    - RAM miss: ~100 ns
    
    ðŸŽ¯ **Optimizations:**
    - Align objects to 64-byte boundaries
    - Pack bitmap densely (1 bit per 64 bytes)
    - Prefetch next cache line during mark
    - Keep hot data (heap_ptr, bitmap) in L1
  | {
    shape: text
    style: {
      font-size: 12
      fill: "#F3F0FF"
      stroke: "#364FC7"
    }
  }
}

# ============================================================================
# PERFORMANCE BOTTLENECKS
# ============================================================================

bottlenecks: "ðŸ”¥ Performance Bottlenecks" {
  shape: rectangle
  style: {
    fill: "#FF8787"
    stroke: "#C92A2A"
    stroke-width: 3
    bold: true
  }

  bottleneck_1: "1. Cache Misses in Mark Phase" {
    shape: rectangle
    style: {
      fill: "#FFE5E5"
      stroke: "#C92A2A"
    }
    
    problem: |md
      **Problem:**
      - Random access to objects
      - Bitmap scattered across memory
      - 50-70% of time in cache misses
    | {
      style.font-size: 12
    }
    
    solution: |md
      **Solution:**
      - Prefetch next 2-3 objects
      - Batch bitmap updates
      - Use SIMD for child scanning
    | {
      style.font-size: 12
    }
  }

  bottleneck_2: "2. Atomic Operations in Parallel Sweep" {
    shape: rectangle
    style: {
      fill: "#FFE5E5"
      stroke: "#C92A2A"
    }
    
    problem: |md
      **Problem:**
      - `atomic_add(&freed_bytes, size)` per object
      - Cache line bouncing between threads
      - 20-30% overhead
    | {
      style.font-size: 12
    }
    
    solution: |md
      **Solution:**
      - Thread-local counters
      - Aggregate at end
      - Reduces contention by 90%
    | {
      style.font-size: 12
    }
  }

  bottleneck_3: "3. Branch Mispredictions" {
    shape: rectangle
    style: {
      fill: "#FFE5E5"
      stroke: "#C92A2A"
    }
    
    problem: |md
      **Problem:**
      - `if (is_marked(obj))` unpredictable
      - 10-15% of cycles wasted
    | {
      style.font-size: 12
    }
    
    solution: |md
      **Solution:**
      - Branchless bitmap check
      - `marked = (bitmap[word] >> bit) & 1`
      - Process in batches
    | {
      style.font-size: 12
    }
  }
}

# ============================================================================
# OPTIMIZATION OPPORTUNITIES
# ============================================================================

optimizations: "ðŸŽ¯ Optimization Opportunities" {
  shape: rectangle
  style: {
    fill: "#69DB7C"
    stroke: "#2B8A3E"
    stroke-width: 3
    bold: true
  }

  opt_1: "1. Lazy Sweep (10-20% speedup)" {
    shape: rectangle
    style: {
      fill: "#D3F9D8"
      stroke: "#2B8A3E"
    }
    
    desc: |md
      **Idea:** Don't sweep immediately after mark.
      Sweep incrementally during next allocations.
      
      **Benefit:** Amortizes sweep cost, reduces pause time.
    | {
      style.font-size: 12
    }
  }

  opt_2: "2. Generational GC (5-10x speedup)" {
    shape: rectangle
    style: {
      fill: "#D3F9D8"
      stroke: "#2B8A3E"
    }
    
    desc: |md
      **Idea:** Most objects die young.
      Collect young generation frequently, old generation rarely.
      
      **Benefit:** 90% of objects collected in <1ms.
    | {
      style.font-size: 12
    }
  }

  opt_3: "3. Incremental Marking (Eliminate pauses)" {
    shape: rectangle
    style: {
      fill: "#D3F9D8"
      stroke: "#2B8A3E"
    }
    
    desc: |md
      **Idea:** Mark a few objects per allocation.
      Spread GC work across program execution.
      
      **Benefit:** No stop-the-world pauses.
    | {
      style.font-size: 12
    }
  }

  opt_4: "4. SIMD Bitmap Scanning (2-3x speedup)" {
    shape: rectangle
    style: {
      fill: "#D3F9D8"
      stroke: "#2B8A3E"
    }
    
    desc: |md
      **Idea:** Use AVX2/AVX-512 to scan 256/512 bits at once.
      
      **Benefit:** Find unmarked objects 4-8x faster.
    | {
      style.font-size: 12
    }
  }
}

# ============================================================================
# PERFORMANCE METRICS
# ============================================================================

metrics: "ðŸ“Š Performance Metrics" {
  shape: rectangle
  style: {
    fill: "#FFD43B"
    stroke: "#F59F00"
    stroke-width: 3
    bold: true
  }

  table: |'md
    | Operation | Time | Frequency | Impact |
    |-----------|------|-----------|--------|
    | **Allocation** | 1-2 ns | 1M/sec | ðŸ”¥ Critical |
    | **Mark (per object)** | 10-20 ns | 100K/GC | âš¡ Hot |
    | **Sweep (per object)** | 5-10 ns | 100K/GC | âš¡ Hot |
    | **GC Pause (100MB heap)** | 10-20 ms | 1/sec | ðŸŽ¯ Target |
    | **Throughput** | 95-98% | - | ðŸŽ¯ Target |
  '| {
    style.font-size: 13
  }

  targets: |md
    ## Performance Targets
    - **Allocation:** < 5 ns (inline bump pointer)
    - **GC Pause:** < 20 ms (100MB heap, 100K objects)
    - **Throughput:** > 95% (app time / total time)
    - **Memory Overhead:** < 10% (bitmap + metadata)
  | {
    style.font-size: 12
  }
}

# ============================================================================
# PROFILING TOOLS
# ============================================================================

profiling: "ðŸ”¬ Profiling Tools" {
  shape: rectangle
  style: {
    fill: "#A9E34B"
    stroke: "#5C940D"
    stroke-width: 3
    bold: true
  }

  perf: "perf (Linux)" {
    shape: rectangle
    style: {
      fill: "#E9FAC8"
      stroke: "#5C940D"
    }
    
    commands: |'md
      bash
      # Record GC performance
      perf record -g ./gc_benchmark
      
      # Analyze hotspots
      perf report
      
      # Cache misses
      perf stat -e cache-misses,cache-references ./gc_benchmark
      
    '| {
      style.font-size: 11
    }
  }

  vtune: "Intel VTune" {
    shape: rectangle
    style: {
      fill: "#E9FAC8"
      stroke: "#5C940D"
    }
    
    features: |md
      - Microarchitecture analysis
      - Cache hierarchy visualization
      - Branch prediction stats
      - Thread synchronization overhead
    | {
      style.font-size: 12
    }
  }

  valgrind: "Valgrind (Cachegrind)" {
    shape: rectangle
    style: {
      fill: "#E9FAC8"
      stroke: "#5C940D"
    }
    
    commands: |'md
      bash
      # Cache simulation
      valgrind --tool=cachegrind ./gc_benchmark
      
      # Visualize with KCachegrind
      kcachegrind cachegrind.out.*
      
    '| {
      style.font-size: 11
    }
  }
}

# ============================================================================
# CONNECTIONS
# ============================================================================

allocation_fast_path.bump_pointer -> mark_phase.mark_queue: "Trigger GC when heap full" {
  style: {
    stroke: "#C92A2A"
    stroke-width: 3
    stroke-dash: 3
  }
}

mark_phase.mark_loop -> mark_phase.bitmap_ops: "Set bit per object" {
  style: {
    stroke: "#D9480F"
    stroke-width: 2
  }
}

mark_phase.bitmap_ops -> sweep_phase.sweep_loop: "Bitmap guides sweep" {
  style: {
    stroke: "#2B8A3E"
    stroke-width: 2
  }
}

sweep_phase.sweep_loop -> sweep_phase.parallel_sweep: "Parallelize for large heaps" {
  style: {
    stroke: "#2B8A3E"
    stroke-width: 2
  }
}

memory_layout.cache_line -> mark_phase.mark_loop: "Cache-friendly layout" {
  style: {
    stroke: "#364FC7"
    stroke-width: 2
    stroke-dash: 5
  }
}

memory_layout.bitmap_layout -> sweep_phase.sweep_loop: "Bitmap in separate region" {
  style: {
    stroke: "#364FC7"
    stroke-width: 2
    stroke-dash: 5
  }
}

bottlenecks.bottleneck_1 -> optimizations.opt_4: "SIMD fixes cache misses" {
  style: {
    stroke: "#2B8A3E"
    stroke-width: 2
    animated: true
  }
}

bottlenecks.bottleneck_2 -> optimizations.opt_1: "Lazy sweep reduces contention" {
  style: {
    stroke: "#2B8A3E"
    stroke-width: 2
    animated: true
  }
}

bottlenecks.bottleneck_3 -> optimizations.opt_2: "Generational GC improves prediction" {
  style: {
    stroke: "#2B8A3E"
    stroke-width: 2
    animated: true
  }
}

profiling.perf -> metrics: "Measure actual performance" {
  style: {
    stroke: "#5C940D"
    stroke-width: 2
  }
}

profiling.vtune -> bottlenecks: "Identify bottlenecks" {
  style: {
    stroke: "#5C940D"
    stroke-width: 2
  }
}

profiling.valgrind -> memory_layout: "Analyze cache behavior" {
  style: {
    stroke: "#5C940D"
    stroke-width: 2
  }
}