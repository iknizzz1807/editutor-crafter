vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Microscopic: Free Block Coalescing
  ## Step-by-Step Merging of Adjacent Free Blocks During Sweep
| {
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
    underline: true
  }
}

# Initial heap state before sweep
initial_state: Initial Heap State (Before Sweep) {
  shape: rectangle
  style: {
    fill: "#f0f0f0"
    stroke: "#333"
    stroke-width: 2
  }
  
  heap_layout: |'md
  | Offset | Size | Status | Marked |
  |--------|------|--------|--------|
  | 0x0000 | 128  | Used   | ✓      |
  | 0x0080 | 64   | Used   | ✗      |
  | 0x00C0 | 32   | Used   | ✗      |
  | 0x00E0 | 256  | Used   | ✓      |
  | 0x01E0 | 128  | Used   | ✗      |
  | 0x0260 | 64   | Used   | ✗      |
  '| {
    shape: rectangle
    style: {
      fill: white
      font: mono
      font-size: 14
    }
  }
}

# Step 1: Identify first unmarked block
step1: Step 1: Identify First Unmarked Block {
  shape: rectangle
  style: {
    fill: "#fff3cd"
    stroke: "#856404"
    stroke-width: 2
  }
  
  action: |md
  **Action**: Sweep encounters block at 0x0080
  - Size: 64 bytes
  - Marked: ✗ (garbage)
  - **Decision**: Free this block
| {
    shape: rectangle
    style: {
      fill: "#fffacd"
    }
  }
  
  code: |c
  // Sweep iteration 1
  Block* current = heap_start + 0x0080;
  if (!is_marked(current)) {
      free_block(current);  // Mark as free
      current_free_start = current;
      current_free_size = 64;
  }
| {
    shape: rectangle
    style: {
      fill: "#f5f5f5"
      font: mono
    }
  }
  
  memory_view: |'md
  | Offset | Size | Status | Action |
  |--------|------|--------|--------|
  | 0x0000 | 128  | Used   | Keep   |
  | **0x0080** | **64**   | **Free**   | **Freed** |
  | 0x00C0 | 32   | Used   | Next   |
  '| {
    shape: rectangle
    style: {
      fill: white
      font: mono
      font-size: 14
    }
  }
}

# Step 2: Encounter adjacent unmarked block
step2: Step 2: Encounter Adjacent Unmarked Block {
  shape: rectangle
  style: {
    fill: "#d1ecf1"
    stroke: "#0c5460"
    stroke-width: 2
  }
  
  action: |md
  **Action**: Next block at 0x00C0 is also unmarked
  - Size: 32 bytes
  - Marked: ✗ (garbage)
  - **Decision**: Coalesce with previous free block
| {
    shape: rectangle
    style: {
      fill: "#d4edda"
    }
  }
  
  code: |c
  // Sweep iteration 2
  Block* next = current + current->size;  // 0x00C0
  if (!is_marked(next)) {
      // Adjacent free blocks - coalesce!
      current_free_size += next->size;  // 64 + 32 = 96
      // Don't add to free list yet
  }
| {
    shape: rectangle
    style: {
      fill: "#f5f5f5"
      font: mono
    }
  }
  
  memory_view: |'md
  | Offset | Size | Status | Action |
  |--------|------|--------|--------|
  | 0x0000 | 128  | Used   | Keep   |
  | **0x0080** | **96**   | **Free**   | **Coalesced** |
  | ~~0x00C0~~ | ~~32~~   | ~~Free~~   | ~~Merged~~ |
  | 0x00E0 | 256  | Used   | Next   |
  '| {
    shape: rectangle
    style: {
      fill: white
      font: mono
      font-size: 14
    }
  }
}

# Step 3: Encounter marked block (boundary)
step3: Step 3: Encounter Marked Block (Boundary) {
  shape: rectangle
  style: {
    fill: "#f8d7da"
    stroke: "#721c24"
    stroke-width: 2
  }
  
  action: |md
  **Action**: Block at 0x00E0 is marked (live)
  - Size: 256 bytes
  - Marked: ✓ (reachable)
  - **Decision**: Finalize coalesced free block, add to free list
| {
    shape: rectangle
    style: {
      fill: "#f5c6cb"
    }
  }
  
  code: |c
  // Sweep iteration 3
  Block* next = current + current_free_size;  // 0x00E0
  if (is_marked(next)) {
      // End of free region - add to free list
      FreeBlock* free = (FreeBlock*)current_free_start;
      free->size = current_free_size;  // 96 bytes
      add_to_free_list(free);
      
      current_free_start = NULL;
      current_free_size = 0;
  }
| {
    shape: rectangle
    style: {
      fill: "#f5f5f5"
      font: mono
    }
  }
  
  memory_view: |'md
  | Offset | Size | Status | Action |
  |--------|------|--------|--------|
  | 0x0000 | 128  | Used   | Keep   |
  | **0x0080** | **96**   | **Free**   | **Added to free list** |
  | 0x00E0 | 256  | Used   | Keep (marked) |
  | 0x01E0 | 128  | Used   | Next   |
  '| {
    shape: rectangle
    style: {
      fill: white
      font: mono
      font-size: 14
    }
  }
}

# Step 4: Continue sweep - another free region
step4: Step 4: Continue Sweep - Another Free Region {
  shape: rectangle
  style: {
    fill: "#e2e3e5"
    stroke: "#383d41"
    stroke-width: 2
  }
  
  action: |md
  **Action**: Blocks at 0x01E0 and 0x0260 are both unmarked
  - 0x01E0: 128 bytes (unmarked)
  - 0x0260: 64 bytes (unmarked)
  - **Decision**: Coalesce into 192-byte free block
| {
    shape: rectangle
    style: {
      fill: "#d6d8db"
    }
  }
  
  code: |c
  // Sweep iterations 4-5
  Block* b1 = heap_start + 0x01E0;
  if (!is_marked(b1)) {
      current_free_start = b1;
      current_free_size = 128;
  }
  
  Block* b2 = b1 + 128;  // 0x0260
  if (!is_marked(b2)) {
      current_free_size += 64;  // 128 + 64 = 192
  }
  
  // End of heap - finalize
  FreeBlock* free = (FreeBlock*)current_free_start;
  free->size = 192;
  add_to_free_list(free);
| {
    shape: rectangle
    style: {
      fill: "#f5f5f5"
      font: mono
    }
  }
  
  memory_view: |'md
  | Offset | Size | Status | Action |
  |--------|------|--------|--------|
  | 0x0000 | 128  | Used   | Keep   |
  | 0x0080 | 96   | Free   | In free list |
  | 0x00E0 | 256  | Used   | Keep   |
  | **0x01E0** | **192**  | **Free**   | **Coalesced + added** |
  | ~~0x0260~~ | ~~64~~   | ~~Free~~   | ~~Merged~~ |
  '| {
    shape: rectangle
    style: {
      fill: white
      font: mono
      font-size: 14
    }
  }
}

# Final state after coalescing
final_state: Final Heap State (After Coalescing) {
  shape: rectangle
  style: {
    fill: "#d4edda"
    stroke: "#155724"
    stroke-width: 3
  }
  
  summary: |md
  **Coalescing Results**:
  - **Before**: 3 small free blocks (64 + 32 + 128 + 64 = 288 bytes)
  - **After**: 2 large free blocks (96 + 192 = 288 bytes)
  - **Fragmentation reduced**: 4 blocks → 2 blocks
  - **Allocation efficiency improved**: Can now satisfy 96-byte and 192-byte requests
| {
    shape: rectangle
    style: {
      fill: "#c3e6cb"
    }
  }
  
  free_list: |'md
  **Free List**:
  | Address | Size | Next |
  |---------|------|------|
  | 0x0080  | 96   | 0x01E0 |
  | 0x01E0  | 192  | NULL |
  '| {
    shape: rectangle
    style: {
      fill: white
      font: mono
      font-size: 14
    }
  }
  
  heap_layout: |'md
  | Offset | Size | Status |
  |--------|------|--------|
  | 0x0000 | 128  | Used   |
  | **0x0080** | **96**   | **Free** |
  | 0x00E0 | 256  | Used   |
  | **0x01E0** | **192**  | **Free** |
  '| {
    shape: rectangle
    style: {
      fill: white
      font: mono
      font-size: 14
    }
  }
}

# Coalescing algorithm pseudocode
algorithm: Coalescing Algorithm {
  shape: rectangle
  style: {
    fill: "#e7f3ff"
    stroke: "#004085"
    stroke-width: 2
  }
  
  pseudocode: |c
  void sweep_with_coalescing(GC* gc) {
      Block* current = gc->heap_start;
      Block* free_start = NULL;
      size_t free_size = 0;
      
      while (current < gc->heap_end) {
          if (!is_marked(current)) {
              // Start or extend free region
              if (free_start == NULL) {
                  free_start = current;
                  free_size = current->size;
              } else {
                  // Coalesce: extend free region
                  free_size += current->size;
              }
          } else {
              // Marked block - finalize free region
              if (free_start != NULL) {
                  FreeBlock* free = (FreeBlock*)free_start;
                  free->size = free_size;
                  add_to_free_list(gc, free);
                  
                  free_start = NULL;
                  free_size = 0;
              }
              // Unmark for next GC cycle
              unmark(current);
          }
          
          current = (Block*)((char*)current + current->size);
      }
      
      // Finalize last free region (if any)
      if (free_start != NULL) {
          FreeBlock* free = (FreeBlock*)free_start;
          free->size = free_size;
          add_to_free_list(gc, free);
      }
  }
| {
    shape: rectangle
    style: {
      fill: "#f5f5f5"
      font: mono
      font-size: 13
    }
  }
}

# Benefits of coalescing
benefits: Benefits of Coalescing {
  shape: rectangle
  style: {
    fill: "#fff3cd"
    stroke: "#856404"
    stroke-width: 2
  }
  
  advantages: |md
  **Why Coalescing Matters**:
  
  1. **Reduces Fragmentation**:
     - Fewer, larger free blocks
     - Better allocation success rate
  
  2. **Improves Allocation Speed**:
     - First-fit can find suitable blocks faster
     - Less free list traversal
  
  3. **Prevents Heap Exhaustion**:
     - Without coalescing: 1000 tiny free blocks (unusable)
     - With coalescing: 10 large free blocks (usable)
  
  4. **Minimal Overhead**:
     - O(n) sweep already visits all blocks
     - Coalescing adds no extra passes
| {
    shape: rectangle
    style: {
      fill: "#fffacd"
    }
  }
  
  example: |md
  **Real-World Impact**:
  
  Without coalescing:
    Free list: [8][16][8][32][8][16]...  (100 blocks)
    Request 64 bytes → FAIL (no block large enough)
  
  With coalescing:
    Free list: [88][64]  (2 blocks)
    Request 64 bytes → SUCCESS
  
| {
    shape: rectangle
    style: {
      fill: white
      font: mono
      font-size: 13
    }
  }
}

# Edge cases
edge_cases: Edge Cases to Handle {
  shape: rectangle
  style: {
    fill: "#f8d7da"
    stroke: "#721c24"
    stroke-width: 2
  }
  
  cases: |md
  **Tricky Scenarios**:
  
  1. **Entire heap is garbage**:
     - Coalesce into one giant free block
     - Reset heap to initial state
  
  2. **No adjacent free blocks**:
     - Each free block added individually
     - No coalescing needed
  
  3. **Free block at heap end**:
     - Must finalize after loop exits
     - Don't forget last region!
  
  4. **Alignment requirements**:
     - Ensure coalesced blocks maintain alignment
     - May need padding between blocks
| {
    shape: rectangle
    style: {
      fill: "#f5c6cb"
    }
  }
}

# Flow connections
initial_state -> step1: Sweep starts
step1 -> step2: Next block
step2 -> step3: Next block (marked)
step3 -> step4: Continue sweep
step4 -> final_state: Sweep complete

algorithm -> step1: Implements {style.stroke-dash: 3}
algorithm -> step2: Implements {style.stroke-dash: 3}
algorithm -> step3: Implements {style.stroke-dash: 3}
algorithm -> step4: Implements {style.stroke-dash: 3}

benefits -> final_state: Results in {style.stroke: green; style.stroke-width: 2}
edge_cases -> algorithm: Must handle {style.stroke: red; style.stroke-dash: 5}