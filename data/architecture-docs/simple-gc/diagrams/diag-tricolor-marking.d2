vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

direction: right

title: "Tri-Color Abstraction: Object States During Marking" {
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
    underline: true
  }
}

# Object states
white_state: "WHITE\n(Unvisited)" {
  shape: circle
  style: {
    fill: "#FFFFFF"
    stroke: "#333333"
    stroke-width: 3
    font-size: 16
    bold: true
  }
  width: 120
  height: 120
}

gray_state: "GRAY\n(Queued)" {
  shape: circle
  style: {
    fill: "#808080"
    stroke: "#333333"
    stroke-width: 3
    font-color: "#FFFFFF"
    font-size: 16
    bold: true
  }
  width: 120
  height: 120
}

black_state: "BLACK\n(Processed)" {
  shape: circle
  style: {
    fill: "#000000"
    stroke: "#333333"
    stroke-width: 3
    font-color: "#FFFFFF"
    font-size: 16
    bold: true
  }
  width: 120
  height: 120
}

# State transitions
white_state -> gray_state: "Discovered\nby marker" {
  style: {
    stroke: "#4A90E2"
    stroke-width: 3
    font-size: 14
  }
}

gray_state -> black_state: "All children\nprocessed" {
  style: {
    stroke: "#50C878"
    stroke-width: 3
    font-size: 14
  }
}

# Invariants box
invariants: |'md
  **Tri-Color Invariants:**
  
  1. **No black → white edges**
     - Black objects never point to white objects
     - Ensures no reachable object is missed
  
  2. **Gray objects form wavefront**
     - All reachable-but-unprocessed objects
     - Work queue for marking phase
  
  3. **White objects after marking = garbage**
     - Anything still white is unreachable
     - Safe to sweep
'| {
  shape: rectangle
  style: {
    fill: "#FFF9E6"
    stroke: "#E6B800"
    stroke-width: 2
    font-size: 13
  }
  near: bottom-center
}

# Example object graph
example: "Example: Marking in Progress" {
  near: top-left
  shape: text
  style: {
    font-size: 18
    bold: true
  }
}

graph_container: {
  grid-columns: 3
  grid-gap: 40

  root: "Root\n(BLACK)" {
    shape: rectangle
    style: {
      fill: "#000000"
      stroke: "#333333"
      stroke-width: 2
      font-color: "#FFFFFF"
      font-size: 14
      bold: true
    }
    width: 100
    height: 60
  }

  obj_a: "Object A\n(BLACK)" {
    shape: rectangle
    style: {
      fill: "#000000"
      stroke: "#333333"
      stroke-width: 2
      font-color: "#FFFFFF"
      font-size: 14
      bold: true
    }
    width: 100
    height: 60
  }

  obj_b: "Object B\n(GRAY)" {
    shape: rectangle
    style: {
      fill: "#808080"
      stroke: "#333333"
      stroke-width: 2
      font-color: "#FFFFFF"
      font-size: 14
      bold: true
    }
    width: 100
    height: 60
  }

  obj_c: "Object C\n(WHITE)" {
    shape: rectangle
    style: {
      fill: "#FFFFFF"
      stroke: "#333333"
      stroke-width: 2
      font-size: 14
      bold: true
    }
    width: 100
    height: 60
  }

  obj_d: "Object D\n(WHITE)" {
    shape: rectangle
    style: {
      fill: "#FFFFFF"
      stroke: "#333333"
      stroke-width: 2
      font-size: 14
      bold: true
    }
    width: 100
    height: 60
  }

  obj_e: "Object E\n(WHITE)" {
    shape: rectangle
    style: {
      fill: "#FFFFFF"
      stroke: "#333333"
      stroke-width: 2
      font-size: 14
      bold: true
    }
    width: 100
    height: 60
  }
}

# Connections between objects
graph_container.root -> graph_container.obj_a: "processed" {
  style: {
    stroke: "#50C878"
    stroke-width: 2
  }
}

graph_container.root -> graph_container.obj_b: "in queue" {
  style: {
    stroke: "#4A90E2"
    stroke-width: 2
    stroke-dash: 3
  }
}

graph_container.obj_a -> graph_container.obj_c: "will discover" {
  style: {
    stroke: "#FF6B6B"
    stroke-width: 2
    stroke-dash: 5
  }
}

graph_container.obj_b -> graph_container.obj_d: "will discover" {
  style: {
    stroke: "#FF6B6B"
    stroke-width: 2
    stroke-dash: 5
  }
}

graph_container.obj_b -> graph_container.obj_e: "will discover" {
  style: {
    stroke: "#FF6B6B"
    stroke-width: 2
    stroke-dash: 5
  }
}

# Mark queue visualization
mark_queue: "Mark Queue (FIFO)" {
  shape: queue
  style: {
    fill: "#E8F4F8"
    stroke: "#4A90E2"
    stroke-width: 2
    font-size: 14
    bold: true
  }
  width: 200
  height: 80
}

mark_queue_contents: |'md
  **Current Queue:**
  
  Front → [ Object B ] ← Back
  
  **Next to process:** Object B
  **Will enqueue:** D, E
'| {
  shape: rectangle
  style: {
    fill: "#F0F8FF"
    stroke: "#4A90E2"
    stroke-width: 1
    font-size: 12
  }
}

graph_container.obj_b -> mark_queue: "currently in" {
  style: {
    stroke: "#4A90E2"
    stroke-width: 2
  }
}

mark_queue -> mark_queue_contents

# Algorithm steps
algorithm: |'md
  **Marking Algorithm:**
  
  c
  1. Initialize: Root → GRAY, enqueue
  2. While queue not empty:
     a. Dequeue object O (GRAY)
     b. For each child C of O:
        - If C is WHITE:
          * Mark C as GRAY
          * Enqueue C
     c. Mark O as BLACK
  3. All WHITE objects = garbage
  
'| {
  shape: rectangle
  style: {
    fill: "#F5F5F5"
    stroke: "#666666"
    stroke-width: 2
    font-size: 12
  }
  near: bottom-right
}

# Performance note
perf_note: |'md
  **Why Tri-Color?**
  
  • **Incremental GC**: Can pause/resume marking
  • **Concurrent GC**: Mutator can run during marking
  • **Write barriers**: Maintain invariants during mutation
  
  **Cost:** Extra metadata per object (2 bits)
'| {
  shape: rectangle
  style: {
    fill: "#FFF0F5"
    stroke: "#C71585"
    stroke-width: 2
    font-size: 12
  }
}

white_state -> perf_note: "enables" {
  style: {
    stroke: "#C71585"
    stroke-width: 1
    stroke-dash: 3
  }
}