{
  "types": {
    "gc_stats_t": "fields: collections_performed size_t, objects_collected size_t, bytes_collected size_t, collection_time_ms size_t",
    "debug_level_t": "fields: DEBUG_NONE, DEBUG_ERROR, DEBUG_WARN, DEBUG_INFO, DEBUG_VERBOSE",
    "object_header_t": "fields: type object_type_t, marked bool, size size_t, next object_header_t*",
    "object_type_t": "fields: TYPE_INVALID, TYPE_INTEGER, TYPE_PAIR, TYPE_STRING",
    "gc_integer_t": "fields: header object_header_t, value int64_t",
    "gc_pair_t": "fields: header object_header_t, first object_header_t*, second object_header_t*",
    "gc_string_t": "fields: header object_header_t, length size_t, data char[]",
    "root_entry_t": "fields: root_address void**, referenced_object void*, root_type const char*, next root_entry_t*",
    "root_set_t": "fields: first_root root_entry_t*, root_count size_t, capacity size_t",
    "stack_bounds_t": "fields: stack_base void*, stack_top void*, stack_size size_t, valid bool",
    "worklist_t": "fields: items object_header_t**, capacity size_t, count size_t, max_used size_t",
    "sweep_stats_t": "fields: objects_examined size_t, objects_freed size_t, bytes_freed size_t, objects_surviving size_t",
    "gc_state_t": "enum: GC_STATE_IDLE, GC_STATE_COLLECTING, GC_STATE_DISCOVERING_ROOTS, GC_STATE_MARKING, GC_STATE_SWEEPING, GC_STATE_FAILED",
    "gc_error_stats_t": "fields: allocation_failures size_t, collection_failures size_t, corruption_detections size_t, stack_overflow_events size_t, recovery_attempts size_t, emergency_collections size_t",
    "test_stats_t": "fields: tests_run size_t, tests_passed size_t, tests_failed size_t, assertions_made size_t",
    "test_case_t": "fields: name const char*, function test_function_t, next test_case*",
    "debug_stats_t": "fields: validation_checks_performed size_t, validation_failures_detected size_t, poison_memory_calls size_t, poison_violations_found size_t, header_corruptions_detected size_t",
    "allocation_record_t": "fields: object_address void*, object_size size_t, object_type object_type_t, allocation_site const char*, allocation_time uint64_t, is_freed bool, next allocation_record_t*",
    "memory_debug_state_t": "fields: allocation_list allocation_record_t*, active_allocations size_t, total_allocations size_t, total_deallocations size_t, tracking_enabled bool, poisoning_enabled bool",
    "incremental_config_t": "fields: increment_size_objects size_t, increment_time_limit_us size_t, allocation_trigger_ratio double, adaptive_sizing bool",
    "incremental_state_t": "fields: collection_state gc_state_t, gray_objects worklist_t*, sweep_cursor object_header_t*, work_performed size_t, increment_start_time uint64_t, config incremental_config_t",
    "generation_t": "fields: start_address void*, end_address void*, allocation_pointer void*, size_bytes size_t, objects_allocated size_t, allocation_list object_header_t*",
    "generational_gc_t": "fields: young_generation generation_t, old_generation generation_t, card_table uint8_t*, card_table_size size_t, collections_since_major size_t",
    "weak_reference_t": "fields: header object_header_t, target object_header_t*, is_valid bool, queue reference_queue_t*, next_weak weak_reference_t*",
    "finalizer_entry_t": "fields: target_object object_header_t*, finalizer_function finalizer_func_t, user_data void*, execution_state finalizer_state_t, next finalizer_entry_t*"
  },
  "methods": {
    "gc_init() returns void": "initialize garbage collector subsystems",
    "gc_collect() returns bool": "perform complete garbage collection cycle",
    "gc_should_collect() returns bool": "check if collection should be triggered",
    "gc_get_stats() returns gc_stats_t": "get current GC statistics",
    "gc_shutdown() returns void": "cleanup and free all GC memory",
    "gc_malloc(size_t) returns void*": "allocate and track memory for GC",
    "gc_allocated_bytes() returns size_t": "get total allocated bytes",
    "gc_object_count() returns size_t": "get count of allocated objects",
    "debug_set_level(debug_level_t) returns void": "set global debug output level",
    "debug_log(debug_level_t, const char*, const char*, ...) returns void": "log message with level filtering",
    "get_object_header(void*) returns object_header_t*": "get header from payload pointer",
    "gc_create_integer(int64_t) returns void*": "create new integer object",
    "gc_create_pair(void*, void*) returns void*": "create new pair object",
    "gc_create_string(const char*) returns void*": "create new string object",
    "discover_all_roots(root_set_t*) returns bool": "orchestrate complete root discovery process",
    "scan_stack_range(void*, void*, root_set_t*) returns bool": "conservative scan of stack memory range",
    "is_potential_heap_pointer(void*) returns bool": "validate potential pointer during root scanning",
    "validate_object_header(void*) returns bool": "comprehensive object header validation",
    "get_stack_bounds() returns stack_bounds_t": "get platform-specific stack boundaries",
    "gc_mark_phase(root_set_t*) returns bool": "perform complete mark phase starting from discovered roots",
    "mark_object_recursive(object_header_t*, size_t) returns void": "recursive marking with depth tracking",
    "mark_object_worklist(object_header_t*) returns void": "mark object using explicit worklist to avoid stack overflow",
    "worklist_init(worklist_t*, size_t) returns bool": "initialize worklist with given initial capacity",
    "worklist_push(worklist_t*, object_header_t*) returns bool": "add object to worklist with overflow handling",
    "worklist_pop(worklist_t*) returns object_header_t*": "remove and return next object from worklist",
    "worklist_empty(worklist_t*) returns bool": "check if worklist is empty",
    "worklist_cleanup(worklist_t*) returns void": "cleanup worklist memory",
    "extract_object_references(object_header_t*, object_header_t**, size_t) returns size_t": "extract references from typed object",
    "gc_sweep_phase() returns bool": "perform complete sweep phase reclaiming unmarked objects",
    "sweep_allocation_list() returns sweep_stats_t": "walk allocation list freeing unmarked objects",
    "reclaim_object_memory(object_header_t*) returns void": "free individual object memory with cleanup",
    "reset_mark_bit(object_header_t*) returns void": "clear mark bit on surviving object",
    "cleanup_object_by_type(object_header_t*) returns void": "type-specific cleanup before freeing",
    "debug_poison_memory(void*, size_t) returns void": "overwrite memory with debug pattern",
    "debug_validate_object_header(object_header_t*) returns bool": "comprehensive object header validation",
    "gc_error_init() returns void": "initialize error tracking system",
    "gc_error_report_failure(const char*, const char*) returns void": "record and log failure event",
    "gc_error_report_corruption(void*, const char*) returns void": "record corruption detection",
    "gc_error_should_abort() returns bool": "check if error threshold exceeded",
    "gc_handle_allocation_failure(size_t) returns bool": "handle allocation failure with emergency collection",
    "gc_emergency_collect() returns bool": "minimal resource garbage collection",
    "memory_debug_record_allocation(void*, size_t, object_type_t, const char*) returns void": "record allocation for debugging",
    "memory_debug_validate_pointer(void*) returns bool": "validate pointer against allocation records",
    "memory_debug_detect_leaks() returns void": "identify and report memory leaks",
    "gc_write_barrier(void**, void*) returns void": "write barrier for incremental collection",
    "minor_collect() returns bool": "collect young generation only",
    "promote_surviving_objects() returns void": "move surviving young objects to old generation",
    "scan_dirty_cards() returns void": "find cross-generational references from card table"
  },
  "constants": {
    "DEBUG_NONE": "0",
    "DEBUG_ERROR": "1",
    "DEBUG_WARN": "2",
    "DEBUG_INFO": "3",
    "DEBUG_VERBOSE": "4",
    "TYPE_INVALID": "0",
    "TYPE_INTEGER": "1",
    "TYPE_PAIR": "2",
    "TYPE_STRING": "3",
    "MAX_RECURSION_DEPTH": "200 maximum recursion depth before worklist fallback",
    "GC_DEFAULT_THRESHOLD_BYTES": "1MB default collection trigger",
    "GC_DEFAULT_THRESHOLD_OBJECTS": "10000 objects default trigger",
    "GC_ALLOCATION_CHECK_INTERVAL": "100 allocations between trigger checks",
    "MAX_COLLECTION_FAILURES": "3 maximum consecutive collection failures",
    "POISON_FREED_OBJECT": "0xDEADBEEF",
    "POISON_UNINITIALIZED": "0xCCCCCCCC",
    "POISON_GUARD_PATTERN": "0xABCDABCD",
    "TYPE_WEAK_REFERENCE": "object type for weak reference objects"
  },
  "terms": {
    "reachability analysis": "determining which objects are accessible from program roots",
    "mark-sweep": "two-phase garbage collection algorithm that marks reachable objects then sweeps unmarked ones",
    "reference counting": "garbage collection approach tracking number of references to each object",
    "copying collector": "GC algorithm that copies live objects to new memory region",
    "generational collector": "GC algorithm separating young and old objects for efficiency",
    "stop-the-world": "GC pause where program execution halts during collection",
    "root references": "directly accessible references from stack, globals, and registers",
    "memory fragmentation": "scattered free memory blocks reducing allocation efficiency",
    "use-after-free": "bug where program accesses memory after it has been freed",
    "double-free": "bug where program calls free() multiple times on same memory",
    "memory leak": "bug where program fails to free allocated memory",
    "conservative scanning": "root discovery treating pointer-like values as potential heap references",
    "precise scanning": "root discovery with exact knowledge of which values are pointers",
    "object header": "metadata stored with each object for GC bookkeeping",
    "mark bit": "flag in object header indicating reachability during collection",
    "allocation tracking": "system for maintaining list of all allocated objects",
    "heap fragmentation": "non-contiguous free memory regions in garbage collected heap",
    "tri-color marking": "conceptual model of white, gray, and black objects during concurrent marking",
    "worklist": "explicit stack or queue data structure for managing graph traversal state",
    "depth-first traversal": "graph traversal strategy that explores deeply before breadth",
    "tri-color invariant": "correctness property ensuring no black object references white object",
    "white objects": "unmarked objects not yet discovered during marking",
    "gray objects": "marked objects whose references haven't been fully processed",
    "black objects": "fully processed marked objects whose references are complete",
    "memory reclamation": "process of returning freed memory to allocator for reuse",
    "memory corruption": "damage to object headers or heap structure",
    "emergency collection": "minimal-resource GC cycle triggered by allocation failure",
    "allocation failure": "inability to allocate memory from operating system",
    "stack overflow": "recursion depth exceeding available stack space",
    "corruption detection": "validation and identification of damaged object data",
    "object header validation": "checking object metadata for consistency and correctness",
    "worklist overflow": "exhaustion of worklist capacity during marking",
    "memory poisoning": "filling freed memory with recognizable patterns to detect use-after-free",
    "incremental collection": "garbage collection performed in small interleaved increments to reduce pause times",
    "generational collection": "GC optimization separating young and old objects based on weak generational hypothesis",
    "parallel marking": "using multiple threads to accelerate mark phase through work distribution",
    "write barrier": "code executed on pointer writes to maintain GC correctness during incremental or concurrent collection",
    "weak references": "references that don't prevent garbage collection of target objects",
    "finalizers": "cleanup code executed when objects become unreachable",
    "concurrent collection": "garbage collection that runs simultaneously with program execution",
    "cross-generational references": "references from old generation objects to young generation objects",
    "card marking": "write barrier technique tracking modifications at memory region granularity",
    "work stealing": "load balancing technique where idle threads steal work from busy threads",
    "reference invalidation": "process of clearing weak references when target objects are collected",
    "resurrection": "finalizer code creating references to objects being finalized",
    "weak generational hypothesis": "observation that most objects die young while survivors tend to live long"
  }
}