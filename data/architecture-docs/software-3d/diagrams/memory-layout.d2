title: Buffer Memory Organization

classes: {
  memory_block: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  pixel_data: {
    style.fill: "#16213e"
    style.stroke: "#8b949e"
    style.font-color: "#e6edf3"
  }
  access_pattern: {
    style.fill: "#0f3460"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
    style.bold: true
  }
}

framebuffer: Framebuffer Memory {
  class: memory_block
  
  color_buffer: Color Buffer {
    class: pixel_data
    shape: rectangle
    width: 800
    height: 600
    format: "RGBA32 (4 bytes/pixel)"
    size: "1.92 MB"
  }
  
  pixel_layout: Pixel Layout {
    class: pixel_data
    pixel_0_0: "Pixel[0,0]" { style.fill: "#d63031" }
    pixel_1_0: "Pixel[1,0]" { style.fill: "#e17055" }
    pixel_0_1: "Pixel[0,1]" { style.fill: "#fdcb6e" }
    pixel_1_1: "Pixel[1,1]" { style.fill: "#6c5ce7" }
    
    pixel_0_0 -> pixel_1_0: +4 bytes
    pixel_0_0 -> pixel_0_1: +3200 bytes (width * 4)
  }
}

zbuffer: Z-Buffer Memory {
  class: memory_block
  
  depth_buffer: Depth Buffer {
    class: pixel_data
    shape: rectangle
    width: 800
    height: 600
    format: "Float32 (4 bytes/pixel)"
    size: "1.92 MB"
  }
  
  depth_layout: Depth Layout {
    class: pixel_data
    depth_0_0: "Depth[0,0]" { style.fill: "#2d3436" }
    depth_1_0: "Depth[1,0]" { style.fill: "#636e72" }
    depth_0_1: "Depth[0,1]" { style.fill: "#b2bec3" }
    depth_1_1: "Depth[1,1]" { style.fill: "#ddd" }
    
    depth_0_0 -> depth_1_0: +4 bytes
    depth_0_0 -> depth_0_1: +3200 bytes (width * 4)
  }
}

access_patterns: Access Patterns {
  class: access_pattern
  
  scanline: Scanline Access {
    shape: rectangle
    pattern: "Sequential (x+1)"
    cache_friendly: true
  }
  
  vertical: Vertical Access {
    shape: rectangle
    pattern: "Stride (y+1)"
    cache_penalty: "High"
  }
  
  random: Random Access {
    shape: rectangle
    pattern: "Pixel (x,y)"
    performance: "Variable"
  }
}

memory_manager: Memory Manager {
  class: memory_block
  
  allocator: Buffer Allocator {
    class: pixel_data
    alignment: "16-byte aligned"
    allocation: "Contiguous blocks"
  }
  
  indexing: Pixel Indexing {
    class: pixel_data
    formula: "offset = (y * width + x) * bytes_per_pixel"
  }
}

framebuffer.color_buffer -> access_patterns.scanline: optimal access
zbuffer.depth_buffer -> access_patterns.scanline: optimal access
framebuffer.color_buffer -> access_patterns.random: pixel operations
zbuffer.depth_buffer -> access_patterns.random: depth testing

memory_manager.allocator -> framebuffer: allocates
memory_manager.allocator -> zbuffer: allocates
memory_manager.indexing -> framebuffer.pixel_layout: calculates offset
memory_manager.indexing -> zbuffer.depth_layout: calculates offset

note: |md
  ## Key Insights
  - Both buffers use **row-major layout** for cache efficiency
  - **Scanline rendering** minimizes memory access patterns
  - **Pixel coordinates (x,y)** map to linear memory via stride calculation
  - **Z-buffer and framebuffer** maintain synchronized dimensions
| {
  shape: page
  near: bottom-center
  style.fill: "#0f3460"
  style.stroke: "#3fb950"
  style.font-color: "#e6edf3"
}