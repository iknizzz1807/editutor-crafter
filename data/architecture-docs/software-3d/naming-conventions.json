{
  "types": {
    "Vector3": "fields: x float, y float, z float",
    "Vector4": "fields: x float, y float, z float, w float",
    "Matrix4": "fields: m[16] float array in column-major order",
    "Color": "fields: r uint8_t, g uint8_t, b uint8_t",
    "Framebuffer": "fields: width int, height int, color_buffer Color*, depth_buffer float*",
    "Renderer": "fields: framebuffer Framebuffer, model_matrix Matrix4, view_matrix Matrix4, projection_matrix Matrix4, light_direction Vector3, ambient_color Color",
    "Triangle": "fields: v0 Vector3, v1 Vector3, v2 Vector3, uv0 Vector2, uv1 Vector2, uv2 Vector2, normal Vector3, diffuse_color Color, specular_color Color, shininess float, texture_id int",
    "Mesh": "fields: vertices Vector3*, triangles Triangle*, vertex_count int, triangle_count int",
    "Viewport": "fields: x_min float, x_max float, y_min float, y_max float",
    "TransformPipeline": "fields: model_matrix Matrix4, view_matrix Matrix4, projection_matrix Matrix4, mvp_matrix Matrix4, viewport_x int, viewport_y int, viewport_width int, viewport_height int",
    "RenderError": "enum: RENDER_SUCCESS, RENDER_ERROR_DEGENERATE_TRIANGLE, RENDER_ERROR_INVALID_COORDINATES, RENDER_ERROR_BUFFER_OVERFLOW, RENDER_ERROR_PRECISION_LOSS",
    "TestResults": "fields: tests_run int, tests_passed int, tests_failed int, current_test char[256]",
    "VisualTest": "fields: reference_path char*, output_path char*, pixel_tolerance float, total_error_threshold float",
    "DebugContext": "fields: current_mode DebugMode, save_debug_frames int, output_directory char[256], frame_counter int",
    "ArtifactReport": "fields: has_depth_fighting int, has_coordinate_overflow int, has_normal_inconsistencies int, has_precision_issues int, diagnostic_message char[1024]",
    "DebugMode": "enum: DEBUG_MODE_NORMAL, DEBUG_MODE_WIREFRAME, DEBUG_MODE_NORMALS, DEBUG_MODE_DEPTH, DEBUG_MODE_BARYCENTRIC",
    "Vector2": "fields: u float, v float",
    "Texture": "fields: width int, height int, pixels Color*, wrap_mode TextureWrapMode, filter_mode TextureFilterMode",
    "TextureWrapMode": "enum: TEXTURE_WRAP_REPEAT, TEXTURE_WRAP_CLAMP, TEXTURE_WRAP_MIRROR",
    "TextureFilterMode": "enum: TEXTURE_FILTER_NEAREST, TEXTURE_FILTER_LINEAR",
    "LightSource": "fields: position Vector3, direction Vector3, color Color, light_type LightType, attenuation Vector3, cutoff_angle float, intensity float",
    "LightType": "enum: LIGHT_TYPE_DIRECTIONAL, LIGHT_TYPE_POINT, LIGHT_TYPE_SPOTLIGHT",
    "LightingSystem": "fields: lights LightSource*, light_count int, max_lights int, ambient_color Color, ambient_intensity float",
    "ThreadPool": "fields: thread_count int, thread_handles void**, work_queue void*, queue_mutex void*, work_available void*, shutdown_requested int",
    "RasterizationTask": "fields: framebuffer Framebuffer*, triangles Triangle*, triangle_count int, tile_x int, tile_y int, tile_width int, tile_height int",
    "Vector3_SIMD": "fields: data __m128",
    "fixed_point_t": "int32_t type for 24.8 fixed-point arithmetic",
    "TerminologyEntry": "fields: term char[64], definition char[256], usage_count int",
    "TerminologyDatabase": "fields: entries TerminologyEntry*, entry_count int, max_entries int"
  },
  "methods": {
    "vec3_create(float, float, float) Vector3": "create 3D vector from components",
    "vec3_add(Vector3, Vector3) Vector3": "add two 3D vectors",
    "vec3_subtract(Vector3, Vector3) Vector3": "subtract two 3D vectors",
    "vec3_multiply(Vector3, float) Vector3": "multiply vector by scalar",
    "vec3_dot(Vector3, Vector3) float": "compute dot product of two vectors",
    "vec3_cross(Vector3, Vector3) Vector3": "compute cross product of two vectors",
    "vec3_normalize(Vector3) Vector3": "normalize vector to unit length",
    "mat4_identity() Matrix4": "create 4x4 identity matrix",
    "mat4_multiply(Matrix4*, Matrix4*) Matrix4": "multiply two 4x4 matrices",
    "mat4_transform_point(Matrix4*, Vector3) Vector3": "transform 3D point through matrix",
    "framebuffer_create(int, int) Framebuffer": "create framebuffer with color and depth buffers",
    "framebuffer_set_pixel(Framebuffer*, int, int, Color)": "set pixel color at coordinates",
    "framebuffer_set_pixel_depth(Framebuffer*, int, int, Color, float) int": "set pixel with depth test, returns 1 if updated",
    "renderer_draw_line(Renderer*, Vector3, Vector3, Color)": "draw line between two 3D points",
    "renderer_fill_triangle(Renderer*, Vector3, Vector3, Vector3, Color)": "fill triangle with solid color",
    "renderer_draw_triangle_shaded(Renderer*, Vector3, Vector3, Vector3, Vector3, Vector3, Vector3, Color)": "draw triangle with per-vertex lighting",
    "mat4_perspective(float, float, float, float) Matrix4": "create perspective projection matrix",
    "framebuffer_save_ppm(Framebuffer*, char*) void": "save framebuffer as PPM image",
    "framebuffer_save_ppm(Framebuffer*, char*)": "save framebuffer as PPM image",
    "draw_line_bresenham(Framebuffer*, int, int, int, int, Color)": "draw line using Bresenham algorithm",
    "fill_triangle_barycentric(Framebuffer*, float, float, float, float, float, float, Color)": "fill triangle using barycentric coordinates",
    "edge_function(float, float, float, float, float, float) float": "compute signed area for barycentric coordinates",
    "compute_outcode(float, float, Viewport*) int": "calculate Cohen-Sutherland outcode",
    "clip_line_cohen_sutherland(float*, float*, float*, float*, Viewport*) int": "clip line against viewport boundaries",
    "mat4_translation(float, float, float) Matrix4": "create translation matrix",
    "mat4_rotation_z(float) Matrix4": "create Z-axis rotation matrix",
    "mat4_look_at(Vector3, Vector3, Vector3) Matrix4": "create view matrix using look-at",
    "transform_vertex_to_screen(TransformPipeline*, Vector3) Vector3": "transform vertex through complete pipeline",
    "update_mvp_matrix(TransformPipeline*) void": "precompute combined model-view-projection matrix",
    "framebuffer_clear_depth(Framebuffer*, float) void": "clear depth buffer to specified value",
    "framebuffer_get_depth(Framebuffer*, int, int) float": "get depth value at pixel coordinates",
    "calculate_barycentric_weights(float, float, float, float, float, float, float, float) Vector3": "compute barycentric weights for point in triangle",
    "interpolate_depth_barycentric(Vector3, float, float, float) float": "interpolate depth using barycentric weights",
    "fill_triangle_with_depth(Framebuffer*, Vector3, float, Vector3, float, Vector3, float, Color) void": "fill triangle with depth testing",
    "compute_triangle_normal(Vector3, Vector3, Vector3) Vector3": "compute face normal from triangle vertices",
    "calculate_diffuse_lighting(Vector3, Vector3) float": "compute Lambertian diffuse intensity",
    "apply_lighting_to_color(Color, float, float, Color) Color": "combine lighting with base color",
    "render_triangle_flat_shaded(Renderer*, Triangle)": "render triangle with uniform face lighting",
    "render_triangle_gouraud_shaded(Renderer*, Triangle, Vector3, Vector3, Vector3)": "render triangle with interpolated vertex lighting",
    "framebuffer_create(int, int)": "create framebuffer with color and depth buffers",
    "framebuffer_set_pixel_depth(Framebuffer*, int, int, Color, float)": "set pixel with depth test, returns 1 if updated",
    "transform_vertex_to_screen(TransformPipeline*, Vector3)": "transform vertex through complete pipeline",
    "update_mvp_matrix(TransformPipeline*)": "precompute combined model-view-projection matrix",
    "framebuffer_clear_depth(Framebuffer*, float)": "clear depth buffer to specified value",
    "framebuffer_get_depth(Framebuffer*, int, int)": "get current depth at pixel coordinates",
    "compute_outcode(float, float, Viewport*)": "calculate Cohen-Sutherland outcode",
    "mat4_transform_point(Matrix4*, Vector3)": "transform 3D point through matrix",
    "is_triangle_degenerate(Vector3, Vector3, Vector3) int": "check if triangle has sufficient area",
    "triangle_has_correct_winding(float, float, float, float, float, float) int": "validate counter-clockwise winding order",
    "has_coincident_vertices(Vector3, Vector3, Vector3) int": "check for vertices within epsilon tolerance",
    "validate_triangle_for_rendering(Triangle*, TransformPipeline*) RenderError": "comprehensive triangle validation",
    "fill_triangle_with_error_handling(Framebuffer*, Vector3, Vector3, Vector3, Color) void": "safe triangle rasterization with bounds checking",
    "multiply_matrices_safe(Matrix4*, Matrix4*) Matrix4": "matrix multiplication with precision validation",
    "float_equals(float, float, float) int": "epsilon-based floating point comparison",
    "depth_equals(float, float, float) int": "depth-relative comparison for z-buffer",
    "coords_in_bounds(int, int, int, int) int": "safe bounds checking for framebuffer access",
    "vec3_length(Vector3) float": "compute vector magnitude",
    "render_triangle_with_depth(Renderer*, Triangle*)": "render triangle with depth testing",
    "debug_create_context(const char*) DebugContext": "initialize debug context with output directory",
    "debug_save_frame(DebugContext*, Framebuffer*, const char*)": "save framebuffer with debug suffix",
    "debug_render_depth_buffer(Framebuffer*, float, float)": "render depth buffer as grayscale visualization",
    "debug_render_normals_as_colors(Renderer*, Triangle*, int)": "render surface normals as RGB color mapping",
    "debug_render_wireframe_overlay(Renderer*, Triangle*, int)": "overlay triangle edges on filled geometry",
    "debug_render_barycentric_weights(Framebuffer*, Vector3, Vector3, Vector3)": "render barycentric coordinates as RGB gradient",
    "detect_rendering_artifacts(Framebuffer*, Framebuffer*) ArtifactReport": "analyze buffers for common rendering artifacts",
    "compare_visual_output(const char*, const char*, float) int": "compare rendered output against reference image",
    "texture_load_from_file(const char*) Texture*": "load texture from image file with PPM format support",
    "texture_sample(const Texture*, float, float) Color": "sample texture color at UV coordinates with filtering",
    "interpolate_uv_perspective_correct(Vector2, Vector2, Vector2, float, float, float, float, float, float) Vector2": "compute perspective-correct UV interpolation using depth values",
    "fill_triangle_textured(Framebuffer*, Vector3, Vector2, Vector3, Vector2, Vector3, Vector2, const Texture*)": "rasterize triangle with texture mapping",
    "calculate_blinn_phong_specular(Vector3, Vector3, Vector3, float) float": "compute specular highlight intensity using Blinn-Phong model",
    "compute_lighting_all_sources(const LightingSystem*, Vector3, Vector3, Vector3, Color, float, float, float) Color": "accumulate lighting from multiple sources",
    "lighting_system_create(int) LightingSystem*": "create lighting system with specified maximum lights",
    "lighting_add_directional_light(LightingSystem*, Vector3, Color, float)": "add directional light to lighting system",
    "lighting_add_point_light(LightingSystem*, Vector3, Color, float, float, float, float)": "add point light with distance attenuation",
    "thread_pool_create(int) ThreadPool*": "create thread pool with specified worker count",
    "mat4_multiply_simd(const Matrix4*, const Matrix4*, Matrix4*)": "SIMD-optimized matrix multiplication",
    "rasterize_triangles_tiled(ThreadPool*, Framebuffer*, Triangle*, int, int)": "multithreaded tile-based triangle rasterization",
    "fill_triangle_fixed_point(Framebuffer*, fixed_point_t, fixed_point_t, fixed_point_t, fixed_point_t, fixed_point_t, fixed_point_t, Color)": "fixed-point triangle rasterization",
    "vec3_simd_add(Vector3_SIMD, Vector3_SIMD) Vector3_SIMD": "SIMD vector addition",
    "vec3_simd_multiply(Vector3_SIMD, float) Vector3_SIMD": "SIMD vector-scalar multiplication",
    "vec3_simd_dot(Vector3_SIMD, Vector3_SIMD) float": "SIMD vector dot product",
    "terminology_create_database() TerminologyDatabase*": "initialize terminology validation system",
    "terminology_validate_code_consistency(const char*) int": "validate code terminology usage"
  },
  "constants": {
    "EPSILON": "1e-6f floating point comparison tolerance",
    "M_PI": "mathematical constant pi",
    "COLOR_BLACK": "predefined black color constant",
    "COLOR_WHITE": "predefined white color constant",
    "COLOR_RED": "predefined red color constant",
    "DEPTH_EPSILON": "1e-6f floating point comparison tolerance for depth testing",
    "SCREEN_EPSILON": "0.5f pixel-level precision threshold",
    "COLOR_GREEN": "predefined green color constant",
    "COLOR_BLUE": "predefined blue color constant",
    "fixed_point_t": "int32_t type for 24.8 fixed-point arithmetic",
    "FIXED_POINT_SHIFT": "8 bits for fractional portion in fixed-point arithmetic",
    "FIXED_POINT_ONE": "value representing 1.0 in fixed-point format"
  },
  "terms": {
    "perspective projection": "mathematical transformation from 3D coordinates to 2D screen coordinates with foreshortening",
    "barycentric coordinates": "coordinate system for points inside triangles using weights of triangle vertices",
    "z-buffering": "hidden surface removal algorithm using per-pixel depth testing",
    "homogeneous coordinates": "4D coordinate system that enables matrix-based transformations and perspective division",
    "rasterization": "process of converting geometric primitives into discrete pixel values",
    "model-view-projection": "sequence of matrix transformations from object space to screen space",
    "SIMD": "Single Instruction Multiple Data - parallel processing of multiple values simultaneously",
    "depth buffer": "per-pixel storage of depth values for visibility determination",
    "scanline rasterization": "triangle filling algorithm that processes pixels row by row",
    "fixed-point arithmetic": "integer-based approximation of floating-point calculations for performance",
    "graphics pipeline": "sequential processing stages that transform 3D vertices into 2D pixels",
    "coordinate transformation hierarchy": "sequence of coordinate spaces from object to screen coordinates",
    "diffuse lighting": "Lambertian reflection model using dot product of surface normal and light direction",
    "flat shading": "per-triangle lighting computation with constant color across surface",
    "Gouraud shading": "per-vertex lighting with smooth interpolation across triangle surface",
    "edge function": "cross-product calculation for determining point-triangle relationship",
    "outcode": "4-bit classification of point position relative to viewport boundaries",
    "Cohen-Sutherland": "line clipping algorithm using outcodes for efficient boundary testing",
    "Sutherland-Hodgman": "polygon clipping algorithm processing one boundary at a time",
    "perspective division": "dividing x,y,z by w component after projection to achieve foreshortening",
    "look-at matrix": "view matrix construction method using eye, target, and up vectors",
    "normalized device coordinates": "coordinate system where visible range is [-1,1] for x,y and [0,1] for z",
    "viewport transformation": "final mapping from NDC to pixel coordinates",
    "column-major order": "matrix storage where columns are stored consecutively in memory",
    "depth testing": "comparison of fragment depth against stored depth to determine visibility",
    "z-fighting": "visual artifact where surfaces at similar depths flicker due to precision limitations",
    "perspective-correct interpolation": "depth interpolation that accounts for perspective projection distortion",
    "depth bias": "artificial depth offset applied to surfaces to prevent z-fighting",
    "depth precision": "accuracy of floating-point depth values affecting z-fighting susceptibility",
    "surface normal": "vector perpendicular to triangle surface indicating orientation",
    "cross product": "vector operation producing perpendicular vector from two input vectors",
    "ambient lighting": "uniform base illumination preventing pure black shadows",
    "degenerate geometry": "geometric primitives that violate mathematical assumptions of rendering algorithms",
    "zero-area triangles": "triangles with collinear vertices or coincident points that have no interior area",
    "coincident vertices": "vertices that occupy identical or nearly identical positions within epsilon tolerance",
    "winding order": "sequence of vertex ordering that determines triangle orientation and normal direction",
    "floating-point precision": "numerical accuracy limitations in floating-point arithmetic operations",
    "epsilon-based comparisons": "tolerance-based equality testing that accounts for floating-point precision limitations",
    "viewport clipping": "removing geometry portions that lie outside the visible screen region",
    "trivial accept": "optimization where geometry entirely within viewport requires no clipping",
    "trivial reject": "optimization where geometry entirely outside viewport can be discarded",
    "buffer overrun": "memory corruption from writing pixels outside valid framebuffer bounds",
    "conservative culling": "simplified clipping that rejects triangles with bounding boxes outside viewport",
    "guard band": "extended rendering region beyond viewport to simplify clipping calculations",
    "matrix precomputation": "combining multiple matrix operations to reduce accumulated precision errors",
    "visual regression testing": "comparing rendered output against reference images",
    "mathematical component testing": "testing matrix operations, coordinate transforms, and geometric calculations",
    "progressive milestone validation": "expected behavior and output verification for each development milestone",
    "matrix multiplication order": "sequence of matrix operations affecting transformation correctness",
    "coordinate system handedness": "orientation convention determining spatial relationships and calculations",
    "normal vector visualization": "technique for displaying surface normals as color-coded information",
    "depth buffer visualization": "rendering depth values as grayscale or false-color images",
    "buffer overflow": "memory corruption from writing pixels outside valid framebuffer bounds",
    "artifact detection": "automated analysis of rendered output for common rendering problems",
    "pipeline stage visualization": "displaying intermediate results at each rendering stage",
    "geometric debug rendering": "overlaying mathematical structures onto rendered scenes",
    "texture mapping": "process of applying 2D images onto 3D surfaces to add visual detail",
    "UV coordinates": "2D texture coordinates that specify how textures map onto 3D geometry",
    "bilinear filtering": "texture sampling method that smoothly interpolates between adjacent texture pixels",
    "specular reflection": "mirror-like reflection that creates bright highlights on shiny surfaces",
    "Blinn-Phong model": "lighting model using half-vector approach for specular highlight calculation",
    "shadow mapping": "technique for real-time shadow generation using depth maps from light's perspective",
    "Structure of Arrays": "data layout where components are stored separately to optimize SIMD processing",
    "tile-based rendering": "dividing framebuffer into rectangular regions processed by different threads",
    "dot product": "scalar result of multiplying corresponding vector components",
    "z-buffer": "per-pixel storage of depth values for visibility determination"
  }
}