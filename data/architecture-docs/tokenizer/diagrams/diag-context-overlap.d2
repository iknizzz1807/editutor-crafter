direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- Classes for Design Consistency ---
classes: {
  mode_active: {
    style: {
      fill: "#E4DBFE"
      stroke: "#673AB7"
      stroke-width: 3
      bold: true
      shadow: true
    }
  }
  token_data: {
    shape: sql_table
    style: {
      fill: "#E3F2FD"
      stroke: "#1976D2"
    }
  }
  source_code: {
    shape: code
    style: {
      stroke: "#455A64"
      fill: "#ECEFF1"
      font: mono
    }
  }
  logic_gate: {
    shape: diamond
    style: {
      fill: "#FFF9C4"
      stroke: "#FBC02D"
    }
  }
}

# --- Legend & System Title ---
header: {
  near: top-center
  label: "LEXER CONTEXT ISOLATION: Context-Aware Mode Switching"
  shape: text
  style: {
    font-size: 28
    bold: true
    underline: true
  }
}

# --- CASE 1: COMMENT INSIDE STRING ---
case_string: {
  label: "CASE 1: Comment Sequence inside String Literal (scanner.c)"
  direction: down
  style.stroke-width: 2

  input: |c
    char* s = "hello // world";
  |
  input.class: source_code

  process: {
    direction: right
    
    state_machine: {
      label: "Lexer._dispatch() (scanner.c)"
      
      start: "char == '\"'" {shape: circle}
      mode_entry: "Enter IN_STRING Mode"
      mode_entry.class: mode_active
      
      start -> mode_entry: "LA(1) match"
    }

    rules: {
      label: "Active Ruleset: _scan_string()"
      content: |md
        c
        // While in IN_STRING mode:
        case '"':  exit_mode(); emit(TOKEN_STRING);
        case '\\': consume_escape_sequence();
        case '\n': report_error("Unterminated string");
        default:   append_to_buffer(c); // '/' and '*' treated as literals
        
      |
    }
    
    state_machine.mode_entry -> rules: "Suspends Global Dispatch"
  }

  output: {
    data: {
      shape: sql_table
      label: "struct Token (token.h)"
      
      row1: "0x00 | uint32_t | type: TOKEN_STRING"
      row2: "0x04 | uint32_t | length: 14"
      row3: "0x08 | char*    | value: \"hello // world\""
      row4: "0x10 | uint32_t | line: 1"
      row5: "0x14 | uint32_t | col: 11"
      label_bottom: "Total: 24 bytes"
    }
    data.class: token_data
  }

  input -> process: "LA(1) reads '\"'"
  process -> output: "Emits on match"
}

# --- CASE 2: STRING INSIDE COMMENT ---
case_comment: {
  label: "CASE 2: Quote Sequence inside Block Comment (scanner.c)"
  direction: down
  style.stroke-width: 2

  input: |c
    /* say "hi" */
  |
  input.class: source_code

  process: {
    direction: right
    
    state_machine: {
      label: "Lexer._dispatch() (scanner.c)"
      
      start: "char == '/'" {shape: circle}
      check: "peek(1) == '*'" {class: logic_gate}
      mode_entry: "Enter BLOCK_COMMENT Mode"
      mode_entry.class: mode_active
      
      start -> check: "Dispatch /"
      check -> mode_entry: "Match success"
    }

    rules: {
      label: "Active Ruleset: _skip_comment()"
      content: |md
        c
        // While in BLOCK_COMMENT mode:
        case '*': if (peek(1) == '/') exit_mode();
        case '\n': line_count++;
        case '"':  ignore(); // '"' is not an exit trigger
        default:   discard(); 
        
      |
    }
    
    state_machine.mode_entry -> rules: "Bypasses Token Generation"
  }

  null_output: {
    shape: circle
    label: "VOID\n(No Token)"
    style: {
      fill: "#BDBDBD"
      stroke-dash: 5
      opacity: 0.6
    }
  }

  input -> process: "LA(2) reads '/*'"
  process -> null_output: "Filtered"
}

# --- Architectural Boundary ---
case_string -> case_comment: "Isolation Boundary: Current Mode determines valid transition subset" {
  style: {
    stroke-width: 4
    stroke-dash: 5
    font-size: 16
    font-color: "#607D8B"
  }
}