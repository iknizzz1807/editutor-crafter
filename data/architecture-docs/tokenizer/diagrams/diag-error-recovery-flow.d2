direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- GLOBAL CLASSES ---
classes: {
  struct_scanner: {
    shape: sql_table
    style: {
      fill: "#f8f9fa"
      stroke: "#212529"
    }
  }
  token_node: {
    shape: sql_table
    style: {
      fill: "#e7f5ff"
      stroke: "#1971c2"
    }
  }
  logic_block: {
    shape: code
    style: {
      stroke: "#495057"
    }
  }
}

# --- 1. SOURCE BUFFER LAYER ---
source_layer: {
  direction: down
  label: "INPUT BUFFER (lexer.py)"
  buffer: |md
    python
    # Index: 0 1 2 3 4 5 6 7 8
    source = "x   @   y   +   z"
    
  |
  marker_x: "idx:0 | char:'x'"
  marker_error: "idx:2 | char:'@'" { 
    style: {
      font-color: red
      bold: true
    }
  }
  marker_y: "idx:4 | char:'y'"
  
  buffer -> marker_x
  buffer -> marker_error
  buffer -> marker_y
}

# --- 2. LOGIC DEFINITION ---
recovery_logic: {
  label: "Panic-Mode Implementation (scanner.py)"
  class: logic_block
  recovery_func: |`python
  def _scan_token(self) -> Token | None:
      self.start = self.current
      self.start_column = self.column
      char = self.advance()
      
      # ... dispatch logic ...
      else:
          # RECOVERY STRATEGY: 
          # 1. Emit error for illegal char
          # 2. Return control to main loop
          # 3. Next call starts at self.current (skip @)
          return Token(
              type=TokenType.ERROR, 
              lexeme=char, 
              line=self.line, 
              col=self.start_column
          )
  `|
}

# --- 3. STATE EVOLUTION TIMELINE ---
evolution: {
  direction: right
  label: "EXECUTION TIMELINE"

  S1: {
    direction: down
    label: "T1: VALID SCAN"
    state: {
      class: struct_scanner
      label: "Scanner State (scanner.py)"
      row1: "0x00 | int | start = 0"
      row2: "0x08 | int | current = 1"
      row3: "char = 'x'"
      label_bottom: "Total: 24 bytes"
    }
    emit: {
      class: token_node
      label: "class Token"
      row1: "type | TokenType | IDENTIFIER"
      row2: "lexeme | str | 'x'"
      row3: "pos | tuple | (1, 1)"
    }
    state -> emit: "advance()"
  }

  S2: {
    direction: down
    label: "T2: PANIC ENCOUNTERED"
    style.stroke: red
    state: {
      class: struct_scanner
      label: "Scanner State (scanner.py)"
      row1: "0x00 | int | start = 2"
      row2: "0x08 | int | current = 3"
      row3: "char = '@'"
      label_bottom: "Panic Mode: Skip '@'"
    }
    emit: {
      class: token_node
      style: {
        fill: "#fff5f5"
        stroke: "#c92a2a"
      }
      label: "class Token (ERROR)"
      row1: "type | TokenType | ERROR"
      row2: "lexeme | str | '@'"
      row3: "pos | tuple | (1, 3)"
    }
    state -> emit: "default_branch"
  }

  S3: {
    direction: down
    label: "T3: RESUME SCAN"
    state: {
      class: struct_scanner
      label: "Scanner State (scanner.py)"
      row1: "0x00 | int | start = 4"
      row2: "0x08 | int | current = 5"
      row3: "char = 'y'"
      label_bottom: "Synchronization OK"
    }
    emit: {
      class: token_node
      label: "class Token"
      row1: "type | TokenType | IDENTIFIER"
      row2: "lexeme | str | 'y'"
      row3: "pos | tuple | (1, 5)"
    }
    state -> emit: "advance()"
  }
}

# --- 4. FINAL RESULT LAYER ---
token_stream: {
  direction: right
  label: "ACCUMULATED TOKEN LIST (list[Token])"
  
  t1: "Ident('x')"
  t2: "Error('@')" { style.fill: "#ffc9c9"; style.stroke: red }
  t3: "Ident('y')"
  t4: "Op('+')"
  t5: "Ident('z')"
  t6: "EOF" { style.fill: "#ced4da" }
  
  t1 -> t2 -> t3 -> t4 -> t5 -> t6
}

# --- CROSS-LAYER CONNECTORS ---
source_layer.marker_x -> evolution.S1.state: "advance()"
source_layer.marker_error -> evolution.S2.state: "unrecognized"
source_layer.marker_y -> evolution.S3.state: "recover"

evolution.S1.emit -> token_stream.t1
evolution.S2.emit -> token_stream.t2
evolution.S3.emit -> token_stream.t3

evolution.S1 -> evolution.S2 -> evolution.S3: "next() cycle"

# --- LEGEND & ANNOTATIONS ---
recovery_annotation: {
  shape: rectangle
  near: bottom-right
  label: "SKIP-ONE STRATEGY: \n1. The scanner emits ERROR tokens.\n2. Control returns to caller.\n3. Downstream Parser handles synchronization.\n4. No internal 'panic' loops."
  style: {
    fill: "#fff9c2"
    stroke: "#e5bc00"
    border-radius: 5
  }
}

evolution.S2 -> recovery_logic: "calls" {
  style.stroke: red
  style.stroke-dash: 3
}