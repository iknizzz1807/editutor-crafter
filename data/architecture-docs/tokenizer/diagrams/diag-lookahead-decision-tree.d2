direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- CLASSES & STYLES ---
classes: {
  decision_node: {
    shape: diamond
    style: {
      fill: "#E4DBFE"
      stroke: "#3b1f8c"
    }
  }
  token_node: {
    shape: class
    style: {
      fill: "#C7F1FF"
      stroke: "#007291"
      bold: true
    }
  }
  error_node: {
    shape: class
    style: {
      fill: "#ffcfcf"
      stroke: "#ca052b"
    }
  }
  scanner_method: {
    shape: code
    style: {
      stroke: "#444444"
      fill: "#f5f5f5"
    }
  }
}

# --- HEADER / CONTEXT ---
scanner_context: {
  label: "Scanner::_scan_token() Logic (scanner.py)"
  direction: down

  match_func: |md
    python
    def _match(self, expected: str) -> bool:
        if self.is_at_end(): return False
        if self.source[self.current] != expected: return False
        self.current += 1 # Consume lookahead
        return True
    
  |
  match_func.class: scanner_method
}

# --- DECISION TREE STRUCTURE ---

lookahead_tree: {
  direction: right
  
  start: "Next Char\nConsumed" {
    shape: circle
  }

  # --- EQUAL BRANCH ---
  branch_eq: {
    label: "Case: '='"
    direction: down
    
    peek_eq: "peek == '='" {
      class: decision_node
    }
    
    token_equals: "Token(EQUALS)" {
      class: token_node
    }
    
    token_assign: "Token(ASSIGN)" {
      class: token_node
    }
    
    peek_eq -> token_equals: "Yes (Match)"
    peek_eq -> token_assign: "No"
  }

  # --- BANG BRANCH ---
  branch_bang: {
    label: "Case: '!'"
    direction: down
    
    peek_bang: "peek == '='" {
      class: decision_node
    }
    
    token_not_equal: "Token(NOT_EQUAL)" {
      class: token_node
    }
    
    token_error: "Token(ERROR)" {
      class: error_node
    }
    
    peek_bang -> token_not_equal: "Yes (Match)"
    peek_bang -> token_error: "No"
  }

  # --- LESS THAN BRANCH ---
  branch_lt: {
    label: "Case: '<'"
    direction: down
    
    peek_lt: "peek == '='" {
      class: decision_node
    }
    
    token_le: "Token(LESS_EQUAL)" {
      class: token_node
    }
    
    token_lt: "Token(LESS_THAN)" {
      class: token_node
    }
    
    peek_lt -> token_le: "Yes (Match)"
    peek_lt -> token_lt: "No"
  }

  # --- GREATER THAN BRANCH ---
  branch_gt: {
    label: "Case: '>'"
    direction: down
    
    peek_gt: "peek == '='" {
      class: decision_node
    }
    
    token_ge: "Token(GREATER_EQUAL)" {
      class: token_node
    }
    
    token_gt: "Token(GREATER_THAN)" {
      class: token_node
    }
    
    peek_gt -> token_ge: "Yes (Match)"
    peek_gt -> token_gt: "No"
  }

  # --- CONNECTIONS ---
  start -> branch_eq.peek_eq: "'='"
  start -> branch_bang.peek_bang: "'!'"
  start -> branch_lt.peek_lt: "'<'"
  start -> branch_gt.peek_gt: "'>'"
}

# Logic Flow Annotation
scanner_context -> lookahead_tree: "Implements LA(1) via _match()"

# Footer Stats
metadata: {
  near: bottom-right
  shape: text
  label: |md
    **Maximal Munch Applied**
    Lookahead: 1 char (LA1)
    Implementation: Conditional Consumption
  |
}