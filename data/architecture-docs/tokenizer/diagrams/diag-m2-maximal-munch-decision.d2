direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- SATELLITE CONTEXT ---
# L0: Tokenizer Pipeline (scanner.py)
# Milestone 2: Multi-Character Operators & Maximal Munch

input_layer: {
  label: "INPUT SOURCE (RAM)"
  direction: down
  
  source_buffer: {
    shape: sql_table
    label: "source: str"
    row1: "0x00 | '>' | current_pos"
    row2: "0x01 | '=' | peek(0)"
    row3: "0x02 | '=' | peek(1)"
    row4: "0x03 | ' ' | peek(2)"
  }
}

logic_layer: {
  label: "SCANNER LOGIC (scanner.py)"
  direction: down

  scan_dispatcher: {
    shape: class
    label: "Scanner.next_token()"
    definition: |md
      python
      def next_token(self) -> Token:
          char = self.advance()
          if char in OPERATOR_CHARS:
              return self._scan_operator(char)
      
    |
  }

  decision_tree: {
    label: "Maximal Munch Decision Tree"
    direction: right
    
    start: "First Char\n(Consumed)" {shape: circle}
    
    # Branch for '='
    op_assign: "'='" {
      match_eq: "peek() == '='?" {shape: diamond}
      emit_eq: "EQUAL (==)" {style.fill: "#ACE1AF"}
      emit_as: "ASSIGN (=)" {style.fill: "#C7F1FF"}
      
      match_eq -> emit_eq: "Yes\n(advance())"
      match_eq -> emit_as: "No"
    }

    # Branch for '!'
    op_bang: "'!'" {
      match_eq: "peek() == '='?" {shape: diamond}
      emit_ne: "NOT_EQUAL (!=)" {style.fill: "#ACE1AF"}
      emit_ba: "BANG (!)" {style.fill: "#C7F1FF"}
      
      match_eq -> emit_ne: "Yes\n(advance())"
      match_eq -> emit_ba: "No"
    }

    # Branch for '<'
    op_less: "'<'" {
      match_eq: "peek() == '='?" {shape: diamond}
      emit_le: "LESS_EQ (<=)" {style.fill: "#ACE1AF"}
      emit_lt: "LESS (<)" {style.fill: "#C7F1FF"}
      
      match_eq -> emit_le: "Yes\n(advance())"
      match_eq -> emit_lt: "No"
    }

    # Branch for '>'
    op_greater: "'>'" {
      match_eq: "peek() == '='?" {shape: diamond}
      emit_ge: "GREATER_EQ (>=)" {style.fill: "#ACE1AF"}
      emit_gt: "GREATER (>)" {style.fill: "#C7F1FF"}
      
      match_eq -> emit_ge: "Yes\n(advance())"
      match_eq -> emit_gt: "No"
    }

    start -> op_assign
    start -> op_bang
    start -> op_less
    start -> op_greater
  }
}

trace_layer: {
  label: "EXECUTION TRACE: '>=='"
  direction: down

  step1: {
    label: "Step 1: Consume '>'"
    action: "advance() -> '>'"
    state: "current=1, peek()='='"
  }

  step2: {
    label: "Step 2: Munch Check"
    action: "_match('=') -> True"
    state: "current=2, peek()='='"
  }

  step3: {
    label: "Step 3: Emit Token"
    action: "Return GREATER_EQ"
    lexeme: "'>='"
  }

  step4: {
    label: "Step 4: Next token()"
    action: "advance() -> '='"
    state: "current=3, peek()=' '"
    result: "Return ASSIGN"
  }

  step1 -> step2 -> step3 -> step4: "Control Flow"
}

# Data Flow Connections
input_layer.source_buffer -> logic_layer.scan_dispatcher: "char | 1 byte | '>'"
logic_layer.decision_tree.op_greater.emit_ge -> trace_layer.step3: "Token | {type: GREATER_EQ, lexeme: '>='}"

legend: {
  near: bottom-right
  two_char: "Green = 2-Char Match (Greedy)" {style.fill: "#ACE1AF"}
  one_char: "Blue = 1-Char Fallback" {style.fill: "#C7F1FF"}
}