direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ── GLOBAL STYLES ──
classes: {
  state_node: {
    style: {
      fill: "#f8f9fa"
      stroke: "#212529"
      border-radius: 5
    }
  }
  logic_block: {
    style: {
      fill: "#e7f5ff"
      stroke: "#228be6"
    }
  }
  correct_path: {
    style: {
      stroke: "#40c057"
      stroke-width: 4
    }
  }
  wrong_path: {
    style: {
      stroke: "#fa5252"
      stroke-width: 2
      stroke-dash: 5
    }
  }
}

# ── INPUT DATA ──
input_stream: {
  shape: sql_table
  label: "Source Buffer (scanner.py)"
  
  row0: "0x00 | '>' | index: 0"
  row1: "0x01 | '=' | index: 1"
  row2: "0x02 | '=' | index: 2"
  row3: "0x03 | '\\0'| index: 3 (EOF)"
}

# ── STEP 1: MAXIMAL MUNCH ──
step_1: {
  label: "Step 1: First Token Selection"
  direction: down
  
  scanner_state: {
    shape: sql_table
    label: "Scanner State (t=0)"
    current: "current = 0"
    line: "line = 1"
    col: "column = 1"
  }

  logic: |md
    python
    # Inside next_token()
    char = advance() # consumes '>'
    if char == '>':
        if _match('='): # peeks '=' at index 1
            # MATCH! Consume '='
            return Token(GREATER_EQ, ">=")
    
  |
  
  scanner_state -> logic: "current: 0"
}

# ── STEP 2: RESIDUE CONSUMPTION ──
step_2: {
  label: "Step 2: Subsequent Scan"
  direction: down
  
  scanner_state: {
    shape: sql_table
    label: "Scanner State (t=1)"
    current: "current = 2"
    line: "line = 1"
    col: "column = 3"
  }

  logic: |md
    python
    # next_token() call #2
    char = advance() # consumes '=' at index 2
    if char == '=':
        if _match('='): # peeks '\0' at index 3
            return Token(EQUAL, "==")
        else:
            # NO MATCH! Return single '='
            return Token(TokenType.ASSIGN, "=")
    
  |
  
  scanner_state -> logic: "current: 2"
}

# ── COMPARISON OF OUTCOMES ──
outcomes: {
  label: "Tokenization Comparison"
  direction: down
  
  correct: {
    label: "CORRECT (Maximal Munch)"
    style.fill: "#d3f9d8"
    
    t1: "Token(GREATER_EQ, '>=', 1:1)"
    t2: "Token(ASSIGN, '=', 1:3)"
    
    t1 -> t2: "Ordered Stream"
  }
  
  wrong: {
    label: "WRONG (Naive/Fixed Split)"
    style.fill: "#ffe3e3"
    
    t1: "Token(GREATER, '>', 1:1)"
    t2: "Token(EQUAL, '==', 1:2)"
    
    t1 -> t2: "Semantic Error"
  }
}

# ── DATA FLOW ──
input_stream.row0 -> step_1.scanner_state: "start"
step_1.logic -> step_2.scanner_state: "advance(2 chars)"
step_1.logic -> outcomes.correct.t1: "Emits Longest Match" {class: correct_path}
step_2.logic -> outcomes.correct.t2: "Emits Remainder" {class: correct_path}

# Explicitly showing the wrong path failure
input_stream.row0 -> outcomes.wrong.t1: "Missed '='" {class: wrong_path}

legend: {
  near: bottom-right
  
  munch: "Maximal Munch: Always prefers the longest sequence (>= over >)"
  lookahead: "Lookahead: peek() used to decide without committing"
}