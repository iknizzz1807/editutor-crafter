direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- L0 SATELLITE MAP: Scanner Pipeline ---

layer_input: {
  label: "INPUT: SOURCE BUFFER"
  direction: down

  source_buffer: {
    shape: sql_table
    label: "Buffer (scanner.py) | Pointer: *current"
    
    row0: "0x00 | 0x22 | '\"' (Opening Quote)"
    row1: "0x01 | 0x68 | 'h'"
    row2: "0x02 | 0x65 | 'e'"
    row3: "0x03 | 0x6C | 'l'"
    row4: "0x04 | 0x6C | 'l'"
    row5: "0x05 | 0x6F | 'o'"
    row6: "0x06 | 0x5C | '\\' (Escape Trigger)"
    row7: "0x07 | 0x6E | 'n' (Literal Line Feed)"
    row8: "0x08 | 0x77 | 'w'"
    row9: "0x09 | 0x6F | 'o'"
    row10: "0x0A | 0x72 | 'r'"
    row11: "0x0B | 0x6C | 'l'"
    row12: "0x0C | 0x64 | 'd'"
    row13: "0x0D | 0x22 | '\"' (Closing Quote)"
    
    label_bottom: "Total: 14 Bytes"
  }
}

layer_logic: {
  label: "LOGIC: _scan_string() STATE EVOLUTION"
  direction: down

  trace_execution: {
    direction: down

    step_1: {
      label: "Step 1: Initiation"
      state: "START -> IN_STRING"
      action: "advance(); lexeme.append('\"')"
      style.fill: "#E1F5FE"
    }

    step_2: {
      label: "Steps 2-6: Literal Accumulation"
      state: "IN_STRING"
      action: "advance() x 5; Consume 'hello'"
      buffer: "['\"', 'h', 'e', 'l', 'l', 'o']"
    }

    step_7: {
      label: "Step 7: Escape Transition"
      state: "IN_STRING -> IN_ESCAPE"
      action: "advance(); char == '\\' -> trigger escape flag"
      style.fill: "#FFF9C4"
    }

    step_8: {
      label: "Step 8: Escape Interpretation"
      state: "IN_ESCAPE -> IN_STRING"
      action: "peek() == 'n' -> Map to 0x0A (\\n)"
      append: "lexeme.append('\\n')"
    }

    step_9: {
      label: "Steps 9-14: Finalization"
      state: "IN_STRING -> START"
      action: "Consume 'world\"'; yield Token"
      style.fill: "#C8E6C9"
    }

    step_1 -> step_2 -> step_7 -> step_8 -> step_9
  }
}

layer_output: {
  label: "OUTPUT: TOKEN INSTANCE"
  direction: down

  token_output: {
    shape: class
    label: "struct Token (token.py)"
    
    fields: |md
      python
      type: TokenType   = STRING
      lexeme: str       = '"hello\\nworld"'
      literal: object   = "hello\nworld"
      line: int         = 1
      column: int       = 1
      
    |
    
    metadata: |md
      **Memory Allocation**
      - Total Bytes: 14 (Source)
      - Semantic Length: 12 chars
      - (Includes escape resolution)
    |
  }

  error_case: {
    label: "ERROR PATH: Unterminated Escape"
    style.stroke: red
    
    bad_input: {
      shape: sql_table
      label: "Mem: \"hello\\"
      row0: "0x05 | 'o'"
      row1: "0x06 | '\\' (Backslash)"
      row2: "EOF  | '\\0' (Null)"
    }

    error_result: {
      shape: class
      label: "Token (ERROR)"
      style.fill: "#FFEBEE"
      
      fields: |md
        python
        type   = TokenType.ERROR
        lexeme = '"hello\\'
        msg    = "Unterminated string"
        
      |
    }
    
    bad_input -> error_result: "is_at_end() during IN_ESCAPE" {
      style.stroke: red
      style.animated: true
    }
  }
}

# --- Connections ---

layer_input.source_buffer -> layer_logic.trace_execution: "char | 1 byte | advance()"
layer_logic.trace_execution -> layer_output.token_output: "yield | Token | 48b"

layer_logic.trace_execution.step_7 -> layer_output.error_case: "Alternative: EOF" {
  style.stroke-dash: 5
}

explanation: |md
  ### Scanner Implementation Reference
  1. **Transient State**: `IN_ESCAPE` is a boolean flag toggled during string iteration, not a top-level lexer state.
  2. **Escape Mapping**: The scanner converts the two-byte sequence `\` + `n` into a single semantic character `\n` (LF, ASCII 10).
  3. **Error Guard**: The `_scan_string` loop must check `is_at_end()` before consuming the character following a backslash.
  4. **Validation**: Unsupported escape sequences (e.g., `\z`) should be handled by the semantic literal builder or reported as a specific `TokenType.ERROR`.
| {
  near: bottom-center
}