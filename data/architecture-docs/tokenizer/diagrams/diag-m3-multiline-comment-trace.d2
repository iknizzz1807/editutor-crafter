direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- 1. SCANNER STATE DEFINITION ---
scanner_class: {
  shape: class
  label: "Scanner (scanner.py)"
  
  fields: |md
    python
    source: str      # Full input text
    current: int     # Pointer to next char (offset)
    line: int        # 1-indexed line tracking
    column: int      # 1-indexed column tracking
    
  |
  
  methods: |md
    python
    def advance(self) -> str:
        # Consumes char, updates line/col
    def peek(self) -> str:
        # Non-consuming lookahead
    def _skip_block_comment(self):
        # The sub-FSM logic for /* ... */
    
  |
}

# --- 2. THE DATA WALK: TRACE THROUGH MULTI-LINE COMMENT ---
trace_container: {
  label: "Trace: Data Walk (a /* comment\\nstill comment */ b)"
  direction: down

  # Memory Visualization
  memory_buffer: {
    shape: sql_table
    label: "Source String Buffer (0x7f00...)"
    
    line1: "Line 1 | 0x00 | a |   | / | * |   | c | o | m | m | e | n | t | \\n"
    line2: "Line 2 | 0x0E |   |   | s | t | i | l | l |   | c | o | m | m | e | n | t |   | * | / |   | b"
    
    label_bottom: "Buffer size: 34 bytes | Encoding: UTF-8"
  }

  # Evolution of Scanner State (Renamed from 'steps' to 'trace_steps' to avoid keyword conflict)
  trace_steps: {
    direction: right
    
    step_1: {
      label: "Step 1: START"
      state: |md
        **Pos:** (1, 1)
        **Action:** advance()
        **Result:** 'a'
        **Emit:** IDENTIFIER("a")
      |
      style.stroke: "#007acc"
    }

    step_2: {
      label: "Step 2: COMMENT START"
      state: |md
        **Pos:** (1, 3)
        **Action:** advance('/') + match('*')
        **Sub-State:** IN_BLOCK_COMMENT
        **Mark:** current_pos captured
      |
      style.stroke: "#6f42c1"
    }

    step_3: {
      label: "Step 3: LINE CROSSING"
      state: |md
        **Pos:** (1, 14)
        **Action:** advance('\n')
        **Trigger:** line += 1; column = 1
        **Pos:** (2, 1)
      |
      style.stroke: "#d4a017"
    }

    step_4: {
      label: "Step 4: COMMENT END"
      state: |md
        **Pos:** (2, 16)
        **Action:** advance('*') + peek('/') == True
        **Finalize:** advance('/')
        **Result:** Comment Consumed
      |
      style.stroke: "#6f42c1"
    }

    step_5: {
      label: "Step 5: RESUME"
      state: |md
        **Pos:** (2, 18)
        **Action:** next_token() -> advance()
        **Result:** 'b'
        **Emit:** IDENTIFIER("b", 2:18)
      |
      style.stroke: "#28a745"
    }

    step_1 -> step_2: "O(1) Dispatch"
    step_2 -> step_3: "Consume Content"
    step_3 -> step_4: "Consume Content"
    step_4 -> step_5: "Return None -> Recurse"
  }
}

# --- 3. THE "C" CONVENTION LOGIC ---
non_nesting_logic: {
  label: "Edge Case: Non-Nesting Failure Mode (scanner.py)"
  direction: right
  
  input_source: {
    shape: code
    label: "Source: /* a /* b */ c */"
  }

  fsm_execution: {
    shape: sequence_diagram
    
    "Scanner.next_token" -> "CommentSubFSM": "Enter at first /*"
    "CommentSubFSM" -> "CommentSubFSM": "Ignore inner /* (Lexeme) "
    "CommentSubFSM" -> "Scanner.next_token": "Exit at first */"
    "Scanner.next_token" -> "Scanner.next_token": "Resume at ' c */'"
    
    analysis: |md
      **Lexical Decomposition:**
      1. IGNORED: `/* a /* b */`
      2. TOKEN: `IDENTIFIER("c")`
      3. ERROR: `*` (Unexpected character)
      4. ERROR: `/` (Unexpected character)
    |
  }

  input_source -> fsm_execution: "Maximal Munch Analysis"
}

# --- 4. TOP-LEVEL CONNECTIONS ---
scanner_class -> trace_container: "Implements logic for"
trace_container -> non_nesting_logic: "Theoretical Constraint"

# Metadata Annotations
trace_container.trace_steps.step_3 -> trace_container.memory_buffer: "advance() triggers line update" {
  style.stroke-dash: 5
}

trace_container.trace_steps.step_5 -> trace_container.memory_buffer: "Capture Start Pos (2, 18)" {
  style.stroke-dash: 5
}