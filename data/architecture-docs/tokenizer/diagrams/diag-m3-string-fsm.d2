direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# String Literal FSM - Scanner Implementation Blueprint
# File: scanner.py | Method: _scan_string()

state_machine: {
  label: "String Scanner Finite State Machine (scanner.py)"

  # State Definitions
  START: {
    shape: circle
    label: "START\n(next_token)"
  }

  OPEN_QUOTE: {
    shape: circle
    label: "OPEN_QUOTE\n0x22 captured"
    tooltip: "Captures tok_line/tok_col"
  }

  NORMAL_CHAR: {
    shape: circle
    label: "IN_STRING\n(Accumulating)"
  }

  ESCAPE_START: {
    shape: circle
    label: "IN_ESCAPE\nSaw 0x5C (\\)"
    style.fill: "#fff2cc"
  }

  CLOSE_QUOTE: {
    shape: circle
    label: "SUCCESS\n(STRING Token)"
    style: {
      stroke: "#2b78e4"
      stroke-width: 4
      double-border: true
    }
  }

  ERROR_UNTERMINATED: {
    shape: circle
    label: "ERROR\n(Unterminated)"
    style: {
      stroke: "#cc0000"
      fill: "#f8cecc"
      stroke-width: 4
    }
  }

  # Transitions
  START -> OPEN_QUOTE: "advance() | 0x22 [\"]"
  
  OPEN_QUOTE -> NORMAL_CHAR: "advance() | ! [\", \\, \\n]"
  
  NORMAL_CHAR -> NORMAL_CHAR: "advance() | ! [\", \\, \\n]"
  
  NORMAL_CHAR -> ESCAPE_START: "advance() | 0x5C [\\]"
  
  ESCAPE_START -> NORMAL_CHAR: "advance() | [n, t, r, \", \\]" {
    label: "Valid Escape Sequence"
    style.stroke: "#6aa84f"
  }

  ESCAPE_START -> ERROR_UNTERMINATED: "advance() | ![n, t, r, \", \\] OR EOF" {
    label: "Invalid Escape / EOF"
    style.stroke: "#cc0000"
  }

  NORMAL_CHAR -> CLOSE_QUOTE: "advance() | 0x22 [\"]" {
    style.stroke: "#6aa84f"
    style.stroke-width: 2
  }

  NORMAL_CHAR -> ERROR_UNTERMINATED: "peek() | 0x0A [\\n] OR EOF" {
    label: "Literal Newline/EOF"
    style.stroke: "#cc0000"
    style.stroke-dash: 3
  }

  OPEN_QUOTE -> CLOSE_QUOTE: "advance() | 0x22 [\"]" {
    label: "Empty String \"\""
  }
}

# Implementation Details Container
implementation_logic: {
  direction: down
  
  scanner_class: {
    shape: class
    label: "Scanner (scanner.py)"
    
    fields: |md
      python
      source: str   # Raw input
      current: int  # Cursor index
      line: int     # 1-indexed
      column: int   # 1-indexed
      
    |
    
    methods: |md
      python
      def _scan_string(self, tok_line: int, tok_col: int) -> Token:
          # FSM logic implemented via while-True loop
          # returns TokenType.STRING or TokenType.ERROR
      
    |
  }

  token_data: {
    shape: sql_table
    label: "struct Token (milestone 1)"
    
    row1: "type     | TokenType.STRING"
    row2: "lexeme   | '\"raw_source_including_quotes\"'"
    row3: "line     | start_line_of_quote"
    row4: "column   | start_col_of_quote"
    label_bottom: "Metadata for Error Reporting"
  }
}

# Layout Connections
state_machine.NORMAL_CHAR -> implementation_logic.scanner_class: "Uses advance() | updates col/line" {
  style.stroke-dash: 5
}

# Annotations
legend: {
  near: bottom-right
  
  valid: Valid Transition {
    style.stroke: "#6aa84f"
  }
  invalid: Error Path {
    style.stroke: "#cc0000"
  }
  lookahead: Non-Consuming (peek) {
    style.stroke-dash: 3
  }
}

explanation: |md
  ### State Machine Contract
  1. **Greedy Accumulation**: Continues until `"` or boundary error.
  2. **Context Shift**: Escape mode (`\`) disables the terminator check for the next byte.
  3. **Position Blame**: `ERROR` tokens must report `tok_line`/`tok_col` (start of string).
  4. **Phase 1 Only**: Escape characters are **NOT** interpreted here; stored raw.
| {
  near: top-center
}