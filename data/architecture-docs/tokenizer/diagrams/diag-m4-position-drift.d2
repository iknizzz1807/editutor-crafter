direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# SATELLITE MAP: Position Tracking Invariants & Cumulative Drift
# This diagram serves as a blueprint for implementing precise source location tracking.

input_layer: {
  direction: down
  label: "SOURCE INPUT LAYER"

  source_data: {
    shape: sql_table
    label: "Raw Source Buffer (scanner.py)"
    row1: "0x00 | uint8_t | 0x69 ('i')"
    row2: "0x01 | uint8_t | 0x66 ('f')"
    row3: "0x02 | uint8_t | 0x20 (' ' Space)"
    row4: "0x03 | uint8_t | 0x09 ('\\t' Tab)"
    row5: "0x04 | uint8_t | 0x78 ('x')"
    label_bottom: "Cursor starts at offset 0x00"
  }

  metadata: |md
    ### Buffer Metadata
    - **Encoding**: UTF-8 (Fixed-width ASCII subset)
    - **Tab Width**: 8 (Standard Alignment)
    - **Buffer Size**: 4096 bytes (Page Aligned)
  |
}

logic_layer: {
  direction: down
  label: "SCANNER POSITION LOGIC"

  buggy_implementation: {
    label: "Naive Tracker (Buggy) (naive.py)"
    style: {
      fill: "#FFEBEE"
      stroke: "#B71C1C"
      stroke-width: 2
    }
    
    code: |md
      python
      # ERROR: Ignores Tab Alignment
      # Treats \t as 1 column, causing visual misalignment
      def advance(self):
          char = self.source[self.current]
          self.current += 1
          self.column += 1 
          return char
      
    |
  }

  fixed_implementation: {
    label: "Invariant-Safe Tracker (Fixed) (tracker.py)"
    style: {
      fill: "#E8F5E9"
      stroke: "#1B5E20"
      stroke-width: 2
    }

    code: |md
      python
      # CORRECT: Tab-Stop Alignment Logic
      # Calculates jump to next 8-char boundary
      def advance(self, tab_size=8):
          char = self.source[self.current]
          self.current += 1
          if char == '\t':
              # Align to next tab stop (1, 9, 17...)
              self.column += (tab_size - (self.column - 1) % tab_size)
          elif char == '\n':
              self.line += 1
              self.column = 1
          else:
              self.column += 1
          return char
      
    |
  }
}

output_layer: {
  direction: down
  label: "VALIDATION & TOKEN STREAM"

  drift_analysis: {
    label: "Cumulative Drift Analysis"
    
    bad_result: {
      shape: sql_table
      label: "Drifted Stream (Fail)"
      style.stroke: "#B71C1C"
      row1: "Token(if) | line: 1 | col: 1"
      row2: "Token(x)  | line: 1 | col: 5 (WRONG)"
      row3: "Result: Column Misalignment"
    }

    good_result: {
      shape: sql_table
      label: "Verified Stream (Pass)"
      style.stroke: "#1B5E20"
      row1: "Token(if) | line: 1 | col: 1"
      row2: "Token(x)  | line: 1 | col: 9 (MATCH)"
      row3: "Result: Precise Source Mapping"
    }
  }

  token_struct: {
    shape: sql_table
    label: "struct Token (token.h)"
    row1: "0x00 | uint32_t  | type"
    row2: "0x04 | uint32_t  | line"
    row3: "0x08 | uint32_t  | column"
    row4: "0x0C | uint32_t  | _padding"
    row5: "0x10 | char*     | lexeme"
    label_bottom: "Total Size: 24 Bytes (64-bit pointers)"
  }
}

# DATA FLOWS
input_layer.source_data -> logic_layer.buggy_implementation: "char | 1 byte | 0x09 (TAB)"
input_layer.source_data -> logic_layer.fixed_implementation: "char | 1 byte | 0x09 (TAB)"

logic_layer.buggy_implementation -> output_layer.drift_analysis.bad_result: "Token | 24 bytes | {col: 5}"
logic_layer.fixed_implementation -> output_layer.drift_analysis.good_result: "Token | 24 bytes | {col: 9}"

output_layer.drift_analysis.good_result -> output_layer.token_struct: "implements"

# ANNOTATIONS
annotation_box: {
  near: bottom-center
  shape: rectangle
  style: {
    fill: "#FFF9C9"
    stroke: "#FBC02D"
    stroke-dash: 2
  }
  label: |md
    ### Design Rule: Maximal Munch & Invariants
    1. Position must be captured **before** consuming bytes.
    2. Column count must account for multi-byte characters.
    3. Tab-stops are relative to line start, not current token.
  |
}

legend: {
  near: bottom-left
  shape: text
  label: "Red: Buggy/Drift Path\nGreen: Corrected Hot Path\nBlue: Data Transmission"
}