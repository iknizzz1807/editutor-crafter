direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# ---------------------------------------------------------------------------------
# 1. CORE DATA STRUCTURES (L2 - Microscopic)
# ---------------------------------------------------------------------------------
token_definition: {
  shape: sql_table
  label: "struct Token (scanner.h)"
  
  0x00: "uint8_t   | type    | enum { TOKEN_IDENT, TOKEN_ERROR, TOKEN_EOF }"
  0x08: "char*     | lexeme  | pointer to source slice"
  0x10: "uint32_t  | line    | 1-based source line"
  0x14: "uint32_t  | column  | 1-based start column"
  0x18: "uint32_t  | length  | slice length"
  
  label_bottom: "Total size: 32 bytes (including 4-byte padding for alignment)"
}

# ---------------------------------------------------------------------------------
# 2. COMPARATIVE SYSTEM LOGIC (L1 - Street Map)
# ---------------------------------------------------------------------------------
lexical_strategies: {
  direction: right
  label: "LEXER ERROR RECOVERY STRATEGIES (scanner.c)"

  input_buffer: {
    shape: code
    label: "Input Source (buffer.c)"
    content: |'md
    python
    # Source contains invalid chars: @, #, $
    source = "x @ y # z $ w"
    
    '|
  }

  comparison_layer: {
    direction: down
    
    # STRATEGY A: ATOMIC FAIL
    naive_strategy: {
      label: "Strategy A: Atomic Fail (Naive Stop)"
      direction: right
      style: {
        stroke: "#e53935"
        fill: "#ffebee"
        stroke-width: 2
      }

      logic: {
        shape: code
        label: "scan_next() (legacy_v1.c)"
        content: |'md
        c
        Token scan_token(Scanner* s) {
            char c = advance(s);
            if (!is_valid(c)) {
                // HALTS ENTIRE PROCESS
                fprintf(stderr, "Lex Error: %c", c);
                exit(1); 
            }
            return emit_token(s, c);
        }
        
        '|
      }

      crash_state: {
        shape: sql_table
        label: "Output Stream (CRASHED)"
        t0: "IDENTIFIER | 'x' | 1:1"
        err: "FATAL: Unexpected '@' at 1:3"
      }
      crash_state.err.style: {
        font-color: red
        bold: true
      }

      logic -> crash_state: "exit(1)"
    }

    # STRATEGY B: PANIC-MODE RECOVERY
    recovery_strategy: {
      label: "Strategy B: Multi-Error Collection (Synchronized)"
      direction: right
      style: {
        stroke: "#2e7d32"
        fill: "#f1f8e9"
        stroke-width: 2
      }

      logic: {
        shape: code
        label: "scan_tokens() (scanner_v2.c)"
        content: |'md
        c
        void scan_tokens(Scanner* s) {
            while (!is_at_end(s)) {
                s->start = s->current;
                // scan_token() reports errors 
                // but does not halt the loop.
                add_token(scan_token(s));
            }
        }
        
        '|
      }

      recovery_output: {
        shape: sql_table
        label: "Token Vector (State: COMPLETE)"
        
        r0: "0x00 | IDENTIFIER | 'x' | 1:1"
        r1: "0x20 | ERROR      | '@' | 1:3"
        r2: "0x40 | IDENTIFIER | 'y' | 1:5"
        r3: "0x60 | ERROR      | '#' | 1:7"
        r4: "0x80 | IDENTIFIER | 'z' | 1:9"
        r5: '0xA0 | ERROR      | "$" | 1:11'
        r6: "0xC0 | IDENTIFIER | 'w' | 1:13"
        r7: "0xE0 | EOF        | ''  | 1:14"
        
        label_bottom: "8 Tokens (256 Bytes) | Total Errors: 3"
      }
      
      recovery_output.r1.style.fill: "#ffcdd2"
      recovery_output.r3.style.fill: "#ffcdd2"
      recovery_output.r5.style.fill: "#ffcdd2"

      logic -> recovery_output: "Vector<Token>"
    }
  }

  input_buffer -> comparison_layer.naive_strategy.logic: "char* (UTF-8)"
  input_buffer -> comparison_layer.recovery_strategy.logic: "char* (UTF-8)"
}

# ---------------------------------------------------------------------------------
# 3. IMPLEMENTATION ANNOTATION
# ---------------------------------------------------------------------------------
recovery_doc: {
  near: bottom-right
  shape: text
  label: |'md
  ### Skip-One Recovery Logic (Panic Mode)
  To prevent cascading failures, the scanner treats invalid characters as single-character error tokens.
  
  1. **Detection**: `scan_token` hits default switch case.
  2. **Reporting**: `errorAtCurrent("Unexpected character.")` updates `hadError` flag.
  3. **Synchronization**: The loop in `scan_tokens` simply continues.
  4. **Pointer Progress**: Since `advance()` was called, `current` is moved forward by 1 byte.
  
  **Implementation Ready**: The compiler continues to parse the full file, enabling a full error report in one pass.
  '|
}

# ---------------------------------------------------------------------------------
# 4. VISUAL FLOWS & BINDINGS
# ---------------------------------------------------------------------------------
(lexical_strategies.comparison_layer.recovery_strategy.logic -> lexical_strategies.comparison_layer.recovery_strategy.recovery_output)[0]: {
  style: {
    stroke: "#2e7d32"
    animated: true
  }
}

token_definition -> lexical_strategies.comparison_layer.recovery_strategy.recovery_output: "Implementation Target" {
  style.stroke-dash: 5
}