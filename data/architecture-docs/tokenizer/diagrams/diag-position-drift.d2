direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# L1: Component Architecture & Structure Definitions
definitions: {
  direction: down
  label: "STRUCTURAL DEFINITIONS (scanner.py)"
  
  scanner_engine: {
    shape: class
    label: "class Scanner (scanner.py)"
    
    fields: |md
    python
    # Internal State (Byte Offsets for 64-bit CPython)
    0x00 | str      | source        # Ptr to input buffer
    0x08 | int      | start         # Lexeme start index
    0x10 | int      | current       # Current cursor pos
    0x18 | int      | line          # 1-based line counter
    0x20 | int      | column        # 1-based column counter
    0x28 | int      | start_column  # Column at lexeme start
    
    |
    
    methods: |md
    python
    def advance(self) -> str: ...
    def peek(self) -> str: ...
    def is_at_end(self) -> bool: ...
    def _skip_line_comment(self) -> None: ...
    def _make_token(self, t: TokenType) -> Token: ...
    
    |
    
    label_bottom: "Total: 48 bytes | Memory Align: 8"
  }

  input_buffer: {
    shape: sql_table
    label: "Source String (source.src)"
    
    row1: "L1 | 0x00-0x09 | i n t _ x _ = _ 5 ; \\n"
    row2: "L2 | 0x0A-0x14 | / / _ c o m m e n t \\n"
    row3: "L3 | 0x15-0x1E | y _ = _ x _ + _ 1 ; \\0"
    
    label_bottom: "Total: 31 bytes | Enc: UTF-8"
  }
}

# L2: Data Walk & State Evolution
trace: {
  direction: down
  label: "Position Accuracy & Drift Analysis"

  t0: {
    label: "T0: Initialization\nLine: 1 | Col: 1 | Curr: 0"
    style: { fill: "#E4DBFE" }
  }

  t1: {
    label: "T1: Lexed 'int x = 5;'\nLine: 1 | Col: 11 | Curr: 10"
    style: { fill: "#C7F1FF" }
  }

  t2: {
    label: "T2: Newline Transition\nLine: 2 | Col: 1 | Curr: 11"
    style: { fill: "#FFF9C9" }
  }

  t3: {
    label: "T3: Comment Traversal\nLine: 2 | Col: 11 | Curr: 21"
    style: { 
      fill: "#E6EBF1"
      stroke-dash: 3
    }
  }

  t4: {
    label: "T4: Post-Comment Boundary\nLine: 3 | Col: 1 | Curr: 22"
    style: { 
      fill: "#ACE1AF"
      bold: true
    }
  }

  t5: {
    label: "T5: Token 'y' Position\nLine: 3 | Col: 2 | Curr: 23"
    style: { fill: "#C7F1FF" }
  }

  # Transitions with detailed data flow
  t0 -> t1: "advance() x10 | 10 chars | Lexeme: 'int x = 5;'"
  t1 -> t2: "advance('\\n') | 1 char | line++"
  t2 -> t3: "_skip_line_comment() | 10 chars | while peek() != '\\n'"
  t3 -> t4: "advance('\\n') | 1 char | line=3, col=1"
  t4 -> t5: "Token(IDENTIFIER, 'y') | 1 char | col=2"
}

# Critical Annotations & Logic Flows
definitions.scanner_engine -> definitions.input_buffer: "mmap/read | 31 bytes"
definitions.input_buffer.row1 -> trace.t1: "10 bytes | UTF-8"
definitions.input_buffer.row2 -> trace.t3: "10 bytes | Comment Block"

bug_alert: {
  label: "CRITICAL DRIFT RISK"
  shape: cloud
  tooltip: "Parser must call advance() within skip loops to maintain line/col sync"
  style: {
    fill: "#FE7070"
    stroke: red
    font-color: white
  }
}

trace.t3 -> bug_alert: "Loop-local index skip (DRIFT)" {
  style: { stroke: red; stroke-dash: 5; animated: true }
}

implementation_notes: |md
  ### Implementation Invariants (scanner.py)
  1. `self.line` is incremented **exclusively** within `advance()` when `char == '\n'`.
  2. `self.column` resets to `1` on `\n`, else increments via `self.column += 1`.
  3. `Token` objects capture `line` and `column` snapshots from `self.line` and `self.start_column`.
| 

# Placement for ELK Layout Compatibility
implementation_notes.near: bottom-right

# Component grouping for 2D scan
definitions -> trace: "Execution Context"
bug_alert -> trace.t4: "Sync Check" {
  style: { stroke: red; stroke-dash: 2 }
}