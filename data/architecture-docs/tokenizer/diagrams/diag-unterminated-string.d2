direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# 1. INPUT BUFFER REPRESENTATION
input_buffer: {
  shape: sql_table
  label: "Source Buffer (scanner.py)"
  
  row0: "Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13"
  row1: "Char  | \" | h | e | l | l | o | \\n | w | o | r | l | d | EOF |"
  row2: "Line  | 1 | 1 | 1 | 1 | 1 | 1 | 1  | 2 | 2 | 2 | 2 | 2 | 2   |"
  row3: "Col   | 1 | 2 | 3 | 4 | 5 | 6 | 7  | 1 | 2 | 3 | 4 | 5 | 6   |"
  
  label_bottom: "Total: 14 characters (Unterminated String)"
}

# 2. COMPARISON LAYERS
strategies: {
  direction: down
  
  naive_impl: {
    label: "NAIVE IMPLEMENTATION (The Failed UX)"
    direction: right
    
    logic: {
      shape: code
      label: "Naive Scan"
      |md
      python
      def _scan_string(self):
          while not self.is_at_end() and self.peek() != '"':
              self.advance()
          if self.is_at_end():
              # Bug: Uses current line/column at loop exit
              return Token(ERROR, self.lexeme(), self.line, self.column)
      
      |
    }
    
    output_token: {
      shape: sql_table
      label: "struct Token (Naive Error)"
      style.stroke: red
      
      type: "0x00 | TokenType | ERROR"
      lex:  "0x08 | char*     | '\"hello\\nworld'"
      line: "0x10 | uint32_t  | 2"
      col:  "0x14 | uint32_t  | 6"
      
      label_bottom: "Error reported at EOF (Useless to Dev)"
    }
    
    logic -> output_token: "Returns at EOF"
  }

  master_impl: {
    label: "IMPLEMENTATION-READY (Master Artist Standard)"
    direction: right
    
    logic: {
      shape: code
      label: "Snapshot Scan"
      |md
      python
      def _scan_string(self):
          # Snapshot opening position for precise error reporting
          err_line = self.line
          err_col = self.start_column
          
          while not self.is_at_end() and self.peek() != '"':
              self.advance()
              
          if self.is_at_end():
              # Correct: Report at snapshot location
              return Token(ERROR, self.lexeme(), err_line, err_col)
      
      |
    }
    
    output_token: {
      shape: sql_table
      label: "struct Token (Correct Error)"
      style.stroke: "#2ecc71"
      
      type: "0x00 | TokenType | ERROR"
      lex:  "0x08 | char*     | '\"hello\\nworld'"
      line: "0x10 | uint32_t  | 1"
      col:  "0x14 | uint32_t  | 1"
      
      label_bottom: "Error reported at Opening Quote (Precise)"
    }
    
    logic -> output_token: "Returns with Metadata Snapshot"
  }
}

# 3. DATA FLOW & POINTERS
input_buffer.row1 -> strategies.naive_impl.logic: "Raw Buffer | 14 bytes" {
  style.stroke: red
  style.stroke-dash: 3
}

input_buffer.row1 -> strategies.master_impl.logic: "Raw Buffer | 14 bytes" {
  style.stroke: "#2ecc71"
}

# Annotations for "Meticulous Detail"
lexer_state: {
  near: bottom-left
  shape: text
  label: |md
    ### Lexer State Mapping
    - **start_column**: 1 (Snapshotted at index 0)
    - **current**: 13 (Pointer at EOF)
    - **Invariant**: `Token.line/col` must reference the start of the lexeme.
  |
}

# Cross references linking Error tokens to position in buffer
strategies.naive_impl.output_token -> input_buffer.row3: "Points to EOF (Index 13)" {
  style.stroke: red
  target-arrowhead: diamond
}

strategies.master_impl.output_token -> input_buffer.row3: "Points to opening '\"' (Index 0)" {
  style.stroke: "#2ecc71"
  target-arrowhead: diamond
}

strategies -> input_buffer: "Scanning Process" {
  style.stroke-width: 1
  source-arrowhead: triangle
}