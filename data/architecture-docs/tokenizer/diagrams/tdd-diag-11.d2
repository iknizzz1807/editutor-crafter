direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# -------------------------------------------------------------------------------------------
# CASE A: MAXIMAL MUNCH (CORRECT)
# -------------------------------------------------------------------------------------------
Maximal_Munch: "ALGORITHM: MAXIMAL MUNCH (CORRECT)" {
  
  Step_1: "1. INITIAL STATE" {
    Buffer: "[ > ] [ = ] [ = ]"
    Pointers: " ^S    ^C"
    State: {
      shape: sql_table
      style.fill: "#9d70ff" # Header=Purple
      0x00: "start = 0" {constraint: "4B"}
      0x04: "current = 0" {constraint: "4B"}
    }
  }

  Step_2: "2. ADVANCE (CONSUME '>')" {
    Buffer: "[ > ] [ = ] [ = ]"
    Pointers: " ^S           ^C"
    State: {
      shape: sql_table
      style.fill: "#9d70ff"
      0x00: "start = 0" {constraint: "4B"}
      0x04: "current = 1" {
        style.font-color: red
        style.bold: true
        constraint: "4B"
      }
    }
    Note: |md **char = '>'** |
  }

  Step_3: "3. PEEK & MATCH ('=')" {
    Buffer: "[ > ] [ = ] [ = ]"
    Pointers: " ^S                 ^C"
    State: {
      shape: sql_table
      style.fill: "#9d70ff"
      0x00: "start = 0" {constraint: "4B"}
      0x04: "current = 2" {
        style.font-color: red
        style.bold: true
        constraint: "4B"
      }
    }
    Note: |md Greedy match succeeds. Consumes '='. Result: **'>='** |
  }

  Step_4: "4. EMIT GREATER_EQUAL" {
    Token: {
      shape: sql_table
      style.fill: "#9d70ff" # Header=Purple
      0x00: "type = GREATER_EQUAL" {constraint: "4B"}
      0x04: "lexeme = '>='" {constraint: "8B"}
      0x0C: "line = 1" {constraint: "4B"}
      0x10: "col = 1" {constraint: "4B"}
    }
  }

  Step_1 -> Step_2 -> Step_3 -> Step_4
}

# -------------------------------------------------------------------------------------------
# CASE B: NON-GREEDY (INCORRECT)
# -------------------------------------------------------------------------------------------
Non_Greedy: "ALGORITHM: NON-GREEDY (INCORRECT)" {
  style.stroke: red

  Step_1: "1. INITIAL STATE" {
    Buffer: "[ > ] [ = ] [ = ]"
    Pointers: " ^S    ^C"
  }

  Step_2: "2. ADVANCE (CONSUME '>')" {
    Buffer: "[ > ] [ = ] [ = ]"
    Pointers: " ^S           ^C"
  }

  Step_3: "3. PREMATURE EMIT" {
    Token: {
      shape: sql_table
      style.fill: "#ff4d4d" # Error State Red
      0x00: "type = GREATER_THAN" {
        style.bold: true
        constraint: "4B"
      }
      0x04: "lexeme = '>'" {constraint: "8B"}
    }
    Note: |md **FAILED TO PEEK.** Logic exits greediness loop early. |
  }

  Step_4: "4. RESTART SCAN" {
    Buffer: "[ > ] [ = ] [ = ]"
    Pointers: "        ^S    ^C"
    Note: |md `start` moves to index 1. |
  }

  Step_5: "5. MATCH EQUALS" {
    Token: {
      shape: sql_table
      style.fill: "#ff4d4d"
      0x00: "type = EQUALS" {
        style.bold: true
        constraint: "4B"
      }
      0x04: "lexeme = '=='" {constraint: "8B"}
    }
  }

  Step_1 -> Step_2 -> Step_3 -> Step_4 -> Step_5
}

# -------------------------------------------------------------------------------------------
# GLOBAL COMPARISON ANNOTATION
# -------------------------------------------------------------------------------------------
# FIXED: Changed 'near: Maximal_Munch' to constant 'near: top-center' for ELK compatibility
Annotation: |md
  ### Lexical Conflict Resolution
  In input string `>==`, the scanner reaches index 0. 
  - **Maximal Munch**: Prefers `source[0:2]` (`>=`) as a single valid operator.
  - **Non-Greedy**: Prefers `source[0:1]` (`>`), leaving `==` as a separate token.
  
  **Maximal Munch is mandatory** to prevent the parser from receiving ambiguous operators as separate assignment/comparison tokens.
| {
  near: top-center
}

# Legend for Intellectual Manual Quality
Legend: {
  shape: package
  style.stroke-dash: 5
  
  Header: "Field Headers" { style.fill: "#9d70ff" }
  Ptrs: "Pointers/Offsets" { style.fill: "#ff9d00" }
  Change: "State Change" { style.font-color: red; style.bold: true }
}