vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

"_match(expected) Algorithm Steps": {
  shape: package
  style.stroke-width: 2

  "Scenario: source='==', current=1, calling _match('=')": {
    shape: rectangle
    style: {
      fill: "#fff9c4"
      stroke-dash: 2
    }
  }

  "Step 1: Boundary Check": {
    "State 1": {
      shape: sql_table
      style.fill: "#E1F5FE"
      current: "1"
      line: "1"
      column: "2"
      source: "=="
      lookahead: "'='"
    }
    "Action 1": "Check is_at_end() -> False"
    "State 1" -> "Action 1": "Proceed"
  }

  "Step 2: Character Match": {
    "State 2": {
      shape: sql_table
      style.fill: "#E1F5FE"
      current: "1"
      line: "1"
      column: "2"
      source: "=="
      match: "source[1] == '='"
    }
    "Action 2": "Compare current char to expected"
    "State 2" -> "Action 2": "Match Found"
  }

  "Step 3: Consumption (advance)": {
    "State 3": {
      shape: sql_table
      style.fill: "#E1F5FE"
      current: "**2**" {style.font-color: red; style.bold: true}
      line: "1"
      column: "**3**" {style.font-color: red; style.bold: true}
      source: "=="
    }
    "Action 3": "self.advance() updates cursor and position"
    "State 3" -> "Action 3": "Consumed"
  }

  "Step 4: Return Result": {
    "State 4": {
      shape: sql_table
      style.fill: "#E1F5FE"
      status: "SUCCESS"
      return: "**True**" {style.font-color: "#2e7d32"; style.bold: true}
    }
    "Action 4": "Caller now emits 2-char token"
    "State 4" -> "Action 4"
  }

  "Step 1: Boundary Check" -> "Step 2: Character Match"
  "Step 2: Character Match" -> "Step 3: Consumption (advance)"
  "Step 3: Consumption (advance)" -> "Step 4: Return Result"
}

"Visual Logic Comparison": {
  "Before _match('=')": {
    shape: sql_table
    style.fill: "#f0f0f0"
    current: "1"
    column: "2"
    lexeme_buffer: "'='"
  }

  "After _match('=') Success": {
    shape: sql_table
    style.fill: "#e6fffa"
    current: "**2**" {style.font-color: red; style.bold: true}
    column: "**3**" {style.font-color: red; style.bold: true}
    lexeme_buffer: "**'=='**" {style.font-color: red; style.bold: true}
  }

  "After _match('=') Failure": {
    shape: sql_table
    style.fill: "#fff5f5"
    current: "1 (No change)"
    column: "2 (No change)"
    lexeme_buffer: "'=' (No change)"
  }

  "Before _match('=')" -> "After _match('=') Success": "char matched"
  "Before _match('=')" -> "After _match('=') Failure": "char mismatch/EOF"
}

"Implementation Note": |md
  ### Invariant Preservation
  `_match()` **must** delegate to `self.advance()` rather than incrementing `self.current` directly.
  This ensures that if a two-character sequence happens to contain a newline, the line counter remains synchronized.
| {
  near: bottom-center
}