vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

diag-m2-keyword-vs-identifier: "Identifier Scanning + Keyword Table Lookup" {
  direction: right

  phase_1: "PHASE 1: Lexeme Collection (Scanning)" {
    dispatcher: "next_token() dispatcher" {
      shape: oval
      style.fill: "#E1D5E7" # Purple (Header/Logic)
    }
    
    consume_1: "1. Consume first_char\n(Letter or '_')" {
      shape: rectangle
      style.fill: "#B1D1FC" # Blue (Data)
    }
    
    munch_loop: "2. Maximal Munch Loop" {
      style.stroke-dash: 3
      
      check: "peek() is alnum\nor '_'?" {
        shape: diamond
        style.fill: "#B1D1FC"
      }
      
      advance: "advance() & append\nto lexeme buffer" {
        shape: rectangle
        style.fill: "#B1D1FC"
      }
      
      check -> advance: "Yes"
      advance -> check: "Repeat"
    }
    
    lexeme_buffer: "3. Complete Lexeme String" {
      shape: cylinder
      style.stroke: "#FFA500" # Orange (Pointer/Output)
      style.fill: "#B1D1FC"
      |'md
        **Size**: N bytes  
        **Encoding**: UTF-8
      '|
    }
    
    dispatcher -> consume_1
    consume_1 -> munch_loop.check
    munch_loop.check -> lexeme_buffer: "No (Boundary Found)"
  }

  phase_2: "PHASE 2: Semantic Resolution (Lookup)" {
    probe: "4. Hash Table Probe" {
      shape: diamond
      label: "KEYWORDS.get(lexeme,\nTokenType.IDENTIFIER)"
      style.fill: "#B1D1FC"
    }

    keyword_table: "Keyword ROM Table" {
      shape: sql_table
      style.fill: "#E1D5E7"
      "if": "KW_IF" {constraint: "8 bytes"}
      "else": "KW_ELSE" {constraint: "8 bytes"}
      "while": "KW_WHILE" {constraint: "8 bytes"}
      "return": "KW_RETURN" {constraint: "8 bytes"}
      "true": "KW_TRUE" {constraint: "8 bytes"}
    }

    emit_keyword: "5a. Token(KEYWORD)" {
      shape: parallelogram
      style.fill: "#D5E8D4" # Green (Free/Success)
    }
    
    emit_identifier: "5b. Token(IDENTIFIER)" {
      shape: parallelogram
      style.fill: "#B1D1FC" # Blue (Data)
    }

    probe -> emit_keyword: "Match Found"
    probe -> emit_identifier: "No Match (Default)"
    probe -> keyword_table: "references" {style.stroke-dash: 5}
  }

  # Connection between phases
  phase_1.lexeme_buffer -> phase_2.probe: "Transfer Lexeme"
}

# Shapes with constant near keys must be at the root level
property_note: |'md
  ### Safety Property
  Lookup operates **only** on the *complete* lexeme, never a prefix. This ensures
  the scanner is greedy (Maximal Munch) before assigning semantics.
'| {
  near: bottom-center
}

trace_examples: "Execution Trace Examples" {
  style.stroke-dash: 2
  near: top-right
  
  trace_1: "'iffy' -> scan produces 'iffy' -> lookup('iffy') -> IDENTIFIER"
  trace_2: "'if' -> scan produces 'if' -> lookup('if') -> KEYWORD"
}