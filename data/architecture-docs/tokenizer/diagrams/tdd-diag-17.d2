direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- Styles ---
classes: {
  logic_gate: {
    shape: diamond
    style: {
      fill: "#f8f9fa"
      stroke: "#212529"
    }
  }
  process_step: {
    shape: rectangle
    style: {
      fill: "#e7f5ff"
      stroke: "#1864ab"
      border-radius: 4
    }
  }
  memory_buffer: {
    shape: cylinder
    style: {
      fill: "#fff4e6"
      stroke: "#d9480f"
    }
  }
  map_lookup: {
    shape: parallelogram
    style: {
      fill: "#f3f0ff"
      stroke: "#5f3dc4"
    }
  }
  token_output: {
    style: {
      fill: "#ebfbee"
      stroke: "#2b8a3e"
      bold: true
    }
  }
}

# --- Identifier Scan Logic ---
identifier_algorithm: {
  label: "Scanner._scan_identifier() Algorithm"
  
  entry: "Trigger: isalpha() or '_'" {class: process_step}
  
  loop: "Greedy Consume Loop\nwhile peek().isalnum() or '_'" {
    class: logic_gate
  }
  
  advance: "advance()" {class: process_step}
  
  slice: "Slice Lexeme\ntext = source[start:current]" {class: process_step}
  
  lookup: "Lookup text in _KEYWORDS" {class: map_lookup}
  
  emit: "Return _make_token(type)" {class: token_output}

  # Connections
  entry -> loop
  loop -> advance: "True (Greedy)"
  advance -> loop: "Next Char"
  loop -> slice: "False (Boundary Found)"
  slice -> lookup
  lookup -> emit
}

# --- Reference Maps ---
data_sources: {
  source_buffer: "source (string)" {class: memory_buffer}
  keywords_map: "_KEYWORDS (HashMap)" {
    shape: sql_table
    "if": TokenType.KEYWORD
    "else": TokenType.KEYWORD
    "while": TokenType.KEYWORD
    "return": TokenType.KEYWORD
    "..." : "..."
  }
}

identifier_algorithm.slice -> data_sources.source_buffer: "O(K) Slice" {style.stroke-dash: 5}
identifier_algorithm.lookup -> data_sources.keywords_map: "O(1) Get" {style.stroke-dash: 5}

# --- Parallel Trace Comparison ---
traces: {
  label: "Execution Traces: Maximal Munch vs Prefix Match"
  
  trace_if: {
    label: "Case 1: 'if '"
    step1: "Scan 'i', 'f'"
    step2: "Peek ' ' (STOP)"
    step3: "text = 'if'"
    step4: "Map.get('if') -> KEYWORD" {style.stroke: "#2b8a3e"}
    
    step1 -> step2 -> step3 -> step4
  }

  trace_iffy: {
    label: "Case 2: 'iffy '"
    step1: "Scan 'i', 'f', 'f', 'y'"
    step2: "Peek ' ' (STOP)"
    step3: "text = 'iffy'"
    step4: "Map.get('iffy') -> IDENTIFIER" {style.stroke: "#1864ab"}
    
    step1 -> step2 -> step3 -> step4
  }
}

# --- Design Invariants ---
annotations: |md
  ### The Critical Rule: Scan First, Lookup Second
  1. **Greedy Scan**: `_scan_identifier` consumes *every* valid character first.
  2. **Atomic Context**: The scanner does not check the keyword map until the boundary is reached.
  3. **Prevention**: This prevents `iffy` from being incorrectly broken into `KEYWORD(if)` + `IDENTIFIER(fy)`.
| {near: top-center}

# Layout constraints for readability
identifier_algorithm.entry -> traces.trace_if: {style.opacity: 0}
identifier_algorithm.entry -> traces.trace_iffy: {style.opacity: 0}