layout-engine: elk
direction: right

vars: {
  d2-config: {
    theme-id: 0
  }
}

# 1. Architecture: Scanner Definition
Scanner: {
  shape: class
  label: "Scanner Object (Reference Holder)"
  _KEYWORDS: "dict* | size: 8B"
  _scan_identifier(): "Token"

  style: {
    stroke: "#6c8ebf"
    fill: "#dae8fc"
    stroke-width: 2
  }
}

# 2. Memory Layout: Heap Representation
MemorySpace: {
  label: "Heap Allocation (Read-Only Data Section)"
  
  HashTable: {
    label: "_KEYWORDS: static hash_table (PyDictObject)"
    shape: sql_table
    
    # Header row styled purple
    "Offset" : "Field Name" {constraint: "Size (Bytes)"}
    
    # PyDict Header
    "0x00" : "ob_refcnt | ob_type" {constraint: "16"}
    "0x10" : "ma_used (count)" {constraint: "8"}
    "0x18" : "ma_version_tag" {constraint: "8"}
    "0x20" : "ma_keys_ptr" {constraint: "8"}
    "0x28" : "ma_values_ptr (NULL)" {constraint: "8"}
    
    # Entries / Buckets
    "0x30" : "Entry[0]: hash | key_ptr | val_ptr" {constraint: "24"}
    "0x48" : "Entry[1]: hash | key_ptr | val_ptr" {constraint: "24"}
    "0x60" : "... Padding / Unused Buckets ..." {constraint: "416"}

    # Coloring based on Role: Header=Purple, Data=Blue, Padding=Gray
    "Offset".style.fill: "#e1d5e7"
    "0x00".style.fill: "#dae8fc"
    "0x10".style.fill: "#dae8fc"
    "0x18".style.fill: "#dae8fc"
    "0x20".style.fill: "#dae8fc"
    "0x28".style.fill: "#dae8fc"
    "0x30".style.fill: "#dae8fc"
    "0x48".style.fill: "#dae8fc"
    "0x60".style.fill: "#f5f5f5"
  }
}

# 64B Cache Line Indicator (intel manual quality)
CacheLineBoundary: "--- 64B Cache Line Boundary (0x40) ---" {
  shape: text
  style.stroke-dash: 5
  style.font-color: gray
}

# Size Annotation (Moved to root to fix compile error)
HT_SIZE: "sizeof=512B (pre-allocated buckets)" {
  shape: text
  style.italic: true
  near: MemorySpace.HashTable
}

# 3. Connection: References (Orange/Dashed)
Scanner._KEYWORDS -> MemorySpace.HashTable: "references (0x7FFF...)" {
  style: {
    stroke: "#ffa500"
    stroke-width: 2
    style.stroke-dash: 3
  }
}

# 4. Logic Flow Diagram
IdentifierResolution: {
  label: "Logic Flow: Identifier vs Keyword"
  
  LexemeInput: "lexeme: 'return'" {
    shape: parallelogram
    style.fill: "#fff2cc"
  }

  Lookup: "val = _KEYWORDS.get(lexeme)" {
    shape: rectangle
    style.stroke-dash: 3
  }

  Result: "TOKEN_RETURN" {
    shape: rectangle
    style.fill: "#d5e8d4" # Success = Green
  }

  Default: "TOKEN_IDENTIFIER" {
    style.fill: "#f5f5f5" # Padding/Gray
  }

  LexemeInput -> Lookup
  Lookup -> Result: "Found (O(1))"
  Lookup -> Default: "Not Found"
}

Scanner -> IdentifierResolution: "dispatch" {
  style.stroke-dash: 5
}

# 5. Global Metadata
Annotation: |md
  ### Internal Memory Characteristics
  - **Type:** `dict[str, TokenType]`
  - **Storage:** Static singleton initialized on module load.
  - **Byte Alignment:** 8-byte boundaries (Standard x64).
  - **Collision Strategy:** Open addressing (Python-native).
| {
  near: top-center
}

# 6. Legend for Engineers (Fixing stroke-dash compile error)
Legend: {
  near: bottom-right
  Header: "Header" { style.fill: "#e1d5e7" }
  Data: "Data" { style.fill: "#dae8fc" }
  Padding: "Padding/Unused" { style.fill: "#f5f5f5" }
  Pointer: "Pointer Reference" { 
    style: {
      stroke: "#ffa500"
      stroke-dash: 3
    }
  }
}