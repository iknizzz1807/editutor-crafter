layout-engine: elk
vars: {
  d2-config: {
    theme-id: 4
  }
}

ScannerContext: {
  label: "Scanner: NORMAL Mode Dispatch"
  style: {
    stroke: "#764ba2"
    stroke-width: 4
    fill: "#f8f9fa"
  }

  SourceStream: "source[current:]" {
    shape: cylinder
    style.fill: "#dae8fc" # Data=Blue
  }

  AmbiguityResolver: {
    shape: sql_table
    style.fill: "#e1d5e7" # Header=Purple
    
    Step1: "1. char = advance()" {
      constraint: "Consumes '/'"
    }
    Step2: "2. _match('/')" {
      constraint: "LA(1) check for Line Comment"
    }
    Step3: "3. _match('*')" {
      constraint: "LA(1) check for Block Comment"
    }
    Step4: "4. Fallthrough" {
      constraint: "Division Operator"
    }
  }

  # Execution Path 1: Line Comment
  PathLineComment: {
    label: "_skip_line_comment()"
    style.fill: "#d5e8d4" # Free=Green
    Lexeme: "// ... [until \n]"
    Output: "return None"
  }

  # Execution Path 2: Block Comment
  PathBlockComment: {
    label: "_skip_block_comment()"
    style.fill: "#d5e8d4" # Free=Green
    Lexeme: "/* ... */"
    Output: "return None | ERROR"
  }

  # Execution Path 3: Division
  PathDivision: {
    label: "_make_token(OPERATOR)"
    style.fill: "#dae8fc" # Data=Blue
    Lexeme: "/"
    Output: "return Token"
  }

  # Transitions
  SourceStream -> AmbiguityResolver.Step1: "char is '/'" {
    style.stroke: "#ff9500" # Pointers=Orange
    style.stroke-width: 2
  }

  AmbiguityResolver.Step2 -> PathLineComment: "MATCH (True)" {
    style: {
      stroke: "#28a745"
      bold: true
    }
  }

  AmbiguityResolver.Step2 -> AmbiguityResolver.Step3: "NO MATCH (False)" {
    style.stroke-dash: 3
  }

  AmbiguityResolver.Step3 -> PathBlockComment: "MATCH (True)" {
    style: {
      stroke: "#28a745"
      bold: true
    }
  }

  AmbiguityResolver.Step3 -> AmbiguityResolver.Step4: "NO MATCH (False)" {
    style.stroke-dash: 3
  }

  AmbiguityResolver.Step4 -> PathDivision: "Default Case" {
    style.stroke: "#007bff"
  }
}

Annotation: |md
  ### Algorithm Logic: Sequential Lookahead
  1. **Primary Consume**: The `/` character is always consumed first by `advance()`.
  2. **LA(1) Priority**:
     - `_match('/')` is checked first. If true, the second `/` is consumed.
     - `_match('*')` is checked only if the first check fails.
  3. **Fallthrough**: If neither sequence matches, the scanner emits a single-character `OPERATOR` token.
  4. **State Reset**: Comments return `None`, causing the main `scan_tokens()` loop to ignore the lexeme and restart in `NORMAL` mode.
| {
  near: bottom-center
  style.font-size: 14
}

# Implementation Details - Fixing path targeting
ScannerContext.PathLineComment.Lexeme.style.font: mono
ScannerContext.PathBlockComment.Lexeme.style.font: mono
ScannerContext.PathDivision.Lexeme.style.font: mono

ScannerContext.style.shadow: true