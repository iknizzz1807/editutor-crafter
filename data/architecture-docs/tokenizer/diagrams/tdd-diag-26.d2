direction: down
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 6
  }
}

# --- STATE DEFINITIONS ---

START: "â— START\n(next_token call)" {
  shape: circle
  style: {
    stroke-width: 4
    fill: "#e1f5fe"
  }
}

IN_OPERATOR: "IN_OPERATOR\n(Maximal Munch)" {
  shape: circle
}

IN_NUMBER_INT: "IN_NUMBER_INT" {
  shape: circle
}

IN_NUMBER_FLOAT: "IN_NUMBER_FLOAT" {
  shape: circle
}

IN_IDENTIFIER: "IN_IDENTIFIER\n(Scan-then-Lookup)" {
  shape: circle
}

IN_STRING: "IN_STRING" {
  shape: circle
}

IN_ESCAPE: "IN_ESCAPE\n(Inside String)" {
  shape: circle
}

IN_LINE_COMMENT: "IN_LINE_COMMENT" {
  shape: circle
}

IN_BLOCK_COMMENT: "IN_BLOCK_COMMENT" {
  shape: circle
}

IN_BLOCK_SAW_STAR: "IN_BLOCK_SAW_STAR" {
  shape: circle
}

ACCEPT: "ACCEPT\n(Return Token)" {
  shape: circle
  style: {
    double-border: true
    fill: "#e8f5e9"
  }
}

ERROR_TERM: "ERROR_TERM\n(Return Error)" {
  shape: circle
  style: {
    fill: "#ffcccc"
    stroke: red
    double-border: true
  }
}

SLASH_BRANCH: "Check /" {
  shape: diamond
}

# --- TRANSITIONS ---

START -> IN_OPERATOR: "[= ! < >] / advance()"
START -> IN_NUMBER_INT: "isdigit() / advance()"
START -> IN_IDENTIFIER: "[a-zA-Z_] / advance()"
START -> IN_STRING: "'\"' / advance()"
START -> SLASH_BRANCH: "'/' / advance()"

# Operator Logic
IN_OPERATOR -> ACCEPT: "_match('=') [true] / emit 2-char"
IN_OPERATOR -> ACCEPT: "_match('=') [false] / emit 1-char"

# Number Logic
IN_NUMBER_INT -> IN_NUMBER_INT: "isdigit() / advance()"
IN_NUMBER_INT -> IN_NUMBER_FLOAT: "'.' && _peek_next().isdigit() / advance()"
IN_NUMBER_INT -> ACCEPT: "else / emit NUMBER"

IN_NUMBER_FLOAT -> IN_NUMBER_FLOAT: "isdigit() / advance()"
IN_NUMBER_FLOAT -> ACCEPT: "else / emit NUMBER"

# Identifier / Keyword Logic
IN_IDENTIFIER -> IN_IDENTIFIER: "isalnum() | '_' / advance()"
IN_IDENTIFIER -> ACCEPT: "else / KEYWORDS.get()"

# String Logic
IN_STRING -> IN_ESCAPE: "'\\' / advance()"
IN_STRING -> ACCEPT: "'\"' / advance(); emit STRING"
IN_STRING -> ERROR_TERM: "[\\n | EOF] / emit ERROR"
IN_STRING -> IN_STRING: "else / advance()"

IN_ESCAPE -> IN_STRING: "is_valid_escape / advance()"
IN_ESCAPE -> ERROR_TERM: "is_invalid_escape / advance()"

# Slash/Comment Branching
SLASH_BRANCH -> IN_LINE_COMMENT: "'/' / advance()"
SLASH_BRANCH -> IN_BLOCK_COMMENT: "'*' / advance()"
SLASH_BRANCH -> ACCEPT: "else / emit SLASH"

# Comment Logic
IN_LINE_COMMENT -> START: "[\\n | EOF] / recurse"
IN_LINE_COMMENT -> IN_LINE_COMMENT: "else / advance()"

IN_BLOCK_COMMENT -> IN_BLOCK_SAW_STAR: "'*' / advance()"
IN_BLOCK_COMMENT -> ERROR_TERM: "EOF / emit ERROR"
IN_BLOCK_COMMENT -> IN_BLOCK_COMMENT: "else / advance()"

IN_BLOCK_SAW_STAR -> START: "'/' / advance(); recurse"
IN_BLOCK_SAW_STAR -> IN_BLOCK_COMMENT: "else / advance()"

# Global Loop - dashed for logic separation
ACCEPT -> START: "scan_tokens loop" {
  style.stroke-dash: 3
}
ERROR_TERM -> START: "recovery / resume" {
  style.stroke-dash: 3
  style.stroke: red
}

# --- ANNOTATIONS ---

# Fixed: Using constant position 'bottom-right' for ELK compatibility
annotation: |md
  ### FSM INVARIANTS
  - **START State:** Not an explicit enum; represents the `next_token()` call frame.
  - **Recursive Recovery:** Transitions to START via `recurse` represent `return self.next_token()`.
  - **Position Capture:** `tok_line` and `tok_col` are snapped at the *entry* to any state from START.
  - **Non-Nesting:** Block comments stop at the first `*/` via the `IN_BLOCK_SAW_STAR` exit.
| {
  near: bottom-right
}