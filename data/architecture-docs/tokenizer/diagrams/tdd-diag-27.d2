layout-engine: elk
vars: {
  d2-config: {
    theme-id: 0
    sketch: false
  }
}

# ---------------------------------------------------------------------------------
# AGENT: TECHNICAL DESIGN ARTIST
# DIAGRAM: next_token() Sequence: Comment Recursion Pattern
# ---------------------------------------------------------------------------------

comment_recursion_flow: {
  shape: sequence_diagram

  # Participants: exact types and methods
  driver: "Scanner\nscan_tokens()" {
    style.fill: "#E1F5FE"
    style.stroke: "#01579B"
  }
  scanner: "Scanner\nnext_token()" {
    style.fill: "#E8EAF6"
    style.stroke: "#1A237E"
  }
  ops: "Scanner\nInternal State" {
    style.fill: "#F3E5F5"
    style.stroke: "#4A148C"
  }

  # --- Sequence Start ---

  driver -> scanner: "next_token()" {
    style.stroke: "#2196F3"
  }
  
  scanner -> ops: "_skip_whitespace()"
  ops -> ops: "advance() [until non-ws]"

  scanner -> ops: "capture_start_pos()"
  ops <- scanner: "(line: 1, col: 1)"

  scanner -> ops: "is_at_end() -> false"
  
  scanner -> ops: "advance() -> char: '/'"
  
  scanner -> ops: "_match('/') -> true"
  scanner."Predictive lookahead identifies //"

  # Delegation to Skip Logic
  scanner -> scanner: "_skip_line_comment()"
  scanner -> ops: "peek() -> != '\\n'"
  scanner -> ops: "advance()"
  scanner."Loop until \\n or EOF"

  # RECURSIVE CALL: The core pattern for comment transparency
  scanner -> scanner: "next_token() [RECURSIVE]" {
    style.stroke: "#2196F3"
    style.stroke-dash: 3
  }
  
  scanner -> ops: "_skip_whitespace()"
  scanner."Consumes the \\n left by comment skip"
  
  scanner -> ops: "capture_start_pos()"
  ops <- scanner: "(line: 2, col: 1)"
  
  scanner -> ops: "advance() -> 'x'"
  
  # Return from Recursion
  scanner <- scanner: "Token(IDENTIFIER, 'x', 2, 1)" {
    style.stroke: "#2196F3"
    style.stroke-dash: 3
  }

  # Return to Driver
  driver <- scanner: "Token(IDENTIFIER, 'x', 2, 1)" {
    style.stroke: "#2196F3"
    style.stroke-dash: 3
  }
}

# --- Annotations & Metadata ---

metadata: {
  # FIX: ELK requires constant values for 'near'
  near: bottom-center
  
  logic_note: |md
    ### Architectural Invariants
    1. **Zero-Token Output**: Comments are semantically transparent; they never appear in the final `list[Token]`.
    2. **Recursion Limit**: The stack depth is strictly $O(C)$ where $C$ is the number of adjacent comment blocks.
    3. **Position Re-synchronization**: The recursive call ensures the `_skip_whitespace()` logic handles the `\n` character following a `//` comment.
    4. **Maximal Munch**: The `_match("/")` ensures `/` (division) is only returned if the character is not followed by another `/` or `*`.
  | {
    style.font-size: 14
    style.fill: "#FFF9C4"
    style.stroke: "#FBC02D"
  }
  
  timing: |md
    **Critical Path Performance:**
    - Single-line Comment: $O(L)$ where $L$ is line length.
    - Overall Complexity: $O(N)$ total source characters.
  | {
    # FIX: ELK requires constant values for 'near'
    near: bottom-right
    style.font-size: 14
    style.fill: "#E8F5E9"
    style.stroke: "#2E7D32"
  }
}

# --- Style Globs ---
(comment_recursion_flow -> **)[*]: {
  style: {
    stroke-width: 2
    font-size: 13
  }
}

comment_recursion_flow.**.style.font-size: 12