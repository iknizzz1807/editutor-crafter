direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# Define Classes for Step States
classes: {
  step_box: {
    style: {
      stroke-width: 2
      border-radius: 5
    }
  }
  changed: {
    style: {
      stroke: red
      stroke-width: 4
      font-color: red
      bold: true
    }
  }
  data_node: {
    style: {
      fill: "#007bff"
      font-color: white
    }
  }
}

APPROACH_A: "APPROACH A: NAIVE CONCATENATION" {
  "1. Initialization": {
    class: step_box
    state: "lexeme = '\"'"
    state.class: data_node
  }

  "2. First Iteration": {
    class: step_box
    op: "lexeme += 'h'"
    state: "**NEW STRING: '\"h'**"
    state.class: [data_node; changed]
    note_label: "Allocates new memory, copies old content" {
      style.font-size: 10
    }
  }

  "3. Nth Iteration (N=1000)": {
    class: step_box
    op: "lexeme += '!'"
    state: "**1000th STRING: '\"...!'**"
    state.class: [data_node; changed]
    note_label: "Must copy 999 existing chars into new buffer" {
      style.font-size: 10
    }
  }

  "Analysis": {
    label: |md
      ### Performance: O(n²)
      - Total Allocations: **n**
      - Total Bytes Copied: **~n²/2**
      - For 1000 chars: **~500,000 bytes copied**
    |
  }

  "1. Initialization" -> "2. First Iteration" -> "3. Nth Iteration (N=1000)" -> "Analysis"
}

APPROACH_B: "APPROACH B: LIST ACCUMULATION" {
  "1. Initialization": {
    class: step_box
    state: "lexeme_chars = ['\"']"
    state.class: data_node
  }

  "2. First Iteration": {
    class: step_box
    op: "lexeme_chars.append('h')"
    state: "lexeme_chars = ['\"', **'h'**]"
    state.class: [data_node; changed]
    note_label: "Appends reference to list (Amortized O(1))" {
      style.font-size: 10
    }
  }

  "3. Nth Iteration (N=1000)": {
    class: step_box
    op: "lexeme_chars.append('!')"
    state: "lexeme_chars = ['\"', ..., **'!'**]"
    state.class: [data_node; changed]
    note_label: "Minimal copies (only when list resizes)" {
      style.font-size: 10
    }
  }

  "4. Finalization": {
    class: step_box
    op: "''.join(lexeme_chars)"
    state: "**RESULT: '\"...!'**"
    state.class: [data_node; changed]
    note_label: "Single O(n) allocation for final string" {
      style.font-size: 10
    }
  }

  "Analysis": {
    label: |md
      ### Performance: O(n)
      - Total Allocations: **1 (List) + 1 (String)**
      - Total Bytes Copied: **~n**
      - For 1000 chars: **~1,000 bytes copied**
    |
  }

  "1. Initialization" -> "2. First Iteration" -> "3. Nth Iteration (N=1000)" -> "4. Finalization" -> "Analysis"
}

Annotation: |md
  ### Architectural Decision Threshold
  - **Identifiers / Numbers (< 20 chars):** `+=` is acceptable due to small constant overhead.
  - **Strings (Unbounded length):** `list + join` is **mandatory** to prevent performance collapse on large literals.
| {
  near: bottom-center
  style: {
    stroke: "#fd7e14"
    fill: "#fff3e0"
    font-size: 14
  }
}