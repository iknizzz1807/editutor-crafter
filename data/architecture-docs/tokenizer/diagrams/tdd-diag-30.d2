direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# 1. Memory Layout: Intel-manual style alignment
TokenStructure: {
  shape: sql_table
  label: "Memory Layout: Token Object (ERROR)"
  tooltip: "sizeof=48 bytes | aligned 8-byte boundaries"
  
  # Offsets | Field Description (Sizes)
  "0x00": "PyObject_HEAD (Metadata) | 16B" {style.fill: "#E1BEE7"} # Header=Purple
  "0x10": "type: TokenType.ERROR | 8B" {style.fill: "#BBDEFB"} # Data=Blue
  "0x18": "lexeme: char* ptr -> '@' | 8B" {style.fill: "#FFE0B2"} # Pointers=Orange
  "0x20": "line: uint64_t | 8B" {style.fill: "#BBDEFB"} # Data=Blue
  "0x28": "column: uint64_t | 8B" {style.fill: "#BBDEFB"} # Data=Blue
  "0x30": "[Padding: Cache Line Alignment] | 16B" {style.fill: "#EEEEEE"; style.stroke-dash: 3} # Padding=Gray
}

# 2. Fault Isolation Logic & Pipeline Sequence
ErrorRecoveryFlow: {
  Source: "Source Buffer: [ 'x', ' ', '@', ' ', 'y', '\\0' ]" {
    shape: rectangle
    style.font: mono
    style.stroke-width: 2
  }

  Scanner: {
    label: "Scanner FSM State"
    style.fill: "#F5F5F5"
    
    CurrentState: {
      shape: sql_table
      label: "Internal State Post-Error"
      "current_ptr": "buffer + 3 (Index of ' ')"
      "line_count": "1"
      "col_count": "4"
      style.fill: "#E8F5E9"
    }
  }

  Pipeline: {
    Call1: "next_token() -> ID('x')"
    Call2: "next_token() -> ERR('@')" {
      style.stroke: red
      style.stroke-width: 3
    }
    Call3: "next_token() -> ID('y')"

    Call1 -> _.Scanner: "Consume 0..1"
    _.Scanner -> Call1: "Success"
    
    Call2 -> _.Scanner: "Consume 2 (INVALID)" {
      style.stroke: red
      style.animated: true
    }
    _.Scanner -> Call2: "RAISE TokenError" {
      style.font-color: red
      style.bold: true
    }

    Call3 -> _.Scanner: "Consume 3..4"
    _.Scanner -> Call3: "Success"
  }

  Output: {
    label: "Resulting Linear Token Stream"
    T1: "IDENTIFIER('x')" {style.fill: "#BBDEFB"}
    T2: "ERROR('@')" {
      style.fill: "#FFCDD2"
      style.stroke: red
      style.double-border: true
    }
    T3: "IDENTIFIER('y')" {style.fill: "#BBDEFB"}
    T4: "EOF" {style.fill: "#C8E6C9"}

    T1 -> T2 -> T3 -> T4: "O(n)"
  }

  Source -> Scanner: "Stream access"
  Scanner -> Output: "Emplace back"
}

# 3. Design Annotation (Fixed near constraint for ELK)
Annotation: |md
  ### Circuit Breaker Pattern â€” Fault Isolation
  - **Isolator**: The `ERROR` token encapsulates the invalid byte without halting the loop.
  - **State Symmetries**: `Scanner.state` after the `@` error is identical in structure to the state after scanning `+`.
  - **Resumption**: The `current` pointer is moved to index 3. The next `next_token()` call starts fresh, ensuring **no corruption** of the subsequent `y` identifier.
  - **Memory Integrity**: Field offsets are fixed at compile time (see TokenStructure); error recovery does not alter struct size.
| {
  near: bottom-center
  style.font-size: 14
}

# Global Styling Compliance
TokenStructure.** {
  style.font: mono
}
ErrorRecoveryFlow.Scanner.CurrentState.** {
  style.font: mono
}
ErrorRecoveryFlow.Pipeline.** {
  style.font: mono
}