layout-engine: elk
vars: {
  d2-config: {
    theme-id: 4
    layout-engine: elk
  }
}

title: |md
  # Performance Benchmark — O(n) Confirmation
  *Validation of Linear Throughput vs Quadratic Bottlenecks*
| {
  near: top-center
  shape: text
}

# 1. Test Data Generation
TestGenerator: "generate_test_program(n)" {
  style.fill: "#DEE1EB"
  
  Patterns: {
    grid-rows: 6
    p0: "0: x{i} = {i};" { tooltip: "Assignment Path" }
    p1: "1: // comment {i}" { tooltip: "Comment Path" }
    p2: "2: label{i} = \"str {i}\";" { tooltip: "String Path" }
    p3: "3: if (x{i} >= {i}) {" { tooltip: "Logic/Op Path" }
    p4: "4: res = res + x{i};" { tooltip: "Arithmetic Path" }
    p5: "5: }" { tooltip: "Scope Path" }
  }
  
  Patterns.p0 -> Patterns.p1 -> Patterns.p2 -> Patterns.p3 -> Patterns.p4 -> Patterns.p5 -> Patterns.p0: "Modulo Rotation"
}

# 2. Scanner Engine Implementation
ScannerEngine: "Scanner.scan_tokens()" {
  style.stroke: "#3f87a6"
  style.stroke-width: 4
  
  Loop: "while !is_at_end()" {
    shape: package
    
    Advance: "advance()" {
      label: "advance(): char"
      tooltip: "O(1) char fetch"
      style.fill: "#C7F1FF"
    }
    
    Dispatch: "_scan_token()" {
      style.fill: "#E4DBFE"
      label: |md
        **State Dispatch**
        O(1) per char
      |
    }
    
    SubScanners: {
      _scan_number
      _scan_string
      _scan_identifier
      style.stroke-dash: 3
    }
    
    Advance -> Dispatch -> SubScanners
  }
}

# 3. Complexity Analysis
Complexity: "Complexity Comparison" {
  
  Correct_On: "O(n) Linear (Chosen)" {
    style.fill: "#ACE1AF"
    logic: |python
      # Single slice at token end
      text = source[start:current]
    |
    analysis: |md
      - **Time:** O(k) per k-length token
      - **Total:** O(n) for n chars
      - **Why:** Python string slicing is highly optimized
    |
  }
  
  Bad_On2: "O(n²) Quadratic (Anti-pattern)" {
    style.fill: "#FE7070"
    style.stroke: red
    logic: |python
      # Concatenation inside loop
      lexeme += char
    |
    analysis: |md
      - **Time:** O(k) per character append
      - **Total:** O(n²) over large tokens
      - **Why:** Every += creates a new heap string
    |
  }
}

# Data Flows
TestGenerator -> ScannerEngine: "10,000 Lines (Input Stream)" {
  style.stroke-width: 4
  style.animated: true
}

ScannerEngine.Loop.SubScanners -> Complexity.Correct_On: "Emit Tokens via Slicing"

# Benchmark Target Annotation
Annotation: |md
  ### Performance Targets
  - **Volume:** 10,000 Lines
  - **Budget:** < 1.0 Second
  - **Actual (Python):** ~200k lines/sec
  - **Limit:** 100ns / character
| {
  near: top-right
  shape: text
}

# Legend/Key
Legend: {
  near: bottom-right
  
  O_1: "O(1) Step" { style.fill: "#C7F1FF" }
  O_N: "O(n) Step" { style.fill: "#E4DBFE" }
  O_N2: "O(n²) Warning" { style.fill: "#FE7070" }
}