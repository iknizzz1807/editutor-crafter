layout-engine: elk
theme-id: 4

# Metadata for Technical Design
metadata: |md
### Token Lifecycle: Character to Structured Data
**Logic:** Finite State Machine Transition (DFA)
**Memory Context:** Stack-allocated pointers, Heap-allocated Tokens
|
metadata.near: top-left

# Global Styles
classes: {
  state_box: {
    style: {
      stroke: "#2C3E50"
      stroke-width: 2
      fill: "#FDFEFE"
      shadow: true
    }
  }
  changed: {
    style: {
      font-color: "#E74C3C"
      bold: true
    }
  }
  header: {
    style: {
      fill: "#8E44AD"
      font-color: "#FFFFFF"
      bold: true
    }
  }
}

lifecycle: {
  # Step 1: Snapshot
  step_1: {
    label: "1. Initialization & Snapshot"
    class: state_box
    
    scanner_state: {
      label: "Scanner State (start_of_token)"
      shape: sql_table
      style.fill: "#EBF5FB"
      start: 0 {class: changed}
      current: 0
      line: 1
      column: 1
      start_column: 1 {class: changed}
    }
    
    source_view: "source: [ i | f | ( | x | ... ]" {
      shape: code
    }
    
    annotation: "anchor points captured"
  }

  # Step 2: Consumption
  step_2: {
    label: "2. advance()"
    class: state_box
    
    scanner_state: {
      label: "Scanner State (post-advance)"
      shape: sql_table
      style.fill: "#EBF5FB"
      start: 0
      current: 2 {class: changed}
      line: 1
      column: 3 {class: changed}
      start_column: 1
    }
    
    returned_chars: "Consumed: 'i', 'f'" {
      style.stroke: "#3498DB"
      style.bold: true
    }
  }

  # Step 3: Dispatch
  step_3: {
    label: "3. Type Dispatch"
    class: state_box
    
    dispatch_logic: {
      shape: parallelogram
      style.fill: "#D5F5E3"
      label: "Lookup 'if' in KEYWORD table"
    }
    
    result_type: "TokenType.KEYWORD" {
      class: changed
      shape: diamond
    }
  }

  # Step 4: Slicing
  step_4: {
    label: "4. _make_token()"
    class: state_box
    
    slicing_op: "source[0:2]" {
      shape: code
    }
    
    lexeme_val: "\"if\"" {
      class: changed
      style.fill: "#D6EAF8"
    }
  }

  # Step 5: Construction
  step_5: {
    label: "5. Return Token"
    class: state_box
    
    final_token: {
      label: "Token Object (sizeof=32B)"
      shape: class
      style.fill: "#D1F2EB"
      type: TokenType.KEYWORD
      lexeme: "\"if\""
      line: 1
      column: 1
    }
  }

  # Transitions
  step_1 -> step_2: "char = advance()"
  step_2 -> step_3: "char.isalpha()"
  step_3 -> step_4: "match found"
  step_4 -> step_5: "constructor"
}

# Source Line Context
source_buffer: {
  grid-rows: 3
  grid-columns: 5
  grid-gap: 0
  
  # Row 1: Characters
  "i"; "f"; "("; "x"; "..."
  # Row 2: Indices
  "0"; "1"; "2"; "3"; "4"
  # Row 3: Pointer Position
  ptr: "^" {
    style.font-color: red
    style.stroke-width: 0
  }
  " "; " "; " "; " "
}
source_buffer.near: top-center

# Field Mapping Annotations
field_map: {
  type_map: "type <- Dispatch Step" {shape: text}
  lex_map: "lexeme <- Slice Step" {shape: text}
  line_map: "line <- Current Scanner.line" {shape: text}
  col_map: "column <- start_column snapshot" {shape: text}
}
field_map.near: bottom-right