vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Positional Encoding Computation
  Step-by-step algorithm state visualization
| {near: top-center}

direction: right

Step_1_Init: "Step 1: Initialize Position Indices" {
  style.fill: "#E8E4F0"
  style.stroke: "#7B68A6"
  style.stroke-width: 2
  
  pos_indices: {
    shape: sql_table
    label: "position tensor [seq_len]"
    style.fill: "#D4C8E8"
    
    idx_0: "0" {style.bold: true; style.font-color: "#C0392B"}
    idx_1: "1" {style.bold: true; style.font-color: "#C0392B"}
    idx_2: "2" {style.bold: true; style.font-color: "#C0392B"}
    idx_3: "..."
    idx_n: "seq_len-1" {style.bold: true; style.font-color: "#C0392B"}
  }
  
  note1: |md
    `pos = torch.arange(seq_len)`
    Shape: `[seq_len]`
  |
}

Step_2_Freq: "Step 2: Compute Frequency Bands" {
  style.fill: "#E3F2FD"
  style.stroke: "#1565C0"
  style.stroke-width: 2
  
  freq_divisor: {
    shape: class
    label: "Frequency Divisor"
    
    formula: "div_term = exp(log(10000) * -2i/d_model)"
    range: "i ∈ [0, d_model/2)"
  }
  
  freq_table: {
    shape: sql_table
    label: "div_term [d_model/2]"
    style.fill: "#BBDEFB"
    
    f_0: "1.0" {style.bold: true; style.font-color: "#C0392B"}
    f_1: "0.0215..." {style.bold: true; style.font-color: "#C0392B"}
    f_2: "0.00046..." {style.bold: true; style.font-color: "#C0392B"}
    f_3: "..."
    f_k: "~10^(-4i/d)" {style.bold: true; style.font-color: "#C0392B"}
  }
  
  note2: |md
    Exponential decay across dimensions
    High freq → Low freq progression
  |
}

Step_3_Outer: "Step 3: Outer Product (Broadcast)" {
  style.fill: "#FFF3E0"
  style.stroke: "#E65100"
  style.stroke-width: 2
  
  angle_grid: {
    shape: sql_table
    label: "angle = pos × div_term"
    style.fill: "#FFE0B2"
    
    col_labels: {
      shape: text
      label: "         div_0    div_1    div_2    ...    div_k"
    }
    
    row_0: "pos 0:  0×f_0    0×f_1    0×f_2    ...    0×f_k" {style.bold: true; style.font-color: "#C0392B"}
    row_1: "pos 1:  1×f_0    1×f_1    1×f_2    ...    1×f_k" {style.bold: true; style.font-color: "#C0392B"}
    row_2: "pos 2:  2×f_0    2×f_1    2×f_2    ...    2×f_k" {style.bold: true; style.font-color: "#C0392B"}
    row_n: "pos n:  n×f_0    n×f_1    n×f_2    ...    n×f_k" {style.bold: true; style.font-color: "#C0392B"}
  }
  
  shape_label: "Shape: [seq_len, d_model/2]"
  
  note3: |md
    `angle = pos.unsqueeze(1) * div_term`
    Each row = one position's angles
  |
}

Step_4_SinCos: "Step 4: Apply sin/cos Alternating" {
  style.fill: "#E8F5E9"
  style.stroke: "#2E7D32"
  style.stroke-width: 2
  
  pe_components: {
    shape: sql_table
    label: "PE components [seq_len, d_model]"
    style.fill: "#C8E6C9"
    
    dim_labels: {
      shape: text
      label: "   dim_0   dim_1   dim_2   dim_3   ...  dim_{n-1}  dim_n"
    }
    
    pos0_row: "p0: sin(a0)  cos(a0)  sin(a1)  cos(a1)  ...  sin(ak)   cos(ak)" {style.bold: true; style.font-color: "#C0392B"}
    pos1_row: "p1: sin(a0)  cos(a0)  sin(a1)  cos(a1)  ...  sin(ak)   cos(ak)" {style.bold: true; style.font-color: "#C0392B"}
    pos2_row: "p2: sin(a0)  cos(a0)  sin(a1)  cos(a1)  ...  sin(ak)   cos(ak)" {style.bold: true; style.font-color: "#C0392B"}
    posn_row: "pn: sin(a0)  cos(a0)  sin(a1)  cos(a1)  ...  sin(ak)   cos(ak)" {style.bold: true; style.font-color: "#C0392B"}
  }
  
  sin_label: "SINE → Even dimensions (0, 2, 4, ...)" {style.fill: "#FFCDD2"}
  cos_label: "COS  → Odd dimensions (1, 3, 5, ...)" {style.fill: "#B3E5FC"}
  
  note4: |md
    
    PE[:, 0::2] = sin(angle)
    PE[:, 1::2] = cos(angle)
    
  |
}

Step_5_Register: "Step 5: Register Buffer" {
  style.fill: "#FCE4EC"
  style.stroke: "#C2185B"
  style.stroke-width: 2
  
  buffer_box: {
    shape: rectangle
    label: "nn.Module state"
    style.fill: "#F8BBD9"
    style.stroke: "#880E4F"
    style.double-border: true
    
    buffer_content: {
      shape: sql_table
      label: "self.register_buffer('pe', PE)"
      style.fill: "#FCE4EC"
      
      attr: "pe: Tensor"
      shape_info: "[1, max_len, d_model]"
      dtype: "float32"
      device: "model.device"
      requires_grad: "False (frozen)"
    }
  }
  
  usage: {
    shape: class
    label: "Forward Usage"
    
    forward: "+x: add positional encoding"
    slice: "+x = x + self.pe[:, :x.size(1)]"
    broadcast: "Broadcasts over batch dimension"
  }
  
  note5: |md
    **Why register_buffer?**
    - Saved with model state_dict
    - Moved to GPU with `.to(device)`
    - NOT a learnable parameter
  |
}

Step_1_Init -> Step_2_Freq: "positions ready" {
  style.stroke: "#7B68A6"
  style.stroke-width: 2
}
Step_2_Freq -> Step_3_Outer: "frequencies ready" {
  style.stroke: "#1565C0"
  style.stroke-width: 2
}
Step_3_Outer -> Step_4_SinCos: "angles ready" {
  style.stroke: "#E65100"
  style.stroke-width: 2
}
Step_4_SinCos -> Step_5_Register: "PE computed" {
  style.stroke: "#2E7D32"
  style.stroke-width: 2
}

legend: {
  near: bottom-right
  style.fill: "transparent"
  
  changed: {
    shape: text
    label: "**Bold Red** = Changed/Computed elements"
    style.font-color: "#C0392B"
  }
  
  header: {
    shape: text
    label: "Purple = Header/Metadata"
    style.font-color: "#7B68A6"
  }
  
  data: {
    shape: text
    label: "Blue = Data buffers"
    style.font-color: "#1565C0"
  }
}

summary: |md
  ### Total Size: O(seq_len × d_model)
  - Memory: 4 bytes × seq_len × d_model
  - Computed **once** at initialization
  - Added to every forward pass: `x + pe[:, :seq_len]`
| {near: top-right}