vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
  colors: {
    header: "#8B5CF6"
    active: "#EF4444"
    candidate: "#3B82F6"
    completed: "#10B981"
    pruned: "#9CA3AF"
    bg: "#1F2937"
    text: "#F9FAFB"
  }
}

title: |md
  # Beam Search Algorithm
  **Step-by-step token expansion with beam_width=2**
| {near: top-center}

Step_1: Step 1 Initialize {
  style.fill: "${colors.header}"
  style.font-color: "${colors.text}"
  style.stroke: transparent
  
  beam: Beam width 2 {
    style.fill: "${colors.bg}"
    
    h1: "<s>" {
      style.fill: "${colors.active}"
      style.bold: true
      style.font-color: "${colors.text}"
    }
    h2: "<s>" {
      style.fill: "${colors.active}"
      style.bold: true
      style.font-color: "${colors.text}"
    }
  }
}

note1: |md
  - Start with BOS token `<s>`
  - log_prob = 0.0
  - No EOS completions yet
| {near: bottom-center}

Step_2: Step 2 Expand Candidates {
  style.fill: "${colors.header}"
  style.font-color: "${colors.text}"
  style.stroke: transparent
  
  expansion: Candidate Expansion {
    style.fill: "${colors.bg}"
    
    from_h1: From BOS {
      c1: The p=-0.2 {
        style.fill: "${colors.candidate}"
        style.font-color: "${colors.text}"
      }
      c2: A p=-0.8 {
        style.fill: "${colors.candidate}"
        style.font-color: "${colors.text}"
      }
      c3: In p=-1.5 {
        style.fill: "${colors.candidate}"
        style.font-color: "${colors.text}"
      }
    }
    
    from_h2: From BOS {
      c4: The p=-0.3 {
        style.fill: "${colors.candidate}"
        style.font-color: "${colors.text}"
      }
      c5: Once p=-1.2 {
        style.fill: "${colors.candidate}"
        style.font-color: "${colors.text}"
      }
    }
  }
}

note2: |md
  - For each hypothesis in beam
  - Get top-k vocab tokens
  - Compute cumulative log_probs
| {near: bottom-center}

Step_3: Step 3 Score and Prune {
  style.fill: "${colors.header}"
  style.font-color: "${colors.text}"
  style.stroke: transparent
  
  scoring: All Candidates Ranked {
    style.fill: "${colors.bg}"
    
    all: ||md
      | Hypothesis | log_prob | Status |
      |------------|----------|--------|
      | BOS The    | -0.2     | KEEP   |
      | BOS The    | -0.3     | KEEP   |
      | BOS A      | -0.8     | PRUNE  |
      | BOS Once   | -1.2     | PRUNE  |
      | BOS In     | -1.5     | PRUNE  |
    ||
  }
  
  pruned: Pruned {
    p1: BOS A {
      style.fill: "${colors.pruned}"
      style.opacity: 0.4
    }
    p2: BOS Once {
      style.fill: "${colors.pruned}"
      style.opacity: 0.4
    }
    p3: BOS In {
      style.fill: "${colors.pruned}"
      style.opacity: 0.4
    }
  }
}

note3: |md
  - Sort all candidates by log_prob
  - Keep top beam_width=2
  - Discard remaining candidates
| {near: bottom-center}

Step_4: Step 4 New Beam {
  style.fill: "${colors.header}"
  style.font-color: "${colors.text}"
  style.stroke: transparent
  
  beam2: Beam After Pruning {
    style.fill: "${colors.bg}"
    
    h1_new: BOS The -0.2 {
      style.fill: "${colors.active}"
      style.bold: true
      style.font-color: "${colors.text}"
    }
    h2_new: BOS The -0.3 {
      style.fill: "${colors.active}"
      style.bold: true
      style.font-color: "${colors.text}"
    }
  }
}

note4: |md
  - Beam now has 2 best hypotheses
  - Both happen to start with The
  - Continue to next expansion
| {near: bottom-center}

Step_5: Step 5 EOS Detection {
  style.fill: "${colors.header}"
  style.font-color: "${colors.text}"
  style.stroke: transparent
  
  eos_check: EOS Handling {
    style.fill: "${colors.bg}"
    
    completed: Completed Sequences {
      seq1: BOS The End EOS -2.1 {
        style.fill: "${colors.completed}"
        style.font-color: "${colors.text}"
        style.bold: true
      }
    }
    
    active_beam: Active Beam {
      a1: BOS The cat -0.8 {
        style.fill: "${colors.active}"
        style.font-color: "${colors.text}"
      }
      a2: BOS The dog -1.1 {
        style.fill: "${colors.active}"
        style.font-color: "${colors.text}"
      }
    }
  }
}

note5: |md
  - If EOS generated move to completions
  - Remove from active beam
  - Track best completed sequence
| {near: bottom-center}

Step_6: Step 6 Termination {
  style.fill: "${colors.header}"
  style.font-color: "${colors.text}"
  style.stroke: transparent
  
  final: Final Output Selection {
    style.fill: "${colors.bg}"
    
    completions: Completed Hypotheses {
      c1: BOS The cat sat EOS -1.5 {
        style.fill: "${colors.completed}"
        style.font-color: "${colors.text}"
        style.bold: true
      }
      c2: BOS The dog ran EOS -2.3 {
        style.fill: "${colors.completed}"
        style.font-color: "${colors.text}"
      }
    }
    
    best: Best Output {
      result: The cat sat {
        style.fill: "${colors.completed}"
        style.bold: true
        style.font-color: "${colors.text}"
        style.stroke: "#059669"
        style.stroke-width: 3
      }
    }
  }
}

note6: |md
  **Termination conditions:**
  - All beams produced EOS, OR
  - max_length reached, OR
  - min_score threshold exceeded
  
  **Return:** highest-scoring completed sequence
| {near: bottom-center}

Flow: {
  style.opacity: 0
  
  Step_1 -> Step_2: expand_top_k
  Step_2 -> Step_3: compute_scores
  Step_3 -> Step_4: prune_to_beam_width
  Step_4 -> Step_5: check_eos
  Step_5 -> Step_6: all_done OR repeat
}

Algorithm: |md
  python
  def beam_search(model, beam_width, max_len):
      beam = [Hypothesis(tokens=[BOS], log_prob=0.0)]
      completed = []
      
      while beam and len(beam[0].tokens) < max_len:
          candidates = []
          for hyp in beam:
              logits = model(hyp.tokens)
              top_k = torch.topk(logits[-1], beam_width)
              for token, prob in zip(top_k.indices, top_k.values):
                  new_hyp = hyp.extend(token, prob)
                  if token == EOS:
                      completed.append(new_hyp)
                  else:
                      candidates.append(new_hyp)
          
          beam = sorted(candidates, key=lambda h: h.log_prob)[:beam_width]
      
      return max(completed + beam, key=lambda h: h.log_prob)
  
| {near: bottom-center}