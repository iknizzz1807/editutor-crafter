vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Beam Search Hypothesis State
  ## Step-by-step hypothesis evolution with beam pruning
| {near: top-center}

classes: {
  hypothesis: {
    style: {
      fill: "#E8F4FD"
      stroke: "#2563EB"
      stroke-width: 2
      border-radius: 4
    }
  }
  active: {
    style: {
      fill: "#DBEAFE"
      stroke: "#1D4ED8"
      stroke-width: 3
      bold: true
    }
  }
  complete: {
    style: {
      fill: "#DCFCE7"
      stroke: "#16A34A"
      stroke-width: 2
    }
  }
  pruned: {
    style: {
      fill: "#FEE2E2"
      stroke: "#DC2626"
      stroke-dash: 3
      opacity: 0.5
    }
  }
  step: {
    style: {
      fill: "#F3F4F6"
      stroke: "#6B7280"
      stroke-width: 2
      border-radius: 8
    }
  }
}

Step_0: "Step 0: Initial State" {
  class: step
  
  Beam: {
    width: 600
    
    h0: {
      class: active
      label: |md
        **h₀** (active)
        `seq: ["<SOS>"]`
        `log_prob: 0.000`
        `is_complete: false`
      |
    }
  }
}

Step_1: "Step 1: Expand to k candidates (k=3)" {
  class: step
  
  Before_pruning: "Before Pruning" {
    width: 800
    
    h0_the: {
      class: hypothesis
      label: |md
        **h₀,ₜ** 
        `seq: ["<SOS>", "the"]`
        `log_prob: -0.693`
        `is_complete: false`
      |
    }
    
    h0_a: {
      class: hypothesis
      label: |md
        **h₀,ₐ**
        `seq: ["<SOS>", "a"]`
        `log_prob: -1.609`
        `is_complete: false`
      |
    }
    
    h0_cat: {
      class: hypothesis
      label: |md
        **h₀,꜀**
        `seq: ["<SOS>", "cat"]`
        `log_prob: -2.303`
        `is_complete: false`
      |
    }
    
    h0_dog: {
      class: pruned
      label: |md
        **h₀,ₑ** (pruned)
        `seq: ["<SOS>", "dog"]`
        `log_prob: -3.912`
        `is_complete: false`
      |
    }
  }
  
  After_pruning: "After Pruning (beam_width=3)" {
    width: 600
    
    h1: {
      class: active
      label: |md
        **h₁** (active)
        `seq: ["<SOS>", "the"]`
        `log_prob: -0.693`
        `is_complete: false`
      |
    }
    
    h2: {
      class: active
      label: |md
        **h₂** (active)
        `seq: ["<SOS>", "a"]`
        `log_prob: -1.609`
        `is_complete: false`
      |
    }
    
    h3: {
      class: active
      label: |md
        **h₃** (active)
        `seq: ["<SOS>", "cat"]`
        `log_prob: -2.303`
        `is_complete: false`
      |
    }
  }
}

Step_2: "Step 2: Expand and detect completion" {
  class: step
  
  Beam_state: {
    width: 800
    
    h1_cat: {
      class: hypothesis
      label: |md
        **h₁,꜀** (best)
        `seq: ["<SOS>", "the", "cat"]`
        `log_prob: -1.386`
        `is_complete: false`
      |
    }
    
    h2_cat: {
      class: complete
      label: |md
        **h₂,꜀** ✓ COMPLETE
        `seq: ["<SOS>", "a", "cat", "<EOS>"]`
        `log_prob: -2.995`
        `is_complete: **true**`
      |
    }
    
    h1_dog: {
      class: hypothesis
      label: |md
        **h₁,ₑ**
        `seq: ["<SOS>", "the", "dog"]`
        `log_prob: -2.079`
        `is_complete: false`
      |
    }
    
    h3_sat: {
      class: pruned
      label: |md
        **h₃,ₛ** (pruned)
        `seq: ["<SOS>", "cat", "sat"]`
        `log_prob: -4.605`
        `is_complete: false`
      |
    }
  }
}

Step_3: "Step 3: Final beam with completed hypotheses" {
  class: step
  
  Final_beam: {
    width: 800
    
    best_complete: {
      class: complete
      label: |md
        **h\*** ← BEST COMPLETE
        `seq: ["<SOS>", "the", "cat", "sat", "<EOS>"]`
        `log_prob: -3.219`
        `is_complete: **true**`
      |
    }
    
    complete_2: {
      class: complete
      label: |md
        **h₂,꜀** ✓ COMPLETE
        `seq: ["<SOS>", "a", "cat", "<EOS>"]`
        `log_prob: -2.995`
        `is_complete: **true**`
      |
    }
    
    active_1: {
      class: hypothesis
      label: |md
        **h₁,꜀,ₛ** (still expanding)
        `seq: ["<SOS>", "the", "cat", "sat"]`
        `log_prob: -3.219`
        `is_complete: false`
      |
    }
  }
}

Data_Structure: "Hypothesis Data Structure" {
  width: 500
  
  Hypothesis: {
    shape: class
    
    "+sequence: List[int]"
        "+log_prob: float"
        "+is_complete: bool"
        "+score: float"
        
        "+__lt__(other): bool"
        "+update(token, log_prob): Hypothesis"
        "+finalize(): Hypothesis"
  }
}

Beam_State: "Beam State at Each Step" {
  width: 500
  
  BeamState: {
    shape: class
    
        "-hypotheses: List[Hypothesis]"
        "-beam_width: int"
        "-completed: List[Hypothesis]"
        
        "+add(hypothesis): void"
        "+prune(): void"
        "+get_active(): List[Hypothesis]"
        "+is_done(): bool"
        "+get_best(): Hypothesis"
  }
}

Algorithm: "Beam Search Step Logic" {
  width: 600
  
  pseudocode: |md
    
    def beam_step(beam, model, beam_width):
        all_candidates = []
        
        for h in beam.get_active():
            if h.is_complete:
                beam.completed.append(h)
                continue
                
            logits = model(h.sequence)
            log_probs = F.log_softmax(logits[-1])
            top_k = torch.topk(log_probs, beam_width)
            
            for token, lp in zip(top_k.indices, top_k.values):
                new_h = h.update(token, lp.item())
                if token == EOS_ID:
                    new_h.is_complete = True
                all_candidates.append(new_h)
        
        # Prune to beam_width best
        all_candidates.sort(reverse=True)
        beam.hypotheses = all_candidates[:beam_width]
        
        return beam
    
  |
}

Step_0 -> Step_1: "expand top-k"
Step_1 -> Step_2: "prune + expand"
Step_2 -> Step_3: "detect <EOS>"

Data_Structure -> Beam_State: "uses"
Beam_State -> Algorithm: "implements"