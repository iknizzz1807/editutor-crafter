vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 200
  }
}

title: |md
  # Beam Search: EOS Completion Handling
  **Step: Move Completed Hypotheses to Output**
| {near: top-center}

direction: right

classes: {
  active_beam: {
    style: {
      fill: "#E3F2FD"
      stroke: "#1976D2"
      stroke-width: 2
    }
  }
  completed: {
    style: {
      fill: "#E8F5E9"
      stroke: "#388E3C"
      stroke-width: 2
    }
  }
  eos_token: {
    style: {
      fill: "#FFCDD2"
      stroke: "#D32F2F"
      stroke-width: 3
      bold: true
    }
  }
  step_box: {
    style: {
      fill: "#FFF8E1"
      stroke: "#F57C00"
      stroke-dash: 4
    }
  }
}

Step_1: "Step 1: Before EOS Detection" {
  class: step_box
  
  Active_Beam_k_5: {
    label: "Active Beam (k=5)"
    class: active_beam
    
    h1: "h1: The cat sat on\nscore: -2.14"
    h2: "h2: The cat sat down\nscore: -2.31"
    h3: "h3: The dog ran fast\nscore: -2.45"
    h4: "h4: A bird flew\nscore: -2.67"
    h5: "h5: The sun is\nscore: -2.89"
  }
  
  Completed: {
    label: "Completed List"
    class: completed
    
    empty: "(empty)"
    empty.style.opacity: 0.4
  }
}

Step_2: "Step 2: Detect EOS Tokens" {
  class: step_box
  
  Active_Beam_with_EOS: {
    label: "Active Beam (k=5)"
    class: active_beam
    
    h1_EOS: "h1: The cat sat on [EOS]\nscore: -2.14" {
      class: eos_token
    }
    h2: "h2: The cat sat down\nscore: -2.31"
    h3_EOS: "h3: The dog ran fast [EOS]\nscore: -2.45" {
      class: eos_token
    }
    h4: "h4: A bird flew\nscore: -2.67"
    h5: "h5: The sun is\nscore: -2.89"
  }
}

EOS_Detection: |md
  **EOS Detection Logic:**
  
  for h in active_beam:
    if h.last_token == EOS_ID:
      move_to_completed(h)
  
|

Step_3: "Step 3: After Moving Completed" {
  class: step_box
  
  Active_Beam_reduced: {
    label: "Active Beam (k'=3)"
    class: active_beam
    
    h2: "h2: The cat sat down\nscore: -2.31"
    h4: "h4: A bird flew\nscore: -2.67"
    h5: "h5: The sun is\nscore: -2.89"
  }
  
  Completed_with_hypotheses: {
    label: "Completed List (2)"
    class: completed
    
    c1: "c1: The cat sat on [EOS]\nscore: -2.14"
    c2: "c2: The dog ran fast [EOS]\nscore: -2.45"
  }
}

Step_4: "Step 4: Refill Beam" {
  class: step_box
  
  Active_Beam_refilled: {
    label: "Active Beam (k=5)"
    class: active_beam
    
    h2: "h2: The cat sat down\nscore: -2.31"
    h2_ext: "h2': The cat sat down the\nscore: -2.58"
    h4: "h4: A bird flew\nscore: -2.67"
    h5: "h5: The sun is\nscore: -2.89"
    h5_ext: "h5': The sun is bright\nscore: -3.12"
  }
  
  Completed_final: {
    label: "Completed List (2)"
    class: completed
    
    c1: "c1: The cat sat on [EOS]\nscore: -2.14"
    c2: "c2: The dog ran fast [EOS]\nscore: -2.45"
  }
}

Step_1 -> Step_2: "Generate next\ntokens"
Step_2 -> Step_3: "Move EOS\nhypotheses"
Step_3 -> Step_4: "Expand\nremaining"

legend: {
  near: bottom-center
  
  Active: "Active Hypothesis" {
    class: active_beam
  }
  Completed_Legend: "Completed ([EOS])" {
    class: completed
  }
  EOS_Legend: "EOS Token Detected" {
    class: eos_token
  }
}

Implementation: |md
  
  def handle_eos_completion(active_beam, completed, beam_size):
      """
      Move hypotheses that emitted EOS to completed list.
      
      Args:
          active_beam: List[(tokens, score)] - current hypotheses
          completed: List[(tokens, score)] - finished sequences
          beam_size: int - k
          
      Returns:
          (new_active, new_completed, done_flag)
      """
      new_active = []
      newly_completed = []
      
      for hypothesis, score in active_beam:
          if hypothesis[-1] == EOS_TOKEN_ID:
              newly_completed.append((hypothesis, score))
          else:
              new_active.append((hypothesis, score))
      
      # Sort completed by score (descending) and add to list
      newly_completed.sort(key=lambda x: x[1], reverse=True)
      completed.extend(newly_completed)
      completed.sort(key=lambda x: x[1], reverse=True)
      
      # Check termination conditions
      done = (len(new_active) == 0) or \
             (len(completed) >= beam_size and 
              completed[beam_size-1][1] >= best_active_score(new_active))
      
      return new_active, completed, done
  
|