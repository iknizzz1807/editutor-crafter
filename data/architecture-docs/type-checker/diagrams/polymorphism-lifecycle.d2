shape: sequence_diagram

classes: {
  type_system: {
    style.fill: "#1a1a2e"
    style.stroke: "#3fb950"
    style.font-color: "#e6edf3"
  }
  generalization: {
    style.stroke: "#e17055"
    style.font-color: "#fdcb6e"
    style.bold: true
  }
  instantiation: {
    style.stroke: "#00b894"
    style.font-color: "#00cec9"
    style.bold: true
  }
}

Parser: Parser {
  class: type_system
}

TypeChecker: Type Checker {
  class: type_system
}

ConstraintSolver: Constraint Solver {
  class: type_system
}

Generalizer: Generalizer {
  class: type_system
}

UseContext: Use Context {
  class: type_system
}

Parser -> TypeChecker: let f = λx. x + 1
TypeChecker -> ConstraintSolver: Generate constraints: α → β, α = Int, β = Int
ConstraintSolver -> TypeChecker: Unified type: Int → Int
TypeChecker -> Generalizer: Type ready for generalization
Generalizer -> Generalizer: Identify free type variables
Generalizer -> TypeChecker: Generalized type: ∀α. α → α (polymorphic)
TypeChecker -> TypeChecker: Bind f : ∀α. α → α in environment

UseContext -> TypeChecker: Request f applied to String
TypeChecker -> TypeChecker: Instantiate ∀α. α → α
TypeChecker -> TypeChecker: Create fresh type variables: β → β
TypeChecker -> ConstraintSolver: Unify β with String
ConstraintSolver -> TypeChecker: Instantiated type: String → String
TypeChecker -> UseContext: f : String → String

UseContext -> TypeChecker: Request f applied to Int
TypeChecker -> TypeChecker: Instantiate ∀α. α → α again
TypeChecker -> TypeChecker: Create fresh type variables: γ → γ
TypeChecker -> ConstraintSolver: Unify γ with Int
ConstraintSolver -> TypeChecker: Instantiated type: Int → Int
TypeChecker -> UseContext: f : Int → Int