{
  "types": {
    "ty": "TInt | TBool | TString | TVar of string | TFun of ty * ty | TForall of string list * ty",
    "TypeEnv.t": "(string * ty) list list",
    "var_id": "int",
    "type_scheme": "Forall of string list * ty",
    "substitution": "fields: (string * ty) list",
    "constraint_t": "fields: ty * ty",
    "check_result": "Success of ty | Error of type_error list",
    "type_error": "fields: error_kind, source_location, expected_type ty option, actual_type ty option, message string, suggestions string list",
    "error_kind": "TypeMismatch | UnboundVariable of string | WrongArity of int * int | NonFunctionCall | InvalidOperation of string",
    "source_location": "fields: file string, line int, column int, end_line int, end_column int",
    "binding": "Monomorphic of ty | Polymorphic of type_scheme",
    "env": "fields: (string * binding) list list",
    "pipeline_result": "fields: typed_ast, errors, warnings",
    "debug_level": "Silent | Errors | Warnings | Info | Debug | Trace",
    "debug_context": "fields: current_expression string, environment_size int, constraint_count int, active_variables string list",
    "TConstructor": "TConstructor of string * ty list",
    "TSum": "TSum of (string * ty list) list",
    "TRecord": "TRecord of (string * ty) list",
    "constraint_": "string * ty",
    "qualified_type": "constraint_ list * ty",
    "TQualified": "TQualified of qualified_type",
    "TRow": "TRow of (string * ty) list * ty option",
    "field_constraint": "ty * string * ty * ty",
    "effect_type": "Pure | IO | State | Exception variants",
    "effect_set": "effect_type list",
    "TEffect": "TEffect of ty * effect_set",
    "kind": "Star | KindArrow of kind * kind",
    "TKinded": "TKinded of ty * kind",
    "kind_env": "(string * kind) list",
    "predicate": "Expression tree for type constraints",
    "TRefined": "TRefined of ty * predicate",
    "TDependent": "TDependent of string * ty * ty",
    "module_path": "string list",
    "TModulePath": "TModulePath of module_path * string",
    "signature_item": "Algebraic type for interface declarations",
    "module_signature": "signature_item list",
    "extended_ty": "Extended type representation supporting multiple features",
    "unified_constraint": "Extended constraint system supporting all extensions",
    "extended_env": "Extended environment supporting modules and type classes",
    "term_category": "CoreType | Algorithm | ErrorHandling | Polymorphism | Advanced",
    "term_definition": "fields: name string, category term_category, definition string, practical_context string, related_terms string list, code_references string list"
  },
  "methods": {
    "type_equal(t1: ty, t2: ty): bool": "structural type equality check",
    "occurs_check(var_name: string, ty: ty): bool": "prevents infinite types in unification",
    "TypeEnv.extend(name: string, ty: ty, env: t): t": "adds binding to innermost scope",
    "TypeEnv.lookup(name: string, env: t): ty option": "searches scopes inside-out",
    "fresh_type_var(): ty": "generates unique type variable",
    "string_of_type(ty): string": "pretty prints types for debugging",
    "apply_subst_to_type(subst, ty): ty": "applies substitution to type",
    "compose_subst(s1, s2): substitution": "composes two substitutions",
    "unify(t1, t2): substitution": "finds most general unifier",
    "generate_constraints(expr, env): ty * constraint_t list": "collects type constraints from expressions",
    "type_equal(t1, t2)": "structural type equality check",
    "TypeEnv.extend(name, ty, env)": "adds binding to innermost scope",
    "TypeEnv.lookup(name, env)": "searches scopes inside-out",
    "fresh_type_var()": "generates unique type variable",
    "string_of_type(ty)": "pretty prints types",
    "apply_subst_to_type(subst, ty)": "applies substitution to type",
    "compose_subst(s1, s2)": "composes two substitutions",
    "unify(t1, t2)": "finds most general unifier",
    "generate_constraints(expr, env)": "collects type constraints from expressions",
    "occurs_check(var_name, ty)": "prevents infinite types during unification",
    "synthesize_expression_type(expr, env): check_result": "determines type produced by expression",
    "check_expression_type(expr, expected, env): check_result": "verifies expression against expected type",
    "check_statement(stmt, env): TypeEnv.t * type_error list": "verifies statement and returns updated environment",
    "make_error(kind, loc, expected, actual, msg, suggestions): type_error": "constructs formatted error",
    "format_error(err): string": "pretty prints error message",
    "recover_from_error(err_kind, expected): ty": "provides placeholder type for error recovery",
    "generate_suggestions(err_kind, env): string list": "suggests fixes for common errors",
    "unify(constraints)": "finds most general unifier for constraint list",
    "unify_one(constraint, subst)": "unifies single constraint",
    "infer_expression(expr, env)": "performs type inference on expression",
    "infer_statement(stmt, env)": "performs type inference on statement",
    "make_type_scheme(quantified_vars, body_type)": "constructs type scheme with quantified variables",
    "scheme_to_string(scheme)": "pretty prints type scheme with forall notation",
    "free_vars_in_scheme(scheme)": "returns variables free in scheme body but not quantified",
    "scheme_contains_var(scheme, var_name)": "checks if variable appears free in scheme",
    "fresh_var_name()": "generates unique variable name string",
    "extend_poly(name, scheme, env)": "adds polymorphic binding to environment",
    "extend_mono(name, ty, env)": "adds monomorphic binding to environment",
    "lookup(name, env)": "searches for variable binding in environment",
    "free_vars_in_env(env)": "collects all free variables in environment",
    "can_generalize(expr)": "checks value restriction for generalization",
    "generalize_type(inferred_type, env, expr)": "generalizes type over free variables",
    "instantiate_scheme(scheme)": "replaces quantified vars with fresh variables",
    "instantiate_binding(binding)": "instantiates monomorphic or polymorphic binding",
    "extend_mono(name, ty, env) returns env": "adds monomorphic binding to innermost scope",
    "extend_poly(name, scheme, env) returns env": "adds polymorphic binding to innermost scope",
    "lookup(name, env) returns binding option": "searches scopes inside-out for variable binding",
    "synthesize_expression_type(expr, env) returns check_result": "determines type produced by expression",
    "check_expression_type(expr, expected, env) returns check_result": "verifies expression against expected type",
    "solve_constraints(constraints) returns result": "finds most general unifier for constraint list",
    "unify_one(constraint, subst) returns result": "unifies single constraint with existing substitution",
    "apply_substitution_to_ast(subst, ast) returns ast": "applies substitution to all type annotations in AST",
    "fresh_scope(env) returns env": "creates new scope layer for binding constructs",
    "instantiate_binding(binding) returns ty": "instantiates monomorphic or polymorphic binding with fresh variables",
    "safe_unify_var(var_name, target_type)": "unifies variable with occurs check",
    "combine_results(r1, r2, f)": "combines two check results",
    "debug_trace(level, context, message)": "conditional debug output with context",
    "trace_constraint_generation(expr, constraints)": "traces constraint generation process",
    "inspect_environment(env)": "examines environment structure for debugging",
    "trace_variable_lookup(name, env)": "traces variable lookup through scopes",
    "validate_inference_result(expr, expected, inferred)": "validates inference quality",
    "solve_unified_constraints(constraints)": "unified constraint solver handling all constraint types",
    "lookup_term(name) returns term_definition option": "searches term database for definition",
    "add_term(name, category, definition, context, related, refs)": "adds new term to glossary database",
    "terms_by_category(category) returns term_definition list": "filters terms by category",
    "find_related_terms(name) returns term_definition list": "finds all related term definitions",
    "validate_terminology_consistency(files) returns (string * string list) list": "checks code against glossary",
    "generate_cross_reference_map() returns (string * string list) list": "builds term relationship graph",
    "format_term_for_documentation(term) returns string": "pretty prints term definition",
    "check_definition_completeness(required) returns string list": "finds missing required terms",
    "type_equal(t1, t2) returns bool": "structural type equality check",
    "fresh_type_var() returns ty": "generates unique type variable",
    "unify(t1, t2) returns substitution": "finds most general unifier",
    "occurs_check(var_name, ty) returns bool": "prevents infinite types",
    "generalize_type(inferred, env, expr)": "generalizes type over free variables",
    "instantiate_scheme(scheme) returns ty": "replaces quantified vars with fresh variables"
  },
  "constants": {
    "TInt": "integer primitive type",
    "TBool": "boolean primitive type",
    "TString": "string primitive type",
    "empty_subst": "empty substitution list for constraint solving",
    "Success": "successful type checking result",
    "Error": "failed type checking result",
    "TypeMismatch": "types don't match error",
    "UnboundVariable": "variable not in scope error",
    "WrongArity": "function arity mismatch error",
    "NonFunctionCall": "calling non-function error",
    "TVar": "type variable constructor",
    "TFun": "function type constructor",
    "TForall": "polymorphic type constructor",
    "Forall": "type scheme constructor with quantified variables",
    "Monomorphic": "monomorphic binding constructor",
    "Polymorphic": "polymorphic binding constructor",
    "InvalidOperation": "invalid operation error",
    "Silent": "no debug output",
    "Trace": "maximum debug verbosity"
  },
  "terms": {
    "constraint generation": "collecting type equality requirements from expressions",
    "unification": "finding substitutions to satisfy type constraints",
    "let-polymorphism": "generalizing types at let-bindings with quantified variables",
    "occurs check": "preventing infinite types during unification",
    "type environment": "symbol table mapping variables to types",
    "type scheme": "polymorphic type with quantified variables using forall",
    "substitution": "mapping from type variables to concrete types",
    "generalization": "abstracting over free type variables at binding sites",
    "instantiation": "replacing quantified variables with fresh type variables",
    "structural equality": "types equal if they have same structure",
    "fresh variable": "newly generated unique type variable",
    "type variable": "placeholder for unknown type determined by inference",
    "expression synthesis": "determining what type an expression produces",
    "expression checking": "verifying expression against expected type",
    "statement checking": "verifying statement type constraints",
    "type compatibility": "whether one type can be used where another is expected",
    "error recovery": "continuing analysis after encountering type errors",
    "source location tracking": "maintaining position information for error reporting",
    "context-aware errors": "error messages that explain why types are incompatible",
    "cascading errors": "spurious errors caused by previous errors",
    "lexical scoping": "variables visible only in their declared scope and nested scopes",
    "environment threading": "passing updated type environments through recursive checking calls",
    "Robinson unification": "standard unification algorithm with occurs check",
    "substitution composition": "combining two substitutions into equivalent single substitution",
    "constraint decomposition": "breaking complex constraints into simpler unifiable pieces",
    "fresh variable generation": "creating unique type variables for unknowns",
    "variable capture": "incorrectly substituting bound variables in polymorphic types",
    "value restriction": "limiting generalization to syntactic values",
    "quantified variables": "type variables bound by forall",
    "free variables": "type variables not bound by quantification",
    "polymorphic recursion": "recursive function calling itself at different types",
    "template instantiation": "creating concrete types from polymorphic templates",
    "context-sensitive abstraction": "generalizing based on environment context",
    "pipeline orchestration": "coordinating type checking phases with proper error handling",
    "type error recovery": "continuing analysis after encountering type violations",
    "infinite type detection": "preventing infinite type expressions during unification",
    "constraint solving failures": "when type constraints cannot be satisfied",
    "graceful degradation": "making reasonable assumptions to continue checking after errors",
    "error suppression logic": "preventing cascading error reports",
    "context preservation": "maintaining type environment context through error recovery",
    "milestone verification": "checkpoint testing ensuring solid foundations",
    "systematic coverage": "testing across multiple orthogonal dimensions",
    "regression testing": "verifying previous functionality still works after changes",
    "most general type verification": "ensuring inference produces optimal polymorphic types",
    "error recovery testing": "verifying graceful handling of invalid programs",
    "algebraic data types": "structured data blueprints with multiple construction patterns",
    "type classes": "structured polymorphism with constraints",
    "row types": "flexible record structures with compile-time safety",
    "effect systems": "compile-time tracking of computational side effects",
    "higher-kinded types": "abstraction over type constructors",
    "dependent types": "types that depend on runtime values",
    "module systems": "large-scale code organization with controlled visibility",
    "incremental type checking": "fast development cycles through selective recomputation",
    "exhaustiveness checking": "verifying all possible constructors are handled in match expressions",
    "instance resolution": "finding applicable instances for type class constraints",
    "SMT solver integration": "automated theorem proving for constraint verification",
    "kind inference": "inferring kinds alongside type inference",
    "type": "classification of values determining valid operations",
    "type system": "set of rules assigning types and verifying correctness",
    "type inference": "automatically determining types without annotations",
    "polymorphism": "ability for code to work with multiple types",
    "constraint": "equality requirement between types",
    "most general unifier": "least restrictive substitution satisfying constraints",
    "type checking": "verifying explicitly annotated types are consistent"
  }
}