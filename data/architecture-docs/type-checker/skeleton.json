{
  "title": "Type Checker: Design Document",
  "overview": "This system implements a type checker for a statically typed language that performs type inference, validation, and error reporting. The key architectural challenge is building a constraint-based type inference engine that can unify type constraints while supporting polymorphism through let-generalization.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Introduces type checking as a compile-time verification system and explains why building one requires sophisticated algorithms for inference and unification.",
      "subsections": [
        {
          "id": "type-checking-analogy",
          "title": "Type Checking as Contract Verification",
          "summary": "Mental model comparing type checking to contract verification in legal systems"
        },
        {
          "id": "existing-approaches",
          "title": "Existing Type System Approaches",
          "summary": "Comparison of simple type checking, Hindley-Milner inference, and gradual typing approaches"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what our type checker will accomplish and explicitly excludes advanced features like dependent types or effect systems.",
      "subsections": []
    },
    {
      "id": "architecture-overview",
      "title": "High-Level Architecture",
      "summary": "Component overview showing the pipeline from AST to type-checked program with error reporting.",
      "subsections": [
        {
          "id": "component-responsibilities",
          "title": "Component Responsibilities",
          "summary": "Breakdown of type representation, environment, inference engine, and error reporter roles"
        },
        {
          "id": "file-structure",
          "title": "Recommended File Structure",
          "summary": "Module organization for clean separation of type representation, inference, and checking logic"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model and Type Representations",
      "summary": "Defines the core data structures for representing types, type schemes, constraints, and environments.",
      "subsections": [
        {
          "id": "type-ast",
          "title": "Type AST Structure",
          "summary": "Algebraic data types for primitives, functions, variables, and generic types"
        },
        {
          "id": "type-environment",
          "title": "Type Environment and Scoping",
          "summary": "Symbol table implementation with lexical scoping support"
        },
        {
          "id": "constraints-substitutions",
          "title": "Constraints and Substitutions",
          "summary": "Data structures for constraint generation and unification algorithm"
        }
      ]
    },
    {
      "id": "type-representation",
      "title": "Type Representation System",
      "summary": "Implements the foundational type system with primitive types, function types, and type variables.",
      "subsections": [
        {
          "id": "type-equality",
          "title": "Type Equality and Compatibility",
          "summary": "Structural vs nominal typing decisions and subtyping rules"
        },
        {
          "id": "type-variables",
          "title": "Type Variable Management",
          "summary": "Fresh variable generation and occurs check implementation"
        }
      ]
    },
    {
      "id": "basic-type-checking",
      "title": "Basic Type Checking Engine",
      "summary": "Core type checking for expressions, statements, and function calls without inference.",
      "subsections": [
        {
          "id": "expression-typing",
          "title": "Expression Type Rules",
          "summary": "Type rules for literals, operators, function calls, and variable references"
        },
        {
          "id": "statement-typing",
          "title": "Statement Type Checking",
          "summary": "Type checking for assignments, declarations, and control flow constructs"
        },
        {
          "id": "error-reporting",
          "title": "Type Error Reporting",
          "summary": "Clear error messages with source locations and suggested fixes"
        }
      ]
    },
    {
      "id": "type-inference",
      "title": "Type Inference Engine",
      "summary": "Constraint-based type inference using unification to deduce types where not explicitly annotated.",
      "subsections": [
        {
          "id": "constraint-generation",
          "title": "Constraint Generation",
          "summary": "Algorithm for collecting type equality constraints from expressions and statements"
        },
        {
          "id": "unification-algorithm",
          "title": "Unification Algorithm",
          "summary": "Robinson unification with occurs check and substitution composition"
        },
        {
          "id": "substitution-application",
          "title": "Substitution Application",
          "summary": "Applying solved constraints to replace type variables with concrete types"
        }
      ]
    },
    {
      "id": "polymorphism",
      "title": "Polymorphic Type System",
      "summary": "Let-polymorphism implementation with type schemes, generalization, and instantiation.",
      "subsections": [
        {
          "id": "type-schemes",
          "title": "Type Schemes and Quantification",
          "summary": "Forall quantification representation and type scheme manipulation"
        },
        {
          "id": "generalization",
          "title": "Type Generalization",
          "summary": "Let-polymorphism generalization algorithm with value restriction"
        },
        {
          "id": "instantiation",
          "title": "Type Instantiation",
          "summary": "Instantiating polymorphic types at use sites with fresh type variables"
        }
      ]
    },
    {
      "id": "interactions-dataflow",
      "title": "Component Interactions and Data Flow",
      "summary": "How the type checker components communicate and the overall pipeline from parsing to type-checked AST.",
      "subsections": [
        {
          "id": "checking-pipeline",
          "title": "Type Checking Pipeline",
          "summary": "Step-by-step flow from AST input to typed output with error handling"
        },
        {
          "id": "environment-threading",
          "title": "Environment Threading",
          "summary": "How type environments flow through recursive checking calls"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Comprehensive error handling for type mismatches, infinite types, and constraint solving failures.",
      "subsections": [
        {
          "id": "type-error-recovery",
          "title": "Type Error Recovery",
          "summary": "Continuing type checking after errors to find multiple issues"
        },
        {
          "id": "infinite-types",
          "title": "Infinite Type Detection",
          "summary": "Occurs check implementation to prevent infinite types during unification"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy and Milestones",
      "summary": "Testing approach for each milestone with specific acceptance criteria and checkpoint verification.",
      "subsections": [
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Verification",
          "summary": "What to test and verify after completing each milestone"
        },
        {
          "id": "test-case-categories",
          "title": "Test Case Categories",
          "summary": "Systematic testing of type rules, inference, errors, and polymorphism"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common issues encountered when implementing type checkers with symptom-cause-fix analysis.",
      "subsections": [
        {
          "id": "unification-debugging",
          "title": "Unification Algorithm Debugging",
          "summary": "Tracing constraint solving and identifying where unification fails"
        },
        {
          "id": "environment-debugging",
          "title": "Type Environment Issues",
          "summary": "Debugging scoping problems and variable lookup failures"
        },
        {
          "id": "inference-debugging",
          "title": "Type Inference Problems",
          "summary": "Understanding why inference produces unexpected types or fails"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements like algebraic data types, type classes, or advanced inference features.",
      "subsections": []
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of type theory terms, algorithm names, and domain-specific vocabulary used throughout.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "Type Checker System Architecture",
      "description": "Shows the main components (Type Representation, Environment, Inference Engine, Error Reporter) and their relationships with data flow between them",
      "type": "component",
      "relevant_sections": [
        "architecture-overview",
        "interactions-dataflow"
      ]
    },
    {
      "id": "type-ast-structure",
      "title": "Type AST Structure",
      "description": "Class diagram showing the algebraic data type hierarchy for representing types including primitives, functions, type variables, and polymorphic types",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "type-representation"
      ]
    },
    {
      "id": "type-checking-pipeline",
      "title": "Type Checking Pipeline Flow",
      "description": "Flowchart showing the complete pipeline from input AST through constraint generation, unification, and error reporting to final typed AST",
      "type": "flowchart",
      "relevant_sections": [
        "interactions-dataflow",
        "basic-type-checking",
        "type-inference"
      ]
    },
    {
      "id": "unification-algorithm",
      "title": "Unification Algorithm Process",
      "description": "Flowchart detailing the unification algorithm steps including occurs check, variable binding, and constraint decomposition",
      "type": "flowchart",
      "relevant_sections": [
        "type-inference"
      ]
    },
    {
      "id": "constraint-solving-sequence",
      "title": "Constraint Solving Sequence",
      "description": "Sequence diagram showing the interaction between constraint generation, unification, and substitution application components during type inference",
      "type": "sequence",
      "relevant_sections": [
        "type-inference",
        "interactions-dataflow"
      ]
    },
    {
      "id": "type-environment-scoping",
      "title": "Type Environment Scoping",
      "description": "State machine showing how type environments are extended and restored during nested scope traversal",
      "type": "state-machine",
      "relevant_sections": [
        "data-model",
        "basic-type-checking"
      ]
    },
    {
      "id": "polymorphism-lifecycle",
      "title": "Polymorphic Type Lifecycle",
      "description": "Sequence diagram illustrating generalization at let-bindings and instantiation at use sites for polymorphic types",
      "type": "sequence",
      "relevant_sections": [
        "polymorphism"
      ]
    },
    {
      "id": "error-handling-flow",
      "title": "Error Handling and Recovery Flow",
      "description": "Flowchart showing how type errors are detected, reported, and how the system continues checking to find additional errors",
      "type": "flowchart",
      "relevant_sections": [
        "error-handling",
        "basic-type-checking"
      ]
    }
  ]
}