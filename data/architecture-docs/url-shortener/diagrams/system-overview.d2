vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 3
  }
}

direction: down

# ─────────────────────────────────────────────────────────────────────────────
# ROW 1: SHARED PACKAGES + INFRASTRUCTURE
# ─────────────────────────────────────────────────────────────────────────────
row1: "" {
  direction: right
  style.stroke: transparent
  style.fill: transparent

  layer_shared: {
    direction: down
    label: "SHARED PACKAGES"
    style.fill: "#EEF2FF"
    style.stroke: "#6366F1"
    events_pkg: {
      shape: class
      label: "shared/events/events.go  [M1]"
      EventTypeURLCreated: "= \"url.created\""
      EventTypeURLClicked: "= \"url.clicked\""
      EventTypeURLDeleted: "= \"url.deleted\""
      EventTypeMilestoneReached: "= \"milestone.reached\""
      +GetEventType(): "string"
      +GetOccurredAt(): "time.Time"
    }
    url_created_event: {
      shape: sql_table
      label: "struct URLCreatedEvent  [M1]"
      EventType:     "string     | routing key"
      OccurredAt:    "time.Time  | RFC3339Nano"
      CorrelationID: "string     | UUID v4"
      ShortCode:     "string     | 7-char base62"
      OriginalURL:   "string     | destination URL"
      UserID:        "string     | UUID owner"
      UserEmail:     "string     | avoids callback"
      ExpiresAt:     "*time.Time | nil=no expiry"
      sz:            "Total: ~96 bytes"
    }
    url_clicked_event: {
      shape: sql_table
      label: "struct URLClickedEvent  [M1]"
      EventType:     "string     | routing key"
      OccurredAt:    "time.Time  | RFC3339Nano"
      CorrelationID: "string     | UUID v4"
      EventID:       "string     | dedup key"
      ShortCode:     "string     | 7-char base62"
      UserID:        "string     | URL owner"
      IPHash:        "string     | SHA-256 hex"
      UserAgent:     "string     | browser string"
      Referer:       "string     | optional"
      sz:            "Total: ~120 bytes"
    }
    url_deleted_event: {
      shape: sql_table
      label: "struct URLDeletedEvent  [M1]"
      EventType:     "string    | url.deleted"
      OccurredAt:    "time.Time | RFC3339Nano"
      CorrelationID: "string    | UUID v4"
      ShortCode:     "string    | 7-char base62"
      UserID:        "string    | UUID owner"
      UserEmail:     "string    | avoids callback"
      sz:            "Total: ~80 bytes"
    }
    milestone_event: {
      shape: sql_table
      label: "struct MilestoneReachedEvent  [M1]"
      EventType:     "string    | milestone.reached"
      OccurredAt:    "time.Time | RFC3339Nano"
      CorrelationID: "string    | UUID v4"
      ShortCode:     "string    | 7-char base62"
      UserID:        "string    | UUID owner"
      UserEmail:     "string    | avoids callback"
      Milestone:     "int       | 10 | 100 | 1000"
      TotalClicks:   "int64     | count at trigger"
      sz:            "Total: ~96 bytes"
    }
    logger_pkg: {
      shape: class
      label: "shared/logger/logger.go  [M1+M5]"
      -service: "string"
      -correlationID: "string"
      +New(serviceName, w): "zerolog.Logger"
      +WithCorrelationID(log, id): "zerolog.Logger"
      +RequestLogger(log): "func(Handler) Handler"
    }
    shared_auth_pkg: {
      shape: class
      label: "shared/auth/types.go  [M2]"
      ErrTokenExpired: "= errors.New(\"token expired\")"
      ErrTokenInvalid: "= errors.New(\"token invalid\")"
      +NewJWTSigner(secret): "JWTSigner"
      +NewJWTVerifier(secret): "JWTVerifier"
      +Sign(claims): "(string, error)"
      +Verify(tokenString): "(Claims, error)"
    }
    claims_struct: {
      shape: sql_table
      label: "struct Claims  shared/auth  [M2]"
      Sub:   "string     | user UUID"
      Email: "string     | user email"
      Iat:   "time.Time  | issued at"
      Exp:   "time.Time  | iat + 24h"
      Iss:   "string     | url-shortener"
      sz:    "Total: ~64 bytes"
    }
    jwt_middleware_pkg: {
      shape: class
      label: "shared/middleware/jwt_middleware.go  [M2]"
      ClaimsContextKey: "contextKey = \"jwt_claims\""
      +RequireAuth(verifier, log): "func(Handler) Handler"
      +ClaimsFromContext(ctx): "(Claims, bool)"
    }
    log_fields_struct: {
      shape: sql_table
      label: "struct LogFields  shared/logger  [M1]"
      Level:         "string | debug/info/warn/error"
      Time:          "int64  | Unix ms"
      Service:       "string | service name"
      CorrelationID: "string | UUID or empty"
      Method:        "string | HTTP method"
      Path:          "string | HTTP path"
      Status:        "int    | HTTP status code"
      DurationMS:    "int64  | handler latency"
      Msg:           "string | human message"
      sz:            "Total: ~120 bytes"
    }
    events_pkg -> url_created_event: "implements"
    events_pkg -> url_clicked_event: "implements"
    events_pkg -> url_deleted_event: "implements"
    events_pkg -> milestone_event: "implements"
    shared_auth_pkg -> claims_struct: "issues Claims"
    jwt_middleware_pkg -> shared_auth_pkg: "uses JWTVerifier"
  }

  layer_infra: {
    direction: down
    label: "INFRASTRUCTURE LAYER"
    style.fill: "#F0FDF4"
    style.stroke: "#16A34A"
    docker_compose: {
      shape: sql_table
      label: "docker-compose.yml  [M1]"
      url_db:             "postgres:16-alpine   | :5432"
      analytics_db:       "postgres:16-alpine   | :5433"
      user_db:            "postgres:16-alpine   | :5434"
      notification_db:    "postgres:16-alpine   | :5435"
      rabbitmq:           "rabbitmq:3.13-mgmt   | :5672/:15672"
      redis:              "redis:7-alpine       | :6379"
      url_service:        "built Dockerfile     | :8081"
      analytics_service:  "built Dockerfile     | :8082"
      user_service:       "built Dockerfile     | :8083"
      notification_svc:   "built Dockerfile     | :8084"
      gateway:            "built Dockerfile     | :8080"
      total:              "11 containers total"
    }
    rabbitmq_topology: {
      shape: sql_table
      label: "RabbitMQ Topology  [M1]"
      exchange:           "url-shortener | topic | durable"
      q_analytics:        "analytics.clicks | bound: url.clicked"
      q_notifications:    "notifications.events | bound: url.created"
      q_notif2:           "notifications.events | bound: url.deleted"
      q_notif3:           "notifications.events | bound: milestone.reached"
      prefetch:           "Qos(1,0,false) per consumer"
    }
    connect_db: {
      shape: class
      label: "ConnectDB  main.go each svc  [M1]"
      MaxConns: "= 10"
      MinConns: "= 2"
      MaxConnLifetime: "= 30 * time.Minute"
      MaxConnIdleTime: "= 5 * time.Minute"
      HealthCheckPeriod: "= 1 * time.Minute"
      +ConnectDB(ctx, dsn): "(*pgxpool.Pool, error)"
      +ConnectRedis(ctx, addr): "(*redis.Client, error)"
      +ConnectRabbitMQ(ctx, url, declFn): "(Conn, Chan, error)"
      -mustGetEnv(key): "string"
      -extractHost(dsn): "string"
    }
    env_vars: {
      shape: sql_table
      label: "Environment Variables  [M1-M5]"
      PORT:                    "all services"
      SERVICE_NAME:            "all services"
      DATABASE_DSN:            "all app services"
      REDIS_ADDR:              "url-service + gateway"
      RABBITMQ_URL:            "all app services"
      JWT_SECRET:              "all services M2+"
      BASE_URL:                "url-service M3"
      CLICK_SALT:              "url-service M3 optional"
      URL_SERVICE_URL:         "gateway"
      ANALYTICS_SERVICE_URL:   "gateway"
      USER_SERVICE_URL:        "gateway"
      NOTIFICATION_SERVICE_URL: "gateway"
    }
  }
}

# ─────────────────────────────────────────────────────────────────────────────
# ROW 2: USER SVC + URL SVC + ANALYTICS SVC
# ─────────────────────────────────────────────────────────────────────────────
row2: "" {
  direction: right
  style.stroke: transparent
  style.fill: transparent

  layer_user_svc: {
    direction: down
    label: "USER SERVICE  :8083"
    style.fill: "#FFF7ED"
    style.stroke: "#EA580C"
    users_table: {
      shape: sql_table
      label: "TABLE users  migrations/001_create_users.sql  [M2]"
      id:            "UUID        | PK DEFAULT gen_random_uuid()"
      email:         "TEXT        | NOT NULL UNIQUE"
      password_hash: "TEXT        | bcrypt cost=12 60 chars"
      created_at:    "TIMESTAMPTZ | NOT NULL DEFAULT now()"
      idx:           "idx_users_email UNIQUE B-tree"
    }
    user_struct: {
      shape: sql_table
      label: "struct User  repository/user_repository.go  [M2]"
      ID:           "string    | UUID v4"
      Email:        "string    | lowercase-normalized"
      PasswordHash: "string    | bcrypt output"
      CreatedAt:    "time.Time | set by DB"
      sz:           "Total: ~80 bytes"
    }
    user_repo: {
      shape: class
      label: "UserRepository  repository/user_repository.go  [M2]"
      ErrDuplicateEmail: "= errors.New(\"email already registered\")"
      ErrUserNotFound: "= errors.New(\"user not found\")"
      +NewPgxUserRepository(pool): "UserRepository"
      +Create(ctx, u): "error"
      +FindByEmail(ctx, email): "(User, error)"
    }
    password_hasher: {
      shape: class
      label: "PasswordHasher  auth/password.go  [M2]"
      ErrPasswordMismatch: "= errors.New(\"password mismatch\")"
      -dummyHash: "string"
      +NewPasswordHasher(): "PasswordHasher"
      +Hash(plaintext): "(string, error)"
      +Compare(hash, plaintext): "error"
    }
    user_service_cls: {
      shape: class
      label: "UserService  service/user_service.go  [M2]"
      -repo: "UserRepository"
      -hasher: "PasswordHasher"
      -signer: "JWTSigner"
      -log: "zerolog.Logger"
      ErrAuthFailed: "= errors.New(\"invalid credentials\")"
      +NewUserService(repo, hasher, signer, log): "*UserService"
      +Register(ctx, email, password): "(User, error)"
      +Login(ctx, email, password): "(string, time.Time, error)"
    }
    user_handlers: {
      shape: class
      label: "Handlers  handler/*.go  [M2]"
      RegisterRequest: "{Email, Password string}"
      RegisterResponse: "{UserID, Email string}"
      LoginRequest: "{Email, Password string}"
      LoginResponse: "{Token, ExpiresAt string}"
      MeResponse: "{UserID, Email string}"
      ErrorResponse: "{Error string}"
      +NewRegisterHandler(svc, log): "http.HandlerFunc"
      +NewLoginHandler(svc, log): "http.HandlerFunc"
      +NewMeHandler(log): "http.HandlerFunc"
      +NewHealthHandler(name, log): "http.HandlerFunc"
    }
    user_service_cls -> user_repo: "repo"
    user_service_cls -> password_hasher: "hasher"
    user_handlers -> user_service_cls: "calls"
    user_repo -> users_table: "SQL queries"
    user_repo -> user_struct: "returns User"
  }

  layer_url_svc: {
    direction: down
    label: "URL SERVICE  :8081"
    style.fill: "#EFF6FF"
    style.stroke: "#2563EB"
    urls_table: {
      shape: sql_table
      label: "TABLE urls  migrations/001_create_urls.sql  [M3]"
      id:          "UUID        | PK DEFAULT gen_random_uuid()"
      short_code:  "VARCHAR(10) | NOT NULL UNIQUE"
      original_url:"TEXT        | NOT NULL"
      user_id:     "UUID        | NOT NULL"
      created_at:  "TIMESTAMPTZ | NOT NULL DEFAULT now()"
      expires_at:  "TIMESTAMPTZ | NULL = no expiry"
      is_active:   "BOOLEAN     | NOT NULL DEFAULT true"
      idx1:        "idx_urls_short_code UNIQUE"
      idx2:        "idx_urls_user_id_created (user_id, created_at DESC)"
    }
    outbox_table: {
      shape: sql_table
      label: "TABLE outbox  migrations/002_create_outbox.sql  [M3]"
      id:           "UUID        | PK DEFAULT gen_random_uuid()"
      event_type:   "TEXT        | NOT NULL routing key"
      payload:      "JSONB       | NOT NULL event struct"
      created_at:   "TIMESTAMPTZ | NOT NULL DEFAULT now()"
      published_at: "TIMESTAMPTZ | NULL = unpublished"
      idx:          "idx_outbox_unpublished WHERE published_at IS NULL"
    }
    url_struct: {
      shape: sql_table
      label: "struct URL  repository/url_repository.go  [M3]"
      ID:          "string     | UUID v4"
      ShortCode:   "string     | 7-char base62 up to 10"
      OriginalURL: "string     | full destination"
      UserID:      "string     | JWT sub claim"
      CreatedAt:   "time.Time  | set by DB"
      ExpiresAt:   "*time.Time | nil=no expiry"
      IsActive:    "bool       | false=soft-deleted"
      sz:          "Total: ~88 bytes"
    }
    outbox_struct: {
      shape: sql_table
      label: "struct OutboxEntry  repository/outbox_repository.go  [M3]"
      ID:          "string     | UUID v4"
      EventType:   "string     | routing key"
      Payload:     "[]byte     | JSON event"
      CreatedAt:   "time.Time  | set by DB"
      PublishedAt: "*time.Time | nil=pending"
      sz:          "Total: ~64 bytes"
    }
    cached_url_struct: {
      shape: sql_table
      label: "struct CachedURL  cache/cache.go  [M3]"
      OriginalURL: "string     | json:original_url"
      ExpiresAt:   "*time.Time | json:expires_at,omitempty"
      IsActive:    "bool       | json:is_active"
      key_fmt:     "Redis key: 'url:{short_code}'"
      ttl:         "min(expires_at-now, 1h)"
      sz:          "Total: ~40 bytes"
    }
    codegen_cls: {
      shape: class
      label: "CodeGenerator  codegen/codegen.go  [M3]"
      -base62Alphabet: "string (62 chars)"
      -codeLength: "= 7"
      +NewCodeGenerator(): "CodeGenerator"
      +Generate(): "(string, error)"
    }
    url_repo_cls: {
      shape: class
      label: "URLRepository  repository/url_repository.go  [M3]"
      ErrURLNotFound: "= errors.New(\"url not found\")"
      ErrCodeConflict: "= errors.New(\"short code already exists\")"
      ErrNotOwner: "= errors.New(\"caller does not own this url\")"
      +Create(ctx, tx, u): "error"
      +FindByCode(ctx, shortCode): "(URL, error)"
      +ListByUser(ctx, userID, afterID, limit): "([]URLSummary, error)"
      +SoftDelete(ctx, tx, shortCode, ownerID): "error"
    }
    outbox_repo_cls: {
      shape: class
      label: "OutboxRepository  repository/outbox_repository.go  [M3]"
      +Insert(ctx, tx, eventType, payload): "error"
      +FetchUnpublished(ctx, limit): "([]OutboxEntry, error)"
      +MarkPublished(ctx, id): "error"
    }
    cache_client_cls: {
      shape: class
      label: "CacheClient  cache/cache.go  [M3]"
      ErrCacheMiss: "= errors.New(\"cache miss\")"
      -client: "*redis.Client"
      +NewRedisCacheClient(client, log): "CacheClient"
      +Get(ctx, shortCode): "(CachedURL, error)"
      +Set(ctx, shortCode, entry, ttl): ""
      +Del(ctx, shortCode): ""
    }
    amqp_publisher_cls: {
      shape: class
      label: "AMQPPublisher  amqp/publisher.go  [M3]"
      -ch: "*amqp091.Channel"
      -mu: "sync.Mutex"
      +NewAMQPPublisher(ch, log): "AMQPPublisher"
      +Publish(ctx, routingKey, body): "error"
    }
    outbox_poller_cls: {
      shape: class
      label: "OutboxPoller  outbox/poller.go  [M3]"
      -jobChan: "chan OutboxEntry (buffered 50)"
      -workers: "= 3"
      -pollPeriod: "= 2 * time.Second"
      +NewOutboxPoller(pool, outboxRepo, pub, log): "*OutboxPoller"
      +Start(ctx): ""
      -outboxWorker(ctx, jobChan): ""
    }
    url_service_cls: {
      shape: class
      label: "URLService  service/url_service.go  [M3]"
      -pool: "*pgxpool.Pool"
      -urlRepo: "URLRepository"
      -outboxRepo: "OutboxRepository"
      -cache: "CacheClient"
      -codegen: "CodeGenerator"
      -baseURL: "string"
      ErrURLInvalid: "= errors.New(\"url is invalid\")"
      ErrURLExpired: "= errors.New(\"url has expired\")"
      ErrURLInactive: "= errors.New(\"url is inactive\")"
      ErrExhausted: "= errors.New(\"short code exhausted\")"
      "+NewURLService(deps)": "*URLService"
      +Shorten(ctx, url, code, exp, userID, corrID): "(URL, error)"
      +Redirect(ctx, code, ipHash, ua, ref, corrID): "(string, error)"
      +ListURLs(ctx, userID, cursor, size): "([]URLSummary, *string, error)"
      +Delete(ctx, code, userID, userEmail, corrID): "error"
    }
    url_handlers_cls: {
      shape: class
      label: "Handlers  handler/*.go  [M3]"
      ShortenRequest: "{URL, CustomCode string; ExpiresAt *string}"
      ShortenResponse: "{ShortCode, ShortURL, OriginalURL string}"
      URLListResponse: "{URLs []URLItem; NextCursor *string}"
      +NewShortenHandler(svc, baseURL, log): "http.HandlerFunc"
      +NewRedirectHandler(svc, log): "http.HandlerFunc"
      +NewListURLsHandler(svc, log): "http.HandlerFunc"
      +NewDeleteURLHandler(svc, log): "http.HandlerFunc"
      -extractClientIP(r): "string"
      -hashIP(rawIP): "string"
    }
    url_service_cls -> url_repo_cls: "urlRepo"
    url_service_cls -> outbox_repo_cls: "outboxRepo"
    url_service_cls -> cache_client_cls: "cache"
    url_service_cls -> codegen_cls: "codegen"
    outbox_poller_cls -> outbox_repo_cls: "fetch"
    outbox_poller_cls -> amqp_publisher_cls: "publish"
    url_repo_cls -> urls_table: "SQL CRUD"
    outbox_repo_cls -> outbox_table: "INSERT+UPDATE"
    cache_client_cls -> cached_url_struct: "stores"
    url_handlers_cls -> url_service_cls: "calls"
  }

  layer_analytics_svc: {
    direction: down
    label: "ANALYTICS SERVICE  :8082"
    style.fill: "#FDF4FF"
    style.stroke: "#9333EA"
    clicks_table: {
      shape: sql_table
      label: "TABLE clicks  migrations/001_create_clicks.sql  [M4]"
      id:         "UUID        | PK DEFAULT gen_random_uuid()"
      short_code: "TEXT        | NOT NULL"
      clicked_at: "TIMESTAMPTZ | NOT NULL (event time)"
      ip_hash:    "TEXT        | NOT NULL SHA-256 hex"
      user_agent: "TEXT        | NOT NULL DEFAULT ''"
      referer:    "TEXT        | NULL = no Referer header"
      idx1:       "idx_clicks_short_code_time (short_code, clicked_at DESC)"
      idx2:       "idx_clicks_referer partial WHERE referer IS NOT NULL"
    }
    milestones_table: {
      shape: sql_table
      label: "TABLE milestones  migrations/002_create_milestones.sql  [M4]"
      id:           "UUID        | PK"
      short_code:   "TEXT        | NOT NULL"
      milestone:    "INT         | 10 | 100 | 1000"
      triggered_at: "TIMESTAMPTZ | NOT NULL DEFAULT now()"
      uniq:         "UNIQUE (short_code, milestone)"
      idx:          "idx_milestones_short_code"
    }
    processed_events_table: {
      shape: sql_table
      label: "TABLE processed_events  migrations/003.sql  [M4]"
      event_id:     "UUID        | PK = URLClickedEvent.EventID"
      processed_at: "TIMESTAMPTZ | NOT NULL DEFAULT now()"
      note:         "PK IS the dedup index"
    }
    click_struct: {
      shape: sql_table
      label: "struct Click  repository/click_repository.go  [M4]"
      ID:        "string    | UUID from DB"
      ShortCode: "string    | routing key match"
      ClickedAt: "time.Time | OccurredAt event time"
      IPHash:    "string    | pre-hashed by url-svc"
      UserAgent: "string    | empty if absent"
      Referer:   "string    | empty->NULL in DB"
      sz:        "Total: ~72 bytes"
    }
    click_repo_cls: {
      shape: class
      label: "ClickRepository  repository/click_repository.go  [M4]"
      +Insert(ctx, tx, click): "error"
      +CountByCode(ctx, shortCode): "(int64, error)"
      +CountSince(ctx, shortCode, since): "(int64, error)"
      +TopReferers(ctx, shortCode, limit): "([]RefererCount, error)"
      +Timeline(ctx, shortCode, interval): "([]PeriodCount, error)"
    }
    processed_event_repo_cls: {
      shape: class
      label: "ProcessedEventRepository  [M4]"
      +IsProcessed(ctx, eventID): "(bool, error)"
      +MarkProcessed(ctx, tx, eventID): "error"
    }
    milestone_repo_cls: {
      shape: class
      label: "MilestoneRepository  [M4]"
      +GetLatestMilestone(ctx, shortCode): "(int, error)"
      +InsertMilestone(ctx, tx, shortCode, milestone): "error"
    }
    milestone_detector_cls: {
      shape: class
      label: "MilestoneDetector  milestone/detector.go  [M4]"
      Thresholds: "= []int{10, 100, 1000}"
      +NewThresholdDetector(): "Detector"
      +Detect(latestMilestone, newTotal): "int"
    }
    click_processor_cls: {
      shape: class
      label: "ClickProcessor  consumer/processor.go  [M4]"
      -clickRepo: "ClickRepository"
      -processedRepo: "ProcessedEventRepository"
      -milestoneRepo: "MilestoneRepository"
      -detector: "Detector"
      -publisher: "AMQPPublisher"
      -pool: "*pgxpool.Pool"
      ProcessResultInserted: "ProcessResult = 0"
      ProcessResultDuplicate: "ProcessResult = 1"
      ProcessResultPoisoned: "ProcessResult = 2"
      ProcessResultError: "ProcessResult = 3"
      +NewClickProcessor(pool, repos, detector, pub, log): "*ClickProcessor"
      +Process(ctx, d): "ProcessResult"
    }
    analytics_handlers_cls: {
      shape: class
      label: "Handlers  handler/*.go  [M4]"
      StatsResponse: "{ShortCode string; Total, Last24h, Last7d int64}"
      TimelineResponse: "{ShortCode, Interval string; Points []TimelinePoint}"
      +NewStatsHandler(clickRepo, log): "http.HandlerFunc"
      +NewTimelineHandler(clickRepo, log): "http.HandlerFunc"
    }
    click_processor_cls -> click_repo_cls: "insert"
    click_processor_cls -> processed_event_repo_cls: "dedup"
    click_processor_cls -> milestone_repo_cls: "milestone"
    click_processor_cls -> milestone_detector_cls: "detect"
    click_repo_cls -> clicks_table: "SQL"
    milestone_repo_cls -> milestones_table: "SQL"
    processed_event_repo_cls -> processed_events_table: "SQL"
    analytics_handlers_cls -> click_repo_cls: "queries"
  }
}

# ─────────────────────────────────────────────────────────────────────────────
# ROW 3: NOTIFICATION SVC + GATEWAY
# ─────────────────────────────────────────────────────────────────────────────
row3: "" {
  direction: right
  style.stroke: transparent
  style.fill: transparent

  layer_notification_svc: {
    direction: down
    label: "NOTIFICATION SERVICE  :8084"
    style.fill: "#FFF1F2"
    style.stroke: "#E11D48"
    notifications_table: {
      shape: sql_table
      label: "TABLE notifications  migrations/001.sql  [M5]"
      id:         "UUID        | PK DEFAULT gen_random_uuid()"
      user_id:    "UUID        | NOT NULL JWT sub"
      event_type: "TEXT        | NOT NULL routing key"
      payload:    "JSONB       | NOT NULL raw event"
      status:     "TEXT        | NOT NULL DEFAULT 'sent'"
      created_at: "TIMESTAMPTZ | NOT NULL DEFAULT now()"
      sent_at:    "TIMESTAMPTZ | NULL until mock send"
      idx:        "idx_notifications_user_id_created"
    }
    processed_notif_table: {
      shape: sql_table
      label: "TABLE processed_notifications  [M5]"
      event_key:    "TEXT        | PK = event_type:correlation_id"
      processed_at: "TIMESTAMPTZ | NOT NULL DEFAULT now()"
      note:         "Dedup key = routing_key + ':' + correlationID"
    }
    notification_struct: {
      shape: sql_table
      label: "struct Notification  repository/notification_repository.go  [M5]"
      ID:        "string     | UUID from DB"
      UserID:    "string     | JWT sub"
      EventType: "string     | routing key"
      Payload:   "[]byte     | raw JSON"
      Status:    "string     | sent/failed"
      CreatedAt: "time.Time  | set by DB"
      SentAt:    "*time.Time | nil until sent"
      sz:        "Total: ~80 bytes"
    }
    notification_repo_cls: {
      shape: class
      label: "NotificationRepository  repository/  [M5]"
      +Insert(ctx, n): "error"
      +ListByUser(ctx, userID, afterID, limit): "([]NotificationSummary, error)"
      +IsProcessed(ctx, eventKey): "(bool, error)"
      +MarkProcessed(ctx, eventKey): "error"
    }
    notif_processor_cls: {
      shape: class
      label: "NotificationProcessor  consumer/processor.go  [M5]"
      -repo: "NotificationRepository"
      +NewNotificationProcessor(repo, log): "*NotificationProcessor"
      +Process(ctx, d): "ProcessResult"
    }
    notif_handlers_cls: {
      shape: class
      label: "Handlers  handler/*.go  [M5]"
      NotificationListResponse: "{Notifications []NotificationItem; NextCursor *string}"
      NotificationItem: "{ID, EventType, Status, CreatedAt string; SentAt *string}"
      +NewNotificationsHandler(repo, log): "http.HandlerFunc"
    }
    notif_processor_cls -> notification_repo_cls: "insert"
    notification_repo_cls -> notifications_table: "SQL"
    notification_repo_cls -> processed_notif_table: "dedup"
    notif_handlers_cls -> notification_repo_cls: "ListByUser"
  }

  layer_gateway: {
    direction: down
    label: "API GATEWAY  :8080"
    style.fill: "#F0FFF4"
    style.stroke: "#059669"
    circuit_breaker_struct: {
      shape: sql_table
      label: "struct CircuitBreaker  circuitbreaker/circuitbreaker.go  [M5]"
      state:           "State    | int32 atomic"
      failureCount:    "int      | consecutive failures"
      lastFailureAt:   "time.Time| window tracking"
      openedAt:        "time.Time| zero when Closed"
      probeInFlight:   "bool     | one probe at a time"
      mu:              "sync.Mutex | protects all fields"
      StateClosed:     "State=0  | pass through"
      StateOpen:       "State=1  | reject immediately"
      StateHalfOpen:   "State=2  | one probe"
      sz:              "Total: ~80 bytes"
    }
    cb_config_struct: {
      shape: sql_table
      label: "struct Config  circuitbreaker  [M5]"
      FailureThreshold: "int           | 5 consecutive"
      Window:           "time.Duration | 10s"
      OpenDuration:     "time.Duration | 30s"
    }
    circuit_breaker_cls: {
      shape: class
      label: "CircuitBreaker methods  [M5]"
      +NewCircuitBreaker(cfg): "*CircuitBreaker"
      +DefaultConfig(): "Config"
      +Allow(): "(bool, error)"
      +RecordSuccess(): ""
      +RecordFailure(): ""
      +State(): "State"
    }
    rate_limiter_struct: {
      shape: sql_table
      label: "struct RateLimiter  ratelimit/ratelimit.go  [M5]"
      client:         "*redis.Client | nil=fail-open"
      LimitShorten:   "RouteLimit | 10 req/min"
      LimitRedirect:  "RouteLimit | 300 req/min"
      key_fmt:        "ratelimit:{route}:{ip}"
      lua_script:     "INCR + EXPIRE-if-new atomic"
      sz:             "Total: ~24 bytes"
    }
    rate_limiter_cls: {
      shape: class
      label: "RateLimiter methods  [M5]"
      +NewRateLimiter(client, log): "*RateLimiter"
      +Allow(ctx, ip, route): "AllowResult"
    }
    reverse_proxy_cls: {
      shape: class
      label: "ReverseProxy  proxy/proxy.go  [M5]"
      -targets: "map[string]*httputil.ReverseProxy"
      -client: "*http.Client"
      DialTimeout: "= 5s"
      ResponseHeaderTimeout: "= 30s"
      +NewReverseProxy(targets, cb, log): "*ReverseProxy"
      +Forward(targetName, w, r): ""
      +HandlerFor(name): "http.Handler"
    }
    correlation_mw: {
      shape: class
      label: "CorrelationMiddleware  middleware/correlation.go  [M5]"
      -correlationIDKey: "contextKey = \"correlation_id\""
      +CorrelationMiddleware(next): "http.Handler"
      +CorrelationIDFromContext(ctx): "string"
    }
    gateway_jwt_mw: {
      shape: class
      label: "GatewayJWTMiddleware  middleware/jwt.go  [M5]"
      +GatewayJWTMiddleware(verifier, log): "func(Handler) Handler"
    }
    gateway_route_table: {
      shape: sql_table
      label: "Route Table  router/router.go  [M5]"
      health:                "GET  /health              -> gateway"
      register:              "POST /api/auth/register   -> user-svc (no JWT)"
      login:                 "POST /api/auth/login      -> user-svc (no JWT)"
      redirect:              "GET  /r/:code             -> url-svc  (rate+cb)"
      shorten:               "POST /api/shorten         -> url-svc  (JWT+rate+cb)"
      list_urls:             "GET  /api/urls            -> url-svc  (JWT+cb)"
      delete_url:            "DELETE /api/urls/:code    -> url-svc  (JWT+cb)"
      stats:                 "GET  /api/stats/:code     -> analytics (public)"
      timeline:              "GET  /api/stats/:code/timeline -> analytics"
      me:                    "GET  /api/me              -> user-svc (JWT)"
      notifications:         "GET  /api/notifications   -> notif-svc (JWT)"
      path_strip:            "strip /api prefix before forward"
    }
    circuit_breaker_cls -> circuit_breaker_struct: "manages state"
    rate_limiter_cls -> rate_limiter_struct: "Redis Lua"
    reverse_proxy_cls -> circuit_breaker_cls: "Allow/Record"
    correlation_mw -> gateway_jwt_mw: "chain"
    gateway_jwt_mw -> reverse_proxy_cls: "chain"
    gateway_route_table -> reverse_proxy_cls: "dispatch"
  }
}

# ─────────────────────────────────────────────────────────────────────────────
# MILESTONE INDEX (bottom)
# ─────────────────────────────────────────────────────────────────────────────
milestone_index: {
  shape: sql_table
  label: "Milestone Index"
  m1: "M1 | url-shortener-m1 | Foundation: Repo, Shared Contracts, Dev Stack"
  m2: "M2 | url-shortener-m2 | User Service: Registration, Login, JWT"
  m3: "M3 | url-shortener-m3 | URL Service: Shorten, Redirect, Outbox"
  m4: "M4 | url-shortener-m4 | Analytics Service: Click Ingestion, Stats API"
  m5: "M5 | url-shortener-m5 | Notification Service + API Gateway + Circuit Breaker"
}

# ─────────────────────────────────────────────────────────────────────────────
# CROSS-ROW EDGES (inter-layer connections)
# ─────────────────────────────────────────────────────────────────────────────
row1.layer_shared -> row1.layer_infra: "imports"
row1.layer_shared -> row2.layer_user_svc: "imports"
row1.layer_shared -> row2.layer_url_svc: "imports"
row1.layer_shared -> row2.layer_analytics_svc: "imports"
row1.layer_shared -> row3.layer_notification_svc: "imports"
row1.layer_shared -> row3.layer_gateway: "imports"
row1.layer_infra -> row2.layer_user_svc: "DB+MQ infra"
row1.layer_infra -> row2.layer_url_svc: "DB+Redis+MQ"
row1.layer_infra -> row2.layer_analytics_svc: "DB+MQ infra"
row1.layer_infra -> row3.layer_notification_svc: "DB+MQ infra"
row1.layer_infra -> row3.layer_gateway: "Redis infra"
row2.layer_user_svc -> row2.layer_url_svc: "JWT_SECRET shared"
row2.layer_user_svc -> row2.layer_analytics_svc: "JWT_SECRET shared"
row2.layer_user_svc -> row3.layer_notification_svc: "JWT_SECRET shared"
row2.layer_user_svc -> row3.layer_gateway: "JWT_SECRET shared"
row2.layer_url_svc -> row2.layer_analytics_svc: "URLClickedEvent | RabbitMQ"
row2.layer_url_svc -> row3.layer_notification_svc: "URLCreatedEvent | RabbitMQ"
row2.layer_url_svc -> row3.layer_notification_svc: "URLDeletedEvent | RabbitMQ"
row2.layer_analytics_svc -> row3.layer_notification_svc: "MilestoneReachedEvent | RabbitMQ"
row3.layer_gateway -> row2.layer_user_svc: "proxy /api/auth/*"
row3.layer_gateway -> row2.layer_url_svc: "proxy /api/shorten /r/:code"
row3.layer_gateway -> row2.layer_analytics_svc: "proxy /api/stats/*"
row3.layer_gateway -> row3.layer_notification_svc: "proxy /api/notifications"
