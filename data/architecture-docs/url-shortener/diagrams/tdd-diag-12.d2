layout-engine: elk
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
  colors: {
    header: "#6a0dad"
    data: "#0d47a1"
    free: "#2e7d32"
    padding: "#808080"
    pointer: "#e65100"
    bg: "#1a1a2e"
  }
}

title: |md
  # JWT Claims Memory Layout — HS256 Wire Format
  `base64url(header) . base64url(payload) . base64url(signature)`
| {near: top-center}

# ─── WIRE FORMAT (COMPACT SERIALIZATION) ─────────────────────────────────────
wire: "JWT Wire Format (3 segments, dot-separated)" {
  style.fill: "#1a1a2e"
  style.font-color: white
  style.bold: true
  
  seg_header: "Segment 1: base64url(header)" {
    style.fill: ${colors.header}
    style.font-color: white
    label: |md
      **36 bytes (base64url)**
      `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`
    |
  }
  dot1: "." {
    style.fill: "#ff6b35"
    style.font-color: white
    width: 20
  }
  seg_payload: "Segment 2: base64url(payload)" {
    style.fill: ${colors.data}
    style.font-color: white
    label: |md
      **~162 bytes (base64url)**
      Claims: sub, email, iat, exp, iss
    |
  }
  dot2: "." {
    style.fill: "#ff6b35"
    style.font-color: white
    width: 20
  }
  seg_sig: "Segment 3: base64url(HMAC-SHA256)" {
    style.fill: ${colors.free}
    style.font-color: white
    label: |md
      **43 bytes (base64url)**
      Final Integrity Check
    |
  }
  
  seg_header -> dot1 -> seg_payload -> dot2 -> seg_sig
}

# ─── HEADER JSON BYTE LAYOUT ─────────────────────────────────────────────────
header_layout: "Header JSON Byte Layout (raw)" {
  style.fill: "#121212"
  style.font-color: white
  
  h0: "0x00 | { | 1B" { style.fill: ${colors.header}; width: 300 }
  h1: "0x01 | \"alg\": | 6B" { style.fill: ${colors.header}; width: 300 }
  h2: "0x07 | \"HS256\" | 7B" { style.fill: ${colors.header}; width: 300 }
  h3: "0x0E | , | 1B" { style.fill: ${colors.header}; width: 300 }
  h4: "0x0F | \"typ\": | 6B" { style.fill: ${colors.header}; width: 300 }
  h5: "0x15 | \"JWT\" | 5B" { style.fill: ${colors.header}; width: 300 }
  h6: "0x1A | } | 1B" { style.fill: ${colors.header}; width: 300 }

  h0 -> h1 -> h2 -> h3 -> h4 -> h5 -> h6
}

# ─── PAYLOAD JSON BYTE LAYOUT ─────────────────────────────────────────────────
payload_layout: "Payload JSON Byte Layout (raw)" {
  style.fill: "#121212"
  style.font-color: white

  p0: "0x00 | { | 1B" { style.fill: ${colors.data}; width: 350 }
  p1: "0x01 | \"sub\":\"UUID-V4\" | 44B" { style.fill: ${colors.pointer}; width: 350 }
  p2: "0x2D | , | 1B" { style.fill: ${colors.data}; width: 350 }
  p3: "0x2E | \"email\":\"...\" | Var (N)" { style.fill: ${colors.data}; width: 350 }
  p4: "0x2E+N | , | 1B" { style.fill: ${colors.data}; width: 350 }
  p5: "0x2F+N | \"iat\":174... | 16B" { style.fill: ${colors.data}; width: 350 }
  p6: "0x3F+N | } | 1B" { style.fill: ${colors.data}; width: 350 }

  p0 -> p1 -> p2 -> p3 -> p4 -> p5 -> p6
}

# ─── GO MEMORY STRUCT ────────────────────────────────────────────────────────
memory_struct: "Go Claims Struct (Process Memory)" {
  style.stroke-dash: 5
  style.stroke: ${colors.pointer}
  
  c0: "0x00 | Sub (string descriptor) | 16B" { style.fill: ${colors.pointer}; width: 400 }
  c1: "0x10 | Email (string descriptor) | 16B" { style.fill: ${colors.pointer}; width: 400 }
  c2: "0x20 | Iat (int64) | 8B" { style.fill: ${colors.data}; width: 400 }
  c3: "0x28 | Exp (int64) | 8B" { style.fill: ${colors.data}; width: 400 }
  c4: "0x30 | Iss (string descriptor) | 16B" { style.fill: ${colors.pointer}; width: 400 }
  
  c0 -> c1 -> c2 -> c3 -> c4
  
  label: |md
    **sizeof(Claims) = 64 Bytes**
    *(Exact 64B Cache Line Alignment)*
  |
}

# ─── SIGNATURE GENERATION ─────────────────────────────────────────────────────
sig_gen: "Signature Generation Flow" {
  input: "ASCII Input" {
    label: "base64(hdr) + '.' + base64(pay)"
    style.fill: ${colors.pointer}
    style.font-color: white
  }
  secret: "Secret Key" {
    label: "HMAC_SECRET"
    style.fill: ${colors.free}
    style.font-color: white
  }
  algo: "HMAC-SHA256" {
    shape: diamond
    style.fill: ${colors.data}
    style.font-color: white
  }
  output: "32-byte Binary Digest" {
    style.fill: ${colors.data}
    style.font-color: white
  }
  
  input -> algo
  secret -> algo
  algo -> output
}

# ─── SUMMARY TABLE ────────────────────────────────────────────────────────────
summary: |'md
## Segment Size Summary (HS256)
| Segment | Raw JSON | base64url | Notes |
|---------|----------|-----------|-------|
| Header  | 27 bytes | 36 chars  | Fixed: HS256/JWT |
| `.`     | —        | 1 char    | Separator |
| Payload | ~120 bytes| ~162 chars| Variable length |
| `.`     | —        | 1 char    | Separator |
| Signature| 32 bytes | 43 chars  | 256-bit HMAC |
| **Total** | **~179B** | **~243 chars**| Final Wire Size |
'| {
  near: bottom-center
  style.fill: "#1a1a1a"
  style.font-color: white
  style.border-radius: 8
}

# ─── CONNECTIONS ──────────────────────────────────────────────────────────────
wire.seg_header -> header_layout: "decoded" {
  style.stroke: ${colors.header}
  style.stroke-dash: 4
}
wire.seg_payload -> payload_layout: "decoded" {
  style.stroke: ${colors.data}
  style.stroke-dash: 4
}
sig_gen.output -> wire.seg_sig: "base64url encode" {
  style.stroke: ${colors.free}
  style.bold: true
}
payload_layout -> memory_struct: "Unmarshaled into" {
  style.stroke: ${colors.pointer}
  style.stroke-dash: 2
}

# Fixed error: using constant value for near in ELK
memory_info_label: |md
  ### Memory Alignment Note
  Struct fields are aligned to 8-byte boundaries. 
  The total size of 64B allows the CPU to fetch 
  the entire claims set in a single cache line 
  transaction, minimizing memory latency.
| {
  near: top-right
  style.stroke: ${colors.pointer}
  style.stroke-dash: 5
}