vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}
direction: down
title: |md
  ## POST /shorten â€” Atomic Transaction (Step-by-Step)
  `url-shortener-m3` Â· Handler â†’ URLService â†’ PostgreSQL
| {near: top-center}

# â”€â”€ Legend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
legend: {
  near: bottom-right
  shape: rectangle
  style.fill: "#F8F8F8"
  style.stroke: "#AAAAAA"
  style.font-size: 12
  label: |md
    **Legend**
    ðŸŸ¦ Happy path  ðŸŸ¥ Error path  ðŸŸ§ Retry loop
    Red border = same DB transaction
    Dashed arrow = error branch
    Solid arrow = success flow
  |
}

# â”€â”€ STEP 1: JWT Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
s1: "â‘  JWT Validation" {
  shape: rectangle
  style.fill: "#E8D5F5"
  style.stroke: "#7B2D8B"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true
  label: |md
    **â‘  Validate JWT â€” Extract Claims**
    **IN:** `Authorization: Bearer &lt;token&gt;` header
    **ACTION:**
    `RequireAuth` middleware calls `JWTVerifier.Verify(token)`
    Local HMAC-SHA256 â€” **no network call**
    Extract: `claims.Sub` â†’ `user_id` (UUID)
    Extract: `claims.Email` â†’ `user_email`
    **OUT:** `(user_id: string, user_email: string)`
  |
}
s1_err: "401 Unauthorized" {
  shape: rectangle
  style.fill: "#FFCCCC"
  style.stroke: "#CC0000"
  style.stroke-width: 2
  style.border-radius: 4
  style.font-size: 12
  label: |md
    **401**
    `{"error":"unauthorized"}`
    ErrTokenExpired â†’ 401
    ErrTokenInvalid â†’ 401
    Missing header â†’ 401
  |
}
s1 -> s1_err: "verify fails" {
  style.stroke: "#CC0000"
  style.stroke-dash: 5
  style.font-color: "#CC0000"
}

# â”€â”€ STEP 2: URL Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
s2: "â‘¡ URL Format Validation" {
  shape: rectangle
  style.fill: "#D5E8F5"
  style.stroke: "#1A6EA8"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true
  label: |md
    **â‘¡ Validate URL + Parse Request Body**
    **IN:** `ShortenRequest{url, custom_code?, expires_at?}`
    Body limit: `http.MaxBytesReader(w, r.Body, 4096)`
    **ACTION:**
    `url.Parse(req.URL)` â€” Go stdlib
    Require: `parsed.Scheme âˆˆ {http, https}`
    Require: `parsed.Host != ""`
    If `expires_at` present: `time.Parse(RFC3339, *req.ExpiresAt)`
    Require: `expiresAt.After(time.Now())`
    **OUT:** `(originalURL: string, expiresAt: *time.Time, customCode: string)`
  |
}
s2_err: "400 Bad Request" {
  shape: rectangle
  style.fill: "#FFCCCC"
  style.stroke: "#CC0000"
  style.stroke-width: 2
  style.border-radius: 4
  style.font-size: 12
  label: |md
    **400**
    Missing scheme/host â†’ `"url must include scheme and host"`
    Non-http scheme â†’ `"url scheme must be http or https"`
    Bad expires_at â†’ `"expires_at must be RFC3339 format"`
    Past expires_at â†’ `"expires_at must be in the future"`
    Body > 4096B â†’ `"request body too large"`
  |
}
s2 -> s2_err: "validation fails" {
  style.stroke: "#CC0000"
  style.stroke-dash: 5
  style.font-color: "#CC0000"
}

# â”€â”€ STEP 3: Short Code Selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
s3: "â‘¢ Short Code Selection" {
  shape: rectangle
  style.fill: "#FFF3CC"
  style.stroke: "#CC8800"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true
  label: |md
    **â‘¢ Select Short Code (with Collision Retry)**
    **IN:** `customCode: string` (may be empty)
    **BRANCH A â€” Custom Code Provided:**
    Validate: `len âˆˆ [4,10]`, all chars in `base62Alphabet`
    Use as-is â†’ collision detected at DB INSERT (Step â‘¤)
    Custom code conflict â†’ **409** (not retried)
    **BRANCH B â€” Auto-Generate (loop â‰¤ 5 attempts):**
    
    go
    for attempt := 1; attempt <= 5; attempt++ {
        code = codegen.Generate()      // crypto/rand, 7 chars
        â†’ attempt INSERT (Step â‘¤)
        if ErrCodeConflict: continue   // retry
        if success: break
    }
    
    
    if attempt &gt; 5: return ErrExhausted â†’ 503
    
    `base62Alphabet = "0123456789A-Za-z"` (62 chars)
    Collision space: 62â· â‰ˆ 3.5 trillion codes
    **OUT:** `shortCode: string` (7 chars auto / 4-10 chars custom)
  |
}
s3_custom_err: "409 Conflict" {
  shape: rectangle
  style.fill: "#FFCCCC"
  style.stroke: "#CC0000"
  style.stroke-width: 2
  style.border-radius: 4
  style.font-size: 12
  label: |md
    **409**
    Custom code taken
    `{"error":"short code already taken"}`
  |
}
s3_exhaust_err: "503 Service Unavailable" {
  shape: rectangle
  style.fill: "#FFCCCC"
  style.stroke: "#CC0000"
  style.stroke-width: 2
  style.border-radius: 4
  style.font-size: 12
  label: |md
    **503**
    5 collision retries exhausted
    `{"error":"could not generate unique code; try again"}`
    (Indicates pathologically high collision rate)
  |
}
s3 -> s3_custom_err: "custom code\nconflict" {
  style.stroke: "#CC0000"
  style.stroke-dash: 5
  style.font-color: "#CC0000"
}
s3 -> s3_exhaust_err: "5 retries\nexhausted" {
  style.stroke: "#CC0000"
  style.stroke-dash: 5
  style.font-color: "#CC0000"
}

# â”€â”€ STEP 4: BEGIN TRANSACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
s4: "â‘£ BEGIN Transaction" {
  shape: rectangle
  style.fill: "#E0FFE0"
  style.stroke: "#006600"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true
  label: |md
    **â‘£ BEGIN PostgreSQL Transaction**
    **IN:** `*pgxpool.Pool`
    **ACTION:**
    `tx, err = pool.Begin(ctx)`
    `defer tx.Rollback(ctx)` â€” auto-rollback if Commit not reached
    **OUT:** `pgx.Tx` â€” transaction handle passed to Steps â‘¤ and â‘¥
    âš  Both Steps â‘¤ and â‘¥ MUST use this same `tx`
    âš  No HTTP response before COMMIT succeeds
  |
}
s4_err: "500 Internal Error" {
  shape: rectangle
  style.fill: "#FFCCCC"
  style.stroke: "#CC0000"
  style.stroke-width: 2
  style.border-radius: 4
  style.font-size: 12
  label: |md
    **500**
    Pool exhausted or DB unreachable
    `log.Error` + `{"error":"internal server error"}`
  |
}
s4 -> s4_err: "pool.Begin fails" {
  style.stroke: "#CC0000"
  style.stroke-dash: 5
  style.font-color: "#CC0000"
}

# â”€â”€ ATOMIC TRANSACTION BOX (Steps 5+6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
atomic_tx: "ATOMIC TRANSACTION â€” Steps â‘¤ + â‘¥ execute in same pgx.Tx" {
  style.fill: "#FFF0F0"
  style.stroke: "#CC0000"
  style.stroke-width: 3
  style.border-radius: 8
  style.stroke-dash: 0
  tx_label: |md
    ðŸ”´ **ATOMICITY INVARIANT:**
    Both INSERTs succeed or both roll back.
    A URL row can never exist without its outbox row.
    An outbox row can never exist for a URL that was not created.
  | {
    shape: text
    style.font-color: "#CC0000"
    style.bold: true
    style.font-size: 12
  }
  # â”€â”€ STEP 5 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  s5: "â‘¤ INSERT INTO urls" {
    shape: rectangle
    style.fill: "#D5E8F5"
    style.stroke: "#1A6EA8"
    style.stroke-width: 2
    style.border-radius: 6
    style.bold: true
    label: |md
      **â‘¤ INSERT INTO urls (within tx)**
      **IN:** `(tx, URL{id, short_code, original_url, user_id, expires_at})`
      `url.ID = uuid.New().String()` â€” generated by app, not DB
      **SQL:**
      sql
      INSERT INTO urls
        (id, short_code, original_url, user_id, expires_at)
      VALUES ($1, $2, $3, $4, $5)
      
      Unique index `idx_urls_short_code` enforces collision detection.
      **ON `23505` (unique violation):**
      â†’ `ErrCodeConflict` returned to `Shorten()`
      â†’ tx rolled back by defer
      â†’ if auto-code: retry loop at Step â‘¢
      â†’ if custom-code: 409 immediately
      **OUT:** URL row in DB (uncommitted until Step â‘¦)
    |
  }
  # â”€â”€ STEP 6 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  s6: "â‘¥ INSERT INTO outbox" {
    shape: rectangle
    style.fill: "#D5E8F5"
    style.stroke: "#1A6EA8"
    style.stroke-width: 2
    style.border-radius: 6
    style.bold: true
    label: |md
      **â‘¥ INSERT INTO outbox (within same tx)**
      **IN:** `(tx, eventType="url.created", payload=URLCreatedEvent JSON)`
      **URLCreatedEvent payload:**
      json
      {
        "event_type":     "url.created",
        "occurred_at":    "2026-03-02T14:00:00Z",
        "correlation_id": "UUID-FROM-HEADER",
        "short_code":     "aB3xY9z",
        "original_url":   "https://...",
        "user_id":        "JWT-SUB",
        "user_email":     "JWT-EMAIL",
        "expires_at":     null
      }
      
      
      **SQL:**
      sql
      INSERT INTO outbox
        (id, event_type, payload, created_at)
      VALUES
        (gen_random_uuid(), $1, $2, now())
      
      
      `published_at` starts NULL â†’ poller picks it up
      **OUT:** Outbox row in DB (uncommitted until Step â‘¦)
    |
  }
  s5 -> s6: "INSERT succeeded\n(tx still open)" {
    style.stroke: "#006600"
    style.stroke-width: 2
    style.font-color: "#006600"
  }
  s5_err_inner: "tx.Rollback â†’ retry or 500" {
    shape: rectangle
    style.fill: "#FFCCCC"
    style.stroke: "#CC0000"
    style.stroke-width: 1
    style.border-radius: 4
    style.font-size: 11
    label: |md
      **Rollback (defer)**
      23505 â†’ ErrCodeConflict
      â†’ retry if auto-code
      â†’ 409 if custom-code
      Other DB error â†’ 500
    |
  }
  s6_err_inner: "tx.Rollback â†’ 500" {
    shape: rectangle
    style.fill: "#FFCCCC"
    style.stroke: "#CC0000"
    style.stroke-width: 1
    style.border-radius: 4
    style.font-size: 11
    label: |md
      **Rollback (defer)**
      Outbox INSERT fails â†’ 500
      urls row also rolled back
      No partial state possible
    |
  }
  s5 -> s5_err_inner: "INSERT fails\n(DB error / conflict)" {
    style.stroke: "#CC0000"
    style.stroke-dash: 4
    style.font-color: "#CC0000"
    style.font-size: 11
  }
  s6 -> s6_err_inner: "INSERT fails" {
    style.stroke: "#CC0000"
    style.stroke-dash: 4
    style.font-color: "#CC0000"
    style.font-size: 11
  }
}

# â”€â”€ STEP 7: COMMIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
s7: "â‘¦ tx.Commit()" {
  shape: rectangle
  style.fill: "#E0FFE0"
  style.stroke: "#006600"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true
  label: |md
    **â‘¦ COMMIT Transaction**
    **IN:** Open `pgx.Tx` with both rows written (uncommitted)
    **ACTION:** `err = tx.Commit(ctx)`
    On success:
    - urls row is durable and visible to other connections
    - outbox row is durable and visible to poller goroutine
    **CRASH BETWEEN COMMIT AND HTTP RESPONSE:**
    Client receives connection reset â†’ URL WAS created
    Client may retry â†’ second INSERT hits unique constraint â†’ 409
    **OUT:** Both rows committed; transaction closed
  |
}
s7_err: "500 Internal Error" {
  shape: rectangle
  style.fill: "#FFCCCC"
  style.stroke: "#CC0000"
  style.stroke-width: 2
  style.border-radius: 4
  style.font-size: 12
  label: |md
    **500**
    Commit fails (extremely rare: network partition to DB)
    Both rows rolled back atomically
    `{"error":"internal server error"}`
  |
}
s7 -> s7_err: "Commit fails" {
  style.stroke: "#CC0000"
  style.stroke-dash: 5
  style.font-color: "#CC0000"
}

# â”€â”€ STEP 8: HTTP 201 Response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
s8: "â‘§ Return 201 Created" {
  shape: rectangle
  style.fill: "#E8D5F5"
  style.stroke: "#7B2D8B"
  style.stroke-width: 2
  style.border-radius: 6
  style.bold: true
  label: |md
    **â‘§ HTTP 201 Created**
    **Response Body:**
    json
    {
      "short_code":   "aB3xY9z",
      "short_url":    "http://localhost:8081/aB3xY9z",
      "original_url": "https://very-long-url.example.com/path",
      "expires_at":   null
    }
    
    
    `short_url = BASE_URL + "/" + short_code`
    `Content-Type: application/json`
  |
}

# â”€â”€ HAPPY PATH CONNECTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
s1 -> s2: "claims.Sub, claims.Email\n(user_id, user_email extracted)" {
  style.stroke: "#006600"
  style.stroke-width: 2
  style.font-color: "#006600"
}
s2 -> s3: "originalURL, expiresAt, customCode\n(all validated)" {
  style.stroke: "#006600"
  style.stroke-width: 2
  style.font-color: "#006600"
}
s3 -> s4: "shortCode selected\n(auto or custom)" {
  style.stroke: "#006600"
  style.stroke-width: 2
  style.font-color: "#006600"
}
s4 -> atomic_tx: "tx handle open\n(defer Rollback armed)" {
  style.stroke: "#006600"
  style.stroke-width: 2
  style.font-color: "#006600"
}
atomic_tx -> s7: "Both INSERTs succeeded\n(within same tx)" {
  style.stroke: "#006600"
  style.stroke-width: 2
  style.font-color: "#006600"
}
s7 -> s8: "Commit succeeded\n(both rows durable)" {
  style.stroke: "#006600"
  style.stroke-width: 2
  style.font-color: "#006600"
}

# â”€â”€ RETRY LOOP ANNOTATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
retry_note: |md
  ðŸ” **Collision Retry Loop**
  `ErrCodeConflict` from Step â‘¤
  (auto-code only) causes control
  to return to Step â‘¢ to generate
  a new 7-char code.
| {
  shape: text
  style.font-color: "#CC8800"
  style.font-size: 12
  near: top-right
}
atomic_tx.s5_err_inner -> s3: "ErrCodeConflict\n+ auto-code\nâ†’ retry" {
  style.stroke: "#CC8800"
  style.stroke-dash: 3
  style.font-color: "#CC8800"
  style.stroke-width: 2
}

# â”€â”€ OUTBOX POLLER DOWNSTREAM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
poller: "Outbox Poller (background goroutine)" {
  shape: rectangle
  style.fill: "#F0F0F0"
  style.stroke: "#888888"
  style.stroke-width: 1
  style.border-radius: 6
  style.stroke-dash: 3
  label: |md
    **Outbox Poller** (url-service, 3 workers)
    Polls every **2s**:
    `SELECT id FROM outbox WHERE published_at IS NULL`
    Publishes to RabbitMQ routing key: `url.created`
  |
}
s8 -> poller: "outbox row picked up\nwithin â‰¤ 2s (async)" {
  style.stroke: "#888888"
  style.stroke-dash: 4
  style.font-color: "#888888"
  style.font-size: 11
}