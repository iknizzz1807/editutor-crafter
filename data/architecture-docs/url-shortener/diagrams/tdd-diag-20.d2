vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}
direction: right
title: "Outbox Worker Pool Architecture + Data Flow" {
  near: top-center
  shape: text
  style: {
    font-size: 20
    bold: true
  }
}
pg: "PostgreSQL — url_db" {
  style.fill: "#e8e0f0"
  style.stroke: "#7c3aed"
  style.border-radius: 6
  outbox_table: "outbox table" {
    shape: sql_table
    style.fill: "#f3eeff"
    id: "UUID (PK)"
    event_type: "TEXT (routing key)"
    payload: "JSONB (event struct)"
    created_at: "TIMESTAMPTZ"
    published_at: "TIMESTAMPTZ NULL"
  }
  idx: "idx_outbox_unpublished\n(partial: WHERE published_at IS NULL\nORDER BY created_at ASC)" {
    style.fill: "#ddd6fe"
    style.font-size: 12
    style.italic: true
  }
}
coordinator: "Coordinator Goroutine\n(1×)" {
  style.fill: "#e0f2fe"
  style.stroke: "#0369a1"
  style.border-radius: 8
  timer: "time.After(2s)\nper poll cycle" {
    shape: circle
    style.fill: "#bae6fd"
    style.stroke: "#0369a1"
    width: 130
    height: 130
  }
  query: |md
    **SELECT** id, event_type, payload
    FROM outbox
    WHERE published_at IS NULL
    ORDER BY created_at ASC
    LIMIT 50
    **FOR UPDATE SKIP LOCKED**
  | {
    style.fill: "#f0f9ff"
    style.stroke: "#0284c7"
    style.border-radius: 4
  }
  skip_locked_note: |md
    ⚠ **FOR UPDATE SKIP LOCKED**
    Prevents concurrent coordinators
    from double-publishing the same row
  | {
    style.fill: "#fff7ed"
    style.stroke: "#c2410c"
    style.font-size: 11
    style.border-radius: 4
  }
}
channel: "jobChan\n(buffered channel)" {
  shape: queue
  style.fill: "#fef9c3"
  style.stroke: "#ca8a04"
  style.font-size: 13
  cap: "capacity = 50\nOutboxEntry rows" {
    style.fill: "#fef08a"
    style.stroke: "#a16207"
    style.font-size: 11
    style.italic: true
  }
}
workers: "Worker Goroutines (3×)\nfor row := range jobChan" {
  style.fill: "#dcfce7"
  style.stroke: "#15803d"
  style.border-radius: 8
  w1: "Worker 1" {
    shape: rectangle
    style.fill: "#bbf7d0"
    style.stroke: "#16a34a"
    style.border-radius: 5
  }
  w2: "Worker 2" {
    shape: rectangle
    style.fill: "#bbf7d0"
    style.stroke: "#16a34a"
    style.border-radius: 5
  }
  w3: "Worker 3" {
    shape: rectangle
    style.fill: "#bbf7d0"
    style.stroke: "#16a34a"
    style.border-radius: 5
  }
}
rmq: "RabbitMQ\nExchange: url-shortener (topic)" {
  style.fill: "#fff7ed"
  style.stroke: "#ea580c"
  style.border-radius: 8
  exchange: "url-shortener\n(topic, durable)" {
    shape: hexagon
    style.fill: "#fed7aa"
    style.stroke: "#c2410c"
  }
  q_analytics: "analytics.clicks\n(durable queue)" {
    style.fill: "#ffedd5"
    style.stroke: "#ea580c"
    style.border-radius: 4
  }
  q_notify: "notifications.events\n(durable queue)" {
    style.fill: "#ffedd5"
    style.stroke: "#ea580c"
    style.border-radius: 4
  }
  exchange -> q_analytics: "url.clicked" {
    style.stroke: "#ea580c"
    style.stroke-dash: 3
  }
  exchange -> q_notify: "url.created\nurl.deleted\nmilestone.reached" {
    style.stroke: "#ea580c"
    style.stroke-dash: 3
  }
}
error_path: "RabbitMQ Unavailable Path" {
  style.fill: "#fef2f2"
  style.stroke: "#dc2626"
  style.border-radius: 6
  publish_err: "publisher.Publish()\nreturns error" {
    style.fill: "#fee2e2"
    style.stroke: "#dc2626"
    style.border-radius: 4
  }
  skip_update: "Skip UPDATE outbox\n(published_at stays NULL)" {
    style.fill: "#fca5a5"
    style.stroke: "#b91c1c"
    style.border-radius: 4
  }
  retry_note: |md
    Row remains in
    **unpublished** state →
    re-fetched next 2s cycle
  | {
    style.fill: "#fef2f2"
    style.stroke: "#dc2626"
    style.font-size: 11
    style.border-radius: 4
  }
  publish_err -> skip_update: "log.Warn()\nskip MarkPublished" {
    style.stroke: "#dc2626"
    style.bold: true
  }
  skip_update -> retry_note {
    style.stroke: "#dc2626"
    style.stroke-dash: 4
  }
}
mark_published: "UPDATE outbox\nSET published_at = now()\nWHERE id = row.ID" {
  style.fill: "#f0fdf4"
  style.stroke: "#16a34a"
  style.border-radius: 6
}
# Poll cycle trigger
coordinator.timer -> coordinator.query: "every 2s\ntime.After fires" {
  style.stroke: "#0369a1"
  style.bold: true
}
# Query to DB
coordinator.query -> pg.outbox_table: "SELECT … FOR UPDATE\nSKIP LOCKED\nLIMIT 50" {
  style.stroke: "#7c3aed"
  style.stroke-width: 2
  style.bold: true
}
# Index used
pg.idx -> pg.outbox_table: "covers unpublished\nrows lookup" {
  style.stroke: "#7c3aed"
  style.stroke-dash: 4
  style.font-size: 11
}
# DB returns rows to coordinator
pg.outbox_table -> coordinator.query: "up to 50 OutboxEntry rows\n(id, event_type, payload)" {
  style.stroke: "#7c3aed"
  style.stroke-dash: 5
}
# Coordinator feeds channel
coordinator.query -> channel: "jobChan <- row\n(blocks if channel full\n→ backpressure)" {
  style.stroke: "#ca8a04"
  style.stroke-width: 2
  style.bold: true
}
# Channel to workers
channel -> workers.w1: "range jobChan" {
  style.stroke: "#15803d"
  style.stroke-width: 2
}
channel -> workers.w2: "range jobChan" {
  style.stroke: "#15803d"
  style.stroke-width: 2
}
channel -> workers.w3: "range jobChan" {
  style.stroke: "#15803d"
  style.stroke-width: 2
}
# Workers publish to RabbitMQ (happy path)
workers.w1 -> rmq.exchange: "Publish(row.EventType,\nrow.Payload)\nContentType: application/json\nDeliveryMode: Persistent" {
  style.stroke: "#ea580c"
  style.stroke-width: 2
  style.bold: true
}
workers.w2 -> rmq.exchange: "Publish(…)" {
  style.stroke: "#ea580c"
  style.stroke-width: 2
}
workers.w3 -> rmq.exchange: "Publish(…)" {
  style.stroke: "#ea580c"
  style.stroke-width: 2
}
# Workers mark published (happy path)
workers.w1 -> mark_published: "on Publish() success\nMarkPublished(row.ID)" {
  style.stroke: "#16a34a"
  style.stroke-width: 2
}
workers.w2 -> mark_published {
  style.stroke: "#16a34a"
  style.stroke-width: 2
}
workers.w3 -> mark_published {
  style.stroke: "#16a34a"
  style.stroke-width: 2
}
# MarkPublished writes to DB
mark_published -> pg.outbox_table: "UPDATE outbox\nSET published_at = now()\nWHERE id = \$1" {
  style.stroke: "#7c3aed"
  style.stroke-width: 2
  style.bold: true
}
# Error path from workers
workers.w1 -> error_path.publish_err: "Publish() returns\nerror" {
  style.stroke: "#dc2626"
  style.stroke-dash: 5
  style.stroke-width: 2
}
# SKIP LOCKED note connection
coordinator.skip_locked_note -> coordinator.query {
  style.stroke: "#c2410c"
  style.stroke-dash: 4
  style.font-size: 10
}
legend: |md
  **Legend**
  - **Coordinator**: polls every 2s, sends rows to buffered channel
  - **Workers (3×)**: drain channel, publish, mark published
  - **FOR UPDATE SKIP LOCKED**: safe for multiple coordinator replicas
  - **Channel capacity = 50**: matches LIMIT 50 fetch; backpressure on slow workers
  - **Error path**: Publish fail → row stays NULL → retried next cycle
  - **At-least-once**: if MarkPublished fails after Publish, row re-published
| {
  near: bottom-center
  style.fill: "#f8fafc"
  style.stroke: "#94a3b8"
  style.border-radius: 6
  style.font-size: 11
}