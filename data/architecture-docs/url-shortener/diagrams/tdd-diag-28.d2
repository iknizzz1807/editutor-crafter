vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

direction: right

title: |'md
  ## IP Privacy Hashing Data Flow
  `handler/redirect.go` â†’ `hashIP()` â†’ `clicks.ip_hash`
'| {
  near: top-center
}

# 1. Input Sources
raw_ip: "Raw IP String\n'203.0.113.42'" {
  style.fill: "#ff6b6b"
  style.font-color: white
  style.bold: true
  style.border-radius: 4
}

gdpr_warn: |'md
  âš ï¸ **GDPR Article 4(1)**
  Raw IP is *personal data* â€”
  uniquely identifies a natural
  person's device/location.
  Storing raw IPs without
  lawful basis = violation.
  Max fine: â‚¬20M or 4% revenue.
'| {
  style.fill: "#fff0f0"
  style.stroke: "#ff6b6b"
  style.border-radius: 4
}

env_salt: "CLICK_SALT\nenv var\n(random bytes)" {
  style.fill: "#f39c12"
  style.font-color: white
  style.bold: true
  style.border-radius: 4
}

salt_warn: |'md
  ðŸ”‘ **Salt Purpose**
  Common IPs (e.g. 8.8.8.8) are 
  pre-computable. Rainbow tables
  reverse unsalted hashes.
  Salt = per-deployment secret.
  SHA-256(ip + salt) is infeasible
  to invert.
'| {
  style.fill: "#fef9e7"
  style.stroke: "#f39c12"
  style.border-radius: 4
}

# 2. Transformation Steps
step1: "Step 1: Concatenate\nip + salt\nâ†’ []byte" {
  shape: diamond
  style.fill: "#9b59b6"
  style.font-color: white
  style.bold: true
}

step1_code: |'go
  rawInput := ip + salt
  // "203.0.113.42" + "secret-salt-xyz"
  input := []byte(rawInput)
'| {
  style.fill: "#f5f0ff"
  style.stroke: "#9b59b6"
  style.border-radius: 4
}

step2: "Step 2: SHA-256\nsha256.Sum256(input)\nâ†’ [32]byte" {
  shape: diamond
  style.fill: "#2980b9"
  style.font-color: white
  style.bold: true
}

step2_code: |'go
  // crypto/sha256 â€” deterministic,
  // one-way, collision-resistant
  hash := sha256.Sum256(input)
'| {
  style.fill: "#eaf4fb"
  style.stroke: "#2980b9"
  style.border-radius: 4
}

# 2.5 Logic Bridge
step3: "Step 3: Hex Encode\nhex.EncodeToString(hash[:])\nâ†’ string (64 chars)" {
  shape: diamond
  style.fill: "#27ae60"
  style.font-color: white
  style.bold: true
}

step3_code: |'go
  ipHash := hex.EncodeToString(hash[:])
  // 32 bytes Ã— 2 hex chars = 64 chars
'| {
  style.fill: "#eafaf1"
  style.stroke: "#27ae60"
  style.border-radius: 4
}

# 3. Output/Sink
db_store: "clicks.ip_hash\nTEXT NOT NULL\n64-byte hex string" {
  style.fill: "#1a5276"
  style.font-color: white
  style.bold: true
  style.border-radius: 4
  style.multiple: true
}

size_note: |'md
  **Storage Characteristics**
  | Property        | Value            |
  |-----------------|------------------|
  | Input size      | variable (7â€“45B) |
  | Hash raw size   | 32 bytes fixed   |
  | Stored size     | **64 bytes fixed** |
  | Column type     | TEXT (not BYTEA) |
  | Reversible      | âŒ No            |
'| {
  style.fill: "#eaf2ff"
  style.stroke: "#1a5276"
  style.border-radius: 4
}

go_func: |'go
  func hashIP(rawIP string) string {
      salt := os.Getenv("CLICK_SALT")
      h := sha256.Sum256([]byte(rawIP + salt))
      return hex.EncodeToString(h[:])
  }
'| {
  near: bottom-center
  style.fill: "#fdfefe"
  style.stroke: "#7f8c8d"
  style.border-radius: 4
}

# 4. Connections & Association Links
gdpr_warn -> raw_ip: {
  style.stroke-dash: 3
  style.stroke: "#ff6b6b"
  style.opacity: 0.6
}

salt_warn -> env_salt: {
  style.stroke-dash: 3
  style.stroke: "#f39c12"
  style.opacity: 0.6
}

size_note -> db_store: {
  style.stroke-dash: 3
  style.stroke: "#1a5276"
  style.opacity: 0.6
}

raw_ip -> step1: "ip string" {
  style.stroke: "#ff6b6b"
  style.bold: true
}
env_salt -> step1: "salt secret" {
  style.stroke: "#f39c12"
  style.bold: true
}
step1 -> step1_code {
  style.stroke-dash: 3
  style.stroke: "#9b59b6"
}
step1 -> step2: "[]byte" {
  style.stroke: "#9b59b6"
  style.bold: true
}
step2 -> step2_code {
  style.stroke-dash: 3
  style.stroke: "#2980b9"
}
step2 -> step3: "[32]byte" {
  style.stroke: "#2980b9"
  style.bold: true
}
step3 -> step3_code {
  style.stroke-dash: 3
  style.stroke: "#27ae60"
}
step3 -> db_store: "64 hex chars" {
  style.stroke: "#27ae60"
  style.bold: true
  style.stroke-width: 3
}