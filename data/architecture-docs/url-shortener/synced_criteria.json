[
  {
    "module_id": "url-shortener-m1",
    "criteria": [
      "Monorepo layout exists: services/{url,analytics,user,notification}-service/, gateway/, shared/events/, docker-compose.yml at root",
      "Each service directory contains main.go, Dockerfile, go.mod with module path github.com/yourhandle/url-shortener/{service-name}",
      "docker-compose.yml declares five app containers, four PostgreSQL containers (url_db, analytics_db, user_db, notification_db) on separate host ports (5432-5435), one RabbitMQ container with management UI port 15672, and one Redis container on port 6379",
      "Each app service connects to its own DB on startup using pgxpool with MaxConns=10 MinConns=2 configured via environment variables; logs 'connected to DB' and exits non-zero if DB is unreachable",
      "url-service connects to Redis on startup and logs 'connected to Redis cache'; Redis unavailability does NOT crash the service (warning log only, nil client stored)",
      "RabbitMQ exchange 'url-shortener' of type 'topic' durable=true is declared on startup by url-service",
      "Queue 'analytics.clicks' durable is declared and bound to exchange 'url-shortener' with routing key 'url.clicked' by analytics-service",
      "Queue 'notifications.events' durable is declared and bound to exchange 'url-shortener' with routing keys 'url.created', 'url.deleted', 'milestone.reached' by notification-service",
      "shared/events/ package defines Go structs: URLCreatedEvent, URLClickedEvent, URLDeletedEvent, MilestoneReachedEvent — each with EventType string, OccurredAt time.Time, CorrelationID string, and domain-specific payload fields",
      "DomainEvent interface defined in shared/events with GetEventType() string and GetOccurredAt() time.Time methods; all four event structs satisfy this interface",
      "docker compose up brings all 11 containers to healthy state; docker compose down -v tears down cleanly; README documents both commands",
      "Each service has GET /health endpoint returning {\"status\":\"ok\",\"service\":\"<name>\"} with HTTP 200 and Content-Type: application/json",
      "Gateway startup loop health-checks all four downstream services and logs degraded state without crashing if any are unreachable",
      "No service uses localhost as a hostname in its Docker Compose environment variables; all inter-container references use Docker service names",
      "depends_on in docker-compose uses condition: service_healthy for all DB and broker dependencies",
      "No hardcoded credentials in any Go source file; all secrets come from environment variables via mustGetEnv",
      "Each PostgreSQL container is a separate container instance with its own named volume; no shared PostgreSQL instance",
      "Redis is not used as a primary data store in any service; only a PING healthcheck occurs during this milestone"
    ]
  },
  {
    "module_id": "url-shortener-m2",
    "criteria": [
      "users table exists in user_db with columns: id UUID PK, email TEXT UNIQUE NOT NULL, password_hash TEXT NOT NULL, created_at TIMESTAMPTZ DEFAULT now(); migration file at services/user-service/migrations/001_create_users.sql",
      "POST /register accepts {email, password}, validates email format using net/mail.ParseAddress and password length >= 8, hashes with bcrypt cost=12, returns 201 {user_id, email} — never returns the hash",
      "POST /register with duplicate email returns 409 Conflict with body {\"error\":\"email already registered\"}, not 500",
      "POST /register with invalid email format returns 400; POST /register with password < 8 chars returns 400",
      "POST /login accepts {email, password}, runs bcrypt.CompareHashAndPassword, returns 200 {token, expires_at} on success",
      "POST /login with wrong password returns 401 {\"error\":\"invalid credentials\"}; POST /login with unknown email returns identical 401 body — no distinction between the two cases",
      "JWT payload contains: sub (user_id UUID), email, iat, exp (iat + 86400s), iss \"url-shortener\"; signed with HS256 using JWT_SECRET environment variable",
      "GET /me requires Authorization: Bearer <token> header, verifies signature and expiry locally with no DB lookup, returns 200 {user_id, email} or 401",
      "GET /me returns 401 for expired tokens, 401 for invalid/tampered signatures, 401 for missing Authorization header",
      "JWT_SECRET is read from environment via mustGetEnv — no hardcoded secret anywhere in source; service exits non-zero if JWT_SECRET is unset or < 32 chars",
      "shared/middleware/jwt_middleware.go exports RequireAuth(verifier, log) middleware and ClaimsFromContext(ctx) helper, importable by other services",
      "shared/auth/ package defines JWTVerifier interface and Claims struct so shared/middleware does not create an import cycle with any service",
      "Timing attack mitigation: login for unknown email runs a dummy bcrypt compare to equalize response time with valid-email-wrong-password path",
      "UserRepository interface defines Create and FindByEmail; pgxUserRepository maps pgx error code 23505 to ErrDuplicateEmail and pgx.ErrNoRows to ErrUserNotFound",
      "bcryptHasher uses golang.org/x/crypto/bcrypt with cost=12; Hash returns error on failure; Compare returns ErrPasswordMismatch for mismatches",
      "Integration test covering full round trip: register → login → GET /me passes end-to-end against live user_db container",
      "POST /register p99 < 200ms; POST /login p99 < 200ms; GET /me p99 < 5ms (no DB call); JWT Verify < 1ms",
      "http.MaxBytesReader limits request body to 1024 bytes on /register and /login to prevent DoS via oversized payloads",
      "All error responses use Content-Type: application/json and the ErrorResponse{Error: string} struct; 500 responses log the full error server-side but return only \"internal server error\" to the client",
      "No global state in handler, service, or repository packages; all dependencies injected via constructors; UserService, bcryptHasher, jwtSigner, jwtVerifier are all safe for concurrent use"
    ]
  },
  {
    "module_id": "url-shortener-m3",
    "criteria": [
      "urls table exists with columns: id UUID PK, short_code VARCHAR(10) UNIQUE NOT NULL, original_url TEXT NOT NULL, user_id UUID NOT NULL, created_at TIMESTAMPTZ DEFAULT now(), expires_at TIMESTAMPTZ NULLABLE, is_active BOOLEAN DEFAULT true; indexes idx_urls_short_code and idx_urls_user_id_created present",
      "outbox table exists with columns: id UUID PK, event_type TEXT, payload JSONB, created_at TIMESTAMPTZ, published_at TIMESTAMPTZ NULLABLE; partial index idx_outbox_unpublished on (created_at ASC) WHERE published_at IS NULL",
      "POST /shorten requires valid JWT (verified locally); accepts {url, custom_code?, expires_at?}; validates URL has scheme + host; returns 201 {short_code, short_url, original_url, expires_at}",
      "Short code generation uses crypto/rand (not math/rand); 7-character base62 alphabet; collision retry up to 5 times; returns 503 after exhaustion",
      "URL creation and URLCreatedEvent outbox insert occur in a single PostgreSQL transaction — they commit or rollback together",
      "GET /:code implements read-through cache: check Redis key 'url:{short_code}' first (TTL = min(expires_at - now, 1h)); on miss query PostgreSQL and populate cache; Redis error falls through to DB silently — never causes redirect failure",
      "Redis cache entry stores JSON {original_url, expires_at, is_active}; TTL is always set (never cache with no expiry)",
      "GET /:code returns 301 for active non-expired URLs, 404 for non-existent codes, 410 for expired URLs (expires_at < now), 410 for inactive URLs (is_active=false)",
      "Every redirect writes a URLClickedEvent to the outbox (with EventID UUID for idempotency); click and outbox write occur in a single transaction",
      "GET /urls uses cursor-based pagination (after=<uuid>) not LIMIT/OFFSET; query uses idx_urls_user_id_created (no sequential scan); returns {urls: [...], next_cursor?: UUID}",
      "DELETE /urls/:code (auth required, owner only) sets is_active=false and publishes URLDeletedEvent via outbox in a single transaction; invalidates Redis cache key 'url:{short_code}' after commit (best-effort); returns 403 if JWT sub != url.user_id",
      "Outbox poller runs as coordinator goroutine + 3 worker goroutines via buffered channel (capacity 50); coordinator polls every 2s for unpublished rows (LIMIT 50); workers publish to RabbitMQ and mark published_at; RabbitMQ unavailability is handled gracefully (retry next cycle, service stays up)",
      "AMQPPublisher uses sync.Mutex to serialize concurrent Publish calls from worker goroutines; publishes with DeliveryMode=Persistent",
      "CacheClient is nil-safe: nil *redis.Client returns ErrCacheMiss from Get and is a no-op for Set and Del — Redis unavailability never panics",
      "URLService.Delete calls cache.Del AFTER tx.Commit (not before); cache invalidation failure is logged but does not fail the request",
      "Redirect handler benchmark: GET /:code cache hit < 5ms p99 at 100 concurrent requests; cache miss < 20ms p99",
      "Unit tests: TestGenerate_Length, TestGenerate_Base62Alphabet, TestGenerate_Randomness, TestShorten_CollisionRetry, TestShorten_CollisionExhausted all pass",
      "Integration test: create URL → redirect → verify outbox row published_at IS NOT NULL within 4 seconds",
      "No import of math/rand in codegen package; verified by go vet and test",
      "go test -race ./... passes with no race conditions detected"
    ]
  },
  {
    "module_id": "url-shortener-m4",
    "criteria": [
      "clicks table exists in analytics_db with columns: id UUID PK, short_code TEXT NOT NULL, clicked_at TIMESTAMPTZ NOT NULL, ip_hash TEXT NOT NULL, user_agent TEXT NOT NULL DEFAULT '', referer TEXT NULL",
      "idx_clicks_short_code_time index exists on clicks(short_code, clicked_at DESC)",
      "idx_clicks_referer partial index exists on clicks(short_code, referer) WHERE referer IS NOT NULL",
      "milestones table exists with UNIQUE constraint on (short_code, milestone)",
      "processed_events table exists with event_id UUID PRIMARY KEY",
      "RabbitMQ consumer subscribes to queue 'analytics.clicks' bound to exchange 'url-shortener' with routing key 'url.clicked'",
      "Consumer declares its own queue and binding on startup (not relying on url-service to declare analytics.clicks)",
      "Consumer sets Qos prefetch=1 before consuming",
      "URLClickedEvent is processed by: (1) IsProcessed check, (2) MarkProcessed + Insert click in single transaction, (3) milestone detection after commit",
      "Duplicate URLClickedEvent with same event_id results in exactly 1 row in clicks table (idempotency via processed_events)",
      "Duplicate URLClickedEvent returns ProcessResultDuplicate and is ACKed without DB insert",
      "Malformed JSON message is ACKed (not NACKed/requeued) and logged at error level",
      "Malformed JSON never crashes the consumer goroutine",
      "Consumer goroutine is supervised: panics are recovered, goroutine restarts after 5s",
      "GET /health returns 200 {status:ok, service:analytics-service} even when RabbitMQ is down",
      "Milestone thresholds are 10, 100, 1000 clicks per short_code",
      "MilestoneReachedEvent is published to exchange 'url-shortener' with routing key 'milestone.reached' when threshold is crossed",
      "MilestoneReachedEvent includes: short_code, user_id, user_email, milestone (int), total_clicks, correlation_id, occurred_at",
      "Milestone publish failure logs a warning but does not roll back the click insert transaction",
      "Milestone row is saved in milestones table even if publish fails",
      "GET /stats/:code returns 200 with: short_code, total_clicks, clicks_last_24h, clicks_last_7d, top_referers (up to 5, empty array not null)",
      "GET /stats/:code uses concurrent errgroup queries for total, last_24h, last_7d, top_referers",
      "GET /stats/:code/timeline?interval=day|hour returns {short_code, interval, points:[{period, clicks}]} ordered oldest-first",
      "GET /stats/:code/timeline uses PostgreSQL date_trunc for bucketing",
      "GET /stats/:code/timeline with invalid interval returns 400",
      "GET /stats/:code/timeline defaults to interval=day when param is absent",
      "Stats endpoints require no authentication (public)",
      "Analytics service never calls url-service or any other service at runtime",
      "Raw IP addresses are never stored; only ip_hash from URLClickedEvent is persisted",
      "clicked_at stores URLClickedEvent.OccurredAt (event time), not ingestion time",
      "top_referers excludes clicks where referer IS NULL",
      "Timeline points array is empty array (not null) when no clicks exist",
      "EXPLAIN on CountByCode query shows Index Scan on idx_clicks_short_code_time",
      "GET /stats/:code p99 latency < 30ms with real indexed DB",
      "GET /stats/:code/timeline p99 latency < 50ms",
      "Click ingestion lag < 500ms from RabbitMQ publish to DB insert under normal load"
    ]
  },
  {
    "module_id": "url-shortener-m5",
    "criteria": [
      "Notification Service consumes url.created, url.deleted, and milestone.reached events from notifications.events queue; each event inserts one row into notifications table with status=sent and logs 'would send email to user: <message>'",
      "Notification consumer is idempotent: duplicate delivery of same event (same routing_key + correlation_id key) results in exactly one notifications row; second delivery returns ProcessResultDuplicate",
      "Poison messages (malformed JSON, unknown routing key, missing user_id) are ACKed and never requeued; consumer loop never panics",
      "GET /notifications requires valid JWT; returns only notifications belonging to the authenticated user's sub claim; cursor-paginated with next_cursor field",
      "GET /notifications returns 401 for missing or invalid JWT; cross-user access returns empty array not 403",
      "API Gateway routes all specified paths to correct downstream services: POST /api/auth/register → user-service, POST /api/auth/login → user-service, GET /r/{code} → url-service, POST /api/shorten → url-service, GET /api/urls → url-service, DELETE /api/urls/{code} → url-service, GET /api/stats/{code} → analytics-service, GET /api/notifications → notification-service",
      "Gateway validates JWT locally (HMAC-SHA256) for all /api/* routes except /api/auth/*; invalid or missing JWT returns 401 before request reaches downstream; no call to user-service for token validation",
      "Gateway enforces per-IP token-bucket rate limiting via Redis: POST /api/shorten allows 10 requests/minute per IP; 11th request returns 429 with Retry-After header; GET /r/{code} allows 300 requests/minute per IP",
      "Rate limiter fails open when Redis is unavailable: requests are allowed and a warning is logged; no traffic is blocked due to Redis outage",
      "Circuit breaker for url-service implements three states (Closed, Open, HalfOpen): trips to Open after 5 consecutive failures within 10s; returns 503 {error: service unavailable} while Open; transitions to HalfOpen after 30s; returns to Closed on successful probe",
      "Circuit breaker HalfOpen state allows exactly one concurrent probe request; all other concurrent requests during HalfOpen are rejected with 503",
      "Gateway adds X-Correlation-ID header (UUID v4, generated if absent) to every forwarded request; echoes the header in the response; all services log this ID in every log line for that request",
      "All services emit structured JSON logs with fields: level, time, service, correlation_id, method, path, status, duration_ms, msg; no fmt.Println in HTTP handlers",
      "X-Correlation-ID propagates through async event payloads: correlation_id appears in notification-service and analytics-service log lines for events triggered by a gateway request",
      "Gateway proxy adds < 2ms overhead p99; circuit breaker Allow() check completes in < 1µs; rate limit check (Redis Lua INCR) completes in < 3ms p99",
      "End-to-end test passes: register → login → shorten → redirect → check /api/stats → check /api/notifications all through gateway with correlation ID visible in all service logs",
      "Rate limit integration test: POST /api/shorten 11 times from same IP via gateway → first 10 return 201, 11th returns 429 with Retry-After header",
      "Gateway /health returns {status: ok, service: gateway} with 200; gateway starts regardless of downstream health (warnings logged for unhealthy downstreams)",
      "No business logic in gateway: gateway code contains no domain terms (short_code computation, click counting, password hashing, URL validation beyond routing)",
      "Notification service GET /notifications response never includes raw event payload; response contains only id, event_type, status, created_at, sent_at fields"
    ]
  }
]