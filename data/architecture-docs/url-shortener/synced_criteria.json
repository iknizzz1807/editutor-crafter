[
  {
    "module_id": "url-shortener-m1",
    "criteria": [
      "Monorepo layout exists: services/{url,analytics,user,notification}-service/, gateway/, shared/events/, shared/logger/, docker-compose.yml at root",
      "Each service directory contains main.go, Dockerfile, go.mod with module path github.com/yourhandle/url-shortener/{service-name}",
      "go.work file at root references all modules; go build ./... exits 0",
      "docker-compose.yml declares five app containers (4 services + 1 gateway), four PostgreSQL containers (url_db, analytics_db, user_db, notification_db) on ports 5432-5435, one RabbitMQ container with management UI on 5672/15672, one Redis container on 6379",
      "Each app service connects to its own DB on startup using pgxpool with MaxConns=10 MinConns=2 configured via DATABASE_URL environment variable",
      "Service logs 'connected to DB' on successful pgxpool.Ping and exits non-zero if DB is unreachable on startup",
      "url-service connects to Redis via REDIS_URL; logs 'connected to Redis cache' on success; Redis unavailability logs a warning and does NOT crash the service",
      "RabbitMQ exchange 'url-shortener' of type 'topic' declared durable by url-service on startup",
      "Queue 'analytics.clicks' declared durable by analytics-service with binding to routing key 'url.clicked'",
      "Queue 'notifications.events' declared durable by notification-service with bindings to routing keys 'url.created', 'url.deleted', 'milestone.reached'",
      "shared/events package defines URLCreatedEvent, URLClickedEvent, URLDeletedEvent, MilestoneReachedEvent structs each with EventType, OccurredAt, CorrelationID, EventID in BaseEvent plus payload fields",
      "shared/logger package provides New(serviceName string) *slog.Logger emitting structured JSON to stdout with 'service' field on every line",
      "All environment variables are read once at startup into a Config struct; os.Getenv is never called in handler or hot-path code",
      "Missing required environment variable (DATABASE_URL, RABBITMQ_URL) causes fatal log and os.Exit(1) with descriptive error naming the missing variable",
      "docker compose up --build brings all containers to healthy state within 60 seconds",
      "GET /health on each service returns HTTP 200 with JSON body {\"status\":\"ok\",\"service\":\"<name>\"} where name matches service identity constant",
      "docker compose down -v tears down all containers and volumes cleanly with exit 0",
      "README documents docker compose up and docker compose down -v commands with all service port mappings",
      "Health handler pre-encodes response body once at startup; no per-request json.Marshal allocation",
      "RabbitMQ connection retries with exponential backoff (doubling from 1s, max 30s) and logs each attempt with attempt number and backoff duration"
    ]
  },
  {
    "module_id": "url-shortener-m2",
    "criteria": [
      "users table exists in user_db with columns: id UUID PK DEFAULT gen_random_uuid(), email TEXT UNIQUE NOT NULL, password_hash TEXT NOT NULL, created_at TIMESTAMPTZ NOT NULL DEFAULT now(); unique index idx_users_email exists on email column",
      "POST /register accepts {email, password}, validates email format (regex: ^[^@s]+@[^@s]+.[^@s]+$) and password length >= 8, returns 201 {user_id, email} on success; password_hash never appears in any response body",
      "POST /register returns 409 Conflict when email already exists (caught via PostgreSQL error code 23505), not 500",
      "POST /register returns 400 with field='email' when email format is invalid; 400 with field='password' when password < 8 characters",
      "POST /login accepts {email, password}, calls bcrypt.CompareHashAndPassword, returns 200 {token, expires_at (RFC3339)} on success",
      "POST /login returns 401 with message 'invalid credentials' for both unknown email and wrong password; response body is identical for both cases (email enumeration prevention); dummy bcrypt compare is performed on unknown email path",
      "JWT payload contains: sub (user_id UUID), email, iss='url-shortener', iat (Unix), exp (Unix, iat + 24h default); signed with HS256 using JWT_SECRET environment variable",
      "JWT_SECRET is read from environment variable at startup via loadConfig(); loadConfig() returns error if JWT_SECRET is empty; service exits with non-zero code on missing JWT_SECRET",
      "GET /me verifies JWT signature and expiry locally using JWTMiddleware from shared/auth package (no DB lookup); returns 200 {user_id, email} on valid token; returns 401 on missing/invalid/expired token",
      "shared/auth package exports: Claims struct (Sub, Email, Iss, Iat, Exp fields), TokenIssuer interface (Issue, Verify methods), VerifyToken standalone function, JWTMiddleware func(http.Handler) http.Handler, ClaimsFromContext function; ErrTokenInvalid sentinel error",
      "JWTMiddleware rejects requests missing Authorization header with 401; rejects non-Bearer scheme with 401; returns 401 for expired tokens without revealing expiry reason",
      "JWT verification rejects tokens with non-HMAC signing method (algorithm confusion attack prevention): key function checks token.Method is *jwt.SigningMethodHMAC",
      "bcrypt cost is configurable via BCRYPT_COST environment variable (range [10,14]); defaults to 12; invalid values cause fatal startup error",
      "Integration test covers full round trip: register -> login -> GET /me -> verify user_id and email match; duplicate email returns 409; wrong password returns 401",
      "All handlers use structured JSON logging via shared/logger package; plaintext passwords and bcrypt hashes never appear in log output",
      "UserRepository interface (Insert, FindByEmail) and PasswordHasher interface (Hash, Verify) are defined at the consumer; pgxUserStore and bcryptHasher are unexported implementations",
      "Database queries use named functions in a Store struct (pgxUserStore); no inline SQL in handler methods",
      "GET /me responds in < 2ms p99 under load (local JWT verify, no DB call); measurable with wrk"
    ]
  },
  {
    "module_id": "url-shortener-m3",
    "criteria": [
      "urls table exists with columns: id UUID PK, short_code VARCHAR(10) UNIQUE NOT NULL, original_url TEXT NOT NULL, user_id UUID NOT NULL, created_at TIMESTAMPTZ, expires_at TIMESTAMPTZ NULLABLE, is_active BOOLEAN DEFAULT true",
      "outbox table exists with columns: id UUID PK, event_type TEXT NOT NULL, payload JSONB NOT NULL, created_at TIMESTAMPTZ NOT NULL, published_at TIMESTAMPTZ NULLABLE",
      "idx_urls_short_code index exists on urls(short_code)",
      "idx_urls_user_id_created index exists on urls(user_id, created_at DESC)",
      "idx_outbox_unpublished partial index exists on outbox(created_at ASC) WHERE published_at IS NULL",
      "POST /shorten requires valid JWT (verified locally via shared/auth JWTMiddleware)",
      "POST /shorten accepts {url, custom_code?, expires_at?} and validates URL has scheme (http/https) and host",
      "POST /shorten returns 422 for invalid URL format (missing scheme, missing host, non-http scheme)",
      "POST /shorten returns 422 for expires_at in the past or malformed RFC3339",
      "POST /shorten returns 201 {short_code, short_url, original_url, expires_at} on success",
      "Short code generation uses crypto/rand (not math/rand) to produce 7-character base62 codes",
      "Base62 alphabet is exactly '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' (62 chars)",
      "Generated short codes are always exactly 7 characters in length",
      "Custom code conflict returns 409 without retry",
      "Auto-generated code collision retries up to 5 times, returns 503 after all 5 fail",
      "POST /shorten inserts URL record and outbox event in a single atomic database transaction",
      "outbox row has event_type='url.created', payload contains URLCreatedEvent JSON with EventID, CorrelationID, user_email",
      "GET /:code checks Redis cache first using key 'url:{short_code}'",
      "GET /:code Redis hit serves 301 redirect without querying PostgreSQL",
      "GET /:code Redis miss queries PostgreSQL and populates Redis cache with TTL = min(expires_at - now, 1h)",
      "GET /:code Redis errors are non-fatal: logged at Warn level, fall through to PostgreSQL",
      "GET /:code returns 301 Location: original_url for active, non-expired URLs",
      "GET /:code returns 404 for non-existent short codes",
      "GET /:code returns 410 for URLs where is_active=false",
      "GET /:code returns 410 for URLs where expires_at < now()",
      "GET /:code inserts URLClickedEvent into outbox (separate transaction, non-fatal on failure)",
      "CachedURL struct contains {original_url, expires_at, is_active} — sufficient to serve redirect without DB hit",
      "GET /urls requires valid JWT, returns paginated {urls: [...], next_cursor: uuid|null}",
      "GET /urls implements cursor-based pagination using after=<uuid> query param, not LIMIT/OFFSET",
      "GET /urls query plan uses idx_urls_user_id_created (verified via EXPLAIN ANALYZE)",
      "DELETE /urls/:code requires valid JWT and verifies URL ownership (user_id match)",
      "DELETE /urls/:code returns 403 if authenticated user is not the URL owner",
      "DELETE /urls/:code returns 404 if short code does not exist",
      "DELETE /urls/:code sets is_active=false, inserts URLDeletedEvent into outbox, and invalidates Redis cache in a single transaction (cache invalidation post-commit)",
      "DELETE /urls/:code Redis cache invalidation is best-effort: failure logged but does not fail the 204 response",
      "Outbox coordinator goroutine polls outbox every 2 seconds for unpublished rows (published_at IS NULL)",
      "Outbox coordinator uses SELECT FOR UPDATE SKIP LOCKED to prevent duplicate processing",
      "Outbox coordinator sends rows to buffered channel (capacity=50), not directly to workers",
      "Exactly 3 outbox worker goroutines read from the buffered channel",
      "Each worker independently publishes to RabbitMQ using routing key = event_type and marks published_at on success",
      "Worker leaves published_at NULL and logs Warn on RabbitMQ publish failure (row retried on next poll)",
      "Worker does NOT call MarkPublished if Publish fails",
      "amqpPublisher uses sync.Mutex to protect concurrent channel access from multiple workers",
      "All messages published with DeliveryMode=amqp.Persistent",
      "Outbox coordinator and workers shut down gracefully on context cancellation: channel closed, wg.Wait() called",
      "RedisCache.Del is called after successful DELETE transaction commit (best-effort, outside tx)",
      "X-Correlation-ID is read from request header, generated if absent, injected into context, and included in all outbox event payloads",
      "All Redis operations use context.WithTimeout (50ms for GET, 100ms for SET/DEL)",
      "Config struct has JWTSecret, ShortURLBase, OutboxPollInterval (default 2s), OutboxWorkerCount (default 3)",
      "benchmark: GET /:code cache hit p99 < 5ms under 100 concurrent requests",
      "EXPLAIN ANALYZE on GET /urls query shows Index Scan using idx_urls_user_id_created (not Seq Scan)",
      "unit tests pass: TestBase62RoundTrip, TestBase62Length, TestBase62Alphabet, TestShortCodeLength, TestShortCodeAlphabet, TestShortCodeUniqueness",
      "unit tests pass: TestValidateURL with all valid/invalid cases",
      "unit tests pass: TestRedisCache_GetMiss, TestRedisCache_SetThenGet, TestRedisCache_Del, TestRedisCache_TTL_WithExpiry, TestRedisCache_ErrorIsolation",
      "unit tests pass: TestShortenHandler_Success, TestShortenHandler_InvalidURL, TestShortenHandler_CustomCodeConflict, TestShortenHandler_AutoCodeCollisionExhausted",
      "unit tests pass: TestRedirectHandler_CacheHit_Active, TestRedirectHandler_CacheMiss_NotFound, TestRedirectHandler_CacheMiss_Expired",
      "unit tests pass: TestDeleteHandler_Success, TestDeleteHandler_NotFound, TestDeleteHandler_WrongOwner",
      "unit tests pass: TestOutboxWorker_PublishAndMark, TestOutboxWorker_PublishFail_NoMark",
      "docker compose up: url-service connects to url_db, redis, rabbitmq; RabbitMQ exchange 'url-shortener' visible in management UI"
    ]
  },
  {
    "module_id": "url-shortener-m4",
    "criteria": [
      "clicks table created with columns: id UUID PK, short_code TEXT NOT NULL, clicked_at TIMESTAMPTZ NOT NULL, ip_hash TEXT NOT NULL, user_agent TEXT NOT NULL DEFAULT '', referer TEXT NULL",
      "milestones table created with columns: id UUID PK, short_code TEXT NOT NULL, milestone INT NOT NULL, triggered_at TIMESTAMPTZ NOT NULL DEFAULT now(), UNIQUE(short_code, milestone)",
      "processed_events table created with event_id TEXT PRIMARY KEY and processed_at TIMESTAMPTZ NOT NULL DEFAULT now()",
      "idx_clicks_short_code_time index exists on clicks(short_code, clicked_at DESC)",
      "idx_clicks_referer partial index exists on clicks(short_code, referer) WHERE referer IS NOT NULL",
      "idx_milestones_code_milestone unique index exists on milestones(short_code, milestone)",
      "RabbitMQ consumer subscribes to queue 'analytics.clicks' bound to exchange 'url-shortener' with routing key 'url.clicked'",
      "Consumer sets AMQP prefetch count to 1 (QoS) before consuming",
      "Consumer uses manual acknowledgement (autoAck=false)",
      "Malformed JSON message body is logged as poison message and Acked (not Nacked) to prevent requeue loop",
      "Consumer panic is recovered via defer/recover and message is Acked",
      "Duplicate URLClickedEvent with same event_id is detected via processed_events table, Acked, and does not insert a duplicate click row",
      "Click insert, processed_event insert, and milestone insert all occur within a single database transaction",
      "DB error on click insert results in tx.Rollback() and d.Nack(false, requeue=true)",
      "ip_hash stored in clicks table is read directly from URLClickedEvent.IPHash (not re-hashed in analytics-service)",
      "MilestoneChecker checks thresholds [10, 100, 1000] in ascending order using COUNT(*) on clicks table within the active transaction",
      "MilestoneChecker uses HasMilestone to skip already-recorded thresholds (idempotent via ON CONFLICT DO NOTHING)",
      "MilestoneReachedEvent is published to RabbitMQ exchange 'url-shortener' with routing key 'milestone.reached' when a new threshold is crossed",
      "MilestoneReachedEvent publish failure is logged at Warn level and does not cause transaction rollback or message Nack",
      "GET /stats/:code returns {short_code, total_clicks, clicks_last_24h, clicks_last_7d, top_referers} with HTTP 200, no authentication required",
      "GET /stats/:code returns top_referers as JSON array [] (never null) with at most 5 entries ordered by count DESC",
      "GET /stats/:code returns HTTP 200 with zeroed stats for unknown short codes (does not call url-service to validate)",
      "GET /stats/:code runs total, last-24h, last-7d, and top-referers queries concurrently (errgroup or equivalent)",
      "GET /stats/:code/timeline?interval=day returns [{period: RFC3339, clicks: int}] bucketed using PostgreSQL date_trunc('day', clicked_at AT TIME ZONE 'UTC')",
      "GET /stats/:code/timeline?interval=hour returns buckets using date_trunc('hour', ...)",
      "GET /stats/:code/timeline with interval not in {day, hour} returns 400 Bad Request",
      "GET /health returns {status:'ok', service:'analytics-service'} with HTTP 200 even when RabbitMQ consumer is paused",
      "Test: send URLClickedEvent twice with identical event_id; assert click count = 1 (primary acceptance criterion)",
      "Test: send 10 URLClickedEvents for same short_code; assert milestones table contains exactly one row with milestone=10",
      "Analytics service does not connect to url_db, user_db, or notification_db",
      "Analytics service does not call url-service HTTP API (trusts events)",
      "All log output uses structured JSON via shared/logger package; no fmt.Println in production code"
    ]
  },
  {
    "module_id": "url-shortener-m5",
    "criteria": [
      "Notification Service: notifications table created with correct schema (id UUID PK, user_id UUID, event_type TEXT, payload JSONB, status TEXT DEFAULT 'sent', created_at TIMESTAMPTZ, sent_at TIMESTAMPTZ NULL) and idx_notifications_user_created index on (user_id, created_at DESC)",
      "Notification Service: RabbitMQ consumer subscribes to 'notifications.events' queue with autoAck=false and prefetch=1; processes url.created, url.deleted, milestone.reached routing keys",
      "Notification Service: each consumed event inserts a notifications row with status='pending', calls mockEmail() (logs 'would send email to <user>: <message>'), updates status='sent' and sent_at — all in a single transaction",
      "Notification Service: malformed JSON event body is Acked (not Nacked) with error log; consumer does not crash or block queue",
      "Notification Service: unknown routing key is Acked with Warn log; no insert occurs",
      "Notification Service: missing user_id in event payload is Acked with error log; no insert occurs",
      "Notification Service: GET /notifications requires valid JWT (verified locally, no user-service call); returns 401 on missing or invalid token",
      "Notification Service: GET /notifications returns caller's notifications sorted by created_at DESC, paginated with cursor-based pagination (after=<uuid> query param); response shape {notifications: [...], next_cursor: string|null}",
      "Notification Service: notifications array in response is always [] (never null) when empty; next_cursor is null when no more pages",
      "Notification Service: GET /health returns 200 {status:'ok', service:'notification-service'} even when RabbitMQ consumer is paused",
      "Notification Service: never calls url-service, analytics-service, or user-service — all needed context (user_id, user_email, short_code) comes from the event payload",
      "API Gateway: routing table implements all specified routes: POST /api/auth/register and /login → user-service (no auth); POST /api/shorten → url-service (auth, rate-limit:10/min); GET /api/urls → url-service (auth); DELETE /api/urls/* → url-service (auth); GET /r/* → url-service (no auth, rate-limit:300/min); GET /api/stats/* → analytics-service (no auth); GET /api/notifications → notification-service (auth)",
      "API Gateway: unknown path returns 404 {error:'not found'}",
      "API Gateway: JWT middleware verifies tokens locally (HMAC-SHA256 with JWT_SECRET env var) on all /api/* routes except /api/auth/*; returns 401 before forwarding on invalid/missing token",
      "API Gateway: rate limiter uses Redis INCR + EXPIRE (window=60s); POST /api/shorten: 10 req/min per IP; GET /r/*: 300 req/min per IP; 11th POST /api/shorten from same IP returns 429 with Retry-After: 60 header",
      "API Gateway: Redis error in rate limiter causes fail-open (request allowed through) with Warn log; never returns 5xx to client for Redis failure",
      "API Gateway: circuit breaker protects url-service only; implements three-state machine (CLOSED, OPEN, HALF_OPEN) with sync.Mutex protecting all state; opens after 5 consecutive failures within 10s; stays OPEN for 30s; transitions to HALF_OPEN after openTimeout; one probe request in HALF_OPEN; success → CLOSED, failure → OPEN",
      "API Gateway: circuit OPEN returns 503 {error:'service unavailable'} immediately without calling upstream",
      "API Gateway: HTTP 4xx responses from url-service do NOT count as circuit breaker failures; only 5xx and network errors count",
      "API Gateway: other upstreams (analytics, user, notification) are NOT affected by url-service circuit breaker",
      "API Gateway: CorrelationIDMiddleware reads X-Correlation-ID header (generates UUID v4 if absent), stores in context, echoes as X-Correlation-ID response header, forwards to upstream via request header",
      "API Gateway: gateway startup health-checks all four downstream services; logs Warn if any are unhealthy but starts regardless",
      "API Gateway: contains zero domain logic — no imports of shared/events, no knowledge of URLRecord, short_code, or click data structures",
      "API Gateway: GET /health returns 200 {status:'ok', service:'gateway'}",
      "shared/logger: WithCorrelationID(log, id) returns derived *slog.Logger with correlation_id field attached to all log lines",
      "shared/logger: RequestLogger middleware emits one structured JSON log line per request with fields: time, level, service, correlation_id, method, path, status, duration_ms",
      "shared/logger: ContextWithCorrelationID and CorrelationIDFromContext enable context-based ID propagation across service layers",
      "All services emit structured JSON logs (no fmt.Println in handlers); every log line for a request includes correlation_id",
      "X-Correlation-ID propagates through async boundary: event payloads carry CorrelationID field; analytics and notification services include correlation_id in their log lines for processed events",
      "End-to-end test passes: register → login → shorten → redirect → stats → notifications — all through gateway; correlation_id found in gateway, url-service, analytics-service, and notification-service logs for the same request",
      "Rate limit test: 11th POST /api/shorten from same IP within 60s returns 429 with Retry-After: 60 header",
      "docker compose up --build brings all containers healthy; docker compose down -v teardown is clean"
    ]
  }
]