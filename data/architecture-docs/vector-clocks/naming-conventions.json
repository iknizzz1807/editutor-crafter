{
  "types": {
    "NodeID": "fields: id str",
    "ClusterMembership": "fields: _nodes Set[NodeID], _node_indices Dict[NodeID, int]",
    "CausalityRelation": "enum: HAPPENS_BEFORE, HAPPENS_AFTER, CONCURRENT, IDENTICAL",
    "VectorClock": "fields: owner_id NodeID, _vector Dict[NodeID, int]",
    "VersionedValue": "fields: value Any, vector_clock VectorClock, timestamp datetime, node_id NodeID",
    "VersionStore": "fields: _storage Dict[str, List[VersionedValue]], _max_versions int",
    "StorageMetrics": "fields: total_versions int, versions_per_key Dict[str, int], total_memory_bytes int",
    "PruningConfig": "fields: max_versions_per_key int, enable_dominated_pruning bool, memory_pressure_threshold_mb int",
    "VersionPruner": "fields: config PruningConfig, metrics StorageMetrics",
    "MemoryOptimizer": "fields: config PruningConfig, metrics StorageMetrics, departed_nodes Set[str]",
    "NetworkMessage": "fields: message_id str, sender_id str, message_type str, vector_clock Dict[str, int], payload Dict[str, Any], timestamp str",
    "DistributedNode": "fields: node_id str, cluster_nodes List[str], port int",
    "HTTPTransport": "fields: local_address str, port int, timeout float",
    "ReliableReplicator": "fields: transport, node_id str, pending_operations Dict",
    "ReplicationOperation": "fields: operation_id str, target_nodes List[str], message Any",
    "ReplicationStatus": "enum: PENDING, SUCCESS, FAILED, TIMEOUT",
    "ReadRepairManager": "fields: node_id str, version_store VersionStore, resolution_strategy ConflictResolutionStrategy",
    "ConflictResolutionStrategy": "enum: LAST_WRITER_WINS, APPLICATION_MERGE, CLIENT_MEDIATED",
    "NodeStatus": "enum: HEALTHY, SUSPECTED, FAILED, RECOVERING",
    "HeartbeatConfig": "fields: interval_seconds float, timeout_multiplier int, grace_period_seconds int, max_consecutive_failures int",
    "NodeHealthInfo": "fields: node_id str, status NodeStatus, last_heartbeat float, consecutive_failures int, partition_id Optional[str]",
    "PartitionContext": "fields: partition_id str, reachable_nodes Set[str], partition_start_time float, operation_log List[str]",
    "FailureDetector": "fields: local_node_id str, config HeartbeatConfig, node_health Dict[str, NodeHealthInfo]",
    "PartitionHandler": "fields: node_id str, cluster_nodes Set[str], partition_mode bool, current_partition Optional[PartitionContext]",
    "RecoveryManager": "fields: node_id str, version_store VersionStore, recovery_in_progress bool",
    "TestCluster": "utility class for managing test node clusters",
    "NetworkSimulator": "utility class for simulating network conditions",
    "CausalityVerifier": "utility class for verifying causality relationships",
    "NetworkPartition": "utility class for simulating network partitions",
    "VectorClockLogger": "fields: node_id str, logger Logger",
    "LogLevel": "enum: TRACE_VECTOR_CLOCK, DEBUG_CAUSALITY, INFO_CONFLICT, WARN_VIOLATION, ERROR_CORRUPTION",
    "VectorClockInspector": "cmd.Cmd subclass for interactive debugging",
    "VectorClockPropertyTests": "property-based test class",
    "IntervalTreeClock": "fields: id_tree ITCTree, event_tree ITCTree",
    "ITCTree": "fields: node_type ITCNodeType, value int, left_child ITCTree, right_child ITCTree",
    "ITCNodeType": "enum: LEAF, INTERNAL",
    "ITCFork": "fields: left_itc IntervalTreeClock, right_itc IntervalTreeClock",
    "ITCComparison": "fields: relation CausalityRelation, comparable bool",
    "BoundedVectorClock": "fields: owner_id str, vector_size int, counters List[int], collision_count int, precision_estimate float",
    "DynamicMembership": "fields: MembershipOracle, VectorClockMigrator, MembershipConsensus, VersionCompatibility",
    "MembershipOracle": "fields: current_members Set[NodeID], historical_membership Dict[timestamp, Set[NodeID]]",
    "VectorClockMigrator": "fields: migration_policies Dict, compatibility_matrix Dict",
    "VectorClockMetrics": "fields: causality_violations Counter, operation_duration Histogram, memory_usage Gauge, conflicts_detected Counter",
    "VectorClockMonitor": "fields: node_id str, metrics VectorClockMetrics, monitoring_active bool"
  },
  "methods": {
    "generate() -> NodeID": "create unique node ID",
    "from_string(node_id: str) -> NodeID": "create NodeID from string",
    "add_node(node_id: NodeID) -> None": "add node to cluster",
    "get_node_index(node_id: NodeID) -> int": "get vector index for node",
    "increment() -> None": "advance local node counter in vector clock",
    "merge_with(other_clock: VectorClock) -> None": "merge with another clock",
    "compare_with(other_clock: VectorClock) -> CausalityRelation": "compare causality relationship",
    "copy() -> VectorClock": "deep copy of vector clock",
    "put(key, value, clock, node) -> bool": "store versioned value with conflict detection",
    "get(key) -> List[VersionedValue]": "retrieve value with read repair",
    "prune_versions(key) -> int": "remove dominated versions",
    "compare_with(other_clock) -> CausalityRelation": "determine causality relationship between vector clocks",
    "detect_conflicts_for_write() -> bool": "identify concurrent write conflicts",
    "resolve_conflicts_lww() -> VersionedValue": "last-writer-wins resolution",
    "prune_versions() -> int": "remove dominated versions to limit storage growth",
    "build_dominance_graph() -> Dict[int, Set[int]]": "construct version dominance relationships",
    "identify_dominated_versions() -> Set[int]": "find prunable version indices",
    "cleanup_departed_node_entries() -> List[VersionedValue]": "remove stale node entries from clocks",
    "detect_memory_pressure() -> float": "calculate current memory pressure level",
    "register_departed_node(node_id) -> None": "mark node as departed for cleanup",
    "should_trigger_compaction() -> bool": "determine if memory compaction needed",
    "send_message(target_address, target_port, message) -> bool": "send message to target node",
    "broadcast_message(target_nodes, message) -> Dict[str, bool]": "send message to multiple nodes",
    "create_message(message_type, sender_id, vector_clock, payload) -> NetworkMessage": "create formatted network message",
    "replicate_to_all(operation_id, target_nodes, message, callback) -> str": "initiate replication with retry",
    "put(key, value, context_clock) -> bool": "store value with replication",
    "process_incoming_message(message) -> Dict[str, Any]": "handle incoming network message",
    "detect_conflicts(versions) -> List[List[VersionedValue]]": "find conflicting version groups",
    "resolve_conflicts(conflict_groups) -> List[VersionedValue]": "resolve detected conflicts",
    "propagate_resolution(key, resolved_version, target_nodes) -> bool": "replicate resolution to other nodes",
    "add_node(node_id: str) -> None": "add node to failure detection monitoring",
    "record_heartbeat(node_id: str, timestamp: float) -> None": "record successful heartbeat from node",
    "get_reachable_nodes() -> Set[str]": "return currently reachable node set",
    "start_monitoring() -> None": "start background monitoring tasks",
    "handle_partition_detected(reachable_nodes: Set[str]) -> None": "enter partition-tolerant mode",
    "is_write_allowed(required_consistency_level: str) -> bool": "check if writes allowed in current partition",
    "mark_value_with_partition_context(versioned_value: VersionedValue) -> None": "add partition metadata to value",
    "handle_partition_healed(recovered_nodes: Set[str]) -> None": "exit partition mode when connectivity restored",
    "initiate_node_recovery(returning_node_id: str) -> bool": "handle previously failed node rejoining",
    "generate_state_summary() -> Dict[str, any]": "create state summary for recovering node",
    "apply_recovery_updates(state_summary: Dict[str, any]) -> List[str]": "apply cluster updates during recovery",
    "rebuild_vector_clock(cluster_vector_clocks: List[VectorClock]) -> VectorClock": "reconstruct vector clock from cluster consensus",
    "cleanup_departed_node(departed_node_id: str) -> int": "remove departed node from stored vector clocks",
    "start_cluster()": "start all nodes in test cluster",
    "stop_cluster()": "stop all nodes in test cluster",
    "put_value(node_index, key, value, context_clock)": "send PUT request to specific test node",
    "get_value(node_index, key)": "send GET request to specific test node",
    "simulate_send(from_node, to_node, message, callback)": "simulate network message with delays",
    "set_delay(from_node, to_node, delay_ms)": "configure network delay between nodes",
    "create_partition(partition_groups)": "split cluster into network partitions",
    "heal_partition()": "restore full network connectivity",
    "add_event(event_name, vector_clock) -> int": "add event for causality verification",
    "add_causal_edge(from_event_idx, to_event_idx)": "declare causal relationship between events",
    "verify_causality_consistency() -> List[str]": "check vector clocks match causal relationships",
    "detect_concurrent_events() -> List[Tuple[str, str]]": "find concurrent event pairs",
    "generate_random_vector_clock(node_count, max_counter) -> VectorClock": "create random clock for testing",
    "generate_causal_sequence(node_count, sequence_length) -> List[VectorClock]": "create causally ordered sequence",
    "generate_concurrent_clocks(node_count) -> Tuple[VectorClock, VectorClock]": "create concurrent clock pair",
    "log_vector_clock_operation(operation, before_clock, after_clock, **kwargs)": "log vector clock state changes",
    "log_causality_relationship(local_clock, remote_clock, relationship, context)": "log causal relationships",
    "log_conflict_detected(key, conflicting_versions, resolution_strategy)": "log conflict detection details",
    "log_causality_violation(description, evidence)": "log causality violations",
    "get_debug_logger(node_id, log_file) -> VectorClockLogger": "get or create debug logger",
    "parse_log_file(log_file_path) -> list": "parse structured log file",
    "start_interactive_inspector(cluster_state)": "start interactive inspector",
    "merge_with(other_clock) -> None": "merge with another clock using element-wise maximum",
    "fork() -> ITCFork": "split ITC for parallel execution",
    "join_with(other_itc) -> None": "merge ITC progress after synchronization",
    "compare_causality(other_itc) -> CausalityRelation": "determine causality relationship between ITCs",
    "normalize() -> ITCTree": "optimize tree structure",
    "_hash_node_id(node_id) -> int": "map node ID to vector position",
    "merge_with(other, known_participants) -> None": "merge bounded vectors with collision detection",
    "compare_with(other) -> CausalityRelation": "compare with potential false concurrency",
    "verify_causality_properties(clocks) -> List[str]": "check causality violations",
    "record_operation(operation, node_id, duration) -> None": "record operation metrics",
    "record_causality_violation(type, node_id) -> None": "record violation for alerting"
  },
  "constants": {
    "HAPPENS_BEFORE": "causal relationship where first event influences second",
    "HAPPENS_AFTER": "causal relationship where second event influences first",
    "CONCURRENT": "events that are causally independent",
    "IDENTICAL": "vector clocks with same values at all positions",
    "PENDING": "replication status for in-progress operations",
    "SUCCESS": "replication status for completed operations",
    "FAILED": "node status when failure confirmed",
    "LAST_WRITER_WINS": "conflict resolution using physical timestamps",
    "APPLICATION_MERGE": "conflict resolution using custom application logic",
    "CLIENT_MEDIATED": "conflict resolution by client",
    "TIMEOUT": "replication status for timed-out operations",
    "HEALTHY": "node status for normal operation",
    "SUSPECTED": "node status when failure suspected but not confirmed",
    "RECOVERING": "node status when previously failed node is rejoining",
    "TRACE_VECTOR_CLOCK": "detailed vector clock operation logging",
    "DEBUG_CAUSALITY": "causal relationship logging",
    "INFO_CONFLICT": "conflict detection logging",
    "WARN_VIOLATION": "causality violation warnings",
    "ERROR_CORRUPTION": "vector clock corruption errors",
    "ITCNodeType.LEAF": "leaf node in interval tree",
    "ITCNodeType.INTERNAL": "internal node in interval tree"
  },
  "terms": {
    "vector clock": "data structure tracking logical time across distributed nodes",
    "happens-before relationship": "partial ordering relation where one event causally influences another",
    "concurrent events": "causally independent events that may conflict when accessing shared resources",
    "logical time": "time based on causal relationships rather than physical clock readings",
    "causality": "relationship where one event influences or enables another event",
    "clock skew": "difference in physical clocks across distributed nodes",
    "element-wise maximum": "vector clock merge operation taking maximum value at each position",
    "dominated version": "version causally superseded by other existing versions",
    "conflict detection": "process of identifying concurrent operations using vector clock comparison",
    "version pruning": "removing old or dominated versions to prevent unbounded storage growth",
    "last-writer-wins": "conflict resolution using timestamps",
    "multi-version storage": "maintaining multiple concurrent versions with their vector clocks",
    "garbage collection": "cleanup of departed node entries from vector clocks",
    "memory pressure": "system resource constraint requiring optimization",
    "causality relationship": "classification of event relationships as before, after, concurrent, or identical",
    "grace period": "delay before cleaning up departed node data",
    "dominated version detection": "algorithm to identify causally superseded versions",
    "count-based pruning": "limiting versions by maximum count per key",
    "adaptive pruning": "dynamically adjusting pruning based on system conditions",
    "storage compaction": "reorganizing data structures for memory efficiency",
    "vector clock propagation": "including vector clock information in network messages",
    "all-nodes replication": "storing complete dataset copy on every node",
    "read repair": "automatic conflict detection and resolution during read operations",
    "reliable delivery": "message transmission with retries and acknowledgments",
    "write-back propagation": "spreading conflict resolution results to other nodes",
    "network partition": "communication failure isolating subsets of nodes",
    "synchronous replication": "waiting for replica acknowledgments before completing writes",
    "message reordering": "network delivery of messages in different order than sent",
    "heartbeat protocol": "periodic messages to detect node failures",
    "split-brain": "multiple isolated partitions accepting writes independently",
    "partition-tolerant mode": "continuing operation despite network splits",
    "partition healing": "restoring connectivity after network partition",
    "quorum": "majority of cluster nodes required for certain operations",
    "state synchronization": "merging divergent data after partition healing",
    "failure detection": "identifying when nodes become unreachable",
    "recovery protocol": "process for rejoining previously failed nodes",
    "partition marking": "metadata indicating which nodes were reachable during write",
    "vector clock reconciliation": "merging logical time views after connectivity returns",
    "integration testing": "testing multi-node interactions and distributed system properties",
    "milestone checkpoints": "structured verification points for incremental implementation validation",
    "property-based testing": "automated test generation using mathematical properties",
    "network simulation": "controlled introduction of delays, reordering, and failures",
    "causality verification": "checking that vector clocks preserve happens-before relationships",
    "test cluster": "managed group of nodes for integration testing",
    "causality violation": "incorrect happens-before relationship tracking",
    "structured logging": "JSON-formatted log entries for analysis",
    "interactive debugging": "command-line tool for system state inspection",
    "causal chain reconstruction": "tracing causality relationships through logs",
    "concurrent event detection": "identifying causally independent operations",
    "clock progression analysis": "monitoring counter advancement patterns",
    "performance profiling": "resource usage analysis for vector clock operations",
    "state inspection": "examining system state at specific points",
    "conflict detection accuracy": "correctness of concurrent write identification",
    "monotonicity property": "vector clocks never decrease during operations",
    "transitivity property": "causal relationships are transitive",
    "concurrency symmetry": "concurrent relation is bidirectional",
    "memory leak detection": "identifying unbounded resource growth",
    "debugging infrastructure": "tools and utilities for system diagnosis",
    "interval tree clocks": "dynamic membership vector clock variant",
    "bounded vector clocks": "fixed-size vector clocks with hash mapping",
    "dynamic membership": "handling nodes joining/leaving cluster",
    "causality violations": "incorrect happens-before relationships",
    "hash collisions": "multiple nodes mapping to same vector position",
    "precision estimate": "accuracy of causality detection with collisions",
    "fork operation": "splitting ITC for parallel execution",
    "join operation": "merging ITCs after synchronization",
    "membership oracle": "service tracking cluster membership",
    "vector clock migration": "updating clocks during membership changes",
    "production monitoring": "observability for vector clock systems",
    "causality correctness": "proper tracking of happens-before relationships",
    "performance metrics": "resource usage and operation latency tracking",
    "adaptive compression": "dynamic compression based on access patterns",
    "network optimization": "reducing bandwidth for clock propagation",
    "partition tolerance": "system capability to operate correctly despite network partitions"
  }
}