direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- STYLES & CLASSES ---
classes: {
  logic_step: {
    shape: step
    style: {
      fill: "linear-gradient(to bottom, #ffffff, #f0f0f0)"
      stroke-width: 2
    }
  }
  fault_path: {
    style: {
      stroke: "#ef4444"
      stroke-width: 2
      stroke-dash: 4
    }
  }
  data_struct: {
    shape: sql_table
    style: {
      fill: "#f8fafc"
      stroke: "#64748b"
    }
  }
}

# --- INPUT LAYER ---
trace_storage: {
  label: "trace_file.txt"
  shape: document
  content: |'text
    # Op | Virtual Address
    R 0x00401000
    W 0x00401004
    R 0x001A3F7C
    W 0x004B0020
  '|
}

# --- PARSER LAYER ---
parser: {
  label: "Trace Parser (vmsim.c)"
  
  api: {
    shape: class
    label: "Parser API"
    methods: |'c
      bool parse_trace_line(const char *line, mem_access_t *out);
      int  load_trace(const char *path, mem_access_t **out, size_t *cnt);
    '|
  }
  
  logic: {
    label: "Parsing Logic"
    code: |'c
      sscanf(p, " %c %lx", &op, &addr);
      out->vaddr = (uint32_t)addr;
      out->type = (op == 'W') ? WRITE : READ;
    '|
    width: 320
  }
}

# --- DATA STRUCTURES ---
mem_access_struct: {
  class: data_struct
  label: "struct mem_access_t"
  f0: "0x00 | access_type_t | type // R=0, W=1"
  f1: "0x04 | uint32_t      | vaddr // 32-bit"
  sz: "Total: 8 bytes"
}

# --- MMU PIPELINE ---
mmu: {
  label: "MMU: translate_address()"
  direction: down

  decompose: {
    class: logic_step
    label: "1. Address Decomposition"
    code: |'c
      vpn = vaddr >> 12;
      offset = vaddr & 0xFFF;
    '|
  }

  pte_fetch: {
    class: logic_step
    label: "2. PTE Lookup"
    code: |'c
      pte = page_table.entries[vpn];
    '|
  }

  is_valid: {
    shape: diamond
    label: "PTE.valid == 1?"
    style.fill: "#fef3c7"
  }

  check_perms: {
    shape: diamond
    label: "Perms OK?"
    style.fill: "#fef3c7"
  }

  update_pte: {
    class: logic_step
    label: "3. Update Flags"
    code: |'c
      pte |= PTE_REFERENCED;
      if (type == WRITE) pte |= PTE_DIRTY;
    '|
  }

  reconstruct: {
    class: logic_step
    label: "4. Reconstruct"
    code: |'c
      paddr = (pfn << 12) | offset;
      return XLATE_SUCCESS;
    '|
  }
}

# --- OS / FAULT HANDLING ---
os_kernel: {
  label: "OS: Page Fault Handler"
  style.fill: "#fff1f2"
  
  allocator: {
    class: logic_step
    label: "alloc_free_frame()"
    code: |'c
      for (int i = 0; i < 64; i++) {
        if (!frames[i].in_use) return i;
      }
      return OOM_ERROR;
    '|
  }

  pte_update: {
    class: logic_step
    label: "Update PTE"
    code: |'c
      pte->pfn = free_frame;
      pte->valid = 1;
      pte->perms = READ | WRITE;
    '|
  }
}

# --- STATISTICS ---
stats: {
  class: data_struct
  label: "Simulation Statistics"
  s0: "total_accesses: uint64_t"
  s1: "page_faults: uint64_t"
  s2: "protection_faults: uint64_t"
}

# --- CONNECTIONS ---
trace_storage -> parser.logic: "ASCII line | 12 bytes | 'R 0x00401000'"
parser.logic -> mem_access_struct: "populate"
mem_access_struct -> mmu.decompose: "struct mem_access_t | 8 bytes | {READ, 0x401000}"

mmu.decompose -> mmu.pte_fetch: "VPN | 20 bits | 0x00401"
mmu.pte_fetch -> mmu.is_valid: "pte_t | 4 bytes | {v:0, pfn:0}"

mmu.is_valid -> mmu.check_perms: "Yes"
mmu.is_valid -> os_kernel.allocator: "No (Page Fault)" { class: fault_path }

os_kernel.allocator -> os_kernel.pte_update: "PFN | 6 bits | 5"
os_kernel.pte_update -> mmu.pte_fetch: "Retry Translation" { style.stroke-dash: 5 }

mmu.check_perms -> mmu.update_pte: "Yes"
mmu.check_perms -> stats.s2: "No (SIGSEGV)" { class: fault_path }

mmu.update_pte -> mmu.reconstruct
mmu.reconstruct -> stats.s0: "Success | 32-bit Addr | 0x00005000"

# Fault feedback to stats
os_kernel.allocator -> stats.s1: "increment" { style.stroke: "#ef4444" }

# Legend
legend: {
  fault: "Fault Path" {
    style.stroke: "#ef4444"
    style.stroke-dash: 4
  }
  retry: "Retry Loop" {
    style.stroke-dash: 5
  }
}
legend.near: bottom-right