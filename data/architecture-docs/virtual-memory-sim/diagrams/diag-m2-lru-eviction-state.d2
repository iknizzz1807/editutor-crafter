direction: right
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- Metadata Classes ---
classes: {
  mru_node: {
    style: {
      fill: "#e1f5fe"
      stroke: "#01579b"
      stroke-width: 2
    }
  }
  lru_node: {
    style: {
      fill: "#ffebee"
      stroke: "#b71c1c"
      stroke-width: 2
    }
  }
  dirty_entry: {
    style: {
      stroke: "#d32f2f"
      stroke-dash: 2
    }
  }
}

# --- Structural Definition ---
tlb_entry_struct: {
  shape: sql_table
  label: "struct tlb_entry_t (tlb.h)"
  f0: "0x00 | uint32_t | vpn // Tag"
  f1: "0x04 | uint32_t | pfn // Data"
  f2: "0x08 | uint16_t | asid // Process Tag"
  f3: "0x0A | uint8_t  | flags // V | D | R | W"
  f4: "0x0B | uint8_t  | lru_counter // Age"
  sz: "Total: 12 bytes"
}

# --- Evolution Timeline ---

timeline: {
  direction: right
  
  t1_state: {
    label: "T1: TLB Partial (3/4 Full)"
    direction: down
    
    tlb_snapshot: {
      shape: sql_table
      t0: "Slot 0 | VPN: 0x10 | PFN: 5 | ASID: 1 | V=1, W=1 | LRU: 2"
      t1: "Slot 1 | VPN: 0x20 | PFN: 8 | ASID: 1 | V=1, D=1 | LRU: 1"
      t2: "Slot 2 | VPN: 0x30 | PFN: 2 | ASID: 1 | V=1, W=0 | LRU: 0 (MRU)"
      t3: "Slot 3 | V=0 (Empty) | - | - | - | -"
    }
    
    status: "Action: Read VPN 0x40"
  }

  t2_state: {
    label: "T2: TLB Full"
    direction: down
    
    tlb_snapshot: {
      shape: sql_table
      t0: "Slot 0 | VPN: 0x10 | PFN: 5 | ASID: 1 | V=1, W=1 | LRU: 3"
      t1: "Slot 1 | VPN: 0x20 | PFN: 8 | ASID: 1 | V=1, D=1 | LRU: 2"
      t2: "Slot 2 | VPN: 0x30 | PFN: 2 | ASID: 1 | V=1, W=0 | LRU: 1"
      t3: "Slot 3 | VPN: 0x40 | PFN: 9 | ASID: 1 | V=1, W=1 | LRU: 0 (MRU)"
    }
    
    status: "Action: Write VPN 0x50"
    note: "Conflict! All slots valid."
  }

  t3_eviction: {
    label: "T3: LRU Eviction & Write-back"
    direction: down
    
    eviction_logic: {
      label: "tlb_writeback_entry(slot_0)"
      code: |'c
        victim = tlb_find_victim_lru(tlb); // Returns Slot 0 (Age 3)
        if (tlb->entries[victim].flags & TLB_DIRTY) {
          pt->entries[vpn].flags |= PTE_DIRTY; // Sync metadata
        }
        tlb_flush_page(tlb, pt, 0x10); // Invalidate coherency
      '|
    }
    
    write_back_flow: {
      shape: package
      label: "Memory Hierarchy Sync"
      tlb_entry -> page_table: "DIRTY BIT | 1 bit | 1"
      page_table -> swap: "Page Data | 4 KB | Frame 5 content"
    }
  }

  t4_final: {
    label: "T4: Updated State"
    direction: down
    
    tlb_snapshot: {
      shape: sql_table
      t0: "Slot 0 | VPN: 0x50 | PFN: 12 | ASID: 1 | V=1, D=1 | LRU: 0 (MRU)"
      t1: "Slot 1 | VPN: 0x20 | PFN: 8  | ASID: 1 | V=1, D=1 | LRU: 3"
      t2: "Slot 2 | VPN: 0x30 | PFN: 2  | ASID: 1 | V=1, W=0 | LRU: 2"
      t3: "Slot 3 | VPN: 0x40 | PFN: 9  | ASID: 1 | V=1, W=1 | LRU: 1"
    }
    
    status: "Result: 0x50 cached in Slot 0"
  }
}

# --- Connections ---

timeline.t1_state -> timeline.t2_state: "Insert | 12 bytes | VPN 0x40"
timeline.t2_state -> timeline.t3_eviction: "MISS | Conflict | VPN 0x50"
timeline.t3_eviction -> timeline.t4_final: "Replace | Slot 0 | LRU Reset"

# --- Styling Annotations ---
timeline.t1_state.tlb_snapshot.t3.style.fill: "#eeeeee"
timeline.t2_state.tlb_snapshot.t0.class: lru_node
timeline.t2_state.tlb_snapshot.t1.class: dirty_entry
timeline.t4_final.tlb_snapshot.t0.class: mru_node

legend: {
  shape: package
  label: "Legend"
  near: bottom-right
  mru: "MRU (Most Recently Used)" { class: mru_node }
  lru: "LRU (Victim Candidate)" { class: lru_node }
  dirty: "Dirty (Requires Write-back)" { class: dirty_entry }
}