layout-engine: elk
vars: {
  d2-config: {
    theme-id: 4
  }
}

title: |md
  ### Algorithm: `translate()` Control Flow
  **Milestone 1: Single-Level Translation & Demand Paging**
| {
  near: top-center
  shape: text
}

# --- MMU STATE DEFINITIONS ---
CPU_Context: {
  label: "Current MMU Context"
  vaddr: "0x00401020" {style.fill: "#dae8fc"}
  vpn: "0x00401" {style.fill: "#dae8fc"}
  offset: "0x020" {style.fill: "#dae8fc"}
  is_write: "TRUE" {style.fill: "#fff2cc"}
  
  PTE_Register: {
    label: "PTE [VPN 0x401]"
    bits: "[V:0][W:0][R:0][D:0][A:0][PFN:0]" {style.stroke-dash: 3}
  }
}

# --- ALGORITHM FLOW ---
# Using 'Algorithm_Stages' instead of reserved 'steps' keyword to allow internal connections
Algorithm_Stages: {
  grid-columns: 1
  
  S1: {
    label: "1. Address Decomposition"
    CPU_State: {
      vaddr: "0x00401020"
      vpn: "**0x00401**"
      offset: "**0x020**"
    }
    CPU_State.vpn.style: { font-color: red; bold: true }
    CPU_State.offset.style: { font-color: red; bold: true }
    explanation: "VPN = (vaddr >> 12); Offset = (vaddr & 0xFFF)"
  }

  S2: {
    label: "2. Bounds Checking"
    check: "VPN (0x00401) < PAGE_TABLE_SIZE (0x100000)?"
    result: "TRUE"
    fail_node: "XLATE_PROT_FAULT" {
      style.fill: "#ffcccc"
      style.stroke: red
    }
    check -> fail_node: "No"
  }

  S3: {
    label: "3. Validity Check (Demand Paging)"
    PTE_State: {
      label: "MMU Fetches PTE"
      old: "[V:0][W:0][R:0][D:0][A:0][PFN:0]"
      status: "Valid bit is 0 -> Trigger handle_page_fault()"
      new: "[V:**1**][W:1][R:1][D:0][A:0][PFN:**5**]"
    }
    PTE_State.new.style: { font-color: red; bold: true }
    annotation: |md
      **CRITICAL ORDERING:** 
      Valid check MUST precede Permission check. 
      Bits [W,R,D,A] are undefined if V=0.
    |
  }

  S4: {
    label: "4. Permission Enforcement"
    eval: "is_write (TRUE) && PTE.W (1)?"
    outcome: "ALLOW"
    fail_node: "XLATE_PROT_FAULT" {
      style.fill: "#ffcccc"
      style.stroke: red
    }
    eval -> fail_node: "is_write=1 && W=0"
  }

  S5: {
    label: "5. Metadata Commit"
    PTE_Final: {
      before: "[V:1][W:1][R:1][D:0][A:0][PFN:5]"
      after: "[V:1][W:1][R:1][D:**1**][A:**1**][PFN:5]"
    }
    PTE_Final.after.style: { font-color: red; bold: true }
    explanation: "Set Referenced(A) on all access; Set Dirty(D) on Write."
  }

  S6: {
    label: "6. Address Reconstruction"
    phys_gen: {
      pfn: "0x00005"
      offset: "0x020"
      paddr: "**0x00005020**"
    }
    phys_gen.paddr.style: { font-color: red; bold: true }
    result: "XLATE_SUCCESS" {
      style.fill: "#ccffcc"
      style.stroke: green
    }
  }
}

# Linear Execution Path
Algorithm_Stages.S1 -> Algorithm_Stages.S2 -> Algorithm_Stages.S3 -> Algorithm_Stages.S4 -> Algorithm_Stages.S5 -> Algorithm_Stages.S6

# Global Stage Styling
Algorithm_Stages.** : {
  style: {
    stroke-width: 2
    border-radius: 8
    fill: "#f8f9fa"
  }
}

# Annotate memory constraints
Algorithm_Stages.S6.phys_gen: {
  tooltip: "Physical Address = (PFN << 12) | Offset"
}