layout-engine: elk
vars: {
  d2-config: {
    theme-id: 4
    layout-engine: elk
    pad: 20
  }
}

direction: right

classes: {
  mem_header: {
    style: {
      fill: "#9b59b6"
      font-color: white
      bold: true
    }
  }
  mem_data: {
    style: {
      fill: "#bbdefb"
      stroke: "#1e88e5"
    }
  }
  mem_free: {
    style: {
      fill: "#c8e6c9"
      stroke: "#43a047"
    }
  }
  mem_fault: {
    style: {
      fill: "#ffcdd2"
      font-color: "#b71c1c"
      stroke: "#b71c1c"
      bold: true
    }
  }
  ptr: {
    style: {
      stroke: "#ffa726"
      stroke-width: 3
    }
  }
}

# --- BEFORE STATE ---
BEFORE: "STATE 0: Page Fault Triggered" {
  page_table: {
    shape: sql_table
    label: "Page Table (ASID 1) | size=4KB"
    vpn_400: "0x0000 | VPN 0x400: [PFN: 0x07 | V:1] | 8B" {class: mem_data}
    vpn_401: "0x0008 | VPN 0x401: [PFN: ?? | V:0] | 8B" {class: mem_free}
    vpn_402: "0x0010 | VPN 0x402: [PFN: 0x09 | V:1] | 8B" {class: mem_data}
  }

  phys_mem: {
    shape: sql_table
    label: "Physical RAM | size=128MB"
    frame_11: "0xB000 | Frame 11: [DATA: ... ] | 4KB" {class: mem_data}
    frame_12: "0xC000 | Frame 12: [FREE / STALE] | 4KB" {class: mem_free}
    frame_13: "0xD000 | Frame 13: [DATA: ... ] | 4KB" {class: mem_data}
  }
}

# --- ALGORITHM SEQUENCE ---
STEPS: "OS Exception Handler: handle_page_fault()" {
  1: "1. MMU Traps: PTE.V == 0"
  2: "2. OS allocates Frame Index 12"
  3: "3. Disk I/O: Swap-in page to frame"
  4: "4. **memset(frame[12], 0, 4096)**" {style.font-color: red}
  5: "5. **PTE[0x401].PFN = 12, .V = 1**" {style.font-color: red}
  
  1 -> 2 -> 3 -> 4 -> 5: {style.stroke: "#ffa726"}
}

# --- AFTER STATE ---
AFTER: "STATE 1: Page Fault Resolved" {
  page_table_after: {
    shape: sql_table
    label: "Page Table (ASID 1) | size=4KB"
    vpn_400: "0x0000 | VPN 0x400: [PFN: 0x07 | V:1] | 8B" {class: mem_data}
    vpn_401: "0x0008 | **VPN 0x401: [PFN: 12 | V:1]** | 8B" {class: mem_fault}
    vpn_402: "0x0010 | VPN 0x402: [PFN: 0x09 | V:1] | 8B" {class: mem_data}
  }

  phys_mem_after: {
    shape: sql_table
    label: "Physical RAM | size=128MB"
    frame_11: "0xB000 | Frame 11: [DATA: ... ] | 4KB" {class: mem_data}
    frame_12: "0xC000 | **Frame 12: [DATA: 0x0...]** | 4KB" {class: mem_fault}
    frame_13: "0xD000 | Frame 13: [DATA: ... ] | 4KB" {class: mem_data}
  }
}

# Control Flow & State Transitions
BEFORE.page_table.vpn_401 -> STEPS.1: "Access 0x401..." {class: ptr}
STEPS.4 -> AFTER.phys_mem_after.frame_12: "Zero-fill" {class: ptr; style.stroke-dash: 5}
STEPS.5 -> AFTER.page_table_after.vpn_401: "Commit PTE" {class: ptr; style.stroke-dash: 5}

# Documentation
security_note: |md
  ### Security Invariant: Zero-Fill
  The OS **must** zero-fill frames (Step 4) before 
  mapping to a process address space. This prevents 
  **Information Leakage** from stale kernel or 
  cross-process data previously residing at 
  physical frame 0xC000.
| {
  near: bottom-right
  style: {
    fill: "#fff9c4"
    stroke: "#fbc02d"
    stroke-width: 2
  }
}