layout-engine: elk
vars: {
  d2-config: {
    layout-engine: elk
    theme-id: 4
  }
}

# --- Classes for Technical Precision ---
classes: {
  header_purple: {
    style: {
      fill: "#f3e5f5"
      stroke: "#6a1b9a"
      stroke-width: 2
    }
  }
  data_blue: {
    style: {
      fill: "#bbdefb"
      stroke: "#1976d2"
    }
  }
  padding_gray: {
    style: {
      fill: "#eeeeee"
      stroke: "#9e9e9e"
    }
  }
  logic_decision: {
    shape: diamond
    style.fill: "#fff9c4"
  }
  process_step: {
    shape: step
    style.fill: "#e3f2fd"
  }
}

# --- Memory Layout: Access Entry Structure ---
# 8-byte aligned structure definition
MemAccessStruct: {
  shape: sql_table
  label: "struct mem_access_t | sizeof=8 bytes"
  class: header_purple
  
  "0x00": "char type" {
    constraint: "1 Byte (Data)"
    class: data_blue
  }
  "0x01": "padding [3]" {
    constraint: "3 Bytes (Padding)"
    class: padding_gray
  }
  "0x04": "uint32_t vaddr" {
    constraint: "4 Bytes (Data)"
    class: data_blue
  }
}

# --- Input: Trace File Structure ---
TraceFile: {
  shape: package
  label: "input.trace (Disk Content)"
  style.fill: "#f3e5f5"
  
  Content: |md
    # Raw ASCII Format
    R 0x1A3F7C
    W 0x004B0020
    # Page boundary (4096B)
    R 0x1A4000
  |
}

# --- Stage 1: Parsing & Loading Pipeline ---
Loader: {
  class: header_purple
  label: "load_trace() context"

  Iterator: "fgets(line, 256, fp)" {
    shape: parallelogram
  }

  Filter: "Skip Logic" {
    shape: diamond
    label: "Is Comment (#) \nor Empty?"
  }

  Parser: "parse_trace_line()" {
    shape: step
  }

  DynamicArray: {
    label: "Buffer Management"
    CapacityCheck: "if (count >= capacity)" {
      shape: diamond
    }
    Grow: "realloc(accesses, cap * 2)" {
      class: logic_decision
    }
    
    CapacityCheck -> Grow: "True"
  }

  Iterator -> Filter: "char* line"
  Filter -> Iterator: "Yes (Skip)" {
    style.stroke-dash: 3
  }
  Filter -> Parser: "No (Data)"
  Parser -> DynamicArray.CapacityCheck: "mem_access_t"
}

TraceFile -> Loader.Iterator: "FILE* fp"

# --- In-Memory State: Continuous Trace Buffer ---
TraceBuffer: {
  shape: cylinder
  label: "mem_access_t[] (Heap Allocation)"
  class: data_blue
  
  Layout: |md
    | Index | Type  | VAddr (Hex)  |
    | :---  | :---  | :---         |
    | 0     | READ  | 0x001A3F7C   |
    | 1     | WRITE | 0x004B0020   |
    | ...   | ...   | ...          |
  |
}

Loader.DynamicArray -> TraceBuffer: "Final Populate"

# --- Stage 2: Execution & Translation Loop ---
Simulator: {
  label: "simulate() logic"
  class: data_blue

  Loop: "for (i = 0; i < count; i++)" {
    shape: step
  }

  MMU: "translate(vaddr, type)" {
    class: process_step
  }

  Decision: "Check PTE.valid" {
    shape: diamond
  }

  Loop -> MMU: "accesses[i]"
  MMU -> Decision: "pte_t lookup"
}

TraceBuffer -> Simulator.Loop: "accesses"

# --- Stage 3: Fault Handling ---
FaultLogic: {
  Handler: "handle_page_fault()" {
    style.fill: "#ffcdd2"
    style.stroke: "#c62828"
  }
  
  FrameAlloc: "alloc_free_frame()" {
    shape: step
  }

  Handler -> FrameAlloc: "Request Frame"
}

Simulator.Decision -> FaultLogic.Handler: "valid == 0" {
  label: "PAGE_FAULT"
  style: {
    stroke: "#c62828"
    font-color: "#c62828"
  }
}

# --- Final Outputs & Trap States ---
Output: {
  shape: package
  label: "Simulation Statistics"
  
  Result: "XLATE_SUCCESS" {
    label: "PAddr Result"
    style.fill: "#c8e6c9"
    style.stroke: "#2e7d32"
  }

  ErrorLog: "XLATE_PROT_FAULT" {
    label: "SIGSEGV / Protection"
    style.fill: "#ffcdd2"
    style.stroke: "#c62828"
  }
}

Simulator.Decision -> Output.Result: "valid == 1" {
  style.stroke: "#2e7d32"
}

Simulator.MMU -> Output.ErrorLog: "Perm Mismatch" {
  style: {
    stroke: "#c62828"
    stroke-dash: 5
  }
}

# --- Metrics Annotation ---
Metrics: |md
  ### Simulation Metrics
  - **Entry Size**: 8 Bytes
  - **Alignment**: 4-byte boundary
  - **Growth**: 2x Capacity Factor
  - **Boundary**: 4KB Page Fault Logic
| {
  near: top-right
}