[
  {
    "milestone_id": "virtual-memory-sim-m1",
    "criteria": [
      "Trace file parser correctly reads lines of format 'R 0xHHHHHHHH' and 'W 0xHHHHHHHH', skipping comment lines (starting with '#') and blank lines, and storing each as an access_type_t + uint32_t vaddr pair",
      "Virtual address decomposition uses configurable PAGE_OFFSET_BITS (default 12 for 4KB pages): VPN = vaddr >> 12 using right-shift, offset = vaddr & (PAGE_SIZE - 1) using AND with 0xFFF — not 0x1000",
      "PTE structure contains exactly: 20-bit physical frame number (PFN), valid bit (bit 0), read permission bit, write permission bit, dirty bit, and referenced bit — all packed into 4 bytes",
      "pte_get_pfn() and make_physical_addr() correctly reconstruct physical address as (PFN << 12) | offset, verified by manual trace: VPN 6723 + PFN 42 + offset 124 = 0x0002A07C",
      "Valid address translation (valid=1, permissions match) returns XLATE_SUCCESS with correct physical address without incrementing page_faults or protection_faults counters",
      "Access to a PTE with valid=0 triggers a page fault: page_faults counter increments, a free frame is allocated via alloc_free_frame(), the new frame is zero-initialized with memset, and the PTE is updated with valid=1 and the allocated PFN before returning XLATE_SUCCESS",
      "Write access to a page with valid=1 but perm_write=0 triggers a protection fault: protection_faults counter increments, XLATE_PROT_FAULT is returned, and no frame is allocated or PTE modified",
      "Permission check occurs only after valid=1 is confirmed — permission bits on invalid PTEs are never tested",
      "Write access sets PTE_DIRTY bit on the PTE; read access does NOT set PTE_DIRTY; any access (read or write) sets PTE_REFERENCED bit",
      "Statistics reporter prints: total_accesses, page_faults with percentage (page_faults/total_accesses * 100), protection_faults with percentage, and frames currently in use out of NUM_FRAMES",
      "simulator_init() zeroes all page table entries (all PTEs start with valid=0) and marks all frames as in_use=false, verified by running an empty trace producing 0 faults",
      "alloc_free_frame() returns UINT32_MAX when all NUM_FRAMES frames are in_use, and simulate() handles this XLATE_OOM result without crashing",
      "simulator_mmap() or equivalent mechanism allows pre-mapping a VPN with specific read/write permissions for testing protection fault scenarios without triggering demand paging"
    ]
  },
  {
    "milestone_id": "virtual-memory-sim-m2",
    "criteria": [
      "TLB is checked on every call to translate_with_tlb(); a TLB hit returns the PFN directly without reading page_table.entries[] and increments the hits counter",
      "A TLB hit correctly handles permission checking: if access_type == ACCESS_WRITE and TLB_WRITABLE is not set in the entry's flags, a protection fault is returned without consulting the page table",
      "A TLB hit updates the TLB entry's TLB_REFERENCED flag; a write hit additionally sets TLB_DIRTY within the TLB entry without writing through to the PTE immediately",
      "A TLB miss increments the misses counter, performs a full page table walk (reads page_table.entries[vpn]), handles page faults as in Milestone 1 if needed, and inserts the resulting VPN→PFN translation into the TLB via tlb_insert()",
      "TLB has a compile-time configurable TLB_SIZE (tested with at least 16, 32, and 64); when all entries are occupied (no slot with TLB_VALID cleared), eviction occurs before insertion",
      "LRU eviction selects the entry with the highest lru_counter (oldest); lru_counter is incremented for all valid entries on each lookup and reset to 0 for the entry that was hit or most recently inserted",
      "Random eviction uses a seeded LCG PRNG (rand_state field) so that eviction order is reproducible given the same seed, enabling deterministic test verification",
      "Every TLB entry contains an asid field (uint16_t) and a lookup only matches if entry.valid AND entry.asid == tlb->active_asid AND entry.vpn == vpn; entries with a different ASID are skipped without any side effects",
      "context_switch() changes tlb->active_asid to new_asid; without force_flush, no TLB entries are invalidated — entries from the previous ASID remain in the TLB and become accessible again if the OS switches back to that ASID",
      "context_switch() with force_flush=1 calls tlb_flush_all() which iterates all entries, calls tlb_writeback_entry() on each valid entry before clearing it, and increments the flushes counter",
      "tlb_flush_page(vpn) invalidates all TLB entries with matching vpn regardless of ASID, calling tlb_writeback_entry() before clearing each; this function must be called in Milestone 4 before clearing a PTE during page eviction",
      "tlb_writeback_entry() propagates TLB_DIRTY from the TLB entry to PTE_DIRTY in the page table, and TLB_REFERENCED to PTE_REFERENCED, without clearing PTE_VALID (the page remains in physical memory, only the TLB entry is being evicted)",
      "Statistics are tracked and reported: total TLB lookups (hits + misses), hit count, miss count, hit rate as a percentage, eviction count, and full flush count",
      "After running test_tlb_hits.trace (12 accesses to 4 distinct pages), the hit rate is 66.7% (8 hits, 4 misses, 0 evictions with TLB_SIZE >= 4)",
      "The ASID context switch test passes: after accessing VPN X under ASID=1, switching to ASID=2, accessing VPN X results in a TLB miss; switching back to ASID=1, accessing VPN X results in a TLB hit without a page table walk",
      "The dirty bit write-back test passes: a write access that hits the TLB sets TLB_DIRTY in the entry; after tlb_flush_all(), the corresponding PTE has PTE_DIRTY set",
      "LRU eviction test passes with TLB_SIZE=4: after filling the TLB with VPNs 1-4, accessing VPN 1 again (making it MRU), the next miss evicts VPN 2 (the new LRU), verified by a subsequent access to VPN 2 resulting in a TLB miss"
    ]
  },
  {
    "milestone_id": "virtual-memory-sim-m3",
    "criteria": [
      "A simulated CR3 register field exists in the simulator state, holding the physical base address (or symbolic pointer) of the active process's root page directory; context switches update CR3 to point to the new process's page directory",
      "Virtual address decomposition uses exactly 10 bits for the page directory index (bits [31:22]), 10 bits for the page table index (bits [21:12]), and 12 bits for the page offset (bits [11:0]) for a 32-bit address space with 4KB pages",
      "Three inline extraction functions — pd_index(), pt_index(), page_offset() — correctly extract their respective fields via bitwise shift and mask operations, verified against at minimum the test vectors 0x004056A8 (PDI=1, PTI=5, offset=0x6A8) and 0xFFFFFFFF (PDI=1023, PTI=1023, offset=0xFFF)",
      "A page directory entry (PDE) type is defined separately from a page table entry (PTE) type; PDEs contain a present bit and a pointer/address to a second-level page table, while PTEs contain PFN plus valid/dirty/referenced/permission bits",
      "Page directory entries with present=0 indicate that the entire 4MB virtual address region is unmapped; accessing such a region triggers on-demand allocation of a new second-level page table (not a page fault that terminates simulation)",
      "Second-level page tables are allocated on demand only at the first access to each 4MB region; a process accessing N distinct 4MB regions allocates exactly N second-level tables, verified by asserting pgtables[i]==NULL for unaccessed regions after translation",
      "The page table walk traverses all levels in order: CR3 → page_directory[PDI] → page_table[PTI] → PTE → PFN → physical_address = (PFN << 12) | offset, with correct behavior at each level for both present and not-present entries",
      "Memory overhead is measured and reported: a process accessing K pages spread across K distinct 4MB regions allocates exactly (1 + K) × 4096 bytes of page table memory, compared to the flat table's fixed 4,194,304 bytes, with savings percentage printed",
      "The overhead comparison function measures and prints: flat table cost in bytes, two-level actual cost in bytes, number of second-level tables allocated, bytes per mapped page for each scheme, and savings percentage",
      "Context switch function updates sim->active_process, sim->cr3, and either flushes the TLB entirely (force_flush=1) or switches the TLB's active_asid (force_flush=0), verified by testing that two processes' identical virtual addresses translate to distinct physical addresses after a context switch",
      "Two processes with the same virtual address 0x00001000 must translate to different physical addresses after a context switch, demonstrating that CR3 enforces address space isolation",
      "The process_destroy() function correctly frees all allocated second-level page tables and the page directory without memory leaks, verified by valgrind or address sanitizer",
      "A three-level page table structure using 2+9+9+12 bit decomposition is implemented as a stretch goal, with L1 root (4 entries), on-demand L2 tables (512 entries each), and on-demand L3 leaf tables (512 entries each) containing PTEs",
      "The three-level walk correctly handles on-demand allocation at both the L2 and L3 levels independently: accessing two addresses in the same L1 region but different L2 regions allocates two L2 tables; accessing two addresses in the same L1 and L2 region allocates only one L2 table",
      "TLB integration from Milestone 2 is preserved: TLB lookup precedes the two-level walk, and on a TLB miss after a successful walk, the (VPN, PFN) pair is inserted into the TLB; tlb_flush_page() is called for any VPN whose PTE is modified or invalidated"
    ]
  },
  {
    "milestone_id": "virtual-memory-sim-m4",
    "criteria": [
      "Physical memory is modeled as a fixed-size frame pool (configurable: 3, 16, 64, 256 frames) using a frame_desc_t array with fields for VPN, load_time, last_access, ref_bit, dirty, and in_use; page faults when all frames are occupied trigger the replacement policy rather than aborting",
      "Simulated swap space is implemented as an array of swap_slot_t records indexed by VPN; dirty pages are written to swap via swap_page_out() on eviction and reloaded via swap_page_in() on subsequent fault; clean pages are discarded without swap write; swap slot is freed after successful page-in",
      "FIFO replacement selects the frame with the smallest load_time (earliest allocation); verified to produce 9 page faults on the classic reference string 7,0,1,2,0,3,0,4,2,3,0,3,2 with 3 frames",
      "LRU replacement selects the frame with the smallest last_access timestamp; last_access is updated on every access (TLB hit and miss paths), not only on page faults; verified to produce 8 page faults on the same 13-element reference string with 3 frames",
      "Clock (Second-Chance) algorithm maintains a persistent clock_hand that advances circularly across frame_desc_t entries; on sweep: ref_bit=true clears the bit (second chance) and advances hand; ref_bit=false triggers eviction; clock_hand persists across calls and is not reset between replacements",
      "Optimal (Bélády's) algorithm scans the remaining future trace (from current_idx forward) for each candidate frame, selecting the victim whose VPN appears farthest in the future (or never); requires the full pre-loaded trace array; implemented as offline algorithm only, not for real-time use",
      "Dirty pages incur a write-back to swap (swap_page_out called, write_backs counter incremented) before frame is freed; clean pages are freed immediately; eviction core (evict_frame) calls tlb_flush_page() and clears PTE_VALID before marking frame as in_use=false",
      "Comparative statistics are printed for all four algorithms on the same trace in a formatted table showing: page fault count, fault rate percentage, dirty write-back count, and peak working set size; efficiency ratio vs Optimal is also printed",
      "Bélády's anomaly is demonstrated with FIFO on reference string 1,2,3,4,1,2,5,1,2,3,4,5: 3 frames produces 9 faults, 4 frames produces 10 faults (more frames = more faults); verified with assertion that 4-frame fault count exceeds 3-frame fault count; LRU immunity to anomaly is also verified (4 frames ≤ 3 frames faults)",
      "Working set size is tracked using a sliding window ring buffer of configurable size (default 10 accesses); ws_record_access() returns the count of distinct VPNs in the current window; peak working set size is recorded per simulation run and included in comparative output",
      "Simulation state is fully reset between algorithm runs (page table zeroed, frame pool re-initialized, swap space cleared, TLB flushed) so each algorithm sees the same initial blank-slate conditions for valid comparison",
      "TLB coherence is maintained on eviction: tlb_flush_page() is called for the evicted VPN before the frame is reused; dirty and referenced bits are written back from the frame descriptor to the PTE only during eviction (not on every access)",
      "Optimal algorithm identifies frames whose VPN never appears again in the future trace as ideal victims (evicts immediately without further scanning); for VPNs that do appear again, selects the one with maximum distance to next use",
      "The unified replace_page() dispatcher accepts a replacement_policy_t enum and routes to the correct algorithm; all algorithms share the evict_frame() core which handles dirty write-back, TLB invalidation, PTE clearing, and frame descriptor reset in the correct order"
    ]
  },
  {
    "module_id": "virtual-memory-sim-m1",
    "criteria": [
      "Address decomposition extracts 20-bit VPN and 12-bit offset using bit-shifts.",
      "Page Table Entry (PTE) uses a 32-bit bit-packed format with Valid, Dirty, Accessed, and Permission bits.",
      "Demand paging allocates a free physical frame on the first valid=0 access.",
      "Protection faults are triggered when a write is attempted on a read-only page.",
      "Statistics report accurately counts total accesses, page faults, and protection faults.",
      "Trace file parser ignores comments and correctly reads hex addresses and operation types.",
      "The simulator manages a fixed-size physical frame pool and detects OOM conditions."
    ]
  },
  {
    "module_id": "virtual-memory-sim-m2",
    "criteria": [
      "TLB entry includes VPN, PFN, ASID, and metadata flags in a 12-byte packed format",
      "tlb_lookup implements three-way matching on Valid, ASID, and VPN",
      "LRU eviction correctly ages entries and selects the oldest for replacement",
      "TLB insertion triggers metadata write-back (Dirty/Ref) to the main Page Table",
      "context_switch updates active_asid and supports optional full flush",
      "tlb_flush_page correctly invalidates specific entries for coherence",
      "Statistics accurately track hits, misses, and hit rate percentage"
    ]
  },
  {
    "module_id": "virtual-memory-sim-m3",
    "criteria": [
      "Implement 10-10-12 address bit decomposition functions.",
      "Simulate CR3 register as the root of the hierarchical walk.",
      "Implement on-demand allocation of second-level page tables.",
      "Provide process_t isolation where each process has its own pgdir.",
      "Calculate and report pt_bytes_allocated vs. 4MB flat table baseline.",
      "Ensure pde_t and pte_t are handled as distinct types in the walk.",
      "Coordinate context switching with M2 TLB (ASID update or flush)."
    ]
  },
  {
    "module_id": "virtual-memory-sim-m4",
    "criteria": [
      "Implement FIFO, LRU, Clock, and Optimal algorithms",
      "Verify Bélády anomaly on trace: 1,2,3,4,1,2,5,1,2,3,4,5",
      "Enforce TLB flush before PTE clearing in eviction core",
      "Implement dirty-page write-back logic with swap space stats",
      "Track peak working set size using a 50-access sliding window",
      "Produce comparative statistics table for all algorithms"
    ]
  }
]