direction: down

classes: {
  error: {
    style.fill: "#d63031"
    style.font-color: "#ffffff"
    style.stroke: "#e17055"
    style.bold: true
  }
  detection: {
    style.fill: "#74b9ff"
    style.font-color: "#ffffff"
    style.stroke: "#0984e3"
  }
  recovery: {
    style.fill: "#00b894"
    style.font-color: "#ffffff"
    style.stroke: "#00a085"
  }
  decision: {
    style.fill: "#fdcb6e"
    style.font-color: "#2d3436"
    style.stroke: "#e17055"
    style.bold: true
  }
}

start: Start Operation {
  shape: circle
  style.fill: "#3fb950"
  style.font-color: "#ffffff"
}

detect_error: Detect Error {
  shape: diamond
  class: detection
}

start -> detect_error

error_type: Determine Error Type {
  shape: diamond
  class: decision
}

detect_error -> error_type: Error Found

normal_flow: Continue Normal Operation {
  class: recovery
}

detect_error -> normal_flow: No Error

corruption_flow: Log Corruption {
  corruption_check: Checksum Validation {
    class: detection
  }
  
  corruption_severity: Assess Severity {
    shape: diamond
    class: decision
  }
  
  single_record: Single Record Corrupt {
    class: error
  }
  
  multiple_records: Multiple Records Corrupt {
    class: error
  }
  
  skip_record: Skip Corrupted Record & Log {
    class: recovery
  }
  
  halt_recovery: Halt Recovery Process {
    class: error
  }
  
  corruption_check -> corruption_severity
  corruption_severity -> single_record: Isolated
  corruption_severity -> multiple_records: Widespread
  single_record -> skip_record
  multiple_records -> halt_recovery
}

partial_write_flow: Partial Write {
  detect_partial: Detect Incomplete Write {
    class: detection
  }
  
  write_boundary: At Transaction Boundary? {
    shape: diamond
    class: decision
  }
  
  truncate_log: Truncate to Last Complete Record {
    class: recovery
  }
  
  retry_write: Retry Write Operation {
    class: recovery
  }
  
  detect_partial -> write_boundary
  write_boundary -> truncate_log: Yes
  write_boundary -> retry_write: No
}

disk_full_flow: Disk Full {
  space_check: Check Available Space {
    class: detection
  }
  
  emergency_space: Emergency Space Available? {
    shape: diamond
    class: decision
  }
  
  cleanup_logs: Clean Up Old Log Files {
    class: recovery
  }
  
  reject_writes: Reject New Writes {
    class: error
  }
  
  force_checkpoint: Force Emergency Checkpoint {
    class: recovery
  }
  
  space_check -> emergency_space
  emergency_space -> cleanup_logs: Yes
  emergency_space -> reject_writes: No
  cleanup_logs -> force_checkpoint
}

recovery_failure_flow: Recovery Failure {
  recovery_attempt: Attempt Recovery {
    class: recovery
  }
  
  recovery_success: Recovery Successful? {
    shape: diamond
    class: decision
  }
  
  retry_count: Retry Count < Max? {
    shape: diamond
    class: decision
  }
  
  backup_recovery: Attempt Backup Recovery {
    class: recovery
  }
  
  manual_intervention: Require Manual Intervention {
    class: error
  }
  
  recovery_attempt -> recovery_success
  recovery_success -> retry_count: Failed
  retry_count -> backup_recovery: Yes
  retry_count -> manual_intervention: No
}

error_type -> corruption_flow: Log Corruption
error_type -> partial_write_flow: Partial Write
error_type -> disk_full_flow: Disk Full
error_type -> recovery_failure_flow: Recovery Failure

success_end: Operation Complete {
  shape: circle
  style.fill: "#00b894"
  style.font-color: "#ffffff"
}

failure_end: Operation Failed {
  shape: circle
  style.fill: "#d63031"
  style.font-color: "#ffffff"
}

normal_flow -> success_end
corruption_flow.skip_record -> success_end
partial_write_flow.truncate_log -> success_end
partial_write_flow.retry_write -> success_end
disk_full_flow.force_checkpoint -> success_end
recovery_failure_flow.recovery_success -> success_end: Success

corruption_flow.halt_recovery -> failure_end
disk_full_flow.reject_writes -> failure_end
recovery_failure_flow.manual_intervention -> failure_end