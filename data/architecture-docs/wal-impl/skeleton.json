{
  "title": "Write-Ahead Logging (WAL) Implementation: Design Document",
  "overview": "A crash-resistant transaction logging system that ensures database durability by writing all changes to a sequential log before applying them to the database. The key architectural challenge is implementing ARIES-style recovery that can reconstruct consistent database state after crashes by replaying committed transactions and rolling back incomplete ones.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Explains the durability problem in databases and why simple approaches fail during crashes",
      "subsections": [
        {
          "id": "durability-challenge",
          "title": "The Durability Challenge",
          "summary": "Why databases can't just write directly to disk and need transaction logging"
        },
        {
          "id": "crash-scenarios",
          "title": "Crash Recovery Scenarios",
          "summary": "Different failure modes and what happens to in-flight transactions"
        },
        {
          "id": "existing-approaches",
          "title": "Existing WAL Approaches",
          "summary": "Comparison of WAL implementations in PostgreSQL, SQLite, and MongoDB"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines what this WAL implementation will and won't support",
      "subsections": [
        {
          "id": "functional-goals",
          "title": "Functional Goals",
          "summary": "Core durability and recovery features this system must provide"
        },
        {
          "id": "non-functional-goals",
          "title": "Non-Functional Goals",
          "summary": "Performance, scalability, and reliability requirements"
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Features deliberately excluded to keep scope manageable"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Overview of major components and their relationships in the WAL system",
      "subsections": [
        {
          "id": "component-overview",
          "title": "Component Overview",
          "summary": "The four main subsystems: LogWriter, LogReader, RecoveryManager, and CheckpointManager"
        },
        {
          "id": "data-flow",
          "title": "Data Flow",
          "summary": "How write operations flow through the WAL before reaching the database"
        },
        {
          "id": "file-organization",
          "title": "File Organization",
          "summary": "Recommended module structure and file layout for the implementation"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Core data structures for log records, transactions, and recovery state (Milestone 1)",
      "subsections": [
        {
          "id": "log-record-format",
          "title": "Log Record Format",
          "summary": "Binary layout of log records with LSN, transaction ID, and operation data"
        },
        {
          "id": "record-types",
          "title": "Record Types",
          "summary": "Different types of log records: redo, undo, checkpoint, and commit records"
        },
        {
          "id": "serialization-format",
          "title": "Serialization Format",
          "summary": "Binary encoding scheme with CRC checksums and variable-length field handling"
        }
      ]
    },
    {
      "id": "log-writer",
      "title": "Log Writer Component",
      "summary": "Implements sequential, durable writing of log records to disk (Milestone 2)",
      "subsections": [
        {
          "id": "append-semantics",
          "title": "Append-Only Semantics",
          "summary": "Why WAL uses sequential writes and how atomic appends are guaranteed"
        },
        {
          "id": "durability-guarantees",
          "title": "Durability Guarantees",
          "summary": "fsync timing, group commit optimization, and force-write semantics"
        },
        {
          "id": "buffer-management",
          "title": "Buffer Management",
          "summary": "In-memory batching of log records before flushing to reduce I/O overhead"
        },
        {
          "id": "log-rotation",
          "title": "Log Rotation",
          "summary": "Creating new segment files when size limits are reached"
        }
      ]
    },
    {
      "id": "recovery-manager",
      "title": "Recovery Manager Component",
      "summary": "Implements ARIES-style crash recovery with redo and undo phases (Milestone 3)",
      "subsections": [
        {
          "id": "aries-overview",
          "title": "ARIES Recovery Overview",
          "summary": "The three-phase recovery algorithm: Analysis, Redo, Undo"
        },
        {
          "id": "log-scanning",
          "title": "Log Scanning and Analysis",
          "summary": "Reading log records to build transaction and dirty page tables"
        },
        {
          "id": "redo-phase",
          "title": "Redo Phase Implementation",
          "summary": "Replaying committed changes to restore database state"
        },
        {
          "id": "undo-phase",
          "title": "Undo Phase Implementation",
          "summary": "Rolling back incomplete transactions using before-images"
        }
      ]
    },
    {
      "id": "checkpoint-manager",
      "title": "Checkpoint Manager Component",
      "summary": "Implements fuzzy checkpointing to bound recovery time (Milestone 4)",
      "subsections": [
        {
          "id": "checkpoint-purpose",
          "title": "Checkpoint Purpose",
          "summary": "Why checkpoints are needed and how they speed up recovery"
        },
        {
          "id": "fuzzy-checkpoints",
          "title": "Fuzzy Checkpoint Algorithm",
          "summary": "Creating consistent checkpoints without blocking concurrent transactions"
        },
        {
          "id": "log-truncation",
          "title": "Log Truncation",
          "summary": "Safely removing old log entries after checkpoints"
        },
        {
          "id": "master-record",
          "title": "Master Record Management",
          "summary": "Tracking the most recent checkpoint for recovery start point"
        }
      ]
    },
    {
      "id": "interactions-flow",
      "title": "Interactions and Data Flow",
      "summary": "How components communicate during normal operations and crash recovery",
      "subsections": [
        {
          "id": "write-transaction-flow",
          "title": "Write Transaction Flow",
          "summary": "Step-by-step process from transaction start to commit"
        },
        {
          "id": "recovery-sequence",
          "title": "Recovery Sequence",
          "summary": "Detailed walkthrough of crash recovery from startup to ready state"
        },
        {
          "id": "checkpoint-coordination",
          "title": "Checkpoint Coordination",
          "summary": "How checkpoint creation interacts with ongoing transactions"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Failure modes, detection strategies, and recovery mechanisms",
      "subsections": [
        {
          "id": "corruption-detection",
          "title": "Corruption Detection",
          "summary": "Using CRC checksums and log structure validation to detect corruption"
        },
        {
          "id": "partial-writes",
          "title": "Partial Write Handling",
          "summary": "Dealing with torn pages and incomplete log records after crashes"
        },
        {
          "id": "disk-full-scenarios",
          "title": "Disk Full Scenarios",
          "summary": "Graceful handling when log disk space is exhausted"
        },
        {
          "id": "recovery-failures",
          "title": "Recovery Failures",
          "summary": "What to do when recovery itself encounters errors or corruption"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy",
      "summary": "Comprehensive testing approach for WAL correctness and crash safety",
      "subsections": [
        {
          "id": "unit-testing",
          "title": "Unit Testing",
          "summary": "Testing individual components in isolation with mock dependencies"
        },
        {
          "id": "crash-testing",
          "title": "Crash Testing",
          "summary": "Simulating crashes at various points to verify recovery correctness"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Checkpoints",
          "summary": "Specific tests and behaviors to verify after each implementation milestone"
        },
        {
          "id": "property-testing",
          "title": "Property-Based Testing",
          "summary": "Using randomized workloads to discover edge cases and invariant violations"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Common issues learners encounter and systematic approaches to diagnose them",
      "subsections": [
        {
          "id": "common-symptoms",
          "title": "Common Symptoms and Causes",
          "summary": "Symptom-to-cause mapping for typical WAL implementation bugs"
        },
        {
          "id": "diagnostic-techniques",
          "title": "Diagnostic Techniques",
          "summary": "Tools and approaches for inspecting log files and recovery state"
        },
        {
          "id": "logging-strategy",
          "title": "Logging and Observability",
          "summary": "Strategic logging points to trace WAL operations and recovery progress"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions",
      "summary": "Potential enhancements and how the current design accommodates them",
      "subsections": [
        {
          "id": "performance-optimizations",
          "title": "Performance Optimizations",
          "summary": "Group commit, log compression, and parallel recovery improvements"
        },
        {
          "id": "advanced-features",
          "title": "Advanced Features",
          "summary": "Point-in-time recovery, logical replication, and distributed WAL"
        },
        {
          "id": "scalability-improvements",
          "title": "Scalability Improvements",
          "summary": "Multiple log files, partitioned recovery, and async checkpointing"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Definitions of technical terms, acronyms, and domain-specific vocabulary",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "System Architecture Overview",
      "description": "Shows the four main components (LogWriter, LogReader, RecoveryManager, CheckpointManager) and their relationships to the main database and client applications. Include data flow arrows showing write path through WAL and recovery path during startup.",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-flow"
      ]
    },
    {
      "id": "log-record-structure",
      "title": "Log Record Data Model",
      "description": "Class diagram showing the relationship between different log record types (RedoRecord, UndoRecord, CheckpointRecord, CommitRecord) and their common base structure with LSN, transaction ID, and CRC fields.",
      "type": "class",
      "relevant_sections": [
        "data-model"
      ]
    },
    {
      "id": "write-transaction-sequence",
      "title": "Write Transaction Sequence",
      "description": "Sequence diagram showing the interaction between Client, TransactionManager, LogWriter, and Database during a normal write transaction. Shows log record creation, fsync timing, and database update order.",
      "type": "sequence",
      "relevant_sections": [
        "log-writer",
        "interactions-flow"
      ]
    },
    {
      "id": "recovery-process-flow",
      "title": "ARIES Recovery Process",
      "description": "Flowchart showing the three phases of ARIES recovery: Analysis (scan log, build tables), Redo (replay committed changes), and Undo (rollback incomplete transactions). Include decision points and state transitions.",
      "type": "flowchart",
      "relevant_sections": [
        "recovery-manager",
        "interactions-flow"
      ]
    },
    {
      "id": "checkpoint-state-machine",
      "title": "Checkpoint State Machine",
      "description": "State machine diagram showing checkpoint states (Idle, Collecting, Writing, Complete) and transitions triggered by checkpoint requests, dirty page scans, and log writes. Shows how fuzzy checkpoints avoid blocking normal operations.",
      "type": "state-machine",
      "relevant_sections": [
        "checkpoint-manager"
      ]
    },
    {
      "id": "log-file-layout",
      "title": "Log File Layout",
      "description": "Component diagram showing the physical structure of log files: segment files, master record, checkpoint records, and how log rotation creates new segments. Shows relationship between logical LSNs and physical file positions.",
      "type": "component",
      "relevant_sections": [
        "log-writer",
        "checkpoint-manager"
      ]
    },
    {
      "id": "recovery-data-structures",
      "title": "Recovery Data Structures",
      "description": "Class diagram showing the transaction table, dirty page table, and their relationship to log records during recovery. Shows how Analysis phase populates these tables for use in Redo and Undo phases.",
      "type": "class",
      "relevant_sections": [
        "recovery-manager",
        "data-model"
      ]
    },
    {
      "id": "error-handling-flow",
      "title": "Error Handling and Recovery Flows",
      "description": "Flowchart showing decision trees for handling different error scenarios: log corruption, partial writes, disk full, and recovery failures. Shows detection points and recovery strategies for each case.",
      "type": "flowchart",
      "relevant_sections": [
        "error-handling",
        "recovery-manager"
      ]
    }
  ]
}