{
  "title": "WebAssembly Emitter: Design Document",
  "overview": "A compiler backend that transforms high-level language constructs into WebAssembly binary format, handling the complexities of stack-based code generation and binary encoding. The key architectural challenge is bridging the gap between tree-structured source programs and WebAssembly's linear instruction format while maintaining correctness in stack depth management and binary section encoding.",
  "sections": [
    {
      "id": "context-problem",
      "title": "Context and Problem Statement",
      "summary": "Establishes the need for WebAssembly compilation and the challenges of binary format generation.",
      "subsections": [
        {
          "id": "mental-model",
          "title": "The Assembly Line Metaphor",
          "summary": "Understanding WebAssembly compilation as a factory process transforming high-level instructions into precise binary output"
        },
        {
          "id": "existing-approaches",
          "title": "Compiler Backend Approaches",
          "summary": "Comparison of different strategies for code generation and binary emission"
        },
        {
          "id": "wasm-challenges",
          "title": "WebAssembly-Specific Challenges",
          "summary": "Stack machines, variable-length encoding, and structured control flow requirements"
        }
      ]
    },
    {
      "id": "goals-non-goals",
      "title": "Goals and Non-Goals",
      "summary": "Defines the scope of the WebAssembly emitter, focusing on core binary generation without advanced optimizations.",
      "subsections": [
        {
          "id": "primary-goals",
          "title": "Primary Goals",
          "summary": "Core functionality for WebAssembly binary generation and basic language constructs"
        },
        {
          "id": "explicit-non-goals",
          "title": "Explicit Non-Goals",
          "summary": "Advanced optimizations, garbage collection, and complex runtime features"
        }
      ]
    },
    {
      "id": "high-level-architecture",
      "title": "High-Level Architecture",
      "summary": "Component overview showing the pipeline from AST to WebAssembly binary with clear separation of concerns.",
      "subsections": [
        {
          "id": "compilation-pipeline",
          "title": "Compilation Pipeline",
          "summary": "The sequential stages of transforming AST nodes into binary WebAssembly output"
        },
        {
          "id": "component-responsibilities",
          "title": "Component Responsibilities",
          "summary": "Clear delineation of what each major component handles in the compilation process"
        },
        {
          "id": "module-structure",
          "title": "Recommended Module Structure",
          "summary": "File organization and crate structure for maintainable WebAssembly compiler implementation"
        }
      ]
    },
    {
      "id": "data-model",
      "title": "Data Model",
      "summary": "Core types and structures representing WebAssembly concepts and intermediate compilation state.",
      "subsections": [
        {
          "id": "wasm-types",
          "title": "WebAssembly Type System",
          "summary": "Value types, function signatures, and type indices used throughout the module"
        },
        {
          "id": "intermediate-representation",
          "title": "Intermediate Representation",
          "summary": "Internal structures bridging AST nodes and binary WebAssembly instructions"
        },
        {
          "id": "binary-structures",
          "title": "Binary Format Structures",
          "summary": "Low-level types representing WebAssembly sections and binary encoding primitives"
        }
      ]
    },
    {
      "id": "binary-format-emitter",
      "title": "Binary Format Emitter Design",
      "summary": "Handles the low-level binary encoding of WebAssembly modules, including section structure and variable-length integer encoding.",
      "subsections": [
        {
          "id": "module-structure-mental-model",
          "title": "Module as Container Metaphor",
          "summary": "Understanding WebAssembly modules as structured containers with typed sections"
        },
        {
          "id": "leb128-encoding",
          "title": "LEB128 Variable-Length Encoding",
          "summary": "Algorithm and implementation strategy for WebAssembly's integer encoding format"
        },
        {
          "id": "section-emission",
          "title": "Section Emission Strategy",
          "summary": "Two-pass approach for calculating section sizes and emitting binary content"
        },
        {
          "id": "binary-format-adrs",
          "title": "Binary Format Architecture Decisions",
          "summary": "Key decisions around buffer management, error handling, and encoding strategies"
        },
        {
          "id": "binary-format-pitfalls",
          "title": "Common Binary Format Pitfalls",
          "summary": "Typical mistakes in LEB128 encoding, section ordering, and size calculation"
        }
      ]
    },
    {
      "id": "expression-compiler",
      "title": "Expression Compiler Design",
      "summary": "Transforms high-level expressions into stack-based WebAssembly instructions while managing operand ordering and local variables.",
      "subsections": [
        {
          "id": "stack-machine-mental-model",
          "title": "Stack Machine as Calculator Metaphor",
          "summary": "Understanding WebAssembly execution as a reverse Polish notation calculator"
        },
        {
          "id": "expression-traversal",
          "title": "AST to Stack Code Generation",
          "summary": "Post-order traversal algorithm for generating correct stack instruction sequences"
        },
        {
          "id": "local-variable-management",
          "title": "Local Variable Index Management",
          "summary": "Mapping source variables to WebAssembly local indices and scope handling"
        },
        {
          "id": "expression-compiler-adrs",
          "title": "Expression Compiler Architecture Decisions",
          "summary": "Decisions around operand ordering, type checking, and stack depth tracking"
        },
        {
          "id": "expression-compiler-pitfalls",
          "title": "Common Expression Compilation Pitfalls",
          "summary": "Stack imbalance issues, operand order mistakes, and type coercion problems"
        }
      ]
    },
    {
      "id": "control-flow-compiler",
      "title": "Control Flow Compiler Design",
      "summary": "Implements WebAssembly's structured control flow for conditionals and loops using label depth calculations and block nesting.",
      "subsections": [
        {
          "id": "structured-control-flow-mental-model",
          "title": "Structured Control Flow as Nested Containers",
          "summary": "Understanding WebAssembly blocks as nested scopes with explicit entry and exit points"
        },
        {
          "id": "label-depth-calculation",
          "title": "Label Depth and Branch Target Resolution",
          "summary": "Algorithm for calculating relative label indices for break and branch instructions"
        },
        {
          "id": "block-type-management",
          "title": "Block Type Annotations",
          "summary": "Determining and encoding block result types for structured control constructs"
        },
        {
          "id": "control-flow-adrs",
          "title": "Control Flow Architecture Decisions",
          "summary": "Decisions around label tracking, loop compilation strategies, and unreachable code handling"
        },
        {
          "id": "control-flow-pitfalls",
          "title": "Common Control Flow Pitfalls",
          "summary": "Label depth miscalculations, missing end markers, and unreachable code after branches"
        }
      ]
    },
    {
      "id": "function-module-system",
      "title": "Function and Module System Design",
      "summary": "Handles function compilation, type signatures, and module-level exports/imports to create complete WebAssembly modules.",
      "subsections": [
        {
          "id": "function-abi-mental-model",
          "title": "Function ABI as Interface Contract",
          "summary": "Understanding function signatures as contracts between caller and callee with parameter and result types"
        },
        {
          "id": "function-body-compilation",
          "title": "Function Body Compilation Process",
          "summary": "Multi-phase process for compiling function bodies including local allocation and instruction emission"
        },
        {
          "id": "export-import-system",
          "title": "Module Linking and Export System",
          "summary": "Mechanisms for making functions available to host environments and importing external functions"
        },
        {
          "id": "function-system-adrs",
          "title": "Function System Architecture Decisions",
          "summary": "Decisions around function indexing, parameter handling, and module composition"
        },
        {
          "id": "function-system-pitfalls",
          "title": "Common Function System Pitfalls",
          "summary": "Index confusion between parameters and locals, export name encoding issues, and body size calculation errors"
        }
      ]
    },
    {
      "id": "interactions-data-flow",
      "title": "Component Interactions and Data Flow",
      "summary": "Describes how compilation components communicate and the overall flow of data through the compilation pipeline.",
      "subsections": [
        {
          "id": "compilation-phases",
          "title": "Multi-Pass Compilation Strategy",
          "summary": "Sequential phases of compilation from AST analysis through binary emission"
        },
        {
          "id": "intermediate-formats",
          "title": "Intermediate Data Formats",
          "summary": "Data structures passed between compilation phases and their transformation rules"
        },
        {
          "id": "error-propagation",
          "title": "Error Propagation Between Components",
          "summary": "How compilation errors are detected, reported, and recovered from across component boundaries"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling and Edge Cases",
      "summary": "Comprehensive error handling strategy for compilation failures, malformed input, and WebAssembly validation errors.",
      "subsections": [
        {
          "id": "error-categories",
          "title": "Compilation Error Categories",
          "summary": "Classification of different types of errors that can occur during WebAssembly compilation"
        },
        {
          "id": "validation-strategy",
          "title": "WebAssembly Validation Integration",
          "summary": "How to integrate WebAssembly validation rules into the compilation process"
        },
        {
          "id": "recovery-mechanisms",
          "title": "Error Recovery and Partial Compilation",
          "summary": "Strategies for continuing compilation after errors and producing useful diagnostic information"
        }
      ]
    },
    {
      "id": "testing-strategy",
      "title": "Testing Strategy and Milestone Checkpoints",
      "summary": "Comprehensive testing approach with clear checkpoints after each milestone implementation.",
      "subsections": [
        {
          "id": "unit-testing-approach",
          "title": "Component-Level Unit Testing",
          "summary": "Testing individual components like LEB128 encoding, expression compilation, and binary emission"
        },
        {
          "id": "integration-testing",
          "title": "End-to-End Integration Testing",
          "summary": "Testing complete compilation pipeline with sample programs and WebAssembly runtime validation"
        },
        {
          "id": "milestone-checkpoints",
          "title": "Milestone Validation Checkpoints",
          "summary": "Specific verification steps and expected outputs after completing each project milestone"
        }
      ]
    },
    {
      "id": "debugging-guide",
      "title": "Debugging Guide",
      "summary": "Systematic approach to diagnosing and fixing common issues in WebAssembly compilation including tools and techniques.",
      "subsections": [
        {
          "id": "binary-format-debugging",
          "title": "Binary Format Debugging Techniques",
          "summary": "Tools and approaches for inspecting WebAssembly binary output and diagnosing encoding issues"
        },
        {
          "id": "stack-machine-debugging",
          "title": "Stack Machine Execution Debugging",
          "summary": "Techniques for tracing stack depth and instruction sequence correctness"
        },
        {
          "id": "common-bug-patterns",
          "title": "Common Bug Patterns and Fixes",
          "summary": "Systematic symptom-cause-fix mapping for typical WebAssembly compiler bugs"
        }
      ]
    },
    {
      "id": "future-extensions",
      "title": "Future Extensions and Scalability",
      "summary": "Potential enhancements to the WebAssembly emitter including optimizations, additional language features, and tooling integration.",
      "subsections": [
        {
          "id": "optimization-opportunities",
          "title": "Code Generation Optimizations",
          "summary": "Potential improvements to generated code quality and performance"
        },
        {
          "id": "language-feature-extensions",
          "title": "Additional Language Feature Support",
          "summary": "How the architecture could be extended to support more complex language constructs"
        },
        {
          "id": "tooling-integration",
          "title": "Development Tooling Integration",
          "summary": "Integration possibilities with debuggers, profilers, and development environments"
        }
      ]
    },
    {
      "id": "glossary",
      "title": "Glossary",
      "summary": "Comprehensive definitions of WebAssembly terminology, compilation concepts, and technical terms used throughout the document.",
      "subsections": []
    }
  ],
  "diagrams": [
    {
      "id": "system-architecture",
      "title": "WebAssembly Emitter System Architecture",
      "description": "High-level component diagram showing the compilation pipeline from AST input through Binary Format Emitter, Expression Compiler, Control Flow Compiler, and Function System to final WebAssembly binary output",
      "type": "component",
      "relevant_sections": [
        "high-level-architecture",
        "interactions-data-flow"
      ]
    },
    {
      "id": "data-model",
      "title": "WebAssembly Data Model and Type Relationships",
      "description": "Class diagram showing relationships between WebAssembly types (ValueType, FunctionType), intermediate representations (Expression, Instruction), and binary structures (Section, Module)",
      "type": "class",
      "relevant_sections": [
        "data-model",
        "binary-format-emitter"
      ]
    },
    {
      "id": "compilation-pipeline-flow",
      "title": "Compilation Pipeline Data Flow",
      "description": "Flowchart showing the sequential transformation of AST nodes through type analysis, expression compilation, control flow handling, function body generation, and binary emission",
      "type": "flowchart",
      "relevant_sections": [
        "interactions-data-flow",
        "expression-compiler",
        "control-flow-compiler"
      ]
    },
    {
      "id": "stack-machine-execution",
      "title": "Stack Machine Instruction Sequence",
      "description": "Sequence diagram showing how expressions like 'a + b * c' are transformed into stack operations: local.get a, local.get b, local.get c, i32.mul, i32.add",
      "type": "sequence",
      "relevant_sections": [
        "expression-compiler"
      ]
    },
    {
      "id": "control-flow-states",
      "title": "Control Flow Compilation State Machine",
      "description": "State machine showing transitions between compilation states for blocks, loops, and conditionals, including label depth tracking and branch target resolution",
      "type": "state-machine",
      "relevant_sections": [
        "control-flow-compiler"
      ]
    },
    {
      "id": "binary-section-structure",
      "title": "WebAssembly Binary Section Structure",
      "description": "Component diagram showing the hierarchical structure of a WebAssembly module with sections (Type, Function, Export, Code) and their internal organization",
      "type": "component",
      "relevant_sections": [
        "binary-format-emitter",
        "function-module-system"
      ]
    },
    {
      "id": "error-handling-flow",
      "title": "Error Detection and Recovery Flow",
      "description": "Flowchart showing how compilation errors are detected at different stages, categorized, and either recovered from or propagated to the user with appropriate diagnostic information",
      "type": "flowchart",
      "relevant_sections": [
        "error-handling",
        "debugging-guide"
      ]
    },
    {
      "id": "function-compilation-sequence",
      "title": "Function Compilation Process",
      "description": "Sequence diagram showing the multi-phase process of compiling a function: signature analysis, local allocation, body compilation, and binary emission with size calculation",
      "type": "sequence",
      "relevant_sections": [
        "function-module-system",
        "interactions-data-flow"
      ]
    }
  ]
}