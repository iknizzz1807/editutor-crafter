{
  "types": {
    "WebSocketServer": "EventEmitter managing connections and HTTP server",
    "HandshakeHandler": "keyCache Map, cacheTimeout Number",
    "ConnectionManager": "manages active connections and broadcasting",
    "Connection": "id String, socket Socket, state CONNECTION_STATES, readBuffer Buffer, messageFragments Array, currentFrameOpcode Number",
    "OPCODES": "CONTINUATION 0x0, TEXT 0x1, BINARY 0x2, CLOSE 0x8, PING 0x9, PONG 0xA",
    "CONNECTION_STATES": "CONNECTING, OPEN, CLOSING, CLOSED",
    "CLOSE_CODES": "NORMAL_CLOSURE 1000, GOING_AWAY 1001, PROTOCOL_ERROR 1002, UNSUPPORTED_DATA 1007, MESSAGE_TOO_BIG 1009, INTERNAL_ERROR 1011",
    "FrameParser": "static methods for parsing and assembly",
    "HeartbeatSystem": "connectionManager ConnectionManager, config Object, connectionHealthMap Map, timerWheelTimer Number, isRunning Boolean",
    "WebSocketFrame": "fin Boolean, opcode Number, masked Boolean, payloadLength Number, maskingKey Buffer, payload Buffer",
    "ConnectionRegistry": "thread-safe storage for connections",
    "Broadcaster": "handles message delivery to multiple connections",
    "ReadWriteLock": "concurrent read access with exclusive writes",
    "ConnectionHealth": "connectionId String, config Object, lastPingSent Number, lastPongReceived Number",
    "MonotonicTime": "startTime Number, startDate Number",
    "ErrorClassifier": "protocolViolations Map, networkFailures Map, resourceConstraints Map",
    "ResourceMonitor": "config Object, metrics Object, isMonitoring Boolean, monitoringTimer Number",
    "LoadShedder": "connectionManager ConnectionManager, resourceMonitor ResourceMonitor, sheddingActive Boolean, sheddingMetrics Object",
    "MockWebSocketClient": "EventEmitter for testing",
    "TestMonitor": "metrics tracking for load testing",
    "DiagnosticLogger": "config Object, logBuffer Array, correlationMap Map, timingMap Map",
    "ConnectionTracer": "connectionManager ConnectionManager, stateHistory Map, transitionValidation Map, raceConditionDetector Map",
    "PerformanceMonitor": "config Object, metrics Map, metricHistory Map, alerts Set, monitoringTimer Number",
    "MemoryTracker": "allocationMap Map, lifetimeTracking Map, leakDetection Map, gcImpactTracking Array",
    "ExtensionNegotiator": "registeredExtensions Map, extensionProcessingOrder Array",
    "PerMessageDeflateExtension": "serverMaxWindowBits Number, compressionContexts Map, threshold Number",
    "TLSWebSocketServer": "tlsOptions Object, server Object, certificateWatcher Object",
    "ClusterManager": "nodeId String, messageBus Object, clusterNodes Map, localConnections Map, remoteConnections Map",
    "MetricsCollector": "config Object, metrics Map, aggregationIntervals Map, exportTargets Array, isRunning Boolean",
    "HistogramAggregator": "buckets Array, counts Map",
    "ExtensionLoadTest": "config Object, connections Array, metrics Object"
  },
  "methods": {
    "generateAcceptKey(clientKey)": "computes Sec-WebSocket-Accept from client key",
    "validateClientKey(clientKey)": "validates base64 format of handshake key",
    "isControlFrame(opcode)": "determines if opcode represents control frame",
    "handleUpgrade(request, socket, head)": "processes HTTP upgrade to WebSocket",
    "broadcast(message, options)": "sends message to all or filtered connections",
    "shutdown(timeout)": "Graceful shutdown with connection draining",
    "validateUpgrade(request)": "validates HTTP upgrade request headers",
    "parseFrame(connection)": "extracts frames from connection buffer",
    "setState(newState)": "transitions connection to new state with validation",
    "appendToReadBuffer(data)": "adds incoming bytes to connection buffer",
    "consumeFromReadBuffer(byteCount)": "extracts and removes bytes from buffer",
    "parseFromBuffer(buffer)": "parses WebSocket frame from buffer bytes",
    "toBuffer()": "converts frame to binary buffer format",
    "isValidUTF8(buffer)": "validates UTF-8 encoding in buffer",
    "isValidOpcode(opcode)": "checks if opcode is defined in protocol",
    "unmaskPayload(payload, maskingKey)": "applies XOR unmasking to frame payload",
    "assembleMessage(connection, frame)": "handles message fragmentation and assembly",
    "createConnection(socket, upgradeRequest)": "creates and registers new WebSocket connection",
    "activateConnection(connectionId)": "completes handshake and transitions to OPEN",
    "closeConnection(connectionId, closeCode, reason)": "initiates graceful close handshake",
    "sendFrame(frame)": "sends WebSocket frame to client",
    "sendText(text)": "sends text message to client",
    "sendBinary(data)": "sends binary message to client",
    "getStats()": "returns heartbeat system statistics",
    "start()": "starts heartbeat monitoring system",
    "stop()": "stops heartbeat monitoring system",
    "addConnection(connectionId)": "registers connection for heartbeat monitoring",
    "removeConnection(connectionId)": "removes connection from heartbeat monitoring",
    "handlePongFrame(connectionId, pongFrame)": "processes incoming pong response",
    "processTimerTick()": "main timer wheel processing",
    "sendPingFrame(connectionId)": "sends ping frame to connection",
    "cleanupDeadConnection(connectionId, reason)": "cleans up dead connection",
    "createPingPayload(sequence)": "creates binary ping payload",
    "now()": "returns monotonic time",
    "toAbsolute(monotonicTime)": "converts to absolute timestamp",
    "recordPingSent(currentTime)": "records ping transmission",
    "recordPongReceived(currentTime, payload)": "records pong reception",
    "checkHealth(currentTime)": "checks connection health status",
    "classifyError(error, context)": "determines error category, severity, and response",
    "collectMetrics()": "gathers current system resource metrics",
    "evaluateAndShedLoad(resourceMetrics)": "implements connection shedding if needed",
    "handleViolation(connectionId, violation, context)": "processes protocol violations",
    "validateFrame(frame, connection)": "validates WebSocket frame structure",
    "rankConnectionsForShedding(connections)": "prioritizes connections for load shedding",
    "createTestServer(config)": "factory for test server instances",
    "validateMilestone(milestoneNumber)": "validates milestone completion",
    "recordConnection()": "tracks connection metrics",
    "generateReport()": "creates test performance report",
    "logHandshake(connectionId, phase, data)": "logs handshake progression with cryptographic details",
    "logFrameParsing(connectionId, frameData, parseResult)": "logs binary frame analysis with hex dumps",
    "logConnectionState(connectionId, transition, metadata)": "logs state machine transitions with validation",
    "logPerformanceMetrics(component, operation, metrics)": "logs performance measurements with analysis",
    "traceStateTransition(connectionId, fromState, toState, trigger)": "records state transition with thread information",
    "detectRaceConditions(connectionId, operation, threadId)": "identifies concurrent operations and race conditions",
    "validateConnectionConsistency()": "scans connections for state consistency",
    "collectSystemMetrics()": "gathers CPU, memory, and process information",
    "collectConnectionMetrics(connectionManager)": "gathers per-connection metrics",
    "analyzePerformanceTrends()": "identifies performance degradation patterns",
    "trackAllocation(objectType, size, context)": "records object allocation with attribution",
    "trackDeallocation(objectType, size, context)": "records object deallocation and lifetime",
    "analyzeMemoryLeaks()": "statistical analysis of allocation patterns",
    "registerExtension(extensionName, extensionHandler)": "Register extension with negotiation and processing logic",
    "negotiateExtensions(clientExtensions, serverCapabilities)": "Process extension header during handshake",
    "processOutgoingFrame(frame, connectionExtensions)": "Apply extensions to outgoing frames",
    "processIncomingFrame(frame, connectionExtensions)": "Process incoming frames through extension pipeline",
    "negotiate(clientParams)": "Negotiate compression parameters with client",
    "initializeContext(connectionId)": "Initialize compression context for connection",
    "compressMessage(connectionId, payload)": "Compress outgoing message payload",
    "decompressMessage(connectionId, payload)": "Decompress incoming message payload",
    "start(port, hostname, callback)": "Start HTTPS server with WebSocket upgrade",
    "startCertificateWatcher()": "Monitor certificate files for changes",
    "initialize()": "Initialize cluster participation",
    "routeMessage(targetConnectionId, message)": "Route message to appropriate cluster node",
    "broadcast(message, filter)": "Handle cross-node broadcast requests",
    "handleClusterMessage(sourceNodeId, messageType, payload)": "Process messages from other cluster nodes",
    "handleNodeFailure(failedNodeId)": "Handle cluster node failures and recovery",
    "registerMetric(name, type, description, labels)": "Register new metric with aggregation strategy",
    "recordMetric(name, value, labels)": "Record metric value with optional labels",
    "createAggregator(type)": "Create metric aggregator based on type",
    "record(labelKey, value)": "Record value in histogram bucket",
    "aggregate()": "Calculate percentiles and histogram data",
    "runCompressionTest()": "Load test compression extension performance",
    "runClusteringTest()": "Load test clustering message routing"
  },
  "constants": {
    "WEBSOCKET_MAGIC_GUID": "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    "MAX_CONTROL_FRAME_PAYLOAD_LENGTH": "125 bytes maximum",
    "DEFAULT_CONFIG": "default server configuration values",
    "MAX_CONNECTIONS": "maximum concurrent connections limit",
    "CONNECTION_TIMEOUT": "handshake completion timeout",
    "HEARTBEAT_INTERVAL": "30000",
    "MAX_MESSAGE_SIZE": "maximum message size limit",
    "CLOSE_TIMEOUT": "maximum time for close handshake",
    "OPCODES.PING": "0x9",
    "OPCODES.PONG": "0xA",
    "CLOSE_CODES.GOING_AWAY": "1001",
    "HEARTBEAT_TIMEOUT": "10000",
    "MAX_MISSED_PONGS": "2",
    "MAX_CONNECTIONS_PER_IP": "per-IP connection limit",
    "MAX_CONNECTIONS_PER_MINUTE_PER_IP": "per-IP rate limit",
    "DEFAULT_BUFFER_SIZE": "default connection buffer size",
    "FRAGMENT_TIMEOUT": "timeout for incomplete fragmented messages",
    "WRITE_TIMEOUT": "timeout for write operations",
    "TARGET_CONNECTIONS": "1000 for load testing",
    "OPCODES": "CONTINUATION 0x0, TEXT 0x1, BINARY 0x2, CLOSE 0x8, PING 0x9, PONG 0xA",
    "CONNECTION_STATES": "CONNECTING, OPEN, CLOSING, CLOSED"
  },
  "terms": {
    "handshake": "HTTP upgrade process to establish WebSocket connection",
    "frame parsing": "extracting WebSocket messages from binary frame format",
    "masking": "XOR encoding required for client-to-server frames",
    "fragmentation": "splitting large messages across multiple frames",
    "heartbeat": "ping/pong mechanism for connection health monitoring",
    "bidirectional communication": "both client and server can initiate messages",
    "connection state machine": "lifecycle management for WebSocket connections",
    "opcode": "4-bit field identifying frame type and handling requirements",
    "continuation frame": "frame type used for message fragments after the first",
    "control frame": "ping, pong, or close frame with special handling rules",
    "connection lifecycle": "state machine for connection states and transitions",
    "broadcasting": "sending message to multiple connections efficiently",
    "connection registry": "thread-safe storage for active connections",
    "state machine": "formal model for connection state transitions",
    "graceful shutdown": "orderly close with proper cleanup",
    "heartbeat monitoring": "ping/pong health checks for connections",
    "resource cleanup": "proper disposal of memory and handles",
    "concurrent access": "thread-safe operations on shared data",
    "ping frame": "control frame sent to test connection liveness",
    "pong frame": "control frame response to ping",
    "timer wheel": "efficient scheduling algorithm for connection timing",
    "monotonic time": "clock source unaffected by system time changes",
    "connection health": "liveness and quality state of WebSocket connection",
    "timeout detection": "identifying unresponsive connections",
    "round-trip time": "network latency measurement via ping/pong",
    "dead connection": "unresponsive connection requiring cleanup",
    "protocol violation": "breach of RFC 6455 WebSocket protocol rules",
    "load shedding": "selective connection termination during resource pressure",
    "graceful degradation": "reducing service quality to maintain core functionality",
    "resource constraint": "system limit on memory, CPU, connections, or I/O",
    "circuit breaker": "pattern to prevent cascade failures by disabling failing components",
    "connection prioritization": "ranking connections by importance for resource allocation",
    "error classification": "categorizing errors by type, severity, and appropriate response",
    "resource monitoring": "tracking system resource utilization and health",
    "backpressure": "flow control mechanism to prevent resource exhaustion",
    "connection admission control": "policies for accepting or rejecting new connections",
    "unit testing": "testing components in isolation with mocked dependencies",
    "integration testing": "testing component interactions and end-to-end flows",
    "load testing": "testing system capacity and performance under high load",
    "milestone validation": "comprehensive checkpoint testing for development stages",
    "protocol compliance": "adherence to RFC 6455 WebSocket specification",
    "connection capacity": "maximum concurrent connections the server can handle",
    "message throughput": "rate of message processing and delivery",
    "resource exhaustion": "system behavior when limits are exceeded",
    "performance benchmarks": "baseline metrics for regression testing",
    "memory leak testing": "validation of proper resource cleanup",
    "memory leak": "unreleased memory allocation causing gradual resource exhaustion",
    "race condition": "concurrent access to shared resources causing inconsistent state",
    "performance bottleneck": "component or operation that limits overall system throughput",
    "diagnostic logging": "detailed instrumentation for debugging and analysis",
    "protocol extensions": "WebSocket extensions that add capabilities like compression or multiplexing",
    "per-message-deflate": "WebSocket compression extension using DEFLATE algorithm",
    "extension negotiation": "Handshake process to agree on WebSocket extensions",
    "TLS integration": "Adding encrypted WebSocket Secure (WSS) support",
    "clustering": "Distributed WebSocket server architecture with multiple nodes",
    "horizontal scaling": "Adding more server instances to handle increased load",
    "load balancing": "Distributing connections across multiple server instances",
    "session affinity": "Routing client connections to the same backend server",
    "consistent hashing": "Deterministic server selection algorithm for load distribution",
    "metrics collection": "Gathering performance and operational data",
    "distributed tracing": "Tracking request flows across multiple services",
    "connection capacity monitoring": "Tracking connection count against configured limits",
    "rate limiting": "Controlling message or connection rates to prevent abuse",
    "geographic distribution": "Deploying servers in multiple regions for latency reduction"
  }
}