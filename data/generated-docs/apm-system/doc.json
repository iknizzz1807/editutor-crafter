{"html":"<h1 id=\"apm-tracing-system-design-document\">APM Tracing System: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>We are building an Application Performance Monitoring (APM) system that tracks requests as they flow through a distributed application, creating detailed traces. The key architectural challenge is efficiently collecting, storing, and analyzing massive volumes of trace data while preserving the most valuable insights for debugging and performance optimization.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"1-context-and-problem-statement\">1. Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides the foundational context for all subsequent milestones, explaining the core problems that the entire APM Tracing System is designed to solve.</p>\n</blockquote>\n<p>Imagine you&#39;re tasked with investigating a performance problem in a modern application. A user reports that a specific action—say, &quot;checkout&quot; in an e-commerce app—is taking 15 seconds to complete, far longer than the expected 2 seconds. The application isn&#39;t a single monolithic program but a constellation of dozens, sometimes hundreds, of microservices. The request from the user&#39;s browser might touch a frontend API gateway, which calls a user service for authentication, which then calls a product catalog service, which queries a database, then calls an inventory service, which publishes an event to a message queue, which is consumed by a shipping service, and so on. Each of these steps could be running on different machines, in different data centers, managed by different teams.</p>\n<p>Without a specialized observability tool, diagnosing this slowdown is like trying to solve a murder mystery where each witness (service) only saw a tiny fragment of the event and speaks a different language. You might find a log in the API gateway showing it took 14 seconds to get a response from the user service. But why? Is the user service slow, or is it waiting on something else? Is the database overloaded? Is there a network partition? Traditional logging and metrics give you isolated data points, but they don&#39;t show you the complete journey of the request as it traverses this complex distributed system. This is the fundamental problem that distributed tracing, and by extension an Application Performance Monitoring (APM) system, exists to solve.</p>\n<h3 id=\"mental-model-the-distributed-detective\">Mental Model: The Distributed Detective</h3>\n<p>Think of a <strong>distributed trace</strong> as the complete <strong>case file</strong> for a single request&#39;s journey through your system. Every time a request enters your application, a new case is opened. As the request moves from service to service, each service creates a <strong>span</strong>—a structured log entry that represents a single unit of work (like a database query or an HTTP call) within that service&#39;s handling of the request. A span contains crucial evidence: what operation was performed, when it started and ended, what service executed it, and whether it succeeded or failed.</p>\n<p>Most importantly, spans are linked. Each span knows the ID of the overarching <strong>trace</strong> (the case file) and the ID of its <strong>parent span</strong> (the previous step in the journey). This creates a hierarchical timeline—a <strong>trace tree</strong>—that reconstructs the exact path and timing of the request.</p>\n<p>Now, picture the APM system as the <strong>distributed detective</strong>. Its job is to:</p>\n<ol>\n<li><strong>Collect</strong> all the span evidence from every service (the witnesses).</li>\n<li><strong>Assemble</strong> the spans into their correct trace trees, linking parent to child across service boundaries.</li>\n<li><strong>Analyze</strong> the assembled traces to answer critical questions: Where was the time spent? Which service was the bottleneck? Did an error in one service cascade to others?</li>\n<li><strong>Visualize</strong> the results, showing the detective (the engineer) not just a single request&#39;s timeline, but also the bigger picture: a map of how all services interact, statistical summaries of performance, and alerts when things deviate from the norm.</li>\n</ol>\n<p>This mental model shifts debugging from sifting through disjointed logs to reading a coherent, end-to-end story of a request&#39;s life. It turns the opaque distributed system into a transparent, understandable entity.</p>\n<h3 id=\"the-observability-challenge-in-microservices\">The Observability Challenge in Microservices</h3>\n<p>Microservices architecture delivers benefits in scalability, developer autonomy, and deployment velocity, but it fundamentally changes the nature of debugging and performance analysis. The core challenges can be distilled into three concrete problems:</p>\n<ol>\n<li><p><strong>The End-to-End Latency Puzzle:</strong> When a user-facing operation is slow, the root cause can be anywhere. A latency metric on your API gateway tells you the <em>symptom</em> (total time = 15s), but not the <em>cause</em>. Without tracing, you must manually hop from service to service, checking their individual metrics and logs, trying to correlate timestamps—a process that is slow, error-prone, and often impossible when calls are asynchronous or batched.</p>\n</li>\n<li><p><strong>The Cascading Failure Mystery:</strong> A failure in one service can propagate in non-obvious ways. For example, if a payment service times out, the order service might retry three times, queueing requests and consuming threads, which then causes the order service itself to become slow and start timing out requests to the inventory service. Looking at the inventory service&#39;s logs, you might see a surge in timeouts and conclude it&#39;s the problem, missing the true root cause two hops upstream. Understanding these failure propagation paths requires seeing the call graph.</p>\n</li>\n<li><p><strong>The Dependency Map Blind Spot:</strong> As systems grow organically, implicit dependencies emerge. Service A might start calling Service C indirectly through Service B. Old dependencies might linger long after they&#39;re no longer used. Without a dynamic, data-driven view of service communications, system architecture diagrams quickly become outdated. This makes impact analysis for deployments, capacity planning, and failure domain isolation guesswork.</p>\n</li>\n</ol>\n<p>The following table summarizes the shift in observability requirements from monolithic to microservices architectures:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Observability Aspect</th>\n<th align=\"left\">Monolithic Application</th>\n<th align=\"left\">Microservices Architecture</th>\n<th align=\"left\">New Challenge</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Latency Attribution</strong></td>\n<td align=\"left\">Profiling within a single process pinpoints slow functions.</td>\n<td align=\"left\">Latency is distributed across network calls and process boundaries.</td>\n<td align=\"left\">Need to attribute time to specific remote calls and understand serial vs. parallel execution.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Error Propagation</strong></td>\n<td align=\"left\">Stack trace localizes error to a module/function.</td>\n<td align=\"left\">Error in one service may manifest as a timeout or degraded behavior in another.</td>\n<td align=\"left\">Need to reconstruct the call chain to find the origin of a fault.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>System Topology</strong></td>\n<td align=\"left\">Static, defined by code structure.</td>\n<td align=\"left\">Dynamic, defined by runtime service discovery and communication.</td>\n<td align=\"left\">Need to discover and visualize the runtime dependency graph.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Debugging Data</strong></td>\n<td align=\"left\">Centralized logs and metrics from one application.</td>\n<td align=\"left\">Data is siloed across many independent services and teams.</td>\n<td align=\"left\">Need to correlate events across service boundaries with a common request identifier.</td>\n</tr>\n</tbody></table>\n<p>These challenges are not merely incremental; they represent a qualitative change in complexity. Traditional monitoring tools, designed for monoliths or simple client-server models, are ill-equipped to provide the necessary cross-boundary visibility.</p>\n<h3 id=\"existing-approaches-and-trade-offs\">Existing Approaches and Trade-offs</h3>\n<p>Before committing to building a dedicated tracing system, it&#39;s essential to understand what existing observability tools can and cannot do. Most teams already use some combination of <strong>logs</strong>, <strong>metrics</strong>, and <strong>health checks</strong>. Each plays a role, but each has significant gaps when it comes to understanding distributed request flow.</p>\n<blockquote>\n<p><strong>Decision: Build a Dedicated Distributed Tracing System</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to understand request flow across microservices for debugging and performance optimization. Existing logging and metrics systems are insufficient for this task.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Enhanced Logging</strong>: Inject a common <code>trace_id</code> into every log line across all services and use a log aggregator (e.g., ELK Stack) to correlate them.</li>\n<li><strong>Enhanced Metrics</strong>: Instrument each service to emit fine-grained timing histograms for all outgoing calls and try to infer relationships from dashboards.</li>\n<li><strong>Dedicated Distributed Tracing</strong>: Implement the OpenTelemetry tracing standard, collect spans, and build a system specifically for assembling and analyzing traces.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Option 3 — Build a dedicated distributed tracing system.</li>\n<li><strong>Rationale</strong>: While logging with <code>trace_id</code> provides some correlation, it lacks the structured hierarchy and timing relationships inherent to spans. Logs are also unstructured and expensive to query for complex path analysis. Metrics can show aggregates but lose individual request context, making it impossible to debug specific user issues. A dedicated tracing system is built around the first-class concepts of traces and spans, enabling efficient storage, precise reconstruction of call graphs, and specialized analytics (like service maps and tail-based sampling) that are impractical with generic tools.</li>\n<li><strong>Consequences</strong>: We must build and operate a new subsystem, but we gain unparalleled visibility into request flow, enabling faster debugging, performance optimization, and system understanding. The system will complement, not replace, existing logs and metrics.</li>\n</ul>\n</blockquote>\n<p>The table below details the trade-offs between these three pillars of observability, highlighting why tracing is a necessary addition:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Approach</th>\n<th align=\"left\">How It Works</th>\n<th align=\"left\">Strengths</th>\n<th align=\"left\">Weaknesses for Distributed Debugging</th>\n<th align=\"left\">Role in Our APM System</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Logging</strong></td>\n<td align=\"left\">Applications emit timestamped text lines describing events. Central aggregator indexes and enables search.</td>\n<td align=\"left\"><strong>High detail</strong>: Can capture any arbitrary event or state. <strong>Flexible</strong>: No predefined schema. <strong>Ubiquitous</strong>: Every application does it.</td>\n<td align=\"left\"><strong>No structure</strong>: Hard to extract consistent fields (e.g., duration, parent ID). <strong>Expensive correlation</strong>: Finding all logs for one request requires scanning millions of lines. <strong>No hierarchy</strong>: Can&#39;t easily visualize parent-child relationships or parallel operations.</td>\n<td align=\"left\">Logs remain crucial for deep, unstructured debugging <em>within</em> a service. The APM system will <strong>correlate</strong> trace IDs with log entries, allowing engineers to jump from a slow span to the relevant service logs.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Metrics</strong></td>\n<td align=\"left\">Services emit numerical measurements (counters, gauges, histograms) at regular intervals. Time-series database stores and dashboards visualize.</td>\n<td align=\"left\"><strong>Aggregation</strong>: Excellent for trends, alerts, and SLOs. <strong>Low overhead</strong>: Sampled and pre-aggregated. <strong>High cardinality</strong>: Modern systems can handle many dimensions.</td>\n<td align=\"left\"><strong>Loss of context</strong>: You see <em>that</em> the 95th percentile latency for Service A spiked, but not <em>which specific requests</em> caused it or <em>why</em>. <strong>No causal links</strong>: Cannot show that a latency spike in Service B caused an error rate increase in Service A.</td>\n<td align=\"left\">Metrics provide the <strong>health dashboard</strong> and <strong>alerting</strong> backbone. The APM system will <strong>generate metrics</strong> from trace data (e.g., request rate, error rate, latency percentiles per service/operation) and may trigger alerts based on trace-derived anomalies.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Distributed Tracing</strong></td>\n<td align=\"left\">Services emit structured <strong>spans</strong> for units of work, linked by trace and parent IDs. Collector assembles spans into trace trees.</td>\n<td align=\"left\"><strong>Request-centric view</strong>: See the complete story of a single user request. <strong>Causal links</strong>: Clear parent-child relationships across services. <strong>Timing context</strong>: Understand serialization, parallelization, and waiting time.</td>\n<td align=\"left\"><strong>High volume</strong>: Can generate massive amounts of data. Requires <strong>sampling</strong>. <strong>Instrumentation cost</strong>: Requires code changes or auto-instrumentation. <strong>Complex backend</strong>: Needs specialized storage and query.</td>\n<td align=\"left\">This is the <strong>core</strong> of our APM system. It provides the connective tissue between logs and metrics, answering the &quot;why&quot; and &quot;how&quot; behind the &quot;what&quot; shown by metrics and logs.</td>\n</tr>\n</tbody></table>\n<p>The synergy between these three signals is often described as the <strong>Observability Golden Triangle</strong>. An engineer might:</p>\n<ol>\n<li>See a <strong>metric</strong> alert for high p95 latency on the checkout endpoint.</li>\n<li>Use the <strong>tracing</strong> system to sample recent slow traces for that endpoint, instantly visualizing that the delay is in the payment service, specifically in a call to a third-party card processor.</li>\n<li>Click from the slow payment span in the trace view to search <strong>logs</strong> from the payment service filtered by that specific <code>trace_id</code>, revealing an error message from the third-party API about an expired certificate.</li>\n</ol>\n<p>This integrated workflow reduces mean time to resolution (MTTR) from hours or days to minutes. Our APM Tracing System aims to be the central platform that makes this workflow not just possible, but efficient and scalable.</p>\n<hr>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>As this is the foundational context section, there is no direct implementation to be done. However, the concepts introduced here directly inform the architecture and design decisions in all subsequent sections. The following table maps the high-level observability concepts to the concrete components you will build in the upcoming milestones.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Conceptual Need</th>\n<th align=\"left\">APM System Component (Milestone)</th>\n<th align=\"left\">What You&#39;ll Build</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Collect evidence (spans) from all services</strong></td>\n<td align=\"left\">Trace Collector (Milestone 1)</td>\n<td align=\"left\">HTTP/gRPC servers to receive spans, buffering logic, storage layer.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Assemble spans into trace trees</strong></td>\n<td align=\"left\">Trace Collector &amp; Storage (Milestone 1)</td>\n<td align=\"left\">Indexing by <code>trace_id</code>, logic to handle out-of-order span arrival.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Understand service relationships</strong></td>\n<td align=\"left\">Service Map (Milestone 2)</td>\n<td align=\"left\">Graph construction algorithms that analyze spans to build a dependency map.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Manage data volume</strong></td>\n<td align=\"left\">Trace Sampling (Milestone 3)</td>\n<td align=\"left\">Head-based and tail-based sampling algorithms to filter traces intelligently.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Analyze performance trends</strong></td>\n<td align=\"left\">Performance Analytics (Milestone 4)</td>\n<td align=\"left\">Percentile calculators (t-digest) and anomaly detectors for time-series data.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Generate spans automatically</strong></td>\n<td align=\"left\">APM SDK (Milestone 5)</td>\n<td align=\"left\">Auto-instrumentation libraries for HTTP, databases, and frameworks.</td>\n</tr>\n</tbody></table>\n<p>Before starting implementation, ensure you are comfortable with the core data model that will be used throughout the system, which is defined in the <strong>Data Model</strong> section (Section 4). The key entities are:</p>\n<ul>\n<li><strong>Trace</strong>: The entire record of a request&#39;s journey, comprised of all its spans.</li>\n<li><strong>Span</strong>: A named, timed operation representing a unit of work within a trace.</li>\n<li><strong>Service</strong>: A logical component of the application (e.g., <code>checkout-service</code>, <code>user-db</code>).</li>\n</ul>\n<p>Proceed to the <strong>High-Level Architecture</strong> section (Section 3) to see how these components fit together into a cohesive system.</p>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides the foundational scope definition that applies to ALL subsequent milestones, setting clear boundaries for what the APM Tracing System will and will not address.</p>\n</blockquote>\n<h2 id=\"2-goals-and-non-goals\">2. Goals and Non-Goals</h2>\n<p>Establishing clear boundaries is critical for the success of any complex system. Without explicit goals, scope creep becomes inevitable, leading to an unfocused product that attempts to solve every observability problem but masters none. Conversely, without declared non-goals, stakeholders may assume capabilities the system was never designed to provide, resulting in disappointment and misuse.</p>\n<p>This section explicitly defines <strong>what the APM Tracing System must deliver</strong> and, equally important, <strong>what it explicitly will not attempt</strong>. These boundaries serve as guardrails for architectural decisions and prioritization throughout the project.</p>\n<h3 id=\"goals-what-we-must-do\">Goals (What We Must Do)</h3>\n<p>The primary goal of this system is to provide <strong>end-to-end visibility into request flow across a distributed application</strong>, enabling developers to debug performance issues, understand service dependencies, and identify anomalies. The system must achieve this while operating efficiently at scale, balancing data volume with insight quality.</p>\n<p>The following table enumerates the mandatory functional requirements, each mapped to its corresponding project milestone:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Goal ID</th>\n<th align=\"left\">Functional Requirement</th>\n<th align=\"left\">Description</th>\n<th align=\"left\">Corresponding Milestone</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>G1</strong></td>\n<td align=\"left\"><strong>Collect and Store Distributed Traces</strong></td>\n<td align=\"left\">Ingest spans in OpenTelemetry format via HTTP/gRPC, correctly assemble them into traces using parent-child relationships, and persistently store them with efficient indexing for retrieval by trace ID. The system must handle at least 1000 spans per second without data loss.</td>\n<td align=\"left\">Milestone 1: Trace Collection</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>G2</strong></td>\n<td align=\"left\"><strong>Generate and Visualize a Dynamic Service Dependency Map</strong></td>\n<td align=\"left\">Automatically derive a directed graph of service-to-service communication from trace data. Compute and display key metrics (request count, latency, error rate) for each edge. Update the map in near-real-time as new trace data arrives.</td>\n<td align=\"left\">Milestone 2: Service Map</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>G3</strong></td>\n<td align=\"left\"><strong>Implement Intelligent, Adaptive Trace Sampling</strong></td>\n<td align=\"left\">Reduce storage and processing costs by filtering traces while preserving diagnostically valuable data. Support both head-based (probabilistic at trace start) and tail-based (decision after trace completion based on errors/latency) sampling strategies. Allow per-service configuration.</td>\n<td align=\"left\">Milestone 3: Trace Sampling</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>G4</strong></td>\n<td align=\"left\"><strong>Provide Performance Analytics and Anomaly Detection</strong></td>\n<td align=\"left\">Calculate latency percentiles (p50, p95, p99) per service and operation. Establish historical baselines and detect deviations using statistical methods. Generate alerts for performance regressions.</td>\n<td align=\"left\">Milestone 4: Performance Analytics &amp; Anomaly Detection</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>G5</strong></td>\n<td align=\"left\"><strong>Offer Auto-Instrumentation via an APM SDK</strong></td>\n<td align=\"left\">Provide client libraries that automatically instrument common frameworks (HTTP servers/clients, database drivers) to generate spans and propagate trace context without requiring manual code changes. Support W3C Trace Context standard.</td>\n<td align=\"left\">Milestone 5: APM SDK &amp; Auto-Instrumentation</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>G6</strong></td>\n<td align=\"left\"><strong>Ensure High Performance and Low Overhead</strong></td>\n<td align=\"left\">The data collection path (from SDK through Collector to storage) must add minimal latency to instrumented applications. Ingestion acknowledgment should occur within 100ms. The SDK&#39;s instrumentation overhead must be negligible for production workloads.</td>\n<td align=\"left\">Cross-cutting (All Milestones)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>G7</strong></td>\n<td align=\"left\"><strong>Design for Horizontal Scalability and Resilience</strong></td>\n<td align=\"left\">The core components (Collector, storage, query services) must be deployable as multiple instances to handle load increases. The system should gracefully degrade (e.g., via increased sampling) under extreme load rather than fail catastrophically.</td>\n<td align=\"left\">Cross-cutting (All Milestones)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Design Insight:</strong> The goals are intentionally ordered to reflect the <strong>data pipeline&#39;s natural flow</strong>. You must first collect data (G1) before you can analyze it to build a service map (G2). You need the raw data volume (G1) before you need to manage it via sampling (G3). The SDK (G5) is the source of all data, but its design is influenced by the needs of the entire pipeline.</p>\n</blockquote>\n<p>Beyond these functional goals, the system adheres to several key architectural principles:</p>\n<ul>\n<li><strong>Open Standards First:</strong> Prioritize compatibility with the OpenTelemetry specification for data format and context propagation (<code>TRACE_ID_HEADER: traceparent</code>, <code>SPAN_ID_HEADER: tracestate</code>). This ensures interoperability with a broader ecosystem of tools.</li>\n<li><strong>Observability of the Observability System:</strong> The system itself must be monitorable, providing its own metrics (e.g., ingestion rate, sampling decisions, storage health) and logs.</li>\n<li><strong>Operator-Friendly Configuration:</strong> Sampling rates, storage backends, and aggregation intervals must be configurable without requiring code deploys, ideally via runtime configuration or feature flags.</li>\n</ul>\n<h3 id=\"non-goals-what-we-explicitly-won39t-do\">Non-Goals (What We Explicitly Won&#39;t Do)</h3>\n<p>A system&#39;s strength often lies in what it chooses <em>not</em> to do. The following are explicitly out of scope for this version of the APM Tracing System. This clarity prevents misallocation of engineering effort and sets correct expectations for users.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Non-Goal ID</th>\n<th align=\"left\">Out-of-Scope Capability</th>\n<th align=\"left\">Rationale &amp; Guidance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>NG1</strong></td>\n<td align=\"left\"><strong>Real User Monitoring (RUM) / Browser Tracing</strong></td>\n<td align=\"left\">We will not instrument client-side web applications to capture browser performance metrics, page load events, or user interaction timings. This domain requires handling of synthetic versus real user data, geolocation, and device fragmentation. <strong>Consideration:</strong> Traces will start at the first instrumented backend service.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>NG2</strong></td>\n<td align=\"left\"><strong>Log Aggregation and Centralized Logging</strong></td>\n<td align=\"left\">While <code>Span.Events</code> can capture log-like data, we will not build a general-purpose log ingestion, indexing, and search system (e.g., like ELK Stack or Loki). Traces are for structured performance data; logs are for unstructured diagnostic text. <strong>Consideration:</strong> Use a dedicated logging system and correlate logs to traces via <code>TraceID</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>NG3</strong></td>\n<td align=\"left\"><strong>Infrastructure and Host-Level Metrics</strong></td>\n<td align=\"left\">We will not collect or alert on system metrics like CPU usage, memory consumption, disk I/O, or network throughput. This is the domain of traditional monitoring systems (e.g., Prometheus). <strong>Consideration:</strong> Our performance analytics (G4) focus on <em>application</em> metrics (latency, error rate) derived from traces.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>NG4</strong></td>\n<td align=\"left\"><strong>Continuous Profiling (CPU, Heap, etc.)</strong></td>\n<td align=\"left\">We will not periodically capture and analyze CPU flame graphs or heap allocations across services. Profiling provides a different, deeper level of insight into <em>why</em> code is slow, not just <em>where</em>. <strong>Consideration:</strong> This could be a valuable future extension (see Future Extensions) but is a separate complex system.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>NG5</strong></td>\n<td align=\"left\"><strong>Synthetic Monitoring / Active Health Checks</strong></td>\n<td align=\"left\">We will not proactively simulate user traffic from various global locations to measure availability and performance from an external perspective. <strong>Consideration:</strong> Our system observes real production traffic. Synthetic monitoring is a complementary practice.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>NG6</strong></td>\n<td align=\"left\"><strong>Advanced AI/ML for Root Cause Analysis</strong></td>\n<td align=\"left\">While we perform basic statistical anomaly detection (G4), we will not implement machine learning models that automatically pinpoint the root cause of an incident or predict future failures. <strong>Consideration:</strong> We provide the high-quality trace data upon which such advanced systems could be built.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>NG7</strong></td>\n<td align=\"left\"><strong>Long-Term, Cold Storage Archival</strong></td>\n<td align=\"left\">Our trace storage is optimized for online querying and analysis over a recent time window (e.g., 7-30 days). We will not build pipelines to compress and archive trace data to object storage (e.g., S3) for indefinite retention and historical forensics. <strong>Consideration:</strong> Implement a separate archival process if needed, using our storage&#39;s export capabilities.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>NG8</strong></td>\n<td align=\"left\"><strong>Full-Text Search Across All Span Attributes</strong></td>\n<td align=\"left\">While we index traces by <code>TraceID</code>, service, and time range, we will not support arbitrary, high-cardinality full-text search over every key-value pair in <code>Span.Attributes</code>. This would require a different indexing technology (e.g., Elasticsearch). <strong>Consideration:</strong> Queries should be scoped to known services, operations, or specific trace IDs.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architectural Decision: Focusing on Core Tracing</strong></p>\n<p><strong>Context:</strong> Observability platforms can encompass logging, metrics, tracing, profiling, and more. Our team has limited resources and must deliver a focused, high-quality product.</p>\n<p><strong>Options Considered:</strong></p>\n<ol>\n<li><strong>Build a &quot;Full-Stack&quot; Observability Platform:</strong> Incorporate RUM, logging, and infrastructure metrics alongside tracing.</li>\n<li><strong>Build a Best-in-Class Distributed Tracing System:</strong> Focus exclusively on the trace data pipeline and its immediate derivatives (service maps, performance analytics).</li>\n<li><strong>Build a Trace-Centric Platform with Extension Points:</strong> Focus on tracing but design explicit integration points for external logging and metrics systems.</li>\n</ol>\n<p><strong>Decision:</strong> Choose Option 2, with design principles aligned to Option 3.</p>\n<p><strong>Rationale:</strong></p>\n<ul>\n<li><strong>Focus &amp; Quality:</strong> Mastering the complexities of distributed trace collection, sampling, and analysis is a significant challenge. Splitting effort across multiple signal types risks delivering a mediocre product in all areas.</li>\n<li><strong>Ecosystem Maturity:</strong> The OpenTelemetry project provides robust standards for traces. By adhering to it, we enable users to pair our tracing system with their preferred best-in-class solutions for logs (e.g., Loki) and metrics (e.g., Prometheus).</li>\n<li><strong>Correlation over Unification:</strong> The highest value comes from correlating <em>across</em> these signals (e.g., jumping from a high-latency trace to its corresponding logs). We achieve this by emitting standard <code>TraceID</code>s, not by building all the systems ourselves.</li>\n</ul>\n<p><strong>Consequences:</strong></p>\n<ul>\n<li><strong>Positive:</strong> We can build a deep, scalable, and feature-rich tracing system.</li>\n<li><strong>Positive:</strong> Users are not locked into a monolithic vendor; they can choose best-of-breed for each observability pillar.</li>\n<li><strong>Negative:</strong> Users must operate and integrate multiple systems for a complete picture.</li>\n<li><strong>Mitigation:</strong> We will provide clear documentation on correlating traces with logs and metrics from common external systems.</li>\n</ul>\n</blockquote>\n<h3 id=\"scope-boundary-visualization\">Scope Boundary Visualization</h3>\n<p>The following mental model helps visualize the system&#39;s scope within the broader observability landscape:</p>\n<blockquote>\n<p><strong>The Observability &quot;House&quot;:</strong> Imagine observability as a house with three main pillars holding up the roof (which represents understanding your system).</p>\n<ul>\n<li><strong>Metrics Pillar (Our Non-Goal NG3):</strong> Answers &quot;How many?&quot; and &quot;How much?&quot; – throughput, error counts, resource utilization. Built by systems like Prometheus.</li>\n<li><strong>Logs Pillar (Our Non-Goal NG2):</strong> Answers &quot;What happened?&quot; – discrete events with detailed context. Built by systems like Elasticsearch/Loki.</li>\n<li><strong>Traces Pillar (Our Core System):</strong> Answers &quot;How long?&quot; and &quot;What path?&quot; – the journey of a request, with timing and causality.</li>\n</ul>\n<p>Our APM system builds and owns the <strong>Traces Pillar</strong>. The roof (full understanding) is supported by all three pillars working together. We design our pillar with strong, standard connections (like <code>TraceID</code>) so it can be securely joined with the others, but we do not construct the entire house ourselves.</p>\n</blockquote>\n<p>By adhering to these Goals and Non-Goals, the project maintains a clear, achievable vision. The subsequent architectural and component designs will be evaluated against this framework to ensure consistency and focus.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>While this section is primarily declarative (defining <em>what</em>), the act of maintaining a clear project scope has implementation implications, particularly for how components are designed to be extensible yet bounded.</p>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple/Initial Option</th>\n<th align=\"left\">Advanced/Scalable Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Scope Enforcement &amp; Feature Flags</strong></td>\n<td align=\"left\">Hard-coded configuration in Go <code>struct</code>s, compiled-in behavior.</td>\n<td align=\"left\">External configuration service (e.g., etcd, Consul) with dynamic reloading and feature flag system (e.g., LaunchDarkly SDK).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Dependency / Boundary Definition</strong></td>\n<td align=\"left\">Explicit <code>internal/</code> package boundaries in Go to prevent unwanted imports.</td>\n<td align=\"left\">API versioning for public endpoints (e.g., <code>/api/v1/collect</code>) and clear internal gRPC/protobuf service definitions.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong>\nTo enforce the separation of concerns implied by our non-goals, the project layout should isolate core tracing logic from potential future extensions or integrations with other systems.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>apm-tracing-system/\n├── cmd/                           # Application entry points\n│   ├── collector/                 # Trace collector service (Milestone 1)\n│   ├── query-service/            # Service for querying traces and service maps\n│   └── analytics-engine/         # Performance analytics service (Milestone 4)\n├── internal/                      # Private application code\n│   ├── apm/                      # Core APM domain logic\n│   │   ├── trace/                # Trace and Span data models (G1)\n│   │   ├── sampling/             # Head &amp; tail sampling logic (G3)\n│   │   ├── servicemap/           # Graph construction algorithms (G2)\n│   │   └── analytics/            # Percentile &amp; anomaly detection (G4)\n│   ├── collector/                # Ingestion API &amp; pipeline (G1, G6)\n│   ├── storage/                  # Abstraction for trace storage (G1, G7)\n│   │   ├── memory/               # In-memory store (for testing)\n│   │   └── cassandra/            # Cassandra-backed store (for production)\n│   └── sdk/                      # Go APM SDK implementation (G5)\n│       ├── instrumentation/      # Auto-instrumentation wrappers\n│       └── propagate/            # Context propagation utilities\n├── pkg/                          # Public libraries (if any)\n│   └── otelhelpers/              # OpenTelemetry compatibility utilities\n└── api/                          # API definitions (protobuf, OpenAPI)\n    ├── protos/                   # .proto files for gRPC\n    └── openapi/                  # OpenAPI specs for HTTP endpoints</code></pre></div>\n\n<p><strong>C. Core Logic Skeleton Code (Scope Validation Helper):</strong>\nWhile not a core component, a validation helper at system initialization can guard against accidental scope creep in configuration.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/apm/config/validator.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Config holds the runtime configuration for the APM system.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Config</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxIngestionRate </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `yaml:\"max_ingestion_rate\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Sampling         </span><span style=\"color:#B392F0\">SamplingConfig</span><span style=\"color:#9ECBFF\"> `yaml:\"sampling\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Storage          </span><span style=\"color:#B392F0\">StorageConfig</span><span style=\"color:#9ECBFF\">  `yaml:\"storage\"`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... other fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Validate ensures the configuration does not request out-of-scope (non-goal) capabilities.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // G6: Performance guardrail</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.MaxIngestionRate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">// Example limit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"max_ingestion_rate </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> exceeds supported scale for this version\"</span><span style=\"color:#E1E4E8\">, c.MaxIngestionRate)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NG3: Ensure we are not mistakenly configured to collect host metrics.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (This is a placeholder; the real check would be for absent or nil config sections)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.HostMetrics </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"host_metrics collection is a non-goal (NG3). Please remove this configuration\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add other validations as needed for non-goals...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Language-Specific Hints (Go):</strong></p>\n<ul>\n<li>Use the <code>internal</code> directory pattern religiously. Code inside <code>internal/</code> cannot be imported by code outside your project repository. This is a powerful mechanism to enforce API boundaries and prevent your packages from being used in ways you didn&#39;t intend (a form of scope enforcement).</li>\n<li>For configuration, use a library like <code>spf13/viper</code> which supports reading from multiple sources (files, env vars) and allows you to bind your config <code>struct</code>. The <code>Validate()</code> method can be called after the config is loaded.</li>\n<li>Start every component&#39;s <code>main.go</code> with a call to <code>config.Validate()</code> and exit gracefully if validation fails, ensuring the system never starts in an out-of-scope configuration.</li>\n</ul>\n<hr>\n<h2 id=\"3-high-level-architecture\">3. High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides the architectural foundation for all subsequent milestones, defining the system&#39;s components and their relationships that will be implemented across Milestones 1-5.</p>\n</blockquote>\n<p>Think of the APM Tracing System as a <strong>distributed nervous system</strong> for your microservices architecture. Just as the human nervous system has sensory receptors (nerve endings), transmission pathways (nerves), processing centers (brain and spinal cord), and a way to perceive the processed information (conscious awareness), our APM system has components that collect, transmit, store, analyze, and visualize trace data. This architectural overview maps out this &quot;nervous system,&quot; showing how telemetry flows from your applications to insights you can act upon.</p>\n<h3 id=\"component-overview-and-responsibilities\">Component Overview and Responsibilities</h3>\n<p>The APM Tracing System is composed of five primary components that work together in a data pipeline. Data flows unidirectionally through most of these components (from left to right in the diagram), with some feedback loops for configuration and querying.</p>\n<p><img src=\"/api/project/apm-system/architecture-doc/asset?path=diagrams%2Fsys-comp-diagram.svg\" alt=\"APM System Component Diagram\"></p>\n<p>Each component has a specific responsibility in the trace lifecycle, following the <strong>single responsibility principle</strong> to ensure maintainability and scalability. The table below details each component&#39;s role, what data it owns, and how it interacts with others:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Primary Responsibility</th>\n<th>Key Data It Owns/Holds</th>\n<th>Interface to Other Components</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>APM SDK &amp; Agent</strong></td>\n<td><strong>Instrumentation &amp; Span Emission</strong></td>\n<td>Span context (trace ID, span ID, parent span ID) within application memory; Configuration for sampling and reporting</td>\n<td>• <strong>To Collector:</strong> Sends spans via HTTP/gRPC using OpenTelemetry format<br>• <strong>To Application:</strong> Injects itself via middleware/monkey-patching to intercept calls</td>\n</tr>\n<tr>\n<td><strong>Collector</strong></td>\n<td><strong>Span Ingestion &amp; Initial Processing</strong></td>\n<td>In-memory buffers of recently received spans; Sampling configuration and decision cache</td>\n<td>• <strong>From Agent:</strong> Receives spans via ingestion endpoints<br>• <strong>To Storage:</strong> Writes processed spans to persistent storage<br>• <strong>To Query Service:</strong> Notifies of trace completion events</td>\n</tr>\n<tr>\n<td><strong>Storage Backend</strong></td>\n<td><strong>Durable Trace Storage &amp; Indexing</strong></td>\n<td>All persisted span data; Secondary indexes on trace ID, service, operation, and timestamp</td>\n<td>• <strong>From Collector:</strong> Accepts span writes<br>• <strong>From Query Service:</strong> Serves span reads and index queries<br>• <strong>To Analytics Engine:</strong> Provides historical data for baseline calculation</td>\n</tr>\n<tr>\n<td><strong>Query Service</strong></td>\n<td><strong>Trace Retrieval &amp; Service Map Computation</strong></td>\n<td>Materialized service dependency graph (if pre-computed); Query execution plans and results caching</td>\n<td>• <strong>From Storage:</strong> Reads spans and indexes<br>• <strong>To Web UI:</strong> Serves trace lists, individual traces, and service map data<br>• <strong>To Collector:</strong> Receives trace completion notifications for tail-based sampling</td>\n</tr>\n<tr>\n<td><strong>Web UI</strong></td>\n<td><strong>Visualization &amp; User Interaction</strong></td>\n<td>User session state, visualization preferences, alert configurations</td>\n<td>• <strong>To Query Service:</strong> Sends queries for traces and service maps<br>• <strong>To User:</strong> Renders interactive visualizations and dashboards</td>\n</tr>\n</tbody></table>\n<p>The <strong>data flow</strong> follows a clear pipeline:</p>\n<ol>\n<li><strong>Instrumentation Phase:</strong> Application code, via the APM SDK, generates <code>Span</code> objects during execution.</li>\n<li><strong>Emission Phase:</strong> The SDK sends these spans to the Collector via network calls.</li>\n<li><strong>Ingestion Phase:</strong> The Collector receives spans, validates them, applies sampling decisions, and buffers them for assembly.</li>\n<li><strong>Storage Phase:</strong> Assembled spans are written to the Storage Backend with appropriate indexing.</li>\n<li><strong>Processing Phase:</strong> The Query Service reads from storage to compute service maps and serve trace queries.</li>\n<li><strong>Visualization Phase:</strong> The Web UI queries the Query Service and renders results for users.</li>\n</ol>\n<p>There are also two important <strong>cross-cutting concerns</strong> that span multiple components:</p>\n<ul>\n<li><strong>Configuration Management:</strong> All components read from a centralized configuration service (or files) for settings like sampling rates, storage endpoints, and feature flags.</li>\n<li><strong>Observability of the Observability System:</strong> The APM system itself generates metrics, logs, and traces about its own operation, which are fed back into itself (dogfooding) or to a separate monitoring system.</li>\n</ul>\n<blockquote>\n<p><strong>Key Design Insight:</strong> This architecture employs the <strong>pipes and filters</strong> pattern. Each component transforms or routes the data stream, allowing independent scaling and technology choices per component. The Collector can be scaled horizontally to handle ingestion load, while the Storage Backend and Query Service can be optimized separately for write-heavy versus read-heavy workloads.</p>\n</blockquote>\n<h4 id=\"detailed-component-breakdown\">Detailed Component Breakdown</h4>\n<p><strong>APM SDK &amp; Agent</strong>\nThis component is actually a <strong>library</strong> embedded within your application processes (the SDK) and potentially a <strong>sidecar/daemon</strong> (the Agent) that manages span batching and export. Its core job is to make tracing <strong>automatic</strong> for developers. It intercepts key operations (HTTP requests, database queries, async tasks), creates <code>Span</code> records, propagates the <code>Trace</code> context across service boundaries using headers (like <code>TRACE_ID_HEADER</code>), and finally exports completed spans to the Collector. It must be extremely lightweight to avoid perturbing the very performance it&#39;s measuring.</p>\n<p><strong>Collector</strong>\nThe Collector is the system&#39;s <strong>front door and traffic cop</strong>. It&#39;s a stateful service that receives spans from potentially thousands of concurrent application instances. Beyond simple receipt, it must:</p>\n<ul>\n<li><strong>Validate</strong> incoming spans for format correctness.</li>\n<li><strong>Apply head-based sampling</strong> immediately to reduce volume.</li>\n<li><strong>Buffer and reassemble</strong> spans that arrive out-of-order into complete traces.</li>\n<li><strong>Apply tail-based sampling</strong> decisions once traces are complete.</li>\n<li><strong>Batch and write</strong> final spans to storage efficiently.\nThink of it as a package sorting facility: packages (spans) arrive on many conveyor belts, are sorted by destination (trace ID), assembled into complete shipments (traces), and then loaded onto trucks (storage writes).</li>\n</ul>\n<p><strong>Storage Backend</strong>\nThis is the system&#39;s <strong>long-term memory</strong>. It must store massive volumes of span data (each request generates multiple spans) with efficient retrieval patterns. The primary access pattern is <strong>retrieve all spans for a given trace ID</strong>, requiring a primary index on <code>TraceID</code>. Secondary access patterns include:</p>\n<ul>\n<li>Find traces for a specific service/operation within a time range.</li>\n<li>Retrieve raw span data for service map computation (which could also be done via materialized views).</li>\n<li>Access historical data for performance baselines and trend analysis.\nThe storage system must balance cost, query performance, and write throughput, often leading to a multi-tiered storage strategy (hot recent data in one system, colder data in another).</li>\n</ul>\n<p><strong>Query Service</strong>\nThis component is the <strong>analytic brain</strong>. It translates user queries (e.g., &quot;show traces for service &#39;checkout&#39; with errors in the last hour&quot;) into efficient storage queries, computes aggregations (like the service dependency graph), and formats results for the UI. For performance, it may maintain <strong>materialized views</strong> (pre-computed service maps) or <strong>caches</strong> of frequent query results. It also houses the <strong>analytics engine</strong> that computes percentiles and runs anomaly detection algorithms on the fly or on scheduled intervals.</p>\n<p><strong>Web UI</strong>\nThe UI is the <strong>human interface</strong> to the system. It provides:</p>\n<ul>\n<li>A <strong>trace viewer</strong> showing waterfall diagrams of request flow.</li>\n<li>A <strong>service map</strong> visualization with interactive exploration.</li>\n<li><strong>Dashboards</strong> for key performance indicators (latency, error rates).</li>\n<li><strong>Alert management</strong> interfaces.</li>\n<li><strong>Search and query builders</strong>.\nIt&#39;s a client-side application that talks to the Query Service&#39;s API, and it must handle large datasets efficiently (e.g., virtual scrolling for long trace lists).</li>\n</ul>\n<h4 id=\"component-interaction-patterns\">Component Interaction Patterns</h4>\n<p>The components communicate using two primary patterns:</p>\n<ol>\n<li><p><strong>Asynchronous Fire-and-Forget (Spans):</strong> The SDK → Collector → Storage flow is primarily asynchronous. The SDK sends spans and doesn&#39;t wait for them to be stored; it may buffer and batch locally. The Collector acknowledges receipt quickly (within 100ms per Milestone 1) but writes to storage asynchronously. This ensures low overhead on the instrumented application.</p>\n</li>\n<li><p><strong>Synchronous Request-Response (Queries):</strong> The Web UI → Query Service → Storage flow for trace retrieval is synchronous. Users expect to see their query results, so the UI waits for the Query Service to return traces or service map data. These queries can be complex and may require optimization (pagination, time-range restrictions).</p>\n</li>\n</ol>\n<h3 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h3>\n<p>A well-organized codebase mirrors the architectural components, making it intuitive for developers to navigate and maintain. For our Go implementation, we follow the <strong>Standard Go Project Layout</strong> conventions with some adaptations for our specific domain.</p>\n<blockquote>\n<p><strong>Mental Model: A Library&#39;s Organization</strong><br>Think of the project structure like a well-organized library. The <code>cmd/</code> directory is the main entrance (front desk). Each major component gets its own <strong>wing</strong> (<code>internal/collector/</code>, <code>internal/query/</code>). Within each wing, books are grouped by topic: the main logic (<code>*.go</code>), its tests (<code>*_test.go</code>), configuration (<code>config/</code>), and internal helpers (<code>internal/</code> within the component). Shared utilities used across wings live in <code>pkg/</code> (like the reference section). This organization helps you know exactly where to go to find or modify any piece of functionality.</p>\n</blockquote>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>apm-tracing-system/\n├── cmd/                          # Application entry points\n│   ├── collector/                # Collector service binary\n│   │   └── main.go               # Sets up config, starts HTTP/gRPC servers\n│   ├── query-service/            # Query service binary\n│   │   └── main.go\n│   └── web-ui/                   # Web UI server (could be Go serving static files + API proxy)\n│       └── main.go\n│\n├── internal/                     # Private application code (not importable by others)\n│   ├── apmsdk/                   # Milestone 5: APM SDK &amp; Auto-Instrumentation\n│   │   ├── instrument/           # Auto-instrumentation wrappers\n│   │   │   ├── http/             # HTTP client/server instrumentation\n│   │   │   ├── database/         # SQL driver wrappers\n│   │   │   └── frameworks/       # Gin, Echo, etc. middleware\n│   │   ├── tracer/               # Core tracer implementation\n│   │   │   ├── tracer.go         # `Tracer` struct and methods\n│   │   │   ├── span.go           # `Span` struct methods\n│   │   │   └── propagation/      # W3C Trace Context propagation logic\n│   │   └── config/               # SDK configuration\n│   │\n│   ├── collector/                # Milestone 1: Trace Collection\n│   │   ├── api/                  # HTTP/gRPC handlers for span ingestion\n│   │   │   ├── http_handler.go\n│   │   │   └── grpc_handler.go\n│   │   ├── ingestion/            # Core ingestion pipeline\n│   │   │   ├── pipeline.go       # Main pipeline orchestration\n│   │   │   ├── validator.go      # Span validation logic\n│   │   │   ├── buffer/           # Buffering strategies for trace assembly\n│   │   │   │   ├── memory_buffer.go\n│   │   │   │   └── wal_buffer.go  # Write-ahead log backed buffer (ADR)\n│   │   │   └── assembler.go      # Trace assembly from spans\n│   │   ├── sampling/             # Milestone 3: Sampling (head-based here)\n│   │   │   ├── sampler.go        # `Sampler` interface\n│   │   │   ├── probabilistic.go  # Probabilistic (head) sampler\n│   │   │   └── consistent.go     # Trace-ID consistent hash sampler\n│   │   └── storage/              # Client to write to storage backend\n│   │       └── writer.go         # Batched span writer\n│   │\n│   ├── storage/                  # Storage abstraction layer\n│   │   ├── driver/               # Storage driver interfaces\n│   │   │   ├── writer.go         # `StorageWriter` interface\n│   │   │   └── reader.go         # `StorageReader` interface\n│   │   ├── indexes/              # Index management logic\n│   │   │   ├── trace_index.go    # Primary index on TraceID\n│   │   │   └── service_index.go  # Secondary index on ServiceName\n│   │   └── implementations/      # Concrete implementations\n│   │       ├── memory/           # In-memory store (for testing)\n│   │       ├── cassandra/        # Cassandra implementation\n│   │       └── elasticsearch/    # Elasticsearch implementation\n│   │\n│   ├── query/                    # Milestone 2 &amp; 4: Query Service &amp; Analytics\n│   │   ├── service/              # gRPC/REST API for queries\n│   │   │   └── handler.go        # Request handlers for trace/search\n│   │   ├── servicemap/           # Milestone 2: Service Map\n│   │   │   ├── builder.go        # Graph construction from spans\n│   │   │   ├── graph.go          # `ServiceGraph` data structure\n│   │   │   ├── aggregator.go     # Edge metric aggregation\n│   │   │   └── materialized/     # Materialized view updater\n│   │   ├── analytics/            # Milestone 4: Performance Analytics\n│   │   │   ├── percentiles/      # t-digest based percentile calculator\n│   │   │   │   ├── aggregator.go\n│   │   │   │   └── tdigest.go    # t-digest implementation\n│   │   │   ├── anomaly/          # Anomaly detection\n│   │   │   │   ├── detector.go   `AnomalyDetector` interface\n│   │   │   │   ├── zscore.go     # Z-score based detector\n│   │   │   │   └── baseline.go   # Historical baseline manager\n│   │   │   └── timeseries/       # Time-series aggregation\n│   │   │       └── aggregator.go\n│   │   └── tail_sampling/        # Milestone 3: Tail-based sampling\n│   │       └── evaluator.go      # Evaluates complete traces for keeping\n│   │\n│   ├── webui/                    # Web UI backend (if not purely static)\n│   │   ├── static/               # Serves compiled frontend assets\n│   │   └── api_proxy.go          # Proxies API calls to query service\n│   │\n│   └── models/                   # Shared data models (used by multiple components)\n│       ├── trace.go              # `Trace` and `Span` struct definitions\n│       ├── service.go            # `Service` struct\n│       ├── config.go             # `Config`, `SamplingConfig`, `StorageConfig`\n│       └── telemetry/            # OpenTelemetry protobuf/generated code\n│\n├── pkg/                          # Public, reusable libraries\n│   ├── sampling/                 # Sampling utilities (importable by others)\n│   ├── traceutils/               # Trace ID generation, context manipulation\n│   └── instrumentation/          # Safe instrumentation helpers\n│\n├── api/                          # API definitions (protobuf, OpenAPI)\n│   ├── protos/                   # .proto files for gRPC\n│   └── openapi/                  # OpenAPI/Swagger specs for REST\n│\n├── configs/                      # Configuration files\n│   ├── collector.yaml            # Collector configuration\n│   ├── query-service.yaml        # Query service configuration\n│   └── sdk-config.example.json   # Example SDK configuration\n│\n├── scripts/                      # Build, deployment, maintenance scripts\n├── deployments/                  # Dockerfiles, Kubernetes manifests\n├── tests/                        # Integration, load tests\n│   ├── integration/              # Component integration tests\n│   └── load/                     # Load test scenarios\n│\n└── docs/                         # Design docs, ADRs, user guides\n    ├── adrs/                     # Architecture Decision Records\n    └── milestones/               # Milestone-specific documentation</code></pre></div>\n\n<h4 id=\"key-structural-decisions\">Key Structural Decisions</h4>\n<p>This structure embodies several architectural decisions:</p>\n<ol>\n<li><p><strong>Clear Separation of Concerns:</strong> Each major component (<code>collector</code>, <code>query</code>, <code>apmsdk</code>) lives in its own directory under <code>internal/</code>, minimizing accidental coupling.</p>\n</li>\n<li><p><strong>Internal vs. Public Code:</strong> The <code>internal/</code> directory prevents external projects from importing our core application logic, which is an implementation detail. Publicly reusable utilities (like sampling algorithms or trace utilities) are placed in <code>pkg/</code> for potential use by other projects (e.g., custom instrumentation libraries).</p>\n</li>\n<li><p><strong>Shared Models Centralized:</strong> The <code>internal/models/</code> directory contains data structures (<code>Trace</code>, <code>Span</code>, <code>Service</code>) used across multiple components. This avoids duplication and ensures consistency. However, each component&#39;s internal representations may differ from these shared models for performance or convenience.</p>\n</li>\n<li><p><strong>Interface-Driven Storage:</strong> The <code>storage/driver/</code> directory defines interfaces (<code>StorageWriter</code>, <code>StorageReader</code>), while concrete implementations live separately. This allows swapping storage backends (Cassandra, Elasticsearch, etc.) without changing business logic.</p>\n</li>\n<li><p><strong>Configuration Externalized:</strong> All configuration files reside in <code>configs/</code>, separate from code, enabling environment-specific deployments (dev, staging, prod).</p>\n</li>\n<li><p><strong>Entry Points Isolated:</strong> Each service binary (<code>collector</code>, <code>query-service</code>, <code>web-ui</code>) has its own subdirectory under <code>cmd/</code>, each with a simple <code>main.go</code> that wires together components from <code>internal/</code>. This keeps bootstrap logic clean and separate from core business logic.</p>\n</li>\n</ol>\n<p>This structure scales well as the project grows. New components (like a separate anomaly detection service) would get their own directory under <code>internal/</code> and a corresponding entry point under <code>cmd/</code>.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Implementation Focus:</strong> This guidance helps you set up the foundational project structure and make initial technology choices. The actual component implementations will be detailed in subsequent sections.</p>\n</blockquote>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Starting Point)</th>\n<th>Advanced Option (Production Scale)</th>\n<th>Rationale for Choice</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Transport (SDK→Collector)</strong></td>\n<td>HTTP/1.1 with JSON (net/http)</td>\n<td>gRPC with Protocol Buffers</td>\n<td>HTTP/JSON is simpler to debug and has wider client compatibility. gRPC offers better performance and bidirectional streaming.</td>\n</tr>\n<tr>\n<td><strong>Collector Framework</strong></td>\n<td>Plain Go with goroutines + channels</td>\n<td>OpenTelemetry Collector Contrib</td>\n<td>Building from scratch offers maximal learning; using OTel Collector gives production-ready pipelines and extensive exporters.</td>\n</tr>\n<tr>\n<td><strong>Primary Storage</strong></td>\n<td>PostgreSQL with JSONB columns</td>\n<td>Cassandra + Elasticsearch (dual storage)</td>\n<td>PostgreSQL is familiar and supports JSON queries; Cassandra handles high write throughput, Elasticsearch enables rich search.</td>\n</tr>\n<tr>\n<td><strong>In-Memory Data Structures</strong></td>\n<td>Built-in maps + slices with <code>sync.RWMutex</code></td>\n<td>Partitioned maps with lock striping or <code>sync.Map</code></td>\n<td>Built-in types are simplest; advanced structures reduce lock contention under high concurrency.</td>\n</tr>\n<tr>\n<td><strong>Service Communication</strong></td>\n<td>REST HTTP calls</td>\n<td>gRPC with service definitions</td>\n<td>REST is straightforward; gRPC provides type safety and performance for internal service calls.</td>\n</tr>\n<tr>\n<td><strong>Web UI Frontend</strong></td>\n<td>Static HTML/JS with Vanilla or lightweight framework</td>\n<td>React/Vue.js with state management</td>\n<td>Simpler UI gets to visualization faster; frameworks help manage complex interactive state.</td>\n</tr>\n</tbody></table>\n<p>For the learning implementation, we recommend the <strong>Simple Options</strong> to focus on the core distributed systems concepts rather than framework intricacies.</p>\n<h4 id=\"b-recommended-filemodule-structure-starter\">B. Recommended File/Module Structure Starter</h4>\n<p>To bootstrap the project, create the directory structure shown above. Here&#39;s a minimal set of starter files to create:</p>\n<p><strong>1. Shared Models (<code>internal/models/trace.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> models</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Trace</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TraceID   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Spans     []</span><span style=\"color:#B392F0\">Span</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EndTime   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Span</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpanID       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TraceID      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentSpanID </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name         </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ServiceName  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duration     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Attributes   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Events       []</span><span style=\"color:#B392F0\">SpanEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status       </span><span style=\"color:#B392F0\">SpanStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SpanEvent</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Attributes </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SpanStatus</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code    </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // 0=Unset, 1=Ok, 2=Error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Service</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operations []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>2. Configuration Structure (<code>internal/models/config.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> models</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Config</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxIngestionRate </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Sampling         </span><span style=\"color:#B392F0\">SamplingConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Storage          </span><span style=\"color:#B392F0\">StorageConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check MaxIngestionRate is positive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate Sampling configuration (rates between 0 and 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate Storage configuration (endpoints, timeouts)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return aggregated errors if any validation fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SamplingConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Probability </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PerService  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StorageConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Endpoint </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timeout  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>3. Collector Entry Point (<code>cmd/collector/main.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os/signal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">apm-tracing-system/internal/collector</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">apm-tracing-system/internal/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load configuration from file or environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MaxIngestionRate: </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Sampling: </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SamplingConfig</span><span style=\"color:#E1E4E8\">{Probability: </span><span style=\"color:#79B8FF\">0.1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Storage:  </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">StorageConfig</span><span style=\"color:#E1E4E8\">{Type: </span><span style=\"color:#9ECBFF\">\"memory\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> config.</span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        log.</span><span style=\"color:#B392F0\">Fatalf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Invalid configuration: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize the collector with configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    coll, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> collector.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(config)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        log.</span><span style=\"color:#B392F0\">Fatalf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to create collector: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start the collector (HTTP/gRPC servers, background workers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#B392F0\"> cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> coll.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(ctx); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        log.</span><span style=\"color:#B392F0\">Fatalf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to start collector: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set up graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sigChan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Signal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    signal.</span><span style=\"color:#B392F0\">Notify</span><span style=\"color:#E1E4E8\">(sigChan, syscall.SIGINT, syscall.SIGTERM)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    &#x3C;-</span><span style=\"color:#E1E4E8\">sigChan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Shutting down collector...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    coll.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Collector stopped\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>4. Basic Collector Skeleton (<code>internal/collector/collector.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> collector</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">apm-tracing-system/internal/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Collector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add fields for HTTP server, storage writer, buffers, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize storage writer based on config.Storage.Type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize span buffer (in-memory or WAL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize HTTP/gRPC servers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return the collector instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">{config: config}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start the HTTP/gRPC servers for span ingestion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start background goroutines for trace assembly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start periodic flush of completed traces to storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return nil if all components started successfully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Stop accepting new spans (close listeners)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Flush all buffered traces to storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Stop background goroutines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Close connections to storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>5. Makefile for Common Tasks:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code>.PHONY: build test run-collector\n\nbuild:\n    go build -o bin/collector ./cmd/collector\n    go build -o bin/query-service ./cmd/query-service\n    go build -o bin/web-ui ./cmd/web-ui\n\ntest:\n    go test ./...\n\nrun-collector:\n    go run ./cmd/collector\n\nrun-all: build\n    # Would use docker-compose in real scenario\n    ./bin/collector &amp;\n    ./bin/query-service &amp;\n    ./bin/web-ui &amp;</code></pre></div>\n\n<h4 id=\"c-language-specific-hints-for-go\">C. Language-Specific Hints for Go</h4>\n<ol>\n<li><p><strong>Concurrency Model:</strong> Use goroutines for independent tasks (listening for spans, assembling traces, writing to storage). Use channels for communication between these goroutines (e.g., a channel for incoming spans, another for completed traces).</p>\n</li>\n<li><p><strong>Context Propagation:</strong> Use <code>context.Context</code> extensively for cancellation and deadlines. Pass context through function calls, especially for network operations (HTTP handlers, storage writes).</p>\n</li>\n<li><p><strong>Error Handling:</strong> Go&#39;s explicit error handling is ideal for observability systems. Always check errors, and add context with <code>fmt.Errorf(&quot;failed to write span: %w&quot;, err)</code> when propagating errors up the call stack.</p>\n</li>\n<li><p><strong>Configuration Management:</strong> Use struct tags with libraries like <code>github.com/spf13/viper</code> for binding environment variables and YAML files to your <code>Config</code> struct.</p>\n</li>\n<li><p><strong>Testing:</strong> Use table-driven tests for stateless functions. For concurrent components, use <code>testing</code> package&#39;s built-in race detector (<code>go test -race</code>) to identify data races.</p>\n</li>\n<li><p><strong>Performance:</strong> Profile early with <code>go tool pprof</code>. Pay attention to memory allocations (use <code>go test -bench . -benchmem</code>) and lock contention in hot paths.</p>\n</li>\n</ol>\n<h4 id=\"d-milestone-checkpoint-architecture-setup\">D. Milestone Checkpoint: Architecture Setup</h4>\n<p>After setting up the initial structure:</p>\n<ol>\n<li><p><strong>Verify Directory Structure:</strong> Run <code>find . -type f -name &quot;*.go&quot; | head -20</code> to confirm key files exist.</p>\n</li>\n<li><p><strong>Build the Project:</strong> Run <code>make build</code> (or <code>go build ./...</code>). It should compile without errors, even though the implementations are mostly stubs.</p>\n</li>\n<li><p><strong>Run Basic Tests:</strong> Execute <code>go test ./internal/models/...</code> to validate the model definitions compile correctly.</p>\n</li>\n<li><p><strong>Start the Collector:</strong> Run <code>make run-collector</code>. It should start and immediately exit (since the <code>Start</code> method returns <code>nil</code> without actually starting servers). This confirms the wiring works.</p>\n</li>\n</ol>\n<p><strong>Signs Something Is Wrong:</strong></p>\n<ul>\n<li><strong>Compilation errors:</strong> Check package imports and ensure all directories have proper <code>package</code> declarations.</li>\n<li><strong>&quot;Cannot find module&quot; errors:</strong> Run <code>go mod init apm-tracing-system</code> at the project root to initialize the module.</li>\n<li><strong>&quot;Undefined type&quot; errors:</strong> Ensure you&#39;ve created all the model structs with exact field names from the naming conventions.</li>\n</ul>\n<p>With this architecture in place, you have a clean foundation to implement each component in the subsequent milestones. The clear separation of concerns will allow you to work on one component (e.g., the Collector in Milestone 1) without worrying about the details of others.</p>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides the foundational data definitions for the entire APM Tracing System, directly supporting Milestone 1 (Trace Collection) and underpinning all subsequent milestones (Service Map, Trace Sampling, Performance Analytics, and APM SDK).</p>\n</blockquote>\n<h2 id=\"4-data-model\">4. Data Model</h2>\n<p><strong>Mental Model: The Family Tree Album</strong>\nThink of the entire APM system as a massive, digital family tree album for software requests. A <strong>Trace</strong> is one complete family tree—the story of a single request as it travels through your services. Each <strong>Span</strong> is an individual family member—a specific unit of work performed by one service. The <strong>Service</strong> is like a family name or household—a logical grouping of related spans. This album (your storage) must organize millions of these family trees so you can quickly find all members of a specific family (trace), identify which households (services) they visited, and understand their relationships.</p>\n<h3 id=\"core-types-span-trace-and-service\">Core Types: Span, Trace, and Service</h3>\n<p>The system revolves around three fundamental entities. Understanding their exact structure is critical because every component—from ingestion to visualization—operates on these types.</p>\n<h4 id=\"the-span-an-individual-operation\">The Span: An Individual Operation</h4>\n<p>A <strong>Span</strong> represents a named, timed operation representing a unit of work performed by a single service. It&#39;s the atomic building block of distributed tracing. Think of it as a single &quot;footprint&quot; left by a request as it passes through a service.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SpanID</code></td>\n<td><code>string</code></td>\n<td>A unique identifier for this specific span within the context of its trace. Typically a 64-bit random number encoded as 16 hexadecimal characters. Must be unique within its trace but can collide across different traces.</td>\n</tr>\n<tr>\n<td><code>TraceID</code></td>\n<td><code>string</code></td>\n<td>The unique identifier of the trace to which this span belongs. All spans that are part of the same request share this same ID. Usually a 128-bit random number encoded as 32 hexadecimal characters. This is the primary grouping key.</td>\n</tr>\n<tr>\n<td><code>ParentSpanID</code></td>\n<td><code>string</code></td>\n<td>The <code>SpanID</code> of the parent span in the trace hierarchy. If this span is the root (the first operation in the request), this field is an empty string. This field establishes the parent-child relationships that form the trace tree structure.</td>\n</tr>\n<tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>A human-readable name describing the operation (e.g., <code>&quot;HTTP GET /api/users&quot;</code>, <code>&quot;database.query&quot;</code>, <code>&quot;redis.get&quot;</code>). Often called the operation name. Used for aggregation and filtering.</td>\n</tr>\n<tr>\n<td><code>ServiceName</code></td>\n<td><code>string</code></td>\n<td>The name of the service that generated this span (e.g., <code>&quot;user-service&quot;</code>, <code>&quot;auth-service&quot;</code>, <code>&quot;payment-gateway&quot;</code>). This is how spans are associated with a particular service.</td>\n</tr>\n<tr>\n<td><code>StartTime</code></td>\n<td><code>time.Time</code></td>\n<td>The precise timestamp (with nanosecond precision) when the operation represented by this span began. Must be comparable across different machines (requires clock synchronization or normalization).</td>\n</tr>\n<tr>\n<td><code>Duration</code></td>\n<td><code>time.Duration</code></td>\n<td>The length of time the operation took to complete, measured from <code>StartTime</code> to the end. This is critical for performance analysis. Represented as a 64-bit integer of nanoseconds.</td>\n</tr>\n<tr>\n<td><code>Attributes</code></td>\n<td><code>map[string]string</code></td>\n<td>A set of key-value pairs that provide additional contextual metadata about the span. Examples: <code>{&quot;http.method&quot;: &quot;GET&quot;, &quot;http.status_code&quot;: &quot;200&quot;, &quot;db.system&quot;: &quot;postgresql&quot;, &quot;user.id&quot;: &quot;12345&quot;}</code>. Used for detailed debugging and filtering.</td>\n</tr>\n<tr>\n<td><code>Events</code></td>\n<td><code>[]SpanEvent</code></td>\n<td>A chronological list of timestamped annotations that occurred during the span&#39;s execution. Each event represents a notable occurrence like an exception, a log statement, or a cache hit/miss.</td>\n</tr>\n<tr>\n<td><code>Status</code></td>\n<td><code>SpanStatus</code></td>\n<td>The final status of the operation represented by this span. Indicates whether it completed successfully, ended with an error, or was unset. Contains both a code and an optional descriptive message.</td>\n</tr>\n</tbody></table>\n<h4 id=\"spanevent-annotated-moments-in-time\">SpanEvent: Annotated Moments in Time</h4>\n<p>A <strong>SpanEvent</strong> is a timestamped annotation attached to a span, representing something noteworthy that happened during the span&#39;s lifetime. Think of it as a &quot;sticky note&quot; attached to a specific moment on the span&#39;s timeline.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>A descriptive name for the event (e.g., <code>&quot;exception&quot;</code>, <code>&quot;cache.miss&quot;</code>, <code>&quot;message.sent&quot;</code>, <code>&quot;checkpoint&quot;</code>).</td>\n</tr>\n<tr>\n<td><code>Timestamp</code></td>\n<td><code>time.Time</code></td>\n<td>The exact moment when this event occurred, relative to the span&#39;s <code>StartTime</code>.</td>\n</tr>\n<tr>\n<td><code>Attributes</code></td>\n<td><code>map[string]string</code></td>\n<td>Additional context specific to this event. For an exception event, this might include <code>{&quot;exception.type&quot;: &quot;IOException&quot;, &quot;exception.message&quot;: &quot;File not found&quot;}</code>.</td>\n</tr>\n</tbody></table>\n<h4 id=\"spanstatus-operation-outcome\">SpanStatus: Operation Outcome</h4>\n<p><strong>SpanStatus</strong> indicates the final outcome of the span&#39;s operation. This is semantically different from technical success/failure—a span can complete successfully (code 0) even if the business logic failed (e.g., a <code>404 Not Found</code> response).</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Code</code></td>\n<td><code>int</code></td>\n<td>A numerical code representing the status. Follows OpenTelemetry semantics: <code>0</code> (Unset), <code>1</code> (OK), <code>2</code> (Error). An <code>Error</code> code indicates the operation itself failed (e.g., a database connection error, timeout).</td>\n</tr>\n<tr>\n<td><code>Message</code></td>\n<td><code>string</code></td>\n<td>An optional human-readable message providing additional details about the status, particularly useful when <code>Code</code> is <code>2</code> (Error). Example: <code>&quot;connection refused&quot;</code>, <code>&quot;timeout after 5s&quot;</code>.</td>\n</tr>\n</tbody></table>\n<h4 id=\"the-trace-a-complete-request-journey\">The Trace: A Complete Request Journey</h4>\n<p>A <strong>Trace</strong> is a collection of spans that together represent the complete path of a single request through the distributed system. It&#39;s not a separate stored entity but a logical aggregation computed from spans sharing the same <code>TraceID</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>TraceID</code></td>\n<td><code>string</code></td>\n<td>The unique identifier for this trace. Matches the <code>TraceID</code> of all spans belonging to this trace.</td>\n</tr>\n<tr>\n<td><code>Spans</code></td>\n<td><code>[]Span</code></td>\n<td>All spans that belong to this trace, typically in no particular order initially. They must be sorted by <code>StartTime</code> and arranged in parent-child hierarchy for display and analysis.</td>\n</tr>\n<tr>\n<td><code>StartTime</code></td>\n<td><code>time.Time</code></td>\n<td>The earliest <code>StartTime</code> among all spans in the trace. Derived by finding the minimum span <code>StartTime</code>. Useful for time-range queries.</td>\n</tr>\n<tr>\n<td><code>EndTime</code></td>\n<td><code>time.Time</code></td>\n<td>The latest end time (calculated as <code>StartTime + Duration</code>) among all spans in the trace. Derived by finding the maximum span end time. Together with <code>StartTime</code>, defines the trace&#39;s temporal bounds.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The <code>Trace</code> type is primarily a <strong>view</strong> or <strong>query result</strong>, not a storage primitive. We store individual spans, then assemble them into traces when queried. This is more flexible than storing complete traces because spans can arrive out-of-order, and we can handle partial traces.</p>\n</blockquote>\n<h4 id=\"the-service-a-logical-component\">The Service: A Logical Component</h4>\n<p>A <strong>Service</strong> represents a deployable, versioned software component in your architecture. In tracing terms, it&#39;s the source that emits spans.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>The unique name identifying this service (e.g., <code>&quot;frontend-web&quot;</code>, <code>&quot;user-service-v2&quot;</code>, <code>&quot;payment-processor&quot;</code>). This should match the <code>ServiceName</code> field in spans.</td>\n</tr>\n<tr>\n<td><code>Operations</code></td>\n<td><code>[]string</code></td>\n<td>A list of distinct operation names (span <code>Name</code> values) that this service has been observed to perform. Derived from analyzing spans. Examples: <code>[&quot;HTTP GET /api/users&quot;, &quot;HTTP POST /api/users&quot;, &quot;database.query.users&quot;]</code>. Useful for configuring sampling rates per operation.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The <code>Service</code> type, like <code>Trace</code>, is typically a <strong>derived entity</strong> computed from span data, not stored directly. However, we might maintain a materialized view of services and their operations for fast access by the UI and configuration systems.</p>\n</blockquote>\n<h3 id=\"relationships-and-storage-indexing-strategy\">Relationships and Storage Indexing Strategy</h3>\n<p><strong>Mental Model: The Library Catalog System</strong>\nImagine our storage system as a massive library containing billions of individual pages (spans). Each book (trace) is scattered across the library—its pages aren&#39;t bound together but are identified by sharing the same call number (TraceID). To find all pages of a book, we need a catalog that tells us where every page with a given call number is located. Additionally, researchers might want to find all books that mention a particular topic (service) or were published in a certain year (time range). We need multiple catalog systems (indexes) to support these different lookup patterns efficiently.</p>\n<h4 id=\"span-to-trace-relationships-building-the-tree\">Span-to-Trace Relationships: Building the Tree</h4>\n<p>Spans are linked into a trace through two relationships:</p>\n<ol>\n<li><strong>Grouping Relationship</strong>: All spans with the same <code>TraceID</code> belong to the same trace. This is a many-to-one relationship.</li>\n<li><strong>Hierarchical Relationship</strong>: The <code>ParentSpanID</code> field establishes parent-child links, forming a tree (or more generally, a directed acyclic graph) within the trace. A span&#39;s parent is another span in the same trace.</li>\n</ol>\n<p>The hierarchical structure is critical for:</p>\n<ul>\n<li><strong>Service Map Construction</strong>: By analyzing parent-child relationships where the parent and child have different <code>ServiceName</code> values, we can infer service-to-service calls.</li>\n<li><strong>Root Cause Analysis</strong>: Understanding which span&#39;s failure caused cascading failures downstream.</li>\n<li><strong>Critical Path Analysis</strong>: Identifying the longest chain of dependencies that determines the total trace duration.</li>\n</ul>\n<p><strong>Visualizing the Relationships:</strong>\n<img src=\"/api/project/apm-system/architecture-doc/asset?path=diagrams%2Fdata-model-diagram.svg\" alt=\"Data Model: Span and Trace Relationships\"></p>\n<h4 id=\"storage-strategy-balancing-write-speed-and-query-flexibility\">Storage Strategy: Balancing Write Speed and Query Flexibility</h4>\n<p>The primary design challenge is organizing billions of spans so we can efficiently:</p>\n<ol>\n<li><strong>Retrieve all spans for a specific trace</strong> (for viewing a single request&#39;s journey)</li>\n<li><strong>Find traces involving a specific service</strong> (for service-focused debugging)</li>\n<li><strong>Find traces within a time range</strong> (for investigating incidents)</li>\n<li><strong>Find traces with specific attributes</strong> (e.g., all traces with <code>http.status_code=500</code>)</li>\n</ol>\n<p>We face competing priorities: writing spans must be extremely fast (thousands per second), while queries should be reasonably fast but can tolerate some latency.</p>\n<p><strong>Architecture Decision Record: Storage Schema and Indexing Approach</strong></p>\n<blockquote>\n<p><strong>Decision: Span-Centric Storage with Composite Primary Key and Secondary Indexes</strong></p>\n<ul>\n<li><p><strong>Context</strong>: We need to store massive volumes of span data (potentially billions of spans) with predictable write performance while supporting the core query patterns. The data has inherent dimensionality: trace ID (high cardinality), service name (medium cardinality), operation name (high cardinality), and timestamp (continuous).</p>\n</li>\n<li><p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Trace-Centric Storage</strong>: Store complete traces as single documents (JSON/protobuf blobs) keyed by <code>TraceID</code>. All spans of a trace are written together.</li>\n<li><strong>Span-Centric Storage</strong>: Store individual spans as separate records with a composite primary key that includes <code>TraceID</code> for co-location.</li>\n<li><strong>Time-Partitioned Span Storage</strong>: Store spans in partitions based on their <code>StartTime</code> (e.g., daily or hourly partitions), with secondary indexes within each partition.</li>\n</ol>\n</li>\n<li><p><strong>Decision</strong>: We chose <strong>Option 2 (Span-Centric Storage with Composite Primary Key)</strong> as our foundation, combined with time-based partitioning for data management.</p>\n</li>\n<li><p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Write Performance</strong>: Spans arrive asynchronously from different services. A trace-centric approach would require buffering all spans of a trace before writing, risking data loss if the buffer is lost and increasing write latency. Writing spans immediately as they arrive provides better durability and lower latency.</li>\n<li><strong>Out-of-Order Arrival</strong>: Spans can arrive minutes or even hours after their parent spans due to network delays, buffering, or clock skew. A span-centric model naturally accommodates this; we simply write late-arriving spans to the same logical location.</li>\n<li><strong>Scalability</strong>: By using <code>(TraceID, SpanID)</code> as a composite primary key in a distributed database like Cassandra or ScyllaDB, all spans of a trace are stored on the same physical node (due to partition key hashing on <code>TraceID</code>). This makes trace retrieval a single-partition query, which is extremely efficient.</li>\n<li><strong>Flexibility</strong>: We can add secondary indexes on other dimensions (<code>ServiceName</code>, <code>StartTime</code>) without affecting the primary write path.</li>\n</ul>\n</li>\n<li><p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Trace Assembly Requires Query</strong>: Retrieving a full trace requires querying all spans for that <code>TraceID</code>. This is an efficient single-partition operation but still involves reading multiple records.</li>\n<li><strong>Secondary Index Overhead</strong>: Maintaining indexes on <code>ServiceName</code> and <code>StartTime</code> incurs additional write overhead and storage.</li>\n<li><strong>Eventual Consistency</strong>: In distributed databases, secondary indexes are often eventually consistent, meaning recently written spans might not immediately appear in service-based queries.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The following table compares the storage approaches:</p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Suitable For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Trace-Centric</strong></td>\n<td>- Single read retrieves entire trace<br>- Natural trace assembly<br>- Simpler query logic</td>\n<td>- Must buffer spans before writing<br>- Risk of data loss if buffer fails<br>- Does not handle out-of-order span arrival well</td>\n<td>Small-scale systems where traces complete quickly and spans arrive in order</td>\n</tr>\n<tr>\n<td><strong>Span-Centric</strong></td>\n<td>- Immediate durability for each span<br>- Handles out-of-order arrival naturally<br>- Scales horizontally with trace ID as shard key</td>\n<td>- Multiple reads to assemble a trace<br>- Requires secondary indexes for service/time queries</td>\n<td><strong>Our choice</strong>: Large-scale production systems with high-volume, asynchronous span ingestion</td>\n</tr>\n<tr>\n<td><strong>Time-Partitioned</strong></td>\n<td>- Efficient time-range queries<br>- Easy data retention (drop old partitions)<br>- Aligns with natural query patterns</td>\n<td>- Spans of same trace may scatter across partitions<br>- Requires cross-partition queries for trace assembly</td>\n<td>Systems where time-based queries dominate and trace assembly is less frequent</td>\n</tr>\n</tbody></table>\n<h4 id=\"indexing-strategy-the-multi-catalog-system\">Indexing Strategy: The Multi-Catalog System</h4>\n<p>We need three types of indexes to support our query patterns:</p>\n<ol>\n<li><p><strong>Primary Index (Clustered)</strong>: <code>(TraceID, SpanID)</code></p>\n<ul>\n<li><strong>Purpose</strong>: Efficient retrieval of all spans for a given trace.</li>\n<li><strong>Implementation</strong>: In Cassandra/ScyllaDB, <code>TraceID</code> is the partition key, <code>SpanID</code> is the clustering key. In Elasticsearch, this would be a primary term index on <code>TraceID</code> with <code>SpanID</code> as document ID.</li>\n<li><strong>Query Pattern</strong>: <code>SELECT * FROM spans WHERE TraceID = ?</code></li>\n</ul>\n</li>\n<li><p><strong>Secondary Index: Service + Time Range</strong></p>\n<ul>\n<li><strong>Purpose</strong>: Find traces for a specific service within a time window (essential for service dashboards and the service map).</li>\n<li><strong>Implementation</strong>: A separate index table with composite key <code>(ServiceName, StartTimeBucket, TraceID)</code>, where <code>StartTimeBucket</code> is a time window (e.g., hour or day) for range query efficiency.</li>\n<li><strong>Query Pattern</strong>: <code>SELECT TraceID FROM service_index WHERE ServiceName = ? AND StartTimeBucket &gt;= ? AND StartTimeBucket &lt;= ? LIMIT 1000</code></li>\n</ul>\n</li>\n<li><p><strong>Secondary Index: Global Time Range</strong></p>\n<ul>\n<li><strong>Purpose</strong>: Find all traces within a time range (for incident investigation when you don&#39;t know which service was involved).</li>\n<li><strong>Implementation</strong>: A time-series-optimized store or a separate index table with key <code>(StartTimeBucket, TraceID)</code>.</li>\n<li><strong>Query Pattern</strong>: <code>SELECT TraceID FROM time_index WHERE StartTimeBucket &gt;= ? AND StartTimeBucket &lt;= ? LIMIT 10000</code></li>\n</ul>\n</li>\n<li><p><strong>Attribute Index (Selective)</strong></p>\n<ul>\n<li><strong>Purpose</strong>: Find traces with specific attribute values (e.g., all traces where <code>http.status_code = 500</code>).</li>\n<li><strong>Implementation</strong>: Only index high-value, low-cardinality attributes (like <code>http.status_code</code>, <code>error=true</code>). High-cardinality attributes (like <code>user.id</code>) should not be indexed; instead, use filtering on already-retrieved traces.</li>\n<li><strong>Query Pattern</strong>: <code>SELECT TraceID FROM attr_index WHERE attr_key = ? AND attr_value = ? AND StartTimeBucket = ?</code></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight:</strong> We use a <strong>two-phase query</strong> pattern for most searches: First, use a secondary index to find relevant <code>TraceID</code>s, then use the primary index to fetch the complete span data for those traces. This balances query flexibility with write performance.</p>\n</blockquote>\n<h4 id=\"data-retention-and-partitioning\">Data Retention and Partitioning</h4>\n<p>Given the massive volume of trace data, we cannot store everything forever. We implement:</p>\n<ul>\n<li><strong>Time-Based Partitioning</strong>: Spans are partitioned by their <code>StartTime</code> (e.g., daily partitions). Old partitions can be archived or deleted based on retention policies.</li>\n<li><strong>Sampling as First-Line Defense</strong>: Before indexing, we apply sampling (Milestone 3) to reduce the volume of spans stored.</li>\n<li><strong>Aggregation for Long-Term Trends</strong>: For performance analytics (Milestone 4), we compute and store aggregated metrics (p50, p95, p99 latencies per service per minute) which have much longer retention than raw spans.</li>\n</ul>\n<p><strong>Common Pitfalls in Data Modeling and Storage</strong></p>\n<p>⚠️ <strong>Pitfall: Treating Trace as a Stored Entity</strong></p>\n<ul>\n<li><strong>Description</strong>: Storing complete traces as monolithic blobs rather than individual spans.</li>\n<li><strong>Why it&#39;s wrong</strong>: When a new span arrives for an existing trace, you must read-modify-write the entire trace document. This creates contention, complicates out-of-order writes, and makes partial failures more costly (losing an entire trace vs. one span).</li>\n<li><strong>How to avoid</strong>: Store spans individually. Treat <code>Trace</code> as a view assembled at query time. Use <code>TraceID</code> as the primary grouping key in your storage schema.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Over-Indexing High-Cardinality Fields</strong></p>\n<ul>\n<li><strong>Description</strong>: Creating secondary indexes on fields with many distinct values, such as full HTTP URLs with parameters (<code>/api/users/12345</code>) or user IDs.</li>\n<li><strong>Why it&#39;s wrong</strong>: High-cardinality indexes become massive (approaching the size of the primary data), slow down writes dramatically, and can overwhelm the index system.</li>\n<li><strong>How to avoid</strong>: Only index low-to-medium cardinality fields (<code>ServiceName</code>, <code>http.method</code>, <code>http.status_code</code>). For high-cardinality filtering, use post-retrieval filtering or specialized search systems. Normalize operation names by removing dynamic parameters before indexing (e.g., <code>/api/users/{id}</code> instead of <code>/api/users/12345</code>).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Clock Skew in Timestamps</strong></p>\n<ul>\n<li><strong>Description</strong>: Assuming all spans have perfectly synchronized clocks and using raw <code>StartTime</code> values for sorting without normalization.</li>\n<li><strong>Why it&#39;s wrong</strong>: Servers can have minutes or even hours of clock drift. A child span might appear to start before its parent, breaking causality and making trace visualization incorrect.</li>\n<li><strong>How to avoid</strong>: Implement <strong>clock skew correction</strong>. One approach: record the difference between the local clock and a reference (like NTP) in span attributes, or use relative timestamps (monotonic clocks) for duration but absolute timestamps only for coarse ordering. During trace assembly, adjust timestamps based on parent-child relationships or use heuristics to reorder spans.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Storing Unlimited Attribute Data</strong></p>\n<ul>\n<li><strong>Description</strong>: Allowing applications to send spans with megabytes of attribute data (e.g., entire request/response bodies).</li>\n<li><strong>Why it&#39;s wrong</strong>: This blows up storage costs, slows down queries, and can expose sensitive data. The tracing system is for performance monitoring, not general-purpose logging.</li>\n<li><strong>How to avoid</strong>: Enforce <strong>attribute size limits</strong> at the collector (e.g., 2KB total per span). Truncate or drop excess attributes. Provide clear guidelines to developers about what belongs in spans (metadata, not payloads).</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Development/Testing)</th>\n<th>Advanced Option (Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Primary Storage</td>\n<td>In-memory map keyed by <code>TraceID</code> (Go <code>map[string][]Span</code>)</td>\n<td>Distributed columnar database: <strong>Cassandra</strong> or <strong>ScyllaDB</strong></td>\n</tr>\n<tr>\n<td>Secondary Indexes</td>\n<td>Separate in-memory maps (e.g., <code>map[string][]string</code> for service→traceIDs)</td>\n<td>Cassandra <strong>Materialized Views</strong> or <strong>Secondary Index</strong> tables</td>\n</tr>\n<tr>\n<td>Time-Series Storage</td>\n<td>Rolling window in Go memory with periodic snapshot to disk</td>\n<td><strong>TimescaleDB</strong> (PostgreSQL extension) or <strong>Prometheus</strong> + <strong>Thanos</strong></td>\n</tr>\n<tr>\n<td>Serialization Format</td>\n<td>JSON over HTTP (easy debugging)</td>\n<td><strong>Protocol Buffers</strong> over gRPC (efficient binary serialization)</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>apm-tracing-system/\n├── internal/\n│   ├── models/                    # Core data types\n│   │   ├── span.go               # Span, SpanEvent, SpanStatus types\n│   │   ├── trace.go              # Trace type (mostly view/computation)\n│   │   ├── service.go            # Service type\n│   │   └── config.go             # Config, SamplingConfig, StorageConfig\n│   ├── storage/                  # Storage abstractions and implementations\n│   │   ├── storage.go            # Storage interface\n│   │   ├── inmemory/             # Simple in-memory implementation\n│   │   │   ├── inmemory.go\n│   │   │   └── inmemory_test.go\n│   │   ├── cassandra/            # Cassandra implementation\n│   │   │   ├── cassandra.go\n│   │   │   └── schema.cql        # CQL schema definitions\n│   │   └── index/                # Index management\n│   │       ├── indexer.go\n│   │       ├── service_index.go\n│   │       └── time_index.go\n│   └── utils/\n│       └── timeutils.go          # Clock skew correction utilities\n└── pkg/\n    └── apmproto/                 # Protocol Buffer definitions\n        └── span.proto            # Protobuf schema for span ingestion</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete Models):</strong></p>\n<p>File: <code>internal/models/span.go</code></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> models</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Span represents a single operation within a distributed trace.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Span</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSpanID       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"spanId\"`</span><span style=\"color:#6A737D\">                 // Unique within trace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTraceID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"traceId\"`</span><span style=\"color:#6A737D\">                // Groups spans into traces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tParentSpanID </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"parentSpanId,omitempty\"`</span><span style=\"color:#6A737D\"> // Empty for root spans</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"name\"`</span><span style=\"color:#6A737D\">                   // Operation name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tServiceName  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"serviceName\"`</span><span style=\"color:#6A737D\">            // Originating service</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tStartTime    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">         `json:\"startTime\"`</span><span style=\"color:#6A737D\">              // When operation started</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDuration     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">     `json:\"duration\"`</span><span style=\"color:#6A737D\">               // How long it took</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAttributes   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"attributes,omitempty\"`</span><span style=\"color:#6A737D\">   // Contextual metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tEvents       []</span><span style=\"color:#B392F0\">SpanEvent</span><span style=\"color:#9ECBFF\">       `json:\"events,omitempty\"`</span><span style=\"color:#6A737D\">       // Timestamped annotations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tStatus       </span><span style=\"color:#B392F0\">SpanStatus</span><span style=\"color:#9ECBFF\">        `json:\"status\"`</span><span style=\"color:#6A737D\">                 // Success/error status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SpanEvent represents a notable event that occurred during a span's execution.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SpanEvent</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"name\"`</span><span style=\"color:#6A737D\">                 // Event name (e.g., \"exception\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTimestamp  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">         `json:\"timestamp\"`</span><span style=\"color:#6A737D\">            // When it happened</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAttributes </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"attributes,omitempty\"`</span><span style=\"color:#6A737D\"> // Event-specific context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SpanStatus indicates the final status of a span.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SpanStatus</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCode    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"code\"`</span><span style=\"color:#6A737D\">              // 0=Unset, 1=OK, 2=Error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMessage </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"message,omitempty\"`</span><span style=\"color:#6A737D\"> // Optional description</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>File: <code>internal/models/trace.go</code></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> models</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Trace represents a complete request journey composed of multiple spans.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is typically a computed view, not a stored entity.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Trace</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTraceID   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"traceId\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSpans     []</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#9ECBFF\">    `json:\"spans\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tStartTime </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"startTime\"`</span><span style=\"color:#6A737D\"> // Derived: min(span.StartTime)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tEndTime   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"endTime\"`</span><span style=\"color:#6A737D\">   // Derived: max(span.StartTime + span.Duration)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewTraceFromSpans constructs a Trace view from a slice of spans with the same TraceID.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It calculates the trace's start and end times and sorts spans by start time.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTraceFromSpans</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">spans</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(spans) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot create trace from empty span slice\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttraceID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> spans[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].TraceID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tstartTime </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> spans[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].StartTime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tendTime </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> spans[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].StartTime.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(spans[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Duration)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Verify all spans belong to the same trace and calculate time bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> _, span </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> spans[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:] {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> span.TraceID </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> traceID {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"spans have different trace IDs\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> span.StartTime.</span><span style=\"color:#B392F0\">Before</span><span style=\"color:#E1E4E8\">(startTime) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tstartTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> span.StartTime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tspanEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> span.StartTime.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(span.Duration)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> spanEnd.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(endTime) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tendTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> spanEnd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Sort spans by start time for consistent viewing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsortedSpans </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(spans))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tcopy</span><span style=\"color:#E1E4E8\">(sortedSpans, spans)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsort.</span><span style=\"color:#B392F0\">Slice</span><span style=\"color:#E1E4E8\">(sortedSpans, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">i</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">j</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> sortedSpans[i].StartTime.</span><span style=\"color:#B392F0\">Before</span><span style=\"color:#E1E4E8\">(sortedSpans[j].StartTime)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tTraceID:   traceID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tSpans:     sortedSpans,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tStartTime: startTime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tEndTime:   endTime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>File: <code>internal/models/service.go</code></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> models</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Service represents a logical component in the distributed system.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Service</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"name\"`</span><span style=\"color:#6A737D\">                 // Unique service identifier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tOperations []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"operations,omitempty\"`</span><span style=\"color:#6A737D\"> // Observed operation names</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code (Storage Interface):</strong></p>\n<p>File: <code>internal/storage/storage.go</code></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> storage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/your-org/apm-tracing/internal/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Storage defines the interface for persistent span storage.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Implementations must handle concurrent access and provide</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// the core query patterns needed by the APM system.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Storage</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// StoreSpan persists a single span to storage.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Implementations should also update any secondary indexes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Returns an error if the span cannot be stored.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tStoreSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">span</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// GetTraceByID retrieves all spans for the given trace ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// and assembles them into a Trace view. Returns nil if trace not found.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetTraceByID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// GetTracesByService returns traces that involve the given service</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// within the specified time range. Results are limited to 'limit' traces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// and ordered by most recent start time first.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetTracesByService</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">serviceName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">\t\tstartTime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">endTime</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limit</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// GetTracesByTimeRange returns traces that started within the given</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// time range, ordered by start time (descending). Useful for incident</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// investigation when service is unknown.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetTracesByTimeRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">\t\tstartTime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">endTime</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limit</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// GetServices returns a list of all services that have emitted spans,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// along with their observed operations. This is used for the service map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// and for configuration UI.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetServices</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Service</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Close gracefully shuts down the storage connection and releases resources.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tClose</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>File: <code>internal/storage/inmemory/inmemory.go</code> (Skeleton)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> inmemory</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/your-org/apm-tracing/internal/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InMemoryStorage is a simple in-memory implementation of storage.Storage.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Useful for development, testing, and small-scale deployments.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NOT suitable for production due to memory limits and lack of durability.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> InMemoryStorage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Primary storage: traceID -> list of spans</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttraces </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Secondary index: serviceName -> set of traceIDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tserviceIndex </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Time index: startTime bucket -> list of traceIDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttimeIndex </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewInMemoryStorage</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InMemoryStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">InMemoryStorage</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttraces:       </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tserviceIndex: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\">{}),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttimeIndex:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InMemoryStorage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StoreSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">span</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ts.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> s.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO: Implement step-by-step:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// 1. Append span to s.traces[span.TraceID] slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// 2. Update service index: add span.TraceID to s.serviceIndex[span.ServiceName]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//    (create map/set if needed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// 3. Update time index: bucket span.StartTime by hour (truncate to hour)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//    and add span.TraceID to s.timeIndex[bucketTime]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// 4. Return nil on success, error on failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InMemoryStorage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTraceByID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ts.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> s.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO: Implement:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// 1. Look up spans := s.traces[traceID]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// 2. If len(spans) == 0, return nil, nil (trace not found)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// 3. Use models.NewTraceFromSpans(spans) to create trace view</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// 4. Return trace, nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Additional method implementations follow similar pattern...</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ol>\n<li><p><strong>Time Handling</strong>: Use <code>time.Time</code> for timestamps throughout. For nanosecond precision, ensure your database driver supports it (Cassandra&#39;s <code>timestamp</code> type supports microseconds). For bucketing in indexes, use <code>t.Truncate(time.Hour)</code> to create hourly buckets.</p>\n</li>\n<li><p><strong>Concurrency</strong>: The in-memory implementation uses <code>sync.RWMutex</code> for concurrent access. For production implementations, the database handles concurrency.</p>\n</li>\n<li><p><strong>ID Generation</strong>: Use <code>crypto/rand</code> for generating random <code>TraceID</code> and <code>SpanID</code> values in the SDK. Example: <code>hex.EncodeToString(randomBytes(16))</code> for 128-bit trace IDs.</p>\n</li>\n<li><p><strong>Memory Management</strong>: The in-memory storage will grow unbounded. In production, you&#39;d use a real database. For testing, consider adding a maximum spans limit and LRU eviction.</p>\n</li>\n</ol>\n<p><strong>Milestone Checkpoint (Trace Collection - Data Model):</strong></p>\n<p>After implementing the data model and basic in-memory storage:</p>\n<ol>\n<li><strong>Verify Model Definitions</strong>: Create a simple test that instantiates each type with sample data:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> TestDataModel</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       span </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           SpanID:      </span><span style=\"color:#9ECBFF\">\"abc123\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           TraceID:     </span><span style=\"color:#9ECBFF\">\"trace-1\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           ParentSpanID: </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           Name:        </span><span style=\"color:#9ECBFF\">\"GET /api/users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           ServiceName: </span><span style=\"color:#9ECBFF\">\"user-service\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           StartTime:   time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           Duration:    </span><span style=\"color:#79B8FF\">150</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           Attributes:  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"http.method\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           Status:      </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SpanStatus</span><span style=\"color:#E1E4E8\">{Code: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Verify fields are accessible</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Test Storage Interface</strong>: Implement the <code>InMemoryStorage</code> methods and verify:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/storage/inmemory/...</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   Expected: Tests should pass, demonstrating span storage and retrieval.</p>\n<ol start=\"3\">\n<li><strong>Verify Trace Assembly</strong>: Write a test that stores multiple spans with the same <code>TraceID</code> but different <code>SpanID</code>s, then retrieves the trace and verifies all spans are present and the <code>StartTime</code>/<code>EndTime</code> are correctly calculated.</li>\n</ol>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Span disappears after storage&quot;</td>\n<td>Concurrent map write panic or incorrect locking</td>\n<td>Add debug logging before and after storage operations. Run with <code>-race</code> flag.</td>\n<td>Ensure proper use of <code>sync.RWMutex</code> locks in <code>InMemoryStorage</code>.</td>\n</tr>\n<tr>\n<td>&quot;Trace shows incorrect time range&quot;</td>\n<td><code>StartTime</code>/<code>EndTime</code> calculation logic error</td>\n<td>Print each span&#39;s start and end times during trace assembly.</td>\n<td>Verify <code>NewTraceFromSpans</code> correctly computes min/max across all spans.</td>\n</tr>\n<tr>\n<td>&quot;Service index grows without bound&quot;</td>\n<td>Not cleaning up old trace IDs from index when traces expire</td>\n<td>Check index sizes over time. Add metrics for index entries.</td>\n<td>Implement TTL or cleanup routine that removes old entries from indexes.</td>\n</tr>\n<tr>\n<td>&quot;High memory usage in tests&quot;</td>\n<td>In-memory storage retaining all spans indefinitely</td>\n<td>Monitor memory with <code>runtime.ReadMemStats</code>.</td>\n<td>Add maximum capacity to <code>InMemoryStorage</code> with LRU eviction for testing.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 1: Trace Collection, which forms the foundation of the entire APM Tracing System.</p>\n</blockquote>\n<h2 id=\"5-component-design-trace-collection-milestone-1\">5. Component Design: Trace Collection (Milestone 1)</h2>\n<p>The <strong>Trace Collector</strong> is the foundational component of our APM system — it&#39;s the &quot;front door&quot; through which all telemetry data enters. This component is responsible for receiving, validating, processing, and storing spans that together form distributed traces. Its design directly impacts the system&#39;s reliability, scalability, and correctness.</p>\n<h3 id=\"mental-model-the-package-sorting-hub\">Mental Model: The Package Sorting Hub</h3>\n<p>Imagine a massive international package sorting facility (like an airport cargo terminal). Thousands of packages (spans) arrive every second via different delivery vehicles (applications). Each package has a destination address (trace ID) and may be part of a larger shipment (trace). The facility must:</p>\n<ol>\n<li><strong>Accept deliveries</strong> from all carriers (HTTP, gRPC) without blocking traffic</li>\n<li><strong>Inspect each package</strong> for damage or incorrect labeling (validation)</li>\n<li><strong>Sort packages by destination</strong> (grouping spans by trace ID)</li>\n<li><strong>Hold incomplete shipments</strong> until all packages arrive (buffering)</li>\n<li><strong>Store completed shipments</strong> in the warehouse (persistent storage)</li>\n<li><strong>Maintain an index</strong> of what&#39;s stored and where (secondary indexing)</li>\n</ol>\n<p>The challenge is that packages from the same shipment don&#39;t arrive together — some come hours later. The facility must have enough temporary storage (buffers) to hold incomplete shipments, but not so much that it runs out of space. It also needs efficient systems to quickly locate all packages from a specific shipment when requested.</p>\n<h3 id=\"collector-interface-and-api\">Collector Interface and API</h3>\n<p>The Collector exposes well-defined endpoints for receiving telemetry data. We support both HTTP (for simplicity and wide compatibility) and gRPC (for high-performance streaming) protocols, following the <strong>OpenTelemetry Protocol (OTLP)</strong> standard.</p>\n<h4 id=\"http-endpoint-specification\">HTTP Endpoint Specification</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Path</th>\n<th>Content-Type</th>\n<th>Request Body</th>\n<th>Response</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>POST</td>\n<td><code>/v1/traces</code></td>\n<td><code>application/json</code></td>\n<td>JSON array of spans</td>\n<td><code>202 Accepted</code> (or error)</td>\n<td>Accepts batch of spans in JSON format</td>\n</tr>\n<tr>\n<td>POST</td>\n<td><code>/v1/traces</code></td>\n<td><code>application/x-protobuf</code></td>\n<td>OTLP protobuf binary</td>\n<td><code>202 Accepted</code> (or error)</td>\n<td>Accepts spans in binary protobuf format</td>\n</tr>\n<tr>\n<td>GET</td>\n<td><code>/health</code></td>\n<td>-</td>\n<td>-</td>\n<td><code>200 OK</code> with status JSON</td>\n<td>Health check endpoint</td>\n</tr>\n</tbody></table>\n<h4 id=\"grpc-service-specification\">gRPC Service Specification</h4>\n<table>\n<thead>\n<tr>\n<th>Service Method</th>\n<th>Request Type</th>\n<th>Response Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Export</code></td>\n<td><code>ExportTraceServiceRequest</code></td>\n<td><code>ExportTraceServiceResponse</code></td>\n<td>Stream spans to collector via gRPC</td>\n</tr>\n<tr>\n<td><code>HealthCheck</code></td>\n<td><code>HealthCheckRequest</code></td>\n<td><code>HealthCheckResponse</code></td>\n<td>Service health status</td>\n</tr>\n</tbody></table>\n<h4 id=\"requestresponse-format-details\">Request/Response Format Details</h4>\n<p>The collector accepts spans in the <strong>OpenTelemetry</strong> format. Below is the JSON representation structure (simplified for clarity):</p>\n<p><strong>Span JSON Format:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>traceId</code></td>\n<td>string (hex)</td>\n<td>Yes</td>\n<td>32-character hex string identifying the trace</td>\n</tr>\n<tr>\n<td><code>spanId</code></td>\n<td>string (hex)</td>\n<td>Yes</td>\n<td>16-character hex string identifying this span</td>\n</tr>\n<tr>\n<td><code>parentSpanId</code></td>\n<td>string (hex)</td>\n<td>No</td>\n<td>Parent span ID (empty for root spans)</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>Operation name (e.g., &quot;GET /api/users&quot;)</td>\n</tr>\n<tr>\n<td><code>kind</code></td>\n<td>integer</td>\n<td>Yes</td>\n<td>Span kind (1=CLIENT, 2=SERVER, etc.)</td>\n</tr>\n<tr>\n<td><code>startTimeUnixNano</code></td>\n<td>integer</td>\n<td>Yes</td>\n<td>Start timestamp in nanoseconds</td>\n</tr>\n<tr>\n<td><code>endTimeUnixNano</code></td>\n<td>integer</td>\n<td>Yes</td>\n<td>End timestamp in nanoseconds</td>\n</tr>\n<tr>\n<td><code>attributes</code></td>\n<td>array of key-value</td>\n<td>No</td>\n<td>Custom metadata (e.g., {&quot;http.method&quot;: &quot;GET&quot;})</td>\n</tr>\n<tr>\n<td><code>events</code></td>\n<td>array</td>\n<td>No</td>\n<td>Timed events within the span</td>\n</tr>\n<tr>\n<td><code>status</code></td>\n<td>object</td>\n<td>No</td>\n<td>Status code and optional message</td>\n</tr>\n</tbody></table>\n<p><strong>Response Codes:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Status Code</th>\n<th>Meaning</th>\n<th>When Used</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>202 Accepted</td>\n<td>Successfully accepted</td>\n<td>All spans validated and queued</td>\n</tr>\n<tr>\n<td>400 Bad Request</td>\n<td>Malformed request</td>\n<td>Invalid JSON or missing required fields</td>\n</tr>\n<tr>\n<td>429 Too Many Requests</td>\n<td>Rate limit exceeded</td>\n<td>Client exceeds configured ingestion rate</td>\n</tr>\n<tr>\n<td>503 Service Unavailable</td>\n<td>Collector overloaded</td>\n<td>Backpressure applied, client should retry</td>\n</tr>\n</tbody></table>\n<h4 id=\"expected-behavior-and-slas\">Expected Behavior and SLAs</h4>\n<p>The collector must provide these guarantees:</p>\n<ol>\n<li><strong>Acknowledgment within 100ms</strong> for 95% of requests (P95 latency)</li>\n<li><strong>No data loss</strong> under normal operating conditions</li>\n<li><strong>Graceful degradation</strong> when overloaded (apply backpressure instead of crashing)</li>\n<li><strong>Span validation</strong> to reject malformed data before processing</li>\n<li><strong>Trace completeness</strong> — all spans of a sampled trace are stored together</li>\n</ol>\n<h3 id=\"internal-behavior-ingestion-pipeline\">Internal Behavior: Ingestion Pipeline</h3>\n<p>When a span arrives at the collector, it goes through a multi-stage pipeline. Each stage transforms, filters, or routes the data. This follows the <strong>pipes and filters</strong> architectural pattern, where each stage is independent and can be scaled separately.</p>\n<p><img src=\"/api/project/apm-system/architecture-doc/asset?path=diagrams%2Fingestion-sequence.svg\" alt=\"Sequence: Trace Ingestion and Processing\"></p>\n<h4 id=\"pipeline-stages-step-by-step-algorithm\">Pipeline Stages (Step-by-Step Algorithm)</h4>\n<ol>\n<li><p><strong>Receipt and Deserialization</strong></p>\n<ul>\n<li>Accept connection from client (HTTP or gRPC)</li>\n<li>Read request body and parse based on content-type (JSON or protobuf)</li>\n<li>Validate basic structure: required fields present, correct data types</li>\n<li>Convert to internal <code>Span</code> struct format for uniform processing</li>\n</ul>\n</li>\n<li><p><strong>Validation and Sanitization</strong></p>\n<ul>\n<li>Validate trace ID and span ID formats (hexadecimal, correct length)</li>\n<li>Verify timestamps: <code>endTime</code> ≥ <code>startTime</code>, timestamps not in future</li>\n<li>Sanitize attributes: truncate overly long values, remove sensitive data</li>\n<li>Check for mandatory OpenTelemetry semantic conventions</li>\n</ul>\n</li>\n<li><p><strong>Sampling Decision (Head-Based)</strong></p>\n<ul>\n<li>Compute hash of trace ID (consistent hashing)</li>\n<li>Apply sampling rate based on service name and operation</li>\n<li>If trace is rejected, drop all spans immediately (no further processing)</li>\n<li>Record sampling decision for later reference</li>\n</ul>\n</li>\n<li><p><strong>Buffering and Grouping</strong></p>\n<ul>\n<li>Add span to in-memory buffer keyed by trace ID</li>\n<li>Check if trace is now &quot;complete&quot; (all expected spans received)</li>\n<li>For incomplete traces, start/refresh timeout timer</li>\n<li>For complete traces, move to next stage immediately</li>\n</ul>\n</li>\n<li><p><strong>Trace Assembly</strong></p>\n<ul>\n<li>Retrieve all spans for the trace from buffer</li>\n<li>Build parent-child relationships using span ID and parent span ID</li>\n<li>Calculate trace-level statistics: start time, end time, total duration</li>\n<li>Create <code>Trace</code> struct containing all spans in chronological order</li>\n</ul>\n</li>\n<li><p><strong>Storage Persistence</strong></p>\n<ul>\n<li>Write all spans of the trace to persistent storage (bulk write)</li>\n<li>Create secondary indexes for efficient querying</li>\n<li>Update service registry with new service/operation names</li>\n<li>Notify downstream components (service map, analytics)</li>\n</ul>\n</li>\n<li><p><strong>Buffer Cleanup</strong></p>\n<ul>\n<li>Remove trace from in-memory buffer after successful persistence</li>\n<li>For timed-out traces (incomplete after window), write partial trace with metadata</li>\n<li>Report metrics: buffer size, trace completion rate, timeout count</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"trace-completion-detection\">Trace Completion Detection</h4>\n<p>A trace is considered &quot;complete&quot; when either:</p>\n<ol>\n<li>All expected spans have arrived (based on span count metadata if provided)</li>\n<li>A configurable timeout (default: 5 minutes) has elapsed since the first span</li>\n<li>An explicit &quot;trace end&quot; marker span is received</li>\n</ol>\n<p>The collector uses a <strong>watermark-based approach</strong>: when the latest timestamp among all received spans exceeds <code>current_time - timeout_window</code>, and no new spans have arrived for that period, the trace is considered complete.</p>\n<h3 id=\"adr-buffering-strategy-for-late-arriving-spans\">ADR: Buffering Strategy for Late-Arriving Spans</h3>\n<blockquote>\n<p><strong>Decision: Hybrid Buffering with Write-Ahead Logging</strong></p>\n<ul>\n<li><strong>Context</strong>: Spans from the same trace arrive out of order and potentially hours apart due to network delays, retries, or slow services. The collector must temporarily store incomplete traces without risking data loss if the collector crashes.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Pure In-Memory Buffer</strong>: Keep all incomplete traces in RAM with periodic snapshots to disk</li>\n<li><strong>Write-Ahead Log (WAL) + Memory Index</strong>: Write all spans immediately to disk log, with in-memory index of incomplete traces</li>\n<li><strong>External Buffer Service</strong>: Offload buffering to external system (Redis, Kafka)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach: spans written to WAL immediately, with in-memory index for fast trace assembly</li>\n<li><strong>Rationale</strong>: <ul>\n<li><strong>Durability</strong>: WAL ensures no data loss on collector crash/restart</li>\n<li><strong>Performance</strong>: In-memory index enables fast trace completion checks</li>\n<li><strong>Simplicity</strong>: No external dependencies for core functionality</li>\n<li><strong>Cost-effective</strong>: Disk storage cheaper than RAM for large buffers</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Added disk I/O for every span (mitigated by batching writes)</li>\n<li>Need for WAL compaction to remove completed traces</li>\n<li>Slightly higher latency per span but better overall reliability</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Options Comparison Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pure In-Memory Buffer</td>\n<td>- Fastest performance<br>- Simple implementation</td>\n<td>- Data loss on crash<br>- Memory grows unbounded<br>- Difficult to scale</td>\n<td>No</td>\n</tr>\n<tr>\n<td>WAL + Memory Index</td>\n<td>- Durable (crash-safe)<br>- Memory usage predictable<br>- Easier to scale horizontally</td>\n<td>- Disk I/O overhead<br>- Requires WAL management<br>- More complex implementation</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>External Buffer Service</td>\n<td>- Offloads resource management<br>- Easier to scale independently<br>- Built-in replication</td>\n<td>- External dependency<br>- Network latency<br>- Additional operational complexity</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h4 id=\"wal-implementation-details\">WAL Implementation Details</h4>\n<p>The Write-Ahead Log is implemented as a set of append-only files:</p>\n<ol>\n<li><p><strong>Span Log</strong>: Each incoming span is serialized and appended with metadata:</p>\n<ul>\n<li>Timestamp of receipt</li>\n<li>Trace ID and span ID</li>\n<li>Processing status (pending, processed)</li>\n</ul>\n</li>\n<li><p><strong>Index File</strong>: In-memory map from trace ID to:</p>\n<ul>\n<li>List of span offsets in the WAL</li>\n<li>Timestamp of first span</li>\n<li>Current state (incomplete, assembling, complete)</li>\n</ul>\n</li>\n<li><p><strong>Cleanup Process</strong>: Background goroutine that:</p>\n<ul>\n<li>Periodically scans for completed traces older than retention period</li>\n<li>Removes their entries from the index</li>\n<li>Marks corresponding WAL segments as reclaimable</li>\n</ul>\n</li>\n<li><p><strong>Recovery Process</strong>: On collector restart:</p>\n<ul>\n<li>Read WAL from last checkpoint</li>\n<li>Rebuild in-memory index</li>\n<li>Resume processing incomplete traces</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"common-pitfalls-in-trace-collection\">Common Pitfalls in Trace Collection</h3>\n<h4 id=\"-pitfall-1-unbounded-memory-growth-from-incomplete-traces\">⚠️ <strong>Pitfall 1: Unbounded Memory Growth from Incomplete Traces</strong></h4>\n<ul>\n<li><strong>Description</strong>: Holding all incomplete traces in memory indefinitely causes OOM crashes</li>\n<li><strong>Why It&#39;s Wrong</strong>: Memory is finite; slow or stuck traces accumulate forever</li>\n<li><strong>Fix</strong>: Implement <strong>time-based eviction</strong> with disk spillover:<ol>\n<li>Set maximum buffer size (e.g., 100,000 traces)</li>\n<li>Move oldest incomplete traces to disk when limit reached</li>\n<li>Implement TTL (e.g., 24 hours) after which partial traces are discarded with warning</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"-pitfall-2-clock-skew-creates-incorrect-span-ordering\">⚠️ <strong>Pitfall 2: Clock Skew Creates Incorrect Span Ordering</strong></h4>\n<ul>\n<li><strong>Description</strong>: Spans from services with misconfigured clocks appear in wrong chronological order</li>\n<li><strong>Why It&#39;s Wrong</strong>: Trace visualization shows impossible sequences (child before parent)</li>\n<li><strong>Fix</strong>: Apply <strong>clock skew correction</strong>:<ol>\n<li>Record collector receipt timestamp for each span</li>\n<li>Compare service timestamp vs. receipt timestamp</li>\n<li>Apply offset correction if discrepancy exceeds threshold (e.g., 5 seconds)</li>\n<li>Log warnings for services with persistent clock issues</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"-pitfall-3-incorrect-parent-child-linking\">⚠️ <strong>Pitfall 3: Incorrect Parent-Child Linking</strong></h4>\n<ul>\n<li><strong>Description</strong>: Spans with invalid parentSpanID create orphaned spans or incorrect hierarchies</li>\n<li><strong>Why It&#39;s Wrong</strong>: Breaks trace continuity, makes debugging impossible</li>\n<li><strong>Fix</strong>: Implement <strong>strict validation and repair</strong>:<ol>\n<li>Validate parentSpanID format (hexadecimal, correct length)</li>\n<li>Verify parent span exists in same trace before linking</li>\n<li>For invalid parents, mark span as &quot;root&quot; with error attribute</li>\n<li>Provide metrics on linking failure rate per service</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"-pitfall-4-head-of-line-blocking-in-pipeline\">⚠️ <strong>Pitfall 4: Head-of-Line Blocking in Pipeline</strong></h4>\n<ul>\n<li><strong>Description</strong>: Slow processing of one trace blocks all subsequent traces</li>\n<li><strong>Why It&#39;s Wrong</strong>: Reduces overall throughput, causes request timeouts</li>\n<li><strong>Fix</strong>: Use <strong>bounded worker pools with per-trace isolation</strong>:<ol>\n<li>Each trace processed by dedicated worker</li>\n<li>Workers can&#39;t block each other</li>\n<li>Slow traces don&#39;t affect unrelated traces</li>\n<li>Implement circuit breakers for pathological traces</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"-pitfall-5-lost-spans-from-trace-sampling-inconsistency\">⚠️ <strong>Pitfall 5: Lost Spans from Trace Sampling Inconsistency</strong></h4>\n<ul>\n<li><strong>Description</strong>: Different spans from same trace get different sampling decisions</li>\n<li><strong>Why It&#39;s Wrong</strong>: Creates incomplete traces missing critical spans</li>\n<li><strong>Fix</strong>: Implement <strong>consistent sampling with decision caching</strong>:<ol>\n<li>Make sampling decision based on trace ID (not span ID)</li>\n<li>Cache decision for trace TTL (e.g., 1 hour)</li>\n<li>All subsequent spans from same trace use cached decision</li>\n<li>Reject spans if decision cache is full (fail-safe to &quot;keep&quot;)</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"implementation-guidance-for-trace-collection\">Implementation Guidance for Trace Collection</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Server</td>\n<td>Go&#39;s <code>net/http</code> with JSON</td>\n<td><code>gin</code> or <code>chi</code> router with middleware</td>\n</tr>\n<tr>\n<td>gRPC Server</td>\n<td>Standard <code>google.golang.org/grpc</code></td>\n<td>With interceptors for auth/telemetry</td>\n</tr>\n<tr>\n<td>Protobuf</td>\n<td><code>google.golang.org/protobuf</code></td>\n<td>With code generation via <code>protoc</code></td>\n</tr>\n<tr>\n<td>WAL Implementation</td>\n<td>Custom file-based append log</td>\n<td>Use <code>github.com/tidwall/wal</code> library</td>\n</tr>\n<tr>\n<td>In-Memory Store</td>\n<td><code>sync.Map</code> for concurrent access</td>\n<td>Sharded maps with <code>github.com/orcaman/concurrent-map</code></td>\n</tr>\n<tr>\n<td>Serialization</td>\n<td>JSON for readability</td>\n<td>Protocol Buffers for performance</td>\n</tr>\n<tr>\n<td>Metrics</td>\n<td>Prometheus client library</td>\n<td>OpenTelemetry metrics SDK</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── cmd/\n│   └── collector/\n│       └── main.go                 # Collector entry point\n├── internal/\n│   ├── collector/\n│   │   ├── api/                    # API layer\n│   │   │   ├── http/\n│   │   │   │   ├── server.go      # HTTP server implementation\n│   │   │   │   └── handlers.go    # Request handlers\n│   │   │   └── grpc/\n│   │   │       ├── server.go      # gRPC server implementation\n│   │   │       └── service.go     # gRPC service definition\n│   │   ├── pipeline/               # Processing pipeline\n│   │   │   ├── pipeline.go        # Pipeline orchestration\n│   │   │   ├── stages/            # Individual pipeline stages\n│   │   │   │   ├── receiver.go    # Stage 1: Receipt\n│   │   │   │   ├── validator.go   # Stage 2: Validation\n│   │   │   │   ├── sampler.go     # Stage 3: Sampling\n│   │   │   │   ├── buffer.go      # Stage 4: Buffering\n│   │   │   │   ├── assembler.go   # Stage 5: Assembly\n│   │   │   │   └── persister.go   # Stage 6: Persistence\n│   │   │   └── queue.go           # Inter-stage queues\n│   │   ├── buffer/                # Buffering subsystem\n│   │   │   ├── wal/\n│   │   │   │   ├── writer.go      # WAL write operations\n│   │   │   │   ├── reader.go      # WAL read operations\n│   │   │   │   ├── index.go       # In-memory index\n│   │   │   │   └── cleaner.go     # WAL cleanup\n│   │   │   └── memory/\n│   │   │       ├── manager.go     # Buffer manager\n│   │   │       ├── eviction.go    # Eviction policies\n│   │   │       └── metrics.go     # Buffer metrics\n│   │   └── storage/               # Storage abstraction\n│   │       ├── interface.go       # Storage interface\n│   │       ├── memory_store.go    # In-memory implementation (dev)\n│   │       └── cassandra_store.go # Cassandra implementation\n├── pkg/\n│   ├── models/                    # Data models\n│   │   ├── trace.go               # Trace struct\n│   │   ├── span.go                # Span struct\n│   │   └── service.go             # Service struct\n│   └── sampling/                  # Sampling logic\n│       ├── sampler.go             # Sampler interface\n│       └── consistent_hash.go     # Consistent hash sampler\n└── proto/                         # Protobuf definitions\n    └── otlp/                      # OpenTelemetry proto files</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete WAL Writer Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/collector/buffer/wal/writer.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> wal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/binary</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WALWriter</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu       </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewWALWriter creates a new WAL writer for the given file path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewWALWriter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">OpenFile</span><span style=\"color:#E1E4E8\">(filePath, os.O_APPEND</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_CREATE</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_WRONLY, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stat, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> file.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file:     file,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        filePath: filePath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset:   stat.</span><span style=\"color:#B392F0\">Size</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Append writes a record to the WAL and returns its offset</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write length prefix (8 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(data))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(w.file, binary.LittleEndian, length); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write the actual data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(data); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sync to disk for durability</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#F97583\"> +</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(length) </span><span style=\"color:#6A737D\">// 8 bytes for length prefix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> currentOffset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Rotate creates a new WAL file and returns the old file for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Rotate</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    oldFile </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create new file with timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newFilePath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.filePath </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \".\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Format</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"20060102_150405\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newFile, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">OpenFile</span><span style=\"color:#E1E4E8\">(newFilePath, os.O_APPEND</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_CREATE</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_WRONLY, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.file </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newFile</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.filePath </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newFilePath</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> oldFile, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close gracefully closes the WAL file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>HTTP Server with Health Check:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/collector/api/http/server.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> http</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Server</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    port   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Handler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        server: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Addr:         fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\":</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, port),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Handler:      handler,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ReadTimeout:  </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            WriteTimeout: </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        port: port,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting HTTP server on port </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, s.port)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.server.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Shutting down HTTP server...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.server.</span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HealthHandler provides health check endpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> HealthHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusOK)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Fprintf</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">`{\"status\": \"healthy\", \"timestamp\": \"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"}`</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UTC</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Format</span><span style=\"color:#E1E4E8\">(time.RFC3339))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Trace Assembler (Core Algorithm):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/collector/pipeline/stages/assembler.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> stages</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-org/apm-tracing/pkg/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TraceAssembler takes a slice of spans and constructs a complete Trace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TraceAssembler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxTraceDuration </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewTraceAssembler creates a new trace assembler with the given configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTraceAssembler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">maxTraceDuration</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceAssembler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TraceAssembler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxTraceDuration: maxTraceDuration,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AssembleTrace takes all spans for a trace and builds the hierarchical structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ta </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceAssembler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AssembleTrace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">spans</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that all spans have the same trace ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If not, return error \"spans belong to different traces\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Sort spans by start time (ascending)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use sort.Slice with spans[i].StartTime comparison</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Build a map from span ID to span for fast lookup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Create map[string]*models.Span</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Store pointer to each span (not copy)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Identify root span(s) - spans with empty or non-existent parentSpanID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - For each span, check if parentSpanID exists in the map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If not, this is a root span (could be multiple in case of errors)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Build parent-child relationships</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - For each non-root span, find its parent in the map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If parent found, establish relationship (you may need to add Children field to Span)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If parent not found, mark as \"orphaned\" with warning attribute</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Calculate trace-level statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Find earliest start time among all spans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Find latest end time (start + duration)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Verify total duration doesn't exceed maxTraceDuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Count spans by status code (success, error)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Create and return the Trace object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Initialize models.Trace with TraceID from first span</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set Spans field to the sorted slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set StartTime and EndTime to calculated values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Return pointer to Trace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#6A737D\"> // Remove this line after implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsTraceComplete checks if we have all spans for a trace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ta </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceAssembler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsTraceComplete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">spans</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">firstSpanTime</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if we have a \"trace end\" marker span</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Look for span with attribute \"trace.end\" = true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check timeout - if first span is older than maxTraceDuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If time.Since(firstSpanTime) > ta.maxTraceDuration, return true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For advanced implementation: check expected span count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Some tracing systems include \"total_spans\" in root span</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Compare len(spans) with expected count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Apply watermark algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Find latest timestamp among all spans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If currentTime - latestTimestamp > completionWindow, return true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#6A737D\"> // Remove this line after implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Buffer Manager with Eviction Policy:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/collector/buffer/memory/manager.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> memory</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-org/apm-tracing/pkg/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BufferManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxSize        </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ttl            </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    traces         </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceBuffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accessTimes    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    evictionPolicy </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // \"lru\", \"ttl\", \"fifo\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TraceBuffer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spans      []</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    firstSeen  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastSeen   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isComplete </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBufferManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">maxSize</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttl</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">evictionPolicy</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BufferManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxSize:        maxSize,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ttl:            ttl,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        traces:         </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceBuffer</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        accessTimes:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        evictionPolicy: evictionPolicy,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddSpan adds a span to the buffer for its trace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">span</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get or create TraceBuffer for this trace ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check if traceID exists in bm.traces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If not, create new TraceBuffer with firstSeen = time.Now()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add span to the buffer's spans slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Append the span</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Update lastSeen to current time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update access times for eviction tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set bm.accessTimes[traceID] = time.Now()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check if buffer is full (len(bm.traces) >= bm.maxSize)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If full, trigger eviction (call bm.evict(ctx))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check TTL for this trace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If time.Since(firstSeen) > bm.ttl, mark for eviction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Remove this line after implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// evict removes traces based on the configured eviction policy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">evict</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Based on bm.evictionPolicy, select traces to evict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If \"lru\": find trace with oldest access time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If \"ttl\": find traces where time.Since(firstSeen) > ttl</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If \"fifo\": find trace with oldest firstSeen</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For selected traces:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Write incomplete traces to disk (partial storage)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Remove from bm.traces map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Remove from bm.accessTimes map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return count of evicted traces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#6A737D\"> // Remove this line after implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetTraceSpans returns all spans for a given trace ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTraceSpans</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up trace in bm.traces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Return error if not found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update access time (for LRU policy)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - bm.accessTimes[traceID] = time.Now()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return copy of spans slice (not the original)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#6A737D\"> // Remove this line after implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Concurrency in Go</strong>: Use <code>sync.RWMutex</code> for protecting the buffer index. Readers (span lookups) use <code>RLock()</code>, writers (adding spans) use <code>Lock()</code>.</p>\n</li>\n<li><p><strong>Context Propagation</strong>: Always pass <code>context.Context</code> through the pipeline. Use <code>ctx.Value()</code> for request-scoped data like request ID, and check <code>ctx.Err()</code> for cancellation.</p>\n</li>\n<li><p><strong>Error Handling</strong>: Use Go 1.13+ error wrapping: <code>fmt.Errorf(&quot;failed to write span: %w&quot;, err)</code>. Create sentinel errors for expected failures (e.g., <code>ErrTraceNotFound</code>).</p>\n</li>\n<li><p><strong>Performance</strong>: Pre-allocate slices with expected capacity: <code>spans := make([]models.Span, 0, estimatedSpanCount)</code> to avoid repeated reallocations.</p>\n</li>\n<li><p><strong>Metrics</strong>: Use Prometheus counters and histograms:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   spansReceived </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> prometheus.</span><span style=\"color:#B392F0\">NewCounterVec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   processingDuration </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> prometheus.</span><span style=\"color:#B392F0\">NewHistogramVec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"6\">\n<li><strong>Graceful Shutdown</strong>: Use <code>signal.NotifyContext</code> to handle SIGTERM:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   ctx, stop </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> signal.</span><span style=\"color:#B392F0\">NotifyContext</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">(), os.Interrupt, syscall.SIGTERM)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   defer</span><span style=\"color:#B392F0\"> stop</span><span style=\"color:#E1E4E8\">()</span></span></code></pre></div>\n\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>To verify Trace Collection is working correctly:</strong></p>\n<ol>\n<li><strong>Start the collector</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   go run cmd/collector/main.go --config config/local.yaml</code></pre></div>\n<p>   Expected output: <code>Starting collector on :4317 (gRPC) and :4318 (HTTP)</code></p>\n<ol start=\"2\">\n<li><strong>Send test spans via HTTP</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:4318/v1/traces</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -d</span><span style=\"color:#9ECBFF\"> '[{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"traceId\": \"4bf92f3577b34da6a3ce929d0e0e4736\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"spanId\": \"00f067aa0ba902b7\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"name\": \"/api/users\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"kind\": 2,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"startTimeUnixNano\": 1505855794194000,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"endTimeUnixNano\": 1505855794195000,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"attributes\": [{\"key\": \"http.method\", \"value\": {\"stringValue\": \"GET\"}}]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">     }]'</span></span></code></pre></div>\n<p>   Expected response: <code>HTTP/2 202 Accepted</code></p>\n<ol start=\"3\">\n<li><strong>Query stored trace</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> http://localhost:4318/api/traces/4bf92f3577b34da6a3ce929d0e0e4736</span></span></code></pre></div>\n<p>   Should return the complete trace with all spans.</p>\n<ol start=\"4\">\n<li><strong>Run validation tests</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   go test ./internal/collector/pipeline/stages/... -v</code></pre></div>\n<p>   All tests should pass, including:</p>\n<ul>\n<li>Test span validation rejects malformed data</li>\n<li>Test trace assembly builds correct hierarchy</li>\n<li>Test buffer eviction works as expected</li>\n</ul>\n<ol start=\"5\">\n<li><strong>Check metrics</strong> (if Prometheus endpoint enabled):</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   curl http://localhost:9090/metrics | grep collector_</code></pre></div>\n<p>   Should see metrics like <code>collector_spans_received_total</code>, <code>collector_buffer_size</code>.</p>\n<p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li><strong>Spans not linking</strong>: Check parentSpanID format and validation logic</li>\n<li><strong>High memory usage</strong>: Check buffer eviction is working, inspect with <code>go tool pprof</code></li>\n<li><strong>Slow ingestion</strong>: Check for blocking operations in pipeline, use Go&#39;s race detector</li>\n<li><strong>Data loss on restart</strong>: Verify WAL is being fsync&#39;d and recovery reads all records</li>\n</ul>\n<hr>\n<h2 id=\"6-component-design-service-map-milestone-2\">6. Component Design: Service Map (Milestone 2)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 2: Service Map, which analyzes trace data to build and visualize dynamic service dependency graphs.</p>\n</blockquote>\n<h3 id=\"mental-model-the-social-network-of-services\">Mental Model: The Social Network of Services</h3>\n<p>Think of your distributed system as a <strong>social network of services</strong>, where each service is a person and each service call is a friendship interaction. The service map is the &quot;friend graph&quot; that shows who talks to whom, how often they communicate, and the quality of their relationships. Just as you could learn about social dynamics by observing who messages whom and how frequently, we learn about system architecture by observing which services call each other and with what latency and success rates.</p>\n<p>This mental model helps clarify several key concepts:</p>\n<ol>\n<li><strong>Nodes as services</strong>: Each service is a node in the graph, similar to each person in a social network</li>\n<li><strong>Edges as relationships</strong>: A call from Service A to Service B creates a directed edge (A→B), similar to A sending a message to B</li>\n<li><strong>Edge weight as interaction frequency</strong>: The thickness of the edge represents call volume, just as thicker lines between people might represent more frequent communication</li>\n<li><strong>Edge color as relationship health</strong>: Red edges indicate high error rates (problematic relationships), while green edges indicate healthy interactions</li>\n<li><strong>Clusters as architectural patterns</strong>: Services that frequently call each other form clusters, revealing microservice boundaries or bounded contexts</li>\n</ol>\n<p>Just as social networks evolve over time with new friendships forming and old ones fading, your service map must detect and visualize topology changes as services are added, removed, or their communication patterns change.</p>\n<h3 id=\"algorithm-building-the-graph-from-spans\">Algorithm: Building the Graph from Spans</h3>\n<p>Building an accurate service map requires analyzing spans to extract service call relationships, then aggregating metrics over those relationships. The algorithm operates in three phases: <strong>extraction</strong>, <strong>aggregation</strong>, and <strong>refresh</strong>. The following flowchart illustrates this process:</p>\n<p><img src=\"/api/project/apm-system/architecture-doc/asset?path=diagrams%2Fservicemap-flowchart.svg\" alt=\"Flowchart: Service Map Construction\"></p>\n<h4 id=\"phase-1-edge-extraction-from-individual-spans\">Phase 1: Edge Extraction from Individual Spans</h4>\n<p>For each incoming span, we extract potential service call edges by examining parent-child relationships:</p>\n<ol>\n<li><strong>Filter relevant spans</strong>: Only consider spans with a non-empty <code>ParentSpanID</code> (excluding root spans) and with <code>ServiceName</code> populated</li>\n<li><strong>Retrieve parent span</strong>: Using the span&#39;s <code>TraceID</code> and <code>ParentSpanID</code>, fetch the parent span from storage or buffer</li>\n<li><strong>Identify caller-callee relationship</strong>: <ul>\n<li><strong>Caller</strong>: The <code>ServiceName</code> of the parent span</li>\n<li><strong>Callee</strong>: The <code>ServiceName</code> of the child span</li>\n</ul>\n</li>\n<li><strong>Validate edge</strong>: Ensure caller ≠ callee (ignore same-service spans for the service map, as they represent internal operations)</li>\n<li><strong>Extract operation context</strong>: Record the <code>Name</code> field (operation) of both spans for detailed metrics</li>\n<li><strong>Capture timing information</strong>: Calculate the <strong>inter-service latency</strong> as: <code>child.StartTime - parent.StartTime</code> (adjusting for any clock skew using techniques from Milestone 1)</li>\n</ol>\n<p>This phase produces raw edges with the following structure:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CallerService</code></td>\n<td><code>string</code></td>\n<td>Name of the service making the call</td>\n</tr>\n<tr>\n<td><code>CalleeService</code></td>\n<td><code>string</code></td>\n<td>Name of the service receiving the call</td>\n</tr>\n<tr>\n<td><code>CallerOperation</code></td>\n<td><code>string</code></td>\n<td>Operation/endpoint name on the caller side</td>\n</tr>\n<tr>\n<td><code>CalleeOperation</code></td>\n<td><code>string</code></td>\n<td>Operation/endpoint name on the callee side</td>\n</tr>\n<tr>\n<td><code>TraceID</code></td>\n<td><code>string</code></td>\n<td>Identifier of the trace containing this call</td>\n</tr>\n<tr>\n<td><code>SpanID</code></td>\n<td><code>string</code></td>\n<td>Identifier of the child span (the call)</td>\n</tr>\n<tr>\n<td><code>StartTime</code></td>\n<td><code>time.Time</code></td>\n<td>When the call began</td>\n</tr>\n<tr>\n<td><code>Duration</code></td>\n<td><code>time.Duration</code></td>\n<td>How long the call took</td>\n</tr>\n<tr>\n<td><code>IsError</code></td>\n<td><code>bool</code></td>\n<td>Whether the span status indicates an error (based on <code>SpanStatus.Code</code>)</td>\n</tr>\n<tr>\n<td><code>Attributes</code></td>\n<td><code>map[string]string</code></td>\n<td>Additional attributes that might affect edge grouping</td>\n</tr>\n</tbody></table>\n<h4 id=\"phase-2-metric-aggregation-over-time-windows\">Phase 2: Metric Aggregation over Time Windows</h4>\n<p>Instead of tracking every individual call, we aggregate metrics over configurable time windows (e.g., 1 minute, 5 minutes, 1 hour) to create summarized views:</p>\n<ol>\n<li><strong>Group edges by (caller, callee) pair</strong>: All calls from Service A to Service B within the same time window are aggregated together</li>\n<li><strong>Calculate aggregated metrics</strong> for each edge:<ul>\n<li><strong>Total Calls</strong>: Count of all calls in the window</li>\n<li><strong>Error Count</strong>: Count of calls where <code>IsError = true</code></li>\n<li><strong>Error Rate</strong>: <code>Error Count / Total Calls</code></li>\n<li><strong>Latency Percentiles</strong>: p50, p95, p99 latencies calculated using the t-digest algorithm (see Milestone 4)</li>\n<li><strong>Total Bytes Transferred</strong> (if available from span attributes)</li>\n</ul>\n</li>\n<li><strong>Maintain rolling windows</strong>: Keep multiple time windows (current, previous) to enable trend analysis (e.g., &quot;error rate increased by 15% compared to last hour&quot;)</li>\n<li><strong>Apply dimension reduction</strong>: Optionally group by operation patterns if there are too many distinct operations causing high cardinality</li>\n</ol>\n<p>The aggregated edge structure becomes:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CallerService</code></td>\n<td><code>string</code></td>\n<td>Name of the service making the call</td>\n</tr>\n<tr>\n<td><code>CalleeService</code></td>\n<td><code>string</code></td>\n<td>Name of the service receiving the call</td>\n</tr>\n<tr>\n<td><code>WindowStart</code></td>\n<td><code>time.Time</code></td>\n<td>Start of the aggregation window</td>\n</tr>\n<tr>\n<td><code>WindowEnd</code></td>\n<td><code>time.Time</code></td>\n<td>End of the aggregation window</td>\n</tr>\n<tr>\n<td><code>TotalCalls</code></td>\n<td><code>int64</code></td>\n<td>Number of calls in this window</td>\n</tr>\n<tr>\n<td><code>ErrorCount</code></td>\n<td><code>int64</code></td>\n<td>Number of failed calls</td>\n</tr>\n<tr>\n<td><code>ErrorRate</code></td>\n<td><code>float64</code></td>\n<td><code>ErrorCount / TotalCalls</code></td>\n</tr>\n<tr>\n<td><code>P50Latency</code></td>\n<td><code>time.Duration</code></td>\n<td>50th percentile latency</td>\n</tr>\n<tr>\n<td><code>P95Latency</code></td>\n<td><code>time.Duration</code></td>\n<td>95th percentile latency</td>\n</tr>\n<tr>\n<td><code>P99Latency</code></td>\n<td><code>time.Duration</code></td>\n<td>99th percentile latency</td>\n</tr>\n<tr>\n<td><code>SampleTraceIDs</code></td>\n<td><code>[]string</code></td>\n<td>A small sample of trace IDs (e.g., 5) representing this edge for drill-down</td>\n</tr>\n</tbody></table>\n<h4 id=\"phase-3-graph-construction-and-topology-detection\">Phase 3: Graph Construction and Topology Detection</h4>\n<p>With aggregated edges, we build the service dependency graph:</p>\n<ol>\n<li><strong>Create graph nodes</strong>: Each unique service name becomes a node in the graph</li>\n<li><strong>Create directed edges</strong>: Each unique (caller, callee) pair becomes a directed edge</li>\n<li><strong>Apply edge weights</strong>: Visual thickness corresponds to <code>TotalCalls</code> (logarithmic scale to handle wide ranges)</li>\n<li><strong>Color coding</strong>: <ul>\n<li>Green: <code>ErrorRate &lt; 1%</code></li>\n<li>Yellow: <code>1% ≤ ErrorRate &lt; 5%</code></li>\n<li>Red: <code>ErrorRate ≥ 5%</code></li>\n</ul>\n</li>\n<li><strong>Detect topology changes</strong>:<ul>\n<li><strong>New service</strong>: A service appears in the trace data that wasn&#39;t in the previous graph</li>\n<li><strong>Removed service</strong>: A service hasn&#39;t been seen in the last N time windows (configurable timeout)</li>\n<li><strong>New dependency</strong>: An edge appears between existing services where none existed before</li>\n<li><strong>Dependency removed</strong>: An edge hasn&#39;t been observed in the last M time windows</li>\n</ul>\n</li>\n<li><strong>Detect cyclic dependencies</strong>: Use depth-first search to identify cycles in the directed graph, which may indicate problematic architectural patterns</li>\n</ol>\n<p>The complete service map refresh algorithm runs periodically (e.g., every 30 seconds) and processes spans that arrived since the last refresh.</p>\n<h3 id=\"adr-graph-storage-materialized-vs-on-demand\">ADR: Graph Storage - Materialized vs. On-Demand</h3>\n<blockquote>\n<p><strong>Decision: Materialized Graph with Incremental Updates</strong></p>\n<ul>\n<li><strong>Context</strong>: The service map needs to support both real-time visualization (updating every few seconds) and historical queries (showing how dependencies changed over hours/days). We must decide whether to pre-compute and store the graph (materialized) or compute it on-demand from raw span data.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>On-Demand Computation</strong>: Query raw spans from storage each time the service map is requested, compute the graph in memory, and return it.</li>\n<li><strong>Materialized Graph with Full Rebuild</strong>: Pre-compute the graph periodically (e.g., every minute), store it in a dedicated graph database, and serve queries from this materialized view.</li>\n<li><strong>Materialized Graph with Incremental Updates</strong>: Maintain an in-memory aggregated view of edges, flush snapshots to storage periodically, and update incrementally as new spans arrive.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Option 3 - Materialized Graph with Incremental Updates.</li>\n<li><strong>Rationale</strong>: <ul>\n<li><strong>Latency requirements</strong>: The service map UI should update near-real-time (sub-second), which on-demand computation cannot guarantee as span volumes grow.</li>\n<li><strong>Resource efficiency</strong>: Incremental updates amortize computation cost, whereas full rebuilds wastefully recompute unchanged portions of the graph.</li>\n<li><strong>Query flexibility</strong>: Materialized edges with time windows enable both current-state and historical trend queries without scanning all raw spans.</li>\n<li><strong>Resilience</strong>: In-memory aggregated state can be reconstructed from recent span data if the process restarts, providing a good balance between performance and durability.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>We must implement careful memory management for the in-memory aggregated state.</li>\n<li>The system maintains eventual consistency - there&#39;s a brief delay (window size) before new dependencies appear.</li>\n<li>Historical queries are limited to the retention period of aggregated edges, not raw spans.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The following table compares the options:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>On-Demand Computation</strong></td>\n<td>Always accurate (no stale data), No additional storage needed, Simple implementation</td>\n<td>Slow for large datasets, High load on span storage, Doesn&#39;t scale with request volume</td>\n<td>Unacceptable latency for real-time visualization (seconds to minutes for large deployments)</td>\n</tr>\n<tr>\n<td><strong>Materialized Graph with Full Rebuild</strong></td>\n<td>Consistent view at rebuild time, Can use optimized graph databases, Clean separation of concerns</td>\n<td>High CPU usage during rebuilds, Stale data between rebuilds, Wastes resources recomputing unchanged portions</td>\n<td>The periodic full rebuilds create resource spikes and stale periods</td>\n</tr>\n<tr>\n<td><strong>Materialized Graph with Incremental Updates</strong></td>\n<td>Near-real-time updates, Efficient resource usage, Enables both current and historical views</td>\n<td>More complex implementation, Requires memory management, Eventual consistency</td>\n<td><strong>CHOSEN</strong>: Best balance of performance, accuracy, and resource efficiency</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-service-map-construction\">Common Pitfalls in Service Map Construction</h3>\n<p>⚠️ <strong>Pitfall 1: Misattributing Async and Concurrent Calls</strong></p>\n<p><strong>Description</strong>: When Service A makes concurrent calls to Service B (e.g., fan-out pattern) or async calls (fire-and-forget), the simple parent-child relationship extraction can misinterpret the dependency direction or create misleading metrics.</p>\n<p><strong>Why it&#39;s wrong</strong>: If Service A calls Service B 10 times concurrently within a single request, counting these as 10 separate dependencies exaggerates the importance of the A→B edge. Async calls might not have proper parent-child linking, causing them to appear as separate, disconnected traces.</p>\n<p><strong>How to fix</strong>: </p>\n<ul>\n<li><strong>Group concurrent calls</strong>: When multiple spans share the same parent and have similar start times (within a small threshold, e.g., 10ms), treat them as a single logical operation for dependency analysis.</li>\n<li><strong>Trace context propagation</strong>: Ensure async operations propagate the trace context properly (see Milestone 5) to maintain parent-child relationships.</li>\n<li><strong>Attribute tagging</strong>: Use span attributes (e.g., <code>call.type=async</code>) to identify and handle special call patterns differently.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 2: High Cardinality from Operation Names</strong></p>\n<p><strong>Description</strong>: When services have hundreds or thousands of distinct operation names (endpoints), creating separate edges for each (caller, callee, caller-op, callee-op) tuple explodes the edge count, making the graph unreadable and storage requirements unsustainable.</p>\n<p><strong>Why it&#39;s wrong</strong>: A service map with 10,000 edges is visually useless and computationally expensive. The core value is understanding service-to-service dependencies, not endpoint-to-endpoint details.</p>\n<p><strong>How to fix</strong>:</p>\n<ul>\n<li><strong>Two-level aggregation</strong>: First aggregate by (caller, callee) pair only, ignoring operation names for the main visualization.</li>\n<li><strong>Drill-down views</strong>: Provide click-through from service edges to see operation-level breakdowns.</li>\n<li><strong>Operation grouping</strong>: Use pattern matching or configuration to group similar operations (e.g., <code>/users/*</code> → <code>/users/:id</code>).</li>\n<li><strong>Cardinality limits</strong>: Implement hard limits (e.g., top 20 operations per edge) and aggregate the rest as &quot;other&quot;.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 3: Missing or Transient Dependencies</strong></p>\n<p><strong>Description</strong>: Infrequently called services (e.g., nightly batch jobs, error-handling services) may not appear in the service map if the aggregation window is too short or sampling rate is too aggressive.</p>\n<p><strong>Why it&#39;s wrong</strong>: The service map should show all dependencies, not just frequent ones. Missing dependencies give a false sense of simplicity and can hide important failure modes.</p>\n<p><strong>How to fix</strong>:</p>\n<ul>\n<li><strong>Longer retention for edges</strong>: Keep edge aggregates for longer periods (e.g., 24-48 hours) even if they have low call volumes.</li>\n<li><strong>Sampling protection</strong>: Ensure sampling algorithms (Milestone 3) don&#39;t systematically drop traces from low-volume services.</li>\n<li><strong>Configuration-driven inclusion</strong>: Allow operators to explicitly list services that must appear regardless of call frequency.</li>\n<li><strong>Periodic full scans</strong>: Occasionally scan older span data to rediscover dormant dependencies.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 4: Incorrect Cycle Detection in Directed Graphs</strong></p>\n<p><strong>Description</strong>: Naive cycle detection algorithms can misidentify legitimate call patterns (like callback patterns, saga orchestrators) as problematic cycles, or miss actual problematic cycles due to timing issues.</p>\n<p><strong>Why it&#39;s wrong</strong>: False positives lead to unnecessary alerts and investigation. False negatives miss actual architectural issues like circular dependencies that cause deadlocks or infinite loops.</p>\n<p><strong>How to fix</strong>:</p>\n<ul>\n<li><strong>Time-bound cycle detection</strong>: Only consider cycles where all calls occur within a single request/trace context, not across different requests.</li>\n<li><strong>Distinguish call patterns</strong>: Use span attributes and operation names to identify legitimate patterns like callbacks vs. accidental cycles.</li>\n<li><strong>Multi-request cycle detection</strong>: For cycles spanning multiple requests/traces, use statistical correlation of call patterns over longer time windows.</li>\n<li><strong>Visual highlighting vs. alerting</strong>: Highlight potential cycles in the visualization for human investigation, but only alert on statistically significant patterns.</li>\n</ul>\n<h3 id=\"implementation-guidance-for-service-map\">Implementation Guidance for Service Map</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>In-Memory Graph</strong></td>\n<td>Go&#39;s native maps and slices with manual adjacency lists</td>\n<td>Dedicated graph library: <a href=\"https://github.com/gonum/graph\"><code>gonum/graph</code></a></td>\n</tr>\n<tr>\n<td><strong>Time-Series Aggregates</strong></td>\n<td>Rolling windows in memory with periodic persistence to Redis/PostgreSQL</td>\n<td>Dedicated time-series database: InfluxDB or TimescaleDB</td>\n</tr>\n<tr>\n<td><strong>Real-Time Updates</strong></td>\n<td>Periodic batch processing (e.g., every 30s) with goroutine</td>\n<td>Streaming pipeline with channels and worker pools</td>\n</tr>\n<tr>\n<td><strong>Visualization Backend</strong></td>\n<td>Static JSON API served to frontend with basic D3.js</td>\n<td>WebSocket stream of graph diffs with interactive frontend</td>\n</tr>\n<tr>\n<td><strong>Edge Storage</strong></td>\n<td>PostgreSQL with (caller, callee, window_start) composite index</td>\n<td>Redis Sorted Sets for time-windowed aggregates</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    servicemap/           # Service map microservice entry point\n      main.go\n  internal/\n    servicemap/           # Service map core logic\n      aggregator.go       # Edge extraction and metric aggregation\n      graph_builder.go    # Graph construction from aggregated edges\n      storage.go          # Interface for edge storage\n      types.go            # Service map specific types\n    servicemap/redis/     # Redis storage implementation\n      edge_store.go\n    servicemap/postgres/  # PostgreSQL storage implementation  \n      edge_store.go\n    servicemap/memory/    # In-memory storage (for development)\n      edge_store.go\n  pkg/\n    models/               # Shared data models (already defined)\n      trace.go            # Contains Span, Trace types\n      servicemap.go       # Service map specific types</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete Edge Storage Interface and In-Memory Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/servicemap/types.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> servicemap</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServiceEdge represents an aggregated edge between two services</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServiceEdge</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CallerService  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"caller_service\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CalleeService  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"callee_service\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WindowStart    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"window_start\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WindowEnd      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"window_end\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalCalls     </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">         `json:\"total_calls\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorCount     </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">         `json:\"error_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorRate      </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\">       `json:\"error_rate\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    P50Latency     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"p50_latency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    P95Latency     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"p95_latency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    P99Latency     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"p99_latency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SampleTraceIDs []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"sample_trace_ids\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServiceNode represents a node (service) in the graph</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServiceNode</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FirstSeen  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"first_seen\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastSeen   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"last_seen\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalCalls </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">     `json:\"total_calls\"`</span><span style=\"color:#6A737D\">  // Sum of all outgoing calls</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServiceGraph represents the complete service dependency graph</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServiceGraph</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Nodes        []</span><span style=\"color:#B392F0\">ServiceNode</span><span style=\"color:#9ECBFF\">          `json:\"nodes\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Edges        []</span><span style=\"color:#B392F0\">ServiceEdge</span><span style=\"color:#9ECBFF\">          `json:\"edges\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GeneratedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"generated_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WindowSize   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">          `json:\"window_size\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EdgeStorage defines the interface for storing and retrieving aggregated edges</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EdgeStorage</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // StoreEdge stores or updates an aggregated edge</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    StoreEdge</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">edge</span><span style=\"color:#B392F0\"> ServiceEdge</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetEdges returns edges for the given time window</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetEdges</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">startTime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">endTime</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">ServiceEdge</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetServiceEdges returns edges for a specific service (as caller or callee)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetServiceEdges</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">serviceName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">startTime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">endTime</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">ServiceEdge</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetEdgeHistory returns historical aggregates for a specific edge</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetEdgeHistory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">caller</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">callee</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">lookbackPeriod</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">ServiceEdge</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cleanup removes edges older than the specified duration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">olderThan</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// internal/servicemap/memory/edge_store.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> memory</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourproject/internal/servicemap</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MemoryEdgeStore</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    edges  []</span><span style=\"color:#B392F0\">servicemap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ServiceEdge</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxAge </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMemoryEdgeStore</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">maxAge</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryEdgeStore</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    store </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MemoryEdgeStore</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        edges:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">servicemap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ServiceEdge</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxAge: maxAge,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start cleanup goroutine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#E1E4E8\"> store.</span><span style=\"color:#B392F0\">periodicCleanup</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> store</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryEdgeStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StoreEdge</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">edge</span><span style=\"color:#B392F0\"> servicemap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ServiceEdge</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> s.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if edge already exists for this window</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, existing </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> s.edges {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> existing.CallerService </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> edge.CallerService </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           existing.CalleeService </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> edge.CalleeService </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           existing.WindowStart.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(edge.WindowStart) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Update existing edge</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s.edges[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> edge</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add new edge</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.edges </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(s.edges, edge)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryEdgeStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetEdges</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">startTime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">endTime</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">servicemap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ServiceEdge</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> s.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> result []</span><span style=\"color:#B392F0\">servicemap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ServiceEdge</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, edge </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> s.edges {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">edge.WindowStart.</span><span style=\"color:#B392F0\">Before</span><span style=\"color:#E1E4E8\">(startTime) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">edge.WindowEnd.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(endTime) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(result, edge)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryEdgeStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">periodicCleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Minute)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cutoff </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">s.maxAge)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            filtered </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.edges[:</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> _, edge </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> s.edges {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> edge.WindowEnd.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(cutoff) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    filtered </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(filtered, edge)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s.edges </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filtered</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Implement other EdgeStorage methods...</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Edge Aggregator with TODOs:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/servicemap/aggregator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> servicemap</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourproject/pkg/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EdgeAggregator extracts service call edges from spans and aggregates metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EdgeAggregator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    edgeStorage  </span><span style=\"color:#B392F0\">EdgeStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    windowSize   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentWindowStart </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pendingEdges </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ServiceEdge</span><span style=\"color:#6A737D\"> // Key: \"caller:callee:window_start\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add fields for t-digest instances for latency percentiles</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add metrics for monitoring the aggregator itself</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewEdgeAggregator creates a new aggregator with the specified window size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewEdgeAggregator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">storage</span><span style=\"color:#B392F0\"> EdgeStorage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">windowSize</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EdgeAggregator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">EdgeAggregator</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        edgeStorage:  storage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        windowSize:   windowSize,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pendingEdges: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ServiceEdge</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessSpan extracts edges from a span and updates aggregations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EdgeAggregator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">span</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Skip if span has no ParentSpanID (it's a root span)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Skip if span.ServiceName is empty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Retrieve parent span using GetTraceByID and ParentSpanID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         (Note: This assumes parent span is already stored - consider buffering)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If parent span not found, buffer this span for later retry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         or use asynchronous parent resolution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Extract caller service from parentSpan.ServiceName</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Extract callee service from span.ServiceName</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Skip if caller == callee (same-service calls)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Determine which time window this span belongs to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         windowStart := span.StartTime.Truncate(a.windowSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Create or update aggregated edge for (caller, callee, windowStart)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         key := fmt.Sprintf(\"%s:%s:%d\", caller, callee, windowStart.Unix())</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         edge := a.pendingEdges[key]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         if edge == nil {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //             edge = &#x26;ServiceEdge{CallerService: caller, CalleeService: callee, ...}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //             a.pendingEdges[key] = edge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Update edge metrics:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         edge.TotalCalls++</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         if span.Status.Code >= 400 { edge.ErrorCount++ } // Adjust error detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Update t-digest with span.Duration for latency percentiles</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Maintain sample of trace IDs (keep up to 5 unique ones)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: If we've reached the end of the current window, flush all pending edges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //          if windowStart != a.currentWindowStart &#x26;&#x26; a.currentWindowStart != (time.Time{}) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //              a.FlushWindow(ctx, a.currentWindowStart)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //          }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FlushWindow persists all aggregated edges for a specific window to storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EdgeAggregator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FlushWindow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">windowStart</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: For each edge in a.pendingEdges with matching windowStart:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate final metrics (ErrorRate = ErrorCount/TotalCalls)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate percentiles from t-digest</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Store edge via a.edgeStorage.StoreEdge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove flushed edges from pendingEdges map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update a.currentWindowStart to the next window</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Graph Builder with TODOs:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/servicemap/graph_builder.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> servicemap</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GraphBuilder constructs service graphs from aggregated edges</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GraphBuilder</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    edgeStorage </span><span style=\"color:#B392F0\">EdgeStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BuildCurrentGraph builds a service graph for the most recent complete time window</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GraphBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BuildCurrentGraph</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">windowSize</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ServiceGraph</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Calculate time window for the most recent complete window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         now := time.Now()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         endTime := now.Truncate(windowSize)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         startTime := endTime.Add(-windowSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Retrieve edges for this window using b.edgeStorage.GetEdges</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Extract unique service names from edges (both caller and callee)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create ServiceNode for each unique service</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         For each node, calculate total outgoing calls by summing edges where service is caller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Build ServiceGraph with nodes and edges</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Detect and mark potential issues:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Services with no incoming edges (entry points)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Services with no outgoing edges (leaf nodes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Potential cycles (use DFS or topological sort)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Edges with high error rates (> threshold)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DetectTopologyChanges compares current graph with previous graph to find changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GraphBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DetectTopologyChanges</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">currentGraph</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">previousGraph</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ServiceGraph</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TopologyChanges</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Compare nodes to detect:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - New services (in current but not previous)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Removed services (in previous but not current)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compare edges to detect:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - New dependencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Removed dependencies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For existing edges, detect significant metric changes:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Error rate increased by more than X%</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Call volume changed by more than Y%</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Latency percentiles changed significantly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return structured TopologyChanges object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Concurrent Map Access</strong>: Use <code>sync.RWMutex</code> for the <code>pendingEdges</code> map in the aggregator, or consider <code>sync.Map</code> if you have a write-once, read-many pattern.</p>\n</li>\n<li><p><strong>Time Window Calculations</strong>: Use <code>time.Time.Truncate()</code> for clean window boundaries: <code>windowStart := timestamp.Truncate(5 * time.Minute)</code>.</p>\n</li>\n<li><p><strong>Efficient Edge Lookups</strong>: Create composite keys for the pending edges map using string concatenation with a delimiter: <code>key := fmt.Sprintf(&quot;%s|%s|%d&quot;, caller, callee, windowStart.Unix())</code>.</p>\n</li>\n<li><p><strong>Background Flushing</strong>: Use a <code>time.Ticker</code> in a goroutine for periodic window flushes:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(flushInterval)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               aggregator.</span><span style=\"color:#B392F0\">FlushWindow</span><span style=\"color:#E1E4E8\">(ctx, currentWindow)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }()</span></span></code></pre></div>\n\n<ol start=\"5\">\n<li><p><strong>Graph Algorithms</strong>: For cycle detection, implement depth-first search with coloring (white/gray/black nodes) to detect back edges efficiently.</p>\n</li>\n<li><p><strong>Memory Management</strong>: Use pointers in slices for edges and nodes to avoid large data copies when building graphs.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>Verification Steps:</strong></p>\n<ol>\n<li><strong>Start the system</strong>: Run the trace collector (from Milestone 1) and the service map aggregator.</li>\n<li><strong>Generate traffic</strong>: Use the provided test harness to simulate calls between 3-5 mock services.</li>\n<li><strong>Check edge extraction</strong>: Query the service map API after 1-2 minutes, you should see:<ul>\n<li>Nodes for each mock service</li>\n<li>Directed edges showing which service calls which</li>\n<li>Basic metrics (call count) on each edge</li>\n</ul>\n</li>\n<li><strong>Verify real-time updates</strong>: Add a new mock service that calls an existing one, wait for the aggregation window (e.g., 1 minute), and confirm the graph updates.</li>\n<li><strong>Test error visualization</strong>: Configure one mock service to return errors 20% of the time, verify the corresponding edge turns yellow/red in the visualization.</li>\n</ol>\n<p><strong>Expected API endpoints:</strong></p>\n<ul>\n<li><code>GET /api/servicemap/current</code> - Returns current service graph as JSON</li>\n<li><code>GET /api/servicemap/history?service=A&amp;hours=24</code> - Returns historical edges for service A</li>\n<li><code>GET /api/servicemap/changes?since=2024-01-01T00:00:00Z</code> - Returns topology changes since timestamp</li>\n</ul>\n<p><strong>Signs of problems:</strong></p>\n<ul>\n<li><strong>No edges appear</strong>: Check that spans have proper parent-child relationships and <code>ServiceName</code> is populated</li>\n<li><strong>High memory usage</strong>: The pending edges map might not be getting flushed; check the flush timer</li>\n<li><strong>Stale data</strong>: The aggregation window might be too long; reduce from default 5 minutes to 1 minute for testing</li>\n<li><strong>Missing services</strong>: Low-volume services might be filtered out; adjust the minimum call threshold</li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Service map shows no edges</strong></td>\n<td>Spans missing parent-child links or <code>ServiceName</code> fields</td>\n<td>Check raw span data in storage; verify <code>ParentSpanID</code> is set and points to valid span</td>\n<td>Ensure SDK (Milestone 5) properly sets parent-child relationships and service names</td>\n</tr>\n<tr>\n<td><strong>Edges appear/disappear randomly</strong></td>\n<td>Aggregation window too short or sampling dropping traces</td>\n<td>Check if total calls per edge are very low (&lt; 10 per window)</td>\n<td>Increase aggregation window size or adjust sampling to keep more traces</td>\n</tr>\n<tr>\n<td><strong>High memory usage in aggregator</strong></td>\n<td>Too many pending edges or window not flushing</td>\n<td>Monitor <code>len(pendingEdges)</code>; check if flush goroutine is running</td>\n<td>Implement edge eviction for old windows; ensure flush timer is working</td>\n</tr>\n<tr>\n<td><strong>Cycles detected in healthy system</strong></td>\n<td>Callback patterns misidentified as cycles</td>\n<td>Examine the specific edges forming the cycle; check if calls are within same trace</td>\n<td>Implement time-bound cycle detection or tag callback patterns in spans</td>\n</tr>\n<tr>\n<td><strong>Visualization overloaded with edges</strong></td>\n<td>Operation-level granularity instead of service-level</td>\n<td>Count distinct (caller, callee, operation) tuples</td>\n<td>Aggregate at service level only; provide operation breakdown on click</td>\n</tr>\n<tr>\n<td><strong>Service map doesn&#39;t update in real-time</strong></td>\n<td>Processing pipeline too slow or batched</td>\n<td>Measure latency from span arrival to edge appearance in API</td>\n<td>Optimize parent span lookup; consider async processing; reduce batch sizes</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-component-design-trace-sampling-milestone-3\">7. Component Design: Trace Sampling (Milestone 3)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 3: Trace Sampling, which designs the intelligent filtering mechanism to reduce storage costs while preserving valuable traces for debugging and analysis.</p>\n</blockquote>\n<h3 id=\"mental-model-the-library-archivist\">Mental Model: The Library Archivist</h3>\n<p>Imagine you&#39;re an archivist in a vast library receiving thousands of books every hour, but your storage shelves have limited capacity. You cannot possibly keep every book that arrives, yet you must ensure that:</p>\n<ol>\n<li><strong>Rare and unique works</strong> are preserved (error traces, anomalies)</li>\n<li><strong>Representative samples</strong> of popular genres are kept (normal traffic patterns)</li>\n<li><strong>Important historical records</strong> are maintained (high-latency operations, critical paths)</li>\n<li><strong>The collection remains useful</strong> for researchers (debuggers, SREs) to understand the library&#39;s contents</li>\n</ol>\n<p>This is exactly the challenge of <strong>trace sampling</strong> in a high-volume APM system. Every request through your distributed system produces a trace (a &quot;book&quot;), but storing all traces would require impractical amounts of storage. The sampling subsystem acts as the intelligent archivist, making real-time decisions about which traces to preserve based on configurable policies, while ensuring that the retained traces form a statistically useful dataset for debugging performance issues and understanding system behavior.</p>\n<p>The archivist faces two critical decisions:</p>\n<ul>\n<li><strong>Immediate filtering (head-based)</strong>: As books arrive at the loading dock, quickly decide which ones to even bring inside based on cover information (trace ID, service name).</li>\n<li><strong>Retrospective evaluation (tail-based)</strong>: After examining a book&#39;s contents (completed trace), decide if it&#39;s valuable enough to override an earlier rejection.</li>\n</ul>\n<h3 id=\"head-based-vs-tail-based-sampling\">Head-Based vs. Tail-Based Sampling</h3>\n<p>Sampling strategies differ fundamentally in <strong>when</strong> the sampling decision is made relative to when the trace completes. Each approach has distinct trade-offs that make it suitable for different parts of the pipeline.</p>\n<h4 id=\"head-based-sampling-the-first-impression\">Head-Based Sampling: The First Impression</h4>\n<p><strong>Head-based sampling</strong> makes its keep/drop decision <strong>at the very beginning of a trace</strong>, when the root span is first created and before any downstream spans are generated. This decision is made locally by the SDK/agent when it starts tracing a request.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> Head-based sampling is like deciding whether to film a documentary based on the title alone—you save resources by not filming at all, but you might miss incredible footage that only reveals itself later.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Decision Point</strong></td>\n<td>At trace creation (when root span starts)</td>\n</tr>\n<tr>\n<td><strong>Information Available</strong></td>\n<td>Only initial context: trace ID, service name, operation name, possibly sampling configuration</td>\n</tr>\n<tr>\n<td><strong>Decision Scope</strong></td>\n<td>Applies to the entire trace—once dropped, no spans are collected</td>\n</tr>\n<tr>\n<td><strong>Performance Impact</strong></td>\n<td>Minimal overhead on downstream services (no context propagation for dropped traces)</td>\n</tr>\n<tr>\n<td><strong>Storage Savings</strong></td>\n<td>Maximum possible reduction (entire traces never enter the system)</td>\n</tr>\n</tbody></table>\n<p>The decision algorithm for head-based sampling typically uses <strong>consistent hashing</strong> on the trace ID to ensure all participants make the same deterministic decision:</p>\n<ol>\n<li>Hash the trace ID to a value between 0 and 1 (e.g., using MurmurHash3)</li>\n<li>Compare against configured sampling probability for the service/operation</li>\n<li>If hash ≤ probability, keep the trace; otherwise, drop it</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">math</span><pre class=\"arch-pre shiki-highlighted\"><code>decision = hash(trace\\_id) ≤ sampling\\_probability(service, operation)</code></pre></div>\n\n<p>This approach ensures <strong>consistency</strong>—all spans for the same trace get the same decision, avoiding partial traces. The <code>SamplingConfig</code> structure supports this with both global (<code>Probability</code>) and per-service (<code>PerService</code>) rates.</p>\n<h4 id=\"tail-based-sampling-the-retrospective-review\">Tail-Based Sampling: The Retrospective Review</h4>\n<p><strong>Tail-based sampling</strong> evaluates traces <strong>after they complete</strong> (or after a significant portion has been collected). This allows decisions based on complete information about the trace&#39;s characteristics: duration, error status, specific operations performed, etc.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> Tail-based sampling is like a film editor reviewing all footage shot during the day and deciding which clips to keep for the final documentary—more resource-intensive but ensures you don&#39;t miss critical scenes.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Decision Point</strong></td>\n<td>After trace completion (or after a timeout)</td>\n</tr>\n<tr>\n<td><strong>Information Available</strong></td>\n<td>Complete trace data: all spans, durations, errors, attributes</td>\n</tr>\n<tr>\n<td><strong>Decision Scope</strong></td>\n<td>Can override head-based decisions to keep interesting traces</td>\n</tr>\n<tr>\n<td><strong>Performance Impact</strong></td>\n<td>Higher resource usage (collect all spans first, then evaluate)</td>\n</tr>\n<tr>\n<td><strong>Storage Savings</strong></td>\n<td>Selective—keeps only traces matching defined criteria</td>\n</tr>\n</tbody></table>\n<p>Tail-based sampling operates as a <strong>second-chance mechanism</strong>:</p>\n<ol>\n<li>All spans for a trace are collected (potentially after head-based sampling)</li>\n<li>When the trace completes or times out, evaluate against criteria</li>\n<li>If criteria match, ensure all spans are persisted; otherwise, discard</li>\n</ol>\n<p><img src=\"/api/project/apm-system/architecture-doc/asset?path=diagrams%2Fsampling-decision-flow.svg\" alt=\"Flowchart: Head-Based and Tail-Based Sampling Decisions\"></p>\n<h4 id=\"comparison-table-when-to-use-each-strategy\">Comparison Table: When to Use Each Strategy</h4>\n<table>\n<thead>\n<tr>\n<th>Strategy</th>\n<th>Best For</th>\n<th>Not Suitable For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Head-Based</strong></td>\n<td>High-volume production traffic, cost reduction, predictable sampling rates</td>\n<td>Debugging rare errors, investigating latency spikes, compliance/audit trails</td>\n</tr>\n<tr>\n<td><strong>Tail-Based</strong></td>\n<td>Error investigation, performance debugging, compliance (keep all errors)</td>\n<td>Extremely high-volume systems without sufficient buffering capacity</td>\n</tr>\n<tr>\n<td><strong>Combined Approach</strong></td>\n<td>Most production systems: head-based for volume reduction + tail-based for error capture</td>\n<td>Systems with extremely tight latency budgets at the edge</td>\n</tr>\n</tbody></table>\n<p>In our APM system, we implement a <strong>hybrid approach</strong>:</p>\n<ol>\n<li><strong>Head-based sampling</strong> at the SDK level reduces initial volume</li>\n<li><strong>Tail-based sampling</strong> at the collector level re-evaluates kept traces</li>\n<li><strong>Priority channels</strong> ensure error traces bypass sampling when detected early</li>\n</ol>\n<h3 id=\"adr-adaptive-sampling-algorithm\">ADR: Adaptive Sampling Algorithm</h3>\n<blockquote>\n<p><strong>Decision: Implement Feedback-Controlled Adaptive Sampling with Per-Service Budgets</strong></p>\n<ul>\n<li><strong>Context</strong>: Our APM system must handle variable traffic loads while maintaining consistent storage costs. Fixed sampling rates either waste storage during low traffic or lose valuable traces during peaks. We need an algorithm that adjusts sampling rates dynamically based on system load and trace value.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Fixed-Rate Sampling</strong>: Constant probability (e.g., 10%) for all services</li>\n<li><strong>Rate-Limiting Sampling</strong>: Maximum spans per second, discarding excess</li>\n<li><strong>Feedback-Controlled Adaptive Sampling</strong>: Dynamically adjusts rates based on ingestion load and trace characteristics</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement feedback-controlled adaptive sampling with separate control loops for head-based and tail-based decisions, using per-service budgets to prioritize critical services.</li>\n<li><strong>Rationale</strong>: <ul>\n<li>Fixed rates cannot adapt to traffic patterns, causing either data loss or storage bloat</li>\n<li>Rate limiting causes unfair distribution—high-traffic services dominate the quota</li>\n<li>Feedback control maintains system stability while maximizing trace value</li>\n<li>Per-service budgets ensure monitoring critical services even during load spikes</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Adds complexity with control loops and monitoring</li>\n<li>Requires careful tuning to avoid oscillation</li>\n<li>Provides optimal trace retention within storage constraints</li>\n<li>Enables priority sampling for business-critical services</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"options-comparison-table\">Options Comparison Table</h4>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fixed-Rate Sampling</strong></td>\n<td>Simple to implement, predictable behavior, easy to reason about</td>\n<td>Cannot adapt to traffic changes, either wastes storage or loses data during peaks, one-size-fits-all approach</td>\n<td>Too inflexible for production systems with variable loads</td>\n</tr>\n<tr>\n<td><strong>Rate-Limiting Sampling</strong></td>\n<td>Enforces hard storage limits, prevents system overload, simple conceptually</td>\n<td>Unfair to high-traffic services, discards based on arrival order not value, causes sampling bias</td>\n<td>Violates principle of preserving valuable traces—discards randomly during congestion</td>\n</tr>\n<tr>\n<td><strong>Feedback-Controlled Adaptive</strong></td>\n<td>Maximizes trace value within constraints, adapts to traffic patterns, prioritizes important services</td>\n<td>Complex implementation, requires tuning, potential for oscillation if poorly designed</td>\n<td><strong>CHOSEN</strong>: Provides optimal balance of value preservation and cost control</td>\n</tr>\n</tbody></table>\n<h4 id=\"adaptive-sampling-algorithm-design\">Adaptive Sampling Algorithm Design</h4>\n<p>Our adaptive sampling system uses <strong>separate but coordinated control loops</strong>:</p>\n<p><strong>1. Head-Based Adaptive Controller</strong></p>\n<ul>\n<li><strong>Input</strong>: Current ingestion rate, storage utilization, per-service budgets</li>\n<li><strong>Output</strong>: Adjusted sampling probabilities per service</li>\n<li><strong>Algorithm</strong>:<ol>\n<li>Measure ingestion rate over sliding window (e.g., 30 seconds)</li>\n<li>Compare against target ingestion capacity (configurable)</li>\n<li>If above target: reduce sampling probabilities proportionally across services, respecting minimum rates</li>\n<li>If below target: gradually increase probabilities toward configured maximums</li>\n<li>Apply emergency reduction if storage exceeds critical threshold</li>\n</ol>\n</li>\n</ul>\n<p><strong>2. Tail-Based Value Scorer</strong></p>\n<ul>\n<li><strong>Input</strong>: Completed trace characteristics (errors, latency, service mix)</li>\n<li><strong>Output</strong>: Priority score (0-100) indicating trace value</li>\n<li><strong>Scoring Factors</strong>:<ul>\n<li>Error presence: +50 points</li>\n<li>High latency ( &gt; p95 for service): +30 points  </li>\n<li>Contains specific operations (configurable): +20 points</li>\n<li>Rare service combinations: +10 points</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Keep trace if score &gt; threshold (configurable)</li>\n</ul>\n<p><strong>3. Per-Service Budget Allocator</strong></p>\n<ul>\n<li><strong>Input</strong>: Total ingestion capacity, service criticality weights</li>\n<li><strong>Output</strong>: Maximum spans per second per service</li>\n<li><strong>Algorithm</strong>:<ul>\n<li>Allocate base budget to all services (e.g., 100 spans/sec)</li>\n<li>Distribute remaining capacity proportionally to criticality weights</li>\n<li>Enforce minimum budget for all services (ensures some visibility)</li>\n<li>Reallocate unused budget from low-traffic to high-traffic services</li>\n</ul>\n</li>\n</ul>\n<p>The control loops run at different frequencies:</p>\n<ul>\n<li><strong>Head-based adjustments</strong>: Every 10 seconds (slow, stable changes)</li>\n<li><strong>Tail-based scoring</strong>: Per completed trace (immediate)</li>\n<li><strong>Budget reallocation</strong>: Every 60 seconds (infrequent redistribution)</li>\n</ul>\n<h4 id=\"state-machine-sampling-decision-process\">State Machine: Sampling Decision Process</h4>\n<p>The complete sampling workflow can be modeled as a state machine:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>New Trace</strong></td>\n<td>Root span created</td>\n<td><code>HeadDecisionPending</code></td>\n<td>Generate trace ID, extract service/operation</td>\n</tr>\n<tr>\n<td><code>HeadDecisionPending</code></td>\n<td>Hash computed</td>\n<td><code>SampledOut</code> or <code>SampledIn</code></td>\n<td>Apply head-based probability, set sampling flag in context</td>\n</tr>\n<tr>\n<td><code>SampledOut</code></td>\n<td>Span propagation</td>\n<td><code>Dropped</code></td>\n<td>Do not propagate context, discard locally</td>\n</tr>\n<tr>\n<td><code>SampledIn</code></td>\n<td>Span collection</td>\n<td><code>Collecting</code></td>\n<td>Propagate context, buffer spans at collector</td>\n</tr>\n<tr>\n<td><code>Collecting</code></td>\n<td>Trace timeout reached</td>\n<td><code>TailEvaluation</code></td>\n<td>Mark trace complete, trigger evaluation</td>\n</tr>\n<tr>\n<td><code>Collecting</code></td>\n<td>All spans received</td>\n<td><code>TailEvaluation</code></td>\n<td>Mark trace complete, trigger evaluation</td>\n</tr>\n<tr>\n<td><code>TailEvaluation</code></td>\n<td>Score calculated</td>\n<td><code>FinalKeep</code> or <code>FinalDrop</code></td>\n<td>Apply tail-based rules, persist or discard</td>\n</tr>\n<tr>\n<td><code>FinalKeep</code></td>\n<td>Storage acknowledgment</td>\n<td><code>Archived</code></td>\n<td>Write to persistent storage, update indexes</td>\n</tr>\n<tr>\n<td><code>FinalDrop</code></td>\n<td>Cleanup complete</td>\n<td><code>Discarded</code></td>\n<td>Release buffer memory, log statistics</td>\n</tr>\n</tbody></table>\n<h4 id=\"adaptive-rate-calculation-algorithm\">Adaptive Rate Calculation Algorithm</h4>\n<p>The core adaptive algorithm adjusts sampling probabilities:</p>\n<ol>\n<li><p><strong>Gather Metrics</strong> (every control interval):</p>\n<ul>\n<li>Current ingestion rate <code>I_current</code> (spans/sec)</li>\n<li>Target ingestion rate <code>I_target</code> (from configuration)</li>\n<li>Storage utilization <code>U</code> (0-100%)</li>\n<li>Per-service traffic rates <code>R_service[]</code></li>\n</ul>\n</li>\n<li><p><strong>Calculate Adjustment Factor</strong>:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">math</span><pre class=\"arch-pre shiki-highlighted\"><code>   error = I_current - I_target\n   adjustment = -Kp × error - Ki × integral(error) - Kd × derivative(error)</code></pre></div>\n<p>   Where Kp, Ki, Kd are PID controller tuning parameters.</p>\n<ol start=\"3\">\n<li><p><strong>Apply with Constraints</strong>:</p>\n<ul>\n<li>New probability = Current probability × (1 + adjustment)</li>\n<li>Clamp between service-specific min/max bounds</li>\n<li>Ensure total across services ≤ system capacity</li>\n</ul>\n</li>\n<li><p><strong>Emergency Overrides</strong>:</p>\n<ul>\n<li>If storage &gt; 90%: Apply global reduction multiplier (e.g., ×0.5)</li>\n<li>If storage &gt; 95%: Drop all non-error traces temporarily</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"common-pitfalls-in-sampling\">Common Pitfalls in Sampling</h3>\n<h4 id=\"-pitfall-1-sampling-bias-leading-to-misleading-statistics\">⚠️ <strong>Pitfall 1: Sampling Bias Leading to Misleading Statistics</strong></h4>\n<p><strong>Description</strong>: Applying uniform sampling rates across all services creates a biased dataset where high-traffic services are overrepresented, while low-traffic but critical services may have no traces at all.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Performance statistics (p95 latency, error rates) calculated from biased samples do not reflect true system behavior. Debugging issues in low-traffic services becomes impossible.</p>\n<p><strong>How to Fix</strong>:</p>\n<ul>\n<li>Implement <strong>per-service sampling rates</strong> with minimum guarantees</li>\n<li>Use <strong>stratified sampling</strong> to ensure representation from all service tiers</li>\n<li>Maintain <strong>separate statistics</strong> for sampled vs. unsampled populations</li>\n<li>Apply <strong>Neyman allocation</strong> for optimal distribution: allocate sample size proportional to traffic × variability</li>\n</ul>\n<h4 id=\"-pitfall-2-inconsistent-decisions-for-the-same-trace\">⚠️ <strong>Pitfall 2: Inconsistent Decisions for the Same Trace</strong></h4>\n<p><strong>Description</strong>: Different services or collectors making independent sampling decisions for spans belonging to the same trace, resulting in partial traces where some spans are stored while others are missing.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Partial traces are useless for debugging—you cannot reconstruct the request flow or identify bottlenecks. This violates the fundamental guarantee of distributed tracing.</p>\n<p><strong>How to Fix</strong>:</p>\n<ul>\n<li>Use <strong>deterministic hash-based sampling</strong> on trace ID</li>\n<li>Propagate sampling decision in trace context (W3C <code>sampled</code> flag)</li>\n<li>Implement <strong>centralized sampling coordination</strong> for tail-based decisions</li>\n<li>Add <strong>consistency checks</strong> during trace assembly to detect and discard partial traces</li>\n</ul>\n<h4 id=\"-pitfall-3-adaptive-algorithm-oscillation\">⚠️ <strong>Pitfall 3: Adaptive Algorithm Oscillation</strong></h4>\n<p><strong>Description</strong>: The adaptive control loop overcorrects, causing sampling rates to oscillate wildly between extremes—from 100% to 1% and back—creating unpredictable retention and making historical comparisons meaningless.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Oscillation reduces system stability, causes operational confusion, and makes capacity planning impossible. Engineers lose trust in the sampling system.</p>\n<p><strong>How to Fix</strong>:</p>\n<ul>\n<li>Implement <strong>hysteresis</strong> in control decisions (require sustained deviation before adjusting)</li>\n<li>Use <strong>moving averages</strong> with appropriate window sizes (not instantaneous measurements)</li>\n<li>Apply <strong>rate limiting</strong> to adjustments (maximum change per interval)</li>\n<li>Add <strong>dead bands</strong> where small deviations are ignored</li>\n<li>Monitor oscillation metrics and trigger alerts when detected</li>\n</ul>\n<h4 id=\"-pitfall-4-head-based-sampling-losing-all-error-traces\">⚠️ <strong>Pitfall 4: Head-Based Sampling Losing All Error Traces</strong></h4>\n<p><strong>Description</strong>: With pure head-based sampling, error traces are dropped at the same rate as successful ones, making post-mortem debugging impossible since no error traces are available for analysis.</p>\n<p><strong>Why It&#39;s Wrong</strong>: The primary value of tracing is debugging failures. Losing all error traces defeats the purpose of the APM system.</p>\n<p><strong>How to Fix</strong>:</p>\n<ul>\n<li>Implement <strong>tail-based sampling override</strong> specifically for error traces</li>\n<li>Use <strong>priority sampling</strong> where error traces bypass head-based decisions</li>\n<li>Apply <strong>multi-stage sampling</strong>: sample all errors, sample subset of successes</li>\n<li>Consider <strong>oversampling</strong> error-prone services or operations</li>\n</ul>\n<h4 id=\"-pitfall-5-clock-skew-causing-premature-trace-completion\">⚠️ <strong>Pitfall 5: Clock Skew Causing Premature Trace Completion</strong></h4>\n<p><strong>Description</strong>: In tail-based sampling, traces are considered &quot;complete&quot; after a timeout period. Clock skew between services causes incorrect timestamp ordering, leading to premature timeout and evaluation before all spans arrive.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Early trace evaluation leads to incorrect tail-based decisions—traces may be dropped even though interesting spans are still in transit.</p>\n<p><strong>How to Fix</strong>:</p>\n<ul>\n<li>Use <strong>watermark algorithm</strong> based on observed timestamps, not system clock</li>\n<li>Implement <strong>buffer extension</strong> when late spans are detected for a trace</li>\n<li>Apply <strong>NTP synchronization</strong> across collectors with monitoring</li>\n<li>Design <strong>forgiving timeout</strong> with grace period for clock skew</li>\n</ul>\n<h3 id=\"implementation-guidance-for-trace-sampling\">Implementation Guidance for Trace Sampling</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Recommendation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Hash Function</strong></td>\n<td>Go&#39;s <code>fnv</code> package (built-in)</td>\n<td><code>MurmurHash3</code> (github.com/spaolacci/murmur3)</td>\n<td>MurmurHash3 for better distribution</td>\n</tr>\n<tr>\n<td><strong>Probability Storage</strong></td>\n<td>In-memory map with mutex</td>\n<td>Redis for distributed coordination</td>\n<td>Start with in-memory, evolve to Redis</td>\n</tr>\n<tr>\n<td><strong>Adaptive Controller</strong></td>\n<td>Simple PID in Go</td>\n<td>Control theory library (github.com/yourbasic/pid)</td>\n<td>Custom PID for simplicity</td>\n</tr>\n<tr>\n<td><strong>Priority Queue</strong></td>\n<td>Slice with sorting</td>\n<td>Heap container (container/heap)</td>\n<td>Heap for O(log n) operations</td>\n</tr>\n<tr>\n<td><strong>Configuration</strong></td>\n<td>YAML file with viper</td>\n<td>Dynamic config service (etcd/Consul)</td>\n<td>YAML + viper initially</td>\n</tr>\n<tr>\n<td><strong>Metrics</strong></td>\n<td>Prometheus counters</td>\n<td>OpenTelemetry metrics + Prometheus</td>\n<td>Prometheus for simplicity</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>apm-tracing/\n├── cmd/\n│   ├── collector/           # Main collector binary\n│   └── sampling-controller/ # Optional separate adaptive controller\n├── internal/\n│   ├── sampling/\n│   │   ├── sampler.go       # Base sampler interface\n│   │   ├── head_sampler.go  # Head-based sampling\n│   │   ├── tail_sampler.go  # Tail-based sampling\n│   │   ├── adaptive.go      # Adaptive controller\n│   │   ├── priority.go      # Priority scoring\n│   │   ├── consistency.go   # Hash consistency utilities\n│   │   └── config.go        # Sampling configuration\n│   ├── models/              # Data models (SamplingConfig, etc.)\n│   └── storage/             # Storage layer\n└── configs/\n    └── sampling.yaml        # Sampling configuration file</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code-consistent-hash-sampler\">C. Infrastructure Starter Code: Consistent Hash Sampler</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/sampling/consistency.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> sampling</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">hash/fnv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ConsistentSampler ensures all participants make the same sampling decision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// for a given trace ID using deterministic hashing.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConsistentSampler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu       </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\trate     </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\"> // 0.0 to 1.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\thashFunc </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewConsistentSampler creates a sampler with the given rate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Uses FNV-1a hash by default for simplicity and good distribution.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewConsistentSampler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rate</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistentSampler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> rate </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> rate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\trate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#6A737D\"> // Default to 10%</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ConsistentSampler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\trate: rate,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\thashFunc: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\th </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fnv.</span><span style=\"color:#B392F0\">New64a</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\th.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(traceID))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">Sum64</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ShouldSample determines if a trace should be kept based on its ID.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns true if the trace should be sampled (kept).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistentSampler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ShouldSample</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ts.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> s.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> s.rate </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#6A737D\"> // Sample everything</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> s.rate </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#6A737D\"> // Sample nothing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hash to a float in [0, 1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\thash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">hashFunc</span><span style=\"color:#E1E4E8\">(traceID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tnormalized </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(hash) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">^uint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> normalized </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> s.rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetRate updates the sampling rate (thread-safe).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistentSampler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetRate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rate</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ts.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> s.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> rate </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\trate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t} </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> rate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\trate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ts.rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetRate returns the current sampling rate.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistentSampler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetRate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ts.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> s.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> s.rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/sampling/head_sampler.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> sampling</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">apm-tracing/internal/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HeadSampler implements head-based sampling with per-service rates.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HeadSampler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu            </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tglobalSampler </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistentSampler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tserviceRates  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistentSampler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdefaultRate   </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tstats         </span><span style=\"color:#B392F0\">HeadSamplerStats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HeadSamplerStats tracks sampling decisions for monitoring.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HeadSamplerStats</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTotalTraces     </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSampledTraces   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPerService      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ServiceStats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tLastReset       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServiceStats tracks per-service sampling statistics.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServiceStats</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTracesSeen    </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTracesSampled </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewHeadSampler creates a new head-based sampler with configuration.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewHeadSampler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SamplingConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HeadSampler</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"config cannot be nil\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsampler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">HeadSampler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tglobalSampler: </span><span style=\"color:#B392F0\">NewConsistentSampler</span><span style=\"color:#E1E4E8\">(config.Probability),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tserviceRates:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistentSampler</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tdefaultRate:   config.Probability,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tstats: </span><span style=\"color:#B392F0\">HeadSamplerStats</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tPerService: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ServiceStats</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tLastReset:  time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Initialize per-service samplers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> serviceName, rate </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> config.PerService {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> rate </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> rate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid rate for service </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, serviceName, rate)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tsampler.serviceRates[serviceName] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> NewConsistentSampler</span><span style=\"color:#E1E4E8\">(rate)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> sampler, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Decide makes a head-based sampling decision for a trace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This should be called when the root span is created.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HeadSampler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Decide</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">serviceName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Look up per-service sampler if configured</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: If no per-service sampler exists, use global sampler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Call ShouldSample on the appropriate sampler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Update statistics (thread-safe)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Return true if trace should be kept, false otherwise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use s.mu for thread safety when accessing serviceRates and stats</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdateRates dynamically adjusts sampling rates based on adaptive controller input.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HeadSampler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateRates</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">newGlobalRate</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">newServiceRates</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Validate all rates are in [0.0, 1.0]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Update global sampler rate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Update or create per-service samplers for each entry in newServiceRates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Log the rate changes for audit purposes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Reset statistics to track new rate effectiveness</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetStats returns current sampling statistics for monitoring.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HeadSampler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HeadSamplerStats</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Acquire read lock for thread safety</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Return copy of stats (not reference)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Include current rates in the returned stats</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#B392F0\"> HeadSamplerStats</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#6A737D\">// Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/sampling/tail_sampler.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> sampling</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">apm-tracing/internal/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TailSampler evaluates completed traces and overrides head decisions.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TailSampler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\trules      []</span><span style=\"color:#B392F0\">TailSamplingRule</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tevaluator  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceEvaluator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbuffer     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceBuffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttimeout    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tstats      </span><span style=\"color:#B392F0\">TailSamplerStats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TailSamplingRule defines criteria for tail-based sampling.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TailSamplingRule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCondition   </span><span style=\"color:#B392F0\">TraceCondition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPriority    </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\"> // Higher priority rules execute first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tKeepIfMatch </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TraceCondition evaluates whether a trace matches criteria.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TraceCondition</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tMatches</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">trace</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TraceEvaluator scores traces based on multiple criteria.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TraceEvaluator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\terrorWeight      </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tlatencyWeight    </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\toperationWeights </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tthreshold        </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewTailSampler creates a tail-based sampler with configured rules.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTailSampler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rules</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">TailSamplingRule</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TailSampler</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> timeout </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttimeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second </span><span style=\"color:#6A737D\">// Default timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsampler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TailSampler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\trules:   rules,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttimeout: timeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tevaluator: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">TraceEvaluator</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\terrorWeight:      </span><span style=\"color:#79B8FF\">50.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tlatencyWeight:    </span><span style=\"color:#79B8FF\">30.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\toperationWeights: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tthreshold:        </span><span style=\"color:#79B8FF\">60.0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Keep if score >= 60</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tstats: </span><span style=\"color:#B392F0\">TailSamplerStats</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tTotalEvaluated:   </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tHeadSampled:      </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tTailOverrides:    </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tPerRuleDecisions: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Sort rules by priority (descending)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO: Implement rule sorting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> sampler, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EvaluateTrace examines a completed trace for tail-based sampling.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns true if the trace should be kept (either head decision or tail override).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TailSampler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EvaluateTrace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">trace</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">headDecision</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Update statistics for head decision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Check if trace already marked for keeping by head sampler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: If head decision was false, evaluate against tail rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Apply rules in priority order until a rule matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: If any rule with KeepIfMatch=true matches, override to keep</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Also compute priority score using evaluator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: If score >= threshold, override to keep</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Update tail override statistics if decision changed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 9: Return final keep/drop decision</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> headDecision </span><span style=\"color:#6A737D\">// Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessCompletedTraces runs a goroutine to evaluate traces that have completed.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TailSampler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessCompletedTraces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">traceCh</span><span style=\"color:#F97583\"> &#x3C;-chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Start a loop that listens on traceCh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: For each trace, check if it's complete (all spans received or timeout)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Extract head decision from trace metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Call EvaluateTrace for final decision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: If final decision is keep, persist to storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: If final decision is drop, clean up buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Handle context cancellation gracefully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddTraceToBuffer stores a trace for later evaluation when it completes.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TailSampler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddTraceToBuffer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">spans</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Check if trace already exists in buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Add spans to existing trace buffer or create new</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Start timeout timer if this is the first span</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Check if trace is now complete (all expected spans received)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: If complete, move to evaluation queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><strong>Concurrency</strong>: Use <code>sync.RWMutex</code> for sampler statistics—multiple goroutines read stats, few update them.</li>\n<li><strong>Hashing</strong>: For production, use <code>github.com/spaolacci/murmur3</code> instead of FNV for better distribution.</li>\n<li><strong>Context Propagation</strong>: Pass <code>context.Context</code> through all sampling methods for cancellation and deadlines.</li>\n<li><strong>Metrics Export</strong>: Use Prometheus counters for sampling statistics:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   var</span><span style=\"color:#E1E4E8\"> sampledTraces </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prometheus.</span><span style=\"color:#B392F0\">NewCounterVec</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CounterOpts</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           Name: </span><span style=\"color:#9ECBFF\">\"sampler_traces_total\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           Help: </span><span style=\"color:#9ECBFF\">\"Total traces processed by sampler\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"service\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"decision\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   )</span></span></code></pre></div>\n<ol start=\"5\">\n<li><strong>Configuration Hot Reload</strong>: Use <code>fsnotify</code> to watch config file changes and reload sampling rates without restart.</li>\n<li><strong>Memory Management</strong>: For trace buffers, use <code>sync.Pool</code> for span slices to reduce GC pressure.</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the sampling subsystem:</p>\n<ol>\n<li><strong>Test Head-Based Sampling</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run unit tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/sampling</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestHeadSampler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected output: All tests pass, showing:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # - Consistent decisions for same trace ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # - Per-service rates work correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # - Statistics are tracked accurately</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Verify Tail-Based Override</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start collector with sampling enabled</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./cmd/collector</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> configs/sampling.yaml</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Send test traces with errors</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/v1/spans</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -d</span><span style=\"color:#9ECBFF\"> '{\"traceId\": \"err-123\", \"spans\": [{\"name\": \"errorOp\", \"status\": {\"code\": 2}}]}'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Check logs: Should see \"tail override\" for error trace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Even with 1% sampling rate, error trace should be kept</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Validate Adaptive Control</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Monitor sampling rate adjustments</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> http://localhost:9090/metrics</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> sampler_rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Send burst traffic (e.g., 10k spans in 1 second)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Observe: Sampling rate should decrease temporarily</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # After traffic normalizes, rate should return to configured level</span></span></code></pre></div>\n\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li><code>sampler_traces_total{decision=&quot;drop&quot;}</code> increasing during normal traffic (rate too low)</li>\n<li>Memory growing unbounded (trace buffer not evicting completed traces)</li>\n<li>Inconsistent trace assembly (spans missing from kept traces)</li>\n</ul>\n<p><strong>Debugging Steps</strong>:</p>\n<ol>\n<li>Check hash consistency: Same trace ID should always get same decision</li>\n<li>Verify context propagation: <code>sampled</code> flag should be passed through all services</li>\n<li>Monitor buffer sizes: Implement metrics for trace buffer occupancy</li>\n</ol>\n<h2 id=\"8-component-design-performance-analytics-amp-anomaly-detection-milestone-4\">8. Component Design: Performance Analytics &amp; Anomaly Detection (Milestone 4)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 4: Performance Analytics &amp; Anomaly Detection, which designs the analytics engine that computes performance percentiles, establishes historical baselines, and automatically flags anomalies in the APM Tracing System.</p>\n</blockquote>\n<p><img src=\"/api/project/apm-system/architecture-doc/asset?path=diagrams%2Fanalytics-sequence.svg\" alt=\"Performance Analytics and Alerting\"></p>\n<h3 id=\"mental-model-the-weather-forecaster-for-performance\">Mental Model: The Weather Forecaster for Performance</h3>\n<p>Imagine our distributed system is a vast, complex climate system. Individual service calls are like local weather events—some sunny and fast (low latency), others stormy and slow (high latency). The <strong>Performance Analytics &amp; Anomaly Detection</strong> component acts as our <strong>weather forecaster</strong>.</p>\n<p>A good weather forecaster doesn&#39;t just report today&#39;s temperature; they:</p>\n<ol>\n<li><strong>Know historical patterns</strong>: They understand that 85°F is normal for July but alarming for December.</li>\n<li><strong>Detect anomalies</strong>: They spot a sudden pressure drop indicating an approaching storm (a latency spike).</li>\n<li><strong>Provide probabilistic forecasts</strong>: They calculate there&#39;s a 90% chance of rain (a 90% likelihood this latency regression is real, not random noise).</li>\n<li><strong>Differentiate local vs. global phenomena</strong>: They know a thunderstorm in one valley doesn&#39;t mean the entire continent is experiencing bad weather (a problem in one service vs. system-wide degradation).</li>\n</ol>\n<p>Similarly, our analytics engine must:</p>\n<ul>\n<li><strong>Calculate what&#39;s &quot;normal&quot;</strong> by establishing baselines from historical data for each service and operation.</li>\n<li><strong>Detect &quot;unusual weather&quot;</strong> by comparing current performance against those baselines using statistical methods.</li>\n<li><strong>Focus on the right signals</strong> by distinguishing between expected variations (daily traffic patterns) and true anomalies (cascading failures).</li>\n<li><strong>Provide actionable insights</strong> by correlating anomalies with specific services, operations, and trace characteristics.</li>\n</ul>\n<p>This mental model helps us understand why simply calculating averages isn&#39;t enough—we need context-aware, statistical analysis that understands both the current state and historical patterns of our distributed system&#39;s &quot;weather.&quot;</p>\n<h3 id=\"algorithms-percentile-calculation-and-anomaly-detection\">Algorithms: Percentile Calculation and Anomaly Detection</h3>\n<p>The analytics engine performs two core computations: <strong>streaming percentile calculation</strong> for real-time performance metrics and <strong>statistical anomaly detection</strong> to flag deviations from normal patterns.</p>\n<h4 id=\"percentile-calculation-with-t-digest\">Percentile Calculation with T-Digest</h4>\n<p>Traditional percentile calculation requires storing all data points, which is impossible for high-volume tracing systems. We need an algorithm that can provide accurate percentile estimates from streaming data with bounded memory.</p>\n<p><strong>The t-digest algorithm</strong> solves this by clustering similar data points. Think of it as creating a histogram that automatically adjusts its bucket sizes: where data is dense (many similar latency values), buckets are narrow and precise; where data is sparse (outliers), buckets are wider but still capture the distribution tails accurately.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm Step</th>\n<th>Description</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. <strong>Initialize t-digest</strong></td>\n<td>Create an empty t-digest structure with a compression parameter (typically δ=100-1000).</td>\n<td>Sets up the data structure with desired accuracy/memory trade-off.</td>\n</tr>\n<tr>\n<td>2. <strong>Add value</strong></td>\n<td>For each incoming latency measurement, find the nearest centroid in the t-digest. If adding the value would exceed size limits for that centroid&#39;s weight, create a new centroid.</td>\n<td>Incorporates new data while maintaining the size bounds of the data structure.</td>\n</tr>\n<tr>\n<td>3. <strong>Merge centroids</strong></td>\n<td>Periodically merge adjacent centroids when their combined weight doesn&#39;t violate the size constraint based on the quantile they represent.</td>\n<td>Maintains the compression guarantee and prevents unbounded growth.</td>\n</tr>\n<tr>\n<td>4. <strong>Query percentile</strong></td>\n<td>To find the p-th percentile (e.g., p95), traverse the sorted centroids, summing weights until reaching p% of total weight, then interpolate between centroids.</td>\n<td>Provides accurate percentile estimates without storing all raw data.</td>\n</tr>\n</tbody></table>\n<p>The key advantage is <strong>bounded memory</strong>: a t-digest with compression parameter δ=100 uses roughly 100 centroids regardless of how many data points are added, making it ideal for long-running services that process millions of latency measurements.</p>\n<h4 id=\"anomaly-detection-with-statistical-methods\">Anomaly Detection with Statistical Methods</h4>\n<p>Once we have current percentiles, we need to determine if they represent anomalous behavior. We use multiple statistical techniques in combination:</p>\n<p><strong>1. Z-Score Method for Point Anomalies</strong>\nFor detecting sudden spikes or drops in metrics like error rate or latency.</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Description</th>\n<th>Mathematical Formulation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. <strong>Establish baseline</strong></td>\n<td>Calculate mean (μ) and standard deviation (σ) from historical data for the same time window (e.g., same hour last week).</td>\n<td>μ = Σx/n, σ = √(Σ(x-μ)²/(n-1))</td>\n</tr>\n<tr>\n<td>2. <strong>Compute z-score</strong></td>\n<td>For current value x, calculate how many standard deviations it is from the mean.</td>\n<td>z = (x - μ) / σ</td>\n</tr>\n<tr>\n<td>3. <strong>Flag anomaly</strong></td>\n<td>If</td>\n<td>z</td>\n</tr>\n</tbody></table>\n<p><strong>2. Moving Average with Control Limits for Trend Anomalies</strong>\nFor detecting sustained deviations rather than single-point spikes.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Description</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Simple Moving Average (SMA)</strong></td>\n<td>Average of last n values.</td>\n<td>Smooths short-term fluctuations to reveal trends.</td>\n</tr>\n<tr>\n<td><strong>Exponential Moving Average (EMA)</strong></td>\n<td>Gives more weight to recent values.</td>\n<td>More responsive to recent changes than SMA.</td>\n</tr>\n<tr>\n<td><strong>Upper/Lower Control Limits</strong></td>\n<td>Bands set at ±k standard deviations from the moving average.</td>\n<td>Defines the &quot;normal&quot; range for the metric.</td>\n</tr>\n<tr>\n<td><strong>Anomaly Condition</strong></td>\n<td>Current value outside control limits for m consecutive measurements.</td>\n<td>Reduces false positives from transient spikes.</td>\n</tr>\n</tbody></table>\n<p><strong>3. Seasonal-Trend Decomposition for Periodic Patterns</strong>\nFor systems with daily/weekly cycles (common in web applications).</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Description</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. <strong>Decompose time series</strong></td>\n<td>Separate historical data into: Trend (T), Seasonal (S), and Residual (R) components.</td>\n<td>xₜ = Tₜ + Sₜ + Rₜ</td>\n</tr>\n<tr>\n<td>2. <strong>Forecast expected value</strong></td>\n<td>Project trend forward and add appropriate seasonal component.</td>\n<td>ŷₜ = T̂ₜ + Ŝₜ</td>\n</tr>\n<tr>\n<td>3. <strong>Compare actual vs. forecast</strong></td>\n<td>Compute residual: eₜ = xₜ - ŷₜ.</td>\n<td>Difference between actual and expected.</td>\n</tr>\n<tr>\n<td>4. <strong>Flag large residuals</strong></td>\n<td>If</td>\n<td>eₜ</td>\n</tr>\n</tbody></table>\n<p>In practice, we combine these methods: z-score for immediate spike detection, moving average for sustained deviations, and seasonal decomposition to avoid false alarms during expected traffic patterns.</p>\n<h3 id=\"adr-time-series-storage-for-aggregates\">ADR: Time-Series Storage for Aggregates</h3>\n<blockquote>\n<p><strong>Decision: Use Dual-Layer Storage with Rolling In-Memory Windows and External Time-Series Database</strong></p>\n</blockquote>\n<p><strong>Context</strong>: The analytics engine needs to store two types of data: (1) real-time aggregates for the current time window (last 1-5 minutes) for immediate anomaly detection, and (2) historical aggregates (hours, days, weeks) for baseline calculation and trend analysis. We must choose storage strategies that balance performance, accuracy, and operational complexity.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Pure in-memory rolling windows</strong>: Store all aggregates in memory with fixed-size circular buffers.</li>\n<li><strong>Pure external time-series database</strong>: Write all aggregates to a dedicated TSDB (e.g., Prometheus, InfluxDB).</li>\n<li><strong>Hybrid approach</strong>: In-memory for recent data with periodic flush to external TSDB.</li>\n</ol>\n<p><strong>Decision</strong>: We chose <strong>Option 3: Hybrid approach</strong> with the following implementation:</p>\n<ul>\n<li><strong>Short-term (last 1 hour)</strong>: In-memory ring buffers per (service, operation) tuple, updated in real-time.</li>\n<li><strong>Long-term (beyond 1 hour)</strong>: Flushed to an external time-series database with configurable retention policies.</li>\n</ul>\n<p><strong>Rationale</strong>:</p>\n<ol>\n<li><strong>Latency requirements</strong>: Real-time anomaly detection needs sub-second query latency for the current window, which in-memory storage provides.</li>\n<li><strong>Historical analysis needs</strong>: Baseline calculation requires days/weeks of data, which exceeds practical memory limits.</li>\n<li><strong>Cost-effectiveness</strong>: External TSDBs optimize storage for time-series data (compression, downsampling) better than a custom solution.</li>\n<li><strong>Operational simplicity</strong>: Using a battle-tested TSDB for long-term storage reduces maintenance burden compared to building our own durable storage layer.</li>\n<li><strong>Data durability</strong>: In-memory data is volatile; periodic flushing to durable storage prevents data loss during restarts.</li>\n</ol>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li>✅ <strong>Low-latency real-time analytics</strong> for current time window.</li>\n<li>✅ <strong>Scalable historical storage</strong> using specialized TSDB.</li>\n<li>✅ <strong>Data persistence</strong> across service restarts.</li>\n<li>⚠️ <strong>Added complexity</strong> of two storage layers with synchronization logic.</li>\n<li>⚠️ <strong>Eventual consistency</strong> for historical queries (data appears after flush interval).</li>\n<li>⚠️ <strong>Dependency</strong> on external TSDB for long-term data.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Storage Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Pure in-memory rolling windows</strong></td>\n<td>- Extremely fast reads/writes<br>- No external dependencies<br>- Simple implementation</td>\n<td>- Limited history (memory-bound)<br>- Data lost on restart<br>- No downsampling for long retention</td>\n<td>❌</td>\n</tr>\n<tr>\n<td><strong>Pure external time-series database</strong></td>\n<td>- Unlimited history with retention policies<br>- Built-in downsampling/aggregation<br>- Durable storage</td>\n<td>- Higher latency for real-time queries<br>- External dependency failure modes<br>- Network overhead for every write</td>\n<td>❌</td>\n</tr>\n<tr>\n<td><strong>Hybrid approach (in-memory + TSDB)</strong></td>\n<td>- Fast real-time window queries<br>- Scalable historical storage<br>- Data persistence through flushing<br>- Best of both worlds</td>\n<td>- Two storage systems to maintain<br>- Synchronization complexity<br>- Slight delay for historical data availability</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-analytics\">Common Pitfalls in Analytics</h3>\n<p>⚠️ <strong>Pitfall 1: The &quot;Percentile of Percentiles&quot; Fallacy</strong></p>\n<ul>\n<li><strong>Description</strong>: Calculating percentiles across services incorrectly by taking the p95 of each service&#39;s p95 latencies. For example: Service A has p95=100ms, Service B has p95=200ms, so you report &quot;system p95 = 150ms&quot; (average) or &quot;system p95 = 200ms&quot; (max).</li>\n<li><strong>Why it&#39;s wrong</strong>: Percentiles are not linear or commutative. The true p95 latency for requests flowing through both services requires analyzing the end-to-end latency distribution, not combining service-level percentiles. This fallacy gives misleading performance summaries.</li>\n<li><strong>How to fix</strong>: Calculate percentiles from the <strong>root span durations</strong> (end-to-end request time) or use statistical methods that properly combine distributions (like convolution or Monte Carlo simulation if you have the raw data).</li>\n</ul>\n<p>⚠️ <strong>Pitfall 2: False Positives During Deployments and Traffic Changes</strong></p>\n<ul>\n<li><strong>Description</strong>: Anomaly detection systems triggering alerts during planned deployments, traffic spikes (flash sales), or daily cycles, even though these are expected events.</li>\n<li><strong>Why it&#39;s wrong</strong>: These false alarms cause &quot;alert fatigue&quot; where teams start ignoring alerts, potentially missing real issues. It wastes engineering time investigating expected behavior.</li>\n<li><strong>How to fix</strong>:<ol>\n<li><strong>Maintenance windows</strong>: Suppress alerts during known deployment periods.</li>\n<li><strong>Traffic-aware baselines</strong>: Use seasonal decomposition to account for daily/weekly patterns.</li>\n<li><strong>Change detection integration</strong>: Correlate anomalies with deployment markers in the CI/CD pipeline.</li>\n<li><strong>Adaptive thresholds</strong>: Increase sensitivity during stable periods, decrease during known volatile periods.</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall 3: Baseline Drift Over Time</strong></p>\n<ul>\n<li><strong>Description</strong>: As systems evolve (new features, optimizations, infrastructure changes), what was &quot;normal&quot; last month may no longer be relevant. Using stale baselines causes either missed anomalies (if performance degrades gradually) or false positives (if improvements make old baselines too pessimistic).</li>\n<li><strong>Why it&#39;s wrong</strong>: Static baselines become increasingly inaccurate over time, reducing the effectiveness of anomaly detection.</li>\n<li><strong>How to fix</strong>:<ol>\n<li><strong>Exponential decay</strong>: Weight recent data more heavily than old data when calculating baselines.</li>\n<li><strong>Change point detection</strong>: Automatically detect significant shifts in performance characteristics and reset baselines.</li>\n<li><strong>Manual baseline updates</strong>: Allow operators to mark periods as &quot;new normal&quot; after verified changes.</li>\n<li><strong>Multiple baseline windows</strong>: Compare against both recent (last 24h) and longer-term (last week) baselines to distinguish temporary shifts from permanent changes.</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall 4: Ignoring Statistical Power and Confidence</strong></p>\n<ul>\n<li><strong>Description</strong>: Making anomaly decisions with insufficient data. For example, flagging a &quot;500% increase in error rate&quot; when going from 1 error in 1000 requests to 5 errors in 1000 requests—statistically insignificant yet appears dramatic.</li>\n<li><strong>Why it&#39;s wrong</strong>: Small sample sizes lead to high variance and unreliable conclusions. A system might appear &quot;anomalous&quot; purely due to random chance with low traffic volumes.</li>\n<li><strong>How to fix</strong>:<ol>\n<li><strong>Minimum sample thresholds</strong>: Require at least N requests (e.g., 100) in a time window before evaluating anomalies.</li>\n<li><strong>Confidence intervals</strong>: Calculate and display the uncertainty around metrics (e.g., &quot;error rate: 0.5% ± 0.2% with 95% confidence&quot;).</li>\n<li><strong>Bayesian methods</strong>: Incorporate prior beliefs about expected rates, which naturally handles low-traffic services better than frequentist statistics.</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"implementation-guidance-for-analytics\">Implementation Guidance for Analytics</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Percentile Algorithm</strong></td>\n<td>Pre-implemented t-digest library (<code>github.com/caio/go-tdigest</code>)</td>\n<td>Custom t-digest implementation with optimizations for sparse data</td>\n</tr>\n<tr>\n<td><strong>Time-Series Storage</strong></td>\n<td>In-memory ring buffers + CSV file export</td>\n<td>In-memory buffers + Prometheus remote write protocol</td>\n</tr>\n<tr>\n<td><strong>Anomaly Detection</strong></td>\n<td>Z-score + moving average implemented manually</td>\n<td>Statistical libraries (<code>github.com/montanaflynn/stats</code>) + machine learning (Isolation Forest)</td>\n</tr>\n<tr>\n<td><strong>Alerting</strong></td>\n<td>Simple HTTP webhook notifications</td>\n<td>Dedicated alert manager (Prometheus Alertmanager integration)</td>\n</tr>\n<tr>\n<td><strong>Visualization</strong></td>\n<td>Built-in metrics endpoint returning JSON</td>\n<td>Grafana dashboard with pre-configured panels</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── cmd/\n│   └── analytics-engine/\n│       └── main.go                 # Analytics service entry point\n├── internal/\n│   ├── analytics/\n│   │   ├── aggregator.go           # Main percentile aggregator\n│   │   ├── tdigest.go              # T-digest wrapper/implementation\n│   │   ├── anomaly/\n│   │   │   ├── detector.go         # Anomaly detection coordinator\n│   │   │   ├── zscore.go           # Z-score detector\n│   │   │   ├── moving_avg.go       # Moving average detector\n│   │   │   └── seasonal.go         # Seasonal decomposition detector\n│   │   ├── storage/\n│   │   │   ├── interface.go        # Storage interface\n│   │   │   ├── memory_store.go     # In-memory ring buffer storage\n│   │   │   └── tsdb_client.go      # External TSDB client\n│   │   ├── baseline/\n│   │   │   ├── calculator.go       # Baseline calculation\n│   │   │   └── manager.go          # Baseline lifecycle management\n│   │   └── alert/\n│   │       ├── evaluator.go        # Alert condition evaluation\n│   │       └── notifier.go         # Alert notification dispatch\n│   └── models/                     # Shared data models\n│       └── analytics.go            # Analytics-specific types\n└── config/\n    └── analytics.yaml              # Analytics configuration</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete T-Digest Wrapper</strong> (ready to use):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/analytics/tdigest.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> analytics</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/caio/go-tdigest</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TDigestMetric maintains a t-digest for streaming percentile calculation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TDigestMetric</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    digest    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tdigest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TDigest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu        </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count     </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastReset </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewTDigestMetric creates a new metric with specified compression</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTDigestMetric</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">compression</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TDigestMetric</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    digest, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tdigest.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(tdigest.</span><span style=\"color:#B392F0\">Compression</span><span style=\"color:#E1E4E8\">(compression))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TDigestMetric</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        digest:    digest,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lastReset: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add adds a value to the distribution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TDigestMetric</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> t.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.digest.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Quantile returns the estimated value at the given quantile (0.0-1.0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TDigestMetric</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Quantile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">q</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> t.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> t.digest.</span><span style=\"color:#B392F0\">Quantile</span><span style=\"color:#E1E4E8\">(q)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Count returns the number of observations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TDigestMetric</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Count</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> t.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> t.count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reset clears the distribution and resets counters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TDigestMetric</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reset</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> t.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.digest.</span><span style=\"color:#B392F0\">Reset</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.lastReset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete In-Memory Time-Series Storage</strong> (ready to use):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/analytics/storage/memory_store.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> storage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">container/ring</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetricPoint represents a single data point in a time series</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricPoint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value     </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Labels    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // e.g., {\"service\": \"api\", \"operation\": \"GET /users\"}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MemoryStore implements in-memory ring buffer storage for recent metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MemoryStore</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffers   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ring</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Ring</span><span style=\"color:#6A737D\"> // key: metric+labels hash</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu        </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxPoints </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ttl       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewMemoryStore creates a new in-memory store with given capacity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMemoryStore</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">maxPoints</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttl</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryStore</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MemoryStore</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffers:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ring</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Ring</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxPoints: maxPoints,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ttl:       ttl,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Write adds a metric point to the appropriate ring buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">point</span><span style=\"color:#B392F0\"> MetricPoint</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> m.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    key </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.</span><span style=\"color:#B392F0\">hashKey</span><span style=\"color:#E1E4E8\">(point.Labels)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get or create ring buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.buffers[key]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ring.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(m.maxPoints)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m.buffers[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Advance and set value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer.Value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> point</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.buffers[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Read returns all points within the time range for given labels</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">labels</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">end</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">MetricPoint</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> m.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    key </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.</span><span style=\"color:#B392F0\">hashKey</span><span style=\"color:#E1E4E8\">(labels)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.buffers[key]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">MetricPoint</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> points []</span><span style=\"color:#B392F0\">MetricPoint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer.</span><span style=\"color:#B392F0\">Do</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        point </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> value.(</span><span style=\"color:#B392F0\">MetricPoint</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">point.Timestamp.</span><span style=\"color:#B392F0\">Before</span><span style=\"color:#E1E4E8\">(start) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">point.Timestamp.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            points </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(points, point)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> points, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// hashKey creates a simple string key from labels map</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">hashKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">labels</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Simple implementation - for production use a proper hash</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> k, v </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> labels {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        key </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> k </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \";\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cleanup removes expired buffers (call this periodically)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">cleanup</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> m.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cutoff </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">m.ttl)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> key, buffer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> m.buffers {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if buffer has recent data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        recent </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer.</span><span style=\"color:#B392F0\">Do</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            point </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> value.(</span><span style=\"color:#B392F0\">MetricPoint</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> point.Timestamp.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(cutoff) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                recent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">recent {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            delete</span><span style=\"color:#E1E4E8\">(m.buffers, key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Percentile Aggregator</strong> (learner implements TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/analytics/aggregator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> analytics</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-project/internal/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PercentileAggregator maintains t-digests for service/operation latency percentiles</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PercentileAggregator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // digests is a map of key(service+operation) -> TDigestMetric</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    digests </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TDigestMetric</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu      </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    window  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewPercentileAggregator creates a new aggregator with the given time window</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPercentileAggregator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">window</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PercentileAggregator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize the digests map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up a background goroutine to reset digests after each window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return the initialized aggregator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessSpan updates percentiles with data from a completed span</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PercentileAggregator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">span</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract service name and operation name from span</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create a unique key from service+operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Get or create a TDigestMetric for this key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add the span's duration (converted to milliseconds) to the digest</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update any internal statistics counters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return nil on success or appropriate error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetPercentiles returns current percentile values for a service/operation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PercentileAggregator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetPercentiles</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">service</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">p50</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">p95</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">p99</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Construct the lookup key from service+operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Acquire read lock on the digests map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Find the TDigestMetric for this key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If not found, return zero values with appropriate error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Query the digest for 0.5, 0.95, and 0.99 quantiles</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Convert the float64 results back to time.Duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return the three percentile values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResetWindow clears all digests and starts a new aggregation window</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PercentileAggregator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ResetWindow</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire write lock on digests map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each TDigestMetric in the map, call Reset()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Optionally, log statistics about the completed window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Release lock</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Anomaly Detector</strong> (learner implements TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/analytics/anomaly/detector.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> anomaly</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Detector evaluates metrics against baselines to detect anomalies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Detector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baselineCalc </span><span style=\"color:#B392F0\">BaselineCalculator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    methods      []</span><span style=\"color:#B392F0\">DetectionMethod</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    thresholds   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DetectionMethod is an interface for different anomaly detection algorithms</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DetectionMethod</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Detect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">current</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">historical</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Name</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDetector creates a new anomaly detector with configured methods</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDetector</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">baselineCalc</span><span style=\"color:#B392F0\"> BaselineCalculator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Detector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize with provided baseline calculator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up default detection methods (z-score, moving average)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set default thresholds for each method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return initialized detector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CheckMetric evaluates a current metric value for anomalies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Detector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckMetric</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">metricName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">labels</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">currentValue</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">AnomalyResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Retrieve historical values for this metric+labels from storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If insufficient historical data, return empty result (no decision)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each detection method in d.methods:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   a. Call Detect() with current value and historical values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   b. If detection returns true, create AnomalyResult record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Aggregate results from all methods (e.g., majority vote)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return slice of anomaly results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AnomalyResult represents a single anomaly detection outcome</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AnomalyResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metric      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Labels      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value       </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expected    </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\"> // baseline value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Confidence  </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\"> // 0.0-1.0 confidence in detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Method      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // which detection method flagged it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Severity    </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // \"warning\", \"critical\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BaselineCalculator computes expected values from historical data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BaselineCalculator</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Calculate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">metricName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">labels</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">t</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Go Concurrency Patterns</strong>: Use <code>sync.RWMutex</code> for the percentile aggregator&#39;s digests map since reads (percentile queries) are more frequent than writes (span processing).</p>\n</li>\n<li><p><strong>Time Handling</strong>: Use <code>time.Duration</code> consistently for all latency values. Convert to <code>float64</code> milliseconds for t-digest storage: <code>ms := float64(span.Duration.Milliseconds())</code>.</p>\n</li>\n<li><p><strong>Context Propagation</strong>: Pass <code>context.Context</code> through all method calls to enable proper cancellation and timeout handling, especially for TSDB queries.</p>\n</li>\n<li><p><strong>Error Wrapping</strong>: Use <code>fmt.Errorf</code> with <code>%w</code> to wrap errors: <code>return fmt.Errorf(&quot;failed to query baseline: %w&quot;, err)</code>.</p>\n</li>\n<li><p><strong>Efficient Map Keys</strong>: For the <code>digests</code> map key, use a precomputed string: <code>key := fmt.Sprintf(&quot;%s:%s&quot;, service, operation)</code> or use a struct key with custom hash function for better performance.</p>\n</li>\n<li><p><strong>Background Goroutines</strong>: Use <code>time.Ticker</code> for periodic tasks like window resetting:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(p.window)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   for</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> ticker.C {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       p.</span><span style=\"color:#B392F0\">ResetWindow</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the Performance Analytics component, verify functionality with these steps:</p>\n<ol>\n<li><strong>Start the analytics engine</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/analytics-engine/main.go</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/analytics.yaml</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Send test spans with varying latencies</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Use a test script to send 1000 spans with latencies following normal distribution</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./scripts/send_test_spans.go</span><span style=\"color:#79B8FF\"> --count</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#79B8FF\"> --mean-latency</span><span style=\"color:#9ECBFF\"> 100ms</span><span style=\"color:#79B8FF\"> --std-dev</span><span style=\"color:#9ECBFF\"> 20ms</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Query percentiles via API</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> \"http://localhost:8081/analytics/percentiles?service=api&#x26;operation=GET%2Fusers\"</span></span></code></pre></div>\n<p>   <strong>Expected output</strong> (example):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     \"service\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"api\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     \"operation\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"GET /users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     \"p50\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"98ms\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     \"p95\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"142ms\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     \"p99\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"165ms\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     \"sample_count\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     \"window_start\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2023-10-01T10:00:00Z\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     \"window_end\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2023-10-01T10:05:00Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Trigger an anomaly detection</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Send spans with suddenly high latency</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./scripts/send_test_spans.go</span><span style=\"color:#79B8FF\"> --count</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#79B8FF\"> --mean-latency</span><span style=\"color:#9ECBFF\"> 500ms</span><span style=\"color:#79B8FF\"> --std-dev</span><span style=\"color:#9ECBFF\"> 100ms</span></span></code></pre></div>\n<p>   Check logs for anomaly alerts:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   INFO anomaly detected: service=api operation=GET /users current=512ms expected=105ms z-score=4.2</code></pre></div>\n\n<ol start=\"5\">\n<li><strong>Verify baseline calculation</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> \"http://localhost:8081/analytics/baselines?service=api&#x26;operation=GET%2Fusers\"</span></span></code></pre></div>\n<p>   Should return historical percentiles for comparison.</p>\n<p><strong>Signs of issues</strong>:</p>\n<ul>\n<li>Percentiles stuck at 0: Likely span processing not working; check <code>ProcessSpan</code> implementation.</li>\n<li>Anomaly alerts never firing: Check detection thresholds and baseline calculation.</li>\n<li>Memory usage growing unbounded: Verify t-digest compression and ring buffer size limits.</li>\n<li>&quot;No historical data&quot; errors: Ensure time-series storage is properly flushing to persistent storage.</li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Percentiles don&#39;t match expected values</strong></td>\n<td>Incorrect t-digest compression parameter or insufficient data</td>\n<td>1. Check sample count in aggregator<br>2. Verify span durations are being added correctly<br>3. Test t-digest with known dataset</td>\n<td>Adjust compression parameter (higher = more accurate), ensure minimum samples before trusting percentiles</td>\n</tr>\n<tr>\n<td><strong>Anomaly detector fires during normal traffic patterns</strong></td>\n<td>Baseline doesn&#39;t account for daily cycles</td>\n<td>1. Check if alerts cluster at same time daily<br>2. Compare current time to historical same-hour data</td>\n<td>Implement seasonal decomposition or time-of-day aware baselines</td>\n</tr>\n<tr>\n<td><strong>High memory usage in analytics engine</strong></td>\n<td>Too many t-digest instances or large ring buffers</td>\n<td>1. Check number of unique service+operation combinations<br>2. Monitor buffer sizes<br>3. Profile heap usage</td>\n<td>Limit cardinality (e.g., ignore high-cardinality operation names), reduce buffer sizes, implement LRU eviction</td>\n</tr>\n<tr>\n<td><strong>&quot;No baseline data&quot; errors for valid services</strong></td>\n<td>Flushing to TSDB failing or retention too short</td>\n<td>1. Check TSDB connection logs<br>2. Verify data exists in TSDB for time ranges<br>3. Check flush interval configuration</td>\n<td>Fix TSDB connectivity, adjust retention policies, implement fallback to recent window if no history</td>\n</tr>\n<tr>\n<td><strong>Delayed anomaly detection (&gt;5 minutes)</strong></td>\n<td>Aggregation window too long or detection runs infrequently</td>\n<td>1. Check window duration configuration<br>2. Monitor detection cycle timing<br>3. Check for blocking operations in pipeline</td>\n<td>Reduce window size, run detection more frequently, pipeline spans for lower latency</td>\n</tr>\n<tr>\n<td><strong>False positives during deployments</strong></td>\n<td>Baseline includes pre-deployment performance</td>\n<td>1. Check if deployment timestamps correlate with alerts<br>2. Compare pre/post-deployment baselines</td>\n<td>Implement deployment markers, suppress alerts during known changes, use shorter baseline windows during volatile periods</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 5: APM SDK &amp; Auto-Instrumentation, which designs the client-side library that automatically instruments application code to generate and propagate traces.</p>\n</blockquote>\n<h2 id=\"9-component-design-apm-sdk-amp-auto-instrumentation-milestone-5\">9. Component Design: APM SDK &amp; Auto-Instrumentation (Milestone 5)</h2>\n<p>The <strong>APM SDK</strong> is the client-side library embedded within each monitored service. Its primary responsibility is to automatically instrument application code—intercepting HTTP requests, database queries, and framework operations—to create <strong>spans</strong> and propagate the <strong>trace context</strong> across service boundaries without requiring significant manual code changes from developers. This component transforms opaque, unobserved service interactions into a rich stream of structured telemetry data that feeds the entire APM system.</p>\n<h3 id=\"mental-model-the-invisible-flight-recorder\">Mental Model: The Invisible Flight Recorder</h3>\n<p>Imagine every application service as an aircraft equipped with a <strong>Flight Data Recorder (FDR)</strong>, commonly known as a &quot;black box.&quot; This recorder automatically and continuously monitors critical systems: engine performance, control surface positions, communication channels, and pilot inputs. It does not require the pilot to manually log each event; instead, it&#39;s always on, passively observing and recording. When investigating an incident or analyzing performance, engineers rely on this objective, detailed record of events to reconstruct exactly what happened.</p>\n<p>The APM SDK functions as this <strong>Invisible Flight Recorder</strong> for your software. It is embedded within the application process and automatically &quot;records&quot; the journey of each request (the &quot;flight&quot;) as it passes through various components (engines, controls). It captures:</p>\n<ul>\n<li><strong>Takeoff and Landing (Request Start/End):</strong> When a request enters and leaves a service.</li>\n<li><strong>Control Inputs (Business Logic):</strong> Key operations and decisions within the service.</li>\n<li><strong>Subsystem Interactions (Outgoing Calls):</strong> Calls to databases, external APIs, or message queues.</li>\n<li><strong>Environmental Conditions (Context):</strong> Metadata like user ID, deployment version, and hostname.</li>\n</ul>\n<p>Just as a flight recorder must be utterly reliable and add minimal weight to the aircraft, the SDK must be robust and have negligible performance overhead. It must also ensure that the recording (the <strong>trace context</strong>) is copied and carried forward whenever the aircraft (request) communicates with another vessel (service), creating a continuous, unbroken chain of evidence across the entire distributed system.</p>\n<h3 id=\"instrumentation-techniques-monkey-patching-and-middleware\">Instrumentation Techniques: Monkey Patching and Middleware</h3>\n<p>Automatic instrumentation works by intercepting normal application execution at strategic points. Two primary techniques are used, each suited to different layers of the stack.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Technique</th>\n<th align=\"left\">Application Layer</th>\n<th align=\"left\">How It Works</th>\n<th align=\"left\">Key Consideration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Middleware / Interceptors</strong></td>\n<td align=\"left\">HTTP Frameworks (Gin, Express), gRPC, Message Queues</td>\n<td align=\"left\">The SDK injects itself into the framework&#39;s request-handling pipeline. For incoming requests, it creates a root span, extracts the trace context from headers, and makes the context available to the application&#39;s handler. For outgoing requests, it wraps the HTTP client or gRPC stub to inject the current trace context into headers before sending.</td>\n<td align=\"left\">This is the <strong>preferred, non-invasive method</strong>. It leverages the framework&#39;s own extension points (e.g., Gin&#39;s <code>Use()</code> method, <code>http.RoundTripper</code> interface in Go).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Monkey Patching</strong></td>\n<td align=\"left\">Database Drivers, Low-level Networking Libraries</td>\n<td align=\"left\">The SDK temporarily replaces (or &quot;wraps&quot;) the original functions or methods of a library (e.g., <code>sql.DB.QueryContext</code>) with its own versions. The wrapper function creates a child span, records the operation (e.g., the SQL query), calls the original function, records the duration and any error, and then closes the span.</td>\n<td align=\"left\">This technique is more <strong>invasive and risky</strong>. It must be done carefully to avoid breaking the original library&#39;s behavior, causing memory leaks, or losing the context in asynchronous operations. It&#39;s often used for libraries that don&#39;t provide a native middleware interface.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Code Generation / Compile-time Weaving</strong></td>\n<td align=\"left\">All Layers (Advanced)</td>\n<td align=\"left\">Instead of modifying behavior at runtime, instrumentation code is injected at compile time. This can be done via code generation (e.g., creating wrapped clients) or through compiler plugins.</td>\n<td align=\"left\">This approach can offer <strong>optimal performance and safety</strong> as the instrumentation is &quot;baked in,&quot; but it requires more complex build tooling and is language/framework specific. For our initial SDK, we will focus on runtime techniques.</td>\n</tr>\n</tbody></table>\n<p>The SDK&#39;s internal architecture for a Go service might look like this, coordinating these techniques:\n<img src=\"/api/project/apm-system/architecture-doc/asset?path=diagrams%2Fsdk-instrumentation-comp.svg\" alt=\"Diagram Title\"></p>\n<p><strong>The Core Tracer:</strong> At the heart of the SDK is a singleton or factory-managed <strong>Tracer</strong> object. It is responsible for:</p>\n<ol>\n<li><strong>Span Creation:</strong> Generating new <code>Span</code> instances with unique IDs and linking them to a parent based on the current context.</li>\n<li><strong>Context Management:</strong> Maintaining a stack or bag of key-value pairs (the <code>Attributes</code>) and the current active span for the duration of a request.</li>\n<li><strong>Span Export:</strong> Batching completed spans and sending them asynchronously to the Collector via the configured transport (HTTP/gRPC).</li>\n</ol>\n<p><strong>The Instrumentation Process:</strong></p>\n<ol>\n<li><strong>HTTP Server (Incoming Request):</strong> A Gin middleware (<code>APMMiddleware</code>) is registered via <code>router.Use()</code>. For each request:<ol>\n<li>It extracts the W3C Trace Context headers (<code>traceparent</code>, <code>tracestate</code>).</li>\n<li>It calls <code>tracer.StartSpanFromContext(ctx, &quot;HTTP GET /api/users&quot;)</code> to create a server-side span. If headers are present, the span becomes a child of the remote parent; otherwise, it starts a new trace.</li>\n<li>It stores the new span in the Go <code>context.Context</code> and passes this context to the next handler.</li>\n<li>After the handler completes, the middleware records the HTTP status code as an attribute, sets the span status (error if 5xx), and calls <code>span.End()</code>.</li>\n</ol>\n</li>\n<li><strong>Database Query:</strong> The <code>database/sql</code> driver is wrapped via monkey patching at SDK initialization.<ol>\n<li>When the application calls <code>db.QueryContext(ctx, &quot;SELECT ...&quot;)</code>, the wrapped driver intercepts the call.</li>\n<li>It uses the <code>ctx</code> to find the current active trace and calls <code>tracer.StartSpanFromContext(ctx, &quot;sql.query&quot;)</code> to create a child span.</li>\n<li>It adds attributes: <code>db.system=&quot;postgresql&quot;</code>, <code>db.statement</code> (the sanitized query).</li>\n<li>It executes the original query, records the duration, adds an error attribute if the query failed, and ends the span.</li>\n</ol>\n</li>\n<li><strong>HTTP Client (Outgoing Request):</strong> The SDK wraps the default <code>http.Client.Transport</code>.<ol>\n<li>When the app makes an outgoing request via <code>http.Get</code>, the wrapped transport&#39;s <code>RoundTrip</code> method is called.</li>\n<li>It gets the current span context from the request&#39;s <code>context.Context</code>.</li>\n<li>It injects the trace context into the request headers (<code>traceparent</code>, <code>tracestate</code>).</li>\n<li>It creates a child &quot;http.client&quot; span, executes the request, records the duration and status, and ends the span.</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"adr-context-propagation-mechanism\">ADR: Context Propagation Mechanism</h3>\n<blockquote>\n<p><strong>Decision: Use Go&#39;s Native <code>context.Context</code> for In-Process Propagation and W3C Trace Context for Cross-Service Propagation</strong></p>\n<ul>\n<li><strong>Context:</strong> In a distributed trace, the <code>TraceID</code> and <code>ParentSpanID</code> must be carried from one span to its child, both within the same process (e.g., from an HTTP server span to a database span) and across process boundaries (e.g., from Service A&#39;s HTTP client span to Service B&#39;s HTTP server span). We need a mechanism that is idiomatic, efficient, and correct for concurrent Go code.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Explicit Parameter Passing:</strong> Require developers to manually pass a <code>Trace</code> or <code>Span</code> object through every function call. This is explicit but burdensome and breaks existing code.</li>\n<li><strong>Thread-Local Storage (TLS):</strong> Use Goroutine-local storage (simulated via maps keyed by goroutine ID). This is fragile because goroutines are multiplexed and a single request may be handled by multiple goroutines. Context can easily be lost.</li>\n<li><strong>Go&#39;s <code>context.Context</code>:</strong> Use the standard library&#39;s <code>context.Context</code> interface to store and retrieve the current span. This is the idiomatic pattern for request-scoped values in Go and is designed to work with cancellation and deadlines.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> We will use <strong>Go&#39;s <code>context.Context</code></strong> for propagation within a single service. For propagation across service boundaries (over HTTP/gRPC), we will use the <strong>W3C Trace Context</strong> standard headers (<code>traceparent</code>, <code>tracestate</code>).</li>\n<li><strong>Rationale:</strong> <code>context.Context</code> is the canonical way to pass request-scoped data in Go. It is used by virtually all major frameworks and libraries (Gin, gRPC, <code>database/sql</code>), making integration seamless. It is concurrency-safe when passed correctly. The W3C standard ensures interoperability with other tracing systems and languages, future-proofing our implementation.</li>\n<li><strong>Consequences:</strong><ul>\n<li><strong>Enables:</strong> Clean, framework-agnostic instrumentation. Developers can manually create spans in their business logic by calling <code>tracer.StartSpanFromContext(ctx, ...)</code>. The SDK automatically propagates context in instrumented HTTP/database calls.</li>\n<li><strong>Requires:</strong> Application code must accept and pass a <code>context.Context</code> through its call chain, which is already a best practice in modern Go. The SDK must provide utilities to extract and inject the trace context from/to a <code>context.Context</code>.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The following table summarizes the key differences between the considered options:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Viability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Explicit Parameter Passing</strong></td>\n<td align=\"left\">Utterly explicit, no magic. Easy to reason about.</td>\n<td align=\"left\">Extremely invasive API. Requires massive refactoring of existing code. Breaks third-party library compatibility.</td>\n<td align=\"left\">❌ Rejected</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Thread-Local Storage (Goroutine-local)</strong></td>\n<td align=\"left\">Conceptually simple for linear, non-concurrent code.</td>\n<td align=\"left\">Goroutines are not 1:1 with threads. Context is lost on any goroutine switch (e.g., using <code>go</code> keyword, <code>async</code>). Highly error-prone and anti-pattern in Go.</td>\n<td align=\"left\">❌ Rejected</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Go&#39;s <code>context.Context</code></strong></td>\n<td align=\"left\">Idiomatic and standard. Supported by all major libraries. Designed for request-scoped values and cancellation. Integrates perfectly with middleware patterns.</td>\n<td align=\"left\">Requires that the application uses <code>context.Context</code> (which is a best practice). Slight learning curve for developers unfamiliar with context.</td>\n<td align=\"left\">✅ <strong>Chosen</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-sdk-development\">Common Pitfalls in SDK Development</h3>\n<p>Building a reliable, low-overhead auto-instrumentation SDK is fraught with subtle challenges. Awareness of these pitfalls is crucial.</p>\n<p>⚠️ <strong>Pitfall 1: Performance Overhead from Excessive Allocation and Locking</strong></p>\n<ul>\n<li><strong>Description:</strong> Creating a span involves allocating several objects (<code>SpanID</code>, <code>TraceID</code>, <code>Attributes</code> map, <code>Events</code> slice). If done naively for every database query in a high-throughput service, the garbage collection pressure and locking within the tracer can become significant, effectively slowing down the application it&#39;s meant to observe.</li>\n<li><strong>Why It&#39;s Wrong:</strong> An APM tool should be observational, not impactful. High overhead makes developers reluctant to enable tracing in production, defeating its purpose.</li>\n<li><strong>How to Fix:</strong><ul>\n<li><strong>Object Pooling:</strong> Use <code>sync.Pool</code> to reuse <code>Span</code> and auxiliary objects, reducing allocations.</li>\n<li><strong>Asynchronous Export:</strong> Never block the application thread to send spans to the collector. Use a buffered channel and a dedicated exporter goroutine.</li>\n<li><strong>Sampling at the Source:</strong> Integrate with the head-based sampler. If a trace is not sampled, avoid creating any span objects or attributes for it entirely.</li>\n</ul>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall 2: Context Loss in Concurrent and Asynchronous Code</strong></p>\n<ul>\n<li><strong>Description:</strong> In Go, when you launch a new goroutine with <code>go myFunction()</code>, the new goroutine does not automatically inherit the <code>context.Context</code> (and thus the current span) from the parent goroutine. If <code>myFunction</code> makes a database call, it will appear as a new, rootless trace fragment, breaking the parent-child relationship.</li>\n<li><strong>Why It&#39;s Wrong:</strong> This destroys the continuity of the trace, making it impossible to understand the causal relationship between the initial request and the work done in the goroutine. Critical debugging context is lost.</li>\n<li><strong>How to Fix:</strong> The SDK must provide clear guidance and utilities. For example, provide a helper: <code>ctx := tracer.ContextWithSpan(context.Background(), currentSpan)</code> and instruct developers to pass this <code>ctx</code> to the new goroutine. For popular async frameworks or worker pools, the SDK can offer specific integrations that automatically propagate context.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 3: Unsafe Monkey Patching that Breaks Host Application</strong></p>\n<ul>\n<li><strong>Description:</strong> Replacing a library&#39;s function pointer globally can have unintended side effects: it can break other parts of the application that rely on the original function&#39;s behavior, cause deadlocks if the wrapper introduces synchronization, or fail if the patching is not done atomically or at the right time (e.g., after another library has already patched the same function).</li>\n<li><strong>Why It&#39;s Wrong:</strong> The SDK becomes a source of instability and weird bugs in the application, eroding trust.</li>\n<li><strong>How to Fix:</strong><ul>\n<li><strong>Prefer Public APIs:</strong> Always use official middleware/interceptor interfaces if available.</li>\n<li><strong>Patch Once, Lazily:</strong> Implement patching logic that is idempotent and thread-safe. Often, this is done in an <code>init()</code> function or a dedicated <code>Instrument()</code> function called at application startup.</li>\n<li><strong>Thorough Testing:</strong> Test the wrapped behavior in isolation and in integration with the original library to ensure functional equivalence.</li>\n</ul>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall 4: Leaking Sensitive Data in Spans</strong></p>\n<ul>\n<li><strong>Description:</strong> Automatically capturing all HTTP request parameters, headers, or full SQL statements can inadvertently record passwords, API keys, or personal data (PII) into the tracing system, creating a security and compliance risk.</li>\n<li><strong>Why It&#39;s Wrong:</strong> This violates data privacy principles and regulations (like GDPR). The trace data, which may be viewed by many engineers or stored in less secure systems, becomes a data leak vector.</li>\n<li><strong>How to Fix:</strong><ul>\n<li><strong>Sanitization:</strong> Provide built-in sanitizers for common data types. For SQL, use a parameter masking library to replace <code>?</code> placeholders with a placeholder. For HTTP, provide a configurable blocklist of headers (e.g., <code>Authorization</code>, <code>Cookie</code>) and query parameters (e.g., <code>password</code>) to omit.</li>\n<li><strong>Customization:</strong> Allow developers to define custom sanitization hooks for their application-specific sensitive fields.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"implementation-guidance-for-the-apm-sdk\">Implementation Guidance for the APM SDK</h3>\n<p>This guidance provides the foundational code and structure to implement the APM SDK in Go, focusing on the patterns for middleware, context propagation, and safe monkey patching.</p>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Starting Point)</th>\n<th align=\"left\">Advanced Option (Production-ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Tracer Core</strong></td>\n<td align=\"left\">In-memory span processing with a buffered channel exporter.</td>\n<td align=\"left\">Integrate with OpenTelemetry Go SDK as a provider, leveraging its battle-tested core, batching, and retry logic.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>HTTP Server Middleware</strong></td>\n<td align=\"left\">Custom middleware for the Gin framework.</td>\n<td align=\"left\">Generic <code>net/http</code> middleware that works with any compatible framework (Gin, Echo, Gorilla Mux).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>HTTP Client Wrapping</strong></td>\n<td align=\"left\">Wrap the default <code>http.DefaultTransport</code>.</td>\n<td align=\"left\">Implement a <code>http.RoundTripper</code> that can be set on any <code>http.Client</code>, supporting connection pooling and redirects.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Database Instrumentation</strong></td>\n<td align=\"left\">Wrap <code>database/sql</code> driver using <code>sql.Register</code>.</td>\n<td align=\"left\">Use the OpenTelemetry SQL driver wrapper (<code>go.opentelemetry.io/contrib/instrumentation/database/sql</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Context Propagation</strong></td>\n<td align=\"left\">Store current span in <code>context.Context</code> using a private key.</td>\n<td align=\"left\">Implement the OpenTelemetry <code>propagation.TextMapPropagator</code> interface for W3C Trace Context.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<p>The SDK should be organized as a separate Go module that applications can import.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>apm-sdk-go/                   # Root of the SDK module\n├── go.mod\n├── go.sum\n├── tracer/                   # Core tracing logic\n│   ├── tracer.go            # Main Tracer struct, Span creation\n│   ├── context.go           # Context propagation utilities (WithSpan, SpanFromContext)\n│   ├── exporter.go          # Interface and channel-based exporter to Collector\n│   └── config.go            # SDK configuration (service name, sampling rate, endpoint)\n├── instruments/             # Auto-instrumentation packages\n│   ├── http/               # HTTP instrumentation\n│   │   ├── server/         # Server-side middleware\n│   │   │   ├── gin.go      # Gin framework middleware\n│   │   │   └── middleware.go # Generic net/http middleware\n│   │   └── client/         # Client-side wrapper\n│   │       └── wrapper.go  # http.RoundTripper implementation\n│   ├── sql/                # Database instrumentation\n│   │   └── driver.go       # sql driver wrapper and registration\n│   └── grpc/               # gRPC interceptors (future)\n│       ├── client.go\n│       └── server.go\n├── propagation/            # Cross-service context propagation\n│   ├── w3c.go             # W3C Trace Context extract/inject\n│   └── propagator.go      # Propagator interface\n└── internal/              # Private utilities\n    ├── sanitize.go        # SQL/query sanitization\n    └── pool.go            # Object pools for Spans</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Here is a complete, ready-to-use implementation for the core context propagation utilities, which are a prerequisite for all instrumentation.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// File: tracer/context.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> tracer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> contextKey</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> activeSpanKey </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">contextKey</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContextWithSpan returns a new context derived from parentCtx that contains the given span.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This span becomes the \"active\" span for any span creation or instrumentation that uses this context.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ContextWithSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">parentCtx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">span</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithValue</span><span style=\"color:#E1E4E8\">(parentCtx, activeSpanKey, span)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SpanFromContext retrieves the active span from the given context.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It returns nil if no span is present in the context.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SpanFromContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> s, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ctx.</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">(activeSpanKey).(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">); ok {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// File: propagation/w3c.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> propagation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TRACE_ID_HEADER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"traceparent\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: SPAN_ID_HEADER is \"tracestate\" per naming conventions, but traceparent contains both trace and parent span ID.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExtractTraceContext reads the W3C Trace Context headers from a carrier (e.g., http.Request)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// and returns a context containing the remote span context.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ExtractTraceContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">carrier</span><span style=\"color:#B392F0\"> TextMapCarrier</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    traceParent </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> carrier.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(TRACE_ID_HEADER)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> traceParent </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ctx </span><span style=\"color:#6A737D\">// No incoming context, will start a new trace.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse traceParent format: version-traceId-parentSpanId-flags</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(traceParent, </span><span style=\"color:#9ECBFF\">\"-\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Malformed header, ignore.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ctx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    traceID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> parts[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parentSpanID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> parts[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Here you would create a SpanContext object and attach it to the context.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For simplicity, we return a context with a placeholder.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In a full implementation, you would call tracer.StartSpan with the extracted parent.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InjectTraceContext writes the current span's context from the given context into the carrier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// (e.g., http.Request headers) for propagation to the next service.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> InjectTraceContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">carrier</span><span style=\"color:#B392F0\"> TextMapCarrier</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    span </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tracer.</span><span style=\"color:#B392F0\">SpanFromContext</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> span </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Nothing to inject</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Format: version-traceId-parentSpanId-flags (flags sampled = 01)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For simplicity, we assume version 00 and sampled flag.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    traceParent </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"00-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-01\"</span><span style=\"color:#E1E4E8\">, span.TraceID, span.SpanID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    carrier.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(TRACE_ID_HEADER, traceParent)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TextMapCarrier is an interface for objects that contain string key-value pairs (e.g., http.Header, metadata.MD).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TextMapCarrier</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>Below is the skeleton for the core Tracer and key instrumentation components. The TODOs map directly to the algorithmic steps described in the prose.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// File: tracer/tracer.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> tracer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/hex</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Tracer is the main entry point for creating spans and managing the export pipeline.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Tracer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serviceName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exporter    </span><span style=\"color:#B392F0\">SpanExporter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sampler     </span><span style=\"color:#B392F0\">HeadSampler</span><span style=\"color:#6A737D\"> // Integrated head-based sampling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartSpanFromContext creates a new span as a child of the active span in the given context.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If no active span exists, it starts a new trace.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Tracer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartSpanFromContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if the trace is already sampled (head-based decision).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Get the traceID from the parent span if it exists, or generate a new one.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Call t.sampler.Decide(traceID, t.serviceName) to get the sampling decision.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If NOT sampled, return a \"no-op\" span that does nothing on End().</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate a unique SpanID (16 bytes random, hex encoded).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Determine parent relationship.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If parentSpan := SpanFromContext(ctx); parentSpan != nil, set this span's ParentSpanID and TraceID from parent.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Otherwise, generate a new TraceID and set ParentSpanID to empty (root span).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create a new Span struct with StartTime = time.Now().</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store this new span as the active span in a new context (using ContextWithSpan).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return the new context and the span.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Span represents an individual operation within a trace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// (Fields are defined per naming conventions; we add methods.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Span</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpanID       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TraceID      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentSpanID </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name         </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ServiceName  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duration     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Attributes   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Events       []</span><span style=\"color:#B392F0\">SpanEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status       </span><span style=\"color:#B392F0\">SpanStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// End finalizes the span, records its duration, and schedules it for export.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">End</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Calculate duration: time.Now() - s.StartTime.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If this span is a no-op (not sampled), do nothing and return.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send the completed span to the exporter's buffer (e.g., via a channel).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - The exporter should run in a separate goroutine to batch and send spans asynchronously.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// File: instruments/http/client/wrapper.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> http</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">apm-sdk-go/tracer</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">apm-sdk-go/propagation</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WrappedTransport implements http.RoundTripper and injects trace context.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WrappedTransport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Base </span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RoundTripper</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Tracer </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tracer</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Tracer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RoundTrip executes the HTTP request, creating a span and propagating context.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">wt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WrappedTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RoundTrip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Response</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start a child span for this outgoing request.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use wt.Tracer.StartSpanFromContext(req.Context(), \"http.client\").</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Add attributes: \"http.method\", \"http.url\", \"peer.hostname\".</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Inject the current trace context into the request headers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Call propagation.InjectTraceContext(ctx, propagation.HeaderCarrier(req.Header)).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Execute the underlying request using wt.Base.RoundTrip(req).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Record the result.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Add attribute \"http.status_code\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If the request failed or status >= 400, mark span status as error.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: End the span.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return the response and error.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> wt.Base.</span><span style=\"color:#B392F0\">RoundTrip</span><span style=\"color:#E1E4E8\">(req)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// File: instruments/sql/driver.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> sql</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql/driver</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">apm-sdk-go/tracer</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WrapDriver returns a new SQL driver that instruments all queries.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WrapDriver</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">baseDriver</span><span style=\"color:#B392F0\"> driver</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Driver</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">driverName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tracer</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">tracer</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Tracer</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create a wrapped driver struct that implements driver.Driver interface.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - It should embed or wrap the baseDriver.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Override the Open method to return a wrapped connection.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Register this wrapped driver with a new name (e.g., \"instrumented-mysql\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   using sql.Register.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The application then uses \"instrumented-mysql\" as the driver name in its DSN.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Context is Key:</strong> Always pass <code>context.Context</code> as the first parameter in your instrumentation functions. Use <code>context.TODO()</code> only as a placeholder during development.</li>\n<li><strong>Safe Concurrency with Channels:</strong> Use a buffered channel (<code>chan *Span</code>) for the exporter. A dedicated goroutine should read from this channel, batch spans, and send them to the collector. This prevents the instrumentation from blocking the application.</li>\n<li><strong>Use <code>sync.Pool</code> for Spans:</strong> Span creation is frequent. Pooling can drastically reduce allocation pressure.</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> spanPool </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Pool</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        New: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} { </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{Attributes: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">)} },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span></code></pre></div>\n<ul>\n<li><strong>Monkey Patching with <code>sql.Register</code>:</strong> The <code>database/sql</code> package is designed for wrapping. Implement the <code>driver.Driver</code> interface, wrap the original driver, and register your wrapper. This is safe and standard.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing the SDK and instrumenting a sample Go application (e.g., a simple Gin server that makes database calls and HTTP requests to another service), you should be able to verify:</p>\n<ol>\n<li><strong>Start the instrumented application:</strong> Run your app with the SDK initialized.</li>\n<li><strong>Generate traffic:</strong> Use <code>curl</code> or a load generator to send HTTP requests to your app.</li>\n<li><strong>Check Collector logs:</strong> Ensure spans are being received at the Collector&#39;s ingestion endpoint.</li>\n<li><strong>Verify Trace Completeness:</strong> Query the stored trace via the Collector&#39;s API. The trace should show:<ul>\n<li>A root span for the incoming HTTP request.</li>\n<li>A child span for the database query.</li>\n<li>A child span for any outgoing HTTP call, with the W3C headers present in the downstream service&#39;s logs.</li>\n<li>All spans should have the same <code>TraceID</code>.</li>\n</ul>\n</li>\n<li><strong>Performance Baseline:</strong> Measure the overhead. The 95th percentile (p95) latency of instrumented endpoints should not increase by more than 1-2% compared to non-instrumented code under load. Use a benchmark tool like <code>wrk</code> or <code>vegeta</code>.</li>\n</ol>\n<p><strong>Signs of Trouble:</strong></p>\n<ul>\n<li><strong>No spans in Collector:</strong> Check that the SDK&#39;s exporter is running and can connect to the Collector endpoint. Verify the sampling rate is not 0%.</li>\n<li><strong>Spans are not linked (different TraceIDs):</strong> Context propagation is broken. Verify the <code>SpanFromContext</code> and <code>ContextWithSpan</code> functions, and ensure the W3C headers are being injected and extracted correctly in HTTP clients/servers.</li>\n<li><strong>High memory or CPU usage in the app:</strong> The SDK&#39;s exporter might be blocking or the object pools might be ineffective. Profile the application using <code>go tool pprof</code>.</li>\n</ul>\n<hr>\n<h2 id=\"10-interactions-and-data-flow\">10. Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section synthesizes concepts from all five milestones (Trace Collection, Service Map, Trace Sampling, Performance Analytics, and APM SDK), illustrating how the entire system works together to transform raw instrumentation data into actionable insights. Understanding these interactions is critical for debugging the system itself and ensuring data flows correctly through the pipeline.</p>\n</blockquote>\n<p>At its core, the APM Tracing System is a <strong>data processing pipeline</strong> that transforms individual spans emitted by instrumented applications into comprehensive traces, service maps, and performance insights. This section traces the complete journey of a single user request—from the moment it enters the first microservice until its performance data appears in dashboards and alerts. Think of this journey as a <strong>documentary film crew following a character</strong> through a complex city: the SDKs are the cameras that capture footage (spans), the collector is the editing studio that assembles the raw clips, and the analytics components are the producers who extract meaning from the final film.</p>\n<h3 id=\"sequence-the-lifecycle-of-a-trace\">Sequence: The Lifecycle of a Trace</h3>\n<p>The lifecycle of a trace can be broken down into eight distinct phases, each involving multiple system components. The following diagram illustrates the high-level component interactions:</p>\n<p><img src=\"/api/project/apm-system/architecture-doc/asset?path=diagrams%2Fsys-comp-diagram.svg\" alt=\"APM System Component Diagram\"></p>\n<p><strong>Phase 1: Instrumentation and Span Creation</strong></p>\n<p>When a user request hits the first service (e.g., an API gateway), the auto-instrumented HTTP server middleware detects the incoming request and begins the trace lifecycle:</p>\n<ol>\n<li><p><strong>Context Extraction</strong>: The SDK&#39;s HTTP middleware examines the incoming request headers for W3C Trace Context headers (<code>traceparent</code> and <code>tracestate</code>). If present, it extracts the <code>TraceID</code>, <code>ParentSpanID</code>, and trace flags. If absent (indicating this is the root of a new trace), it generates a new 128-bit <code>TraceID</code> using a cryptographically secure random number generator.</p>\n</li>\n<li><p><strong>Root Span Creation</strong>: The middleware creates a new <code>Span</code> object with:</p>\n<ul>\n<li><code>SpanID</code>: A new 64-bit identifier for this span</li>\n<li><code>TraceID</code>: Either extracted from headers or newly generated</li>\n<li><code>ParentSpanID</code>: Empty for root spans, or the extracted parent span ID</li>\n<li><code>Name</code>: The HTTP route (e.g., <code>GET /api/orders</code>)</li>\n<li><code>ServiceName</code>: The name of the current service (from configuration)</li>\n<li><code>StartTime</code>: Current timestamp with nanosecond precision</li>\n<li><code>Attributes</code>: HTTP method, URL, user agent, and other request metadata</li>\n</ul>\n</li>\n<li><p><strong>Context Storage</strong>: The SDK stores this span in Go&#39;s <code>context.Context</code> using the private key <code>activeSpanKey</code>, making it accessible to all downstream function calls within the same request processing chain. This context is passed through the application&#39;s call stack.</p>\n</li>\n<li><p><strong>Head-Based Sampling Decision</strong>: Before adding substantial overhead, the SDK consults the configured <code>HeadSampler</code> by calling <code>Decide(ctx, traceID, serviceName)</code>. The sampler uses consistent hashing on the <code>TraceID</code> to make a deterministic decision:</p>\n<ul>\n<li>If the decision is <strong>DROP</strong>, the span is marked as <code>Sampled = false</code> and will only record minimal metadata (trace ID, span ID, sampling decision).</li>\n<li>If the decision is <strong>KEEP</strong>, the span proceeds with full instrumentation.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Phase 2: Context Propagation and Child Span Creation</strong></p>\n<p>As the request flows through the service&#39;s internal components and makes outbound calls, the SDK automatically creates child spans:</p>\n<ol>\n<li><p><strong>Database Call</strong>: When the service executes a SQL query through the instrumented database driver:</p>\n<ul>\n<li>The driver wrapper extracts the active span from the <code>context.Context</code></li>\n<li>Creates a child span with <code>ParentSpanID</code> set to the current span&#39;s ID</li>\n<li>Records the SQL operation type, table name, and sanitized query parameters</li>\n<li>Measures query execution time from request to response</li>\n<li>On completion, calls <code>End()</code> on the span, which records the duration</li>\n</ul>\n</li>\n<li><p><strong>Outbound HTTP Call</strong>: When the service calls another microservice:</p>\n<ul>\n<li>The instrumented HTTP client wrapper extracts the active span context</li>\n<li>Creates a child span for the outbound request</li>\n<li>Injects the trace context into HTTP headers using <code>InjectTraceContext()</code>, setting <code>traceparent</code> header with format <code>00-{TraceID}-{SpanID}-{TraceFlags}</code></li>\n<li>Sends the request and records response status code and timing</li>\n<li>On the receiving service, the server middleware extracts this context (as described in Phase 1), maintaining the parent-child relationship across service boundaries</li>\n</ul>\n</li>\n<li><p><strong>Async Operations</strong>: For asynchronous operations (goroutines, message queue processing), the SDK provides mechanisms to preserve trace context across async boundaries. In Go, this typically involves creating a new context from the parent span and passing it explicitly to the goroutine.</p>\n</li>\n</ol>\n<p><strong>Phase 3: Span Export to Collector</strong></p>\n<p>When a span completes (via <code>End()</code> method), the SDK&#39;s <code>SpanExporter</code> component queues it for export. The export process follows this sequence:</p>\n<ol>\n<li><p><strong>Batch Assembly</strong>: The exporter collects completed spans into batches (typically 100 spans or every 5 seconds, whichever comes first) to optimize network utilization.</p>\n</li>\n<li><p><strong>Transport Selection</strong>: The batch is serialized into OpenTelemetry Protocol (OTLP) format and sent via either HTTP/JSON or gRPC/protobuf to the Collector&#39;s ingestion endpoint. The diagram below shows this ingestion sequence:</p>\n</li>\n</ol>\n<p><img src=\"/api/project/apm-system/architecture-doc/asset?path=diagrams%2Fingestion-sequence.svg\" alt=\"Sequence: Trace Ingestion and Processing\"></p>\n<ol start=\"3\">\n<li><strong>Network Dispatch</strong>: The SDK transmits the batch asynchronously, with retry logic for transient network failures. If the Collector is unavailable, spans may be buffered in memory (with size limits) or written to local disk to prevent memory exhaustion.</li>\n</ol>\n<p><strong>Phase 4: Collector Ingestion and Buffering</strong></p>\n<p>Upon receiving a batch of spans, the Collector&#39;s ingestion pipeline processes each span through a multi-stage pipeline:</p>\n<ol>\n<li><p><strong>Request Handling</strong>: The Collector&#39;s HTTP or gRPC server receives the batch, validates authentication/authorization (if configured), and parses the OTLP payload into internal <code>Span</code> objects.</p>\n</li>\n<li><p><strong>Validation and Enrichment</strong>: Each span undergoes validation:</p>\n<ul>\n<li>Required fields (<code>TraceID</code>, <code>SpanID</code>) must be present and properly formatted</li>\n<li>Timestamps must be within acceptable bounds (not too far in future or past)</li>\n<li>Span duration must be non-negative</li>\n<li>Malformed spans are logged and discarded, but the batch continues processing</li>\n</ul>\n</li>\n<li><p><strong>Head Sampling Verification</strong>: The Collector verifies the head sampling decision by recalculating the hash-based decision. This ensures consistency between SDK and Collector (important for edge cases where SDK configuration differs). If the Collector&#39;s decision differs from the span&#39;s <code>Sampled</code> flag, it respects the SDK&#39;s decision but logs a warning.</p>\n</li>\n<li><p><strong>Buffer Management</strong>: The validated span is passed to the <code>BufferManager</code> via <code>AddSpan(ctx, span)</code>. The manager:</p>\n<ul>\n<li>Looks up the trace buffer for the span&#39;s <code>TraceID</code></li>\n<li>If no buffer exists, creates a new <code>TraceBuffer</code> with <code>firstSeen</code> set to current time</li>\n<li>Appends the span to the buffer&#39;s <code>spans</code> slice</li>\n<li>Updates the buffer&#39;s <code>lastSeen</code> timestamp</li>\n<li>Triggers eviction if total buffers exceed <code>maxSize</code> (oldest or least-recently-used traces are removed based on <code>evictionPolicy</code>)</li>\n</ul>\n</li>\n<li><p><strong>Write-Ahead Logging</strong>: For durability, the span is simultaneously appended to the <code>WALWriter</code> via <code>Append()</code>. The WAL record contains the span data plus metadata (arrival timestamp, source service). This allows recovery of in-flight traces after Collector restart.</p>\n</li>\n</ol>\n<p><strong>Phase 5: Trace Assembly and Storage</strong></p>\n<p>When certain conditions are met, traces are assembled from their constituent spans and persisted to storage:</p>\n<ol>\n<li><p><strong>Trace Completion Detection</strong>: The <code>TraceAssembler</code> periodically scans buffers to identify complete traces:</p>\n<ul>\n<li>A trace is considered <strong>potentially complete</strong> if <code>current_time - buffer.lastSeen &gt; maxTraceDuration</code> (e.g., 5 minutes)</li>\n<li>The assembler calls <code>IsTraceComplete()</code> which examines span parent-child relationships to check for missing spans</li>\n<li>For incomplete traces with expired timeout, the system proceeds anyway (handling late arrivals via the WAL recovery mechanism)</li>\n</ul>\n</li>\n<li><p><strong>Tail-Based Sampling Evaluation</strong>: For each potentially complete trace, the <code>TailSampler</code> evaluates whether to keep it:</p>\n<ul>\n<li>The trace is passed to <code>EvaluateTrace(ctx, trace, headDecision)</code></li>\n<li>Each <code>TailSamplingRule</code> is evaluated in priority order:<ul>\n<li>Rule 1: Keep all traces with error status codes (HTTP 5xx, span status = ERROR)</li>\n<li>Rule 2: Keep traces with latency above the 99th percentile for their service/operation</li>\n<li>Rule 3: Random sampling for &quot;normal&quot; traces to maintain baseline coverage</li>\n</ul>\n</li>\n<li>If any rule matches with <code>KeepIfMatch = true</code>, the trace is kept regardless of head decision</li>\n<li>Statistics are updated in <code>TailSamplerStats</code></li>\n</ul>\n</li>\n<li><p><strong>Trace Assembly</strong>: For traces selected for storage, <code>AssembleTrace(ctx, spans)</code> constructs a hierarchical <code>Trace</code> object:</p>\n<ul>\n<li>Sorts spans by <code>StartTime</code></li>\n<li>Reconstructs parent-child relationships using <code>ParentSpanID</code> references</li>\n<li>Calculates trace-level <code>StartTime</code> (earliest span start) and <code>EndTime</code> (latest span end)</li>\n<li>Validates temporal consistency (child spans must start after parent and end before parent)</li>\n</ul>\n</li>\n<li><p><strong>Storage Persistence</strong>: The assembled trace is written to the storage backend:</p>\n<ul>\n<li><strong>Primary Storage</strong>: All spans are written with <code>TraceID</code> as the primary index, enabling efficient retrieval of all spans for a trace</li>\n<li><strong>Secondary Indexes</strong>: Index entries are created for:<ul>\n<li><code>ServiceName</code> + <code>StartTime</code> range (for service-specific queries)</li>\n<li><code>StartTime</code> alone (for time-range queries)</li>\n<li><code>Attributes</code> (for specific tag queries, if supported)</li>\n</ul>\n</li>\n<li><strong>Aggregation Updates</strong>: The span data is simultaneously sent to the analytics pipeline</li>\n</ul>\n</li>\n</ol>\n<p><strong>Phase 6: Service Map Construction</strong></p>\n<p>As traces are assembled, service dependency information is extracted and aggregated:</p>\n<ol>\n<li><p><strong>Edge Extraction</strong>: For each inter-service span (where parent and child spans have different <code>ServiceName</code> values), the <code>EdgeAggregator</code> extracts a service call relationship:</p>\n<ul>\n<li><code>CallerService</code>: The service name from the parent span</li>\n<li><code>CalleeService</code>: The service name from the child span</li>\n<li>Latency, error status, and other metadata from the child span</li>\n</ul>\n</li>\n<li><p><strong>Windowed Aggregation</strong>: The aggregator&#39;s <code>ProcessSpan(ctx, span)</code> method updates in-memory aggregates for the current time window (e.g., 1 minute):</p>\n<ul>\n<li>Maintains <code>TotalCalls</code>, <code>ErrorCount</code>, latency histograms for each unique caller-callee pair</li>\n<li>Tracks a sample of <code>TraceID</code> values for each edge (for drill-down capability)</li>\n</ul>\n</li>\n<li><p><strong>Window Flush</strong>: At the end of each aggregation window, <code>FlushWindow(ctx, windowStart)</code>:</p>\n<ul>\n<li>Calculates final metrics: <code>ErrorRate = ErrorCount / TotalCalls</code>, latency percentiles (p50, p95, p99)</li>\n<li>Persists the aggregated <code>ServiceEdge</code> to the <code>EdgeStorage</code></li>\n<li>Resets in-memory aggregates for the next window</li>\n</ul>\n</li>\n<li><p><strong>Graph Construction</strong>: The <code>GraphBuilder</code> periodically calls <code>BuildCurrentGraph(ctx, windowSize)</code> to construct a complete <code>ServiceGraph</code>:</p>\n<ul>\n<li>Retrieves all edges from the specified time window</li>\n<li>Deduplicates nodes (services) and creates <code>ServiceNode</code> entries</li>\n<li>Detects topology changes by comparing with previous graph via <code>DetectTopologyChanges()</code></li>\n<li>Updates the visualization layer with the new graph</li>\n</ul>\n</li>\n</ol>\n<p><strong>Phase 7: Performance Analytics Processing</strong></p>\n<p>Simultaneously with trace storage and service map construction, spans flow through the performance analytics pipeline:</p>\n<ol>\n<li><p><strong>Latency Aggregation</strong>: For each span with duration information, the <code>PercentileAggregator</code> updates its t-digest structures:</p>\n<ul>\n<li>Creates or retrieves a <code>TDigestMetric</code> for the key <code>service:operation</code></li>\n<li>Calls <code>Add(float64(span.Duration))</code> to incorporate the latency measurement</li>\n<li>Maintains separate aggregations per time window (e.g., 1-minute windows)</li>\n</ul>\n</li>\n<li><p><strong>Anomaly Detection</strong>: At regular intervals (e.g., every 10 seconds), the <code>Detector</code> evaluates current metrics against historical baselines:</p>\n<ul>\n<li>For each service-operation pair, retrieves current p95 latency via <code>GetPercentiles()</code></li>\n<li>Calls <code>CheckMetric(ctx, &quot;latency_p95&quot;, labels, currentValue)</code> which:<ul>\n<li>Calculates expected value using <code>BaselineCalculator.Calculate()</code> (considering time-of-day, day-of-week patterns)</li>\n<li>Computes z-score: <code>(current - expected) / standard_deviation</code></li>\n<li>If z-score exceeds threshold (e.g., 3.0), generates an <code>AnomalyResult</code></li>\n</ul>\n</li>\n<li>For high-severity anomalies, triggers alert notifications</li>\n</ul>\n</li>\n<li><p><strong>Time-Series Storage</strong>: Aggregated metrics (percentiles, call counts, error rates) are written to the time-series database at regular intervals (e.g., every minute) for long-term retention and trend analysis.</p>\n</li>\n</ol>\n<p><strong>Phase 8: Query and Visualization</strong></p>\n<p>When an engineer needs to investigate an issue, they interact with the system through the Web UI and Query Service:</p>\n<ol>\n<li><p><strong>Trace Search</strong>: The engineer queries for traces by service, time range, or attributes:</p>\n<ul>\n<li>Query Service translates the UI request into storage queries:<ul>\n<li><code>GetTracesByService(ctx, &quot;payment-service&quot;, startTime, endTime, 100)</code></li>\n<li><code>GetTracesByTimeRange(ctx, startTime, endTime, 50)</code></li>\n</ul>\n</li>\n<li>Storage retrieves trace IDs from secondary indexes, then fetches full span data</li>\n<li>Traces are returned in chronological order with hierarchical span display</li>\n</ul>\n</li>\n<li><p><strong>Service Map Visualization</strong>: The UI requests the current service map:</p>\n<ul>\n<li>Query Service calls <code>BuildCurrentGraph(ctx, &quot;5m&quot;)</code> or retrieves a pre-computed graph</li>\n<li>Returns nodes (services) and edges (calls with metrics) to the UI</li>\n<li>UI renders interactive graph with node size proportional to request volume and edge color indicating error rate</li>\n</ul>\n</li>\n<li><p><strong>Performance Dashboard</strong>: The UI queries time-series metrics for display:</p>\n<ul>\n<li>Historical latency percentiles (p50, p95, p99) for selected services</li>\n<li>Error rate trends and anomaly alerts</li>\n<li>Comparison views (this week vs. last week)</li>\n</ul>\n</li>\n<li><p><strong>Drill-Down Investigation</strong>: From any visualization, engineers can drill down to individual traces:</p>\n<ul>\n<li>Clicking a service map edge shows sample traces for that service pair</li>\n<li>Clicking an anomaly alert shows the affected traces with high latency</li>\n<li>The trace detail view shows the complete waterfall diagram of spans with timing and error information</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"key-message-and-wire-formats\">Key Message and Wire Formats</h3>\n<p>The system uses several well-defined wire formats for communication between components. Understanding these formats is essential for debugging interoperability issues and extending the system.</p>\n<h4 id=\"opentelemetry-protocol-otlp-span-format\">OpenTelemetry Protocol (OTLP) Span Format</h4>\n<p>The primary external interface uses the OpenTelemetry Protocol (OTLP), which supports both HTTP/JSON and gRPC/protobuf encodings. The following table describes the key fields in the OTLP span representation and their mapping to our internal <code>Span</code> type:</p>\n<table>\n<thead>\n<tr>\n<th>OTLP Field</th>\n<th>Type</th>\n<th>Description</th>\n<th>Mapping to <code>Span</code> Field</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>trace_id</code></td>\n<td>bytes (16 bytes)</td>\n<td>Unique identifier for the trace, represented as 32 hex characters when encoded as text</td>\n<td><code>TraceID</code> (string hex representation)</td>\n</tr>\n<tr>\n<td><code>span_id</code></td>\n<td>bytes (8 bytes)</td>\n<td>Unique identifier for the span within the trace, 16 hex characters as text</td>\n<td><code>SpanID</code> (string hex representation)</td>\n</tr>\n<tr>\n<td><code>trace_state</code></td>\n<td>string</td>\n<td>Comma-separated list of key-value pairs representing vendor-specific trace state</td>\n<td>Not directly mapped; stored in <code>Attributes</code> under <code>&quot;w3c.tracestate&quot;</code></td>\n</tr>\n<tr>\n<td><code>parent_span_id</code></td>\n<td>bytes (8 bytes)</td>\n<td>Identifier of the parent span; empty for root spans</td>\n<td><code>ParentSpanID</code> (string hex representation)</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td>string</td>\n<td>Span name (operation name)</td>\n<td><code>Name</code></td>\n</tr>\n<tr>\n<td><code>kind</code></td>\n<td>enum</td>\n<td>Span kind: INTERNAL, SERVER, CLIENT, PRODUCER, CONSUMER</td>\n<td>Derived into <code>Attributes[&quot;span.kind&quot;]</code></td>\n</tr>\n<tr>\n<td><code>start_time_unix_nano</code></td>\n<td>fixed64</td>\n<td>Start time in nanoseconds since Unix epoch</td>\n<td><code>StartTime</code> (converted from nanoseconds to <code>time.Time</code>)</td>\n</tr>\n<tr>\n<td><code>end_time_unix_nano</code></td>\n<td>fixed64</td>\n<td>End time in nanoseconds since Unix epoch</td>\n<td><code>Duration</code> = <code>EndTime - StartTime</code></td>\n</tr>\n<tr>\n<td><code>attributes</code></td>\n<td>key-value list</td>\n<td>Span attributes (tags) as string, bool, int, double, or array values</td>\n<td><code>Attributes</code> (string values only; complex types stringified)</td>\n</tr>\n<tr>\n<td><code>dropped_attributes_count</code></td>\n<td>uint32</td>\n<td>Count of attributes that were dropped due to limits</td>\n<td>Logged but not stored</td>\n</tr>\n<tr>\n<td><code>events</code></td>\n<td>event list</td>\n<td>Time-stamped events with attributes</td>\n<td><code>Events</code> (mapped to <code>SpanEvent</code> list)</td>\n</tr>\n<tr>\n<td><code>dropped_events_count</code></td>\n<td>uint32</td>\n<td>Count of events that were dropped</td>\n<td>Logged but not stored</td>\n</tr>\n<tr>\n<td><code>links</code></td>\n<td>link list</td>\n<td>Links to other spans (for batch operations)</td>\n<td>Not directly supported in current model</td>\n</tr>\n<tr>\n<td><code>dropped_links_count</code></td>\n<td>uint32</td>\n<td>Count of links that were dropped</td>\n<td>Logged but not stored</td>\n</tr>\n<tr>\n<td><code>status</code></td>\n<td>Status</td>\n<td>Span status: code (Ok, Error, Unset) and optional description</td>\n<td><code>Status.Code</code> and <code>Status.Message</code></td>\n</tr>\n</tbody></table>\n<p><strong>HTTP Endpoint Example:</strong> The Collector exposes an HTTP endpoint at <code>POST /v1/traces</code> accepting JSON with this structure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"resourceSpans\"</span><span style=\"color:#E1E4E8\">: [{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"resource\"</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#79B8FF\">\"attributes\"</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#79B8FF\">\"key\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"service.name\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"value\"</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#79B8FF\">\"stringValue\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"payment-service\"</span><span style=\"color:#E1E4E8\">}}]},</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"scopeSpans\"</span><span style=\"color:#E1E4E8\">: [{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"spans\"</span><span style=\"color:#E1E4E8\">: [{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"traceId\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"4bf92f3577b34da6a3ce929d0e0e4736\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"spanId\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"00f067aa0ba902b7\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"parentSpanId\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"process_payment\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"kind\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"SPAN_KIND_INTERNAL\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"startTimeUnixNano\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"1616234190000000000\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"endTimeUnixNano\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"1616234190500000000\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"attributes\"</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#79B8FF\">\"key\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"http.method\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"value\"</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#79B8FF\">\"stringValue\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">}}],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"status\"</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#79B8FF\">\"code\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"STATUS_CODE_OK\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"internal-span-representation\">Internal Span Representation</h4>\n<p>While the Collector accepts OTLP format, it immediately converts spans to the internal representation defined in Section 4. The following table shows the complete internal <code>Span</code> structure and its persistence format:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type in Go</th>\n<th>Storage Format</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SpanID</code></td>\n<td><code>string</code></td>\n<td>UTF-8 string (16 chars)</td>\n<td>Hex representation of 8-byte span ID</td>\n</tr>\n<tr>\n<td><code>TraceID</code></td>\n<td><code>string</code></td>\n<td>UTF-8 string (32 chars)</td>\n<td>Hex representation of 16-byte trace ID</td>\n</tr>\n<tr>\n<td><code>ParentSpanID</code></td>\n<td><code>string</code></td>\n<td>UTF-8 string (0 or 16 chars)</td>\n<td>Empty for root spans, otherwise hex representation</td>\n</tr>\n<tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>UTF-8 string</td>\n<td>Operation name, max 255 characters</td>\n</tr>\n<tr>\n<td><code>ServiceName</code></td>\n<td><code>string</code></td>\n<td>UTF-8 string</td>\n<td>Service identifier, max 100 characters</td>\n</tr>\n<tr>\n<td><code>StartTime</code></td>\n<td><code>time.Time</code></td>\n<td>int64 (nanoseconds)</td>\n<td>Nanoseconds since Unix epoch, UTC</td>\n</tr>\n<tr>\n<td><code>Duration</code></td>\n<td><code>time.Duration</code></td>\n<td>int64 (nanoseconds)</td>\n<td>Duration in nanoseconds</td>\n</tr>\n<tr>\n<td><code>Attributes</code></td>\n<td><code>map[string]string</code></td>\n<td>JSON object</td>\n<td>Key-value pairs, keys max 255 chars, values max 1024 chars</td>\n</tr>\n<tr>\n<td><code>Events</code></td>\n<td><code>[]SpanEvent</code></td>\n<td>JSON array</td>\n<td>List of timed events during span execution</td>\n</tr>\n<tr>\n<td><code>Status.Code</code></td>\n<td><code>int</code></td>\n<td>int32</td>\n<td>0=Unset, 1=Ok, 2=Error</td>\n</tr>\n<tr>\n<td><code>Status.Message</code></td>\n<td><code>string</code></td>\n<td>UTF-8 string</td>\n<td>Optional status description</td>\n</tr>\n<tr>\n<td><code>Sampled</code></td>\n<td><code>bool</code></td>\n<td>boolean</td>\n<td>Whether this trace was sampled (not part of OTLP)</td>\n</tr>\n<tr>\n<td><code>ReceivedAt</code></td>\n<td><code>time.Time</code></td>\n<td>int64 (nanoseconds)</td>\n<td>When collector received the span (internal use)</td>\n</tr>\n</tbody></table>\n<p><strong>Storage Optimization:</strong> In the storage layer, spans are typically stored in a columnar format with compression. Frequently queried fields (<code>TraceID</code>, <code>ServiceName</code>, <code>StartTime</code>) are stored in separate columns with dictionary encoding, while larger fields (<code>Attributes</code>, <code>Events</code>) are stored in a compressed JSON blob.</p>\n<h4 id=\"collector-internal-messages\">Collector Internal Messages</h4>\n<p>Between internal Collector components, spans are passed as in-memory <code>Span</code> objects, but several key internal APIs use structured messages. The most important is the <strong>Trace Completion Notification</strong> sent from the <code>BufferManager</code> to the <code>TraceAssembler</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>TraceID</code></td>\n<td><code>string</code></td>\n<td>The trace identifier</td>\n</tr>\n<tr>\n<td><code>SpanCount</code></td>\n<td><code>int</code></td>\n<td>Number of spans in the trace</td>\n</tr>\n<tr>\n<td><code>FirstSeen</code></td>\n<td><code>time.Time</code></td>\n<td>When the first span for this trace arrived</td>\n</tr>\n<tr>\n<td><code>LastSeen</code></td>\n<td><code>time.Time</code></td>\n<td>When the most recent span arrived</td>\n</tr>\n<tr>\n<td><code>IsTimedOut</code></td>\n<td><code>bool</code></td>\n<td>Whether trace completion is due to timeout (vs. explicit completion)</td>\n</tr>\n<tr>\n<td><code>BufferSize</code></td>\n<td><code>int</code></td>\n<td>Current memory usage of this trace&#39;s buffer</td>\n</tr>\n</tbody></table>\n<h4 id=\"query-service-apis\">Query Service APIs</h4>\n<p>The Query Service exposes RESTful endpoints for trace retrieval. The key endpoints and their request/response formats are:</p>\n<p><strong>GET /api/traces/{traceId}</strong>\n<em>Request:</em> Path parameter <code>traceId</code> (32-character hex string)\n<em>Response:</em></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"traceId\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"4bf92f3577b34da6a3ce929d0e0e4736\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"spans\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"spanId\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"00f067aa0ba902b7\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"parentSpanId\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"process_payment\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"serviceName\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"payment-service\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"startTime\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2021-03-20T10:56:30Z\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"durationMs\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"attributes\"</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#79B8FF\">\"http.method\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"status\"</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#79B8FF\">\"code\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"startTime\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2021-03-20T10:56:30Z\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"endTime\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2021-03-20T10:56:30.050Z\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"durationMs\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"serviceCount\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>GET /api/traces</strong>\n<em>Query Parameters:</em></p>\n<ul>\n<li><code>service</code> (optional): Filter by service name</li>\n<li><code>operation</code> (optional): Filter by operation name</li>\n<li><code>start</code> (required): Start time in ISO 8601 or Unix milliseconds</li>\n<li><code>end</code> (required): End time in ISO 8601 or Unix milliseconds</li>\n<li><code>limit</code> (optional, default=100): Maximum number of traces to return</li>\n<li><code>minDuration</code> (optional): Filter by minimum trace duration (ms)</li>\n<li><code>maxDuration</code> (optional): Filter by maximum trace duration (ms)</li>\n<li><code>tags</code> (optional): Key-value pairs to match in span attributes</li>\n</ul>\n<p><em>Response:</em> Array of trace summaries (not full span details):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"traces\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"traceId\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"4bf92f3577b34da6a3ce929d0e0e4736\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"rootService\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"payment-service\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"rootOperation\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"process_payment\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"startTime\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2021-03-20T10:56:30Z\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"durationMs\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"spanCount\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"serviceCount\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"hasError\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"total\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"limit\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"offset\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>GET /api/services/{serviceName}/operations</strong>\n<em>Request:</em> Path parameter <code>serviceName</code>\n<em>Response:</em></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"service\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"payment-service\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"operations\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#79B8FF\">\"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"process_payment\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"count\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1500</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#79B8FF\">\"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"validate_card\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"count\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1500</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#79B8FF\">\"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"update_inventory\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"count\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">800</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>GET /api/services/{serviceName}/latency</strong>\n<em>Query Parameters:</em></p>\n<ul>\n<li><code>operation</code> (optional): Specific operation name</li>\n<li><code>start</code> (required): Start time</li>\n<li><code>end</code> (required): End time</li>\n<li><code>percentile</code> (optional, default=95): Percentile to calculate (50, 95, 99)</li>\n</ul>\n<p><em>Response:</em></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"service\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"payment-service\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"operation\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"process_payment\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"percentiles\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"p50\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">45.2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"p95\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">128.7</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"p99\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">245.3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"unit\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"milliseconds\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"sampleSize\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1500</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"timeWindow\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"start\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2021-03-20T10:00:00Z\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"end\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2021-03-20T11:00:00Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>GET /api/service-map</strong>\n<em>Query Parameters:</em></p>\n<ul>\n<li><code>window</code> (optional, default=&quot;5m&quot;): Time window for aggregation (e.g., &quot;5m&quot;, &quot;1h&quot;, &quot;1d&quot;)</li>\n<li><code>time</code> (optional): Reference time for the window (defaults to now)</li>\n</ul>\n<p><em>Response:</em> Complete service graph:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"generatedAt\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2021-03-20T11:05:00Z\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"windowSize\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"5m\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"nodes\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#79B8FF\">\"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"payment-service\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"totalCalls\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1500</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#79B8FF\">\"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"inventory-service\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"totalCalls\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">800</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#79B8FF\">\"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"user-service\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"totalCalls\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">700</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"edges\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"caller\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"payment-service\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"callee\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"inventory-service\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"totalCalls\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">800</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"errorCount\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"errorRate\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0.015</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"p50LatencyMs\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">25.4</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"p95LatencyMs\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">89.1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"p99LatencyMs\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">210.5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"sampleTraceIds\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"4bf92f3577b34da6...\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"5ac93e4688c45eb7...\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"w3c-trace-context-propagation\">W3C Trace Context Propagation</h4>\n<p>For context propagation between services, the system uses W3C Trace Context headers:</p>\n<table>\n<thead>\n<tr>\n<th>Header</th>\n<th>Format</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>traceparent</code></td>\n<td><code>00-{trace-id}-{span-id}-{flags}</code></td>\n<td>Required header with version (00), trace ID (32 hex), span ID (16 hex), and flags (2 hex)</td>\n</tr>\n<tr>\n<td><code>tracestate</code></td>\n<td><code>key1=value1,key2=value2</code></td>\n<td>Optional comma-separated list of vendor-specific tracing system states</td>\n</tr>\n<tr>\n<td><code>traceresponse</code></td>\n<td>(Proposed)</td>\n<td>Future header for returning trace context from server to client</td>\n</tr>\n</tbody></table>\n<p><strong>Example traceparent:</strong> <code>00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01</code></p>\n<ul>\n<li><code>00</code>: Version (current version is 00)</li>\n<li><code>0af7651916cd43dd8448eb211c80319c</code>: 32-character hex trace ID (16 bytes)</li>\n<li><code>b7ad6b7169203331</code>: 16-character hex parent span ID (8 bytes)</li>\n<li><code>01</code>: Flags (bit field: 01 = sampled, 02 = debug, etc.)</li>\n</ul>\n<p>The SDK&#39;s <code>TextMapCarrier</code> interface abstracts these headers for both HTTP and other propagation mechanisms (gRPC metadata, message queues, etc.).</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Note:</strong> This section provides practical guidance for implementing the data flow and wire format handling described above.</p>\n</blockquote>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Span Transport</strong></td>\n<td>HTTP/JSON with <code>net/http</code></td>\n<td>gRPC with Protocol Buffers using OpenTelemetry protobuf definitions</td>\n</tr>\n<tr>\n<td><strong>JSON Serialization</strong></td>\n<td>Standard <code>encoding/json</code></td>\n<td><code>json-iterator/go</code> for faster serialization with compatibility</td>\n</tr>\n<tr>\n<td><strong>Protocol Buffers</strong></td>\n<td>Manually defined .proto files</td>\n<td>Import <code>opentelemetry-proto</code> from GitHub for official OTLP definitions</td>\n</tr>\n<tr>\n<td><strong>HTTP Server</strong></td>\n<td><code>net/http</code> with Gorilla Mux</td>\n<td><code>chi</code> router for lightweight routing with middleware support</td>\n</tr>\n<tr>\n<td><strong>WAL Format</strong></td>\n<td>JSON lines with newline delimiter</td>\n<td>Binary format with length-prefixed protobuf messages</td>\n</tr>\n<tr>\n<td><strong>Context Propagation</strong></td>\n<td>Manual header manipulation</td>\n<td>OpenTelemetry Go SDK&#39;s <code>propagation</code> package</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>apm-tracing-system/\n├── cmd/\n│   ├── collector/                 # Collector main binary\n│   │   └── main.go\n│   ├── query-service/             # Query service main binary  \n│   │   └── main.go\n│   └── web-ui/                    # Web UI server (optional)\n│       └── main.go\n├── internal/\n│   ├── apm/                       # Shared APM data structures\n│   │   ├── span.go               # Span, Trace, Service types\n│   │   ├── wire_formats.go       # OTLP JSON/protobuf marshal/unmarshal\n│   │   └── w3c_trace_context.go  # Trace context header handling\n│   ├── collector/                 # Collector component\n│   │   ├── server/\n│   │   │   ├── http_server.go    # HTTP ingestion endpoint\n│   │   │   └── grpc_server.go    # gRPC ingestion endpoint\n│   │   ├── ingestion/\n│   │   │   ├── pipeline.go       # Main ingestion pipeline\n│   │   │   ├── validator.go      # Span validation logic\n│   │   │   └── buffer_manager.go # Trace buffering\n│   │   ├── sampling/\n│   │   │   ├── head_sampler.go   # Head-based sampling\n│   │   │   └── tail_sampler.go   # Tail-based sampling\n│   │   └── storage/\n│   │       ├── writer.go         # Storage interface implementation\n│   │       └── wal.go            # Write-ahead log\n│   ├── query/                     # Query service component\n│   │   ├── handler.go            # HTTP request handlers\n│   │   ├── service.go            # Business logic for queries\n│   │   └── storage_reader.go     # Storage read interface\n│   ├── servicemap/               # Service map component (Milestone 2)\n│   │   ├── edge_aggregator.go\n│   │   ├── graph_builder.go\n│   │   └── storage.go\n│   ├── analytics/                # Analytics component (Milestone 4)\n│   │   ├── percentile_aggregator.go\n│   │   ├── anomaly_detector.go\n│   │   └── timeseries_store.go\n│   └── sdk/                      # APM SDK (Milestone 5)\n│       ├── tracer.go\n│       ├── instrumentation/\n│       │   ├── http.go\n│       │   ├── database.go\n│       │   └── middleware.go\n│       └── propagation/\n│           └── w3c.go\n└── pkg/\n    ├── otlp/                     # OpenTelemetry protocol handling\n    │   ├── models.pb.go          # Generated protobuf code\n    │   └── marshal.go            # Conversion utilities\n    └── storage/                  # Storage abstractions\n        ├── interface.go\n        ├── elasticsearch.go      # Elasticsearch implementation\n        └── cassandra.go          # Cassandra implementation</code></pre></div>\n\n<h4 id=\"c-otlp-http-handler-implementation\">C. OTLP HTTP Handler Implementation</h4>\n<p>Here&#39;s a complete, working implementation of the Collector&#39;s OTLP HTTP ingestion endpoint:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/gorilla/mux</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">go.uber.org/zap</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">apm-tracing-system/internal/apm</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">apm-tracing-system/internal/collector/ingestion</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OTLPHandler handles OpenTelemetry Protocol over HTTP requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OTLPHandler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pipeline </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ingestion</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Pipeline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">zap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewOTLPHandler creates a new HTTP handler for OTLP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewOTLPHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pipeline</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ingestion</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Pipeline</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">logger</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">zap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OTLPHandler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">OTLPHandler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pipeline: pipeline,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger:   logger,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServeHTTP implements http.Handler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OTLPHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ServeHTTP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only accept POST requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> r.Method </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.MethodPost {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        h.</span><span style=\"color:#B392F0\">respondWithError</span><span style=\"color:#E1E4E8\">(w, http.StatusMethodNotAllowed, </span><span style=\"color:#9ECBFF\">\"Method not allowed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check content type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    contentType </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.Header.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> contentType </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"application/json\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> contentType </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"application/x-protobuf\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        h.</span><span style=\"color:#B392F0\">respondWithError</span><span style=\"color:#E1E4E8\">(w, http.StatusUnsupportedMediaType, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unsupported content type: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, contentType))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read and parse request body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">ReadAll</span><span style=\"color:#E1E4E8\">(r.Body)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        h.logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to read request body\"</span><span style=\"color:#E1E4E8\">, zap.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        h.</span><span style=\"color:#B392F0\">respondWithError</span><span style=\"color:#E1E4E8\">(w, http.StatusBadRequest, </span><span style=\"color:#9ECBFF\">\"Failed to read request body\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> r.Body.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> spans []</span><span style=\"color:#B392F0\">apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> contentType </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"application/json\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Parse OTLP JSON format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        spans, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">parseOTLPJSON</span><span style=\"color:#E1E4E8\">(body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Parse OTLP protobuf format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        spans, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">parseOTLPProtobuf</span><span style=\"color:#E1E4E8\">(body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        h.logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to parse request\"</span><span style=\"color:#E1E4E8\">, zap.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        h.</span><span style=\"color:#B392F0\">respondWithError</span><span style=\"color:#E1E4E8\">(w, http.StatusBadRequest, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Invalid request format: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process spans through the ingestion pipeline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processedCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, span </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> spans {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> h.pipeline.</span><span style=\"color:#B392F0\">ProcessSpan</span><span style=\"color:#E1E4E8\">(r.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">(), span); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            h.logger.</span><span style=\"color:#B392F0\">Warn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to process span\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                zap.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"trace_id\"</span><span style=\"color:#E1E4E8\">, span.TraceID),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                zap.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"span_id\"</span><span style=\"color:#E1E4E8\">, span.SpanID),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                zap.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Continue processing other spans even if one fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            processedCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send success response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"status\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"success\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"processed_spans\"</span><span style=\"color:#E1E4E8\">: processedCount,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"total_spans\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(spans),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"processing_time_ms\"</span><span style=\"color:#E1E4E8\">: time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start).</span><span style=\"color:#B392F0\">Milliseconds</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusOK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(response); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        h.logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to encode response\"</span><span style=\"color:#E1E4E8\">, zap.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    h.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Processed OTLP batch\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        zap.</span><span style=\"color:#B392F0\">Int</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"processed\"</span><span style=\"color:#E1E4E8\">, processedCount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        zap.</span><span style=\"color:#B392F0\">Int</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"total\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(spans)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        zap.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"duration\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseOTLPJSON parses OTLP JSON format into internal Span objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OTLPHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseOTLPJSON</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> otlpRequest </span><span style=\"color:#B392F0\">OTLPJSONRequest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">otlpRequest); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"JSON unmarshal failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Convert OTLP spans to internal representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> spans []</span><span style=\"color:#B392F0\">apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, resourceSpan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> otlpRequest.ResourceSpans {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        serviceName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> extractServiceName</span><span style=\"color:#E1E4E8\">(resourceSpan.Resource)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, scopeSpan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> resourceSpan.ScopeSpans {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> _, otlpSpan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> scopeSpan.Spans {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                span, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> convertOTLPSpan</span><span style=\"color:#E1E4E8\">(otlpSpan, serviceName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    h.logger.</span><span style=\"color:#B392F0\">Warn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to convert OTLP span\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        zap.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        zap.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"span_name\"</span><span style=\"color:#E1E4E8\">, otlpSpan.Name))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                spans </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(spans, span)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> spans, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseOTLPProtobuf parses OTLP protobuf format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OTLPHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseOTLPProtobuf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation would use generated protobuf code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For simplicity, we show a placeholder</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"protobuf parsing not implemented in this example\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// respondWithError sends an error response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OTLPHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">respondWithError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">code</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"status\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"code\"</span><span style=\"color:#E1E4E8\">:    code,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"message\"</span><span style=\"color:#E1E4E8\">: message,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(code)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(response); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        h.logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to encode error response\"</span><span style=\"color:#E1E4E8\">, zap.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OTLPJSONRequest represents the OTLP JSON structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OTLPJSONRequest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceSpans []</span><span style=\"color:#B392F0\">ResourceSpan</span><span style=\"color:#9ECBFF\"> `json:\"resourceSpans\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceSpan represents OTLP ResourceSpans</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceSpan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Resource   </span><span style=\"color:#B392F0\">Resource</span><span style=\"color:#9ECBFF\">   `json:\"resource\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ScopeSpans []</span><span style=\"color:#B392F0\">ScopeSpan</span><span style=\"color:#9ECBFF\"> `json:\"scopeSpans\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Resource represents OTLP Resource</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Resource</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Attributes []</span><span style=\"color:#B392F0\">KeyValue</span><span style=\"color:#9ECBFF\"> `json:\"attributes\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ScopeSpan represents OTLP ScopeSpans</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ScopeSpan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Spans []</span><span style=\"color:#B392F0\">OTLPSpan</span><span style=\"color:#9ECBFF\"> `json:\"spans\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OTLPSpan represents an OTLP span in JSON format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OTLPSpan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TraceID           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"traceId\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpanID            </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"spanId\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentSpanID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"parentSpanId\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name              </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Kind              </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"kind\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTimeUnixNano </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"startTimeUnixNano\"`</span><span style=\"color:#6A737D\"> // string to handle large numbers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EndTimeUnixNano   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"endTimeUnixNano\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Attributes        []</span><span style=\"color:#B392F0\">KeyValue</span><span style=\"color:#9ECBFF\">  `json:\"attributes\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status            </span><span style=\"color:#B392F0\">OTLPStatus</span><span style=\"color:#9ECBFF\">  `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// KeyValue represents OTLP KeyValue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> KeyValue</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Key   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"key\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#9ECBFF\">       `json:\"value\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Value represents OTLP AnyValue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StringValue  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"stringValue,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BoolValue    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">      `json:\"boolValue,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IntValue     </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">     `json:\"intValue,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DoubleValue  </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\">   `json:\"doubleValue,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ArrayValue   []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#9ECBFF\">   `json:\"arrayValue,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OTLPStatus represents OTLP Status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OTLPStatus</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"message,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// extractServiceName extracts service name from OTLP resource attributes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> extractServiceName</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">resource</span><span style=\"color:#B392F0\"> Resource</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, attr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> resource.Attributes {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> attr.Key </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"service.name\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> attr.Value.StringValue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"unknown-service\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// convertOTLPSpan converts OTLP span to internal Span representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> convertOTLPSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">otlpSpan</span><span style=\"color:#B392F0\"> OTLPSpan</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">serviceName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse timestamps from nanosecond strings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    startTime, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseUnixNano</span><span style=\"color:#E1E4E8\">(otlpSpan.StartTimeUnixNano)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid start time: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    endTime, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseUnixNano</span><span style=\"color:#E1E4E8\">(otlpSpan.EndTimeUnixNano)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid end time: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    duration </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> endTime.</span><span style=\"color:#B392F0\">Sub</span><span style=\"color:#E1E4E8\">(startTime)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"negative duration: start=</span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">, end=</span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, startTime, endTime)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Convert attributes to map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    attributes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, attr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> otlpSpan.Attributes {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Convert value to string representation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        attributes[attr.Key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> valueToString</span><span style=\"color:#E1E4E8\">(attr.Value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add span.kind from OTLP kind field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> otlpSpan.Kind </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        attributes[</span><span style=\"color:#9ECBFF\">\"span.kind\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> otlpSpan.Kind</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Convert status code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statusCode </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\"> // Unset</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> otlpSpan.Status.Code </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"STATUS_CODE_OK\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        statusCode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> otlpSpan.Status.Code </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"STATUS_CODE_ERROR\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        statusCode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SpanID:       otlpSpan.SpanID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TraceID:      otlpSpan.TraceID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ParentSpanID: otlpSpan.ParentSpanID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name:         otlpSpan.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ServiceName:  serviceName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StartTime:    startTime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Duration:     duration,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Attributes:   attributes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Status: </span><span style=\"color:#B392F0\">apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SpanStatus</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Code:    statusCode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Message: otlpSpan.Status.Message,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ReceivedAt: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseUnixNano parses a string representing nanoseconds since Unix epoch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseUnixNano</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nsStr</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation parses string to int64 then converts to time.Time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Simplified for this example</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// valueToString converts OTLP AnyValue to string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> valueToString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v.StringValue </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.StringValue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v.BoolValue {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"true\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v.IntValue </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, v.IntValue)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v.DoubleValue </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, v.DoubleValue)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterRoutes registers the OTLP handler with the router</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RegisterRoutes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">router</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">mux</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Router</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pipeline</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ingestion</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Pipeline</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">logger</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">zap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewOTLPHandler</span><span style=\"color:#E1E4E8\">(pipeline, logger)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    router.</span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/v1/traces\"</span><span style=\"color:#E1E4E8\">, handler).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    router.</span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/api/v2/spans\"</span><span style=\"color:#E1E4E8\">, handler).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// Legacy Jaeger endpoint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-span-processing-pipeline-skeleton\">D. Span Processing Pipeline Skeleton</h4>\n<p>Here&#39;s the skeleton for the core ingestion pipeline that processes spans through validation, buffering, and sampling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> ingestion</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">apm-tracing-system/internal/apm</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Pipeline is the main ingestion pipeline for processing spans</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Pipeline</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validator      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SpanValidator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bufferManager  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headSampler    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sampling</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">HeadSampler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tailSampler    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sampling</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TailSampler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storageWriter  </span><span style=\"color:#B392F0\">storage</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Writer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metrics        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PipelineMetrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewPipeline creates a new ingestion pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPipeline</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Pipeline</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize span validator with config validation rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create buffer manager with configured max size and TTL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize head sampler with sampling rates from config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize tail sampler with rules from config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create storage writer for the configured storage backend</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Set up metrics collection for pipeline statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Start background goroutines for buffer eviction and trace assembly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Pipeline</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessSpan processes a single span through the ingestion pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Pipeline</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">span</span><span style=\"color:#B392F0\"> apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate span fields (trace ID, span ID, timestamps, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Return error if span is invalid (malformed data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Apply head-based sampling decision if not already made by SDK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Use consistent hashing on trace ID for deterministic decision</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If span is not sampled, only store minimal metadata for trace existence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Otherwise, proceed with full processing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add span to buffer manager for its trace ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Buffer manager will handle out-of-order arrival and trace assembly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Write span to Write-Ahead Log for durability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         This ensures spans aren't lost if collector crashes before processing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update pipeline metrics (counters for spans processed, errors, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return nil on success, error if any step fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessCompleteTrace is called when a trace is assembled and ready for tail sampling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Pipeline</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessCompleteTrace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">trace</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">apm</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Apply tail-based sampling rules to the completed trace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Evaluate error status, latency percentiles, custom rules</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If tail sampling overrides head decision to keep, mark trace as sampled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Otherwise, if head decision was drop, discard the trace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For sampled traces, write all spans to persistent storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Use bulk write operations for efficiency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Extract service dependencies and send to service map builder</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Each inter-service span creates an edge in the dependency graph</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Send span metrics to analytics aggregator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Latency, error rates, operation counts for anomaly detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update sampling statistics for adaptive rate adjustment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PipelineMetrics tracks ingestion pipeline performance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PipelineMetrics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpansReceived   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpansProcessed  </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpansDropped    </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TracesAssembled </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ProcessingTime  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>HTTP Server Best Practices:</strong></p>\n<ul>\n<li>Use <code>http.TimeoutHandler</code> to enforce request timeouts</li>\n<li>Implement middleware for CORS, authentication, and request logging</li>\n<li>Set <code>ReadTimeout</code> and <code>WriteTimeout</code> on the HTTP server to prevent resource exhaustion</li>\n<li>Use connection pooling with <code>http.Transport</code> for outgoing requests to storage</li>\n</ul>\n</li>\n<li><p><strong>JSON Processing Optimization:</strong></p>\n<ul>\n<li>For high-throughput scenarios, consider <code>json-iterator/go</code> which is API-compatible with <code>encoding/json</code> but significantly faster</li>\n<li>Reuse JSON encoders/decoders where possible to reduce allocations</li>\n<li>Use <code>json.RawMessage</code> for deferred parsing of nested structures</li>\n</ul>\n</li>\n<li><p><strong>Time Handling:</strong></p>\n<ul>\n<li>Always use <code>time.Time</code> for timestamps internally, but be careful with timezone conversions</li>\n<li>For nanosecond precision timestamps, use <code>time.Unix(0, nanoseconds)</code> and <code>time.UnixNano()</code></li>\n<li>Consider using <code>monotonic</code> time for duration measurements within a process</li>\n</ul>\n</li>\n<li><p><strong>Context Propagation:</strong></p>\n<ul>\n<li>Use <code>context.WithTimeout</code> for operations that should have time limits</li>\n<li>Pass context as first parameter to all functions that make I/O calls</li>\n<li>Store span in context using a private key type to avoid collisions: <code>type contextKey int; const spanKey contextKey = 0</code></li>\n</ul>\n</li>\n<li><p><strong>Concurrency Patterns:</strong></p>\n<ul>\n<li>Use <code>sync.Pool</code> for frequently allocated objects (like <code>Span</code> structs)</li>\n<li>Consider buffered channels for decoupling pipeline stages with backpressure</li>\n<li>Use <code>errgroup</code> for managing groups of goroutines with coordinated error handling</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the data flow pipeline, verify the complete trace lifecycle:</p>\n<ol>\n<li><strong>Start the Collector:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/collector/main.go</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config.yaml</span></span></code></pre></div>\n<p>   Expected output: <code>Collector started on :4318 (HTTP) and :4317 (gRPC)</code></p>\n<ol start=\"2\">\n<li><strong>Send Test Spans:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Using curl to send OTLP JSON</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:4318/v1/traces</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -d</span><span style=\"color:#9ECBFF\"> '{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"resourceSpans\": [{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         \"resource\": {\"attributes\": [{\"key\": \"service.name\", \"value\": {\"stringValue\": \"test-service\"}}]},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         \"scopeSpans\": [{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           \"spans\": [{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"traceId\": \"4bf92f3577b34da6a3ce929d0e0e4736\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"spanId\": \"00f067aa0ba902b7\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"name\": \"test-operation\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"startTimeUnixNano\": \"'</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#9ECBFF\">000000000'\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"endTimeUnixNano\": \"'</span><span style=\"color:#E1E4E8\">$(($(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">)+1))</span><span style=\"color:#9ECBFF\">000000000'\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"attributes\": [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"status\": {\"code\": \"STATUS_CODE_OK\"}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           }]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         }]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       }]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">     }'</span></span></code></pre></div>\n<p>   Expected response: <code>{&quot;status&quot;:&quot;success&quot;,&quot;processed_spans&quot;:1,&quot;total_spans&quot;:1,&quot;processing_time_ms&quot;:5}</code></p>\n<ol start=\"3\">\n<li><strong>Query for the Trace:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/api/traces/4bf92f3577b34da6a3ce929d0e0e4736\"</span></span></code></pre></div>\n<p>   Expected: JSON response with the trace containing your test span.</p>\n<ol start=\"4\">\n<li><strong>Check Service Map:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/api/service-map?window=1m\"</span></span></code></pre></div>\n<p>   Expected: Service map with <code>test-service</code> node (though no edges since only one span).</p>\n<ol start=\"5\">\n<li><strong>Verify Storage:</strong><ul>\n<li>Check that spans appear in your storage backend (Elasticsearch, Cassandra, etc.)</li>\n<li>Verify indexes are created for trace ID and service name</li>\n</ul>\n</li>\n</ol>\n<p><strong>Signs of Issues:</strong></p>\n<ul>\n<li><strong>Spans not appearing in queries:</strong> Check buffer manager eviction policy and trace assembly timeout</li>\n<li><strong>High memory usage:</strong> Buffer manager may not be evicting old traces; check <code>maxSize</code> configuration</li>\n<li><strong>Slow response times:</strong> Ingestion pipeline may be overloaded; implement rate limiting or increase batch sizes</li>\n<li><strong>Missing parent-child relationships:</strong> Verify context propagation headers are being injected/extracted correctly</li>\n</ul>\n<h2 id=\"11-error-handling-and-edge-cases\">11. Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section applies to all five milestones, as error handling and edge case management are cross-cutting concerns that affect the entire APM Tracing System&#39;s reliability and resilience.</p>\n</blockquote>\n<h3 id=\"mental-model-the-fault-tolerant-hospital\">Mental Model: The Fault-Tolerant Hospital</h3>\n<p>Think of the APM system as a well-run hospital emergency room during a crisis. When everything functions normally, patients (traces) flow smoothly through triage (sampling), diagnosis (analysis), and treatment (storage/visualization). However, during a mass casualty event (traffic surge) or when critical equipment fails (storage outage), the hospital must adapt. It implements <strong>triage protocols</strong> (backpressure) to prioritize the most critical cases, activates <strong>backup generators</strong> (redundant storage), and maintains <strong>patient records</strong> (WAL) to ensure no critical information is lost even during power failures. This section defines how our system behaves when things go wrong, ensuring it degrades gracefully rather than collapsing catastrophically.</p>\n<h3 id=\"failure-modes-and-recovery-strategies\">Failure Modes and Recovery Strategies</h3>\n<p>A robust APM system must anticipate and handle failures at multiple layers. The following table categorizes the most critical failure modes, their detection mechanisms, and recovery strategies:</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Symptoms/Detection</th>\n<th>Immediate Response</th>\n<th>Recovery Strategy</th>\n<th>Prevention</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Collector Overload</strong> (Traffic surge exceeding ingestion capacity)</td>\n<td>• HTTP 503/429 responses from ingestion endpoints<br>• Growing memory consumption in <code>BufferManager</code><br>• Increasing <code>PipelineMetrics.SpansDropped</code> counter<br>• High CPU utilization on collector nodes</td>\n<td>1. Return HTTP 429 (Too Many Requests) with Retry-After header<br>2. Activate head sampling at 100% drop rate temporarily<br>3. Shed load by rejecting spans from low-priority services<br>4. Emit high-priority alert</td>\n<td>1. Auto-scale collector pods based on queue depth<br>2. Gradually restore sampling rates as load decreases<br>3. Replay spans from Write-Ahead Log (WAL) if available</td>\n<td>• Implement rate limiting per client IP/service<br>• Set memory bounds with automatic eviction<br>• Use load balancers with health checks</td>\n</tr>\n<tr>\n<td><strong>Storage Backend Unavailable</strong> (Database/object store connection loss)</td>\n<td>• Storage write timeouts exceeding <code>StorageConfig.Timeout</code><br>• Exponential backoff in storage writer retries<br>• <code>GetTraceByID</code> returns &quot;storage unavailable&quot; errors<br>• Health check endpoint reports degraded status</td>\n<td>1. Buffer spans in memory up to safe limits<br>2. Write to local WAL for durability<br>3. Mark storage writer as degraded, continue processing<br>4. Switch to read-only mode for query endpoints</td>\n<td>1. Implement circuit breaker pattern for storage client<br>2. Retry with exponential backoff when connection restored<br>3. Replay WAL entries to catch up on missed writes<br>4. Validate data consistency after recovery</td>\n<td>• Use multiple storage replicas with failover<br>• Implement storage health probes<br>• Set conservative timeouts with context cancellation</td>\n</tr>\n<tr>\n<td><strong>Network Partition</strong> (Collector cluster split-brain)</td>\n<td>• Leader election failures in distributed components<br>• Inconsistent service map views across nodes<br>• Duplicate span storage across partitions<br>• Clock skew exceeding allowed tolerance</td>\n<td>1. Continue operating independently in each partition<br>2. Mark data with partition identifier for later reconciliation<br>3. Disable distributed coordination features (global sampling rates)<br>4. Log partition events for manual intervention</td>\n<td>1. Use CRDTs for eventually consistent service maps<br>2. Implement last-write-wins for duplicate spans with timestamps<br>3. Run reconciliation job when network heals<br>4. Reset adaptive sampling state post-partition</td>\n<td>• Use consensus algorithms (Raft) for critical state<br>• Implement anti-entropy protocols for background sync<br>• Monitor network latency and partition probability</td>\n</tr>\n<tr>\n<td><strong>Corrupt Span Data</strong> (Malformed, invalid, or poisoned spans)</td>\n<td>• <code>SpanValidator</code> returns validation errors<br>• JSON/protobuf parsing failures with specific error codes<br>• Span timestamps far in future/past (beyond <code>maxTraceDuration</code>)<br>• Trace ID format violations (wrong length/encoding)</td>\n<td>1. Reject individual malformed spans with 400 Bad Request<br>2. Continue processing other spans in same batch<br>3. Increment &quot;spans rejected&quot; metric with error type label<br>4. Optionally quarantine suspicious spans for analysis</td>\n<td>1. Implement strict validation with clear error messages<br>2. Provide validation error details in response (truncated)<br>3. Log full corrupt spans at DEBUG level for debugging<br>4. Auto-block repeat offenders after threshold</td>\n<td>• Validate spans at SDK before transmission<br>• Use schema validation for OpenTelemetry formats<br>• Implement request size limits to prevent DoS</td>\n</tr>\n<tr>\n<td><strong>Clock Skew Across Services</strong> (Span ordering inconsistencies)</td>\n<td>• Child spans appearing to start before parent spans<br>• Negative span durations after timestamp normalization<br>• Service map edges with impossible latency values<br>• Trace visualization showing time travel</td>\n<td>1. Normalize timestamps using collector&#39;s clock on ingestion<br>2. Calculate durations using normalized times only<br>3. Apply heuristic corrections (child cannot start before parent)<br>4. Log clock skew warnings for investigation</td>\n<td>1. Implement NTP synchronization across all services<br>2. Store original and normalized timestamps separately<br>3. Use monotonic clocks for duration calculations where possible<br>4. Detect and report services with consistent clock issues</td>\n<td>• Require SDKs to send monotonic clock readings alongside wall time<br>• Implement timestamp bounds checking in validator<br>• Educate users about time synchronization best practices</td>\n</tr>\n<tr>\n<td><strong>Memory Exhaustion</strong> (Unbounded buffer growth)</td>\n<td>• <code>BufferManager</code> eviction running constantly<br>• Go runtime reporting &quot;out of memory&quot;<br>• High GC pressure affecting throughput<br>• <code>TraceBuffer</code> count exceeding <code>maxSize</code> despite eviction</td>\n<td>1. Trigger aggressive eviction of oldest/incomplete traces<br>2. Temporarily increase head sampling drop rate to 100%<br>3. Spill over to disk if disk buffer configured<br>4. Restart process with clean state as last resort</td>\n<td>1. Implement multiple eviction policies (LRU, by age, by size)<br>2. Add memory limits with hard boundaries<br>3. Monitor buffer metrics with alerting thresholds<br>4. Adjust <code>maxTraceDuration</code> based on memory pressure</td>\n<td>• Set conservative default buffer sizes<br>• Implement proactive monitoring of memory trends<br>• Use off-heap storage for large trace buffers</td>\n</tr>\n<tr>\n<td><strong>Late-Arriving Spans</strong> (Spans arriving after trace assembly)</td>\n<td>• <code>TraceAssembler.IsTraceComplete</code> returning false for assembled traces<br>• Spans with timestamps outside assembly window<br>• Orphan spans without parent in storage<br>• Incomplete traces in query results</td>\n<td>1. Extend buffer TTL for traces expecting late children<br>2. Store late spans separately for manual attachment<br>3. Mark traces as &quot;potentially incomplete&quot; in query results<br>4. Update service map with partial information</td>\n<td>1. Implement watermark-based trace completion detection<br>2. Use asynchronous trace assembly with configurable wait time<br>3. Provide admin API to force assembly of specific traces<br>4. Re-process buffers periodically to attach late spans</td>\n<td>• Set realistic <code>maxTraceDuration</code> based on network latency<br>• Implement span batching with deadlines at SDK<br>• Use synchronous tracing for critical paths where possible</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The system&#39;s error handling follows the principle of <strong>graceful degradation</strong> rather than all-or-nothing availability. When components fail, the system continues operating with reduced functionality (e.g., storing spans locally when storage is unavailable) rather than rejecting all incoming data.</p>\n</blockquote>\n<h4 id=\"adr-storage-failure-recovery-strategy\">ADR: Storage Failure Recovery Strategy</h4>\n<p><strong>Decision: WAL + Delayed Retry with Exponential Backoff for Storage Failures</strong></p>\n<ul>\n<li><p><strong>Context</strong>: The storage backend (database, object store) is a critical dependency that may experience temporary outages lasting from seconds to hours. During outages, we must preserve incoming span data without overwhelming memory, and ensure eventual consistency when storage recovers.</p>\n</li>\n<li><p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Drop spans during outage</strong>: Simple but loses critical debugging data precisely when needed most (during system failures).</li>\n<li><strong>In-memory buffering only</strong>: Preserves data but risks memory exhaustion during prolonged outages.</li>\n<li><strong>WAL to local disk with retry</strong>: Writes spans to local disk Write-Ahead Log during outages, retries when storage recovers.</li>\n</ol>\n</li>\n<li><p><strong>Decision</strong>: Implement a hybrid approach using <strong>bounded in-memory buffering</strong> (for short outages) combined with <strong>WAL to local disk</strong> (for prolonged outages), with automatic retry using exponential backoff when storage recovers.</p>\n</li>\n<li><p><strong>Rationale</strong>: </p>\n<ul>\n<li>WAL provides durability guarantees similar to databases—spans are fsynced to disk before acknowledging receipt.</li>\n<li>Local disk storage is typically larger and more reliable than memory for temporary storage.</li>\n<li>Exponential backoff prevents overwhelming recovering storage with backlog.</li>\n<li>Bounded memory buffer handles short blips without disk I/O overhead.</li>\n</ul>\n</li>\n<li><p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: No data loss during storage outages of arbitrary length (assuming disk space).</li>\n<li><strong>Positive</strong>: Self-healing—automatically catches up when storage recovers.</li>\n<li><strong>Negative</strong>: Requires disk space provisioning on collector nodes.</li>\n<li><strong>Negative</strong>: Adds complexity with WAL rotation, cleanup, and replay logic.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Drop spans during outage</td>\n<td>Simple implementation, no resource pressure</td>\n<td>Unacceptable data loss, violates APM&#39;s core purpose</td>\n<td>Data loss is catastrophic for debugging production issues</td>\n</tr>\n<tr>\n<td>In-memory buffering only</td>\n<td>Fast, no disk I/O overhead</td>\n<td>Bounded by RAM, data loss on process restart</td>\n<td>Memory is precious and expensive; outages may last longer than RAM can buffer</td>\n</tr>\n<tr>\n<td><strong>WAL + delayed retry</strong></td>\n<td>Durable, handles arbitrary outage length, self-healing</td>\n<td>Disk I/O overhead, cleanup complexity</td>\n<td><strong>CHOSEN</strong> - Provides strongest durability with manageable operational complexity</td>\n</tr>\n</tbody></table>\n<h3 id=\"backpressure-and-degraded-modes\">Backpressure and Degraded Modes</h3>\n<h4 id=\"mental-model-the-pressure-release-valve\">Mental Model: The Pressure Release Valve</h4>\n<p>Imagine a steam boiler with multiple safety valves. Under normal pressure, all valves remain closed. As pressure increases, smaller valves open first to relieve minor overpressure. In extreme conditions, the main rupture disk bursts to prevent catastrophic explosion, sacrificing the disk to save the boiler. Our APM system implements similar <strong>cascading backpressure mechanisms</strong>: starting with gentle load shedding (adjusting sampling rates) and escalating to aggressive measures (dropping all low-priority data) when under extreme load.</p>\n<h4 id=\"cascading-backpressure-strategy\">Cascading Backpressure Strategy</h4>\n<p>The system implements a multi-tiered approach to handle load, with each tier activating at progressively severe conditions:</p>\n<p><strong>Tier 1: Adaptive Sampling Adjustment</strong> (Load &gt; 80% capacity)</p>\n<ul>\n<li>Automatically reduce head sampling rates for high-traffic services</li>\n<li>Increase tail sampling thresholds to keep only critical errors</li>\n<li>Adjust based on real-time throughput measurements</li>\n<li><strong>Activation</strong>: When ingestion queue depth exceeds 80% of buffer capacity</li>\n</ul>\n<p><strong>Tier 2: Selective Load Shedding</strong> (Load &gt; 95% capacity)</p>\n<ul>\n<li>Reject spans from pre-configured low-priority services</li>\n<li>Implement per-client rate limiting with 429 responses</li>\n<li>Temporarily disable expensive processing (detailed attribute indexing)</li>\n<li><strong>Activation</strong>: When memory utilization exceeds 90% or CPU &gt; 85%</li>\n</ul>\n<p><strong>Tier 3: Aggressive Degradation</strong> (Load &gt; 100% capacity, system unstable)</p>\n<ul>\n<li>Drop all head sampling (100% drop rate)</li>\n<li>Process only tail sampling for critical errors</li>\n<li>Disable service map updates and analytics aggregation</li>\n<li>Return &quot;degraded service&quot; status from health endpoints</li>\n<li><strong>Activation</strong>: When system is at risk of OOM kill or complete unresponsiveness</li>\n</ul>\n<p><strong>Tier 4: Fail-Safe Mode</strong> (Complete overload, preserving core function)</p>\n<ul>\n<li>Write spans directly to WAL without processing</li>\n<li>Disable all HTTP/gRPC endpoints except health check</li>\n<li>Log detailed diagnostics for post-mortem analysis</li>\n<li><strong>Activation</strong>: Manual trigger or automatic when multiple collectors fail</li>\n</ul>\n<h4 id=\"degraded-modes-operation\">Degraded Modes Operation</h4>\n<p>When the system enters a degraded mode, it maintains transparency through:</p>\n<ol>\n<li><p><strong>Health Endpoint Status Levels</strong>:</p>\n<ul>\n<li><code>/healthz</code> returns HTTP 200 with <code>{&quot;status&quot;: &quot;healthy&quot;}</code></li>\n<li><code>/healthz</code> returns HTTP 200 with <code>{&quot;status&quot;: &quot;degraded&quot;, &quot;affected_components&quot;: [&quot;sampling&quot;, &quot;analytics&quot;]}</code></li>\n<li><code>/healthz</code> returns HTTP 503 with <code>{&quot;status&quot;: &quot;unhealthy&quot;, &quot;reason&quot;: &quot;storage_unavailable&quot;}</code></li>\n</ul>\n</li>\n<li><p><strong>Client Notification</strong>:</p>\n<ul>\n<li>HTTP 429 responses include <code>Retry-After: 30</code> header</li>\n<li>gRPC status codes with <code>RESOURCE_EXHAUSTED</code> and retry hints</li>\n<li>SDKs receive backpressure signals and apply client-side sampling</li>\n</ul>\n</li>\n<li><p><strong>Monitoring and Alerting</strong>:</p>\n<ul>\n<li>Each backpressure tier activation emits structured log event</li>\n<li>Metrics track time spent in each degraded state</li>\n<li>Alert managers notified of state transitions for operator intervention</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"adr-backpressure-implementation-pattern\">ADR: Backpressure Implementation Pattern</h4>\n<p><strong>Decision: Client-Responsive Backpressure with Progressive Degradation</strong></p>\n<ul>\n<li><p><strong>Context</strong>: Under extreme load, the system must protect itself while providing the best possible service. Simply rejecting all requests leads to &quot;goodput collapse&quot; where useful work drops to zero. We need a strategy that maximizes valuable output (error traces, high-latency traces) while shedding less important load.</p>\n</li>\n<li><p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Random drop</strong>: Simple random selection of requests to reject.</li>\n<li><strong>Queue-based backpressure</strong>: Use bounded queues that block when full, pushing back on clients.</li>\n<li><strong>Adaptive priority-based shedding</strong>: Intelligently select which traces to process based on their likely value.</li>\n</ol>\n</li>\n<li><p><strong>Decision</strong>: Implement <strong>adaptive priority-based shedding</strong> using a combination of:</p>\n<ul>\n<li>Client-side sampling adjustments (via response headers)</li>\n<li>Server-side priority queues</li>\n<li>Value-based trace selection (errors, high latency first)</li>\n</ul>\n</li>\n<li><p><strong>Rationale</strong>:</p>\n<ul>\n<li>Random drop wastes capacity on unimportant traces while potentially dropping critical ones.</li>\n<li>Queue-based backpressure can cause cascading failures upstream when clients block.</li>\n<li>Priority-based shedding maximizes the value of processed traces during overload, acting like a triage system that prioritizes the most medically critical patients during an emergency.</li>\n</ul>\n</li>\n<li><p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: Maximizes retention of operationally valuable traces during overload.</li>\n<li><strong>Positive</strong>: Clients automatically adjust their sampling rates based on server feedback.</li>\n<li><strong>Negative</strong>: More complex to implement than simple random drop.</li>\n<li><strong>Negative</strong>: Requires coordination between client SDKs and collector.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random drop</td>\n<td>Trivial to implement, predictable load reduction</td>\n<td>Wastes capacity on low-value traces, drops critical data</td>\n<td>Poor utilization of limited resources during crisis</td>\n</tr>\n<tr>\n<td>Queue-based backpressure</td>\n<td>Simple, preserves order, no data loss</td>\n<td>Can cause upstream cascading failures, clients may timeout</td>\n<td>Backpressure should propagate intelligently, not just block</td>\n</tr>\n<tr>\n<td><strong>Adaptive priority-based shedding</strong></td>\n<td>Maximizes value retention, adapts to load</td>\n<td>Complex implementation, requires client cooperation</td>\n<td><strong>CHOSEN</strong> - Provides optimal trade-off between self-protection and service value</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Circuit Breaker</td>\n<td>Manual state tracking with counters</td>\n<td><code>github.com/sony/gobreaker</code> for production-ready circuit breaker</td>\n</tr>\n<tr>\n<td>Rate Limiting</td>\n<td>Token bucket using <code>time.Ticker</code></td>\n<td><code>golang.org/x/time/rate</code> for sophisticated limiting</td>\n</tr>\n<tr>\n<td>Health Checks</td>\n<td>Simple HTTP handler with status flags</td>\n<td><code>github.com/heptiolabs/healthcheck</code> with Kubernetes probes</td>\n</tr>\n<tr>\n<td>WAL Implementation</td>\n<td>Custom file rotation with fsync</td>\n<td><code>github.com/tidwall/wal</code> for production-grade WAL</td>\n</tr>\n<tr>\n<td>Backpressure Signals</td>\n<td>HTTP 429 with Retry-After header</td>\n<td>gRPC flow control with <code>RESOURCE_EXHAUSTED</code> status</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/collector/main.go                    # Entry point with graceful shutdown\n  internal/\n    apm/\n      collector/\n        health/                            # Health check subsystem\n          health.go                        # Health status tracking\n          handler.go                       # HTTP health endpoint\n        backpressure/                      # Backpressure management\n          manager.go                       # Backpressure tier management\n          signals.go                       # Client backpressure signaling\n        degradation/                       # Degraded mode handling\n          modes.go                         # Degraded mode state machine\n          monitor.go                       # Mode transition monitoring\n      resilience/\n        circuitbreaker/                    # Circuit breaker implementation\n          breaker.go                       # Storage client circuit breaker\n          metrics.go                       # Breaker state metrics\n        ratelimiter/                       # Rate limiting\n          limiter.go                       # Token bucket rate limiter\n          middleware.go                    # HTTP/gRPC rate limit middleware\n        wal/                               # Write-Ahead Log\n          writer.go                        # WAL writer with rotation\n          replayer.go                      # WAL replay on recovery\n          cleaner.go                       # WAL file cleanup\n      errors/                              # Error types and handling\n        errors.go                          # Custom error types\n        recovery.go                        # Error recovery utilities\n  pkg/\n    api/\n      middlewares/                         # HTTP/gRPC middlewares\n        recovery.go                        # Panic recovery middleware\n        backpressure.go                    # Backpressure injection middleware</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete WAL Implementation for Storage Failures:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/apm/resilience/wal/writer.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> wal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/binary</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WALWriter provides durable write-ahead logging for spans during storage outages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WALWriter</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset       </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxFileSize  </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentSize  </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rotateSignal </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    done         </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewWALWriter creates a new WAL writer with automatic rotation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewWALWriter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">dataDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">maxFileSize</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(dataDir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create WAL directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(dataDir, fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"wal-</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">.bin\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">()))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">OpenFile</span><span style=\"color:#E1E4E8\">(filePath, os.O_CREATE</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_RDWR</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_APPEND, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create WAL file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stat, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> file.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to stat WAL file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file:         file,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        filePath:     filePath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset:       </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxFileSize:  maxFileSize,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentSize:  stat.</span><span style=\"color:#B392F0\">Size</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rotateSignal: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        done:         </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start background rotation monitor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#E1E4E8\"> w.</span><span style=\"color:#B392F0\">rotationMonitor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> w, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Append writes a record to WAL with length-prefixed format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if we need to rotate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> w.currentSize</span><span style=\"color:#F97583\">+int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(data))</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#F97583\"> ></span><span style=\"color:#E1E4E8\"> w.maxFileSize {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.</span><span style=\"color:#B392F0\">rotate</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to rotate WAL: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write length prefix (8 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(data))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(w.file, binary.LittleEndian, length); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write length prefix: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write WAL data: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sync for durability</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to sync WAL: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(n </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// Include length prefix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.currentSize </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(n </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> currentOffset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// rotate creates a new WAL file and closes the old one</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">rotate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    oldFile </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create new file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newFilePath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Dir</span><span style=\"color:#E1E4E8\">(w.filePath), </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"wal-</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">.bin\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">()))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newFile, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">OpenFile</span><span style=\"color:#E1E4E8\">(newFilePath, os.O_CREATE</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_RDWR</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_APPEND, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create new WAL file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.file </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newFile</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.filePath </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newFilePath</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.currentSize </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Close old file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> oldFile.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to close old WAL file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Signal cleanup goroutine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> w.rotateSignal </span><span style=\"color:#F97583\">&#x3C;-</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}{}:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close gracefully closes the WAL writer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(w.done)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// rotationMonitor handles cleanup of old WAL files</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">rotationMonitor</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Minute)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">w.rotateSignal:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            w.</span><span style=\"color:#B392F0\">cleanupOldFiles</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            w.</span><span style=\"color:#B392F0\">cleanupOldFiles</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">w.done:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cleanupOldFiles removes WAL files older than retention period</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">cleanupOldFiles</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation for cleaning up old WAL files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Keep last 24 hours of WAL files for recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WALReader reads records from WAL file for replay</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WALReader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewWALReader creates a reader for replaying WAL entries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewWALReader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALReader</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(filePath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to open WAL file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">WALReader</span><span style=\"color:#E1E4E8\">{file: file}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadNext reads the next record from WAL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALReader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadNext</span><span style=\"color:#E1E4E8\">() ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read length prefix</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(r.file, binary.LittleEndian, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">length); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err </span><span style=\"color:#6A737D\">// EOF or error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, length)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.file.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to read WAL data: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">(n) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> length {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"short read: expected </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, length, n)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> data, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Circuit Breaker for Storage Client:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/apm/resilience/circuitbreaker/breaker.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> circuitbreaker</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync/atomic</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrCircuitOpen    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"circuit breaker is open\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrTooManyRequests </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"too many requests in half-open state\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// State represents circuit breaker state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> State</span><span style=\"color:#F97583\"> int32</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateClosed</span><span style=\"color:#B392F0\"> State</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateOpen</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateHalfOpen</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CircuitBreaker implements the circuit breaker pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CircuitBreaker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu                </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state             </span><span style=\"color:#B392F0\">State</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureThreshold  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    successThreshold  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureCount      </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    successCount      </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout           </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastFailure       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    halfOpenMax       </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    halfOpenCount     </span><span style=\"color:#F97583\">int32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    onStateChange     </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">from</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">to</span><span style=\"color:#B392F0\"> State</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Config holds circuit breaker configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Config</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FailureThreshold </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Failures before opening circuit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SuccessThreshold </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Successes before closing circuit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timeout          </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#6A737D\"> // How long to stay open before half-open</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HalfOpenMax      </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Max requests allowed in half-open state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCircuitBreaker creates a new circuit breaker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCircuitBreaker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> Config</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state:            StateClosed,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        failureThreshold: config.FailureThreshold,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        successThreshold: config.SuccessThreshold,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timeout:          config.Timeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        halfOpenMax:      config.HalfOpenMax,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Execute runs the operation with circuit breaker protection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if we should allow the request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cb.</span><span style=\"color:#B392F0\">allowRequest</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrCircuitOpen</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Execute the operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> operation</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Record the result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cb.</span><span style=\"color:#B392F0\">recordResult</span><span style=\"color:#E1E4E8\">(err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// allowRequest determines if a request should be allowed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">allowRequest</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cb.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cb.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> cb.state {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateClosed:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateOpen:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if timeout has elapsed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(cb.lastFailure) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> cb.timeout {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Double-check after acquiring write lock</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cb.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> StateOpen </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(cb.lastFailure) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> cb.timeout {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cb.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateHalfOpen</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cb.halfOpenCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> cb.onStateChange </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    cb.</span><span style=\"color:#B392F0\">onStateChange</span><span style=\"color:#E1E4E8\">(StateOpen, StateHalfOpen)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Now recheck state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateHalfOpen:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allow only limited number of requests in half-open state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> atomic.</span><span style=\"color:#B392F0\">LoadInt32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cb.halfOpenCount) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> int32</span><span style=\"color:#E1E4E8\">(cb.halfOpenMax) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        atomic.</span><span style=\"color:#B392F0\">AddInt32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cb.halfOpenCount, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// recordResult updates circuit breaker state based on operation result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">recordResult</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cb.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cb.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> cb.state {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateClosed:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.failureCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cb.failureCount </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> cb.failureThreshold {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cb.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateOpen</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cb.lastFailure </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> cb.onStateChange </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    cb.</span><span style=\"color:#B392F0\">onStateChange</span><span style=\"color:#E1E4E8\">(StateClosed, StateOpen)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.failureCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\"> // Reset on success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateHalfOpen:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Failure in half-open state -> back to open</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateOpen</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.lastFailure </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.failureCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cb.onStateChange </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cb.</span><span style=\"color:#B392F0\">onStateChange</span><span style=\"color:#E1E4E8\">(StateHalfOpen, StateOpen)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.successCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cb.successCount </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> cb.successThreshold {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Enough successes -> close the circuit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cb.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateClosed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cb.failureCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cb.successCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> cb.onStateChange </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    cb.</span><span style=\"color:#B392F0\">onStateChange</span><span style=\"color:#E1E4E8\">(StateHalfOpen, StateClosed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// State returns current circuit breaker state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">State</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">State</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cb.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cb.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cb.state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetStateChangeCallback sets a callback for state changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetStateChangeCallback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">from</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">to</span><span style=\"color:#B392F0\"> State</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cb.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cb.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cb.onStateChange </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> callback</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Backpressure Manager Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/apm/collector/backpressure/manager.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> backpressure</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Tier represents a backpressure tier with activation thresholds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Tier</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TierNormal</span><span style=\"color:#B392F0\"> Tier</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TierAdaptiveSampling</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TierSelectiveShedding</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TierAggressiveDegradation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TierFailSafe</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Thresholds define when to transition between tiers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Thresholds</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryPercent      </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPULoadPercent     </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueueDepthPercent  </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StorageLatencyMS   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BackpressureManager manages system backpressure state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BackpressureManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentTier  </span><span style=\"color:#B392F0\">Tier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    thresholds   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">Tier</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Thresholds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metrics      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemMetrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stateChan    </span><span style=\"color:#F97583\">chan&#x3C;-</span><span style=\"color:#B392F0\"> StateChange</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastCheck    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    checkInterval </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SystemMetrics contains system metrics for tier decisions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SystemMetrics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryUsedPercent  </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPULoadPercent     </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueueDepthPercent  </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StorageLatencyMS   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpansDroppedPerSec </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ActiveTraces       </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StateChange represents a backpressure state transition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StateChange</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FromTier  </span><span style=\"color:#B392F0\">Tier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ToTier    </span><span style=\"color:#B392F0\">Tier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Reason    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metrics   </span><span style=\"color:#B392F0\">SystemMetrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewBackpressureManager creates a new backpressure manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBackpressureManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">initialThresholds</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">Tier</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Thresholds</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                          checkInterval</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackpressureManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BackpressureManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentTier:  TierNormal,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        thresholds:   initialThresholds,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checkInterval: checkInterval,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins monitoring and tier adjustment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackpressureManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(bm.checkInterval)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            bm.</span><span style=\"color:#B392F0\">evaluateAndAdjust</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ctx.</span><span style=\"color:#B392F0\">Err</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// evaluateAndAdjust evaluates current metrics and adjusts tier if needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackpressureManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">evaluateAndAdjust</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Gather current system metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Memory usage from runtime.MemStats</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - CPU load from gopsutil or runtime metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Queue depth from BufferManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Storage latency from storage client metrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Determine target tier based on thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Compare each metric against thresholds for each tier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Select highest (most severe) tier where any threshold is exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Apply hysteresis: require sustained violation before tier increase</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If tier change is needed:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Log state transition with metrics snapshot</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Update currentTier with write lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Send StateChange to stateChan if configured</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Apply tier-specific actions (call applyTierActions)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If staying in same tier, check if we can downgrade</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check if metrics have been below downgrade thresholds for cooldown period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Gradually step down through tiers (don't jump from Tier 4 to Tier 0 directly)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update lastCheck timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// applyTierActions applies actions specific to the new tier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackpressureManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">applyTierActions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">newTier</span><span style=\"color:#B392F0\"> Tier</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> bm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: For each component that needs adjustment, apply tier-specific changes:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - HeadSampler: adjust sampling rates (Tier 1-4)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - TailSampler: adjust evaluation thresholds (Tier 2-4)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - BufferManager: adjust eviction policy (Tier 2-4)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Pipeline: disable expensive processing (Tier 3-4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update health endpoint status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set degraded status with affected components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Emit metrics for backpressure state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Gauge for current tier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Counter for tier transitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log transition at appropriate level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - INFO for Tier 0-2 transitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - WARN for Tier 3 transitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - ERROR for Tier 4 transitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CurrentTier returns the current backpressure tier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackpressureManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CurrentTier</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Tier</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bm.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> bm.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bm.currentTier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetStateChangeChannel sets the channel for state change notifications</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackpressureManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetStateChangeChannel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ch</span><span style=\"color:#F97583\"> chan&#x3C;-</span><span style=\"color:#B392F0\"> StateChange</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> bm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bm.stateChan </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetRecommendedSamplingRate returns sampling rate recommendation for current tier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackpressureManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetRecommendedSamplingRate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">service</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return appropriate sampling rate based on:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Current tier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Service priority (from configuration)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Historical error rate for this service</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - System-wide load metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#6A737D\"> // Default: keep all traces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ShouldProcessSpan determines if a span should be processed in current tier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackpressureManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ShouldProcessSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">span</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tier </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bm.</span><span style=\"color:#B392F0\">CurrentTier</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: For higher tiers, implement filtering logic:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Tier 2: Check if service is in priority whitelist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Tier 3: Check if span has error status or high latency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Tier 4: Only process spans marked as critical</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Apply sampling based on tier-specific rates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use consistent hashing for deterministic decisions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return true if span should be processed, false to drop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Health Check Endpoint with Degraded States:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/apm/collector/health/handler.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> health</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HealthStatus represents system health status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HealthStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusHealthy</span><span style=\"color:#B392F0\">   HealthStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"healthy\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusDegraded</span><span style=\"color:#B392F0\">  HealthStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"degraded\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusUnhealthy</span><span style=\"color:#B392F0\"> HealthStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unhealthy\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ComponentStatus represents status of an individual component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ComponentStatus</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status  </span><span style=\"color:#B392F0\">HealthStatus</span><span style=\"color:#9ECBFF\"> `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Details </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"details,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Since   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"since\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HealthResponse is the JSON response from health endpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HealthResponse</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status      </span><span style=\"color:#B392F0\">HealthStatus</span><span style=\"color:#9ECBFF\">      `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">         `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Components  []</span><span style=\"color:#B392F0\">ComponentStatus</span><span style=\"color:#9ECBFF\"> `json:\"components,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"message,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DegradedSince </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">      `json:\"degraded_since,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HealthRegistry manages component health status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HealthRegistry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    components </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ComponentStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    overrides  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    startTime  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewHealthRegistry creates a new health registry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewHealthRegistry</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthRegistry</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">HealthRegistry</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        components: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ComponentStatus</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        overrides:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentStatus</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        startTime:  time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterComponent adds a component to health checks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                         checkFunc</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentStatus</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> r.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.overrides[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> checkFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetComponentStatus manually sets a component's status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetComponentStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">status</span><span style=\"color:#B392F0\"> HealthStatus</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                          details</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> r.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.components[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ComponentStatus</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name:    name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Status:  status,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Details: details,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Since:   time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HealthHandler implements the HTTP health check endpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HealthHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">calculateOverallStatus</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">buildHealthResponse</span><span style=\"color:#E1E4E8\">(status)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set appropriate HTTP status code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> httpStatus </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> status {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StatusHealthy:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        httpStatus </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> http.StatusOK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StatusDegraded:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        httpStatus </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> http.StatusOK </span><span style=\"color:#6A737D\">// 200 for degraded, body indicates issue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StatusUnhealthy:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        httpStatus </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> http.StatusServiceUnavailable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(httpStatus)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(response)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// calculateOverallStatus determines overall system health</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">calculateOverallStatus</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">HealthStatus</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> r.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check all registered components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Execute override functions for dynamic checks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Merge with manually set component statuses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Apply health aggregation logic:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If ANY component is \"unhealthy\", overall is \"unhealthy\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If ANY component is \"degraded\" but none are \"unhealthy\", overall is \"degraded\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Otherwise, \"healthy\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Apply minimum uptime requirement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If system started less than 30 seconds ago, return \"degraded\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> StatusHealthy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// buildHealthResponse constructs the health response JSON</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">buildHealthResponse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">overallStatus</span><span style=\"color:#B392F0\"> HealthStatus</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HealthResponse</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Build complete health response with:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Overall status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - All component statuses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Uptime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Version information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Any degradation messages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> HealthResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Status:    overallStatus,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Message:   </span><span style=\"color:#9ECBFF\">\"System operational\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LivenessHandler returns simple liveness check (for Kubernetes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LivenessHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Simple check - is the process running?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Always return 200 unless process is terminally broken</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusOK)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ok\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadinessHandler returns readiness check (for Kubernetes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadinessHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if system is ready to receive traffic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return 200 if ready, 503 if not</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">calculateOverallStatus</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> status </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> StatusUnhealthy {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusServiceUnavailable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not ready\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusOK)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ready\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Go-Specific Error Handling Patterns:</strong></p>\n<ol>\n<li><strong>Context Cancellation for Timeouts</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Always pass context through call chains</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">Collector) </span><span style=\"color:#B392F0\">StoreSpan</span><span style=\"color:#E1E4E8\">(ctx context.Context, span models.Span) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Use context for timeouts and cancellation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithTimeout</span><span style=\"color:#E1E4E8\">(ctx, c.config.Storage.Timeout)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       defer</span><span style=\"color:#B392F0\"> cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#E1E4E8\"> c.storage.</span><span style=\"color:#B392F0\">WriteSpan</span><span style=\"color:#E1E4E8\">(ctx, span)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Error Wrapping with Context</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Use fmt.Errorf with %w for wrapping errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> processBatch</span><span style=\"color:#E1E4E8\">(batch []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       spans, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseSpans</span><span style=\"color:#E1E4E8\">(batch)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to parse batch: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       for</span><span style=\"color:#E1E4E8\"> _, span </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> spans {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> validateSpan</span><span style=\"color:#E1E4E8\">(span); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">               // Add span context to error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid span </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, span.SpanID, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Structured Error Types</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Define error types for different failure modes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   type</span><span style=\"color:#B392F0\"> StorageError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       Op      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       Err     </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       RetryAfter </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#E1E4E8\"> (e </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">StorageError) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"storage error during </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, e.Op, e.Err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#E1E4E8\"> (e </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">StorageError) </span><span style=\"color:#B392F0\">Unwrap</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#E1E4E8\"> e.Err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   // Check error types for recovery decisions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">Is</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">StorageError</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       var</span><span style=\"color:#E1E4E8\"> storageErr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StorageError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">As</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">storageErr) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           time.</span><span style=\"color:#B392F0\">Sleep</span><span style=\"color:#E1E4E8\">(storageErr.RetryAfter)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">           // Retry the operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Graceful Shutdown with Context</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Implement graceful shutdown in main</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       collector, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> collector.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(config)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">/* handle */</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Start collector in background</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> collector.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(ctx); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               log.</span><span style=\"color:#B392F0\">Fatalf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Collector failed: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Handle OS signals</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       sigChan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Signal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       signal.</span><span style=\"color:#B392F0\">Notify</span><span style=\"color:#E1E4E8\">(sigChan, syscall.SIGINT, syscall.SIGTERM)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       &#x3C;-</span><span style=\"color:#E1E4E8\">sigChan </span><span style=\"color:#6A737D\">// Wait for signal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Start graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       log.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Shutting down gracefully...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Give components time to clean up</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       shutdownCtx, shutdownCancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithTimeout</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       defer</span><span style=\"color:#B392F0\"> shutdownCancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Wait for shutdown or timeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       &#x3C;-</span><span style=\"color:#E1E4E8\">shutdownCtx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       log.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Shutdown complete\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Spans being dropped under load</strong></td>\n<td>Backpressure tier activation</td>\n<td>1. Check <code>/healthz</code> endpoint for degraded status<br>2. Examine backpressure manager logs for tier transitions<br>3. Monitor <code>apm_backpressure_current_tier</code> metric</td>\n<td>1. Increase collector resources<br>2. Adjust backpressure thresholds<br>3. Optimize span processing pipeline</td>\n</tr>\n<tr>\n<td><strong>High memory usage with frequent GC</strong></td>\n<td>Buffer growth or memory leak</td>\n<td>1. Use <code>pprof</code> to capture heap profile<br>2. Check <code>BufferManager</code> trace count<br>3. Look for unbounded maps or slices</td>\n<td>1. Reduce <code>maxTraceDuration</code><br>2. Implement more aggressive eviction<br>3. Fix memory leaks in span processing</td>\n</tr>\n<tr>\n<td><strong>Storage timeouts causing cascading failures</strong></td>\n<td>Storage overload or network issues</td>\n<td>1. Check storage health metrics<br>2. Examine circuit breaker state<br>3. Look for WAL growth indicating write failures</td>\n<td>1. Increase storage capacity<br>2. Adjust circuit breaker thresholds<br>3. Implement storage connection pooling</td>\n</tr>\n<tr>\n<td><strong>Clock skew warnings in logs</strong></td>\n<td>NTP sync issues or VM clock drift</td>\n<td>1. Compare timestamps from different services in same trace<br>2. Check system clock sync status<br>3. Look for negative durations</td>\n<td>1. Implement NTP on all hosts<br>2. Use collector clock normalization<br>3. Warn users about misconfigured hosts</td>\n</tr>\n<tr>\n<td><strong>Service map showing impossible latencies</strong></td>\n<td>Async spans or incorrect parent-child links</td>\n<td>1. Examine span parent relationships<br>2. Check for async operation markers<br>3. Look for clock correction artifacts</td>\n<td>1. Improve async span detection<br>2. Implement span relationship validation<br>3. Apply timestamp normalization corrections</td>\n</tr>\n<tr>\n<td><strong>WAL files accumulating without cleanup</strong></td>\n<td>Storage recovery failures or configuration issues</td>\n<td>1. Check WAL replayer logs for errors<br>2. Verify storage connectivity<br>3. Check disk space on collector nodes</td>\n<td>1. Fix storage connection issues<br>2. Implement WAL cleanup job<br>3. Monitor disk usage with alerts</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing error handling and backpressure mechanisms, verify resilience with these tests:</p>\n<ol>\n<li><strong>Storage Failure Simulation</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Stop storage backend</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   docker-compose</span><span style=\"color:#9ECBFF\"> stop</span><span style=\"color:#9ECBFF\"> apm-storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Send spans - should see WAL writes but no errors</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> test/loadgen/main.go</span><span style=\"color:#79B8FF\"> --spans-per-sec=100</span><span style=\"color:#79B8FF\"> --duration=30s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Check WAL directory for new files</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /var/lib/apm/wal/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Restart storage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   docker-compose</span><span style=\"color:#9ECBFF\"> start</span><span style=\"color:#9ECBFF\"> apm-storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Verify spans are replayed from WAL</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   tail</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> /var/log/apm/collector.log</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"WAL replay\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Query for test traces - should appear within 60 seconds</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/api/traces?service=test-service\"</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Backpressure Activation Test</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Generate overload traffic</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> test/loadgen/main.go</span><span style=\"color:#79B8FF\"> --spans-per-sec=5000</span><span style=\"color:#79B8FF\"> --duration=60s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Monitor health endpoint for tier transitions</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   watch</span><span style=\"color:#79B8FF\"> -n1</span><span style=\"color:#9ECBFF\"> 'curl -s http://localhost:8080/healthz | jq .'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Check metrics for backpressure state</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/metrics</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> backpressure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Verify spans are being sampled more aggressively</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/metrics</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> spans_dropped</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Error Recovery Verification</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Send malformed spans</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/v1/traces</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -d</span><span style=\"color:#9ECBFF\"> '{\"invalid\": \"data\"}'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should receive 400 with error details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Collector should continue processing other requests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Send valid spans after error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> test/loadgen/main.go</span><span style=\"color:#79B8FF\"> --spans-per-sec=10</span><span style=\"color:#79B8FF\"> --duration=5s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Verify normal processing resumes</span></span></code></pre></div>\n\n<p>Expected signs of correct implementation:</p>\n<ul>\n<li>Collector remains responsive during storage outages</li>\n<li>Memory usage stays within configured bounds under load</li>\n<li>Health endpoint accurately reflects system state</li>\n<li>WAL files are created during outages and cleaned up after recovery</li>\n<li>No panics or deadlocks under stress conditions</li>\n</ul>\n<p>Signs of incorrect implementation:</p>\n<ul>\n<li>Collector crashes or becomes unresponsive under load</li>\n<li>Memory grows unbounded until OOM kill</li>\n<li>Spans are lost permanently during storage outages</li>\n<li>Health endpoint shows &quot;healthy&quot; when components are failing</li>\n<li>WAL files accumulate indefinitely without cleanup</li>\n</ul>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section applies to all five milestones, providing a comprehensive testing strategy that verifies each component and the system as a whole.</p>\n</blockquote>\n<h2 id=\"12-testing-strategy\">12. Testing Strategy</h2>\n<p>The APM Tracing System is a complex distributed application that must be reliable under heavy load, process data correctly even when it arrives out of order, and degrade gracefully when stressed. A robust testing strategy is not a luxury but a necessity. We must verify not only that the system works under ideal conditions, but that it handles the messy reality of production—network failures, clock skew, malformed data, and traffic spikes—without data loss or cascading failures.</p>\n<p>This strategy is built on a foundation of <strong>property-based testing</strong> for core data invariants, <strong>chaos testing</strong> for resilience, and <strong>concrete milestone checkpoints</strong> that provide clear, binary pass/fail criteria for each development stage.</p>\n<h3 id=\"testing-approaches-unit-integration-and-load\">Testing Approaches: Unit, Integration, and Load</h3>\n<p>Testing in the APM system occurs at three complementary levels, each with distinct goals and techniques.</p>\n<p><strong>Mental Model: The Building Inspection, Fire Drill, and Stress Test</strong>\nThink of testing our system like ensuring a new skyscraper is safe. <strong>Unit tests</strong> are like inspecting individual steel beams and concrete pillars—verifying each component in isolation meets its specification. <strong>Integration tests</strong> are like a fire drill—testing how people (components) move through stairwells and exits (APIs and data flows) in a coordinated way under simulated emergency (failure) conditions. <strong>Load tests</strong> are the structural stress test—applying massive weight (traffic) to see if the building sways within acceptable limits or collapses, revealing bottlenecks and breaking points.</p>\n<h4 id=\"unit-testing-verifying-component-invariants\">Unit Testing: Verifying Component Invariants</h4>\n<p>Unit tests focus on the smallest testable units of code—typically individual functions or methods—in complete isolation. Mocks and stubs are used heavily to control the environment and dependencies.</p>\n<p><strong>Key Areas for Unit Testing:</strong></p>\n<ol>\n<li><strong>Data Structure Validation:</strong> Ensure that <code>Span</code>, <code>Trace</code>, and other core types enforce their invariants (e.g., a <code>Span</code>&#39;s <code>EndTime</code> must be after its <code>StartTime</code>).</li>\n<li><strong>Algorithm Correctness:</strong> Test the step-by-step logic of critical algorithms with known inputs and expected outputs.<ul>\n<li><strong>Trace Assembly:</strong> Given a specific, unordered set of <code>Span</code> objects, verify that <code>TraceAssembler.AssembleTrace</code> produces the correct hierarchical tree structure.</li>\n<li><strong>Sampling Decisions:</strong> For a given <code>traceID</code> and sampling rate, the <code>ConsistentSampler.ShouldSample</code> method must return a deterministic, predictable result.</li>\n<li><strong>Percentile Calculation:</strong> Feed a known sequence of latency values into <code>TDigestMetric</code> and verify that <code>Quantile(0.95)</code> returns a value within an acceptable error margin.</li>\n</ul>\n</li>\n<li><strong>State Machine Transitions:</strong> Test that the <code>CircuitBreaker</code> and <code>BackpressureManager</code> transition between states (<code>StateClosed</code>, <code>StateOpen</code>, <code>TierNormal</code>, <code>TierAdaptiveSampling</code>) exactly when the defined thresholds are crossed.</li>\n<li><strong>Error Handling:</strong> Verify that functions return the expected errors for invalid inputs (e.g., <code>StoreSpan</code> with an empty <code>TraceID</code>) or when dependencies fail (e.g., a mocked storage layer returns <code>io.EOF</code>).</li>\n</ol>\n<p><strong>Property-Based Testing for Core Logic:</strong>\nFor algorithms where the output space is large or complex, we employ property-based testing (using a library like <code>github.com/leanovate/gopter</code> for Go). Instead of writing individual example-based tests, we define <em>properties</em> that must <em>always</em> hold true for any valid input, and the framework generates hundreds of random test cases.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Property to Test</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>TraceAssembler</code></td>\n<td align=\"left\"><strong>Trace Completeness:</strong></td>\n<td align=\"left\">For any generated set of spans belonging to the same trace, if <code>IsTraceComplete</code> returns <code>true</code>, then the assembled trace must contain exactly those spans, and the trace&#39;s <code>StartTime</code> must be the earliest span start, and <code>EndTime</code> the latest span end.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ConsistentSampler</code></td>\n<td align=\"left\"><strong>Determinism &amp; Rate Adherence:</strong></td>\n<td align=\"left\">For any <code>traceID</code> and sampling <code>rate</code>, the <code>ShouldSample</code> decision must be identical for all calls. Over a large number of random <code>traceID</code>s, the ratio of <code>true</code> decisions must converge to <code>rate</code> within a small statistical error.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>TDigestMetric</code></td>\n<td align=\"left\"><strong>Percentile Monotonicity:</strong></td>\n<td align=\"left\">For any set of added values, the computed quantiles must be monotonically non-decreasing: <code>Quantile(0.50)</code> ≤ <code>Quantile(0.95)</code> ≤ <code>Quantile(0.99)</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>BufferManager</code></td>\n<td align=\"left\"><strong>Capacity Bound:</strong></td>\n<td align=\"left\">No matter the order or timing of <code>AddSpan</code> calls, the total number of spans stored in the <code>BufferManager</code> must never exceed its configured <code>maxSize</code>.</td>\n</tr>\n</tbody></table>\n<p><strong>ADR: Mocking Strategy for External Dependencies</strong></p>\n<blockquote>\n<p><strong>Decision: Use Interface-Based Mocking with Generated Test Doubles</strong></p>\n<ul>\n<li><strong>Context:</strong> Our components depend on external systems (storage, network) and other internal modules. We need to isolate units for testing without bringing up entire systems.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Hand-written mocks:</strong> Create concrete test types that implement our defined interfaces (e.g., <code>storage.Writer</code>).</li>\n<li><strong>Mock generation tools:</strong> Use a tool like <code>mockgen</code> (for Go) to automatically generate mock implementations from interfaces.</li>\n<li><strong>Integration-heavy unit tests:</strong> Use lightweight, real implementations (e.g., an in-memory map for storage).</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Use <strong>interface-based design</strong> combined with <strong>generated mocks</strong> for complex dependencies, and <strong>lightweight real implementations</strong> (fakes) for simpler ones.</li>\n<li><strong>Rationale:</strong> Generated mocks reduce boilerplate and are consistent. They allow us to easily set expectations (e.g., &quot;<code>StoreSpan</code> should be called exactly once with these arguments&quot;) and simulate failures. For simpler dependencies like an in-memory store, a fake is easier to reason about and can be used in integration tests as well.</li>\n<li><strong>Consequences:</strong> Developers must define clear interfaces. The build process requires a mock generation step. Tests become tightly coupled to mock expectations, which can make them brittle if interactions change frequently.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Hand-written mocks</td>\n<td align=\"left\">Full control, no extra tooling.</td>\n<td align=\"left\">High boilerplate, tedious to maintain for large interfaces.</td>\n<td align=\"left\">For simple, stable interfaces.</td>\n</tr>\n<tr>\n<td align=\"left\">Generated mocks (mockgen)</td>\n<td align=\"left\">Low maintenance, consistent patterns, powerful expectation API.</td>\n<td align=\"left\">Adds build step, can produce verbose tests, learning curve.</td>\n<td align=\"left\"><strong>Yes</strong>, for core external dependencies (Storage, WAL).</td>\n</tr>\n<tr>\n<td align=\"left\">Lightweight real implementations (Fakes)</td>\n<td align=\"left\">Realistic behavior, can be used in integration tests.</td>\n<td align=\"left\">May hide bugs if the fake doesn&#39;t perfectly emulate the real component.</td>\n<td align=\"left\"><strong>Yes</strong>, for internal abstractions like <code>EdgeStorage</code>.</td>\n</tr>\n</tbody></table>\n<h4 id=\"integration-testing-verifying-component-interaction\">Integration Testing: Verifying Component Interaction</h4>\n<p>Integration tests verify that multiple components work together correctly. They use real implementations for some components and mocked or faked versions for others (like external services).</p>\n<p><strong>Key Integration Test Scenarios:</strong></p>\n<ol>\n<li><strong>End-to-End Ingestion Pipeline:</strong> Send a batch of OTLP-formatted spans via HTTP to the <code>OTLPHandler</code>. Verify that they flow through the <code>Pipeline</code> (validation, buffering, sampling) and are eventually persisted by the <code>storage.Writer</code> (using an in-memory or test-database implementation).</li>\n<li><strong>Service Map Construction:</strong> Feed a set of spans representing calls between services <code>A-&gt;B</code> and <code>B-&gt;C</code> into the <code>GraphBuilder</code>. Verify that <code>BuildCurrentGraph</code> produces a <code>ServiceGraph</code> with three <code>ServiceNode</code>s and two <code>ServiceEdge</code>s with correct aggregated metrics.</li>\n<li><strong>Cross-Component Error Propagation:</strong> Simulate a failure in the storage layer and verify that the <code>CircuitBreaker</code> on the <code>Pipeline</code> trips open, causing subsequent span processing attempts to fail fast with <code>ErrCircuitOpen</code>, and that the system&#39;s health endpoint (<code>HealthHandler</code>) reflects a <code>StatusDegraded</code> state.</li>\n<li><strong>Context Propagation:</strong> Use the <code>APM SDK</code>&#39;s <code>Tracer</code> to instrument a simple HTTP client and server in the same test process. Verify that the <code>TraceID</code> created on the client is correctly propagated via headers and appears in the span generated by the server, linking them in the collected trace.</li>\n</ol>\n<p><strong>Chaos Testing for Resilience:</strong>\nChaos testing involves deliberately injecting failures into a running system to verify its resilience and recovery mechanisms. These are run less frequently, often in a dedicated staging environment.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Failure Injection</th>\n<th align=\"left\">Expected System Behavior</th>\n<th align=\"left\">Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Kill the <code>Collector</code> process</strong> while spans are being ingested.</td>\n<td align=\"left\">The WAL (<code>WALWriter</code>) should have recorded spans before the crash. Upon restart, the <code>WALReader</code> should replay unprocessed spans, and no data should be lost.</td>\n<td align=\"left\">Compare span count before crash and after recovery.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Introduce network latency or packet loss</strong> between the SDK and Collector.</td>\n<td align=\"left\">The SDK&#39;s <code>SpanExporter</code> should implement retries with exponential backoff. The <code>CircuitBreaker</code> in the Collector&#39;s ingress may open if failures persist, shedding load gracefully.</td>\n<td align=\"left\">Verify spans are eventually received despite temporary network issues.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Fill the disk</strong> used by the storage backend.</td>\n<td align=\"left\">The storage layer should return errors. The <code>BackpressureManager</code> should escalate to <code>TierAggressiveDegradation</code> or <code>TierFailSafe</code>, dramatically increasing sampling rates or rejecting non-critical traffic, preventing a complete crash.</td>\n<td align=\"left\">Monitor system logs for escalation events and verify it remains responsive for health checks.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Simulate clock skew</strong> by feeding spans with timestamps from wildly different system times.</td>\n<td align=\"left\">The <code>TraceAssembler</code> should use a watermark algorithm or buffer TTL to eventually assemble traces correctly, albeit with delay. Late-arriving spans beyond the <code>maxTraceDuration</code> should be logged and discarded.</td>\n<td align=\"left\">Verify that traces with correct internal relationships are still assembled, even if out-of-order.</td>\n</tr>\n</tbody></table>\n<h4 id=\"load-and-performance-testing-verifying-scalability\">Load and Performance Testing: Verifying Scalability</h4>\n<p>Load tests verify that the system meets its performance requirements (e.g., 1000 spans/sec) and identify bottlenecks under stress. These tests require careful planning and monitoring.</p>\n<p><strong>Key Performance Tests:</strong></p>\n<ol>\n<li><strong>Ingestion Throughput:</strong> Ramp up the rate of span submission to the Collector&#39;s OTLP endpoint until the system&#39;s response latency exceeds the 100ms SLA or spans start being dropped (monitored via <code>PipelineMetrics.SpansDropped</code>). Plot the relationship between input rate, CPU/memory usage, and latency.</li>\n<li><strong>Concurrent Trace Assembly:</strong> Generate a high volume of complex, multi-span traces where spans arrive out of order. Measure the memory footprint of the <code>BufferManager</code> and the accuracy of trace completion decisions.</li>\n<li><strong>Sampling Overhead:</strong> Measure the CPU cost of <code>HeadSampler.Decide</code> and <code>TailSampler.EvaluateTrace</code> at high decision rates. Ensure sampling logic does not become the bottleneck.</li>\n<li><strong>Query Performance:</strong> With a large dataset of stored traces, measure the latency of <code>GetTraceByID</code>, <code>GetTracesByService</code>, and <code>BuildCurrentGraph</code> for service maps under increasing data volumes.</li>\n</ol>\n<p><strong>Tooling:</strong> Use tools like Apache Bench (<code>ab</code>), <code>wrk</code>, or custom Go load-test clients to generate traffic. Use the application&#39;s own metrics (<code>PipelineMetrics</code>, <code>HeadSamplerStats</code>) and system-level profiling (Go&#39;s <code>pprof</code>) to identify hotspots.</p>\n<h3 id=\"milestone-checkpoints-and-verification\">Milestone Checkpoints and Verification</h3>\n<p>Each milestone has concrete acceptance criteria. The following checklists provide verifiable, binary steps to confirm functionality before moving on. Treat these as the &quot;definition of done&quot; for each phase.</p>\n<h4 id=\"milestone-1-trace-collection\">Milestone 1: Trace Collection</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Checkpoint</th>\n<th align=\"left\">Verification Steps</th>\n<th align=\"left\">Expected Outcome / Pass Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Ingestion API Accepts Spans</strong></td>\n<td align=\"left\">1. Start the Collector with an in-memory storage backend.<br>2. Use <code>curl</code> or a test client to send a valid OTLP/JSON span payload to <code>POST /v1/traces</code>.<br>3. Check the HTTP response status and timing.</td>\n<td align=\"left\">Response status is <code>200 OK</code>. Response time is &lt; 100ms.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Spans are Parsed &amp; Validated</strong></td>\n<td align=\"left\">1. Send a span with an invalid <code>TraceID</code> (e.g., empty string).<br>2. Send a span with a future <code>StartTime</code>.<br>3. Send a valid span with attributes and events.</td>\n<td align=\"left\">Invalid spans are rejected with <code>400 Bad Request</code>. Valid span is accepted and its internal representation matches the sent data.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Spans are Indexed &amp; Retrievable</strong></td>\n<td align=\"left\">1. Send 10 spans belonging to 2 different traces.<br>2. Call <code>GetTraceByID</code> for each trace ID via a test client or admin API.<br>3. Call <code>GetTracesByService</code> for the involved service name.</td>\n<td align=\"left\">Each call returns the correct, complete set of spans for that trace or service. Spans maintain their parent-child relationships.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Throughput Requirement Met</strong></td>\n<td align=\"left\">1. Write a load test client that sustains 1000 spans/sec for 60 seconds.<br>2. Monitor the Collector&#39;s logs and metrics for errors or drops.<br>3. After the test, query for the total number of spans stored.</td>\n<td align=\"left\">No errors or warnings in logs. <code>SpansDropped</code> metric is zero. Total stored span count is within 1% of 60,000 (accounting for sampling if enabled).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Late-Arriving Span Handling</strong></td>\n<td align=\"left\">1. Send Span B (child) before Span A (parent).<br>2. Wait longer than the buffer&#39;s typical flush time.<br>3. Send Span A.<br>4. Query for the complete trace.</td>\n<td align=\"left\">The trace is eventually assembled and returned correctly, demonstrating the buffer held Span B until its parent arrived.</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-2-service-map\">Milestone 2: Service Map</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Checkpoint</th>\n<th align=\"left\">Verification Steps</th>\n<th align=\"left\">Expected Outcome / Pass Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Dependency Extraction</strong></td>\n<td align=\"left\">1. Feed spans representing a chain of calls: <code>ServiceA -&gt; ServiceB -&gt; ServiceC</code>.<br>2. Run the <code>EdgeAggregator.ProcessSpan</code> logic offline or via test.<br>3. Inspect the generated <code>ServiceEdge</code> objects.</td>\n<td align=\"left\">Two edges are created: (<code>ServiceA</code>, <code>ServiceB</code>) and (<code>ServiceB</code>, <code>ServiceC</code>). Each edge&#39;s <code>TotalCalls</code> is correct.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Graph Construction</strong></td>\n<td align=\"left\">1. Feed a more complex set of spans with multiple callers to the same service and some error responses.<br>2. Call <code>GraphBuilder.BuildCurrentGraph</code>.<br>3. Inspect the resulting <code>ServiceGraph</code>.</td>\n<td align=\"left\">The graph contains the correct number of nodes and edges. Edges for calls with errors have <code>ErrorRate</code> &gt; 0. The <code>P95Latency</code> field is populated.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Topology Change Detection</strong></td>\n<td align=\"left\">1. Build a graph for time window T1.<br>2. Feed new spans where a new <code>ServiceD</code> appears and calls <code>ServiceA</code>.<br>3. Build a graph for the next window T2.<br>4. Call <code>DetectTopologyChanges</code>.</td>\n<td align=\"left\">The change detection correctly identifies <code>ServiceD</code> as a new node and a new edge (<code>ServiceD</code>, <code>ServiceA</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Real-Time Update</strong></td>\n<td align=\"left\">1. Start a live visualization endpoint or test that consumes the graph.<br>2. Continuously feed spans from a changing service topology.<br>3. Monitor the graph output.</td>\n<td align=\"left\">The graph updates within the configured refresh interval (e.g., 1 minute) to reflect new services and dependencies.</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-3-trace-sampling\">Milestone 3: Trace Sampling</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Checkpoint</th>\n<th align=\"left\">Verification Steps</th>\n<th align=\"left\">Expected Outcome / Pass Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Head-Based Sampling Rate Adherence</strong></td>\n<td align=\"left\">1. Configure a <code>HeadSampler</code> with a global rate of 0.1 (10%).<br>2. Send 10,000 traces with unique IDs.<br>3. Collect the <code>HeadSamplerStats</code>.</td>\n<td align=\"left\">The ratio of <code>TracesSampled</code> to <code>TotalTraces</code> is between 9% and 11%.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Consistent Sampling per Trace</strong></td>\n<td align=\"left\">1. Send all spans for a single trace (5 spans) one by one.<br>2. Check the sampling decision logged for each span (or a tag on the span).</td>\n<td align=\"left\">All 5 spans have the same sampling decision (<code>keep</code>/<code>drop</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Tail-Based Sampling Override</strong></td>\n<td align=\"left\">1. Configure a <code>TailSampler</code> with a rule to keep traces with <code>Status.Code</code> = <code>ERROR</code>.<br>2. Send a trace that was initially dropped by head-sampling (rate=0) but contains an error span.<br>3. Check the final storage.</td>\n<td align=\"left\">The error trace is present in storage, demonstrating the tail-sampler overrode the head decision.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Per-Service Sampling Configuration</strong></td>\n<td align=\"left\">1. Configure <code>serviceRates</code>: <code>&quot;frontend&quot;</code>: 1.0, <code>&quot;backend&quot;</code>: 0.01.<br>2. Send 1000 traces from each service.<br>3. Check stats per service.</td>\n<td align=\"left\">Nearly all <code>frontend</code> traces are kept; only ~1% of <code>backend</code> traces are kept.</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-4-performance-analytics-amp-anomaly-detection\">Milestone 4: Performance Analytics &amp; Anomaly Detection</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Checkpoint</th>\n<th align=\"left\">Verification Steps</th>\n<th align=\"left\">Expected Outcome / Pass Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Percentile Calculation (t-digest)</strong></td>\n<td align=\"left\">1. Feed 10,000 latency values with a known distribution (e.g., uniformly distributed between 100ms and 1000ms) into a <code>TDigestMetric</code>.<br>2. Query <code>p50</code>, <code>p95</code>, <code>p99</code>.<br>3. Compare to theoretical values.</td>\n<td align=\"left\">Calculated percentiles are within 1% of the expected values (e.g., p95 ~= 955ms).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Anomaly Detection Trigger</strong></td>\n<td align=\"left\">1. Establish a baseline of latencies for a service (~100ms).<br>2. Inject a series of latencies spiking to 500ms.<br>3. Run <code>Detector.CheckMetric</code>.<br>4. Inspect <code>AnomalyResult</code>.</td>\n<td align=\"left\">Anomalies are detected with high <code>Confidence</code>. The <code>Severity</code> is appropriate (e.g., <code>&quot;high&quot;</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Time-Series Storage &amp; Retrieval</strong></td>\n<td align=\"left\">1. Write <code>MetricPoint</code>s for various services over a 1-hour period.<br>2. Query the <code>MemoryStore</code> for a specific 15-minute window.<br>3. Query for a service that has no data in that window.</td>\n<td align=\"left\">The correct subset of points is returned for the first query. The second query returns an empty slice (not an error).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Regression Alerting</strong></td>\n<td align=\"left\">1. Set up a test alerting channel (e.g., log file).<br>2. Trigger an anomaly as above.<br>3. Monitor the channel.</td>\n<td align=\"left\">An alert message containing the <code>AnomalyResult</code> details is emitted.</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-5-apm-sdk-amp-auto-instrumentation\">Milestone 5: APM SDK &amp; Auto-Instrumentation</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Checkpoint</th>\n<th align=\"left\">Verification Steps</th>\n<th align=\"left\">Expected Outcome / Pass Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>HTTP Context Propagation</strong></td>\n<td align=\"left\">1. Instrument an HTTP client and server using the SDK.<br>2. Make a request from client to server.<br>3. Collect the trace from the Collector.<br>4. Inspect the trace structure.</td>\n<td align=\"left\">The trace contains two spans (client and server) linked by parent-child relationship. The <code>TraceID</code> is identical in both spans.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Database Query Tracing</strong></td>\n<td align=\"left\">1. Instrument a SQL database driver.<br>2. Execute a <code>SELECT</code> query.<br>3. Collect the resulting span.</td>\n<td align=\"left\">A span is created with the <code>Name</code> containing the SQL operation. The span&#39;s attributes contain the sanitized query string and execution time.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Framework Middleware</strong></td>\n<td align=\"left\">1. Add the Gin middleware to a simple Go web server.<br>2. Make an HTTP request to a registered route.<br>3. Collect the trace.</td>\n<td align=\"left\">A span is created for the incoming request, with the <code>Name</code> as the route path (e.g., <code>GET /api/users</code>). The span&#39;s duration matches the request handling time.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Async Context Propagation</strong></td>\n<td align=\"left\">1. In an instrumented handler, launch a goroutine that creates a child span.<br>2. Collect the trace.</td>\n<td align=\"left\">The child span created in the goroutine is correctly linked as a child of the handler span, demonstrating the context was propagated.</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (For Learning)</th>\n<th align=\"left\">Advanced Option (For Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Unit Testing Framework</td>\n<td align=\"left\">Go&#39;s built-in <code>testing</code> package + <code>testify/assert</code></td>\n<td align=\"left\">Go&#39;s <code>testing</code> + <code>testify/suite</code> for test suites</td>\n</tr>\n<tr>\n<td align=\"left\">Mock Generation</td>\n<td align=\"left\">Hand-written fakes for key interfaces</td>\n<td align=\"left\"><code>mockgen</code> (from <code>github.com/golang/mock</code>)</td>\n</tr>\n<tr>\n<td align=\"left\">Property-Based Testing</td>\n<td align=\"left\"><code>github.com/leanovate/gopter</code></td>\n<td align=\"left\"><code>github.com/leanovate/gopter</code> with custom generators</td>\n</tr>\n<tr>\n<td align=\"left\">Load Testing</td>\n<td align=\"left\">Custom Go program using goroutines</td>\n<td align=\"left\"><code>k6</code> or <code>ghz</code> (for gRPC)</td>\n</tr>\n<tr>\n<td align=\"left\">Code Coverage</td>\n<td align=\"left\"><code>go test -cover</code></td>\n<td align=\"left\"><code>go test -coverprofile</code> + <code>go tool cover -html=</code></td>\n</tr>\n<tr>\n<td align=\"left\">Benchmarking</td>\n<td align=\"left\">Go&#39;s built-in benchmarking (<code>go test -bench .</code>)</td>\n<td align=\"left\"><code>go test -bench . -benchmem</code> + pprof profiling</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure for Tests</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>apm-tracing-system/\n├── cmd/\n│   └── collector/\n│       └── main.go\n├── internal/\n│   ├── ingestion/               # Milestone 1\n│   │   ├── pipeline.go\n│   │   ├── pipeline_test.go     # Unit tests\n│   │   ├── handler_otlp.go\n│   │   └── handler_otlp_test.go\n│   ├── storage/\n│   │   ├── memory.go            # Fake for testing\n│   │   ├── memory_test.go\n│   │   └── writer.go            # Interface\n│   ├── sampling/                # Milestone 3\n│   │   ├── head_sampler.go\n│   │   ├── head_sampler_test.go\n│   │   ├── property_test.go     # Property-based tests\n│   │   └── tail_sampler.go\n│   ├── servicegraph/            # Milestone 2\n│   │   ├── builder.go\n│   │   ├── builder_integration_test.go\n│   │   └── aggregator_test.go\n│   ├── analytics/               # Milestone 4\n│   │   ├── tdigest_metric.go\n│   │   ├── tdigest_metric_test.go\n│   │   └── detector_test.go\n│   └── sdk/                     # Milestone 5\n│       ├── tracer.go\n│       ├── tracer_integration_test.go\n│       └── http_client_test.go\n├── test/                        # Integration &amp; load tests\n│   ├── integration/\n│   │   ├── collector_test.go    # Spans ingestion -&gt; storage\n│   │   └── service_map_test.go\n│   ├── load/\n│   │   └── span_throughput.go   # Load test program\n│   └── chaos/\n│       └── kill_collector_test.go\n└── pkg/\n    └── models/                  # Data models\n        ├── span.go\n        └── span_test.go         # Validation logic tests</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code: Mock Span Generator</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// testutils/generator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> testutils</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/hex</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-org/apm-tracing-system/pkg/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateSpan creates a deterministic or random span for testing.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> GenerateSpan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">parentSpanID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">serviceName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> traceID </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        traceID </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> generateID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spanID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> generateID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">randomInt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> time.Millisecond)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    duration </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">randomInt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">500</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> time.Millisecond</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SpanID:       spanID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TraceID:      traceID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ParentSpanID: parentSpanID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name:         operation,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ServiceName:  serviceName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StartTime:    start,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Duration:     duration,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Attributes:   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"true\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Status:       </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SpanStatus</span><span style=\"color:#E1E4E8\">{Code: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#6A737D\">// OK</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateTrace generates a complete trace with a root span and n children.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> GenerateTrace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">serviceName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">childCount</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    traceID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> generateID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> GenerateSpan</span><span style=\"color:#E1E4E8\">(traceID, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, serviceName, </span><span style=\"color:#9ECBFF\">\"root-operation\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spans </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{root}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> childCount; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        child </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> GenerateSpan</span><span style=\"color:#E1E4E8\">(traceID, root.SpanID, serviceName, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                             \"child-operation\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        spans </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(spans, child)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> spans</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> generateID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, length</span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// 2 hex chars per byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rand.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hex.</span><span style=\"color:#B392F0\">EncodeToString</span><span style=\"color:#E1E4E8\">(bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> randomInt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">max</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // simplified deterministic random for tests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> max</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code for Key Unit Tests</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/sampling/head_sampler_property_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> sampling</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/leanovate/gopter</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/leanovate/gopter/gen</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/leanovate/gopter/prop</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestConsistentSampler_PropertyBased</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> gopter.</span><span style=\"color:#B392F0\">DefaultTestParameters</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters.MinSuccessfulTests </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> gopter.</span><span style=\"color:#B392F0\">NewProperties</span><span style=\"color:#E1E4E8\">(parameters)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties.</span><span style=\"color:#B392F0\">Property</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"deterministic sampling for same traceID\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prop.</span><span style=\"color:#B392F0\">ForAll</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rate</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sampler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewConsistentSampler</span><span style=\"color:#E1E4E8\">(rate)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                decision1 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sampler.</span><span style=\"color:#B392F0\">ShouldSample</span><span style=\"color:#E1E4E8\">(traceID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                decision2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sampler.</span><span style=\"color:#B392F0\">ShouldSample</span><span style=\"color:#E1E4E8\">(traceID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 1: The decision for the same traceID should be identical</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> decision1 </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> decision2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gen.</span><span style=\"color:#B392F0\">AlphaString</span><span style=\"color:#E1E4E8\">(),  </span><span style=\"color:#6A737D\">// Generates random traceIDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gen.</span><span style=\"color:#B392F0\">Float64Range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#6A737D\">// Generates random rates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties.</span><span style=\"color:#B392F0\">Property</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sampling rate converges to configured rate\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prop.</span><span style=\"color:#B392F0\">ForAll</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rate</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sampler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewConsistentSampler</span><span style=\"color:#E1E4E8\">(rate)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                samples </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 10000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                kept </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 2: Generate a large set of unique traceIDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 3: Call ShouldSample for each traceID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 4: Count how many were kept</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 5: The ratio kept/samples should be within 1% of 'rate'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // return math.Abs(float64(kept)/float64(samples) - rate) &#x3C; 0.01</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gen.</span><span style=\"color:#B392F0\">Float64Range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0.05</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.95</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#6A737D\">// Avoid extremes for meaningful test</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties.</span><span style=\"color:#B392F0\">TestingRun</span><span style=\"color:#E1E4E8\">(t)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/ingestion/pipeline_integration_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> ingestion</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/stretchr/testify/assert</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/stretchr/testify/require</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-org/apm-tracing-system/pkg/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-org/apm-tracing-system/testutils</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPipeline_EndToEnd</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create an in-memory storage fake</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // storage := memory.NewStorage()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create a Pipeline with a head sampler (rate=1.0) and the fake storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // pipeline, err := NewPipeline(config)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // require.NoError(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Generate a test trace with 3 spans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // spans := testutils.GenerateTrace(\"test-service\", 2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Process each span through the pipeline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // for _, span := range spans {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     err := pipeline.ProcessSpan(context.Background(), span)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     assert.NoError(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Query the storage for the complete trace by TraceID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // trace, err := storage.GetTraceByID(context.Background(), spans[0].TraceID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Assert the trace contains all 3 spans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // assert.Len(t, trace.Spans, 3)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // assert.Equal(t, spans[0].TraceID, trace.TraceID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Go)</strong></p>\n<ul>\n<li><strong>Use <code>t.Helper()</code>:</strong> Mark helper functions in tests so the failure line points to the actual test, not the helper.</li>\n<li><strong>Table-Driven Tests:</strong> Use for testing multiple input/output combinations for the same function.</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">    func</span><span style=\"color:#B392F0\"> TestSpanValidation</span><span style=\"color:#E1E4E8\">(t </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">testing.T) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            name </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            span </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            wantErr </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {</span><span style=\"color:#9ECBFF\">\"valid span\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{TraceID: </span><span style=\"color:#9ECBFF\">\"abc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {</span><span style=\"color:#9ECBFF\">\"missing traceid\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, tt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tests {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">(tt.name, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tt.span.</span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> tt.wantErr {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span></code></pre></div>\n<ul>\n<li><strong>Parallel Tests:</strong> Use <code>t.Parallel()</code> in independent tests to speed up execution.</li>\n<li><strong>Test Main:</strong> Use <code>func TestMain(m *testing.M)</code> for global setup/teardown (e.g., starting a test database container).</li>\n<li><strong>Benchmarks:</strong> Place benchmarks in <code>_test.go</code> files with functions starting with <code>Benchmark</code>. Use <code>b.ResetTimer()</code> and <code>b.StopTimer()</code> to exclude setup time.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint Execution</strong>\nFor each milestone, after implementing the components, run the relevant test suite:</p>\n<ol>\n<li><strong>Milestone 1:</strong> <code>go test ./internal/ingestion/... -v -count=1</code></li>\n<li><strong>Milestone 2:</strong> <code>go test ./internal/servicegraph/... -v</code></li>\n<li><strong>Milestone 3:</strong> <code>go test ./internal/sampling/... -v</code></li>\n<li><strong>Milestone 4:</strong> <code>go test ./internal/analytics/... -v</code></li>\n<li><strong>Milestone 5:</strong> <code>go test ./internal/sdk/... -v</code></li>\n</ol>\n<p>Then, run the integration tests: <code>go test ./test/integration/... -v</code></p>\n<p><strong>Expected Output:</strong> All tests pass (exit code 0). For property-based tests, you&#39;ll see output like <code>&quot;OK: 1000 passed&quot;</code>.</p>\n<p><strong>Signs of Trouble:</strong></p>\n<ul>\n<li><strong>Tests hang:</strong> Check for deadlocks in concurrent code (use <code>-timeout</code> flag).</li>\n<li><strong>High memory in tests:</strong> May indicate a leak in <code>BufferManager</code> or <code>WALReader</code>; run with <code>-memprofile</code>.</li>\n<li><strong>Flaky tests:</strong> Usually a concurrency bug or reliance on system time. Use fake clocks and synchronized channels.</li>\n</ul>\n<p><strong>G. Debugging Tips for Test Failures</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom</th>\n<th align=\"left\">Likely Cause</th>\n<th align=\"left\">How to Diagnose</th>\n<th align=\"left\">Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Span linking fails</strong> in trace assembly test.</td>\n<td align=\"left\">Incorrect parent-child relationship logic or <code>SpanID</code> generation.</td>\n<td align=\"left\">Log the <code>TraceID</code>, <code>SpanID</code>, and <code>ParentSpanID</code> of all spans in the test. Draw the expected tree.</td>\n<td align=\"left\">Verify <code>NewTraceFromSpans</code> groups by <code>TraceID</code> and builds the tree correctly.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Sampling rate test fails</strong> (ratio is 0% or 100%).</td>\n<td align=\"left\">Hash function in <code>ConsistentSampler</code> is incorrectly mapped to the rate.</td>\n<td align=\"left\">Print the hash value for a few <code>traceID</code>s and the threshold.</td>\n<td align=\"left\">Ensure hash is uniformly distributed and comparison is <code>hash % 10000 &lt; rate*10000</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Service map missing edges.</strong></td>\n<td align=\"left\"><code>EdgeAggregator</code> is not extracting caller/callee from spans correctly.</td>\n<td align=\"left\">Check that spans representing cross-service calls have different <code>ServiceName</code> and correct parent links.</td>\n<td align=\"left\">In <code>ProcessSpan</code>, ensure you extract the caller&#39;s service from the parent span.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Anomaly detector floods alerts.</strong></td>\n<td align=\"left\">Baseline calculation is wrong or detection threshold is too sensitive.</td>\n<td align=\"left\">Log the historical baseline values and the current value with z-score.</td>\n<td align=\"left\">Adjust the <code>thresholds</code> in <code>Detector</code> or increase the baseline window size.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Integration test passes alone but fails in suite.</strong></td>\n<td align=\"left\">Shared global state (like a package-level variable) is not reset.</td>\n<td align=\"left\">Look for <code>init()</code> functions or <code>var</code> declarations that hold state.</td>\n<td align=\"left\">Use dependency injection, not globals. Reset state in a <code>TestMain</code> or <code>setup/teardown</code>.</td>\n</tr>\n</tbody></table>\n<h2 id=\"13-debugging-guide\">13. Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section applies to all five milestones, providing a practical manual for diagnosing and fixing common issues encountered while building and running the APM Tracing System.</p>\n</blockquote>\n<p>Building a distributed tracing system involves multiple interconnected components that process high-volume data streams in real-time. When things go wrong—spans disappear, performance degrades, or metrics become inaccurate—the complexity can make debugging daunting. This guide provides a structured approach to diagnosing and resolving common issues, along with practical techniques and tools that will help you navigate the system&#39;s inner workings.</p>\n<h3 id=\"common-bugs-symptom-cause-fix\">Common Bugs: Symptom → Cause → Fix</h3>\n<p>Think of debugging the APM system like being a <strong>systems detective</strong>. Each symptom is a clue, each cause is a suspect, and your diagnosis steps are the investigative process to eliminate possibilities until you find the culprit. The following table organizes common issues by symptom, with concrete steps to identify root causes and implement fixes.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Spans are not linked into traces</strong> (spans with the same <code>TraceID</code> appear as separate, incomplete traces)</td>\n<td>1. <strong>Parent-child linking logic error</strong> in <code>TraceAssembler.AssembleTrace()</code><br>2. <strong>Missing or incorrect <code>ParentSpanID</code></strong> in incoming spans<br>3. <strong>Clock skew</strong> between services causing incorrect span ordering<br>4. <strong>Late-arriving spans</strong> evicted from <code>BufferManager</code> before assembly</td>\n<td>1. Check <code>TraceAssembler</code> logs for assembly errors<br>2. Verify span JSON/protobuf payloads contain correct <code>ParentSpanID</code><br>3. Compare timestamps across services—look for negative durations<br>4. Monitor <code>BufferManager</code> eviction metrics and trace completion rates</td>\n<td>1. Add validation to ensure <code>ParentSpanID</code> format matches <code>SpanID</code><br>2. Implement clock skew compensation in <code>TraceAssembler</code><br>3. Increase <code>BufferManager</code> TTL or adjust eviction policy<br>4. Add telemetry to track span arrival latency relative to trace start</td>\n</tr>\n<tr>\n<td><strong>Service map is empty or missing edges</strong> (dependency graph shows no connections between services)</td>\n<td>1. <strong>Edge extraction logic</strong> failing to identify caller-callee relationships<br>2. <strong>Aggregation window misalignment</strong> causing edges to be discarded<br>3. <strong>Sampling dropping all inter-service traces</strong><br>4. <strong><code>ServiceName</code> extraction incorrect</strong> from OTLP resource attributes</td>\n<td>1. Inspect raw spans to verify they contain cross-service references<br>2. Check <code>EdgeAggregator</code> window boundaries and flush timing<br>3. Review <code>HeadSampler</code> and <code>TailSampler</code> statistics for service<br>4. Validate <code>extractServiceName()</code> logic against actual OTLP payloads</td>\n<td>1. Enhance <code>EdgeAggregator.ProcessSpan()</code> to log extracted edges for debugging<br>2. Align aggregation windows with trace collection windows<br>3. Adjust sampling rates or add sampling bypass for test traffic<br>4. Update <code>extractServiceName()</code> to handle multiple attribute formats</td>\n</tr>\n<tr>\n<td><strong>High memory usage in collector</strong> (memory grows unbounded, leads to OOM crashes)</td>\n<td>1. <strong>Incomplete trace accumulation</strong> in <code>BufferManager</code> without eviction<br>2. <strong>Memory leak</strong> in WAL or pipeline components<br>3. <strong>Backpressure failure</strong> causing queue buildup<br>4. <strong>Large attribute values</strong> stored in span <code>Attributes</code> maps</td>\n<td>1. Monitor <code>BufferManager.traces</code> map size and age distribution<br>2. Use Go pprof heap profiling to identify allocation hotspots<br>3. Check <code>BackpressureManager</code> tier transitions and sampling adjustments<br>4. Inspect span sizes in storage—look for exceptionally large attributes</td>\n<td>1. Implement more aggressive <code>BufferManager</code> eviction based on trace age<br>2. Add periodic resource cleanup in long-lived goroutines<br>3. Tune <code>BackpressureManager</code> thresholds for earlier intervention<br>4. Enforce attribute size limits in <code>SpanValidator</code></td>\n</tr>\n<tr>\n<td><strong>Slow trace queries</strong> (<code>GetTraceByID</code> takes &gt;1s even for small traces)</td>\n<td>1. <strong>Missing or inefficient indexes</strong> on trace storage<br>2. <strong>N+1 query problem</strong> fetching spans individually<br>3. <strong>Storage layer contention</strong> from high ingestion volume<br>4. <strong>Cache misses</strong> in query service layer</td>\n<td>1. Examine query execution plans in storage backend<br>2. Profile query service to identify repeated round-trips<br>3. Monitor storage latency metrics during peak ingestion<br>4. Check cache hit rates for frequently accessed traces</td>\n<td>1. Ensure composite index on (<code>TraceID</code>, <code>StartTime</code>) in storage<br>2. Implement batch span fetching in <code>GetTraceByID</code><br>3. Add read replicas or query-side caching for trace data<br>4. Implement query result caching with TTL based on trace age</td>\n</tr>\n<tr>\n<td><strong>Sampling rate not being respected</strong> (too many/few traces stored vs. configured probability)</td>\n<td>1. <strong>Inconsistent hashing</strong> across sampler instances<br>2. <strong>Race condition</strong> updating <code>ConsistentSampler.rate</code><br>3. <strong>Tail-based sampling overriding</strong> too many head decisions<br>4. <strong>Configuration propagation delay</strong> across collector instances</td>\n<td>1. Compare hash outputs for same <code>TraceID</code> across sampler instances<br>2. Check for concurrent <code>SetRate()</code> calls without proper synchronization<br>3. Review <code>TailSampler</code> statistics—high <code>TailOverrides</code> indicates aggressive overriding<br>4. Monitor configuration timestamps vs. sampling decision timestamps</td>\n<td>1. Use deterministic hash function (e.g., xxHash) with fixed seed<br>2. Add mutex protection in <code>ConsistentSampler.SetRate()</code><br>3. Adjust <code>TailSamplingRule</code> priorities and thresholds<br>4. Implement configuration versioning with decision logging</td>\n</tr>\n<tr>\n<td><strong>Anomaly detection producing too many false positives</strong> (alerts fire during normal operation)</td>\n<td>1. <strong>Insufficient historical baseline</strong> for comparison<br>2. <strong>Statistical method sensitivity</strong> too high (low z-score threshold)<br>3. <strong>Seasonal patterns</strong> not accounted for in baseline<br>4. <strong>Metric aggregation window</strong> misaligned with traffic patterns</td>\n<td>1. Check baseline calculation—minimum data points required<br>2. Review anomaly <code>Confidence</code> scores—consistently low indicates weak signal<br>3. Plot metric history to identify daily/weekly patterns<br>4. Compare aggregation window with natural traffic cycles</td>\n<td>1. Increase baseline training period before enabling detection<br>2. Adjust <code>Detector.thresholds</code> based on observed false positive rate<br>3. Implement seasonal decomposition in <code>BaselineCalculator</code><br>4. Experiment with different aggregation windows (1m vs 5m vs 15m)</td>\n</tr>\n<tr>\n<td><strong>SDK causing performance overhead</strong> (instrumented application shows &gt;5% latency increase)</td>\n<td>1. <strong>Synchronous span export</strong> blocking request processing<br>2. <strong>Excessive attribute collection</strong> on hot code paths<br>3. <strong>Context propagation overhead</strong> in deep call chains<br>4. <strong>Lock contention</strong> in shared <code>Tracer</code> structures</td>\n<td>1. Profile application with and without SDK to isolate overhead<br>2. Measure time spent in <code>End()</code> and span export operations<br>3. Count context propagation operations per request<br>4. Check goroutine profiles for lock wait times</td>\n<td>1. Implement asynchronous batched span export in SDK<br>2. Add sampling to attribute collection on high-volume operations<br>3. Optimize <code>context.Context</code> value storage/retrieval<br>4. Use <code>sync.Pool</code> for reusable span objects</td>\n</tr>\n<tr>\n<td><strong>Clock skew making span ordering incorrect</strong> (child spans appear to start before parents)</td>\n<td>1. <strong>System clock differences</strong> between services (seconds/minutes offset)<br>2. <strong>NTP synchronization issues</strong> causing drift<br>3. <strong>Virtual machine clock skew</strong> in containerized environments<br>4. <strong>Timestamp normalization logic</strong> not accounting for timezone</td>\n<td>1. Compare <code>StartTime</code> of parent and child spans across services<br>2. Check system clock synchronization status on collector and services<br>3. Monitor for gradual drift in span timing over hours/days<br>4. Verify timestamp parsing handles UTC conversion correctly</td>\n<td>1. Implement relative timestamp adjustment in <code>TraceAssembler</code><br>2. Add NTP client to collector to maintain accurate time<br>3. Use monotonic clocks for duration calculations where possible<br>4. Normalize all timestamps to UTC at ingestion point</td>\n</tr>\n<tr>\n<td><strong>Backpressure not engaging under load</strong> (system becomes unresponsive instead of degrading gracefully)</td>\n<td>1. <strong>Threshold detection lag</strong>—metrics don&#39;t reflect reality quickly enough<br>2. <strong>Tier transition logic</strong> too conservative<br>3. <strong>Sampling rate adjustment</strong> insufficient to reduce load<br>4. <strong>Feedback loop delay</strong> between action and effect</td>\n<td>1. Monitor <code>SystemMetrics</code> vs. <code>BackpressureManager</code> tier decisions<br>2. Check tier transition history for delayed responses to load spikes<br>3. Compare sampling rate changes with span ingestion rate changes<br>4. Measure time from tier change to metric improvement</td>\n<td>1. Reduce <code>checkInterval</code> and use more sensitive thresholds<br>2. Implement predictive tier transitions based on trend analysis<br>3. Add exponential backoff to sampling rate reductions<br>4. Create faster feedback loop with direct metric-to-action coupling</td>\n</tr>\n<tr>\n<td><strong>WAL recovery losing spans</strong> after collector restart</td>\n<td>1. <strong>WAL corruption</strong> due to improper file rotation<br>2. <strong>Incomplete records</strong> written before crash<br>3. <strong>Race condition</strong> between write and rotation<br>4. <strong>Disk space exhaustion</strong> during WAL append</td>\n<td>1. Check WAL file integrity—look for malformed length prefixes<br>2. Verify last few records in WAL are complete<br>3. Examine rotation timing relative to crash time<br>4. Monitor disk usage metrics before restart</td>\n<td>1. Add record checksums to detect corruption<br>2. Implement atomic record writing with fsync<br>3. Use file locking during rotation<br>4. Add disk space monitoring and proactive WAL cleanup</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> Many APM system bugs manifest as <strong>data quality issues</strong>—missing links, incorrect timing, or inaccurate aggregations. Always start your investigation by examining the raw data flowing through the system. Add debug logging to capture a sample of problematic spans before and after each processing stage.</p>\n</blockquote>\n<h3 id=\"debugging-techniques-and-tools\">Debugging Techniques and Tools</h3>\n<p>Effective debugging requires both systematic methodology and the right tools. Think of this as your <strong>detective&#39;s toolkit</strong>—each tool serves a specific purpose in uncovering different types of issues.</p>\n<h4 id=\"strategic-logging\">Strategic Logging</h4>\n<p>Well-placed logs are your first line of defense. Unlike metrics that aggregate, logs preserve individual request context, which is crucial for debugging trace assembly, sampling decisions, and edge cases.</p>\n<p><strong>Where to Add Diagnostic Logging:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Critical Log Points</th>\n<th>What to Log</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>OTLPHandler</code></td>\n<td>Request parsing errors, payload size anomalies</td>\n<td><code>traceID</code>, <code>spanID</code>, error details, payload size</td>\n</tr>\n<tr>\n<td><code>Pipeline.ProcessSpan()</code></td>\n<td>Span validation failures, sampling decisions</td>\n<td><code>traceID</code>, <code>spanID</code>, validation error, sampler decision</td>\n</tr>\n<tr>\n<td><code>BufferManager.AddSpan()</code></td>\n<td>Trace completion, eviction events</td>\n<td><code>traceID</code>, span count, buffer size, eviction reason</td>\n</tr>\n<tr>\n<td><code>EdgeAggregator.ProcessSpan()</code></td>\n<td>Edge extraction, window flushes</td>\n<td>caller/callee services, extracted edge metrics</td>\n</tr>\n<tr>\n<td><code>HeadSampler.Decide()</code></td>\n<td>Sampling decisions, rate changes</td>\n<td><code>traceID</code>, service, rate, decision</td>\n</tr>\n<tr>\n<td><code>TailSampler.EvaluateTrace()</code></td>\n<td>Rule evaluations, override decisions</td>\n<td><code>traceID</code>, rule matches, final decision</td>\n</tr>\n<tr>\n<td><code>CircuitBreaker.Execute()</code></td>\n<td>State transitions, operation failures</td>\n<td>operation name, state change, error</td>\n</tr>\n</tbody></table>\n<p><strong>Implementing Structured Logging:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Use a structured logger like zap or logrus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Span processing completed\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zap.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"trace_id\"</span><span style=\"color:#E1E4E8\">, span.TraceID),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zap.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"span_id\"</span><span style=\"color:#E1E4E8\">, span.SpanID),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zap.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"service\"</span><span style=\"color:#E1E4E8\">, span.ServiceName),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zap.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"duration\"</span><span style=\"color:#E1E4E8\">, span.Duration),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zap.</span><span style=\"color:#B392F0\">Int</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"buffer_size\"</span><span style=\"color:#E1E4E8\">, bufferSize))</span></span></code></pre></div>\n\n<p><strong>Log Sampling for High Volume:</strong> Enable debug logging only for a percentage of traces to avoid overwhelming the log system. Use the same <code>ConsistentSampler</code> mechanism to ensure the same traces are logged across components.</p>\n<h4 id=\"performance-profiling-with-pprof\">Performance Profiling with pprof</h4>\n<p>When the system experiences high CPU, memory leaks, or goroutine explosions, Go&#39;s built-in profiling tools (<code>pprof</code>) are indispensable. Think of pprof as an <strong>X-ray machine</strong> for your running application—it reveals internal structures and hotspots invisible from the outside.</p>\n<p><strong>Enabling pprof in Your Collector:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add to your HTTP server setup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">net/http/pprof</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(http.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"localhost:6060\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}()</span></span></code></pre></div>\n\n<p><strong>Common pprof Investigations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Profile Type</th>\n<th>What to Look For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>High CPU usage</td>\n<td><code>cpu</code> profile</td>\n<td>Functions with highest <code>cumulative</code> time; often reveals hot loops or expensive serialization</td>\n</tr>\n<tr>\n<td>Memory leaks</td>\n<td><code>heap</code> profile</td>\n<td>Objects with increasing <code>inuse_space</code> over time; check for retained references in global maps</td>\n</tr>\n<tr>\n<td>Goroutine leaks</td>\n<td><code>goroutine</code> profile</td>\n<td>Growing goroutine count; look for blocked goroutines in sync primitives or channel operations</td>\n</tr>\n<tr>\n<td>Contention</td>\n<td><code>mutex</code> profile</td>\n<td>Functions with high lock contention; indicates scalability bottlenecks</td>\n</tr>\n<tr>\n<td>Blocking</td>\n<td><code>block</code> profile</td>\n<td>Operations causing goroutines to wait; often I/O or channel operations</td>\n</tr>\n</tbody></table>\n<p><strong>Diagnostic Workflow:</strong></p>\n<ol>\n<li><strong>Reproduce the issue</strong> under load (use simulation tools below)</li>\n<li><strong>Collect profiles</strong> during the problematic behavior:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # CPU profile (30 seconds)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> tool</span><span style=\"color:#9ECBFF\"> pprof</span><span style=\"color:#9ECBFF\"> http://localhost:6060/debug/pprof/profile?seconds=</span><span style=\"color:#79B8FF\">30</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Heap snapshot</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> tool</span><span style=\"color:#9ECBFF\"> pprof</span><span style=\"color:#9ECBFF\"> http://localhost:6060/debug/pprof/heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Goroutine dump</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> http://localhost:6060/debug/pprof/goroutine?debug=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> goroutines.txt</span></span></code></pre></div>\n<ol start=\"3\">\n<li><strong>Analyze with pprof web interface:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Launch interactive web UI</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> tool</span><span style=\"color:#9ECBFF\"> pprof</span><span style=\"color:#79B8FF\"> -http=:8080</span><span style=\"color:#9ECBFF\"> profile.pprof</span></span></code></pre></div>\n<ol start=\"4\">\n<li><strong>Look for patterns:</strong> Repeated allocation patterns, deep call stacks with many allocations, or single functions dominating CPU time.</li>\n</ol>\n<blockquote>\n<p><strong>Pro Tip:</strong> Use <strong>comparative profiling</strong>—take profiles before and after a code change, or during normal vs. degraded operation. The differences often reveal the root cause more clearly than absolute profiles.</p>\n</blockquote>\n<h4 id=\"simulating-production-traffic-for-testing\">Simulating Production Traffic for Testing</h4>\n<p>You cannot debug what you cannot reproduce. Creating realistic test traffic is essential for diagnosing issues that only appear under production-like load.</p>\n<p><strong>Traffic Simulation Approaches:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Technique</th>\n<th>Best For</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Replay from WAL</strong></td>\n<td>Reproducing specific failure scenarios</td>\n<td>Use <code>WALReader.ReadNext()</code> to replay spans exactly as they arrived</td>\n</tr>\n<tr>\n<td><strong>Synthetic trace generation</strong></td>\n<td>Load testing and stress scenarios</td>\n<td>Programmatically generate traces with realistic service call patterns</td>\n</tr>\n<tr>\n<td><strong>Record-and-replay</strong></td>\n<td>Capturing production patterns without PII</td>\n<td>Capture trace samples (anonymized) and replay through test collector</td>\n</tr>\n<tr>\n<td><strong>Chaos injection</strong></td>\n<td>Testing resilience and failure recovery</td>\n<td>Randomly drop spans, introduce delays, or corrupt data</td>\n</tr>\n</tbody></table>\n<p><strong>Building a Trace Generator for Testing:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Generate a realistic multi-service trace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> generateTestTrace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spans </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Root span (web request)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spans </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(spans, </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TraceID: traceID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SpanID: </span><span style=\"color:#B392F0\">generateID</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ParentSpanID: </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name: </span><span style=\"color:#9ECBFF\">\"HTTP GET /api/users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ServiceName: </span><span style=\"color:#9ECBFF\">\"frontend\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StartTime: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Duration: </span><span style=\"color:#79B8FF\">120</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Database call child span</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spans </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(spans, </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TraceID: traceID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SpanID: </span><span style=\"color:#B392F0\">generateID</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ParentSpanID: spans[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].SpanID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name: </span><span style=\"color:#9ECBFF\">\"SELECT users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ServiceName: </span><span style=\"color:#9ECBFF\">\"users-db\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StartTime: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Duration: </span><span style=\"color:#79B8FF\">45</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // External API call child span</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spans </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(spans, </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TraceID: traceID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SpanID: </span><span style=\"color:#B392F0\">generateID</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ParentSpanID: spans[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].SpanID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name: </span><span style=\"color:#9ECBFF\">\"GET /recommendations\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ServiceName: </span><span style=\"color:#9ECBFF\">\"recommendation-service\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StartTime: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Duration: </span><span style=\"color:#79B8FF\">80</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> spans</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Load Testing Script Pattern:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run a controlled load test with increasing volume</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> rate </span><span style=\"color:#F97583\">in</span><span style=\"color:#9ECBFF\"> 100</span><span style=\"color:#9ECBFF\"> 500</span><span style=\"color:#9ECBFF\"> 1000</span><span style=\"color:#9ECBFF\"> 2000</span><span style=\"color:#9ECBFF\"> 5000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing at ${</span><span style=\"color:#E1E4E8\">rate</span><span style=\"color:#9ECBFF\">} spans/sec\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ./trace-generator</span><span style=\"color:#79B8FF\"> --rate=</span><span style=\"color:#E1E4E8\">$rate</span><span style=\"color:#79B8FF\"> --duration=60s</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        --collector-endpoint=</span><span style=\"color:#9ECBFF\">\"http://localhost:4318/v1/traces\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Wait for system to stabilize and collect metrics</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sleep</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#9ECBFF\"> http://localhost:6060/debug/pprof/heap</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> heap_</span><span style=\"color:#E1E4E8\">${rate}</span><span style=\"color:#9ECBFF\">.pprof</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre></div>\n\n<h4 id=\"using-the-system-to-debug-itself-dogfooding\">Using the System to Debug Itself (Dogfooding)</h4>\n<p>The most powerful debugging technique for an APM system is to <strong>use it to monitor itself</strong>. Instrument your collector, query service, and storage layer with the same SDK you provide to applications. This creates a virtuous cycle where debugging improvements benefit both the system and its users.</p>\n<p><strong>Self-Instrumentation Strategy:</strong></p>\n<ol>\n<li><strong>Add tracing to collector ingress/egress:</strong> Wrap <code>OTLPHandler.ServeHTTP()</code> with spans to track request handling latency and errors.</li>\n<li><strong>Trace internal pipeline operations:</strong> Add spans around <code>BufferManager</code> operations, <code>EdgeAggregator</code> processing, and <code>TailSampler</code> evaluations.</li>\n<li><strong>Monitor system health with built-in analytics:</strong> Feed collector metrics into your own anomaly detection system to get early warnings of degradation.</li>\n<li><strong>Build service maps of internal components:</strong> Visualize data flow between pipeline stages to identify bottlenecks.</li>\n</ol>\n<p><strong>Example Collector Self-Instrumentation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OTLPHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ServeHTTP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create a span for this request</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, span </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> h.tracer.</span><span style=\"color:#B392F0\">StartSpanFromContext</span><span style=\"color:#E1E4E8\">(r.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"OTLPHandler.ServeHTTP\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> span.</span><span style=\"color:#B392F0\">End</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    span.</span><span style=\"color:#B392F0\">SetAttribute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"http.method\"</span><span style=\"color:#E1E4E8\">, r.Method)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    span.</span><span style=\"color:#B392F0\">SetAttribute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"http.url\"</span><span style=\"color:#E1E4E8\">, r.URL.Path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    span.</span><span style=\"color:#B392F0\">SetAttribute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"content.type\"</span><span style=\"color:#E1E4E8\">, r.Header.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process the request with the context containing the span</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    h.</span><span style=\"color:#B392F0\">processRequestWithContext</span><span style=\"color:#E1E4E8\">(ctx, w, r)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    span.</span><span style=\"color:#B392F0\">SetAttribute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"http.status_code\"</span><span style=\"color:#E1E4E8\">, statusCode)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> statusCode </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        span.</span><span style=\"color:#B392F0\">SetStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SpanStatus</span><span style=\"color:#E1E4E8\">{Code: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, Message: </span><span style=\"color:#9ECBFF\">\"HTTP error\"</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>Design Principle:</strong> A well-instrumented system is a debuggable system. The effort you invest in adding observability to your APM system pays dividends every time you need to diagnose a production issue.</p>\n</blockquote>\n<h4 id=\"diagnostic-endpoints-and-health-checks\">Diagnostic Endpoints and Health Checks</h4>\n<p>Beyond pprof, build custom diagnostic endpoints that expose internal state. These are your <strong>system vitals monitor</strong>—quick ways to check pulse, respiration, and other critical signs.</p>\n<p><strong>Essential Diagnostic Endpoints:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Endpoint</th>\n<th>Purpose</th>\n<th>Response Fields</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GET /debug/state/buffer</code></td>\n<td><code>BufferManager</code> status</td>\n<td><code>total_traces</code>, <code>total_spans</code>, <code>oldest_trace_age</code>, <code>eviction_count</code></td>\n</tr>\n<tr>\n<td><code>GET /debug/state/sampling</code></td>\n<td>Sampler statistics</td>\n<td><code>head_sampled_rate</code>, <code>tail_overrides</code>, <code>per_service_decisions</code></td>\n</tr>\n<tr>\n<td><code>GET /debug/state/edges</code></td>\n<td>Service map construction</td>\n<td><code>edge_count</code>, <code>last_flush_time</code>, <code>pending_edges</code></td>\n</tr>\n<tr>\n<td><code>GET /debug/trace/:id</code></td>\n<td>Manual trace inspection</td>\n<td>Complete trace with all spans (bypasses normal query path)</td>\n</tr>\n<tr>\n<td><code>POST /debug/inject-fault</code></td>\n<td>Chaos engineering</td>\n<td>Inject delays, errors, or data corruption for testing resilience</td>\n</tr>\n</tbody></table>\n<p><strong>Example Diagnostic Handler:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DebugHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> m.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"traces_count\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(m.traces),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"spans_count\"</span><span style=\"color:#E1E4E8\">:  m.</span><span style=\"color:#B392F0\">totalSpans</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"max_size\"</span><span style=\"color:#E1E4E8\">:     m.maxSize,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"ttl\"</span><span style=\"color:#E1E4E8\">:          m.ttl.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(stats)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"systematic-diagnosis-workflow\">Systematic Diagnosis Workflow</h4>\n<p>When faced with an unknown issue, follow this <strong>systematic diagnosis workflow</strong> to avoid rabbit holes and confirmation bias:</p>\n<ol>\n<li><strong>Reproduce Consistently:</strong> Can you make it happen on demand? If not, add logging to capture it next time.</li>\n<li><strong>Isolate the Component:</strong> Use the architecture diagram to identify which component is likely responsible. Check component health endpoints.</li>\n<li><strong>Examine Inputs/Outputs:</strong> Compare what enters the component vs. what leaves. Add debug logging at boundaries.</li>\n<li><strong>Check Internal State:</strong> Use diagnostic endpoints to inspect internal data structures and counters.</li>\n<li><strong>Simplify and Test:</strong> Create a minimal test case that reproduces the issue with controlled inputs.</li>\n<li><strong>Hypothesize and Verify:</strong> Form a hypothesis about the root cause, make a prediction, and test it.</li>\n<li><strong>Fix and Monitor:</strong> Implement the fix, then monitor to ensure the issue is resolved and doesn&#39;t regress.</li>\n</ol>\n<p>Remember that in distributed tracing systems, many issues are <strong>timing-related</strong> (race conditions, late arrivals, clock skew) or <strong>data quality issues</strong> (malformed spans, incorrect context propagation). Always consider these categories early in your diagnosis.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete code patterns and tools to implement the debugging techniques described above.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Structured Logging</td>\n<td><code>log/slog</code> (Go 1.21+)</td>\n<td><code>uber-go/zap</code> with sampling and hooks</td>\n</tr>\n<tr>\n<td>Profiling</td>\n<td><code>net/http/pprof</code> embedded</td>\n<td>Custom profiling endpoints with filtering</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td><code>expvar</code> for basic metrics</td>\n<td><code>prometheus/client_golang</code> for rich metrics</td>\n</tr>\n<tr>\n<td>Trace Generation</td>\n<td>Custom Go generator</td>\n<td>OpenTelemetry Collector test data generator</td>\n</tr>\n<tr>\n<td>Health Checks</td>\n<td>Simple HTTP endpoint</td>\n<td>Kubernetes-ready liveness/readiness probes</td>\n</tr>\n<tr>\n<td>Diagnostic UI</td>\n<td>pprof web interface</td>\n<td>Custom React dashboard aggregating all debug endpoints</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-diagnostic-endpoint-implementation\">B. Diagnostic Endpoint Implementation</h4>\n<p>Create a dedicated debugging module that exposes system state without affecting production performance:</p>\n<p><strong>File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/debug/\n    handler.go           # HTTP handlers for debug endpoints\n    pprof_wrapper.go     # Enhanced pprof with authentication\n    state_dumper.go      # Component state inspection\n    metrics.go           # Debug-specific metrics collection\n  cmd/debug-tool/\n    main.go              # CLI tool for offline diagnostics</code></pre></div>\n\n<p><strong>Complete State Dumper Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/debug/state_dumper.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ComponentState represents a component's internal state for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ComponentState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Health      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"health\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metrics     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"metrics\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastUpdated </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"last_updated\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StateDumper collects and serves debug state from all registered components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StateDumper</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    components </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewStateDumper creates a new state dumper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewStateDumper</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateDumper</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">StateDumper</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        components: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentState</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterComponent adds a component state provider</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateDumper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">provider</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentState</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    d.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> d.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    d.components[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> provider</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServeHTTP implements http.Handler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateDumper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ServeHTTP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    d.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> d.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    states </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ComponentState</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> name, provider </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> d.components {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        states[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> provider</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(states); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), http.StatusInternalServerError)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BufferManagerStateProvider example</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> BufferManagerStateProvider</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bm</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BufferManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentState</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentState</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bm.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        defer</span><span style=\"color:#E1E4E8\"> bm.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> ComponentState</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name:   </span><span style=\"color:#9ECBFF\">\"buffer_manager\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Health: </span><span style=\"color:#9ECBFF\">\"healthy\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Metrics: </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"traces_count\"</span><span style=\"color:#E1E4E8\">:      </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(bm.traces),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"spans_count\"</span><span style=\"color:#E1E4E8\">:       bm.</span><span style=\"color:#B392F0\">totalSpans</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"oldest_trace_age\"</span><span style=\"color:#E1E4E8\">:  time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(bm.</span><span style=\"color:#B392F0\">oldestTraceTime</span><span style=\"color:#E1E4E8\">()).</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"evictions_total\"</span><span style=\"color:#E1E4E8\">:   bm.evictionCount,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"evictions_recent\"</span><span style=\"color:#E1E4E8\">:  bm.recentEvictionCount,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LastUpdated: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"c-strategic-logging-skeleton\">C. Strategic Logging Skeleton</h4>\n<p>Implement a logging wrapper that adds trace context to all log messages automatically:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/telemetry/logger.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> telemetry</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">go.uber.org/zap</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">go.uber.org/zap/zapcore</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContextLogger wraps a zap logger with context awareness</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContextLogger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">zap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewContextLogger creates a new context-aware logger</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewContextLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#B392F0\"> zapcore</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Level</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContextLogger</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> zap.</span><span style=\"color:#B392F0\">NewProductionConfig</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config.Level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> zap.</span><span style=\"color:#B392F0\">NewAtomicLevelAt</span><span style=\"color:#E1E4E8\">(level)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config.EncoderConfig.TimeKey </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"timestamp\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config.EncoderConfig.EncodeTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> zapcore.ISO8601TimeEncoder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> config.</span><span style=\"color:#B392F0\">Build</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ContextLogger</span><span style=\"color:#E1E4E8\">{logger: logger}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithContext returns a logger with trace context fields added</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cl </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContextLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WithContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">zap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cl.logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Extract trace context from context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> span </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SpanFromContext</span><span style=\"color:#E1E4E8\">(ctx); span </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logger.</span><span style=\"color:#B392F0\">With</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            zap.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"trace_id\"</span><span style=\"color:#E1E4E8\">, span.TraceID),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            zap.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"span_id\"</span><span style=\"color:#E1E4E8\">, span.SpanID),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SampledDebug logs debug messages only for sampled traces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cl </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContextLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SampledDebug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> ...</span><span style=\"color:#B392F0\">zap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Field</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> span </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SpanFromContext</span><span style=\"color:#E1E4E8\">(ctx); span </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Sample 1% of traces for debug logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> hashTraceID</span><span style=\"color:#E1E4E8\">(span.TraceID)</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cl.</span><span style=\"color:#B392F0\">WithContext</span><span style=\"color:#E1E4E8\">(ctx).</span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(msg, fields</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// hashTraceID helper for consistent sampling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> hashTraceID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use xxHash for fast, consistent hashing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation omitted for brevity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-load-test-generator-skeleton\">D. Load Test Generator Skeleton</h4>\n<p>Create a trace generator that can simulate realistic production traffic patterns:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cmd/trace-generator/main.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">flag</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-project/internal/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GeneratorConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Rate        </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Spans per second</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duration    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#6A737D\"> // How long to run</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Services    []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">      // Service names to include</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorRate   </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\">       // Percentage of spans with errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxDepth    </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Maximum call depth in traces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TraceGenerator creates synthetic traces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TraceGenerator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#B392F0\">GeneratorConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats  </span><span style=\"color:#B392F0\">GeneratorStats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateTrace creates a single trace with realistic structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tg </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateTrace</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    traceID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> generateUUID</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create root span for entry point (e.g., \"HTTP GET /api\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Randomly determine trace depth (1 to MaxDepth)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each level, create child spans for different services</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Apply ErrorRate to randomly mark some spans as errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add realistic durations (parent > sum of children)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Include attributes (URL paths, DB queries, status codes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TraceID:   traceID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Spans:     []</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#6A737D\">/* populated spans */</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StartTime: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EndTime:   time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Run generates traces at the configured rate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tg </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(time.Second </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(tg.config.Rate))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deadline </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(tg.config.Duration)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ctx.</span><span style=\"color:#B392F0\">Err</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">deadline:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            log.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Generation complete. Sent </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> traces\"</span><span style=\"color:#E1E4E8\">, tg.stats.TracesGenerated)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            trace </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tg.</span><span style=\"color:#B392F0\">GenerateTrace</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 7: Send trace to collector via OTLP</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tg.stats.TracesGenerated</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> rate </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">IntVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">rate, </span><span style=\"color:#9ECBFF\">\"rate\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Spans per second\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">DurationVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">duration, </span><span style=\"color:#9ECBFF\">\"duration\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second, </span><span style=\"color:#9ECBFF\">\"Test duration\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> GeneratorConfig</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Rate:      rate,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Duration:  duration,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Services:  []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"frontend\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"users-service\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"orders-service\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"payments-service\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"database\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ErrorRate: </span><span style=\"color:#79B8FF\">0.01</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// 1% error rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MaxDepth:  </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    generator </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TraceGenerator</span><span style=\"color:#E1E4E8\">{config: config}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> generator.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">(ctx); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        log.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Go pprof:</strong> Use <code>go tool pprof -http=:8080 profile.pprof</code> to launch the web UI. The flame graph view is particularly useful for identifying CPU hotspots.</li>\n<li><strong>Memory profiling:</strong> Run your tests with <code>-memprofile=mem.pprof</code> and <code>-memprofilerate=1</code> to get detailed allocation data.</li>\n<li><strong>Race detection:</strong> Always run tests with <code>-race</code> flag during development to catch data races early.</li>\n<li><strong>Goroutine leaks:</strong> Use <code>runtime.NumGoroutine()</code> in your health checks to monitor goroutine counts.</li>\n<li><strong>Block profiling:</strong> Enable with <code>runtime.SetBlockProfileRate(1)</code> to capture all blocking operations.</li>\n</ul>\n<h4 id=\"f-debugging-workflow-checkpoint\">F. Debugging Workflow Checkpoint</h4>\n<p>After implementing the debugging infrastructure, verify it works:</p>\n<ol>\n<li><strong>Start the collector</strong> with debug endpoints enabled:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   ./collector</span><span style=\"color:#79B8FF\"> --debug-addr=:6060</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Check debug endpoints:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Basic health</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> http://localhost:6060/health</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Buffer manager state</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> http://localhost:6060/debug/state/buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # pprof interface (open in browser)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   open</span><span style=\"color:#9ECBFF\"> http://localhost:6060/debug/pprof/</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Generate test traffic:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/trace-generator/main.go</span><span style=\"color:#79B8FF\"> --rate=500</span><span style=\"color:#79B8FF\"> --duration=1m</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Monitor during load:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Take a CPU profile during load</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> tool</span><span style=\"color:#9ECBFF\"> pprof</span><span style=\"color:#9ECBFF\"> http://localhost:6060/debug/pprof/profile?seconds=</span><span style=\"color:#79B8FF\">10</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Check memory growth</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> tool</span><span style=\"color:#9ECBFF\"> pprof</span><span style=\"color:#9ECBFF\"> http://localhost:6060/debug/pprof/heap</span></span></code></pre></div>\n\n<ol start=\"5\">\n<li><strong>Verify self-instrumentation:</strong> Check that the collector&#39;s own traces appear in the trace query interface.</li>\n</ol>\n<p><strong>Expected Results:</strong> You should be able to see internal spans from the collector, monitor buffer sizes in real-time, and capture performance profiles under load. If debug endpoints don&#39;t respond or show empty data, check that components are properly registered with the <code>StateDumper</code>.</p>\n<h4 id=\"g-debugging-tips-quick-reference\">G. Debugging Tips Quick Reference</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Immediate Action</th>\n<th>Long-term Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Collector OOM</td>\n<td>1. Check <code>BufferManager</code> size<br>2. Profile heap with pprof</td>\n<td>Implement smarter eviction, add memory limits</td>\n</tr>\n<tr>\n<td>High CPU</td>\n<td>1. Capture CPU profile<br>2. Check for hot loops in serialization</td>\n<td>Optimize hot paths, add caching, use pooling</td>\n</tr>\n<tr>\n<td>Slow queries</td>\n<td>1. Check storage indexes<br>2. Profile query execution</td>\n<td>Add query caching, optimize indexes, partition data</td>\n</tr>\n<tr>\n<td>Missing traces</td>\n<td>1. Verify sampling decisions<br>2. Check WAL for lost spans</td>\n<td>Improve sampling debug logging, enhance WAL durability</td>\n</tr>\n<tr>\n<td>Incorrect service map</td>\n<td>1. Inspect edge extraction logic<br>2. Check <code>ServiceName</code> extraction</td>\n<td>Add validation, improve attribute parsing</td>\n</tr>\n</tbody></table>\n<p>Remember that the most effective debugging comes from <strong>understanding normal behavior first</strong>. Establish baselines for key metrics (memory usage, processing latency, trace completion rates) so you can recognize anomalies when they occur.</p>\n<h2 id=\"14-future-extensions\">14. Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section looks beyond the current five milestones, exploring potential enhancements that could build upon the existing APM Tracing System. These ideas are not part of the current scope but illustrate how the system can evolve to address more complex observability challenges, leverage emerging technologies, and provide deeper insights into distributed system behavior.</p>\n</blockquote>\n<h3 id=\"potential-enhancements\">Potential Enhancements</h3>\n<p>The current APM Tracing System provides a solid foundation for distributed tracing, service dependency visualization, intelligent sampling, performance analytics, and automatic instrumentation. However, the world of observability is rapidly evolving. This section explores several natural extensions that could build upon our existing architecture, demonstrating how the system&#39;s modular design and clear data flow enable future enhancements without requiring major re-architecting.</p>\n<h4 id=\"141-continuous-profiling-integration\">14.1 Continuous Profiling Integration</h4>\n<p><strong>Mental Model: The X-Ray Machine for Code Execution</strong></p>\n<blockquote>\n<p>While traces show you <em>what</em> happened (the request flow) and <em>when</em> (timing), profiling shows you <em>why</em> (which specific lines of code consumed CPU or memory). Integrating continuous profiling is like adding an X-ray machine to our diagnostic toolkit—it reveals the internal structure and hotspots that surface metrics and traces can only hint at.</p>\n</blockquote>\n<p>Continuous profiling involves periodically capturing CPU flame graphs, memory allocation profiles, and goroutine/thread stacks from production services, then correlating this data with trace information to identify performance bottlenecks at the code level. Our APM system is uniquely positioned to integrate profiling because we already understand service boundaries and can correlate profiles with specific operations and trace contexts.</p>\n<p><strong>Integration Approach:</strong></p>\n<ol>\n<li><strong>Profile Collection Extension:</strong> Extend the existing APM SDK to include a lightweight profiler that captures stack samples at configurable intervals (e.g., every 10 seconds for 5 seconds).</li>\n<li><strong>Profile-Execution Correlation:</strong> Tag each profile sample with the current trace context (when available) so profiles can be filtered to specific operations or services.</li>\n<li><strong>Dedicated Profile Storage:</strong> Add a new storage backend optimized for profile data (which is larger and more hierarchical than span data), potentially using columnar formats for efficient querying.</li>\n<li><strong>Profile Analysis Engine:</strong> Implement analysis that identifies resource-intensive functions and correlates them with high-latency traces or error conditions.</li>\n</ol>\n<p><strong>Required Architecture Changes:</strong></p>\n<ul>\n<li>New <code>Profiler</code> component in the SDK with methods <code>StartProfiling()</code> and <code>StopProfiling()</code></li>\n<li>Extended <code>Span</code> type to optionally include <code>ProfileID</code> reference</li>\n<li>New <code>ProfileStorage</code> interface with implementations for different backends</li>\n<li>Enhanced Query Service to support profile queries by service, operation, or trace ID</li>\n</ul>\n<p><strong>Benefits and Challenges:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Benefit</th>\n<th>Challenge</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pinpoint exact code causing latency spikes</td>\n<td>Profile data volume is 10-100× larger than trace data</td>\n</tr>\n<tr>\n<td>Correlate resource usage with business transactions</td>\n<td>Profiling overhead must be minimal (&lt;2% CPU)</td>\n</tr>\n<tr>\n<td>Identify memory leaks by tracking heap growth over time</td>\n<td>Stack trace symbolization requires debug symbols</td>\n</tr>\n</tbody></table>\n<p><strong>Example Workflow:</strong> When the anomaly detector flags elevated p99 latency for the <code>payment-service</code>&#39;s <code>ProcessPayment</code> operation, engineers could query for CPU profiles collected during those high-latency traces, immediately seeing that 40% of CPU time was spent in a specific encryption library function that was recently updated.</p>\n<h4 id=\"142-ai-powered-root-cause-analysis\">14.2 AI-Powered Root Cause Analysis</h4>\n<p><strong>Mental Model: The Distributed Systems Detective with Machine Learning Intuition</strong></p>\n<blockquote>\n<p>Our current anomaly detection identifies <em>when</em> something is wrong. AI-powered root cause analysis would answer <em>why</em> and <em>what</em> caused it by learning normal patterns across thousands of dimensions and identifying the most probable culprit when deviations occur—like a seasoned detective who instantly recognizes which clue matters most.</p>\n</blockquote>\n<p>This enhancement would apply machine learning models to the rich correlation data already flowing through our system: service dependencies, latency patterns, error rates, and topology changes. By training models on historical incident data (what changed before an outage), the system could automatically suggest root causes when anomalies are detected.</p>\n<p><strong>Integration Approach:</strong></p>\n<ol>\n<li><strong>Feature Extraction Pipeline:</strong> Extend the existing analytics engine to compute additional features from trace data: service call graphs, latency distributions across dependency chains, error propagation patterns, and deployment timestamps.</li>\n<li><strong>Model Training Infrastructure:</strong> Add a batch processing pipeline that trains models on historical data labeled with known incidents (requires integration with incident management systems).</li>\n<li><strong>Real-Time Inference:</strong> Integrate trained models into the anomaly detection pipeline to provide root cause suggestions alongside anomaly alerts.</li>\n<li><strong>Feedback Loop:</strong> Allow engineers to validate or correct root cause suggestions, creating labeled data for continuous model improvement.</li>\n</ol>\n<p><strong>Implementation Components:</strong></p>\n<ul>\n<li><code>RootCauseAnalyzer</code> interface with <code>Analyze(anomalies []AnomalyResult, currentGraph ServiceGraph) RootCauseSuggestion</code></li>\n<li><code>ModelTrainingPipeline</code> for offline training on historical trace and incident data</li>\n<li>Enhanced <code>AnomalyResult</code> type with <code>SuggestedRootCauses []RootCauseSuggestion</code> field</li>\n</ul>\n<p><strong>Data Flow Enhancement:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Anomaly Detector → [New: Root Cause Analyzer] → Alert with suggested root cause\n                              ↓\n                   [New: Model Store] (periodically updated)\n                              ↓\n                   [New: Training Pipeline] (runs daily on historical data)</code></pre></div>\n\n<p><strong>Key Algorithms to Consider:</strong></p>\n<ul>\n<li><strong>Graph-based algorithms</strong> to identify service dependency changes coinciding with anomalies</li>\n<li><strong>Time-series correlation</strong> to find services whose metrics deviated first</li>\n<li><strong>Change point detection</strong> in deployment logs to correlate with performance regressions</li>\n</ul>\n<blockquote>\n<p><strong>Architecture Decision: Offline vs. Online Learning</strong></p>\n<ul>\n<li><strong>Context:</strong> We need to decide whether root cause models should be trained offline (batch) or online (continuously).</li>\n<li><strong>Option 1: Offline Batch Training:</strong> Train daily/weekly on historical data.<ul>\n<li><em>Pros:</em> Simpler infrastructure, easier model validation, predictable resource usage</li>\n<li><em>Cons:</em> Latency in adapting to new patterns, requires labeled historical data</li>\n</ul>\n</li>\n<li><strong>Option 2: Online Continuous Learning:</strong> Update models incrementally as new data arrives.<ul>\n<li><em>Pros:</em> Rapid adaptation to system changes, no manual retraining needed</li>\n<li><em>Cons:</em> Complex to implement correctly, risk of model drift, harder to debug</li>\n</ul>\n</li>\n<li><strong>Decision:</strong> Start with offline batch training for initial implementation.</li>\n<li><strong>Rationale:</strong> The primary goal is to prove value with simpler infrastructure. Offline training allows for careful validation of model suggestions before deployment. We can transition to online learning once the feature proves valuable and we understand the patterns better.</li>\n<li><strong>Consequences:</strong> Root cause suggestions may be slightly stale (up to 24 hours) but this is acceptable for initial implementation.</li>\n</ul>\n</blockquote>\n<h4 id=\"143-ebpf-based-instrumentation\">14.3 eBPF-Based Instrumentation</h4>\n<p><strong>Mental Model: The Universal System Tap</strong></p>\n<blockquote>\n<p>eBPF (extended Berkeley Packet Filter) allows us to insert instrumentation directly into the Linux kernel or application runtime without modifying source code—like installing microscopic sensors throughout a building&#39;s infrastructure (pipes, electrical, HVAC) that can monitor flow and performance without touching the rooms themselves.</p>\n</blockquote>\n<p>While our current APM SDK requires language-specific instrumentation (Go, Python, Java), eBPF-based instrumentation could provide universal, zero-code-change tracing for any application, including those written in languages we don&#39;t yet support or legacy systems where adding an SDK is impractical. This would dramatically expand the observability surface with minimal performance overhead.</p>\n<p><strong>Integration Approach:</strong></p>\n<ol>\n<li><strong>eBPF Collector Sidecar:</strong> Deploy a lightweight daemon (e.g., using <code>libbpf</code> or <code>bcc</code> tools) alongside each service that captures system calls, network traffic, and application runtime events.</li>\n<li><strong>Span Generation from Kernel Events:</strong> Transform eBPF events into spans, inferring service boundaries from network connections and process relationships.</li>\n<li><strong>Hybrid Instrumentation Strategy:</strong> Combine eBPF spans with SDK-generated spans for complete coverage, using consistent trace IDs.</li>\n<li><strong>Resource-Aware Sampling:</strong> Apply intelligent sampling at the eBPF level to manage the potentially massive volume of kernel-level events.</li>\n</ol>\n<p><strong>Technical Architecture:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[Application Process] ← eBPF probes → [eBPF Collector Sidecar] → Spans → [Existing Collector]\n       ↓                                       ↓\n [APM SDK spans]                        [Kernel/System spans]</code></pre></div>\n\n<p><strong>eBPF Event Types to Capture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Event Type</th>\n<th>Span Conversion</th>\n<th>Information Gained</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>sys_enter</code>/<code>sys_exit</code> for <code>connect</code>, <code>accept</code>, <code>send</code>, <code>recv</code></td>\n<td>Network call spans</td>\n<td>Cross-service calls without SDK</td>\n</tr>\n<tr>\n<td><code>sys_enter</code>/<code>sys_exit</code> for file I/O, disk operations</td>\n<td>Storage I/O spans</td>\n<td>Database/disk latency breakdown</td>\n</tr>\n<tr>\n<td>Application function entry/exit via USDT probes</td>\n<td>Function-level spans</td>\n<td>Code path visibility without source modification</td>\n</tr>\n<tr>\n<td>TCP retransmissions, congestion window changes</td>\n<td>Network quality spans</td>\n<td>Infrastructure-level issues affecting application</td>\n</tr>\n</tbody></table>\n<p><strong>Required New Components:</strong></p>\n<ul>\n<li><code>eBPFCollector</code> implementing <code>SpanExporter</code> interface</li>\n<li><code>eBPFSpanGenerator</code> converting eBPF events to <code>Span</code> objects</li>\n<li><code>KernelEventBuffer</code> with ring buffer for high-volume event handling</li>\n</ul>\n<p><strong>Performance Considerations:</strong></p>\n<ul>\n<li>eBPF programs run in the kernel with JIT compilation for near-native speed</li>\n<li>Event filtering at the kernel level reduces userspace overhead</li>\n<li>Still requires careful sampling for high-throughput systems</li>\n</ul>\n<h4 id=\"144-real-user-monitoring-rum-integration\">14.4 Real User Monitoring (RUM) Integration</h4>\n<p><strong>Mental Model: The Frontend Flight Recorder</strong></p>\n<blockquote>\n<p>While our current system monitors backend services, Real User Monitoring captures the actual user experience in browsers and mobile apps—like adding cockpit voice recorders and control inputs to our existing flight data recorders, giving us the complete picture from pilot intent to aircraft response.</p>\n</blockquote>\n<p>RUM extends tracing to the client side, capturing browser performance metrics (First Contentful Paint, Largest Contentful Paint), JavaScript errors, and user interaction timing. Integrating RUM with our existing backend traces creates end-to-end visibility from user click to database query and back.</p>\n<p><strong>Integration Strategy:</strong></p>\n<ol>\n<li><strong>Browser SDK Extension:</strong> Develop a lightweight JavaScript library that instruments page load, resource timing, and user interactions.</li>\n<li><strong>Trace Context Propagation:</strong> Extend W3C Trace Context to include frontend-originated trace IDs, ensuring seamless correlation with backend traces.</li>\n<li><strong>Session-Based Analysis:</strong> Group RUM events by user session to understand complete user journeys.</li>\n<li><strong>Synthetic Monitoring Baseline:</strong> Compare real user data with synthetic tests to distinguish network issues from application problems.</li>\n</ol>\n<p><strong>Data Model Extensions:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Extended Span type for RUM-specific data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RUMSpan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#6A737D\">                   // Embedded base span</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BrowserInfo      </span><span style=\"color:#B392F0\">BrowserInfo</span><span style=\"color:#6A737D\">  // Browser version, viewport size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageURL          </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">       // URL where span occurred</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UserInteraction  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">       // \"click\", \"scroll\", \"input\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WebVitals        </span><span style=\"color:#B392F0\">WebVitals</span><span style=\"color:#6A737D\">    // Core Web Vitals metrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WebVitals</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FCP    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#6A737D\">  // First Contentful Paint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LCP    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#6A737D\">  // Largest Contentful Paint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FID    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#6A737D\">  // First Input Delay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CLS    </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\">        // Cumulative Layout Shift</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Correlation Enhancement:</strong>\nWhen a user reports &quot;the checkout page is slow,&quot; engineers could:</p>\n<ol>\n<li>Query RUM spans for the checkout page to see if it&#39;s a frontend issue (slow LCP)</li>\n<li>Follow the trace ID to see backend processing time</li>\n<li>Identify whether the bottleneck is in JavaScript execution, network latency, or service processing</li>\n</ol>\n<h4 id=\"145-business-transaction-tracing\">14.5 Business Transaction Tracing</h4>\n<p><strong>Mental Model: The Business Process Map Overlay</strong></p>\n<blockquote>\n<p>While technical traces show service calls, business transaction tracing overlays business semantics (customer journeys, order flows, payment processing) onto the technical infrastructure—like adding labeled &quot;shipping routes&quot; and &quot;warehouse operations&quot; to a map of roads and buildings.</p>\n</blockquote>\n<p>This enhancement allows tagging traces with business context (user ID, order value, transaction type) and defining key business transactions (e.g., &quot;new user signup,&quot; &quot;premium checkout&quot;) that can be monitored for SLAs, error rates, and performance against business objectives.</p>\n<p><strong>Implementation Approach:</strong></p>\n<ol>\n<li><strong>Business Context Propagation:</strong> Extend trace context to include business key-value pairs that flow with the request.</li>\n<li><strong>Transaction Definition DSL:</strong> Create a domain-specific language for defining business transactions as patterns of spans with specific attributes.</li>\n<li><strong>Business Metrics Aggregation:</strong> Extend the analytics engine to compute metrics per business transaction rather than just per service/operation.</li>\n<li><strong>Business SLA Monitoring:</strong> Alert when business transactions violate defined SLAs (e.g., &quot;gold-tier checkout must complete under 2 seconds 99% of the time&quot;).</li>\n</ol>\n<p><strong>Example Business Transaction Definition:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">yaml</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#85E89D\">business_transactions</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#85E89D\">name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"premium_checkout\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    description</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Checkout flow for premium users\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    match</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#85E89D\">span.service</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"checkout-service\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        span.operation</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"process_payment\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        span.attributes.user_tier</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"premium\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#85E89D\">span.service</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"inventory-service\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        span.operation</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"reserve_item\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    sla</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      p99_latency</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2s\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      error_rate</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"0.1%\"</span></span></code></pre></div>\n\n<p><strong>Required System Changes:</strong></p>\n<ul>\n<li>Enhanced <code>Span</code> type with <code>BusinessAttributes map[string]string</code></li>\n<li>New <code>BusinessTransactionMonitor</code> component</li>\n<li>Extended Query Service API for querying traces by business attributes</li>\n<li>New visualization layer showing business transaction flow across services</li>\n</ul>\n<h4 id=\"146-trace-data-enrichment-with-logs-and-metrics\">14.6 Trace Data Enrichment with Logs and Metrics</h4>\n<p><strong>Mental Model: The Unified Observability Timeline</strong></p>\n<blockquote>\n<p>Currently, traces, logs, and metrics exist in separate silos. Enrichment creates bidirectional links between them—like adding cross-references between a detective&#39;s case notes (logs), crime scene photos (metrics), and witness interview transcripts (traces), creating a unified case file.</p>\n</blockquote>\n<p>This enhancement would correlate trace data with log entries and infrastructure metrics, allowing engineers to pivot from a slow trace to the corresponding application logs (to see error messages) and system metrics (to see CPU spikes) from the same time period.</p>\n<p><strong>Integration Architecture:</strong></p>\n<ol>\n<li><strong>Unified Storage Backend:</strong> Extend storage to support logs and metrics alongside traces, or implement connectors to existing log/metric systems.</li>\n<li><strong>Correlation Index:</strong> Create an index by timestamp and service to quickly find related telemetry data.</li>\n<li><strong>Query Language Enhancement:</strong> Extend the query language to support joins across trace, log, and metric data.</li>\n<li><strong>Unified Visualization:</strong> Create a single UI that shows traces alongside related logs and metrics.</li>\n</ol>\n<p><strong>Correlation Strategies:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Correlation Method</th>\n<th>Implementation</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Timestamp Proximity</strong></td>\n<td>Find logs/metrics within ±100ms of span timestamps</td>\n<td>General debugging</td>\n</tr>\n<tr>\n<td><strong>Trace Context Injection</strong></td>\n<td>Inject trace ID into log messages (via structured logging)</td>\n<td>Precise log-to-trace linking</td>\n</tr>\n<tr>\n<td><strong>Resource Attributes</strong></td>\n<td>Match by service name, host, container ID</td>\n<td>Infrastructure issue correlation</td>\n</tr>\n</tbody></table>\n<p><strong>Example Enhancement to Storage Layer:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Extended storage interface supporting multi-signal queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UnifiedStorage</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetTraceWithContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">traceID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TraceWithContext</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TraceWithContext</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Trace   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Logs    []</span><span style=\"color:#B392F0\">LogEntry</span><span style=\"color:#6A737D\">          // Related log entries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metrics []</span><span style=\"color:#B392F0\">MetricSample</span><span style=\"color:#6A737D\">      // Related metric samples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Events  []</span><span style=\"color:#B392F0\">InfrastructureEvent</span><span style=\"color:#6A737D\"> // Deployment, scaling events</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"147-multi-tenancy-and-data-isolation\">14.7 Multi-Tenancy and Data Isolation</h4>\n<p><strong>Mental Model: The Observability Apartment Building</strong></p>\n<blockquote>\n<p>Currently, our system treats all data as belonging to a single organization. Multi-tenancy adds separate &quot;apartments&quot; (tenants) with soundproof walls and separate entrances—each tenant&#39;s data is fully isolated, but they share the same building infrastructure (collectors, storage, query engines).</p>\n</blockquote>\n<p>This enhancement would enable serving multiple independent organizations or internal teams from a single APM deployment, with strict data isolation, tenant-specific configurations, and usage-based billing.</p>\n<p><strong>Implementation Considerations:</strong></p>\n<ol>\n<li><strong>Tenant Identification:</strong> Add tenant ID to all spans, either via authentication tokens or request headers.</li>\n<li><strong>Storage Isolation:</strong> Implement storage backends that support tenant partitioning at the data layer.</li>\n<li><strong>Query Isolation:</strong> Extend all query APIs to filter by tenant ID, enforced at the API gateway.</li>\n<li><strong>Rate Limiting and Quotas:</strong> Apply tenant-specific limits on ingestion rate, storage usage, and query frequency.</li>\n<li><strong>Administrative UI:</strong> Add tenant management interfaces for provisioning, configuration, and usage monitoring.</li>\n</ol>\n<p><strong>Data Flow Changes:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[Tenant A App] → [Collector] → [Storage with Tenant Partitioning]\n[Tenant B App] ↗        ↓\n           [Query Service with Tenant Filtering] → [Tenant-Specific UI]</code></pre></div>\n\n<p><strong>Security Considerations:</strong></p>\n<ul>\n<li>Tenant isolation must be enforced at every layer (API, storage, cache)</li>\n<li>No cross-tenant data leakage in aggregations or sampling decisions</li>\n<li>Audit logging of all tenant data access</li>\n</ul>\n<h4 id=\"148-advanced-visualization-flame-graphs-and-heat-maps\">14.8 Advanced Visualization: Flame Graphs and Heat Maps</h4>\n<p><strong>Mental Model: The Performance Topographical Map</strong></p>\n<blockquote>\n<p>While our current service map shows service relationships, flame graphs show time distribution within a service, and heat maps show request density patterns—like adding elevation contours (flame graphs) and population density shading (heat maps) to a geographical map, revealing not just locations but intensity and distribution.</p>\n</blockquote>\n<p>These visualization enhancements would help engineers quickly identify hotspots in their code (flame graphs) and understand temporal patterns of request flow (heat maps).</p>\n<p><strong>Flame Graph Implementation:</strong></p>\n<ol>\n<li><strong>Span Stack Construction:</strong> Convert parent-child span relationships into call stacks for flame graph rendering.</li>\n<li><strong>Time-Aggregated Views:</strong> Aggregate spans from multiple traces to show typical execution patterns.</li>\n<li><strong>Interactive Exploration:</strong> Allow drilling into specific functions or time ranges.</li>\n</ol>\n<p><strong>Heat Map Implementation:</strong></p>\n<ol>\n<li><strong>Request Density Calculation:</strong> Compute requests per second across services and time buckets.</li>\n<li><strong>Latency Coloring:</strong> Color cells by average latency or error rate.</li>\n<li><strong>Anomaly Highlighting:</strong> Visually flag time periods with anomalies.</li>\n</ol>\n<p><strong>Visualization Integration:</strong></p>\n<ul>\n<li>Extend the existing Web UI with new visualization components</li>\n<li>Add new API endpoints for flame graph and heat map data</li>\n<li>Support exporting visualizations for incident reports</li>\n</ul>\n<h4 id=\"149-predictive-capacity-planning\">14.9 Predictive Capacity Planning</h4>\n<p><strong>Mental Model: The Observability Crystal Ball</strong></p>\n<blockquote>\n<p>While current analytics tell us what <em>is</em> happening and what <em>did</em> happen, predictive capacity planning forecasts what <em>will</em> happen—like using weather radar patterns to predict storm paths and intensities hours in advance.</p>\n</blockquote>\n<p>This enhancement would apply time-series forecasting algorithms to historical performance data to predict future resource needs, identify capacity bottlenecks before they cause outages, and recommend scaling actions.</p>\n<p><strong>Forecasting Algorithms:</strong></p>\n<ul>\n<li><strong>ARIMA/SARIMA</strong> for seasonal patterns</li>\n<li><strong>Prophet</strong> for handling holidays and changepoints</li>\n<li><strong>LSTM neural networks</strong> for complex multi-variate patterns</li>\n</ul>\n<p><strong>Integration Points:</strong></p>\n<ol>\n<li><strong>Forecasting Pipeline:</strong> Extend the analytics engine with forecasting modules that run periodically.</li>\n<li><strong>Capacity Recommendations:</strong> Generate actionable recommendations (e.g., &quot;Increase payment-service instances by 2 before Black Friday&quot;).</li>\n<li><strong>What-If Analysis:</strong> Simulate the impact of traffic increases or infrastructure changes.</li>\n</ol>\n<p><strong>Example Output:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"service\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"payment-service\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"metric\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"p95_latency\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"current_value\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"145ms\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"forecast\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"1_hour\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"152ms (±8ms)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"24_hours\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"210ms (±25ms)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"7_days\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Will exceed 500ms SLA in 4.3 days at current growth rate\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"recommendation\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Add 2 instances within 48 hours\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"1410-enhancement-prioritization-framework\">14.10 Enhancement Prioritization Framework</h4>\n<p>To help prioritize which enhancements to implement first, consider this decision matrix:</p>\n<table>\n<thead>\n<tr>\n<th>Enhancement</th>\n<th>Business Value</th>\n<th>Implementation Complexity</th>\n<th>Data Volume Impact</th>\n<th>User Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Continuous Profiling</td>\n<td>High (pinpoints code issues)</td>\n<td>Medium (new data type)</td>\n<td>High (large profiles)</td>\n<td>Medium (developers)</td>\n</tr>\n<tr>\n<td>AI Root Cause Analysis</td>\n<td>Very High (reduces MTTR)</td>\n<td>High (ML expertise)</td>\n<td>Low (metadata only)</td>\n<td>High (on-call engineers)</td>\n</tr>\n<tr>\n<td>eBPF Instrumentation</td>\n<td>High (universal coverage)</td>\n<td>Very High (kernel expertise)</td>\n<td>Very High (raw events)</td>\n<td>Medium (platform teams)</td>\n</tr>\n<tr>\n<td>RUM Integration</td>\n<td>High (end-to-end visibility)</td>\n<td>Medium (new SDK)</td>\n<td>Medium (browser data)</td>\n<td>High (frontend teams)</td>\n</tr>\n<tr>\n<td>Business Transaction Tracing</td>\n<td>High (aligns with business)</td>\n<td>Low (metadata addition)</td>\n<td>Low (small attributes)</td>\n<td>High (product managers)</td>\n</tr>\n<tr>\n<td>Multi-Tenancy</td>\n<td>Medium (enables SaaS)</td>\n<td>High (security critical)</td>\n<td>Medium (partitioning)</td>\n<td>Medium (operations)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The most valuable enhancements often build upon existing capabilities with minimal disruption. Business Transaction Tracing and RUM Integration offer high value with moderate complexity, making them excellent candidates for near-term implementation.</p>\n</blockquote>\n<h3 id=\"implementation-guidance-for-future-extensions\">Implementation Guidance for Future Extensions</h3>\n<p><strong>A. Technology Recommendations for Extensions</strong></p>\n<table>\n<thead>\n<tr>\n<th>Extension</th>\n<th>Core Technology</th>\n<th>Integration Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Continuous Profiling</td>\n<td><strong>pprof</strong> (Go), <strong>py-spy</strong> (Python), <strong>async-profiler</strong> (Java)</td>\n<td>Extend <code>Tracer</code> to optionally capture profiles</td>\n</tr>\n<tr>\n<td>AI Root Cause Analysis</td>\n<td><strong>scikit-learn</strong>, <strong>TensorFlow</strong>, or <strong>H2O.ai</strong> for ML; <strong>Jupyter</strong> for analysis</td>\n<td>New <code>RootCauseAnalyzer</code> component in analytics layer</td>\n</tr>\n<tr>\n<td>eBPF Instrumentation</td>\n<td><strong>libbpf</strong> (C library), <strong>bcc</strong> (Python tools), <strong>cilium/ebpf</strong> (Go library)</td>\n<td>New <code>eBPFCollector</code> sidecar process</td>\n</tr>\n<tr>\n<td>RUM Integration</td>\n<td><strong>Web Performance API</strong>, <strong>Error Tracking API</strong></td>\n<td>New JavaScript SDK extending W3C Trace Context</td>\n</tr>\n<tr>\n<td>Business Transaction Tracing</td>\n<td><strong>YAML/JSON DSL</strong> for definitions</td>\n<td>Extend <code>Span</code> attributes and add <code>BusinessTransactionMonitor</code></td>\n</tr>\n<tr>\n<td>Multi-Tenancy</td>\n<td><strong>JWT/OAuth2</strong> for auth, <strong>PostgreSQL Row Security</strong> or storage partitioning</td>\n<td>Tenant ID propagation throughout data pipeline</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure for Extensible Design</strong></p>\n<p>To accommodate future extensions without major refactoring, organize the codebase with clear interfaces and plugin points:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    collector/           # Main collector binary\n    query-service/       # Query service binary\n    web-ui/             # Web UI server\n  internal/\n    # Core components (existing)\n    ingestion/          # Pipeline, validation, buffering\n    storage/            # Span storage interfaces and implementations\n    sampling/           # Head and tail sampling\n    analytics/          # Percentiles, anomaly detection\n    sdk/                # Auto-instrumentation libraries\n    \n    # Extension points (new directories)\n    extensions/         # Interfaces and registries for extensions\n      profiler/         # Profiling extension interfaces\n      rum/              # RUM extension interfaces  \n      ebpf/             # eBPF collection interfaces\n      business/         # Business transaction interfaces\n    \n    # Implementation of specific extensions (when built)\n    extensions/impl/\n      profiler-pprof/   # pprof-based profiler\n      rum-js/           # JavaScript RUM SDK\n      ebpf-collector/   # eBPF event collector\n      \n  pkg/\n    api/                # Public APIs for external integration\n    models/             # Core data types (Span, Trace, etc.)\n    plugin/             # Plugin framework interfaces</code></pre></div>\n\n<p><strong>C. Extension Point Interfaces</strong></p>\n<p>To ensure the system can be extended without modification to core components, define these key interfaces:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Extension point for adding new telemetry sources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TelemetrySource</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Name</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Stop</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TelemetryChan</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;-chan</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extension point for adding new analysis modules  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AnalysisModule</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Name</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Analyze</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">trace</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">AnalysisResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RequiredFields</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Span fields needed for analysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extension point for adding new visualizations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VisualizationProvider</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Name</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Type</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // \"flamegraph\", \"heatmap\", etc.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    DataQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">params</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RenderOptions</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Registry for extensions (simplified example)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExtensionRegistry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sources     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">TelemetrySource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    analyzers   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">AnalysisModule</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    visualizers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">VisualizationProvider</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ExtensionRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterSource</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">source</span><span style=\"color:#B392F0\"> TelemetrySource</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> r.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.sources[source.</span><span style=\"color:#B392F0\">Name</span><span style=\"color:#E1E4E8\">()] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize extensions in main()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    registry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewExtensionRegistry</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register built-in extensions based on configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.EnableProfiling {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        registry.</span><span style=\"color:#B392F0\">RegisterSource</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">NewPProfProfiler</span><span style=\"color:#E1E4E8\">(config.Profiling))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.EnableRUM {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        registry.</span><span style=\"color:#B392F0\">RegisterSource</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">NewRUMSource</span><span style=\"color:#E1E4E8\">(config.RUM))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start all registered extensions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, source </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> registry.</span><span style=\"color:#B392F0\">Sources</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#E1E4E8\"> source.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Design for Extension: Span Enrichment Pattern</strong></p>\n<p>Many extensions (business tracing, multi-tenancy, log correlation) need to add metadata to spans. Instead of modifying the core <code>Span</code> type for each extension, use an extensible attributes pattern:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Current Span type already has Attributes map[string]string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Use a namespacing convention for extension attributes:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// \"extension.attribute_name\" → \"value\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Business transaction attributes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">span.Attributes[</span><span style=\"color:#9ECBFF\">\"business.transaction\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"premium_checkout\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">span.Attributes[</span><span style=\"color:#9ECBFF\">\"business.customer_tier\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"gold\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RUM attributes  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">span.Attributes[</span><span style=\"color:#9ECBFF\">\"rum.browser\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Chrome 91\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">span.Attributes[</span><span style=\"color:#9ECBFF\">\"rum.page_url\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"https://example.com/checkout\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Multi-tenancy attributes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">span.Attributes[</span><span style=\"color:#9ECBFF\">\"tenant.id\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"acme-corp\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">span.Attributes[</span><span style=\"color:#9ECBFF\">\"tenant.environment\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"production\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper functions for extension authors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> AddBusinessContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">span</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Span</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">transaction</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">attributes</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    span.Attributes[</span><span style=\"color:#9ECBFF\">\"business.transaction\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> transaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> k, v </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> attributes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        span.Attributes[</span><span style=\"color:#9ECBFF\">\"business.\"</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">k] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> v</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Query support for extension attributes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> GetTracesByBusinessTransaction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">transaction</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Trace</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Storage layer should index extension.* attributes for efficient querying</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> storage.</span><span style=\"color:#B392F0\">GetTracesByAttribute</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#9ECBFF\">\"business.transaction\"</span><span style=\"color:#E1E4E8\">, transaction)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Migration Strategy for Extensions</strong></p>\n<p>When implementing extensions that change data schemas or require new storage formats:</p>\n<ol>\n<li><strong>Versioned Data Formats:</strong> Always include a version field in stored data.</li>\n<li><strong>Dual-Write During Migration:</strong> Write both old and new formats during transition.</li>\n<li><strong>Backward Compatibility:</strong> Ensure queries work with old data formats.</li>\n<li><strong>Gradual Rollout:</strong> Enable extensions per-service or per-tenant initially.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example: Adding profile storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StorageV1</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">/* existing span storage */</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StorageV2</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    StorageV1</span><span style=\"color:#6A737D\">                    // embedded for backward compatibility</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    profileStorage </span><span style=\"color:#B392F0\">ProfileStorage</span><span style=\"color:#6A737D\"> // new capability</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// During migration period</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> config.UseProfilingExtension {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Store profiles in new storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storageV2.profileStorage.</span><span style=\"color:#B392F0\">StoreProfile</span><span style=\"color:#E1E4E8\">(profile)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Always store spans in V1-compatible format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">storageV1.</span><span style=\"color:#B392F0\">StoreSpan</span><span style=\"color:#E1E4E8\">(span)</span></span></code></pre></div>\n\n<p><strong>F. Testing Extension Points</strong></p>\n<p>Create test helpers for extension developers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Extension test suite</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestExtensionContract</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify extension implements required interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#B392F0\">extensions</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TelemetrySource</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MyExtension</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test integration with core pipeline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pipeline </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ingestion.</span><span style=\"color:#B392F0\">NewTestPipeline</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    extension </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMyExtension</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start extension</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> extension.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify it produces valid spans</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> span </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">extension.</span><span style=\"color:#B392F0\">TelemetryChan</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">NotEmpty</span><span style=\"color:#E1E4E8\">(t, span.TraceID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">NotEmpty</span><span style=\"color:#E1E4E8\">(t, span.ServiceName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">time.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Extension didn't produce telemetry within 1 second\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>G. Performance Monitoring for Extensions</strong></p>\n<p>Extensions should include their own performance monitoring:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExtensionMetrics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpansGenerated   </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Counter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ProcessingTime   </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Histogram</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Errors           </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Counter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueueLength      </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Gauge</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register with central metrics registry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MyExtension</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">registerMetrics</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metrics.ExtensionMetrics.</span><span style=\"color:#B392F0\">WithLabelValues</span><span style=\"color:#E1E4E8\">(e.</span><span style=\"color:#B392F0\">Name</span><span style=\"color:#E1E4E8\">()).</span><span style=\"color:#B392F0\">Inc</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>Key Implementation Insight:</strong> The most important design principle for future extensions is <strong>dependency inversion</strong>—core components should depend on abstractions (interfaces) that extensions implement, not the other way around. This allows adding new capabilities without modifying tested core code.</p>\n</blockquote>\n<p>By designing with these extension points in mind, the APM Tracing System can evolve gracefully to incorporate new observability capabilities as they emerge, ensuring the system remains valuable and relevant as technology and requirements change.</p>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides a comprehensive reference for terminology used throughout all five milestones of the APM Tracing System, ensuring consistent understanding across the design document.</p>\n</blockquote>\n<h2 id=\"15-glossary\">15. Glossary</h2>\n<p>As you navigate the design of the APM Tracing System, you&#39;ll encounter specialized terms that carry precise technical meanings. This glossary serves as a definitive reference, clarifying terminology used across all system components. Think of it as the <strong>legend for a complex map</strong>—it doesn&#39;t change the territory, but makes it readable. Having a shared vocabulary is essential for clear communication among team members and for understanding the architectural decisions documented throughout this design.</p>\n<h3 id=\"terminology-reference\">Terminology Reference</h3>\n<p>The following table defines key terms used in this design document, organized alphabetically for quick reference.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context &amp; Significance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Adaptive Sampling</strong></td>\n<td>A sampling strategy that dynamically adjusts sampling rates based on system load, trace value, or other real-time metrics.</td>\n<td>Used in <strong>Milestone 3</strong> to balance data volume with insight preservation. Unlike fixed-rate sampling, adaptive sampling responds to changing conditions—for example, lowering rates during traffic surges to protect storage, or increasing rates when error rates spike to capture more debugging data.</td>\n</tr>\n<tr>\n<td><strong>Anomaly</strong></td>\n<td>A data point or pattern in metrics that deviates significantly from expected, historical behavior.</td>\n<td>The target of detection in <strong>Milestone 4</strong>. Anomalies in APM systems typically manifest as sudden latency spikes, error rate increases, or throughput drops. Distinguishing true anomalies from expected variations (like daily traffic patterns) is a core challenge.</td>\n</tr>\n<tr>\n<td><strong>APM (Application Performance Monitoring)</strong></td>\n<td>The practice and technology for monitoring software applications for performance, availability, and user experience.</td>\n<td>The overarching domain of this project. APM systems combine distributed tracing, metrics, and sometimes logs to provide holistic visibility into application behavior. Our system focuses specifically on the tracing pillar.</td>\n</tr>\n<tr>\n<td><strong>Backpressure</strong></td>\n<td>A flow control mechanism where a downstream component signals upstream components to slow down or stop sending data when it cannot keep up.</td>\n<td>A critical resilience concept discussed in <strong>Section 11</strong>. When the collector is overwhelmed, it must apply backpressure (e.g., via aggressive sampling or connection refusal) to prevent cascading failures and data loss.</td>\n</tr>\n<tr>\n<td><strong>Baseline</strong></td>\n<td>Historical performance data (e.g., latency percentiles, error rates) used as a reference for comparison when detecting anomalies.</td>\n<td>Established in <strong>Milestone 4</strong> through analysis of past metrics. Baselines can be simple (like a rolling average) or sophisticated (accounting for weekly seasonality). Comparing current metrics against baselines allows the system to identify deviations that warrant investigation.</td>\n</tr>\n<tr>\n<td><strong>Buffer Eviction</strong></td>\n<td>The process of removing items from an in-memory buffer when it reaches capacity or when items have exceeded their time-to-live (TTL).</td>\n<td>A key mechanism in <strong>Milestone 1&#39;s</strong> <code>BufferManager</code>. Since we cannot buffer spans indefinitely while waiting for late-arriving spans, we must evict old, incomplete traces. The eviction policy (e.g., LRU, based on first-seen time) directly impacts trace completeness.</td>\n</tr>\n<tr>\n<td><strong>Business Transaction Tracing</strong></td>\n<td>Tagging traces with business context (e.g., customer ID, transaction type) to enable monitoring and analysis of business processes rather than just technical operations.</td>\n<td>A <strong>Future Extension</strong> from Section 14. This allows correlating performance issues with business impact—for example, seeing that checkout latency increases are affecting premium customers.</td>\n</tr>\n<tr>\n<td><strong>Cascading Failures</strong></td>\n<td>A failure mode where the failure of one component causes failures in dependent components, potentially leading to system-wide outage.</td>\n<td>A risk mitigated by patterns like circuit breakers and backpressure. In our APM system, if the storage backend becomes slow, the collector could exhaust memory buffering spans, then become unresponsive to new spans, causing instrumentation SDKs to block or drop data.</td>\n</tr>\n<tr>\n<td><strong>Chaos Testing</strong></td>\n<td>A testing methodology that deliberately injects failures (network partitions, process kills, latency spikes) into a system to verify its resilience.</td>\n<td>Part of the <strong>Testing Strategy</strong> in Section 12. For our APM system, chaos testing might involve randomly killing collector instances or introducing high latency to storage to verify that sampling degrades gracefully and data isn&#39;t lost.</td>\n</tr>\n<tr>\n<td><strong>Circuit Breaker Pattern</strong></td>\n<td>A design pattern that prevents calls to a failing service by opening a &quot;circuit&quot; after failure thresholds are exceeded, failing fast instead of waiting for timeouts.</td>\n<td>Used in <strong>Section 11</strong> for protecting interactions between components (e.g., collector to storage). The <code>CircuitBreaker</code> struct implements states (<code>StateClosed</code>, <code>StateOpen</code>, <code>StateHalfOpen</code>) to prevent overloading already-struggling dependencies.</td>\n</tr>\n<tr>\n<td><strong>Clock Skew</strong></td>\n<td>The difference in system clock times between different machines in a distributed system.</td>\n<td>A <strong>Common Pitfall</strong> in <strong>Milestone 1</strong>. Since spans arrive from multiple services with potentially unsynchronized clocks, relying solely on span timestamps for ordering can produce incorrect trace sequences. The system must handle or normalize for clock skew.</td>\n</tr>\n<tr>\n<td><strong>Columnar Storage</strong></td>\n<td>A storage format that organizes data by columns rather than rows, optimizing for analytical queries that aggregate over specific fields.</td>\n<td>Mentioned as an optimization for trace storage. Storing all <code>Duration</code> values contiguously enables faster percentile calculations across many traces, compared to row-oriented storage that would load entire spans.</td>\n</tr>\n<tr>\n<td><strong>Consistent Hashing</strong></td>\n<td>A hash function that ensures the same input (e.g., trace ID) always maps to the same output, enabling deterministic decisions across distributed components.</td>\n<td>Critical for <strong>head-based sampling</strong> in <strong>Milestone 3</strong>. Using <code>ConsistentSampler.ShouldSample(traceID)</code> with a hash function guarantees that all spans from the same trace receive the same sampling decision, even if they arrive at different collectors.</td>\n</tr>\n<tr>\n<td><strong>Context Propagation</strong></td>\n<td>The mechanism for carrying trace context (trace ID, span ID, sampling decision) across process and service boundaries, typically via HTTP headers or RPC metadata.</td>\n<td>A core concept in <strong>Milestone 5</strong>. The SDK&#39;s <code>InjectTraceContext</code> and <code>ExtractTraceContext</code> methods implement the W3C Trace Context standard, allowing traces to continue seamlessly across service calls.</td>\n</tr>\n<tr>\n<td><strong>Continuous Profiling</strong></td>\n<td>The practice of periodically capturing and analyzing application profiles (CPU, memory allocation) to identify performance bottlenecks over time.</td>\n<td>A <strong>Future Extension</strong> that could integrate with the APM system. While tracing shows <em>what</em> happened and <em>when</em>, profiling shows <em>why</em> certain code paths are slow by revealing hot functions and allocation patterns.</td>\n</tr>\n<tr>\n<td><strong>Cycle Detection</strong></td>\n<td>An algorithm to identify circular dependencies in service calls (e.g., Service A → Service B → Service A), which can indicate architectural issues or cause infinite loops.</td>\n<td>Part of <strong>service map construction</strong> in <strong>Milestone 2</strong>. The <code>ServiceGraph</code> should identify cycles to alert developers about potentially problematic dependency patterns that could lead to cascading failures.</td>\n</tr>\n<tr>\n<td><strong>Dictionary Encoding</strong></td>\n<td>A compression technique that replaces repeated string values (like service names or operation names) with integer IDs in storage, reducing disk usage and improving query performance.</td>\n<td>An optimization for trace storage. Since <code>ServiceName</code> and <code>Span.Name</code> fields often have high repetition, dictionary encoding can significantly reduce the storage footprint of the <code>Attributes</code> map and other string-heavy fields.</td>\n</tr>\n<tr>\n<td><strong>Distributed Tracing</strong></td>\n<td>A method of tracking requests as they propagate through a distributed system, recording timing data and metadata at each step (span) to form a complete timeline (trace).</td>\n<td>The foundational technique of this entire project. It addresses the observability challenge in microservices by providing request-centric visibility, as opposed to metric- or log-centric views.</td>\n</tr>\n<tr>\n<td><strong>Edge Aggregation</strong></td>\n<td>The process of combining multiple individual service call observations (spans) into summarized metrics (call count, error rate, latency percentiles) for a specific caller-callee pair over a time window.</td>\n<td>The core operation in <strong>Milestone 2&#39;s</strong> <code>EdgeAggregator</code>. Instead of storing every call, we aggregate spans into <code>ServiceEdge</code> records that represent the communication pattern between two services during a specific time window.</td>\n</tr>\n<tr>\n<td><strong>eBPF (Extended Berkeley Packet Filter)</strong></td>\n<td>A technology for running sandboxed programs in the Linux kernel, enabling observability, networking, and security functionality without modifying kernel source code or loading kernel modules.</td>\n<td>A <strong>Future Extension</strong> for zero-instrumentation tracing. An <code>eBPFCollector</code> could automatically trace system calls, network traffic, or application functions without requiring code changes, complementing the SDK-based instrumentation.</td>\n</tr>\n<tr>\n<td><strong>Flame Graph</strong></td>\n<td>A visualization of hierarchical data, typically call stacks, where the width of each element represents its resource consumption (CPU time, memory allocations).</td>\n<td>A potential visualization for performance analytics. While not part of the core milestones, flame graphs could be generated from trace data to show which code paths contribute most to latency.</td>\n</tr>\n<tr>\n<td><strong>Graceful Degradation</strong></td>\n<td>A design principle where a system continues to operate with reduced functionality rather than failing completely when under stress or partial failure.</td>\n<td>A guiding principle for <strong>Error Handling</strong>. For example, when storage is unavailable, the collector might switch to a &quot;degraded mode&quot; where it samples traces more aggressively but still provides some visibility, rather than rejecting all spans.</td>\n</tr>\n<tr>\n<td><strong>Head-Based Sampling</strong></td>\n<td>A sampling strategy where the decision to keep or drop a trace is made at the very beginning of the trace (when the root span is created), using only initial context (trace ID, service name).</td>\n<td>Implemented by the <code>HeadSampler</code> in <strong>Milestone 3</strong>. This is efficient (no buffering required) but risks dropping interesting traces that only become &quot;interesting&quot; later (e.g., due to an error in a downstream service).</td>\n</tr>\n<tr>\n<td><strong>Head-of-Line Blocking</strong></td>\n<td>A performance issue where processing of one item is delayed, causing all subsequent items in the queue to wait, even if they could be processed independently.</td>\n<td>A potential pitfall in the ingestion pipeline. If one malformed span requires expensive validation or blocking I/O, it shouldn&#39;t stall the processing of all other spans. The pipeline design uses buffered channels and parallel processing to avoid this.</td>\n</tr>\n<tr>\n<td><strong>Health Check</strong></td>\n<td>An endpoint or probe that reports the operational status of a component or system, typically used by load balancers and orchestration systems to determine if an instance should receive traffic.</td>\n<td>Implemented via <code>HealthRegistry</code> and its handlers (<code>HealthHandler</code>, <code>LivenessHandler</code>, <code>ReadinessHandler</code>) in <strong>Section 11</strong>. The health check aggregates status from all components (collector, buffer manager, storage connection) to give a holistic view.</td>\n</tr>\n<tr>\n<td><strong>Infrastructure Metrics</strong></td>\n<td>System-level measurements like CPU utilization, memory usage, disk I/O, and network bandwidth, as opposed to application-level metrics (request latency, error rates).</td>\n<td>A <strong>Non-Goal</strong> of this APM system (we focus on application traces), but mentioned as a complementary observability signal. In a unified observability platform, infrastructure metrics would correlate with trace data to identify root causes.</td>\n</tr>\n<tr>\n<td><strong>Integration Test</strong></td>\n<td>A test that verifies multiple components work together correctly by testing their interactions through real or simulated interfaces.</td>\n<td>Part of the <strong>Testing Strategy</strong>. For example, an integration test might start a collector, send spans via the OTLP endpoint, and verify they appear in storage and affect the service map.</td>\n</tr>\n<tr>\n<td><strong>Load Test</strong></td>\n<td>A test that measures system performance (throughput, latency, resource usage) under expected or peak load conditions.</td>\n<td>Essential for verifying <strong>Milestone 1</strong> acceptance criteria (handling 1000 spans/second). Load tests simulate production traffic patterns to identify bottlenecks and validate scaling assumptions.</td>\n</tr>\n<tr>\n<td><strong>Log Aggregation</strong></td>\n<td>The practice of centralized collection, indexing, and search of unstructured log data from multiple services.</td>\n<td>A <strong>Non-Goal</strong>—our system focuses on structured trace data, not unstructured logs. However, traces can be correlated with logs via trace IDs injected into log messages, creating a unified debugging experience.</td>\n</tr>\n<tr>\n<td><strong>Liveness Probe</strong></td>\n<td>A type of health check that indicates whether a process is running (alive), without guaranteeing it&#39;s ready to handle work.</td>\n<td>Simpler than a readiness check. The <code>LivenessHandler</code> typically returns success as long as the process hasn&#39;t crashed. Kubernetes uses this to decide when to restart a container.</td>\n</tr>\n<tr>\n<td><strong>Microservices</strong></td>\n<td>An architectural style that structures an application as a collection of loosely coupled, independently deployable services that communicate via APIs.</td>\n<td>The primary architectural context for distributed tracing. Microservices introduce the observability challenge that tracing solves: a single user request may traverse dozens of services, making debugging without traces nearly impossible.</td>\n</tr>\n<tr>\n<td><strong>Middleware</strong></td>\n<td>A software layer that intercepts requests and responses in a framework&#39;s processing pipeline, enabling cross-cutting concerns like logging, authentication, and—in our case—tracing.</td>\n<td>The primary instrumentation technique in <strong>Milestone 5</strong> for web frameworks. The SDK provides middleware for Gin (Go), Express (Node.js), and Flask (Python) that automatically creates spans for incoming HTTP requests.</td>\n</tr>\n<tr>\n<td><strong>Mock</strong></td>\n<td>A simulated object that mimics the behavior of a real component in controlled ways for testing purposes.</td>\n<td>Used extensively in unit tests. For example, we mock the <code>storage.Writer</code> interface to test the collector without needing a real database, verifying that <code>StoreSpan</code> is called with expected parameters.</td>\n</tr>\n<tr>\n<td><strong>Monkey Patching</strong></td>\n<td>A technique to modify or extend the behavior of a library at runtime by replacing its functions or methods.</td>\n<td>One method for <strong>auto-instrumentation</strong> in <strong>Milestone 5</strong>, particularly in dynamic languages like Python. The SDK might monkey-patch the <code>requests</code> library to automatically inject trace headers into all HTTP requests. Must be done carefully to avoid breaking original behavior.</td>\n</tr>\n<tr>\n<td><strong>Moving Average</strong></td>\n<td>A calculation to analyze data points by creating a series of averages of different subsets of the full data set, often used to smooth short-term fluctuations and highlight longer-term trends.</td>\n<td>One statistical method for <strong>anomaly detection</strong> in <strong>Milestone 4</strong>. By comparing current latency to a moving average of recent latencies, we can detect deviations from recent norms.</td>\n</tr>\n<tr>\n<td><strong>Multi-Tenancy</strong></td>\n<td>An architectural pattern where a single deployment of software serves multiple independent customers (tenants), with data and configuration isolated between them.</td>\n<td>A <strong>Future Extension</strong> consideration. The APM system could be enhanced to support multiple teams or external customers, requiring isolation of trace data, sampling configurations, and service maps per tenant.</td>\n</tr>\n<tr>\n<td><strong>OpenTelemetry</strong></td>\n<td>A vendor-neutral, open-source collection of APIs, SDKs, and tools for instrumenting, generating, collecting, and exporting telemetry data (traces, metrics, logs).</td>\n<td>The standard we adopt for trace format and context propagation. Our collector accepts spans in <strong>OpenTelemetry Protocol (OTLP)</strong> format via the <code>OTLPHandler</code>, ensuring compatibility with a wide ecosystem of instrumentation libraries.</td>\n</tr>\n<tr>\n<td><strong>OpenTelemetry Protocol (OTLP)</strong></td>\n<td>The standard protocol defined by OpenTelemetry for telemetry data exchange between clients and collectors, supporting both gRPC and HTTP/JSON transports.</td>\n<td>The wire format for span ingestion. The <code>parseOTLPJSON</code> and <code>parseOTLPProtobuf</code> methods convert OTLP payloads into our internal <code>Span</code> representation, ensuring we can receive data from any OpenTelemetry-compliant SDK.</td>\n</tr>\n<tr>\n<td><strong>Percentile</strong></td>\n<td>A value below which a given percentage of observations in a group of observations falls. For example, the 95th percentile (p95) latency is the value below which 95% of observed latencies fall.</td>\n<td>A core metric in <strong>Milestone 4</strong>. Percentiles (p50, p95, p99) are more informative than averages for performance analysis because they reveal tail latency behavior that affects user experience.</td>\n</tr>\n<tr>\n<td><strong>PID Controller</strong></td>\n<td>A control loop mechanism that uses proportional, integral, and derivative terms to calculate an error value as the difference between a desired setpoint and a measured process variable.</td>\n<td>One possible algorithm for <strong>adaptive sampling</strong> in <strong>Milestone 3</strong>. A PID controller could adjust sampling rates to maintain a target span ingestion rate, smoothly responding to traffic changes without oscillation.</td>\n</tr>\n<tr>\n<td><strong>pipes and filters</strong></td>\n<td>An architectural pattern where data flows through a sequence of processing components (filters), each performing a specific transformation, connected by pipes (channels, queues).</td>\n<td>The pattern used in the ingestion <code>Pipeline</code>. Spans flow through: validator → buffer manager → head sampler → (later) tail sampler → storage writer. This design promotes separation of concerns and easy component replacement.</td>\n</tr>\n<tr>\n<td><strong>Predictive Capacity Planning</strong></td>\n<td>Using historical performance data and trends to forecast future resource needs (CPU, memory, storage) for a system.</td>\n<td>A <strong>Future Extension</strong> leveraging the analytics engine. By analyzing trace volume growth and latency trends, the system could predict when storage capacity will be exhausted or when additional collector instances will be needed.</td>\n</tr>\n<tr>\n<td><strong>Property-Based Testing</strong></td>\n<td>A testing methodology that verifies properties or invariants hold for a large number of randomly generated inputs, rather than testing specific examples.</td>\n<td>Useful for testing complex logic like trace assembly. For example, a property-based test could generate random spans with valid parent-child relationships and verify that <code>TraceAssembler.AssembleTrace</code> always produces a properly structured trace hierarchy.</td>\n</tr>\n<tr>\n<td><strong>Readiness Probe</strong></td>\n<td>A type of health check that indicates whether a component is ready to handle work (e.g., dependencies connected, caches warmed).</td>\n<td>More comprehensive than a liveness probe. The <code>ReadinessHandler</code> might check that the collector can connect to storage and that the buffer manager is not overloaded. Kubernetes uses this to control when to send traffic to a pod.</td>\n</tr>\n<tr>\n<td><strong>Real User Monitoring (RUM)</strong></td>\n<td>Instrumenting client-side web applications to capture browser performance metrics, user interactions, and frontend errors experienced by real users.</td>\n<td>A <strong>Non-Goal</strong>—our system focuses on server-side tracing. However, the data model includes <code>RUMSpan</code> as a potential extension, showing how client-side spans could integrate with server-side traces for full-stack visibility.</td>\n</tr>\n<tr>\n<td><strong>Ring Buffer</strong></td>\n<td>A circular buffer data structure that uses a single, fixed-size buffer as if it were connected end-to-end, providing efficient FIFO semantics for streaming data.</td>\n<td>Used in the <code>MemoryStore</code> for metric aggregation in <strong>Milestone 4</strong>. Ring buffers naturally evict old data as new data arrives, making them ideal for sliding window calculations without explicit cleanup logic.</td>\n</tr>\n<tr>\n<td><strong>Seasonal Decomposition</strong></td>\n<td>A time series analysis method that separates data into trend, seasonal (periodic), and residual components, useful for detecting anomalies in data with regular patterns (like daily or weekly cycles).</td>\n<td>An advanced technique for <strong>baseline calculation</strong> in <strong>Milestone 4</strong>. By accounting for regular patterns (e.g., lower traffic on weekends), seasonal decomposition reduces false positives in anomaly detection.</td>\n</tr>\n<tr>\n<td><strong>Service</strong></td>\n<td>A logical component in a distributed system that emits spans. In our data model, a <code>Service</code> has a name and a list of operations (endpoints) it performs.</td>\n<td>A fundamental entity in service maps and sampling configuration. Services are extracted from spans&#39; <code>ServiceName</code> field, and sampling rates can be configured per service via <code>SamplingConfig.PerService</code>.</td>\n</tr>\n<tr>\n<td><strong>Service Map</strong></td>\n<td>A visual representation of service dependencies in a distributed system, typically shown as a directed graph where nodes are services and edges represent calls between them, annotated with metrics.</td>\n<td>The primary deliverable of <strong>Milestone 2</strong>. The <code>ServiceGraph</code> is constructed from trace data and provides an at-a-glance view of system topology and health, helping engineers understand communication patterns and identify bottlenecks.</td>\n</tr>\n<tr>\n<td><strong>Span</strong></td>\n<td>A named, timed operation representing a unit of work within a trace. Spans have a parent-child relationship structure and contain timing data, attributes, and status. Defined as the <code>Span</code> struct with fields like <code>SpanID</code>, <code>TraceID</code>, <code>ParentSpanID</code>, <code>Name</code>, <code>ServiceName</code>, <code>StartTime</code>, <code>Duration</code>, etc.</td>\n<td>The atomic unit of tracing data. Everything in the APM system revolves around spans—they are ingested, buffered, sampled, stored, and analyzed. A trace is composed of one or more spans.</td>\n</tr>\n<tr>\n<td><strong>SpanExporter</strong></td>\n<td>A component in the SDK that sends completed spans to the collector, typically batching them for efficiency.</td>\n<td>Part of the SDK architecture in <strong>Milestone 5</strong>. The exporter handles the network communication, retry logic, and backoff, allowing the instrumentation code to be non-blocking.</td>\n</tr>\n<tr>\n<td><strong>Synthetic Monitoring</strong></td>\n<td>Proactive simulation of user traffic (e.g., via scripted browser sessions or API calls) to measure availability and performance from predefined locations.</td>\n<td>A <strong>Non-Goal</strong> but mentioned as complementary to tracing. Synthetic traces could be generated by monitoring scripts and would flow through the same collection pipeline, providing baseline performance measurements.</td>\n</tr>\n<tr>\n<td><strong>t-digest</strong></td>\n<td>A probabilistic data structure for computing approximate percentiles from streaming data with high accuracy, especially in the tails of the distribution, using limited memory.</td>\n<td>The algorithm used in <code>TDigestMetric</code> for <strong>percentile calculation</strong> in <strong>Milestone 4</strong>. t-digest allows us to maintain rolling percentiles across millions of spans without storing every individual latency value.</td>\n</tr>\n<tr>\n<td><strong>Tail-Based Sampling</strong></td>\n<td>A sampling strategy where the decision to keep or drop a trace is made after the trace is complete (or nearly complete), allowing evaluation based on the full trace content (errors, latency, patterns).</td>\n<td>Implemented by the <code>TailSampler</code> in <strong>Milestone 3</strong>. This approach can override head-based sampling decisions to retain &quot;interesting&quot; traces (e.g., those with errors or high latency) even if they were initially sampled out, but requires buffering traces until completion.</td>\n</tr>\n<tr>\n<td><strong>TextMapCarrier</strong></td>\n<td>An interface for reading and writing trace context to arbitrary carrier formats (HTTP headers, gRPC metadata, message queue properties) during context propagation.</td>\n<td>Used by the SDK&#39;s <code>InjectTraceContext</code> and <code>ExtractTraceContext</code> methods in <strong>Milestone 5</strong>. The carrier abstraction allows the same propagation logic to work across different transport protocols.</td>\n</tr>\n<tr>\n<td><strong>Time Series Database (TSDB)</strong></td>\n<td>A database optimized for storing and retrieving time-stamped data, typically supporting efficient range queries and aggregations over time intervals.</td>\n<td>Considered for storing aggregated metrics in <strong>Milestone 4</strong>. While our design uses an in-memory <code>MemoryStore</code> for simplicity, a production system might offload historical metrics to a dedicated TSDB like Prometheus or InfluxDB for long-term retention.</td>\n</tr>\n<tr>\n<td><strong>Time Window</strong></td>\n<td>A fixed period (e.g., 1 minute, 5 minutes) over which metrics are aggregated or analyzed. Windows can be tumbling (non-overlapping) or sliding (overlapping).</td>\n<td>Used throughout the system: for edge aggregation in service maps (<code>EdgeAggregator.windowSize</code>), for percentile calculations (<code>PercentileAggregator.window</code>), and for anomaly detection baselines. Windows balance temporal granularity with statistical significance.</td>\n</tr>\n<tr>\n<td><strong>Topology Change</strong></td>\n<td>The addition, removal, or modification of service dependencies in the system, detected by comparing service graphs across time windows.</td>\n<td>A key insight from the service map. The <code>DetectTopologyChanges</code> function compares current and previous <code>ServiceGraph</code> instances to identify new services, removed dependencies, or changed communication patterns, which can indicate deployments or issues.</td>\n</tr>\n<tr>\n<td><strong>Trace</strong></td>\n<td>A collection of spans that represent a single request&#39;s path through a distributed system, sharing a common <code>TraceID</code>. Defined as the <code>Trace</code> struct with fields <code>TraceID</code>, <code>Spans</code>, <code>StartTime</code>, and <code>EndTime</code>.</td>\n<td>The unit of analysis for debugging. While spans are collected individually, they are assembled into traces for visualization and analysis. A trace shows the complete lifecycle of a request, including parallel and sequential operations across services.</td>\n</tr>\n<tr>\n<td><strong>Unified Observability</strong></td>\n<td>The practice of correlating traces, logs, and metrics for complete system understanding, allowing engineers to move seamlessly between signals during debugging.</td>\n<td>A <strong>Future Extension</strong> vision. The <code>TraceWithContext</code> struct shows how trace data could be enriched with related logs and metrics, while the <code>UnifiedStorage</code> interface suggests a backend that stores all telemetry types.</td>\n</tr>\n<tr>\n<td><strong>W3C Trace Context</strong></td>\n<td>A W3C standard specification for HTTP headers (<code>traceparent</code>, <code>tracestate</code>) that propagate trace context across service boundaries, ensuring interoperability between different tracing systems.</td>\n<td>The propagation standard adopted by OpenTelemetry and implemented in our SDK. The <code>TRACE_ID_HEADER</code> and <code>SPAN_ID_HEADER</code> constants correspond to these standard headers, enabling traces to cross service boundaries even when services use different tracing implementations.</td>\n</tr>\n<tr>\n<td><strong>Watermark Algorithm</strong></td>\n<td>An algorithm that marks a point in a data stream after which no earlier data is expected, used for handling out-of-order data in streaming systems.</td>\n<td>Relevant for <strong>trace assembly</strong> in <strong>Milestone 1</strong>. Since spans arrive out-of-order, we need a heuristic to decide when we&#39;ve received all spans for a trace (or enough to make a decision). A watermark based on span timestamps plus a max delay tolerance helps determine when to flush incomplete traces.</td>\n</tr>\n<tr>\n<td><strong>Wire Format</strong></td>\n<td>The serialized representation of data (e.g., spans) for transmission over a network. Our system supports both OTLP/JSON and OTLP/Protobuf wire formats.</td>\n<td>Defined by the OpenTelemetry specification. The <code>OTLPJSONRequest</code> and related types model the JSON structure, while <code>parseOTLPProtobuf</code> handles the binary protobuf format. Choosing a standard wire format ensures interoperability.</td>\n</tr>\n<tr>\n<td><strong>Write-Ahead Log (WAL)</strong></td>\n<td>A durability mechanism where changes (incoming spans) are written to a sequential log file before being processed and acknowledged, allowing recovery after crashes.</td>\n<td>Implemented by <code>WALWriter</code> and <code>WALReader</code> in <strong>Milestone 1</strong> as part of the buffering strategy. If the collector crashes before spans are processed, they can be replayed from the WAL, preventing data loss at the cost of increased I/O.</td>\n</tr>\n<tr>\n<td><strong>z-score</strong></td>\n<td>A statistical measurement describing a value&#39;s relationship to the mean of a group of values, expressed in terms of standard deviations. Used to detect anomalies.</td>\n<td>One method in the <code>Detector</code> for <strong>anomaly detection</strong> in <strong>Milestone 4</strong>. A latency value with a high absolute z-score (e.g., &gt;3) is far from the historical mean and likely an anomaly, assuming the data is normally distributed.</td>\n</tr>\n</tbody></table>\n<p>This glossary provides a shared vocabulary for discussing the APM Tracing System. When reviewing the design document, refer back to these definitions to ensure precise understanding of each concept&#39;s role and implementation.</p>\n<hr>\n","toc":[{"level":1,"text":"APM Tracing System: Design Document","id":"apm-tracing-system-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"1. Context and Problem Statement","id":"1-context-and-problem-statement"},{"level":3,"text":"Mental Model: The Distributed Detective","id":"mental-model-the-distributed-detective"},{"level":3,"text":"The Observability Challenge in Microservices","id":"the-observability-challenge-in-microservices"},{"level":3,"text":"Existing Approaches and Trade-offs","id":"existing-approaches-and-trade-offs"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"2. Goals and Non-Goals","id":"2-goals-and-non-goals"},{"level":3,"text":"Goals (What We Must Do)","id":"goals-what-we-must-do"},{"level":3,"text":"Non-Goals (What We Explicitly Won&#39;t Do)","id":"non-goals-what-we-explicitly-won39t-do"},{"level":3,"text":"Scope Boundary Visualization","id":"scope-boundary-visualization"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"3. High-Level Architecture","id":"3-high-level-architecture"},{"level":3,"text":"Component Overview and Responsibilities","id":"component-overview-and-responsibilities"},{"level":4,"text":"Detailed Component Breakdown","id":"detailed-component-breakdown"},{"level":4,"text":"Component Interaction Patterns","id":"component-interaction-patterns"},{"level":3,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Key Structural Decisions","id":"key-structural-decisions"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure Starter","id":"b-recommended-filemodule-structure-starter"},{"level":4,"text":"C. Language-Specific Hints for Go","id":"c-language-specific-hints-for-go"},{"level":4,"text":"D. Milestone Checkpoint: Architecture Setup","id":"d-milestone-checkpoint-architecture-setup"},{"level":2,"text":"4. Data Model","id":"4-data-model"},{"level":3,"text":"Core Types: Span, Trace, and Service","id":"core-types-span-trace-and-service"},{"level":4,"text":"The Span: An Individual Operation","id":"the-span-an-individual-operation"},{"level":4,"text":"SpanEvent: Annotated Moments in Time","id":"spanevent-annotated-moments-in-time"},{"level":4,"text":"SpanStatus: Operation Outcome","id":"spanstatus-operation-outcome"},{"level":4,"text":"The Trace: A Complete Request Journey","id":"the-trace-a-complete-request-journey"},{"level":4,"text":"The Service: A Logical Component","id":"the-service-a-logical-component"},{"level":3,"text":"Relationships and Storage Indexing Strategy","id":"relationships-and-storage-indexing-strategy"},{"level":4,"text":"Span-to-Trace Relationships: Building the Tree","id":"span-to-trace-relationships-building-the-tree"},{"level":4,"text":"Storage Strategy: Balancing Write Speed and Query Flexibility","id":"storage-strategy-balancing-write-speed-and-query-flexibility"},{"level":4,"text":"Indexing Strategy: The Multi-Catalog System","id":"indexing-strategy-the-multi-catalog-system"},{"level":4,"text":"Data Retention and Partitioning","id":"data-retention-and-partitioning"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"5. Component Design: Trace Collection (Milestone 1)","id":"5-component-design-trace-collection-milestone-1"},{"level":3,"text":"Mental Model: The Package Sorting Hub","id":"mental-model-the-package-sorting-hub"},{"level":3,"text":"Collector Interface and API","id":"collector-interface-and-api"},{"level":4,"text":"HTTP Endpoint Specification","id":"http-endpoint-specification"},{"level":4,"text":"gRPC Service Specification","id":"grpc-service-specification"},{"level":4,"text":"Request/Response Format Details","id":"requestresponse-format-details"},{"level":4,"text":"Expected Behavior and SLAs","id":"expected-behavior-and-slas"},{"level":3,"text":"Internal Behavior: Ingestion Pipeline","id":"internal-behavior-ingestion-pipeline"},{"level":4,"text":"Pipeline Stages (Step-by-Step Algorithm)","id":"pipeline-stages-step-by-step-algorithm"},{"level":4,"text":"Trace Completion Detection","id":"trace-completion-detection"},{"level":3,"text":"ADR: Buffering Strategy for Late-Arriving Spans","id":"adr-buffering-strategy-for-late-arriving-spans"},{"level":4,"text":"WAL Implementation Details","id":"wal-implementation-details"},{"level":3,"text":"Common Pitfalls in Trace Collection","id":"common-pitfalls-in-trace-collection"},{"level":4,"text":"⚠️ Pitfall 1: Unbounded Memory Growth from Incomplete Traces","id":"-pitfall-1-unbounded-memory-growth-from-incomplete-traces"},{"level":4,"text":"⚠️ Pitfall 2: Clock Skew Creates Incorrect Span Ordering","id":"-pitfall-2-clock-skew-creates-incorrect-span-ordering"},{"level":4,"text":"⚠️ Pitfall 3: Incorrect Parent-Child Linking","id":"-pitfall-3-incorrect-parent-child-linking"},{"level":4,"text":"⚠️ Pitfall 4: Head-of-Line Blocking in Pipeline","id":"-pitfall-4-head-of-line-blocking-in-pipeline"},{"level":4,"text":"⚠️ Pitfall 5: Lost Spans from Trace Sampling Inconsistency","id":"-pitfall-5-lost-spans-from-trace-sampling-inconsistency"},{"level":3,"text":"Implementation Guidance for Trace Collection","id":"implementation-guidance-for-trace-collection"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"6. Component Design: Service Map (Milestone 2)","id":"6-component-design-service-map-milestone-2"},{"level":3,"text":"Mental Model: The Social Network of Services","id":"mental-model-the-social-network-of-services"},{"level":3,"text":"Algorithm: Building the Graph from Spans","id":"algorithm-building-the-graph-from-spans"},{"level":4,"text":"Phase 1: Edge Extraction from Individual Spans","id":"phase-1-edge-extraction-from-individual-spans"},{"level":4,"text":"Phase 2: Metric Aggregation over Time Windows","id":"phase-2-metric-aggregation-over-time-windows"},{"level":4,"text":"Phase 3: Graph Construction and Topology Detection","id":"phase-3-graph-construction-and-topology-detection"},{"level":3,"text":"ADR: Graph Storage - Materialized vs. On-Demand","id":"adr-graph-storage-materialized-vs-on-demand"},{"level":3,"text":"Common Pitfalls in Service Map Construction","id":"common-pitfalls-in-service-map-construction"},{"level":3,"text":"Implementation Guidance for Service Map","id":"implementation-guidance-for-service-map"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"7. Component Design: Trace Sampling (Milestone 3)","id":"7-component-design-trace-sampling-milestone-3"},{"level":3,"text":"Mental Model: The Library Archivist","id":"mental-model-the-library-archivist"},{"level":3,"text":"Head-Based vs. Tail-Based Sampling","id":"head-based-vs-tail-based-sampling"},{"level":4,"text":"Head-Based Sampling: The First Impression","id":"head-based-sampling-the-first-impression"},{"level":4,"text":"Tail-Based Sampling: The Retrospective Review","id":"tail-based-sampling-the-retrospective-review"},{"level":4,"text":"Comparison Table: When to Use Each Strategy","id":"comparison-table-when-to-use-each-strategy"},{"level":3,"text":"ADR: Adaptive Sampling Algorithm","id":"adr-adaptive-sampling-algorithm"},{"level":4,"text":"Options Comparison Table","id":"options-comparison-table"},{"level":4,"text":"Adaptive Sampling Algorithm Design","id":"adaptive-sampling-algorithm-design"},{"level":4,"text":"State Machine: Sampling Decision Process","id":"state-machine-sampling-decision-process"},{"level":4,"text":"Adaptive Rate Calculation Algorithm","id":"adaptive-rate-calculation-algorithm"},{"level":3,"text":"Common Pitfalls in Sampling","id":"common-pitfalls-in-sampling"},{"level":4,"text":"⚠️ Pitfall 1: Sampling Bias Leading to Misleading Statistics","id":"-pitfall-1-sampling-bias-leading-to-misleading-statistics"},{"level":4,"text":"⚠️ Pitfall 2: Inconsistent Decisions for the Same Trace","id":"-pitfall-2-inconsistent-decisions-for-the-same-trace"},{"level":4,"text":"⚠️ Pitfall 3: Adaptive Algorithm Oscillation","id":"-pitfall-3-adaptive-algorithm-oscillation"},{"level":4,"text":"⚠️ Pitfall 4: Head-Based Sampling Losing All Error Traces","id":"-pitfall-4-head-based-sampling-losing-all-error-traces"},{"level":4,"text":"⚠️ Pitfall 5: Clock Skew Causing Premature Trace Completion","id":"-pitfall-5-clock-skew-causing-premature-trace-completion"},{"level":3,"text":"Implementation Guidance for Trace Sampling","id":"implementation-guidance-for-trace-sampling"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code: Consistent Hash Sampler","id":"c-infrastructure-starter-code-consistent-hash-sampler"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"8. Component Design: Performance Analytics &amp; Anomaly Detection (Milestone 4)","id":"8-component-design-performance-analytics-amp-anomaly-detection-milestone-4"},{"level":3,"text":"Mental Model: The Weather Forecaster for Performance","id":"mental-model-the-weather-forecaster-for-performance"},{"level":3,"text":"Algorithms: Percentile Calculation and Anomaly Detection","id":"algorithms-percentile-calculation-and-anomaly-detection"},{"level":4,"text":"Percentile Calculation with T-Digest","id":"percentile-calculation-with-t-digest"},{"level":4,"text":"Anomaly Detection with Statistical Methods","id":"anomaly-detection-with-statistical-methods"},{"level":3,"text":"ADR: Time-Series Storage for Aggregates","id":"adr-time-series-storage-for-aggregates"},{"level":3,"text":"Common Pitfalls in Analytics","id":"common-pitfalls-in-analytics"},{"level":3,"text":"Implementation Guidance for Analytics","id":"implementation-guidance-for-analytics"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"9. Component Design: APM SDK &amp; Auto-Instrumentation (Milestone 5)","id":"9-component-design-apm-sdk-amp-auto-instrumentation-milestone-5"},{"level":3,"text":"Mental Model: The Invisible Flight Recorder","id":"mental-model-the-invisible-flight-recorder"},{"level":3,"text":"Instrumentation Techniques: Monkey Patching and Middleware","id":"instrumentation-techniques-monkey-patching-and-middleware"},{"level":3,"text":"ADR: Context Propagation Mechanism","id":"adr-context-propagation-mechanism"},{"level":3,"text":"Common Pitfalls in SDK Development","id":"common-pitfalls-in-sdk-development"},{"level":3,"text":"Implementation Guidance for the APM SDK","id":"implementation-guidance-for-the-apm-sdk"},{"level":2,"text":"10. Interactions and Data Flow","id":"10-interactions-and-data-flow"},{"level":3,"text":"Sequence: The Lifecycle of a Trace","id":"sequence-the-lifecycle-of-a-trace"},{"level":3,"text":"Key Message and Wire Formats","id":"key-message-and-wire-formats"},{"level":4,"text":"OpenTelemetry Protocol (OTLP) Span Format","id":"opentelemetry-protocol-otlp-span-format"},{"level":4,"text":"Internal Span Representation","id":"internal-span-representation"},{"level":4,"text":"Collector Internal Messages","id":"collector-internal-messages"},{"level":4,"text":"Query Service APIs","id":"query-service-apis"},{"level":4,"text":"W3C Trace Context Propagation","id":"w3c-trace-context-propagation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. OTLP HTTP Handler Implementation","id":"c-otlp-http-handler-implementation"},{"level":4,"text":"D. Span Processing Pipeline Skeleton","id":"d-span-processing-pipeline-skeleton"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"11. Error Handling and Edge Cases","id":"11-error-handling-and-edge-cases"},{"level":3,"text":"Mental Model: The Fault-Tolerant Hospital","id":"mental-model-the-fault-tolerant-hospital"},{"level":3,"text":"Failure Modes and Recovery Strategies","id":"failure-modes-and-recovery-strategies"},{"level":4,"text":"ADR: Storage Failure Recovery Strategy","id":"adr-storage-failure-recovery-strategy"},{"level":3,"text":"Backpressure and Degraded Modes","id":"backpressure-and-degraded-modes"},{"level":4,"text":"Mental Model: The Pressure Release Valve","id":"mental-model-the-pressure-release-valve"},{"level":4,"text":"Cascading Backpressure Strategy","id":"cascading-backpressure-strategy"},{"level":4,"text":"Degraded Modes Operation","id":"degraded-modes-operation"},{"level":4,"text":"ADR: Backpressure Implementation Pattern","id":"adr-backpressure-implementation-pattern"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"12. Testing Strategy","id":"12-testing-strategy"},{"level":3,"text":"Testing Approaches: Unit, Integration, and Load","id":"testing-approaches-unit-integration-and-load"},{"level":4,"text":"Unit Testing: Verifying Component Invariants","id":"unit-testing-verifying-component-invariants"},{"level":4,"text":"Integration Testing: Verifying Component Interaction","id":"integration-testing-verifying-component-interaction"},{"level":4,"text":"Load and Performance Testing: Verifying Scalability","id":"load-and-performance-testing-verifying-scalability"},{"level":3,"text":"Milestone Checkpoints and Verification","id":"milestone-checkpoints-and-verification"},{"level":4,"text":"Milestone 1: Trace Collection","id":"milestone-1-trace-collection"},{"level":4,"text":"Milestone 2: Service Map","id":"milestone-2-service-map"},{"level":4,"text":"Milestone 3: Trace Sampling","id":"milestone-3-trace-sampling"},{"level":4,"text":"Milestone 4: Performance Analytics &amp; Anomaly Detection","id":"milestone-4-performance-analytics-amp-anomaly-detection"},{"level":4,"text":"Milestone 5: APM SDK &amp; Auto-Instrumentation","id":"milestone-5-apm-sdk-amp-auto-instrumentation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"13. Debugging Guide","id":"13-debugging-guide"},{"level":3,"text":"Common Bugs: Symptom → Cause → Fix","id":"common-bugs-symptom-cause-fix"},{"level":3,"text":"Debugging Techniques and Tools","id":"debugging-techniques-and-tools"},{"level":4,"text":"Strategic Logging","id":"strategic-logging"},{"level":4,"text":"Performance Profiling with pprof","id":"performance-profiling-with-pprof"},{"level":4,"text":"Simulating Production Traffic for Testing","id":"simulating-production-traffic-for-testing"},{"level":4,"text":"Using the System to Debug Itself (Dogfooding)","id":"using-the-system-to-debug-itself-dogfooding"},{"level":4,"text":"Diagnostic Endpoints and Health Checks","id":"diagnostic-endpoints-and-health-checks"},{"level":4,"text":"Systematic Diagnosis Workflow","id":"systematic-diagnosis-workflow"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Diagnostic Endpoint Implementation","id":"b-diagnostic-endpoint-implementation"},{"level":4,"text":"C. Strategic Logging Skeleton","id":"c-strategic-logging-skeleton"},{"level":4,"text":"D. Load Test Generator Skeleton","id":"d-load-test-generator-skeleton"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Debugging Workflow Checkpoint","id":"f-debugging-workflow-checkpoint"},{"level":4,"text":"G. Debugging Tips Quick Reference","id":"g-debugging-tips-quick-reference"},{"level":2,"text":"14. Future Extensions","id":"14-future-extensions"},{"level":3,"text":"Potential Enhancements","id":"potential-enhancements"},{"level":4,"text":"14.1 Continuous Profiling Integration","id":"141-continuous-profiling-integration"},{"level":4,"text":"14.2 AI-Powered Root Cause Analysis","id":"142-ai-powered-root-cause-analysis"},{"level":4,"text":"14.3 eBPF-Based Instrumentation","id":"143-ebpf-based-instrumentation"},{"level":4,"text":"14.4 Real User Monitoring (RUM) Integration","id":"144-real-user-monitoring-rum-integration"},{"level":4,"text":"14.5 Business Transaction Tracing","id":"145-business-transaction-tracing"},{"level":4,"text":"14.6 Trace Data Enrichment with Logs and Metrics","id":"146-trace-data-enrichment-with-logs-and-metrics"},{"level":4,"text":"14.7 Multi-Tenancy and Data Isolation","id":"147-multi-tenancy-and-data-isolation"},{"level":4,"text":"14.8 Advanced Visualization: Flame Graphs and Heat Maps","id":"148-advanced-visualization-flame-graphs-and-heat-maps"},{"level":4,"text":"14.9 Predictive Capacity Planning","id":"149-predictive-capacity-planning"},{"level":4,"text":"14.10 Enhancement Prioritization Framework","id":"1410-enhancement-prioritization-framework"},{"level":3,"text":"Implementation Guidance for Future Extensions","id":"implementation-guidance-for-future-extensions"},{"level":2,"text":"15. Glossary","id":"15-glossary"},{"level":3,"text":"Terminology Reference","id":"terminology-reference"}],"title":"APM Tracing System: Design Document","markdown":"# APM Tracing System: Design Document\n\n\n## Overview\n\nWe are building an Application Performance Monitoring (APM) system that tracks requests as they flow through a distributed application, creating detailed traces. The key architectural challenge is efficiently collecting, storing, and analyzing massive volumes of trace data while preserving the most valuable insights for debugging and performance optimization.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## 1. Context and Problem Statement\n\n> **Milestone(s):** This section provides the foundational context for all subsequent milestones, explaining the core problems that the entire APM Tracing System is designed to solve.\n\nImagine you're tasked with investigating a performance problem in a modern application. A user reports that a specific action—say, \"checkout\" in an e-commerce app—is taking 15 seconds to complete, far longer than the expected 2 seconds. The application isn't a single monolithic program but a constellation of dozens, sometimes hundreds, of microservices. The request from the user's browser might touch a frontend API gateway, which calls a user service for authentication, which then calls a product catalog service, which queries a database, then calls an inventory service, which publishes an event to a message queue, which is consumed by a shipping service, and so on. Each of these steps could be running on different machines, in different data centers, managed by different teams.\n\nWithout a specialized observability tool, diagnosing this slowdown is like trying to solve a murder mystery where each witness (service) only saw a tiny fragment of the event and speaks a different language. You might find a log in the API gateway showing it took 14 seconds to get a response from the user service. But why? Is the user service slow, or is it waiting on something else? Is the database overloaded? Is there a network partition? Traditional logging and metrics give you isolated data points, but they don't show you the complete journey of the request as it traverses this complex distributed system. This is the fundamental problem that distributed tracing, and by extension an Application Performance Monitoring (APM) system, exists to solve.\n\n### Mental Model: The Distributed Detective\n\nThink of a **distributed trace** as the complete **case file** for a single request's journey through your system. Every time a request enters your application, a new case is opened. As the request moves from service to service, each service creates a **span**—a structured log entry that represents a single unit of work (like a database query or an HTTP call) within that service's handling of the request. A span contains crucial evidence: what operation was performed, when it started and ended, what service executed it, and whether it succeeded or failed.\n\nMost importantly, spans are linked. Each span knows the ID of the overarching **trace** (the case file) and the ID of its **parent span** (the previous step in the journey). This creates a hierarchical timeline—a **trace tree**—that reconstructs the exact path and timing of the request.\n\nNow, picture the APM system as the **distributed detective**. Its job is to:\n1.  **Collect** all the span evidence from every service (the witnesses).\n2.  **Assemble** the spans into their correct trace trees, linking parent to child across service boundaries.\n3.  **Analyze** the assembled traces to answer critical questions: Where was the time spent? Which service was the bottleneck? Did an error in one service cascade to others?\n4.  **Visualize** the results, showing the detective (the engineer) not just a single request's timeline, but also the bigger picture: a map of how all services interact, statistical summaries of performance, and alerts when things deviate from the norm.\n\nThis mental model shifts debugging from sifting through disjointed logs to reading a coherent, end-to-end story of a request's life. It turns the opaque distributed system into a transparent, understandable entity.\n\n### The Observability Challenge in Microservices\n\nMicroservices architecture delivers benefits in scalability, developer autonomy, and deployment velocity, but it fundamentally changes the nature of debugging and performance analysis. The core challenges can be distilled into three concrete problems:\n\n1.  **The End-to-End Latency Puzzle:** When a user-facing operation is slow, the root cause can be anywhere. A latency metric on your API gateway tells you the *symptom* (total time = 15s), but not the *cause*. Without tracing, you must manually hop from service to service, checking their individual metrics and logs, trying to correlate timestamps—a process that is slow, error-prone, and often impossible when calls are asynchronous or batched.\n\n2.  **The Cascading Failure Mystery:** A failure in one service can propagate in non-obvious ways. For example, if a payment service times out, the order service might retry three times, queueing requests and consuming threads, which then causes the order service itself to become slow and start timing out requests to the inventory service. Looking at the inventory service's logs, you might see a surge in timeouts and conclude it's the problem, missing the true root cause two hops upstream. Understanding these failure propagation paths requires seeing the call graph.\n\n3.  **The Dependency Map Blind Spot:** As systems grow organically, implicit dependencies emerge. Service A might start calling Service C indirectly through Service B. Old dependencies might linger long after they're no longer used. Without a dynamic, data-driven view of service communications, system architecture diagrams quickly become outdated. This makes impact analysis for deployments, capacity planning, and failure domain isolation guesswork.\n\nThe following table summarizes the shift in observability requirements from monolithic to microservices architectures:\n\n| Observability Aspect | Monolithic Application | Microservices Architecture | New Challenge |\n| :--- | :--- | :--- | :--- |\n| **Latency Attribution** | Profiling within a single process pinpoints slow functions. | Latency is distributed across network calls and process boundaries. | Need to attribute time to specific remote calls and understand serial vs. parallel execution. |\n| **Error Propagation** | Stack trace localizes error to a module/function. | Error in one service may manifest as a timeout or degraded behavior in another. | Need to reconstruct the call chain to find the origin of a fault. |\n| **System Topology** | Static, defined by code structure. | Dynamic, defined by runtime service discovery and communication. | Need to discover and visualize the runtime dependency graph. |\n| **Debugging Data** | Centralized logs and metrics from one application. | Data is siloed across many independent services and teams. | Need to correlate events across service boundaries with a common request identifier. |\n\nThese challenges are not merely incremental; they represent a qualitative change in complexity. Traditional monitoring tools, designed for monoliths or simple client-server models, are ill-equipped to provide the necessary cross-boundary visibility.\n\n### Existing Approaches and Trade-offs\n\nBefore committing to building a dedicated tracing system, it's essential to understand what existing observability tools can and cannot do. Most teams already use some combination of **logs**, **metrics**, and **health checks**. Each plays a role, but each has significant gaps when it comes to understanding distributed request flow.\n\n> **Decision: Build a Dedicated Distributed Tracing System**\n> - **Context**: We need to understand request flow across microservices for debugging and performance optimization. Existing logging and metrics systems are insufficient for this task.\n> - **Options Considered**:\n>     1. **Enhanced Logging**: Inject a common `trace_id` into every log line across all services and use a log aggregator (e.g., ELK Stack) to correlate them.\n>     2. **Enhanced Metrics**: Instrument each service to emit fine-grained timing histograms for all outgoing calls and try to infer relationships from dashboards.\n>     3. **Dedicated Distributed Tracing**: Implement the OpenTelemetry tracing standard, collect spans, and build a system specifically for assembling and analyzing traces.\n> - **Decision**: Option 3 — Build a dedicated distributed tracing system.\n> - **Rationale**: While logging with `trace_id` provides some correlation, it lacks the structured hierarchy and timing relationships inherent to spans. Logs are also unstructured and expensive to query for complex path analysis. Metrics can show aggregates but lose individual request context, making it impossible to debug specific user issues. A dedicated tracing system is built around the first-class concepts of traces and spans, enabling efficient storage, precise reconstruction of call graphs, and specialized analytics (like service maps and tail-based sampling) that are impractical with generic tools.\n> - **Consequences**: We must build and operate a new subsystem, but we gain unparalleled visibility into request flow, enabling faster debugging, performance optimization, and system understanding. The system will complement, not replace, existing logs and metrics.\n\nThe table below details the trade-offs between these three pillars of observability, highlighting why tracing is a necessary addition:\n\n| Approach | How It Works | Strengths | Weaknesses for Distributed Debugging | Role in Our APM System |\n| :--- | :--- | :--- | :--- | :--- |\n| **Logging** | Applications emit timestamped text lines describing events. Central aggregator indexes and enables search. | **High detail**: Can capture any arbitrary event or state. **Flexible**: No predefined schema. **Ubiquitous**: Every application does it. | **No structure**: Hard to extract consistent fields (e.g., duration, parent ID). **Expensive correlation**: Finding all logs for one request requires scanning millions of lines. **No hierarchy**: Can't easily visualize parent-child relationships or parallel operations. | Logs remain crucial for deep, unstructured debugging *within* a service. The APM system will **correlate** trace IDs with log entries, allowing engineers to jump from a slow span to the relevant service logs. |\n| **Metrics** | Services emit numerical measurements (counters, gauges, histograms) at regular intervals. Time-series database stores and dashboards visualize. | **Aggregation**: Excellent for trends, alerts, and SLOs. **Low overhead**: Sampled and pre-aggregated. **High cardinality**: Modern systems can handle many dimensions. | **Loss of context**: You see *that* the 95th percentile latency for Service A spiked, but not *which specific requests* caused it or *why*. **No causal links**: Cannot show that a latency spike in Service B caused an error rate increase in Service A. | Metrics provide the **health dashboard** and **alerting** backbone. The APM system will **generate metrics** from trace data (e.g., request rate, error rate, latency percentiles per service/operation) and may trigger alerts based on trace-derived anomalies. |\n| **Distributed Tracing** | Services emit structured **spans** for units of work, linked by trace and parent IDs. Collector assembles spans into trace trees. | **Request-centric view**: See the complete story of a single user request. **Causal links**: Clear parent-child relationships across services. **Timing context**: Understand serialization, parallelization, and waiting time. | **High volume**: Can generate massive amounts of data. Requires **sampling**. **Instrumentation cost**: Requires code changes or auto-instrumentation. **Complex backend**: Needs specialized storage and query. | This is the **core** of our APM system. It provides the connective tissue between logs and metrics, answering the \"why\" and \"how\" behind the \"what\" shown by metrics and logs. |\n\nThe synergy between these three signals is often described as the **Observability Golden Triangle**. An engineer might:\n1.  See a **metric** alert for high p95 latency on the checkout endpoint.\n2.  Use the **tracing** system to sample recent slow traces for that endpoint, instantly visualizing that the delay is in the payment service, specifically in a call to a third-party card processor.\n3.  Click from the slow payment span in the trace view to search **logs** from the payment service filtered by that specific `trace_id`, revealing an error message from the third-party API about an expired certificate.\n\nThis integrated workflow reduces mean time to resolution (MTTR) from hours or days to minutes. Our APM Tracing System aims to be the central platform that makes this workflow not just possible, but efficient and scalable.\n\n---\n### Implementation Guidance\n\nAs this is the foundational context section, there is no direct implementation to be done. However, the concepts introduced here directly inform the architecture and design decisions in all subsequent sections. The following table maps the high-level observability concepts to the concrete components you will build in the upcoming milestones.\n\n| Conceptual Need | APM System Component (Milestone) | What You'll Build |\n| :--- | :--- | :--- |\n| **Collect evidence (spans) from all services** | Trace Collector (Milestone 1) | HTTP/gRPC servers to receive spans, buffering logic, storage layer. |\n| **Assemble spans into trace trees** | Trace Collector & Storage (Milestone 1) | Indexing by `trace_id`, logic to handle out-of-order span arrival. |\n| **Understand service relationships** | Service Map (Milestone 2) | Graph construction algorithms that analyze spans to build a dependency map. |\n| **Manage data volume** | Trace Sampling (Milestone 3) | Head-based and tail-based sampling algorithms to filter traces intelligently. |\n| **Analyze performance trends** | Performance Analytics (Milestone 4) | Percentile calculators (t-digest) and anomaly detectors for time-series data. |\n| **Generate spans automatically** | APM SDK (Milestone 5) | Auto-instrumentation libraries for HTTP, databases, and frameworks. |\n\nBefore starting implementation, ensure you are comfortable with the core data model that will be used throughout the system, which is defined in the **Data Model** section (Section 4). The key entities are:\n*   **Trace**: The entire record of a request's journey, comprised of all its spans.\n*   **Span**: A named, timed operation representing a unit of work within a trace.\n*   **Service**: A logical component of the application (e.g., `checkout-service`, `user-db`).\n\nProceed to the **High-Level Architecture** section (Section 3) to see how these components fit together into a cohesive system.\n\n---\n\n\n> **Milestone(s):** This section provides the foundational scope definition that applies to ALL subsequent milestones, setting clear boundaries for what the APM Tracing System will and will not address.\n\n## 2. Goals and Non-Goals\n\nEstablishing clear boundaries is critical for the success of any complex system. Without explicit goals, scope creep becomes inevitable, leading to an unfocused product that attempts to solve every observability problem but masters none. Conversely, without declared non-goals, stakeholders may assume capabilities the system was never designed to provide, resulting in disappointment and misuse.\n\nThis section explicitly defines **what the APM Tracing System must deliver** and, equally important, **what it explicitly will not attempt**. These boundaries serve as guardrails for architectural decisions and prioritization throughout the project.\n\n### Goals (What We Must Do)\n\nThe primary goal of this system is to provide **end-to-end visibility into request flow across a distributed application**, enabling developers to debug performance issues, understand service dependencies, and identify anomalies. The system must achieve this while operating efficiently at scale, balancing data volume with insight quality.\n\nThe following table enumerates the mandatory functional requirements, each mapped to its corresponding project milestone:\n\n| Goal ID | Functional Requirement | Description | Corresponding Milestone |\n| :--- | :--- | :--- | :--- |\n| **G1** | **Collect and Store Distributed Traces** | Ingest spans in OpenTelemetry format via HTTP/gRPC, correctly assemble them into traces using parent-child relationships, and persistently store them with efficient indexing for retrieval by trace ID. The system must handle at least 1000 spans per second without data loss. | Milestone 1: Trace Collection |\n| **G2** | **Generate and Visualize a Dynamic Service Dependency Map** | Automatically derive a directed graph of service-to-service communication from trace data. Compute and display key metrics (request count, latency, error rate) for each edge. Update the map in near-real-time as new trace data arrives. | Milestone 2: Service Map |\n| **G3** | **Implement Intelligent, Adaptive Trace Sampling** | Reduce storage and processing costs by filtering traces while preserving diagnostically valuable data. Support both head-based (probabilistic at trace start) and tail-based (decision after trace completion based on errors/latency) sampling strategies. Allow per-service configuration. | Milestone 3: Trace Sampling |\n| **G4** | **Provide Performance Analytics and Anomaly Detection** | Calculate latency percentiles (p50, p95, p99) per service and operation. Establish historical baselines and detect deviations using statistical methods. Generate alerts for performance regressions. | Milestone 4: Performance Analytics & Anomaly Detection |\n| **G5** | **Offer Auto-Instrumentation via an APM SDK** | Provide client libraries that automatically instrument common frameworks (HTTP servers/clients, database drivers) to generate spans and propagate trace context without requiring manual code changes. Support W3C Trace Context standard. | Milestone 5: APM SDK & Auto-Instrumentation |\n| **G6** | **Ensure High Performance and Low Overhead** | The data collection path (from SDK through Collector to storage) must add minimal latency to instrumented applications. Ingestion acknowledgment should occur within 100ms. The SDK's instrumentation overhead must be negligible for production workloads. | Cross-cutting (All Milestones) |\n| **G7** | **Design for Horizontal Scalability and Resilience** | The core components (Collector, storage, query services) must be deployable as multiple instances to handle load increases. The system should gracefully degrade (e.g., via increased sampling) under extreme load rather than fail catastrophically. | Cross-cutting (All Milestones) |\n\n> **Key Design Insight:** The goals are intentionally ordered to reflect the **data pipeline's natural flow**. You must first collect data (G1) before you can analyze it to build a service map (G2). You need the raw data volume (G1) before you need to manage it via sampling (G3). The SDK (G5) is the source of all data, but its design is influenced by the needs of the entire pipeline.\n\nBeyond these functional goals, the system adheres to several key architectural principles:\n\n*   **Open Standards First:** Prioritize compatibility with the OpenTelemetry specification for data format and context propagation (`TRACE_ID_HEADER: traceparent`, `SPAN_ID_HEADER: tracestate`). This ensures interoperability with a broader ecosystem of tools.\n*   **Observability of the Observability System:** The system itself must be monitorable, providing its own metrics (e.g., ingestion rate, sampling decisions, storage health) and logs.\n*   **Operator-Friendly Configuration:** Sampling rates, storage backends, and aggregation intervals must be configurable without requiring code deploys, ideally via runtime configuration or feature flags.\n\n### Non-Goals (What We Explicitly Won't Do)\n\nA system's strength often lies in what it chooses *not* to do. The following are explicitly out of scope for this version of the APM Tracing System. This clarity prevents misallocation of engineering effort and sets correct expectations for users.\n\n| Non-Goal ID | Out-of-Scope Capability | Rationale & Guidance |\n| :--- | :--- | :--- |\n| **NG1** | **Real User Monitoring (RUM) / Browser Tracing** | We will not instrument client-side web applications to capture browser performance metrics, page load events, or user interaction timings. This domain requires handling of synthetic versus real user data, geolocation, and device fragmentation. **Consideration:** Traces will start at the first instrumented backend service. |\n| **NG2** | **Log Aggregation and Centralized Logging** | While `Span.Events` can capture log-like data, we will not build a general-purpose log ingestion, indexing, and search system (e.g., like ELK Stack or Loki). Traces are for structured performance data; logs are for unstructured diagnostic text. **Consideration:** Use a dedicated logging system and correlate logs to traces via `TraceID`. |\n| **NG3** | **Infrastructure and Host-Level Metrics** | We will not collect or alert on system metrics like CPU usage, memory consumption, disk I/O, or network throughput. This is the domain of traditional monitoring systems (e.g., Prometheus). **Consideration:** Our performance analytics (G4) focus on *application* metrics (latency, error rate) derived from traces. |\n| **NG4** | **Continuous Profiling (CPU, Heap, etc.)** | We will not periodically capture and analyze CPU flame graphs or heap allocations across services. Profiling provides a different, deeper level of insight into *why* code is slow, not just *where*. **Consideration:** This could be a valuable future extension (see Future Extensions) but is a separate complex system. |\n| **NG5** | **Synthetic Monitoring / Active Health Checks** | We will not proactively simulate user traffic from various global locations to measure availability and performance from an external perspective. **Consideration:** Our system observes real production traffic. Synthetic monitoring is a complementary practice. |\n| **NG6** | **Advanced AI/ML for Root Cause Analysis** | While we perform basic statistical anomaly detection (G4), we will not implement machine learning models that automatically pinpoint the root cause of an incident or predict future failures. **Consideration:** We provide the high-quality trace data upon which such advanced systems could be built. |\n| **NG7** | **Long-Term, Cold Storage Archival** | Our trace storage is optimized for online querying and analysis over a recent time window (e.g., 7-30 days). We will not build pipelines to compress and archive trace data to object storage (e.g., S3) for indefinite retention and historical forensics. **Consideration:** Implement a separate archival process if needed, using our storage's export capabilities. |\n| **NG8** | **Full-Text Search Across All Span Attributes** | While we index traces by `TraceID`, service, and time range, we will not support arbitrary, high-cardinality full-text search over every key-value pair in `Span.Attributes`. This would require a different indexing technology (e.g., Elasticsearch). **Consideration:** Queries should be scoped to known services, operations, or specific trace IDs. |\n\n> **Architectural Decision: Focusing on Core Tracing**\n>\n> **Context:** Observability platforms can encompass logging, metrics, tracing, profiling, and more. Our team has limited resources and must deliver a focused, high-quality product.\n>\n> **Options Considered:**\n> 1.  **Build a \"Full-Stack\" Observability Platform:** Incorporate RUM, logging, and infrastructure metrics alongside tracing.\n> 2.  **Build a Best-in-Class Distributed Tracing System:** Focus exclusively on the trace data pipeline and its immediate derivatives (service maps, performance analytics).\n> 3.  **Build a Trace-Centric Platform with Extension Points:** Focus on tracing but design explicit integration points for external logging and metrics systems.\n>\n> **Decision:** Choose Option 2, with design principles aligned to Option 3.\n>\n> **Rationale:**\n> *   **Focus & Quality:** Mastering the complexities of distributed trace collection, sampling, and analysis is a significant challenge. Splitting effort across multiple signal types risks delivering a mediocre product in all areas.\n> *   **Ecosystem Maturity:** The OpenTelemetry project provides robust standards for traces. By adhering to it, we enable users to pair our tracing system with their preferred best-in-class solutions for logs (e.g., Loki) and metrics (e.g., Prometheus).\n> *   **Correlation over Unification:** The highest value comes from correlating *across* these signals (e.g., jumping from a high-latency trace to its corresponding logs). We achieve this by emitting standard `TraceID`s, not by building all the systems ourselves.\n>\n> **Consequences:**\n> *   **Positive:** We can build a deep, scalable, and feature-rich tracing system.\n> *   **Positive:** Users are not locked into a monolithic vendor; they can choose best-of-breed for each observability pillar.\n> *   **Negative:** Users must operate and integrate multiple systems for a complete picture.\n> *   **Mitigation:** We will provide clear documentation on correlating traces with logs and metrics from common external systems.\n\n### Scope Boundary Visualization\n\nThe following mental model helps visualize the system's scope within the broader observability landscape:\n\n> **The Observability \"House\":** Imagine observability as a house with three main pillars holding up the roof (which represents understanding your system).\n> *   **Metrics Pillar (Our Non-Goal NG3):** Answers \"How many?\" and \"How much?\" – throughput, error counts, resource utilization. Built by systems like Prometheus.\n> *   **Logs Pillar (Our Non-Goal NG2):** Answers \"What happened?\" – discrete events with detailed context. Built by systems like Elasticsearch/Loki.\n> *   **Traces Pillar (Our Core System):** Answers \"How long?\" and \"What path?\" – the journey of a request, with timing and causality.\n>\n> Our APM system builds and owns the **Traces Pillar**. The roof (full understanding) is supported by all three pillars working together. We design our pillar with strong, standard connections (like `TraceID`) so it can be securely joined with the others, but we do not construct the entire house ourselves.\n\nBy adhering to these Goals and Non-Goals, the project maintains a clear, achievable vision. The subsequent architectural and component designs will be evaluated against this framework to ensure consistency and focus.\n\n### Implementation Guidance\n\nWhile this section is primarily declarative (defining *what*), the act of maintaining a clear project scope has implementation implications, particularly for how components are designed to be extensible yet bounded.\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple/Initial Option | Advanced/Scalable Option |\n| :--- | :--- | :--- |\n| **Scope Enforcement & Feature Flags** | Hard-coded configuration in Go `struct`s, compiled-in behavior. | External configuration service (e.g., etcd, Consul) with dynamic reloading and feature flag system (e.g., LaunchDarkly SDK). |\n| **Dependency / Boundary Definition** | Explicit `internal/` package boundaries in Go to prevent unwanted imports. | API versioning for public endpoints (e.g., `/api/v1/collect`) and clear internal gRPC/protobuf service definitions. |\n\n**B. Recommended File/Module Structure:**\nTo enforce the separation of concerns implied by our non-goals, the project layout should isolate core tracing logic from potential future extensions or integrations with other systems.\n\n```\napm-tracing-system/\n├── cmd/                           # Application entry points\n│   ├── collector/                 # Trace collector service (Milestone 1)\n│   ├── query-service/            # Service for querying traces and service maps\n│   └── analytics-engine/         # Performance analytics service (Milestone 4)\n├── internal/                      # Private application code\n│   ├── apm/                      # Core APM domain logic\n│   │   ├── trace/                # Trace and Span data models (G1)\n│   │   ├── sampling/             # Head & tail sampling logic (G3)\n│   │   ├── servicemap/           # Graph construction algorithms (G2)\n│   │   └── analytics/            # Percentile & anomaly detection (G4)\n│   ├── collector/                # Ingestion API & pipeline (G1, G6)\n│   ├── storage/                  # Abstraction for trace storage (G1, G7)\n│   │   ├── memory/               # In-memory store (for testing)\n│   │   └── cassandra/            # Cassandra-backed store (for production)\n│   └── sdk/                      # Go APM SDK implementation (G5)\n│       ├── instrumentation/      # Auto-instrumentation wrappers\n│       └── propagate/            # Context propagation utilities\n├── pkg/                          # Public libraries (if any)\n│   └── otelhelpers/              # OpenTelemetry compatibility utilities\n└── api/                          # API definitions (protobuf, OpenAPI)\n    ├── protos/                   # .proto files for gRPC\n    └── openapi/                  # OpenAPI specs for HTTP endpoints\n```\n\n**C. Core Logic Skeleton Code (Scope Validation Helper):**\nWhile not a core component, a validation helper at system initialization can guard against accidental scope creep in configuration.\n\n```go\n// internal/apm/config/validator.go\n\n// Config holds the runtime configuration for the APM system.\ntype Config struct {\n    MaxIngestionRate int           `yaml:\"max_ingestion_rate\"`\n    Sampling         SamplingConfig `yaml:\"sampling\"`\n    Storage          StorageConfig  `yaml:\"storage\"`\n    // ... other fields\n}\n\n// Validate ensures the configuration does not request out-of-scope (non-goal) capabilities.\nfunc (c *Config) Validate() error {\n    // G6: Performance guardrail\n    if c.MaxIngestionRate > 10000 { // Example limit\n        return fmt.Errorf(\"max_ingestion_rate %d exceeds supported scale for this version\", c.MaxIngestionRate)\n    }\n\n    // NG3: Ensure we are not mistakenly configured to collect host metrics.\n    // (This is a placeholder; the real check would be for absent or nil config sections)\n    if c.HostMetrics != nil {\n        return fmt.Errorf(\"host_metrics collection is a non-goal (NG3). Please remove this configuration\")\n    }\n\n    // Add other validations as needed for non-goals...\n    return nil\n}\n```\n\n**D. Language-Specific Hints (Go):**\n*   Use the `internal` directory pattern religiously. Code inside `internal/` cannot be imported by code outside your project repository. This is a powerful mechanism to enforce API boundaries and prevent your packages from being used in ways you didn't intend (a form of scope enforcement).\n*   For configuration, use a library like `spf13/viper` which supports reading from multiple sources (files, env vars) and allows you to bind your config `struct`. The `Validate()` method can be called after the config is loaded.\n*   Start every component's `main.go` with a call to `config.Validate()` and exit gracefully if validation fails, ensuring the system never starts in an out-of-scope configuration.\n\n---\n\n\n## 3. High-Level Architecture\n> **Milestone(s):** This section provides the architectural foundation for all subsequent milestones, defining the system's components and their relationships that will be implemented across Milestones 1-5.\n\nThink of the APM Tracing System as a **distributed nervous system** for your microservices architecture. Just as the human nervous system has sensory receptors (nerve endings), transmission pathways (nerves), processing centers (brain and spinal cord), and a way to perceive the processed information (conscious awareness), our APM system has components that collect, transmit, store, analyze, and visualize trace data. This architectural overview maps out this \"nervous system,\" showing how telemetry flows from your applications to insights you can act upon.\n\n### Component Overview and Responsibilities\n\nThe APM Tracing System is composed of five primary components that work together in a data pipeline. Data flows unidirectionally through most of these components (from left to right in the diagram), with some feedback loops for configuration and querying.\n\n![APM System Component Diagram](./diagrams/sys-comp-diagram.svg)\n\nEach component has a specific responsibility in the trace lifecycle, following the **single responsibility principle** to ensure maintainability and scalability. The table below details each component's role, what data it owns, and how it interacts with others:\n\n| Component | Primary Responsibility | Key Data It Owns/Holds | Interface to Other Components |\n|-----------|-----------------------|------------------------|-------------------------------|\n| **APM SDK & Agent** | **Instrumentation & Span Emission** | Span context (trace ID, span ID, parent span ID) within application memory; Configuration for sampling and reporting | • **To Collector:** Sends spans via HTTP/gRPC using OpenTelemetry format<br>• **To Application:** Injects itself via middleware/monkey-patching to intercept calls |\n| **Collector** | **Span Ingestion & Initial Processing** | In-memory buffers of recently received spans; Sampling configuration and decision cache | • **From Agent:** Receives spans via ingestion endpoints<br>• **To Storage:** Writes processed spans to persistent storage<br>• **To Query Service:** Notifies of trace completion events |\n| **Storage Backend** | **Durable Trace Storage & Indexing** | All persisted span data; Secondary indexes on trace ID, service, operation, and timestamp | • **From Collector:** Accepts span writes<br>• **From Query Service:** Serves span reads and index queries<br>• **To Analytics Engine:** Provides historical data for baseline calculation |\n| **Query Service** | **Trace Retrieval & Service Map Computation** | Materialized service dependency graph (if pre-computed); Query execution plans and results caching | • **From Storage:** Reads spans and indexes<br>• **To Web UI:** Serves trace lists, individual traces, and service map data<br>• **To Collector:** Receives trace completion notifications for tail-based sampling |\n| **Web UI** | **Visualization & User Interaction** | User session state, visualization preferences, alert configurations | • **To Query Service:** Sends queries for traces and service maps<br>• **To User:** Renders interactive visualizations and dashboards |\n\nThe **data flow** follows a clear pipeline:\n1. **Instrumentation Phase:** Application code, via the APM SDK, generates `Span` objects during execution.\n2. **Emission Phase:** The SDK sends these spans to the Collector via network calls.\n3. **Ingestion Phase:** The Collector receives spans, validates them, applies sampling decisions, and buffers them for assembly.\n4. **Storage Phase:** Assembled spans are written to the Storage Backend with appropriate indexing.\n5. **Processing Phase:** The Query Service reads from storage to compute service maps and serve trace queries.\n6. **Visualization Phase:** The Web UI queries the Query Service and renders results for users.\n\nThere are also two important **cross-cutting concerns** that span multiple components:\n- **Configuration Management:** All components read from a centralized configuration service (or files) for settings like sampling rates, storage endpoints, and feature flags.\n- **Observability of the Observability System:** The APM system itself generates metrics, logs, and traces about its own operation, which are fed back into itself (dogfooding) or to a separate monitoring system.\n\n> **Key Design Insight:** This architecture employs the **pipes and filters** pattern. Each component transforms or routes the data stream, allowing independent scaling and technology choices per component. The Collector can be scaled horizontally to handle ingestion load, while the Storage Backend and Query Service can be optimized separately for write-heavy versus read-heavy workloads.\n\n#### Detailed Component Breakdown\n\n**APM SDK & Agent**\nThis component is actually a **library** embedded within your application processes (the SDK) and potentially a **sidecar/daemon** (the Agent) that manages span batching and export. Its core job is to make tracing **automatic** for developers. It intercepts key operations (HTTP requests, database queries, async tasks), creates `Span` records, propagates the `Trace` context across service boundaries using headers (like `TRACE_ID_HEADER`), and finally exports completed spans to the Collector. It must be extremely lightweight to avoid perturbing the very performance it's measuring.\n\n**Collector**\nThe Collector is the system's **front door and traffic cop**. It's a stateful service that receives spans from potentially thousands of concurrent application instances. Beyond simple receipt, it must:\n- **Validate** incoming spans for format correctness.\n- **Apply head-based sampling** immediately to reduce volume.\n- **Buffer and reassemble** spans that arrive out-of-order into complete traces.\n- **Apply tail-based sampling** decisions once traces are complete.\n- **Batch and write** final spans to storage efficiently.\nThink of it as a package sorting facility: packages (spans) arrive on many conveyor belts, are sorted by destination (trace ID), assembled into complete shipments (traces), and then loaded onto trucks (storage writes).\n\n**Storage Backend**\nThis is the system's **long-term memory**. It must store massive volumes of span data (each request generates multiple spans) with efficient retrieval patterns. The primary access pattern is **retrieve all spans for a given trace ID**, requiring a primary index on `TraceID`. Secondary access patterns include:\n- Find traces for a specific service/operation within a time range.\n- Retrieve raw span data for service map computation (which could also be done via materialized views).\n- Access historical data for performance baselines and trend analysis.\nThe storage system must balance cost, query performance, and write throughput, often leading to a multi-tiered storage strategy (hot recent data in one system, colder data in another).\n\n**Query Service**\nThis component is the **analytic brain**. It translates user queries (e.g., \"show traces for service 'checkout' with errors in the last hour\") into efficient storage queries, computes aggregations (like the service dependency graph), and formats results for the UI. For performance, it may maintain **materialized views** (pre-computed service maps) or **caches** of frequent query results. It also houses the **analytics engine** that computes percentiles and runs anomaly detection algorithms on the fly or on scheduled intervals.\n\n**Web UI**\nThe UI is the **human interface** to the system. It provides:\n- A **trace viewer** showing waterfall diagrams of request flow.\n- A **service map** visualization with interactive exploration.\n- **Dashboards** for key performance indicators (latency, error rates).\n- **Alert management** interfaces.\n- **Search and query builders**.\nIt's a client-side application that talks to the Query Service's API, and it must handle large datasets efficiently (e.g., virtual scrolling for long trace lists).\n\n#### Component Interaction Patterns\n\nThe components communicate using two primary patterns:\n\n1. **Asynchronous Fire-and-Forget (Spans):** The SDK → Collector → Storage flow is primarily asynchronous. The SDK sends spans and doesn't wait for them to be stored; it may buffer and batch locally. The Collector acknowledges receipt quickly (within 100ms per Milestone 1) but writes to storage asynchronously. This ensures low overhead on the instrumented application.\n\n2. **Synchronous Request-Response (Queries):** The Web UI → Query Service → Storage flow for trace retrieval is synchronous. Users expect to see their query results, so the UI waits for the Query Service to return traces or service map data. These queries can be complex and may require optimization (pagination, time-range restrictions).\n\n### Recommended File/Module Structure\n\nA well-organized codebase mirrors the architectural components, making it intuitive for developers to navigate and maintain. For our Go implementation, we follow the **Standard Go Project Layout** conventions with some adaptations for our specific domain.\n\n> **Mental Model: A Library's Organization**  \n> Think of the project structure like a well-organized library. The `cmd/` directory is the main entrance (front desk). Each major component gets its own **wing** (`internal/collector/`, `internal/query/`). Within each wing, books are grouped by topic: the main logic (`*.go`), its tests (`*_test.go`), configuration (`config/`), and internal helpers (`internal/` within the component). Shared utilities used across wings live in `pkg/` (like the reference section). This organization helps you know exactly where to go to find or modify any piece of functionality.\n\n```\napm-tracing-system/\n├── cmd/                          # Application entry points\n│   ├── collector/                # Collector service binary\n│   │   └── main.go               # Sets up config, starts HTTP/gRPC servers\n│   ├── query-service/            # Query service binary\n│   │   └── main.go\n│   └── web-ui/                   # Web UI server (could be Go serving static files + API proxy)\n│       └── main.go\n│\n├── internal/                     # Private application code (not importable by others)\n│   ├── apmsdk/                   # Milestone 5: APM SDK & Auto-Instrumentation\n│   │   ├── instrument/           # Auto-instrumentation wrappers\n│   │   │   ├── http/             # HTTP client/server instrumentation\n│   │   │   ├── database/         # SQL driver wrappers\n│   │   │   └── frameworks/       # Gin, Echo, etc. middleware\n│   │   ├── tracer/               # Core tracer implementation\n│   │   │   ├── tracer.go         # `Tracer` struct and methods\n│   │   │   ├── span.go           # `Span` struct methods\n│   │   │   └── propagation/      # W3C Trace Context propagation logic\n│   │   └── config/               # SDK configuration\n│   │\n│   ├── collector/                # Milestone 1: Trace Collection\n│   │   ├── api/                  # HTTP/gRPC handlers for span ingestion\n│   │   │   ├── http_handler.go\n│   │   │   └── grpc_handler.go\n│   │   ├── ingestion/            # Core ingestion pipeline\n│   │   │   ├── pipeline.go       # Main pipeline orchestration\n│   │   │   ├── validator.go      # Span validation logic\n│   │   │   ├── buffer/           # Buffering strategies for trace assembly\n│   │   │   │   ├── memory_buffer.go\n│   │   │   │   └── wal_buffer.go  # Write-ahead log backed buffer (ADR)\n│   │   │   └── assembler.go      # Trace assembly from spans\n│   │   ├── sampling/             # Milestone 3: Sampling (head-based here)\n│   │   │   ├── sampler.go        # `Sampler` interface\n│   │   │   ├── probabilistic.go  # Probabilistic (head) sampler\n│   │   │   └── consistent.go     # Trace-ID consistent hash sampler\n│   │   └── storage/              # Client to write to storage backend\n│   │       └── writer.go         # Batched span writer\n│   │\n│   ├── storage/                  # Storage abstraction layer\n│   │   ├── driver/               # Storage driver interfaces\n│   │   │   ├── writer.go         # `StorageWriter` interface\n│   │   │   └── reader.go         # `StorageReader` interface\n│   │   ├── indexes/              # Index management logic\n│   │   │   ├── trace_index.go    # Primary index on TraceID\n│   │   │   └── service_index.go  # Secondary index on ServiceName\n│   │   └── implementations/      # Concrete implementations\n│   │       ├── memory/           # In-memory store (for testing)\n│   │       ├── cassandra/        # Cassandra implementation\n│   │       └── elasticsearch/    # Elasticsearch implementation\n│   │\n│   ├── query/                    # Milestone 2 & 4: Query Service & Analytics\n│   │   ├── service/              # gRPC/REST API for queries\n│   │   │   └── handler.go        # Request handlers for trace/search\n│   │   ├── servicemap/           # Milestone 2: Service Map\n│   │   │   ├── builder.go        # Graph construction from spans\n│   │   │   ├── graph.go          # `ServiceGraph` data structure\n│   │   │   ├── aggregator.go     # Edge metric aggregation\n│   │   │   └── materialized/     # Materialized view updater\n│   │   ├── analytics/            # Milestone 4: Performance Analytics\n│   │   │   ├── percentiles/      # t-digest based percentile calculator\n│   │   │   │   ├── aggregator.go\n│   │   │   │   └── tdigest.go    # t-digest implementation\n│   │   │   ├── anomaly/          # Anomaly detection\n│   │   │   │   ├── detector.go   `AnomalyDetector` interface\n│   │   │   │   ├── zscore.go     # Z-score based detector\n│   │   │   │   └── baseline.go   # Historical baseline manager\n│   │   │   └── timeseries/       # Time-series aggregation\n│   │   │       └── aggregator.go\n│   │   └── tail_sampling/        # Milestone 3: Tail-based sampling\n│   │       └── evaluator.go      # Evaluates complete traces for keeping\n│   │\n│   ├── webui/                    # Web UI backend (if not purely static)\n│   │   ├── static/               # Serves compiled frontend assets\n│   │   └── api_proxy.go          # Proxies API calls to query service\n│   │\n│   └── models/                   # Shared data models (used by multiple components)\n│       ├── trace.go              # `Trace` and `Span` struct definitions\n│       ├── service.go            # `Service` struct\n│       ├── config.go             # `Config`, `SamplingConfig`, `StorageConfig`\n│       └── telemetry/            # OpenTelemetry protobuf/generated code\n│\n├── pkg/                          # Public, reusable libraries\n│   ├── sampling/                 # Sampling utilities (importable by others)\n│   ├── traceutils/               # Trace ID generation, context manipulation\n│   └── instrumentation/          # Safe instrumentation helpers\n│\n├── api/                          # API definitions (protobuf, OpenAPI)\n│   ├── protos/                   # .proto files for gRPC\n│   └── openapi/                  # OpenAPI/Swagger specs for REST\n│\n├── configs/                      # Configuration files\n│   ├── collector.yaml            # Collector configuration\n│   ├── query-service.yaml        # Query service configuration\n│   └── sdk-config.example.json   # Example SDK configuration\n│\n├── scripts/                      # Build, deployment, maintenance scripts\n├── deployments/                  # Dockerfiles, Kubernetes manifests\n├── tests/                        # Integration, load tests\n│   ├── integration/              # Component integration tests\n│   └── load/                     # Load test scenarios\n│\n└── docs/                         # Design docs, ADRs, user guides\n    ├── adrs/                     # Architecture Decision Records\n    └── milestones/               # Milestone-specific documentation\n```\n\n#### Key Structural Decisions\n\nThis structure embodies several architectural decisions:\n\n1. **Clear Separation of Concerns:** Each major component (`collector`, `query`, `apmsdk`) lives in its own directory under `internal/`, minimizing accidental coupling.\n\n2. **Internal vs. Public Code:** The `internal/` directory prevents external projects from importing our core application logic, which is an implementation detail. Publicly reusable utilities (like sampling algorithms or trace utilities) are placed in `pkg/` for potential use by other projects (e.g., custom instrumentation libraries).\n\n3. **Shared Models Centralized:** The `internal/models/` directory contains data structures (`Trace`, `Span`, `Service`) used across multiple components. This avoids duplication and ensures consistency. However, each component's internal representations may differ from these shared models for performance or convenience.\n\n4. **Interface-Driven Storage:** The `storage/driver/` directory defines interfaces (`StorageWriter`, `StorageReader`), while concrete implementations live separately. This allows swapping storage backends (Cassandra, Elasticsearch, etc.) without changing business logic.\n\n5. **Configuration Externalized:** All configuration files reside in `configs/`, separate from code, enabling environment-specific deployments (dev, staging, prod).\n\n6. **Entry Points Isolated:** Each service binary (`collector`, `query-service`, `web-ui`) has its own subdirectory under `cmd/`, each with a simple `main.go` that wires together components from `internal/`. This keeps bootstrap logic clean and separate from core business logic.\n\nThis structure scales well as the project grows. New components (like a separate anomaly detection service) would get their own directory under `internal/` and a corresponding entry point under `cmd/`.\n\n### Implementation Guidance\n\n> **Implementation Focus:** This guidance helps you set up the foundational project structure and make initial technology choices. The actual component implementations will be detailed in subsequent sections.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Starting Point) | Advanced Option (Production Scale) | Rationale for Choice |\n|-----------|-------------------------------|-----------------------------------|----------------------|\n| **Transport (SDK→Collector)** | HTTP/1.1 with JSON (net/http) | gRPC with Protocol Buffers | HTTP/JSON is simpler to debug and has wider client compatibility. gRPC offers better performance and bidirectional streaming. |\n| **Collector Framework** | Plain Go with goroutines + channels | OpenTelemetry Collector Contrib | Building from scratch offers maximal learning; using OTel Collector gives production-ready pipelines and extensive exporters. |\n| **Primary Storage** | PostgreSQL with JSONB columns | Cassandra + Elasticsearch (dual storage) | PostgreSQL is familiar and supports JSON queries; Cassandra handles high write throughput, Elasticsearch enables rich search. |\n| **In-Memory Data Structures** | Built-in maps + slices with `sync.RWMutex` | Partitioned maps with lock striping or `sync.Map` | Built-in types are simplest; advanced structures reduce lock contention under high concurrency. |\n| **Service Communication** | REST HTTP calls | gRPC with service definitions | REST is straightforward; gRPC provides type safety and performance for internal service calls. |\n| **Web UI Frontend** | Static HTML/JS with Vanilla or lightweight framework | React/Vue.js with state management | Simpler UI gets to visualization faster; frameworks help manage complex interactive state. |\n\nFor the learning implementation, we recommend the **Simple Options** to focus on the core distributed systems concepts rather than framework intricacies.\n\n#### B. Recommended File/Module Structure Starter\n\nTo bootstrap the project, create the directory structure shown above. Here's a minimal set of starter files to create:\n\n**1. Shared Models (`internal/models/trace.go`):**\n```go\npackage models\n\nimport (\n    \"time\"\n)\n\ntype Trace struct {\n    TraceID   string\n    Spans     []Span\n    StartTime time.Time\n    EndTime   time.Time\n}\n\ntype Span struct {\n    SpanID       string\n    TraceID      string\n    ParentSpanID string\n    Name         string\n    ServiceName  string\n    StartTime    time.Time\n    Duration     time.Duration\n    Attributes   map[string]string\n    Events       []SpanEvent\n    Status       SpanStatus\n}\n\ntype SpanEvent struct {\n    Name       string\n    Timestamp  time.Time\n    Attributes map[string]string\n}\n\ntype SpanStatus struct {\n    Code    int    // 0=Unset, 1=Ok, 2=Error\n    Message string\n}\n\ntype Service struct {\n    Name       string\n    Operations []string\n}\n```\n\n**2. Configuration Structure (`internal/models/config.go`):**\n```go\npackage models\n\ntype Config struct {\n    MaxIngestionRate int\n    Sampling         SamplingConfig\n    Storage          StorageConfig\n}\n\nfunc (c *Config) Validate() error {\n    // TODO 1: Check MaxIngestionRate is positive\n    // TODO 2: Validate Sampling configuration (rates between 0 and 1)\n    // TODO 3: Validate Storage configuration (endpoints, timeouts)\n    // TODO 4: Return aggregated errors if any validation fails\n    return nil\n}\n\ntype SamplingConfig struct {\n    Probability float64\n    PerService  map[string]float64\n}\n\ntype StorageConfig struct {\n    Type     string\n    Endpoint string\n    Timeout  time.Duration\n}\n```\n\n**3. Collector Entry Point (`cmd/collector/main.go`):**\n```go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \n    \"apm-tracing-system/internal/collector\"\n    \"apm-tracing-system/internal/models\"\n)\n\nfunc main() {\n    // TODO 1: Load configuration from file or environment\n    config := &models.Config{\n        MaxIngestionRate: 1000,\n        Sampling: models.SamplingConfig{Probability: 0.1},\n        Storage:  models.StorageConfig{Type: \"memory\"},\n    }\n    \n    if err := config.Validate(); err != nil {\n        log.Fatalf(\"Invalid configuration: %v\", err)\n    }\n    \n    // TODO 2: Initialize the collector with configuration\n    coll, err := collector.New(config)\n    if err != nil {\n        log.Fatalf(\"Failed to create collector: %v\", err)\n    }\n    \n    // TODO 3: Start the collector (HTTP/gRPC servers, background workers)\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n    \n    if err := coll.Start(ctx); err != nil {\n        log.Fatalf(\"Failed to start collector: %v\", err)\n    }\n    \n    // TODO 4: Set up graceful shutdown\n    sigChan := make(chan os.Signal, 1)\n    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n    <-sigChan\n    \n    log.Println(\"Shutting down collector...\")\n    coll.Stop()\n    log.Println(\"Collector stopped\")\n}\n```\n\n**4. Basic Collector Skeleton (`internal/collector/collector.go`):**\n```go\npackage collector\n\nimport (\n    \"context\"\n    \"apm-tracing-system/internal/models\"\n)\n\ntype Collector struct {\n    config *models.Config\n    // TODO: Add fields for HTTP server, storage writer, buffers, etc.\n}\n\nfunc New(config *models.Config) (*Collector, error) {\n    // TODO 1: Validate configuration\n    // TODO 2: Initialize storage writer based on config.Storage.Type\n    // TODO 3: Initialize span buffer (in-memory or WAL)\n    // TODO 4: Initialize HTTP/gRPC servers\n    // TODO 5: Return the collector instance\n    return &Collector{config: config}, nil\n}\n\nfunc (c *Collector) Start(ctx context.Context) error {\n    // TODO 1: Start the HTTP/gRPC servers for span ingestion\n    // TODO 2: Start background goroutines for trace assembly\n    // TODO 3: Start periodic flush of completed traces to storage\n    // TODO 4: Return nil if all components started successfully\n    return nil\n}\n\nfunc (c *Collector) Stop() {\n    // TODO 1: Stop accepting new spans (close listeners)\n    // TODO 2: Flush all buffered traces to storage\n    // TODO 3: Stop background goroutines\n    // TODO 4: Close connections to storage\n}\n```\n\n**5. Makefile for Common Tasks:**\n```makefile\n.PHONY: build test run-collector\n\nbuild:\n    go build -o bin/collector ./cmd/collector\n    go build -o bin/query-service ./cmd/query-service\n    go build -o bin/web-ui ./cmd/web-ui\n\ntest:\n    go test ./...\n\nrun-collector:\n    go run ./cmd/collector\n\nrun-all: build\n    # Would use docker-compose in real scenario\n    ./bin/collector &\n    ./bin/query-service &\n    ./bin/web-ui &\n```\n\n#### C. Language-Specific Hints for Go\n\n1. **Concurrency Model:** Use goroutines for independent tasks (listening for spans, assembling traces, writing to storage). Use channels for communication between these goroutines (e.g., a channel for incoming spans, another for completed traces).\n\n2. **Context Propagation:** Use `context.Context` extensively for cancellation and deadlines. Pass context through function calls, especially for network operations (HTTP handlers, storage writes).\n\n3. **Error Handling:** Go's explicit error handling is ideal for observability systems. Always check errors, and add context with `fmt.Errorf(\"failed to write span: %w\", err)` when propagating errors up the call stack.\n\n4. **Configuration Management:** Use struct tags with libraries like `github.com/spf13/viper` for binding environment variables and YAML files to your `Config` struct.\n\n5. **Testing:** Use table-driven tests for stateless functions. For concurrent components, use `testing` package's built-in race detector (`go test -race`) to identify data races.\n\n6. **Performance:** Profile early with `go tool pprof`. Pay attention to memory allocations (use `go test -bench . -benchmem`) and lock contention in hot paths.\n\n#### D. Milestone Checkpoint: Architecture Setup\n\nAfter setting up the initial structure:\n\n1. **Verify Directory Structure:** Run `find . -type f -name \"*.go\" | head -20` to confirm key files exist.\n\n2. **Build the Project:** Run `make build` (or `go build ./...`). It should compile without errors, even though the implementations are mostly stubs.\n\n3. **Run Basic Tests:** Execute `go test ./internal/models/...` to validate the model definitions compile correctly.\n\n4. **Start the Collector:** Run `make run-collector`. It should start and immediately exit (since the `Start` method returns `nil` without actually starting servers). This confirms the wiring works.\n\n**Signs Something Is Wrong:**\n- **Compilation errors:** Check package imports and ensure all directories have proper `package` declarations.\n- **\"Cannot find module\" errors:** Run `go mod init apm-tracing-system` at the project root to initialize the module.\n- **\"Undefined type\" errors:** Ensure you've created all the model structs with exact field names from the naming conventions.\n\nWith this architecture in place, you have a clean foundation to implement each component in the subsequent milestones. The clear separation of concerns will allow you to work on one component (e.g., the Collector in Milestone 1) without worrying about the details of others.\n\n\n> **Milestone(s):** This section provides the foundational data definitions for the entire APM Tracing System, directly supporting Milestone 1 (Trace Collection) and underpinning all subsequent milestones (Service Map, Trace Sampling, Performance Analytics, and APM SDK).\n\n## 4. Data Model\n\n**Mental Model: The Family Tree Album**\nThink of the entire APM system as a massive, digital family tree album for software requests. A **Trace** is one complete family tree—the story of a single request as it travels through your services. Each **Span** is an individual family member—a specific unit of work performed by one service. The **Service** is like a family name or household—a logical grouping of related spans. This album (your storage) must organize millions of these family trees so you can quickly find all members of a specific family (trace), identify which households (services) they visited, and understand their relationships.\n\n### Core Types: Span, Trace, and Service\n\nThe system revolves around three fundamental entities. Understanding their exact structure is critical because every component—from ingestion to visualization—operates on these types.\n\n#### The Span: An Individual Operation\n\nA **Span** represents a named, timed operation representing a unit of work performed by a single service. It's the atomic building block of distributed tracing. Think of it as a single \"footprint\" left by a request as it passes through a service.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `SpanID` | `string` | A unique identifier for this specific span within the context of its trace. Typically a 64-bit random number encoded as 16 hexadecimal characters. Must be unique within its trace but can collide across different traces. |\n| `TraceID` | `string` | The unique identifier of the trace to which this span belongs. All spans that are part of the same request share this same ID. Usually a 128-bit random number encoded as 32 hexadecimal characters. This is the primary grouping key. |\n| `ParentSpanID` | `string` | The `SpanID` of the parent span in the trace hierarchy. If this span is the root (the first operation in the request), this field is an empty string. This field establishes the parent-child relationships that form the trace tree structure. |\n| `Name` | `string` | A human-readable name describing the operation (e.g., `\"HTTP GET /api/users\"`, `\"database.query\"`, `\"redis.get\"`). Often called the operation name. Used for aggregation and filtering. |\n| `ServiceName` | `string` | The name of the service that generated this span (e.g., `\"user-service\"`, `\"auth-service\"`, `\"payment-gateway\"`). This is how spans are associated with a particular service. |\n| `StartTime` | `time.Time` | The precise timestamp (with nanosecond precision) when the operation represented by this span began. Must be comparable across different machines (requires clock synchronization or normalization). |\n| `Duration` | `time.Duration` | The length of time the operation took to complete, measured from `StartTime` to the end. This is critical for performance analysis. Represented as a 64-bit integer of nanoseconds. |\n| `Attributes` | `map[string]string` | A set of key-value pairs that provide additional contextual metadata about the span. Examples: `{\"http.method\": \"GET\", \"http.status_code\": \"200\", \"db.system\": \"postgresql\", \"user.id\": \"12345\"}`. Used for detailed debugging and filtering. |\n| `Events` | `[]SpanEvent` | A chronological list of timestamped annotations that occurred during the span's execution. Each event represents a notable occurrence like an exception, a log statement, or a cache hit/miss. |\n| `Status` | `SpanStatus` | The final status of the operation represented by this span. Indicates whether it completed successfully, ended with an error, or was unset. Contains both a code and an optional descriptive message. |\n\n#### SpanEvent: Annotated Moments in Time\n\nA **SpanEvent** is a timestamped annotation attached to a span, representing something noteworthy that happened during the span's lifetime. Think of it as a \"sticky note\" attached to a specific moment on the span's timeline.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Name` | `string` | A descriptive name for the event (e.g., `\"exception\"`, `\"cache.miss\"`, `\"message.sent\"`, `\"checkpoint\"`). |\n| `Timestamp` | `time.Time` | The exact moment when this event occurred, relative to the span's `StartTime`. |\n| `Attributes` | `map[string]string` | Additional context specific to this event. For an exception event, this might include `{\"exception.type\": \"IOException\", \"exception.message\": \"File not found\"}`. |\n\n#### SpanStatus: Operation Outcome\n\n**SpanStatus** indicates the final outcome of the span's operation. This is semantically different from technical success/failure—a span can complete successfully (code 0) even if the business logic failed (e.g., a `404 Not Found` response).\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Code` | `int` | A numerical code representing the status. Follows OpenTelemetry semantics: `0` (Unset), `1` (OK), `2` (Error). An `Error` code indicates the operation itself failed (e.g., a database connection error, timeout). |\n| `Message` | `string` | An optional human-readable message providing additional details about the status, particularly useful when `Code` is `2` (Error). Example: `\"connection refused\"`, `\"timeout after 5s\"`. |\n\n#### The Trace: A Complete Request Journey\n\nA **Trace** is a collection of spans that together represent the complete path of a single request through the distributed system. It's not a separate stored entity but a logical aggregation computed from spans sharing the same `TraceID`.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `TraceID` | `string` | The unique identifier for this trace. Matches the `TraceID` of all spans belonging to this trace. |\n| `Spans` | `[]Span` | All spans that belong to this trace, typically in no particular order initially. They must be sorted by `StartTime` and arranged in parent-child hierarchy for display and analysis. |\n| `StartTime` | `time.Time` | The earliest `StartTime` among all spans in the trace. Derived by finding the minimum span `StartTime`. Useful for time-range queries. |\n| `EndTime` | `time.Time` | The latest end time (calculated as `StartTime + Duration`) among all spans in the trace. Derived by finding the maximum span end time. Together with `StartTime`, defines the trace's temporal bounds. |\n\n> **Design Insight:** The `Trace` type is primarily a **view** or **query result**, not a storage primitive. We store individual spans, then assemble them into traces when queried. This is more flexible than storing complete traces because spans can arrive out-of-order, and we can handle partial traces.\n\n#### The Service: A Logical Component\n\nA **Service** represents a deployable, versioned software component in your architecture. In tracing terms, it's the source that emits spans.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Name` | `string` | The unique name identifying this service (e.g., `\"frontend-web\"`, `\"user-service-v2\"`, `\"payment-processor\"`). This should match the `ServiceName` field in spans. |\n| `Operations` | `[]string` | A list of distinct operation names (span `Name` values) that this service has been observed to perform. Derived from analyzing spans. Examples: `[\"HTTP GET /api/users\", \"HTTP POST /api/users\", \"database.query.users\"]`. Useful for configuring sampling rates per operation. |\n\n> **Design Insight:** The `Service` type, like `Trace`, is typically a **derived entity** computed from span data, not stored directly. However, we might maintain a materialized view of services and their operations for fast access by the UI and configuration systems.\n\n### Relationships and Storage Indexing Strategy\n\n**Mental Model: The Library Catalog System**\nImagine our storage system as a massive library containing billions of individual pages (spans). Each book (trace) is scattered across the library—its pages aren't bound together but are identified by sharing the same call number (TraceID). To find all pages of a book, we need a catalog that tells us where every page with a given call number is located. Additionally, researchers might want to find all books that mention a particular topic (service) or were published in a certain year (time range). We need multiple catalog systems (indexes) to support these different lookup patterns efficiently.\n\n#### Span-to-Trace Relationships: Building the Tree\n\nSpans are linked into a trace through two relationships:\n\n1. **Grouping Relationship**: All spans with the same `TraceID` belong to the same trace. This is a many-to-one relationship.\n2. **Hierarchical Relationship**: The `ParentSpanID` field establishes parent-child links, forming a tree (or more generally, a directed acyclic graph) within the trace. A span's parent is another span in the same trace.\n\nThe hierarchical structure is critical for:\n- **Service Map Construction**: By analyzing parent-child relationships where the parent and child have different `ServiceName` values, we can infer service-to-service calls.\n- **Root Cause Analysis**: Understanding which span's failure caused cascading failures downstream.\n- **Critical Path Analysis**: Identifying the longest chain of dependencies that determines the total trace duration.\n\n**Visualizing the Relationships:**\n![Data Model: Span and Trace Relationships](./diagrams/data-model-diagram.svg)\n\n#### Storage Strategy: Balancing Write Speed and Query Flexibility\n\nThe primary design challenge is organizing billions of spans so we can efficiently:\n1. **Retrieve all spans for a specific trace** (for viewing a single request's journey)\n2. **Find traces involving a specific service** (for service-focused debugging)\n3. **Find traces within a time range** (for investigating incidents)\n4. **Find traces with specific attributes** (e.g., all traces with `http.status_code=500`)\n\nWe face competing priorities: writing spans must be extremely fast (thousands per second), while queries should be reasonably fast but can tolerate some latency.\n\n**Architecture Decision Record: Storage Schema and Indexing Approach**\n\n> **Decision: Span-Centric Storage with Composite Primary Key and Secondary Indexes**\n>\n> - **Context**: We need to store massive volumes of span data (potentially billions of spans) with predictable write performance while supporting the core query patterns. The data has inherent dimensionality: trace ID (high cardinality), service name (medium cardinality), operation name (high cardinality), and timestamp (continuous).\n>\n> - **Options Considered**:\n>   1. **Trace-Centric Storage**: Store complete traces as single documents (JSON/protobuf blobs) keyed by `TraceID`. All spans of a trace are written together.\n>   2. **Span-Centric Storage**: Store individual spans as separate records with a composite primary key that includes `TraceID` for co-location.\n>   3. **Time-Partitioned Span Storage**: Store spans in partitions based on their `StartTime` (e.g., daily or hourly partitions), with secondary indexes within each partition.\n>\n> - **Decision**: We chose **Option 2 (Span-Centric Storage with Composite Primary Key)** as our foundation, combined with time-based partitioning for data management.\n>\n> - **Rationale**:\n>   - **Write Performance**: Spans arrive asynchronously from different services. A trace-centric approach would require buffering all spans of a trace before writing, risking data loss if the buffer is lost and increasing write latency. Writing spans immediately as they arrive provides better durability and lower latency.\n>   - **Out-of-Order Arrival**: Spans can arrive minutes or even hours after their parent spans due to network delays, buffering, or clock skew. A span-centric model naturally accommodates this; we simply write late-arriving spans to the same logical location.\n>   - **Scalability**: By using `(TraceID, SpanID)` as a composite primary key in a distributed database like Cassandra or ScyllaDB, all spans of a trace are stored on the same physical node (due to partition key hashing on `TraceID`). This makes trace retrieval a single-partition query, which is extremely efficient.\n>   - **Flexibility**: We can add secondary indexes on other dimensions (`ServiceName`, `StartTime`) without affecting the primary write path.\n>\n> - **Consequences**:\n>   - **Trace Assembly Requires Query**: Retrieving a full trace requires querying all spans for that `TraceID`. This is an efficient single-partition operation but still involves reading multiple records.\n>   - **Secondary Index Overhead**: Maintaining indexes on `ServiceName` and `StartTime` incurs additional write overhead and storage.\n>   - **Eventual Consistency**: In distributed databases, secondary indexes are often eventually consistent, meaning recently written spans might not immediately appear in service-based queries.\n\nThe following table compares the storage approaches:\n\n| Approach | Pros | Cons | Suitable For |\n|----------|------|------|--------------|\n| **Trace-Centric** | - Single read retrieves entire trace<br>- Natural trace assembly<br>- Simpler query logic | - Must buffer spans before writing<br>- Risk of data loss if buffer fails<br>- Does not handle out-of-order span arrival well | Small-scale systems where traces complete quickly and spans arrive in order |\n| **Span-Centric** | - Immediate durability for each span<br>- Handles out-of-order arrival naturally<br>- Scales horizontally with trace ID as shard key | - Multiple reads to assemble a trace<br>- Requires secondary indexes for service/time queries | **Our choice**: Large-scale production systems with high-volume, asynchronous span ingestion |\n| **Time-Partitioned** | - Efficient time-range queries<br>- Easy data retention (drop old partitions)<br>- Aligns with natural query patterns | - Spans of same trace may scatter across partitions<br>- Requires cross-partition queries for trace assembly | Systems where time-based queries dominate and trace assembly is less frequent |\n\n#### Indexing Strategy: The Multi-Catalog System\n\nWe need three types of indexes to support our query patterns:\n\n1. **Primary Index (Clustered)**: `(TraceID, SpanID)`\n   - **Purpose**: Efficient retrieval of all spans for a given trace.\n   - **Implementation**: In Cassandra/ScyllaDB, `TraceID` is the partition key, `SpanID` is the clustering key. In Elasticsearch, this would be a primary term index on `TraceID` with `SpanID` as document ID.\n   - **Query Pattern**: `SELECT * FROM spans WHERE TraceID = ?`\n\n2. **Secondary Index: Service + Time Range**\n   - **Purpose**: Find traces for a specific service within a time window (essential for service dashboards and the service map).\n   - **Implementation**: A separate index table with composite key `(ServiceName, StartTimeBucket, TraceID)`, where `StartTimeBucket` is a time window (e.g., hour or day) for range query efficiency.\n   - **Query Pattern**: `SELECT TraceID FROM service_index WHERE ServiceName = ? AND StartTimeBucket >= ? AND StartTimeBucket <= ? LIMIT 1000`\n\n3. **Secondary Index: Global Time Range**\n   - **Purpose**: Find all traces within a time range (for incident investigation when you don't know which service was involved).\n   - **Implementation**: A time-series-optimized store or a separate index table with key `(StartTimeBucket, TraceID)`.\n   - **Query Pattern**: `SELECT TraceID FROM time_index WHERE StartTimeBucket >= ? AND StartTimeBucket <= ? LIMIT 10000`\n\n4. **Attribute Index (Selective)**\n   - **Purpose**: Find traces with specific attribute values (e.g., all traces where `http.status_code = 500`).\n   - **Implementation**: Only index high-value, low-cardinality attributes (like `http.status_code`, `error=true`). High-cardinality attributes (like `user.id`) should not be indexed; instead, use filtering on already-retrieved traces.\n   - **Query Pattern**: `SELECT TraceID FROM attr_index WHERE attr_key = ? AND attr_value = ? AND StartTimeBucket = ?`\n\n> **Design Insight:** We use a **two-phase query** pattern for most searches: First, use a secondary index to find relevant `TraceID`s, then use the primary index to fetch the complete span data for those traces. This balances query flexibility with write performance.\n\n#### Data Retention and Partitioning\n\nGiven the massive volume of trace data, we cannot store everything forever. We implement:\n\n- **Time-Based Partitioning**: Spans are partitioned by their `StartTime` (e.g., daily partitions). Old partitions can be archived or deleted based on retention policies.\n- **Sampling as First-Line Defense**: Before indexing, we apply sampling (Milestone 3) to reduce the volume of spans stored.\n- **Aggregation for Long-Term Trends**: For performance analytics (Milestone 4), we compute and store aggregated metrics (p50, p95, p99 latencies per service per minute) which have much longer retention than raw spans.\n\n**Common Pitfalls in Data Modeling and Storage**\n\n⚠️ **Pitfall: Treating Trace as a Stored Entity**\n- **Description**: Storing complete traces as monolithic blobs rather than individual spans.\n- **Why it's wrong**: When a new span arrives for an existing trace, you must read-modify-write the entire trace document. This creates contention, complicates out-of-order writes, and makes partial failures more costly (losing an entire trace vs. one span).\n- **How to avoid**: Store spans individually. Treat `Trace` as a view assembled at query time. Use `TraceID` as the primary grouping key in your storage schema.\n\n⚠️ **Pitfall: Over-Indexing High-Cardinality Fields**\n- **Description**: Creating secondary indexes on fields with many distinct values, such as full HTTP URLs with parameters (`/api/users/12345`) or user IDs.\n- **Why it's wrong**: High-cardinality indexes become massive (approaching the size of the primary data), slow down writes dramatically, and can overwhelm the index system.\n- **How to avoid**: Only index low-to-medium cardinality fields (`ServiceName`, `http.method`, `http.status_code`). For high-cardinality filtering, use post-retrieval filtering or specialized search systems. Normalize operation names by removing dynamic parameters before indexing (e.g., `/api/users/{id}` instead of `/api/users/12345`).\n\n⚠️ **Pitfall: Ignoring Clock Skew in Timestamps**\n- **Description**: Assuming all spans have perfectly synchronized clocks and using raw `StartTime` values for sorting without normalization.\n- **Why it's wrong**: Servers can have minutes or even hours of clock drift. A child span might appear to start before its parent, breaking causality and making trace visualization incorrect.\n- **How to avoid**: Implement **clock skew correction**. One approach: record the difference between the local clock and a reference (like NTP) in span attributes, or use relative timestamps (monotonic clocks) for duration but absolute timestamps only for coarse ordering. During trace assembly, adjust timestamps based on parent-child relationships or use heuristics to reorder spans.\n\n⚠️ **Pitfall: Storing Unlimited Attribute Data**\n- **Description**: Allowing applications to send spans with megabytes of attribute data (e.g., entire request/response bodies).\n- **Why it's wrong**: This blows up storage costs, slows down queries, and can expose sensitive data. The tracing system is for performance monitoring, not general-purpose logging.\n- **How to avoid**: Enforce **attribute size limits** at the collector (e.g., 2KB total per span). Truncate or drop excess attributes. Provide clear guidelines to developers about what belongs in spans (metadata, not payloads).\n\n### Implementation Guidance\n\n**Technology Recommendations Table:**\n\n| Component | Simple Option (Development/Testing) | Advanced Option (Production) |\n|-----------|-------------------------------------|------------------------------|\n| Primary Storage | In-memory map keyed by `TraceID` (Go `map[string][]Span`) | Distributed columnar database: **Cassandra** or **ScyllaDB** |\n| Secondary Indexes | Separate in-memory maps (e.g., `map[string][]string` for service→traceIDs) | Cassandra **Materialized Views** or **Secondary Index** tables |\n| Time-Series Storage | Rolling window in Go memory with periodic snapshot to disk | **TimescaleDB** (PostgreSQL extension) or **Prometheus** + **Thanos** |\n| Serialization Format | JSON over HTTP (easy debugging) | **Protocol Buffers** over gRPC (efficient binary serialization) |\n\n**Recommended File/Module Structure:**\n\n```\napm-tracing-system/\n├── internal/\n│   ├── models/                    # Core data types\n│   │   ├── span.go               # Span, SpanEvent, SpanStatus types\n│   │   ├── trace.go              # Trace type (mostly view/computation)\n│   │   ├── service.go            # Service type\n│   │   └── config.go             # Config, SamplingConfig, StorageConfig\n│   ├── storage/                  # Storage abstractions and implementations\n│   │   ├── storage.go            # Storage interface\n│   │   ├── inmemory/             # Simple in-memory implementation\n│   │   │   ├── inmemory.go\n│   │   │   └── inmemory_test.go\n│   │   ├── cassandra/            # Cassandra implementation\n│   │   │   ├── cassandra.go\n│   │   │   └── schema.cql        # CQL schema definitions\n│   │   └── index/                # Index management\n│   │       ├── indexer.go\n│   │       ├── service_index.go\n│   │       └── time_index.go\n│   └── utils/\n│       └── timeutils.go          # Clock skew correction utilities\n└── pkg/\n    └── apmproto/                 # Protocol Buffer definitions\n        └── span.proto            # Protobuf schema for span ingestion\n```\n\n**Infrastructure Starter Code (Complete Models):**\n\nFile: `internal/models/span.go`\n```go\npackage models\n\nimport (\n\t\"time\"\n)\n\n// Span represents a single operation within a distributed trace.\ntype Span struct {\n\tSpanID       string            `json:\"spanId\"`                 // Unique within trace\n\tTraceID      string            `json:\"traceId\"`                // Groups spans into traces\n\tParentSpanID string            `json:\"parentSpanId,omitempty\"` // Empty for root spans\n\tName         string            `json:\"name\"`                   // Operation name\n\tServiceName  string            `json:\"serviceName\"`            // Originating service\n\tStartTime    time.Time         `json:\"startTime\"`              // When operation started\n\tDuration     time.Duration     `json:\"duration\"`               // How long it took\n\tAttributes   map[string]string `json:\"attributes,omitempty\"`   // Contextual metadata\n\tEvents       []SpanEvent       `json:\"events,omitempty\"`       // Timestamped annotations\n\tStatus       SpanStatus        `json:\"status\"`                 // Success/error status\n}\n\n// SpanEvent represents a notable event that occurred during a span's execution.\ntype SpanEvent struct {\n\tName       string            `json:\"name\"`                 // Event name (e.g., \"exception\")\n\tTimestamp  time.Time         `json:\"timestamp\"`            // When it happened\n\tAttributes map[string]string `json:\"attributes,omitempty\"` // Event-specific context\n}\n\n// SpanStatus indicates the final status of a span.\ntype SpanStatus struct {\n\tCode    int    `json:\"code\"`              // 0=Unset, 1=OK, 2=Error\n\tMessage string `json:\"message,omitempty\"` // Optional description\n}\n```\n\nFile: `internal/models/trace.go`\n```go\npackage models\n\nimport (\n\t\"sort\"\n\t\"time\"\n)\n\n// Trace represents a complete request journey composed of multiple spans.\n// This is typically a computed view, not a stored entity.\ntype Trace struct {\n\tTraceID   string    `json:\"traceId\"`\n\tSpans     []Span    `json:\"spans\"`\n\tStartTime time.Time `json:\"startTime\"` // Derived: min(span.StartTime)\n\tEndTime   time.Time `json:\"endTime\"`   // Derived: max(span.StartTime + span.Duration)\n}\n\n// NewTraceFromSpans constructs a Trace view from a slice of spans with the same TraceID.\n// It calculates the trace's start and end times and sorts spans by start time.\nfunc NewTraceFromSpans(spans []Span) (*Trace, error) {\n\tif len(spans) == 0 {\n\t\treturn nil, errors.New(\"cannot create trace from empty span slice\")\n\t}\n\t\n\ttraceID := spans[0].TraceID\n\tstartTime := spans[0].StartTime\n\tendTime := spans[0].StartTime.Add(spans[0].Duration)\n\t\n\t// Verify all spans belong to the same trace and calculate time bounds\n\tfor _, span := range spans[1:] {\n\t\tif span.TraceID != traceID {\n\t\t\treturn nil, errors.New(\"spans have different trace IDs\")\n\t\t}\n\t\tif span.StartTime.Before(startTime) {\n\t\t\tstartTime = span.StartTime\n\t\t}\n\t\tspanEnd := span.StartTime.Add(span.Duration)\n\t\tif spanEnd.After(endTime) {\n\t\t\tendTime = spanEnd\n\t\t}\n\t}\n\t\n\t// Sort spans by start time for consistent viewing\n\tsortedSpans := make([]Span, len(spans))\n\tcopy(sortedSpans, spans)\n\tsort.Slice(sortedSpans, func(i, j int) bool {\n\t\treturn sortedSpans[i].StartTime.Before(sortedSpans[j].StartTime)\n\t})\n\t\n\treturn &Trace{\n\t\tTraceID:   traceID,\n\t\tSpans:     sortedSpans,\n\t\tStartTime: startTime,\n\t\tEndTime:   endTime,\n\t}, nil\n}\n```\n\nFile: `internal/models/service.go`\n```go\npackage models\n\n// Service represents a logical component in the distributed system.\ntype Service struct {\n\tName       string   `json:\"name\"`                 // Unique service identifier\n\tOperations []string `json:\"operations,omitempty\"` // Observed operation names\n}\n```\n\n**Core Logic Skeleton Code (Storage Interface):**\n\nFile: `internal/storage/storage.go`\n```go\npackage storage\n\nimport (\n\t\"context\"\n\t\"time\"\n\t\n\t\"github.com/your-org/apm-tracing/internal/models\"\n)\n\n// Storage defines the interface for persistent span storage.\n// Implementations must handle concurrent access and provide\n// the core query patterns needed by the APM system.\ntype Storage interface {\n\t// StoreSpan persists a single span to storage.\n\t// Implementations should also update any secondary indexes.\n\t// Returns an error if the span cannot be stored.\n\tStoreSpan(ctx context.Context, span models.Span) error\n\t\n\t// GetTraceByID retrieves all spans for the given trace ID\n\t// and assembles them into a Trace view. Returns nil if trace not found.\n\tGetTraceByID(ctx context.Context, traceID string) (*models.Trace, error)\n\t\n\t// GetTracesByService returns traces that involve the given service\n\t// within the specified time range. Results are limited to 'limit' traces\n\t// and ordered by most recent start time first.\n\tGetTracesByService(ctx context.Context, serviceName string, \n\t\tstartTime, endTime time.Time, limit int) ([]*models.Trace, error)\n\t\n\t// GetTracesByTimeRange returns traces that started within the given\n\t// time range, ordered by start time (descending). Useful for incident\n\t// investigation when service is unknown.\n\tGetTracesByTimeRange(ctx context.Context,\n\t\tstartTime, endTime time.Time, limit int) ([]*models.Trace, error)\n\t\n\t// GetServices returns a list of all services that have emitted spans,\n\t// along with their observed operations. This is used for the service map\n\t// and for configuration UI.\n\tGetServices(ctx context.Context) ([]*models.Service, error)\n\t\n\t// Close gracefully shuts down the storage connection and releases resources.\n\tClose() error\n}\n```\n\nFile: `internal/storage/inmemory/inmemory.go` (Skeleton)\n```go\npackage inmemory\n\nimport (\n\t\"context\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\t\n\t\"github.com/your-org/apm-tracing/internal/models\"\n)\n\n// InMemoryStorage is a simple in-memory implementation of storage.Storage.\n// Useful for development, testing, and small-scale deployments.\n// NOT suitable for production due to memory limits and lack of durability.\ntype InMemoryStorage struct {\n\tmu sync.RWMutex\n\t\n\t// Primary storage: traceID -> list of spans\n\ttraces map[string][]models.Span\n\t\n\t// Secondary index: serviceName -> set of traceIDs\n\tserviceIndex map[string]map[string]struct{}\n\t\n\t// Time index: startTime bucket -> list of traceIDs\n\ttimeIndex map[time.Time][]string\n}\n\nfunc NewInMemoryStorage() *InMemoryStorage {\n\treturn &InMemoryStorage{\n\t\ttraces:       make(map[string][]models.Span),\n\t\tserviceIndex: make(map[string]map[string]struct{}),\n\t\ttimeIndex:    make(map[time.Time][]string),\n\t}\n}\n\nfunc (s *InMemoryStorage) StoreSpan(ctx context.Context, span models.Span) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\t\n\t// TODO: Implement step-by-step:\n\t// 1. Append span to s.traces[span.TraceID] slice\n\t// 2. Update service index: add span.TraceID to s.serviceIndex[span.ServiceName]\n\t//    (create map/set if needed)\n\t// 3. Update time index: bucket span.StartTime by hour (truncate to hour)\n\t//    and add span.TraceID to s.timeIndex[bucketTime]\n\t// 4. Return nil on success, error on failure\n\t\n\treturn nil\n}\n\nfunc (s *InMemoryStorage) GetTraceByID(ctx context.Context, traceID string) (*models.Trace, error) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\t\n\t// TODO: Implement:\n\t// 1. Look up spans := s.traces[traceID]\n\t// 2. If len(spans) == 0, return nil, nil (trace not found)\n\t// 3. Use models.NewTraceFromSpans(spans) to create trace view\n\t// 4. Return trace, nil\n\t\n\treturn nil, nil\n}\n\n// Additional method implementations follow similar pattern...\n```\n\n**Language-Specific Hints:**\n\n1. **Time Handling**: Use `time.Time` for timestamps throughout. For nanosecond precision, ensure your database driver supports it (Cassandra's `timestamp` type supports microseconds). For bucketing in indexes, use `t.Truncate(time.Hour)` to create hourly buckets.\n\n2. **Concurrency**: The in-memory implementation uses `sync.RWMutex` for concurrent access. For production implementations, the database handles concurrency.\n\n3. **ID Generation**: Use `crypto/rand` for generating random `TraceID` and `SpanID` values in the SDK. Example: `hex.EncodeToString(randomBytes(16))` for 128-bit trace IDs.\n\n4. **Memory Management**: The in-memory storage will grow unbounded. In production, you'd use a real database. For testing, consider adding a maximum spans limit and LRU eviction.\n\n**Milestone Checkpoint (Trace Collection - Data Model):**\n\nAfter implementing the data model and basic in-memory storage:\n\n1. **Verify Model Definitions**: Create a simple test that instantiates each type with sample data:\n   ```go\n   func TestDataModel() {\n       span := models.Span{\n           SpanID:      \"abc123\",\n           TraceID:     \"trace-1\",\n           ParentSpanID: \"\",\n           Name:        \"GET /api/users\",\n           ServiceName: \"user-service\",\n           StartTime:   time.Now(),\n           Duration:    150 * time.Millisecond,\n           Attributes:  map[string]string{\"http.method\": \"GET\"},\n           Status:      models.SpanStatus{Code: 1},\n       }\n       // Verify fields are accessible\n   }\n   ```\n\n2. **Test Storage Interface**: Implement the `InMemoryStorage` methods and verify:\n   ```bash\n   go test ./internal/storage/inmemory/... -v\n   ```\n   Expected: Tests should pass, demonstrating span storage and retrieval.\n\n3. **Verify Trace Assembly**: Write a test that stores multiple spans with the same `TraceID` but different `SpanID`s, then retrieves the trace and verifies all spans are present and the `StartTime`/`EndTime` are correctly calculated.\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"Span disappears after storage\" | Concurrent map write panic or incorrect locking | Add debug logging before and after storage operations. Run with `-race` flag. | Ensure proper use of `sync.RWMutex` locks in `InMemoryStorage`. |\n| \"Trace shows incorrect time range\" | `StartTime`/`EndTime` calculation logic error | Print each span's start and end times during trace assembly. | Verify `NewTraceFromSpans` correctly computes min/max across all spans. |\n| \"Service index grows without bound\" | Not cleaning up old trace IDs from index when traces expire | Check index sizes over time. Add metrics for index entries. | Implement TTL or cleanup routine that removes old entries from indexes. |\n| \"High memory usage in tests\" | In-memory storage retaining all spans indefinitely | Monitor memory with `runtime.ReadMemStats`. | Add maximum capacity to `InMemoryStorage` with LRU eviction for testing. |\n\n\n> **Milestone(s):** This section corresponds to Milestone 1: Trace Collection, which forms the foundation of the entire APM Tracing System.\n\n## 5. Component Design: Trace Collection (Milestone 1)\n\nThe **Trace Collector** is the foundational component of our APM system — it's the \"front door\" through which all telemetry data enters. This component is responsible for receiving, validating, processing, and storing spans that together form distributed traces. Its design directly impacts the system's reliability, scalability, and correctness.\n\n### Mental Model: The Package Sorting Hub\n\nImagine a massive international package sorting facility (like an airport cargo terminal). Thousands of packages (spans) arrive every second via different delivery vehicles (applications). Each package has a destination address (trace ID) and may be part of a larger shipment (trace). The facility must:\n\n1. **Accept deliveries** from all carriers (HTTP, gRPC) without blocking traffic\n2. **Inspect each package** for damage or incorrect labeling (validation)\n3. **Sort packages by destination** (grouping spans by trace ID)\n4. **Hold incomplete shipments** until all packages arrive (buffering)\n5. **Store completed shipments** in the warehouse (persistent storage)\n6. **Maintain an index** of what's stored and where (secondary indexing)\n\nThe challenge is that packages from the same shipment don't arrive together — some come hours later. The facility must have enough temporary storage (buffers) to hold incomplete shipments, but not so much that it runs out of space. It also needs efficient systems to quickly locate all packages from a specific shipment when requested.\n\n### Collector Interface and API\n\nThe Collector exposes well-defined endpoints for receiving telemetry data. We support both HTTP (for simplicity and wide compatibility) and gRPC (for high-performance streaming) protocols, following the **OpenTelemetry Protocol (OTLP)** standard.\n\n#### HTTP Endpoint Specification\n\n| Method | Path | Content-Type | Request Body | Response | Description |\n|--------|------|--------------|--------------|----------|-------------|\n| POST | `/v1/traces` | `application/json` | JSON array of spans | `202 Accepted` (or error) | Accepts batch of spans in JSON format |\n| POST | `/v1/traces` | `application/x-protobuf` | OTLP protobuf binary | `202 Accepted` (or error) | Accepts spans in binary protobuf format |\n| GET | `/health` | - | - | `200 OK` with status JSON | Health check endpoint |\n\n#### gRPC Service Specification\n\n| Service Method | Request Type | Response Type | Description |\n|----------------|--------------|---------------|-------------|\n| `Export` | `ExportTraceServiceRequest` | `ExportTraceServiceResponse` | Stream spans to collector via gRPC |\n| `HealthCheck` | `HealthCheckRequest` | `HealthCheckResponse` | Service health status |\n\n#### Request/Response Format Details\n\nThe collector accepts spans in the **OpenTelemetry** format. Below is the JSON representation structure (simplified for clarity):\n\n**Span JSON Format:**\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `traceId` | string (hex) | Yes | 32-character hex string identifying the trace |\n| `spanId` | string (hex) | Yes | 16-character hex string identifying this span |\n| `parentSpanId` | string (hex) | No | Parent span ID (empty for root spans) |\n| `name` | string | Yes | Operation name (e.g., \"GET /api/users\") |\n| `kind` | integer | Yes | Span kind (1=CLIENT, 2=SERVER, etc.) |\n| `startTimeUnixNano` | integer | Yes | Start timestamp in nanoseconds |\n| `endTimeUnixNano` | integer | Yes | End timestamp in nanoseconds |\n| `attributes` | array of key-value | No | Custom metadata (e.g., {\"http.method\": \"GET\"}) |\n| `events` | array | No | Timed events within the span |\n| `status` | object | No | Status code and optional message |\n\n**Response Codes:**\n| Status Code | Meaning | When Used |\n|-------------|---------|-----------|\n| 202 Accepted | Successfully accepted | All spans validated and queued |\n| 400 Bad Request | Malformed request | Invalid JSON or missing required fields |\n| 429 Too Many Requests | Rate limit exceeded | Client exceeds configured ingestion rate |\n| 503 Service Unavailable | Collector overloaded | Backpressure applied, client should retry |\n\n#### Expected Behavior and SLAs\n\nThe collector must provide these guarantees:\n1. **Acknowledgment within 100ms** for 95% of requests (P95 latency)\n2. **No data loss** under normal operating conditions\n3. **Graceful degradation** when overloaded (apply backpressure instead of crashing)\n4. **Span validation** to reject malformed data before processing\n5. **Trace completeness** — all spans of a sampled trace are stored together\n\n### Internal Behavior: Ingestion Pipeline\n\nWhen a span arrives at the collector, it goes through a multi-stage pipeline. Each stage transforms, filters, or routes the data. This follows the **pipes and filters** architectural pattern, where each stage is independent and can be scaled separately.\n\n![Sequence: Trace Ingestion and Processing](./diagrams/ingestion-sequence.svg)\n\n#### Pipeline Stages (Step-by-Step Algorithm)\n\n1. **Receipt and Deserialization**\n   - Accept connection from client (HTTP or gRPC)\n   - Read request body and parse based on content-type (JSON or protobuf)\n   - Validate basic structure: required fields present, correct data types\n   - Convert to internal `Span` struct format for uniform processing\n\n2. **Validation and Sanitization**\n   - Validate trace ID and span ID formats (hexadecimal, correct length)\n   - Verify timestamps: `endTime` ≥ `startTime`, timestamps not in future\n   - Sanitize attributes: truncate overly long values, remove sensitive data\n   - Check for mandatory OpenTelemetry semantic conventions\n\n3. **Sampling Decision (Head-Based)**\n   - Compute hash of trace ID (consistent hashing)\n   - Apply sampling rate based on service name and operation\n   - If trace is rejected, drop all spans immediately (no further processing)\n   - Record sampling decision for later reference\n\n4. **Buffering and Grouping**\n   - Add span to in-memory buffer keyed by trace ID\n   - Check if trace is now \"complete\" (all expected spans received)\n   - For incomplete traces, start/refresh timeout timer\n   - For complete traces, move to next stage immediately\n\n5. **Trace Assembly**\n   - Retrieve all spans for the trace from buffer\n   - Build parent-child relationships using span ID and parent span ID\n   - Calculate trace-level statistics: start time, end time, total duration\n   - Create `Trace` struct containing all spans in chronological order\n\n6. **Storage Persistence**\n   - Write all spans of the trace to persistent storage (bulk write)\n   - Create secondary indexes for efficient querying\n   - Update service registry with new service/operation names\n   - Notify downstream components (service map, analytics)\n\n7. **Buffer Cleanup**\n   - Remove trace from in-memory buffer after successful persistence\n   - For timed-out traces (incomplete after window), write partial trace with metadata\n   - Report metrics: buffer size, trace completion rate, timeout count\n\n#### Trace Completion Detection\n\nA trace is considered \"complete\" when either:\n1. All expected spans have arrived (based on span count metadata if provided)\n2. A configurable timeout (default: 5 minutes) has elapsed since the first span\n3. An explicit \"trace end\" marker span is received\n\nThe collector uses a **watermark-based approach**: when the latest timestamp among all received spans exceeds `current_time - timeout_window`, and no new spans have arrived for that period, the trace is considered complete.\n\n### ADR: Buffering Strategy for Late-Arriving Spans\n\n> **Decision: Hybrid Buffering with Write-Ahead Logging**\n>\n> - **Context**: Spans from the same trace arrive out of order and potentially hours apart due to network delays, retries, or slow services. The collector must temporarily store incomplete traces without risking data loss if the collector crashes.\n> - **Options Considered**:\n>   1. **Pure In-Memory Buffer**: Keep all incomplete traces in RAM with periodic snapshots to disk\n>   2. **Write-Ahead Log (WAL) + Memory Index**: Write all spans immediately to disk log, with in-memory index of incomplete traces\n>   3. **External Buffer Service**: Offload buffering to external system (Redis, Kafka)\n> - **Decision**: Hybrid approach: spans written to WAL immediately, with in-memory index for fast trace assembly\n> - **Rationale**: \n>   - **Durability**: WAL ensures no data loss on collector crash/restart\n>   - **Performance**: In-memory index enables fast trace completion checks\n>   - **Simplicity**: No external dependencies for core functionality\n>   - **Cost-effective**: Disk storage cheaper than RAM for large buffers\n> - **Consequences**:\n>   - Added disk I/O for every span (mitigated by batching writes)\n>   - Need for WAL compaction to remove completed traces\n>   - Slightly higher latency per span but better overall reliability\n\n**Options Comparison Table:**\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Pure In-Memory Buffer | - Fastest performance<br>- Simple implementation | - Data loss on crash<br>- Memory grows unbounded<br>- Difficult to scale | No |\n| WAL + Memory Index | - Durable (crash-safe)<br>- Memory usage predictable<br>- Easier to scale horizontally | - Disk I/O overhead<br>- Requires WAL management<br>- More complex implementation | **Yes** |\n| External Buffer Service | - Offloads resource management<br>- Easier to scale independently<br>- Built-in replication | - External dependency<br>- Network latency<br>- Additional operational complexity | No |\n\n#### WAL Implementation Details\n\nThe Write-Ahead Log is implemented as a set of append-only files:\n\n1. **Span Log**: Each incoming span is serialized and appended with metadata:\n   - Timestamp of receipt\n   - Trace ID and span ID\n   - Processing status (pending, processed)\n\n2. **Index File**: In-memory map from trace ID to:\n   - List of span offsets in the WAL\n   - Timestamp of first span\n   - Current state (incomplete, assembling, complete)\n\n3. **Cleanup Process**: Background goroutine that:\n   - Periodically scans for completed traces older than retention period\n   - Removes their entries from the index\n   - Marks corresponding WAL segments as reclaimable\n\n4. **Recovery Process**: On collector restart:\n   - Read WAL from last checkpoint\n   - Rebuild in-memory index\n   - Resume processing incomplete traces\n\n### Common Pitfalls in Trace Collection\n\n#### ⚠️ **Pitfall 1: Unbounded Memory Growth from Incomplete Traces**\n- **Description**: Holding all incomplete traces in memory indefinitely causes OOM crashes\n- **Why It's Wrong**: Memory is finite; slow or stuck traces accumulate forever\n- **Fix**: Implement **time-based eviction** with disk spillover:\n  1. Set maximum buffer size (e.g., 100,000 traces)\n  2. Move oldest incomplete traces to disk when limit reached\n  3. Implement TTL (e.g., 24 hours) after which partial traces are discarded with warning\n\n#### ⚠️ **Pitfall 2: Clock Skew Creates Incorrect Span Ordering**\n- **Description**: Spans from services with misconfigured clocks appear in wrong chronological order\n- **Why It's Wrong**: Trace visualization shows impossible sequences (child before parent)\n- **Fix**: Apply **clock skew correction**:\n  1. Record collector receipt timestamp for each span\n  2. Compare service timestamp vs. receipt timestamp\n  3. Apply offset correction if discrepancy exceeds threshold (e.g., 5 seconds)\n  4. Log warnings for services with persistent clock issues\n\n#### ⚠️ **Pitfall 3: Incorrect Parent-Child Linking**\n- **Description**: Spans with invalid parentSpanID create orphaned spans or incorrect hierarchies\n- **Why It's Wrong**: Breaks trace continuity, makes debugging impossible\n- **Fix**: Implement **strict validation and repair**:\n  1. Validate parentSpanID format (hexadecimal, correct length)\n  2. Verify parent span exists in same trace before linking\n  3. For invalid parents, mark span as \"root\" with error attribute\n  4. Provide metrics on linking failure rate per service\n\n#### ⚠️ **Pitfall 4: Head-of-Line Blocking in Pipeline**\n- **Description**: Slow processing of one trace blocks all subsequent traces\n- **Why It's Wrong**: Reduces overall throughput, causes request timeouts\n- **Fix**: Use **bounded worker pools with per-trace isolation**:\n  1. Each trace processed by dedicated worker\n  2. Workers can't block each other\n  3. Slow traces don't affect unrelated traces\n  4. Implement circuit breakers for pathological traces\n\n#### ⚠️ **Pitfall 5: Lost Spans from Trace Sampling Inconsistency**\n- **Description**: Different spans from same trace get different sampling decisions\n- **Why It's Wrong**: Creates incomplete traces missing critical spans\n- **Fix**: Implement **consistent sampling with decision caching**:\n  1. Make sampling decision based on trace ID (not span ID)\n  2. Cache decision for trace TTL (e.g., 1 hour)\n  3. All subsequent spans from same trace use cached decision\n  4. Reject spans if decision cache is full (fail-safe to \"keep\")\n\n### Implementation Guidance for Trace Collection\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| HTTP Server | Go's `net/http` with JSON | `gin` or `chi` router with middleware |\n| gRPC Server | Standard `google.golang.org/grpc` | With interceptors for auth/telemetry |\n| Protobuf | `google.golang.org/protobuf` | With code generation via `protoc` |\n| WAL Implementation | Custom file-based append log | Use `github.com/tidwall/wal` library |\n| In-Memory Store | `sync.Map` for concurrent access | Sharded maps with `github.com/orcaman/concurrent-map` |\n| Serialization | JSON for readability | Protocol Buffers for performance |\n| Metrics | Prometheus client library | OpenTelemetry metrics SDK |\n\n#### B. Recommended File/Module Structure\n\n```\nproject-root/\n├── cmd/\n│   └── collector/\n│       └── main.go                 # Collector entry point\n├── internal/\n│   ├── collector/\n│   │   ├── api/                    # API layer\n│   │   │   ├── http/\n│   │   │   │   ├── server.go      # HTTP server implementation\n│   │   │   │   └── handlers.go    # Request handlers\n│   │   │   └── grpc/\n│   │   │       ├── server.go      # gRPC server implementation\n│   │   │       └── service.go     # gRPC service definition\n│   │   ├── pipeline/               # Processing pipeline\n│   │   │   ├── pipeline.go        # Pipeline orchestration\n│   │   │   ├── stages/            # Individual pipeline stages\n│   │   │   │   ├── receiver.go    # Stage 1: Receipt\n│   │   │   │   ├── validator.go   # Stage 2: Validation\n│   │   │   │   ├── sampler.go     # Stage 3: Sampling\n│   │   │   │   ├── buffer.go      # Stage 4: Buffering\n│   │   │   │   ├── assembler.go   # Stage 5: Assembly\n│   │   │   │   └── persister.go   # Stage 6: Persistence\n│   │   │   └── queue.go           # Inter-stage queues\n│   │   ├── buffer/                # Buffering subsystem\n│   │   │   ├── wal/\n│   │   │   │   ├── writer.go      # WAL write operations\n│   │   │   │   ├── reader.go      # WAL read operations\n│   │   │   │   ├── index.go       # In-memory index\n│   │   │   │   └── cleaner.go     # WAL cleanup\n│   │   │   └── memory/\n│   │   │       ├── manager.go     # Buffer manager\n│   │   │       ├── eviction.go    # Eviction policies\n│   │   │       └── metrics.go     # Buffer metrics\n│   │   └── storage/               # Storage abstraction\n│   │       ├── interface.go       # Storage interface\n│   │       ├── memory_store.go    # In-memory implementation (dev)\n│   │       └── cassandra_store.go # Cassandra implementation\n├── pkg/\n│   ├── models/                    # Data models\n│   │   ├── trace.go               # Trace struct\n│   │   ├── span.go                # Span struct\n│   │   └── service.go             # Service struct\n│   └── sampling/                  # Sampling logic\n│       ├── sampler.go             # Sampler interface\n│       └── consistent_hash.go     # Consistent hash sampler\n└── proto/                         # Protobuf definitions\n    └── otlp/                      # OpenTelemetry proto files\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete WAL Writer Implementation:**\n\n```go\n// internal/collector/buffer/wal/writer.go\npackage wal\n\nimport (\n    \"encoding/binary\"\n    \"os\"\n    \"sync\"\n    \"time\"\n)\n\ntype WALWriter struct {\n    file     *os.File\n    mu       sync.Mutex\n    filePath string\n    offset   int64\n}\n\n// NewWALWriter creates a new WAL writer for the given file path\nfunc NewWALWriter(filePath string) (*WALWriter, error) {\n    file, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n    if err != nil {\n        return nil, err\n    }\n    \n    stat, err := file.Stat()\n    if err != nil {\n        file.Close()\n        return nil, err\n    }\n    \n    return &WALWriter{\n        file:     file,\n        filePath: filePath,\n        offset:   stat.Size(),\n    }, nil\n}\n\n// Append writes a record to the WAL and returns its offset\nfunc (w *WALWriter) Append(data []byte) (int64, error) {\n    w.mu.Lock()\n    defer w.mu.Unlock()\n    \n    // Write length prefix (8 bytes)\n    length := uint64(len(data))\n    if err := binary.Write(w.file, binary.LittleEndian, length); err != nil {\n        return -1, err\n    }\n    \n    // Write the actual data\n    if _, err := w.file.Write(data); err != nil {\n        return -1, err\n    }\n    \n    // Sync to disk for durability\n    if err := w.file.Sync(); err != nil {\n        return -1, err\n    }\n    \n    currentOffset := w.offset\n    w.offset += 8 + int64(length) // 8 bytes for length prefix\n    \n    return currentOffset, nil\n}\n\n// Rotate creates a new WAL file and returns the old file for cleanup\nfunc (w *WALWriter) Rotate() (*os.File, error) {\n    w.mu.Lock()\n    defer w.mu.Unlock()\n    \n    oldFile := w.file\n    \n    // Create new file with timestamp\n    newFilePath := w.filePath + \".\" + time.Now().Format(\"20060102_150405\")\n    newFile, err := os.OpenFile(newFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n    if err != nil {\n        return nil, err\n    }\n    \n    w.file = newFile\n    w.offset = 0\n    w.filePath = newFilePath\n    \n    return oldFile, nil\n}\n\n// Close gracefully closes the WAL file\nfunc (w *WALWriter) Close() error {\n    w.mu.Lock()\n    defer w.mu.Unlock()\n    \n    return w.file.Close()\n}\n```\n\n**HTTP Server with Health Check:**\n\n```go\n// internal/collector/api/http/server.go\npackage http\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n)\n\ntype Server struct {\n    server *http.Server\n    port   int\n}\n\nfunc NewServer(port int, handler http.Handler) *Server {\n    return &Server{\n        server: &http.Server{\n            Addr:         fmt.Sprintf(\":%d\", port),\n            Handler:      handler,\n            ReadTimeout:  10 * time.Second,\n            WriteTimeout: 10 * time.Second,\n        },\n        port: port,\n    }\n}\n\nfunc (s *Server) Start() error {\n    fmt.Printf(\"Starting HTTP server on port %d\\n\", s.port)\n    return s.server.ListenAndServe()\n}\n\nfunc (s *Server) Shutdown(ctx context.Context) error {\n    fmt.Println(\"Shutting down HTTP server...\")\n    return s.server.Shutdown(ctx)\n}\n\n// HealthHandler provides health check endpoint\nfunc HealthHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusOK)\n    fmt.Fprintf(w, `{\"status\": \"healthy\", \"timestamp\": \"%s\"}`, time.Now().UTC().Format(time.RFC3339))\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**Trace Assembler (Core Algorithm):**\n\n```go\n// internal/collector/pipeline/stages/assembler.go\npackage stages\n\nimport (\n    \"context\"\n    \"sort\"\n    \"time\"\n    \n    \"github.com/your-org/apm-tracing/pkg/models\"\n)\n\n// TraceAssembler takes a slice of spans and constructs a complete Trace\ntype TraceAssembler struct {\n    maxTraceDuration time.Duration\n}\n\n// NewTraceAssembler creates a new trace assembler with the given configuration\nfunc NewTraceAssembler(maxTraceDuration time.Duration) *TraceAssembler {\n    return &TraceAssembler{\n        maxTraceDuration: maxTraceDuration,\n    }\n}\n\n// AssembleTrace takes all spans for a trace and builds the hierarchical structure\nfunc (ta *TraceAssembler) AssembleTrace(ctx context.Context, spans []models.Span) (*models.Trace, error) {\n    // TODO 1: Validate that all spans have the same trace ID\n    //   - If not, return error \"spans belong to different traces\"\n    \n    // TODO 2: Sort spans by start time (ascending)\n    //   - Use sort.Slice with spans[i].StartTime comparison\n    \n    // TODO 3: Build a map from span ID to span for fast lookup\n    //   - Create map[string]*models.Span\n    //   - Store pointer to each span (not copy)\n    \n    // TODO 4: Identify root span(s) - spans with empty or non-existent parentSpanID\n    //   - For each span, check if parentSpanID exists in the map\n    //   - If not, this is a root span (could be multiple in case of errors)\n    \n    // TODO 5: Build parent-child relationships\n    //   - For each non-root span, find its parent in the map\n    //   - If parent found, establish relationship (you may need to add Children field to Span)\n    //   - If parent not found, mark as \"orphaned\" with warning attribute\n    \n    // TODO 6: Calculate trace-level statistics\n    //   - Find earliest start time among all spans\n    //   - Find latest end time (start + duration)\n    //   - Verify total duration doesn't exceed maxTraceDuration\n    //   - Count spans by status code (success, error)\n    \n    // TODO 7: Create and return the Trace object\n    //   - Initialize models.Trace with TraceID from first span\n    //   - Set Spans field to the sorted slice\n    //   - Set StartTime and EndTime to calculated values\n    //   - Return pointer to Trace\n    \n    return nil, nil // Remove this line after implementation\n}\n\n// IsTraceComplete checks if we have all spans for a trace\nfunc (ta *TraceAssembler) IsTraceComplete(ctx context.Context, traceID string, spans []models.Span, firstSpanTime time.Time) bool {\n    // TODO 1: Check if we have a \"trace end\" marker span\n    //   - Look for span with attribute \"trace.end\" = true\n    \n    // TODO 2: Check timeout - if first span is older than maxTraceDuration\n    //   - If time.Since(firstSpanTime) > ta.maxTraceDuration, return true\n    \n    // TODO 3: For advanced implementation: check expected span count\n    //   - Some tracing systems include \"total_spans\" in root span\n    //   - Compare len(spans) with expected count\n    \n    // TODO 4: Apply watermark algorithm\n    //   - Find latest timestamp among all spans\n    //   - If currentTime - latestTimestamp > completionWindow, return true\n    \n    return false // Remove this line after implementation\n}\n```\n\n**Buffer Manager with Eviction Policy:**\n\n```go\n// internal/collector/buffer/memory/manager.go\npackage memory\n\nimport (\n    \"context\"\n    \"time\"\n    \n    \"github.com/your-org/apm-tracing/pkg/models\"\n)\n\ntype BufferManager struct {\n    maxSize        int\n    ttl            time.Duration\n    traces         map[string]*TraceBuffer\n    accessTimes    map[string]time.Time\n    evictionPolicy string // \"lru\", \"ttl\", \"fifo\"\n}\n\ntype TraceBuffer struct {\n    spans      []models.Span\n    firstSeen  time.Time\n    lastSeen   time.Time\n    isComplete bool\n}\n\nfunc NewBufferManager(maxSize int, ttl time.Duration, evictionPolicy string) *BufferManager {\n    return &BufferManager{\n        maxSize:        maxSize,\n        ttl:            ttl,\n        traces:         make(map[string]*TraceBuffer),\n        accessTimes:    make(map[string]time.Time),\n        evictionPolicy: evictionPolicy,\n    }\n}\n\n// AddSpan adds a span to the buffer for its trace\nfunc (bm *BufferManager) AddSpan(ctx context.Context, span models.Span) error {\n    // TODO 1: Get or create TraceBuffer for this trace ID\n    //   - Check if traceID exists in bm.traces\n    //   - If not, create new TraceBuffer with firstSeen = time.Now()\n    \n    // TODO 2: Add span to the buffer's spans slice\n    //   - Append the span\n    //   - Update lastSeen to current time\n    \n    // TODO 3: Update access times for eviction tracking\n    //   - Set bm.accessTimes[traceID] = time.Now()\n    \n    // TODO 4: Check if buffer is full (len(bm.traces) >= bm.maxSize)\n    //   - If full, trigger eviction (call bm.evict(ctx))\n    \n    // TODO 5: Check TTL for this trace\n    //   - If time.Since(firstSeen) > bm.ttl, mark for eviction\n    \n    return nil // Remove this line after implementation\n}\n\n// evict removes traces based on the configured eviction policy\nfunc (bm *BufferManager) evict(ctx context.Context) (int, error) {\n    // TODO 1: Based on bm.evictionPolicy, select traces to evict\n    //   - If \"lru\": find trace with oldest access time\n    //   - If \"ttl\": find traces where time.Since(firstSeen) > ttl\n    //   - If \"fifo\": find trace with oldest firstSeen\n    \n    // TODO 2: For selected traces:\n    //   - Write incomplete traces to disk (partial storage)\n    //   - Remove from bm.traces map\n    //   - Remove from bm.accessTimes map\n    \n    // TODO 3: Return count of evicted traces\n    \n    return 0, nil // Remove this line after implementation\n}\n\n// GetTraceSpans returns all spans for a given trace ID\nfunc (bm *BufferManager) GetTraceSpans(ctx context.Context, traceID string) ([]models.Span, error) {\n    // TODO 1: Look up trace in bm.traces\n    //   - Return error if not found\n    \n    // TODO 2: Update access time (for LRU policy)\n    //   - bm.accessTimes[traceID] = time.Now()\n    \n    // TODO 3: Return copy of spans slice (not the original)\n    \n    return nil, nil // Remove this line after implementation\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **Concurrency in Go**: Use `sync.RWMutex` for protecting the buffer index. Readers (span lookups) use `RLock()`, writers (adding spans) use `Lock()`.\n\n2. **Context Propagation**: Always pass `context.Context` through the pipeline. Use `ctx.Value()` for request-scoped data like request ID, and check `ctx.Err()` for cancellation.\n\n3. **Error Handling**: Use Go 1.13+ error wrapping: `fmt.Errorf(\"failed to write span: %w\", err)`. Create sentinel errors for expected failures (e.g., `ErrTraceNotFound`).\n\n4. **Performance**: Pre-allocate slices with expected capacity: `spans := make([]models.Span, 0, estimatedSpanCount)` to avoid repeated reallocations.\n\n5. **Metrics**: Use Prometheus counters and histograms:\n   ```go\n   spansReceived := prometheus.NewCounterVec(...)\n   processingDuration := prometheus.NewHistogramVec(...)\n   ```\n\n6. **Graceful Shutdown**: Use `signal.NotifyContext` to handle SIGTERM:\n   ```go\n   ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)\n   defer stop()\n   ```\n\n#### F. Milestone Checkpoint\n\n**To verify Trace Collection is working correctly:**\n\n1. **Start the collector**:\n   ```\n   go run cmd/collector/main.go --config config/local.yaml\n   ```\n   Expected output: `Starting collector on :4317 (gRPC) and :4318 (HTTP)`\n\n2. **Send test spans via HTTP**:\n   ```bash\n   curl -X POST http://localhost:4318/v1/traces \\\n     -H \"Content-Type: application/json\" \\\n     -d '[{\n       \"traceId\": \"4bf92f3577b34da6a3ce929d0e0e4736\",\n       \"spanId\": \"00f067aa0ba902b7\",\n       \"name\": \"/api/users\",\n       \"kind\": 2,\n       \"startTimeUnixNano\": 1505855794194000,\n       \"endTimeUnixNano\": 1505855794195000,\n       \"attributes\": [{\"key\": \"http.method\", \"value\": {\"stringValue\": \"GET\"}}]\n     }]'\n   ```\n   Expected response: `HTTP/2 202 Accepted`\n\n3. **Query stored trace**:\n   ```bash\n   curl http://localhost:4318/api/traces/4bf92f3577b34da6a3ce929d0e0e4736\n   ```\n   Should return the complete trace with all spans.\n\n4. **Run validation tests**:\n   ```\n   go test ./internal/collector/pipeline/stages/... -v\n   ```\n   All tests should pass, including:\n   - Test span validation rejects malformed data\n   - Test trace assembly builds correct hierarchy\n   - Test buffer eviction works as expected\n\n5. **Check metrics** (if Prometheus endpoint enabled):\n   ```\n   curl http://localhost:9090/metrics | grep collector_\n   ```\n   Should see metrics like `collector_spans_received_total`, `collector_buffer_size`.\n\n**Signs something is wrong:**\n- **Spans not linking**: Check parentSpanID format and validation logic\n- **High memory usage**: Check buffer eviction is working, inspect with `go tool pprof`\n- **Slow ingestion**: Check for blocking operations in pipeline, use Go's race detector\n- **Data loss on restart**: Verify WAL is being fsync'd and recovery reads all records\n\n---\n\n\n## 6. Component Design: Service Map (Milestone 2)\n\n> **Milestone(s):** This section corresponds to Milestone 2: Service Map, which analyzes trace data to build and visualize dynamic service dependency graphs.\n\n### Mental Model: The Social Network of Services\n\nThink of your distributed system as a **social network of services**, where each service is a person and each service call is a friendship interaction. The service map is the \"friend graph\" that shows who talks to whom, how often they communicate, and the quality of their relationships. Just as you could learn about social dynamics by observing who messages whom and how frequently, we learn about system architecture by observing which services call each other and with what latency and success rates.\n\nThis mental model helps clarify several key concepts:\n\n1. **Nodes as services**: Each service is a node in the graph, similar to each person in a social network\n2. **Edges as relationships**: A call from Service A to Service B creates a directed edge (A→B), similar to A sending a message to B\n3. **Edge weight as interaction frequency**: The thickness of the edge represents call volume, just as thicker lines between people might represent more frequent communication\n4. **Edge color as relationship health**: Red edges indicate high error rates (problematic relationships), while green edges indicate healthy interactions\n5. **Clusters as architectural patterns**: Services that frequently call each other form clusters, revealing microservice boundaries or bounded contexts\n\nJust as social networks evolve over time with new friendships forming and old ones fading, your service map must detect and visualize topology changes as services are added, removed, or their communication patterns change.\n\n### Algorithm: Building the Graph from Spans\n\nBuilding an accurate service map requires analyzing spans to extract service call relationships, then aggregating metrics over those relationships. The algorithm operates in three phases: **extraction**, **aggregation**, and **refresh**. The following flowchart illustrates this process:\n\n![Flowchart: Service Map Construction](./diagrams/servicemap-flowchart.svg)\n\n#### Phase 1: Edge Extraction from Individual Spans\n\nFor each incoming span, we extract potential service call edges by examining parent-child relationships:\n\n1. **Filter relevant spans**: Only consider spans with a non-empty `ParentSpanID` (excluding root spans) and with `ServiceName` populated\n2. **Retrieve parent span**: Using the span's `TraceID` and `ParentSpanID`, fetch the parent span from storage or buffer\n3. **Identify caller-callee relationship**: \n   - **Caller**: The `ServiceName` of the parent span\n   - **Callee**: The `ServiceName` of the child span\n4. **Validate edge**: Ensure caller ≠ callee (ignore same-service spans for the service map, as they represent internal operations)\n5. **Extract operation context**: Record the `Name` field (operation) of both spans for detailed metrics\n6. **Capture timing information**: Calculate the **inter-service latency** as: `child.StartTime - parent.StartTime` (adjusting for any clock skew using techniques from Milestone 1)\n\nThis phase produces raw edges with the following structure:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `CallerService` | `string` | Name of the service making the call |\n| `CalleeService` | `string` | Name of the service receiving the call |\n| `CallerOperation` | `string` | Operation/endpoint name on the caller side |\n| `CalleeOperation` | `string` | Operation/endpoint name on the callee side |\n| `TraceID` | `string` | Identifier of the trace containing this call |\n| `SpanID` | `string` | Identifier of the child span (the call) |\n| `StartTime` | `time.Time` | When the call began |\n| `Duration` | `time.Duration` | How long the call took |\n| `IsError` | `bool` | Whether the span status indicates an error (based on `SpanStatus.Code`) |\n| `Attributes` | `map[string]string` | Additional attributes that might affect edge grouping |\n\n#### Phase 2: Metric Aggregation over Time Windows\n\nInstead of tracking every individual call, we aggregate metrics over configurable time windows (e.g., 1 minute, 5 minutes, 1 hour) to create summarized views:\n\n1. **Group edges by (caller, callee) pair**: All calls from Service A to Service B within the same time window are aggregated together\n2. **Calculate aggregated metrics** for each edge:\n   - **Total Calls**: Count of all calls in the window\n   - **Error Count**: Count of calls where `IsError = true`\n   - **Error Rate**: `Error Count / Total Calls`\n   - **Latency Percentiles**: p50, p95, p99 latencies calculated using the t-digest algorithm (see Milestone 4)\n   - **Total Bytes Transferred** (if available from span attributes)\n3. **Maintain rolling windows**: Keep multiple time windows (current, previous) to enable trend analysis (e.g., \"error rate increased by 15% compared to last hour\")\n4. **Apply dimension reduction**: Optionally group by operation patterns if there are too many distinct operations causing high cardinality\n\nThe aggregated edge structure becomes:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `CallerService` | `string` | Name of the service making the call |\n| `CalleeService` | `string` | Name of the service receiving the call |\n| `WindowStart` | `time.Time` | Start of the aggregation window |\n| `WindowEnd` | `time.Time` | End of the aggregation window |\n| `TotalCalls` | `int64` | Number of calls in this window |\n| `ErrorCount` | `int64` | Number of failed calls |\n| `ErrorRate` | `float64` | `ErrorCount / TotalCalls` |\n| `P50Latency` | `time.Duration` | 50th percentile latency |\n| `P95Latency` | `time.Duration` | 95th percentile latency |\n| `P99Latency` | `time.Duration` | 99th percentile latency |\n| `SampleTraceIDs` | `[]string` | A small sample of trace IDs (e.g., 5) representing this edge for drill-down |\n\n#### Phase 3: Graph Construction and Topology Detection\n\nWith aggregated edges, we build the service dependency graph:\n\n1. **Create graph nodes**: Each unique service name becomes a node in the graph\n2. **Create directed edges**: Each unique (caller, callee) pair becomes a directed edge\n3. **Apply edge weights**: Visual thickness corresponds to `TotalCalls` (logarithmic scale to handle wide ranges)\n4. **Color coding**: \n   - Green: `ErrorRate < 1%`\n   - Yellow: `1% ≤ ErrorRate < 5%`\n   - Red: `ErrorRate ≥ 5%`\n5. **Detect topology changes**:\n   - **New service**: A service appears in the trace data that wasn't in the previous graph\n   - **Removed service**: A service hasn't been seen in the last N time windows (configurable timeout)\n   - **New dependency**: An edge appears between existing services where none existed before\n   - **Dependency removed**: An edge hasn't been observed in the last M time windows\n6. **Detect cyclic dependencies**: Use depth-first search to identify cycles in the directed graph, which may indicate problematic architectural patterns\n\nThe complete service map refresh algorithm runs periodically (e.g., every 30 seconds) and processes spans that arrived since the last refresh.\n\n### ADR: Graph Storage - Materialized vs. On-Demand\n\n> **Decision: Materialized Graph with Incremental Updates**\n> - **Context**: The service map needs to support both real-time visualization (updating every few seconds) and historical queries (showing how dependencies changed over hours/days). We must decide whether to pre-compute and store the graph (materialized) or compute it on-demand from raw span data.\n> - **Options Considered**:\n>   1. **On-Demand Computation**: Query raw spans from storage each time the service map is requested, compute the graph in memory, and return it.\n>   2. **Materialized Graph with Full Rebuild**: Pre-compute the graph periodically (e.g., every minute), store it in a dedicated graph database, and serve queries from this materialized view.\n>   3. **Materialized Graph with Incremental Updates**: Maintain an in-memory aggregated view of edges, flush snapshots to storage periodically, and update incrementally as new spans arrive.\n> - **Decision**: Option 3 - Materialized Graph with Incremental Updates.\n> - **Rationale**: \n>   - **Latency requirements**: The service map UI should update near-real-time (sub-second), which on-demand computation cannot guarantee as span volumes grow.\n>   - **Resource efficiency**: Incremental updates amortize computation cost, whereas full rebuilds wastefully recompute unchanged portions of the graph.\n>   - **Query flexibility**: Materialized edges with time windows enable both current-state and historical trend queries without scanning all raw spans.\n>   - **Resilience**: In-memory aggregated state can be reconstructed from recent span data if the process restarts, providing a good balance between performance and durability.\n> - **Consequences**:\n>   - We must implement careful memory management for the in-memory aggregated state.\n>   - The system maintains eventual consistency - there's a brief delay (window size) before new dependencies appear.\n>   - Historical queries are limited to the retention period of aggregated edges, not raw spans.\n\nThe following table compares the options:\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| **On-Demand Computation** | Always accurate (no stale data), No additional storage needed, Simple implementation | Slow for large datasets, High load on span storage, Doesn't scale with request volume | Unacceptable latency for real-time visualization (seconds to minutes for large deployments) |\n| **Materialized Graph with Full Rebuild** | Consistent view at rebuild time, Can use optimized graph databases, Clean separation of concerns | High CPU usage during rebuilds, Stale data between rebuilds, Wastes resources recomputing unchanged portions | The periodic full rebuilds create resource spikes and stale periods |\n| **Materialized Graph with Incremental Updates** | Near-real-time updates, Efficient resource usage, Enables both current and historical views | More complex implementation, Requires memory management, Eventual consistency | **CHOSEN**: Best balance of performance, accuracy, and resource efficiency |\n\n### Common Pitfalls in Service Map Construction\n\n⚠️ **Pitfall 1: Misattributing Async and Concurrent Calls**\n\n**Description**: When Service A makes concurrent calls to Service B (e.g., fan-out pattern) or async calls (fire-and-forget), the simple parent-child relationship extraction can misinterpret the dependency direction or create misleading metrics.\n\n**Why it's wrong**: If Service A calls Service B 10 times concurrently within a single request, counting these as 10 separate dependencies exaggerates the importance of the A→B edge. Async calls might not have proper parent-child linking, causing them to appear as separate, disconnected traces.\n\n**How to fix**: \n- **Group concurrent calls**: When multiple spans share the same parent and have similar start times (within a small threshold, e.g., 10ms), treat them as a single logical operation for dependency analysis.\n- **Trace context propagation**: Ensure async operations propagate the trace context properly (see Milestone 5) to maintain parent-child relationships.\n- **Attribute tagging**: Use span attributes (e.g., `call.type=async`) to identify and handle special call patterns differently.\n\n⚠️ **Pitfall 2: High Cardinality from Operation Names**\n\n**Description**: When services have hundreds or thousands of distinct operation names (endpoints), creating separate edges for each (caller, callee, caller-op, callee-op) tuple explodes the edge count, making the graph unreadable and storage requirements unsustainable.\n\n**Why it's wrong**: A service map with 10,000 edges is visually useless and computationally expensive. The core value is understanding service-to-service dependencies, not endpoint-to-endpoint details.\n\n**How to fix**:\n- **Two-level aggregation**: First aggregate by (caller, callee) pair only, ignoring operation names for the main visualization.\n- **Drill-down views**: Provide click-through from service edges to see operation-level breakdowns.\n- **Operation grouping**: Use pattern matching or configuration to group similar operations (e.g., `/users/*` → `/users/:id`).\n- **Cardinality limits**: Implement hard limits (e.g., top 20 operations per edge) and aggregate the rest as \"other\".\n\n⚠️ **Pitfall 3: Missing or Transient Dependencies**\n\n**Description**: Infrequently called services (e.g., nightly batch jobs, error-handling services) may not appear in the service map if the aggregation window is too short or sampling rate is too aggressive.\n\n**Why it's wrong**: The service map should show all dependencies, not just frequent ones. Missing dependencies give a false sense of simplicity and can hide important failure modes.\n\n**How to fix**:\n- **Longer retention for edges**: Keep edge aggregates for longer periods (e.g., 24-48 hours) even if they have low call volumes.\n- **Sampling protection**: Ensure sampling algorithms (Milestone 3) don't systematically drop traces from low-volume services.\n- **Configuration-driven inclusion**: Allow operators to explicitly list services that must appear regardless of call frequency.\n- **Periodic full scans**: Occasionally scan older span data to rediscover dormant dependencies.\n\n⚠️ **Pitfall 4: Incorrect Cycle Detection in Directed Graphs**\n\n**Description**: Naive cycle detection algorithms can misidentify legitimate call patterns (like callback patterns, saga orchestrators) as problematic cycles, or miss actual problematic cycles due to timing issues.\n\n**Why it's wrong**: False positives lead to unnecessary alerts and investigation. False negatives miss actual architectural issues like circular dependencies that cause deadlocks or infinite loops.\n\n**How to fix**:\n- **Time-bound cycle detection**: Only consider cycles where all calls occur within a single request/trace context, not across different requests.\n- **Distinguish call patterns**: Use span attributes and operation names to identify legitimate patterns like callbacks vs. accidental cycles.\n- **Multi-request cycle detection**: For cycles spanning multiple requests/traces, use statistical correlation of call patterns over longer time windows.\n- **Visual highlighting vs. alerting**: Highlight potential cycles in the visualization for human investigation, but only alert on statistically significant patterns.\n\n### Implementation Guidance for Service Map\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **In-Memory Graph** | Go's native maps and slices with manual adjacency lists | Dedicated graph library: [`gonum/graph`](https://github.com/gonum/graph) |\n| **Time-Series Aggregates** | Rolling windows in memory with periodic persistence to Redis/PostgreSQL | Dedicated time-series database: InfluxDB or TimescaleDB |\n| **Real-Time Updates** | Periodic batch processing (e.g., every 30s) with goroutine | Streaming pipeline with channels and worker pools |\n| **Visualization Backend** | Static JSON API served to frontend with basic D3.js | WebSocket stream of graph diffs with interactive frontend |\n| **Edge Storage** | PostgreSQL with (caller, callee, window_start) composite index | Redis Sorted Sets for time-windowed aggregates |\n\n#### B. Recommended File/Module Structure\n\n```\nproject-root/\n  cmd/\n    servicemap/           # Service map microservice entry point\n      main.go\n  internal/\n    servicemap/           # Service map core logic\n      aggregator.go       # Edge extraction and metric aggregation\n      graph_builder.go    # Graph construction from aggregated edges\n      storage.go          # Interface for edge storage\n      types.go            # Service map specific types\n    servicemap/redis/     # Redis storage implementation\n      edge_store.go\n    servicemap/postgres/  # PostgreSQL storage implementation  \n      edge_store.go\n    servicemap/memory/    # In-memory storage (for development)\n      edge_store.go\n  pkg/\n    models/               # Shared data models (already defined)\n      trace.go            # Contains Span, Trace types\n      servicemap.go       # Service map specific types\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete Edge Storage Interface and In-Memory Implementation:**\n\n```go\n// internal/servicemap/types.go\npackage servicemap\n\nimport (\n    \"time\"\n)\n\n// ServiceEdge represents an aggregated edge between two services\ntype ServiceEdge struct {\n    CallerService  string        `json:\"caller_service\"`\n    CalleeService  string        `json:\"callee_service\"`\n    WindowStart    time.Time     `json:\"window_start\"`\n    WindowEnd      time.Time     `json:\"window_end\"`\n    TotalCalls     int64         `json:\"total_calls\"`\n    ErrorCount     int64         `json:\"error_count\"`\n    ErrorRate      float64       `json:\"error_rate\"`\n    P50Latency     time.Duration `json:\"p50_latency\"`\n    P95Latency     time.Duration `json:\"p95_latency\"`\n    P99Latency     time.Duration `json:\"p99_latency\"`\n    SampleTraceIDs []string      `json:\"sample_trace_ids\"`\n}\n\n// ServiceNode represents a node (service) in the graph\ntype ServiceNode struct {\n    Name       string    `json:\"name\"`\n    FirstSeen  time.Time `json:\"first_seen\"`\n    LastSeen   time.Time `json:\"last_seen\"`\n    TotalCalls int64     `json:\"total_calls\"`  // Sum of all outgoing calls\n}\n\n// ServiceGraph represents the complete service dependency graph\ntype ServiceGraph struct {\n    Nodes        []ServiceNode          `json:\"nodes\"`\n    Edges        []ServiceEdge          `json:\"edges\"`\n    GeneratedAt  time.Time              `json:\"generated_at\"`\n    WindowSize   time.Duration          `json:\"window_size\"`\n}\n\n// EdgeStorage defines the interface for storing and retrieving aggregated edges\ntype EdgeStorage interface {\n    // StoreEdge stores or updates an aggregated edge\n    StoreEdge(ctx context.Context, edge ServiceEdge) error\n    \n    // GetEdges returns edges for the given time window\n    GetEdges(ctx context.Context, startTime, endTime time.Time) ([]ServiceEdge, error)\n    \n    // GetServiceEdges returns edges for a specific service (as caller or callee)\n    GetServiceEdges(ctx context.Context, serviceName string, startTime, endTime time.Time) ([]ServiceEdge, error)\n    \n    // GetEdgeHistory returns historical aggregates for a specific edge\n    GetEdgeHistory(ctx context.Context, caller, callee string, lookbackPeriod time.Duration) ([]ServiceEdge, error)\n    \n    // Cleanup removes edges older than the specified duration\n    Cleanup(ctx context.Context, olderThan time.Time) error\n}\n\n// internal/servicemap/memory/edge_store.go\npackage memory\n\nimport (\n    \"context\"\n    \"sort\"\n    \"sync\"\n    \"time\"\n    \n    \"github.com/yourproject/internal/servicemap\"\n)\n\ntype MemoryEdgeStore struct {\n    mu     sync.RWMutex\n    edges  []servicemap.ServiceEdge\n    maxAge time.Duration\n}\n\nfunc NewMemoryEdgeStore(maxAge time.Duration) *MemoryEdgeStore {\n    store := &MemoryEdgeStore{\n        edges:  make([]servicemap.ServiceEdge, 0),\n        maxAge: maxAge,\n    }\n    \n    // Start cleanup goroutine\n    go store.periodicCleanup(context.Background())\n    \n    return store\n}\n\nfunc (s *MemoryEdgeStore) StoreEdge(ctx context.Context, edge servicemap.ServiceEdge) error {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    \n    // Check if edge already exists for this window\n    for i, existing := range s.edges {\n        if existing.CallerService == edge.CallerService &&\n           existing.CalleeService == edge.CalleeService &&\n           existing.WindowStart.Equal(edge.WindowStart) {\n            // Update existing edge\n            s.edges[i] = edge\n            return nil\n        }\n    }\n    \n    // Add new edge\n    s.edges = append(s.edges, edge)\n    return nil\n}\n\nfunc (s *MemoryEdgeStore) GetEdges(ctx context.Context, startTime, endTime time.Time) ([]servicemap.ServiceEdge, error) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    \n    var result []servicemap.ServiceEdge\n    for _, edge := range s.edges {\n        if !edge.WindowStart.Before(startTime) && !edge.WindowEnd.After(endTime) {\n            result = append(result, edge)\n        }\n    }\n    \n    return result, nil\n}\n\nfunc (s *MemoryEdgeStore) periodicCleanup(ctx context.Context) {\n    ticker := time.NewTicker(5 * time.Minute)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case <-ctx.Done():\n            return\n        case <-ticker.C:\n            cutoff := time.Now().Add(-s.maxAge)\n            s.mu.Lock()\n            filtered := s.edges[:0]\n            for _, edge := range s.edges {\n                if edge.WindowEnd.After(cutoff) {\n                    filtered = append(filtered, edge)\n                }\n            }\n            s.edges = filtered\n            s.mu.Unlock()\n        }\n    }\n}\n\n// Implement other EdgeStorage methods...\n```\n\n#### D. Core Logic Skeleton Code\n\n**Edge Aggregator with TODOs:**\n\n```go\n// internal/servicemap/aggregator.go\npackage servicemap\n\nimport (\n    \"context\"\n    \"time\"\n    \n    \"github.com/yourproject/pkg/models\"\n)\n\n// EdgeAggregator extracts service call edges from spans and aggregates metrics\ntype EdgeAggregator struct {\n    edgeStorage  EdgeStorage\n    windowSize   time.Duration\n    currentWindowStart time.Time\n    pendingEdges map[string]*ServiceEdge // Key: \"caller:callee:window_start\"\n    \n    // TODO: Add fields for t-digest instances for latency percentiles\n    // TODO: Add metrics for monitoring the aggregator itself\n}\n\n// NewEdgeAggregator creates a new aggregator with the specified window size\nfunc NewEdgeAggregator(storage EdgeStorage, windowSize time.Duration) *EdgeAggregator {\n    return &EdgeAggregator{\n        edgeStorage:  storage,\n        windowSize:   windowSize,\n        pendingEdges: make(map[string]*ServiceEdge),\n    }\n}\n\n// ProcessSpan extracts edges from a span and updates aggregations\nfunc (a *EdgeAggregator) ProcessSpan(ctx context.Context, span models.Span) error {\n    // TODO 1: Skip if span has no ParentSpanID (it's a root span)\n    // TODO 2: Skip if span.ServiceName is empty\n    \n    // TODO 3: Retrieve parent span using GetTraceByID and ParentSpanID\n    //         (Note: This assumes parent span is already stored - consider buffering)\n    \n    // TODO 4: If parent span not found, buffer this span for later retry\n    //         or use asynchronous parent resolution\n    \n    // TODO 5: Extract caller service from parentSpan.ServiceName\n    //         Extract callee service from span.ServiceName\n    \n    // TODO 6: Skip if caller == callee (same-service calls)\n    \n    // TODO 7: Determine which time window this span belongs to\n    //         windowStart := span.StartTime.Truncate(a.windowSize)\n    \n    // TODO 8: Create or update aggregated edge for (caller, callee, windowStart)\n    //         key := fmt.Sprintf(\"%s:%s:%d\", caller, callee, windowStart.Unix())\n    //         edge := a.pendingEdges[key]\n    //         if edge == nil {\n    //             edge = &ServiceEdge{CallerService: caller, CalleeService: callee, ...}\n    //             a.pendingEdges[key] = edge\n    //         }\n    \n    // TODO 9: Update edge metrics:\n    //         edge.TotalCalls++\n    //         if span.Status.Code >= 400 { edge.ErrorCount++ } // Adjust error detection\n    //         Update t-digest with span.Duration for latency percentiles\n    //         Maintain sample of trace IDs (keep up to 5 unique ones)\n    \n    // TODO 10: If we've reached the end of the current window, flush all pending edges\n    //          if windowStart != a.currentWindowStart && a.currentWindowStart != (time.Time{}) {\n    //              a.FlushWindow(ctx, a.currentWindowStart)\n    //          }\n    \n    return nil\n}\n\n// FlushWindow persists all aggregated edges for a specific window to storage\nfunc (a *EdgeAggregator) FlushWindow(ctx context.Context, windowStart time.Time) error {\n    // TODO 1: For each edge in a.pendingEdges with matching windowStart:\n    // TODO 2: Calculate final metrics (ErrorRate = ErrorCount/TotalCalls)\n    // TODO 3: Calculate percentiles from t-digest\n    // TODO 4: Store edge via a.edgeStorage.StoreEdge\n    // TODO 5: Remove flushed edges from pendingEdges map\n    // TODO 6: Update a.currentWindowStart to the next window\n    return nil\n}\n```\n\n**Graph Builder with TODOs:**\n\n```go\n// internal/servicemap/graph_builder.go\npackage servicemap\n\nimport (\n    \"context\"\n    \"time\"\n)\n\n// GraphBuilder constructs service graphs from aggregated edges\ntype GraphBuilder struct {\n    edgeStorage EdgeStorage\n}\n\n// BuildCurrentGraph builds a service graph for the most recent complete time window\nfunc (b *GraphBuilder) BuildCurrentGraph(ctx context.Context, windowSize time.Duration) (*ServiceGraph, error) {\n    // TODO 1: Calculate time window for the most recent complete window\n    //         now := time.Now()\n    //         endTime := now.Truncate(windowSize)\n    //         startTime := endTime.Add(-windowSize)\n    \n    // TODO 2: Retrieve edges for this window using b.edgeStorage.GetEdges\n    \n    // TODO 3: Extract unique service names from edges (both caller and callee)\n    \n    // TODO 4: Create ServiceNode for each unique service\n    //         For each node, calculate total outgoing calls by summing edges where service is caller\n    \n    // TODO 5: Build ServiceGraph with nodes and edges\n    \n    // TODO 6: Detect and mark potential issues:\n    //         - Services with no incoming edges (entry points)\n    //         - Services with no outgoing edges (leaf nodes)\n    //         - Potential cycles (use DFS or topological sort)\n    //         - Edges with high error rates (> threshold)\n    \n    return nil, nil\n}\n\n// DetectTopologyChanges compares current graph with previous graph to find changes\nfunc (b *GraphBuilder) DetectTopologyChanges(ctx context.Context, currentGraph, previousGraph *ServiceGraph) *TopologyChanges {\n    // TODO 1: Compare nodes to detect:\n    //         - New services (in current but not previous)\n    //         - Removed services (in previous but not current)\n    \n    // TODO 2: Compare edges to detect:\n    //         - New dependencies\n    //         - Removed dependencies\n    \n    // TODO 3: For existing edges, detect significant metric changes:\n    //         - Error rate increased by more than X%\n    //         - Call volume changed by more than Y%\n    //         - Latency percentiles changed significantly\n    \n    // TODO 4: Return structured TopologyChanges object\n    return nil\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **Concurrent Map Access**: Use `sync.RWMutex` for the `pendingEdges` map in the aggregator, or consider `sync.Map` if you have a write-once, read-many pattern.\n\n2. **Time Window Calculations**: Use `time.Time.Truncate()` for clean window boundaries: `windowStart := timestamp.Truncate(5 * time.Minute)`.\n\n3. **Efficient Edge Lookups**: Create composite keys for the pending edges map using string concatenation with a delimiter: `key := fmt.Sprintf(\"%s|%s|%d\", caller, callee, windowStart.Unix())`.\n\n4. **Background Flushing**: Use a `time.Ticker` in a goroutine for periodic window flushes: \n   ```go\n   go func() {\n       ticker := time.NewTicker(flushInterval)\n       defer ticker.Stop()\n       for {\n           select {\n           case <-ctx.Done():\n               return\n           case <-ticker.C:\n               aggregator.FlushWindow(ctx, currentWindow)\n           }\n       }\n   }()\n   ```\n\n5. **Graph Algorithms**: For cycle detection, implement depth-first search with coloring (white/gray/black nodes) to detect back edges efficiently.\n\n6. **Memory Management**: Use pointers in slices for edges and nodes to avoid large data copies when building graphs.\n\n#### F. Milestone Checkpoint\n\n**Verification Steps:**\n\n1. **Start the system**: Run the trace collector (from Milestone 1) and the service map aggregator.\n2. **Generate traffic**: Use the provided test harness to simulate calls between 3-5 mock services.\n3. **Check edge extraction**: Query the service map API after 1-2 minutes, you should see:\n   - Nodes for each mock service\n   - Directed edges showing which service calls which\n   - Basic metrics (call count) on each edge\n4. **Verify real-time updates**: Add a new mock service that calls an existing one, wait for the aggregation window (e.g., 1 minute), and confirm the graph updates.\n5. **Test error visualization**: Configure one mock service to return errors 20% of the time, verify the corresponding edge turns yellow/red in the visualization.\n\n**Expected API endpoints:**\n- `GET /api/servicemap/current` - Returns current service graph as JSON\n- `GET /api/servicemap/history?service=A&hours=24` - Returns historical edges for service A\n- `GET /api/servicemap/changes?since=2024-01-01T00:00:00Z` - Returns topology changes since timestamp\n\n**Signs of problems:**\n- **No edges appear**: Check that spans have proper parent-child relationships and `ServiceName` is populated\n- **High memory usage**: The pending edges map might not be getting flushed; check the flush timer\n- **Stale data**: The aggregation window might be too long; reduce from default 5 minutes to 1 minute for testing\n- **Missing services**: Low-volume services might be filtered out; adjust the minimum call threshold\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Service map shows no edges** | Spans missing parent-child links or `ServiceName` fields | Check raw span data in storage; verify `ParentSpanID` is set and points to valid span | Ensure SDK (Milestone 5) properly sets parent-child relationships and service names |\n| **Edges appear/disappear randomly** | Aggregation window too short or sampling dropping traces | Check if total calls per edge are very low (< 10 per window) | Increase aggregation window size or adjust sampling to keep more traces |\n| **High memory usage in aggregator** | Too many pending edges or window not flushing | Monitor `len(pendingEdges)`; check if flush goroutine is running | Implement edge eviction for old windows; ensure flush timer is working |\n| **Cycles detected in healthy system** | Callback patterns misidentified as cycles | Examine the specific edges forming the cycle; check if calls are within same trace | Implement time-bound cycle detection or tag callback patterns in spans |\n| **Visualization overloaded with edges** | Operation-level granularity instead of service-level | Count distinct (caller, callee, operation) tuples | Aggregate at service level only; provide operation breakdown on click |\n| **Service map doesn't update in real-time** | Processing pipeline too slow or batched | Measure latency from span arrival to edge appearance in API | Optimize parent span lookup; consider async processing; reduce batch sizes |\n\n\n## 7. Component Design: Trace Sampling (Milestone 3)\n\n> **Milestone(s):** This section corresponds to Milestone 3: Trace Sampling, which designs the intelligent filtering mechanism to reduce storage costs while preserving valuable traces for debugging and analysis.\n\n### Mental Model: The Library Archivist\n\nImagine you're an archivist in a vast library receiving thousands of books every hour, but your storage shelves have limited capacity. You cannot possibly keep every book that arrives, yet you must ensure that:\n1. **Rare and unique works** are preserved (error traces, anomalies)\n2. **Representative samples** of popular genres are kept (normal traffic patterns)\n3. **Important historical records** are maintained (high-latency operations, critical paths)\n4. **The collection remains useful** for researchers (debuggers, SREs) to understand the library's contents\n\nThis is exactly the challenge of **trace sampling** in a high-volume APM system. Every request through your distributed system produces a trace (a \"book\"), but storing all traces would require impractical amounts of storage. The sampling subsystem acts as the intelligent archivist, making real-time decisions about which traces to preserve based on configurable policies, while ensuring that the retained traces form a statistically useful dataset for debugging performance issues and understanding system behavior.\n\nThe archivist faces two critical decisions:\n- **Immediate filtering (head-based)**: As books arrive at the loading dock, quickly decide which ones to even bring inside based on cover information (trace ID, service name).\n- **Retrospective evaluation (tail-based)**: After examining a book's contents (completed trace), decide if it's valuable enough to override an earlier rejection.\n\n### Head-Based vs. Tail-Based Sampling\n\nSampling strategies differ fundamentally in **when** the sampling decision is made relative to when the trace completes. Each approach has distinct trade-offs that make it suitable for different parts of the pipeline.\n\n#### Head-Based Sampling: The First Impression\n\n**Head-based sampling** makes its keep/drop decision **at the very beginning of a trace**, when the root span is first created and before any downstream spans are generated. This decision is made locally by the SDK/agent when it starts tracing a request.\n\n> **Key Insight:** Head-based sampling is like deciding whether to film a documentary based on the title alone—you save resources by not filming at all, but you might miss incredible footage that only reveals itself later.\n\n| Aspect | Description |\n|--------|-------------|\n| **Decision Point** | At trace creation (when root span starts) |\n| **Information Available** | Only initial context: trace ID, service name, operation name, possibly sampling configuration |\n| **Decision Scope** | Applies to the entire trace—once dropped, no spans are collected |\n| **Performance Impact** | Minimal overhead on downstream services (no context propagation for dropped traces) |\n| **Storage Savings** | Maximum possible reduction (entire traces never enter the system) |\n\nThe decision algorithm for head-based sampling typically uses **consistent hashing** on the trace ID to ensure all participants make the same deterministic decision:\n\n1. Hash the trace ID to a value between 0 and 1 (e.g., using MurmurHash3)\n2. Compare against configured sampling probability for the service/operation\n3. If hash ≤ probability, keep the trace; otherwise, drop it\n\n```math\ndecision = hash(trace\\_id) ≤ sampling\\_probability(service, operation)\n```\n\nThis approach ensures **consistency**—all spans for the same trace get the same decision, avoiding partial traces. The `SamplingConfig` structure supports this with both global (`Probability`) and per-service (`PerService`) rates.\n\n#### Tail-Based Sampling: The Retrospective Review\n\n**Tail-based sampling** evaluates traces **after they complete** (or after a significant portion has been collected). This allows decisions based on complete information about the trace's characteristics: duration, error status, specific operations performed, etc.\n\n> **Key Insight:** Tail-based sampling is like a film editor reviewing all footage shot during the day and deciding which clips to keep for the final documentary—more resource-intensive but ensures you don't miss critical scenes.\n\n| Aspect | Description |\n|--------|-------------|\n| **Decision Point** | After trace completion (or after a timeout) |\n| **Information Available** | Complete trace data: all spans, durations, errors, attributes |\n| **Decision Scope** | Can override head-based decisions to keep interesting traces |\n| **Performance Impact** | Higher resource usage (collect all spans first, then evaluate) |\n| **Storage Savings** | Selective—keeps only traces matching defined criteria |\n\nTail-based sampling operates as a **second-chance mechanism**:\n1. All spans for a trace are collected (potentially after head-based sampling)\n2. When the trace completes or times out, evaluate against criteria\n3. If criteria match, ensure all spans are persisted; otherwise, discard\n\n![Flowchart: Head-Based and Tail-Based Sampling Decisions](./diagrams/sampling-decision-flow.svg)\n\n#### Comparison Table: When to Use Each Strategy\n\n| Strategy | Best For | Not Suitable For |\n|----------|----------|------------------|\n| **Head-Based** | High-volume production traffic, cost reduction, predictable sampling rates | Debugging rare errors, investigating latency spikes, compliance/audit trails |\n| **Tail-Based** | Error investigation, performance debugging, compliance (keep all errors) | Extremely high-volume systems without sufficient buffering capacity |\n| **Combined Approach** | Most production systems: head-based for volume reduction + tail-based for error capture | Systems with extremely tight latency budgets at the edge |\n\nIn our APM system, we implement a **hybrid approach**:\n1. **Head-based sampling** at the SDK level reduces initial volume\n2. **Tail-based sampling** at the collector level re-evaluates kept traces\n3. **Priority channels** ensure error traces bypass sampling when detected early\n\n### ADR: Adaptive Sampling Algorithm\n\n> **Decision: Implement Feedback-Controlled Adaptive Sampling with Per-Service Budgets**\n> - **Context**: Our APM system must handle variable traffic loads while maintaining consistent storage costs. Fixed sampling rates either waste storage during low traffic or lose valuable traces during peaks. We need an algorithm that adjusts sampling rates dynamically based on system load and trace value.\n> - **Options Considered**:\n>   1. **Fixed-Rate Sampling**: Constant probability (e.g., 10%) for all services\n>   2. **Rate-Limiting Sampling**: Maximum spans per second, discarding excess\n>   3. **Feedback-Controlled Adaptive Sampling**: Dynamically adjusts rates based on ingestion load and trace characteristics\n> - **Decision**: Implement feedback-controlled adaptive sampling with separate control loops for head-based and tail-based decisions, using per-service budgets to prioritize critical services.\n> - **Rationale**: \n>   - Fixed rates cannot adapt to traffic patterns, causing either data loss or storage bloat\n>   - Rate limiting causes unfair distribution—high-traffic services dominate the quota\n>   - Feedback control maintains system stability while maximizing trace value\n>   - Per-service budgets ensure monitoring critical services even during load spikes\n> - **Consequences**:\n>   - Adds complexity with control loops and monitoring\n>   - Requires careful tuning to avoid oscillation\n>   - Provides optimal trace retention within storage constraints\n>   - Enables priority sampling for business-critical services\n\n#### Options Comparison Table\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| **Fixed-Rate Sampling** | Simple to implement, predictable behavior, easy to reason about | Cannot adapt to traffic changes, either wastes storage or loses data during peaks, one-size-fits-all approach | Too inflexible for production systems with variable loads |\n| **Rate-Limiting Sampling** | Enforces hard storage limits, prevents system overload, simple conceptually | Unfair to high-traffic services, discards based on arrival order not value, causes sampling bias | Violates principle of preserving valuable traces—discards randomly during congestion |\n| **Feedback-Controlled Adaptive** | Maximizes trace value within constraints, adapts to traffic patterns, prioritizes important services | Complex implementation, requires tuning, potential for oscillation if poorly designed | **CHOSEN**: Provides optimal balance of value preservation and cost control |\n\n#### Adaptive Sampling Algorithm Design\n\nOur adaptive sampling system uses **separate but coordinated control loops**:\n\n**1. Head-Based Adaptive Controller**\n- **Input**: Current ingestion rate, storage utilization, per-service budgets\n- **Output**: Adjusted sampling probabilities per service\n- **Algorithm**:\n  1. Measure ingestion rate over sliding window (e.g., 30 seconds)\n  2. Compare against target ingestion capacity (configurable)\n  3. If above target: reduce sampling probabilities proportionally across services, respecting minimum rates\n  4. If below target: gradually increase probabilities toward configured maximums\n  5. Apply emergency reduction if storage exceeds critical threshold\n\n**2. Tail-Based Value Scorer**\n- **Input**: Completed trace characteristics (errors, latency, service mix)\n- **Output**: Priority score (0-100) indicating trace value\n- **Scoring Factors**:\n  - Error presence: +50 points\n  - High latency ( > p95 for service): +30 points  \n  - Contains specific operations (configurable): +20 points\n  - Rare service combinations: +10 points\n- **Decision**: Keep trace if score > threshold (configurable)\n\n**3. Per-Service Budget Allocator**\n- **Input**: Total ingestion capacity, service criticality weights\n- **Output**: Maximum spans per second per service\n- **Algorithm**:\n  - Allocate base budget to all services (e.g., 100 spans/sec)\n  - Distribute remaining capacity proportionally to criticality weights\n  - Enforce minimum budget for all services (ensures some visibility)\n  - Reallocate unused budget from low-traffic to high-traffic services\n\nThe control loops run at different frequencies:\n- **Head-based adjustments**: Every 10 seconds (slow, stable changes)\n- **Tail-based scoring**: Per completed trace (immediate)\n- **Budget reallocation**: Every 60 seconds (infrequent redistribution)\n\n#### State Machine: Sampling Decision Process\n\nThe complete sampling workflow can be modeled as a state machine:\n\n| Current State | Event | Next State | Actions Taken |\n|---------------|-------|------------|---------------|\n| **New Trace** | Root span created | `HeadDecisionPending` | Generate trace ID, extract service/operation |\n| `HeadDecisionPending` | Hash computed | `SampledOut` or `SampledIn` | Apply head-based probability, set sampling flag in context |\n| `SampledOut` | Span propagation | `Dropped` | Do not propagate context, discard locally |\n| `SampledIn` | Span collection | `Collecting` | Propagate context, buffer spans at collector |\n| `Collecting` | Trace timeout reached | `TailEvaluation` | Mark trace complete, trigger evaluation |\n| `Collecting` | All spans received | `TailEvaluation` | Mark trace complete, trigger evaluation |\n| `TailEvaluation` | Score calculated | `FinalKeep` or `FinalDrop` | Apply tail-based rules, persist or discard |\n| `FinalKeep` | Storage acknowledgment | `Archived` | Write to persistent storage, update indexes |\n| `FinalDrop` | Cleanup complete | `Discarded` | Release buffer memory, log statistics |\n\n#### Adaptive Rate Calculation Algorithm\n\nThe core adaptive algorithm adjusts sampling probabilities:\n\n1. **Gather Metrics** (every control interval):\n   - Current ingestion rate `I_current` (spans/sec)\n   - Target ingestion rate `I_target` (from configuration)\n   - Storage utilization `U` (0-100%)\n   - Per-service traffic rates `R_service[]`\n\n2. **Calculate Adjustment Factor**:\n   ```math\n   error = I_current - I_target\n   adjustment = -Kp × error - Ki × integral(error) - Kd × derivative(error)\n   ```\n   Where Kp, Ki, Kd are PID controller tuning parameters.\n\n3. **Apply with Constraints**:\n   - New probability = Current probability × (1 + adjustment)\n   - Clamp between service-specific min/max bounds\n   - Ensure total across services ≤ system capacity\n\n4. **Emergency Overrides**:\n   - If storage > 90%: Apply global reduction multiplier (e.g., ×0.5)\n   - If storage > 95%: Drop all non-error traces temporarily\n\n### Common Pitfalls in Sampling\n\n#### ⚠️ **Pitfall 1: Sampling Bias Leading to Misleading Statistics**\n\n**Description**: Applying uniform sampling rates across all services creates a biased dataset where high-traffic services are overrepresented, while low-traffic but critical services may have no traces at all.\n\n**Why It's Wrong**: Performance statistics (p95 latency, error rates) calculated from biased samples do not reflect true system behavior. Debugging issues in low-traffic services becomes impossible.\n\n**How to Fix**:\n- Implement **per-service sampling rates** with minimum guarantees\n- Use **stratified sampling** to ensure representation from all service tiers\n- Maintain **separate statistics** for sampled vs. unsampled populations\n- Apply **Neyman allocation** for optimal distribution: allocate sample size proportional to traffic × variability\n\n#### ⚠️ **Pitfall 2: Inconsistent Decisions for the Same Trace**\n\n**Description**: Different services or collectors making independent sampling decisions for spans belonging to the same trace, resulting in partial traces where some spans are stored while others are missing.\n\n**Why It's Wrong**: Partial traces are useless for debugging—you cannot reconstruct the request flow or identify bottlenecks. This violates the fundamental guarantee of distributed tracing.\n\n**How to Fix**:\n- Use **deterministic hash-based sampling** on trace ID\n- Propagate sampling decision in trace context (W3C `sampled` flag)\n- Implement **centralized sampling coordination** for tail-based decisions\n- Add **consistency checks** during trace assembly to detect and discard partial traces\n\n#### ⚠️ **Pitfall 3: Adaptive Algorithm Oscillation**\n\n**Description**: The adaptive control loop overcorrects, causing sampling rates to oscillate wildly between extremes—from 100% to 1% and back—creating unpredictable retention and making historical comparisons meaningless.\n\n**Why It's Wrong**: Oscillation reduces system stability, causes operational confusion, and makes capacity planning impossible. Engineers lose trust in the sampling system.\n\n**How to Fix**:\n- Implement **hysteresis** in control decisions (require sustained deviation before adjusting)\n- Use **moving averages** with appropriate window sizes (not instantaneous measurements)\n- Apply **rate limiting** to adjustments (maximum change per interval)\n- Add **dead bands** where small deviations are ignored\n- Monitor oscillation metrics and trigger alerts when detected\n\n#### ⚠️ **Pitfall 4: Head-Based Sampling Losing All Error Traces**\n\n**Description**: With pure head-based sampling, error traces are dropped at the same rate as successful ones, making post-mortem debugging impossible since no error traces are available for analysis.\n\n**Why It's Wrong**: The primary value of tracing is debugging failures. Losing all error traces defeats the purpose of the APM system.\n\n**How to Fix**:\n- Implement **tail-based sampling override** specifically for error traces\n- Use **priority sampling** where error traces bypass head-based decisions\n- Apply **multi-stage sampling**: sample all errors, sample subset of successes\n- Consider **oversampling** error-prone services or operations\n\n#### ⚠️ **Pitfall 5: Clock Skew Causing Premature Trace Completion**\n\n**Description**: In tail-based sampling, traces are considered \"complete\" after a timeout period. Clock skew between services causes incorrect timestamp ordering, leading to premature timeout and evaluation before all spans arrive.\n\n**Why It's Wrong**: Early trace evaluation leads to incorrect tail-based decisions—traces may be dropped even though interesting spans are still in transit.\n\n**How to Fix**:\n- Use **watermark algorithm** based on observed timestamps, not system clock\n- Implement **buffer extension** when late spans are detected for a trace\n- Apply **NTP synchronization** across collectors with monitoring\n- Design **forgiving timeout** with grace period for clock skew\n\n### Implementation Guidance for Trace Sampling\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option | Recommendation |\n|-----------|---------------|-----------------|----------------|\n| **Hash Function** | Go's `fnv` package (built-in) | `MurmurHash3` (github.com/spaolacci/murmur3) | MurmurHash3 for better distribution |\n| **Probability Storage** | In-memory map with mutex | Redis for distributed coordination | Start with in-memory, evolve to Redis |\n| **Adaptive Controller** | Simple PID in Go | Control theory library (github.com/yourbasic/pid) | Custom PID for simplicity |\n| **Priority Queue** | Slice with sorting | Heap container (container/heap) | Heap for O(log n) operations |\n| **Configuration** | YAML file with viper | Dynamic config service (etcd/Consul) | YAML + viper initially |\n| **Metrics** | Prometheus counters | OpenTelemetry metrics + Prometheus | Prometheus for simplicity |\n\n#### B. Recommended File/Module Structure\n\n```\napm-tracing/\n├── cmd/\n│   ├── collector/           # Main collector binary\n│   └── sampling-controller/ # Optional separate adaptive controller\n├── internal/\n│   ├── sampling/\n│   │   ├── sampler.go       # Base sampler interface\n│   │   ├── head_sampler.go  # Head-based sampling\n│   │   ├── tail_sampler.go  # Tail-based sampling\n│   │   ├── adaptive.go      # Adaptive controller\n│   │   ├── priority.go      # Priority scoring\n│   │   ├── consistency.go   # Hash consistency utilities\n│   │   └── config.go        # Sampling configuration\n│   ├── models/              # Data models (SamplingConfig, etc.)\n│   └── storage/             # Storage layer\n└── configs/\n    └── sampling.yaml        # Sampling configuration file\n```\n\n#### C. Infrastructure Starter Code: Consistent Hash Sampler\n\n```go\n// internal/sampling/consistency.go\npackage sampling\n\nimport (\n\t\"hash/fnv\"\n\t\"sync\"\n)\n\n// ConsistentSampler ensures all participants make the same sampling decision\n// for a given trace ID using deterministic hashing.\ntype ConsistentSampler struct {\n\tmu       sync.RWMutex\n\trate     float64 // 0.0 to 1.0\n\thashFunc func(string) uint64\n}\n\n// NewConsistentSampler creates a sampler with the given rate.\n// Uses FNV-1a hash by default for simplicity and good distribution.\nfunc NewConsistentSampler(rate float64) *ConsistentSampler {\n\tif rate < 0.0 || rate > 1.0 {\n\t\trate = 0.1 // Default to 10%\n\t}\n\t\n\treturn &ConsistentSampler{\n\t\trate: rate,\n\t\thashFunc: func(traceID string) uint64 {\n\t\t\th := fnv.New64a()\n\t\t\th.Write([]byte(traceID))\n\t\t\treturn h.Sum64()\n\t\t},\n\t}\n}\n\n// ShouldSample determines if a trace should be kept based on its ID.\n// Returns true if the trace should be sampled (kept).\nfunc (s *ConsistentSampler) ShouldSample(traceID string) bool {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\t\n\tif s.rate >= 1.0 {\n\t\treturn true // Sample everything\n\t}\n\tif s.rate <= 0.0 {\n\t\treturn false // Sample nothing\n\t}\n\t\n\t// Hash to a float in [0, 1)\n\thash := s.hashFunc(traceID)\n\tnormalized := float64(hash) / float64(^uint64(0))\n\t\n\treturn normalized < s.rate\n}\n\n// SetRate updates the sampling rate (thread-safe).\nfunc (s *ConsistentSampler) SetRate(rate float64) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\t\n\tif rate < 0.0 {\n\t\trate = 0.0\n\t} else if rate > 1.0 {\n\t\trate = 1.0\n\t}\n\ts.rate = rate\n}\n\n// GetRate returns the current sampling rate.\nfunc (s *ConsistentSampler) GetRate() float64 {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\treturn s.rate\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n```go\n// internal/sampling/head_sampler.go\npackage sampling\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\t\n\t\"apm-tracing/internal/models\"\n)\n\n// HeadSampler implements head-based sampling with per-service rates.\ntype HeadSampler struct {\n\tmu            sync.RWMutex\n\tglobalSampler *ConsistentSampler\n\tserviceRates  map[string]*ConsistentSampler\n\tdefaultRate   float64\n\tstats         HeadSamplerStats\n}\n\n// HeadSamplerStats tracks sampling decisions for monitoring.\ntype HeadSamplerStats struct {\n\tTotalTraces     int64\n\tSampledTraces   int64\n\tPerService      map[string]ServiceStats\n\tLastReset       time.Time\n}\n\n// ServiceStats tracks per-service sampling statistics.\ntype ServiceStats struct {\n\tTracesSeen    int64\n\tTracesSampled int64\n}\n\n// NewHeadSampler creates a new head-based sampler with configuration.\nfunc NewHeadSampler(config *models.SamplingConfig) (*HeadSampler, error) {\n\tif config == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\t\n\tsampler := &HeadSampler{\n\t\tglobalSampler: NewConsistentSampler(config.Probability),\n\t\tserviceRates:  make(map[string]*ConsistentSampler),\n\t\tdefaultRate:   config.Probability,\n\t\tstats: HeadSamplerStats{\n\t\t\tPerService: make(map[string]ServiceStats),\n\t\t\tLastReset:  time.Now(),\n\t\t},\n\t}\n\t\n\t// Initialize per-service samplers\n\tfor serviceName, rate := range config.PerService {\n\t\tif rate < 0.0 || rate > 1.0 {\n\t\t\treturn nil, fmt.Errorf(\"invalid rate for service %s: %f\", serviceName, rate)\n\t\t}\n\t\tsampler.serviceRates[serviceName] = NewConsistentSampler(rate)\n\t}\n\t\n\treturn sampler, nil\n}\n\n// Decide makes a head-based sampling decision for a trace.\n// This should be called when the root span is created.\nfunc (s *HeadSampler) Decide(ctx context.Context, traceID, serviceName string) bool {\n\t// TODO 1: Look up per-service sampler if configured\n\t// TODO 2: If no per-service sampler exists, use global sampler\n\t// TODO 3: Call ShouldSample on the appropriate sampler\n\t// TODO 4: Update statistics (thread-safe)\n\t// TODO 5: Return true if trace should be kept, false otherwise\n\t// Hint: Use s.mu for thread safety when accessing serviceRates and stats\n\treturn false // Placeholder\n}\n\n// UpdateRates dynamically adjusts sampling rates based on adaptive controller input.\nfunc (s *HeadSampler) UpdateRates(ctx context.Context, newGlobalRate float64, newServiceRates map[string]float64) error {\n\t// TODO 1: Validate all rates are in [0.0, 1.0]\n\t// TODO 2: Update global sampler rate\n\t// TODO 3: Update or create per-service samplers for each entry in newServiceRates\n\t// TODO 4: Log the rate changes for audit purposes\n\t// TODO 5: Reset statistics to track new rate effectiveness\n\treturn nil // Placeholder\n}\n\n// GetStats returns current sampling statistics for monitoring.\nfunc (s *HeadSampler) GetStats(ctx context.Context) HeadSamplerStats {\n\t// TODO 1: Acquire read lock for thread safety\n\t// TODO 2: Return copy of stats (not reference)\n\t// TODO 3: Include current rates in the returned stats\n\treturn HeadSamplerStats{} // Placeholder\n}\n```\n\n```go\n// internal/sampling/tail_sampler.go\npackage sampling\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\t\n\t\"apm-tracing/internal/models\"\n)\n\n// TailSampler evaluates completed traces and overrides head decisions.\ntype TailSampler struct {\n\trules      []TailSamplingRule\n\tevaluator  *TraceEvaluator\n\tbuffer     *TraceBuffer\n\ttimeout    time.Duration\n\tstats      TailSamplerStats\n}\n\n// TailSamplingRule defines criteria for tail-based sampling.\ntype TailSamplingRule struct {\n\tName        string\n\tCondition   TraceCondition\n\tPriority    int // Higher priority rules execute first\n\tKeepIfMatch bool\n}\n\n// TraceCondition evaluates whether a trace matches criteria.\ntype TraceCondition interface {\n\tMatches(trace *models.Trace) bool\n}\n\n// TraceEvaluator scores traces based on multiple criteria.\ntype TraceEvaluator struct {\n\terrorWeight      float64\n\tlatencyWeight    float64\n\toperationWeights map[string]float64\n\tthreshold        float64\n}\n\n// NewTailSampler creates a tail-based sampler with configured rules.\nfunc NewTailSampler(rules []TailSamplingRule, timeout time.Duration) (*TailSampler, error) {\n\tif timeout <= 0 {\n\t\ttimeout = 30 * time.Second // Default timeout\n\t}\n\t\n\tsampler := &TailSampler{\n\t\trules:   rules,\n\t\ttimeout: timeout,\n\t\tevaluator: &TraceEvaluator{\n\t\t\terrorWeight:      50.0,\n\t\t\tlatencyWeight:    30.0,\n\t\t\toperationWeights: make(map[string]float64),\n\t\t\tthreshold:        60.0, // Keep if score >= 60\n\t\t},\n\t\tstats: TailSamplerStats{\n\t\t\tTotalEvaluated:   0,\n\t\t\tHeadSampled:      0,\n\t\t\tTailOverrides:    0,\n\t\t\tPerRuleDecisions: make(map[string]int64),\n\t\t},\n\t}\n\t\n\t// Sort rules by priority (descending)\n\t// TODO: Implement rule sorting\n\t\n\treturn sampler, nil\n}\n\n// EvaluateTrace examines a completed trace for tail-based sampling.\n// Returns true if the trace should be kept (either head decision or tail override).\nfunc (s *TailSampler) EvaluateTrace(ctx context.Context, trace *models.Trace, headDecision bool) bool {\n\t// TODO 1: Update statistics for head decision\n\t// TODO 2: Check if trace already marked for keeping by head sampler\n\t// TODO 3: If head decision was false, evaluate against tail rules\n\t// TODO 4: Apply rules in priority order until a rule matches\n\t// TODO 5: If any rule with KeepIfMatch=true matches, override to keep\n\t// TODO 6: Also compute priority score using evaluator\n\t// TODO 7: If score >= threshold, override to keep\n\t// TODO 8: Update tail override statistics if decision changed\n\t// TODO 9: Return final keep/drop decision\n\treturn headDecision // Placeholder\n}\n\n// ProcessCompletedTraces runs a goroutine to evaluate traces that have completed.\nfunc (s *TailSampler) ProcessCompletedTraces(ctx context.Context, traceCh <-chan *models.Trace) error {\n\t// TODO 1: Start a loop that listens on traceCh\n\t// TODO 2: For each trace, check if it's complete (all spans received or timeout)\n\t// TODO 3: Extract head decision from trace metadata\n\t// TODO 4: Call EvaluateTrace for final decision\n\t// TODO 5: If final decision is keep, persist to storage\n\t// TODO 6: If final decision is drop, clean up buffer\n\t// TODO 7: Handle context cancellation gracefully\n\treturn nil // Placeholder\n}\n\n// AddTraceToBuffer stores a trace for later evaluation when it completes.\nfunc (s *TailSampler) AddTraceToBuffer(ctx context.Context, traceID string, spans []models.Span) error {\n\t// TODO 1: Check if trace already exists in buffer\n\t// TODO 2: Add spans to existing trace buffer or create new\n\t// TODO 3: Start timeout timer if this is the first span\n\t// TODO 4: Check if trace is now complete (all expected spans received)\n\t// TODO 5: If complete, move to evaluation queue\n\treturn nil // Placeholder\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **Concurrency**: Use `sync.RWMutex` for sampler statistics—multiple goroutines read stats, few update them.\n2. **Hashing**: For production, use `github.com/spaolacci/murmur3` instead of FNV for better distribution.\n3. **Context Propagation**: Pass `context.Context` through all sampling methods for cancellation and deadlines.\n4. **Metrics Export**: Use Prometheus counters for sampling statistics:\n   ```go\n   var sampledTraces = prometheus.NewCounterVec(\n       prometheus.CounterOpts{\n           Name: \"sampler_traces_total\",\n           Help: \"Total traces processed by sampler\",\n       },\n       []string{\"service\", \"decision\"},\n   )\n   ```\n5. **Configuration Hot Reload**: Use `fsnotify` to watch config file changes and reload sampling rates without restart.\n6. **Memory Management**: For trace buffers, use `sync.Pool` for span slices to reduce GC pressure.\n\n#### F. Milestone Checkpoint\n\nAfter implementing the sampling subsystem:\n\n1. **Test Head-Based Sampling**:\n   ```bash\n   # Run unit tests\n   go test ./internal/sampling -v -run TestHeadSampler\n   \n   # Expected output: All tests pass, showing:\n   # - Consistent decisions for same trace ID\n   # - Per-service rates work correctly\n   # - Statistics are tracked accurately\n   ```\n\n2. **Verify Tail-Based Override**:\n   ```bash\n   # Start collector with sampling enabled\n   ./cmd/collector --config configs/sampling.yaml\n   \n   # Send test traces with errors\n   curl -X POST http://localhost:8080/api/v1/spans \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"traceId\": \"err-123\", \"spans\": [{\"name\": \"errorOp\", \"status\": {\"code\": 2}}]}'\n   \n   # Check logs: Should see \"tail override\" for error trace\n   # Even with 1% sampling rate, error trace should be kept\n   ```\n\n3. **Validate Adaptive Control**:\n   ```bash\n   # Monitor sampling rate adjustments\n   curl http://localhost:9090/metrics | grep sampler_rate\n   \n   # Send burst traffic (e.g., 10k spans in 1 second)\n   # Observe: Sampling rate should decrease temporarily\n   # After traffic normalizes, rate should return to configured level\n   ```\n\n**Signs of Problems**:\n- `sampler_traces_total{decision=\"drop\"}` increasing during normal traffic (rate too low)\n- Memory growing unbounded (trace buffer not evicting completed traces)\n- Inconsistent trace assembly (spans missing from kept traces)\n\n**Debugging Steps**:\n1. Check hash consistency: Same trace ID should always get same decision\n2. Verify context propagation: `sampled` flag should be passed through all services\n3. Monitor buffer sizes: Implement metrics for trace buffer occupancy\n\n\n## 8. Component Design: Performance Analytics & Anomaly Detection (Milestone 4)\n\n> **Milestone(s):** This section corresponds to Milestone 4: Performance Analytics & Anomaly Detection, which designs the analytics engine that computes performance percentiles, establishes historical baselines, and automatically flags anomalies in the APM Tracing System.\n\n![Performance Analytics and Alerting](./diagrams/analytics-sequence.svg)\n\n### Mental Model: The Weather Forecaster for Performance\n\nImagine our distributed system is a vast, complex climate system. Individual service calls are like local weather events—some sunny and fast (low latency), others stormy and slow (high latency). The **Performance Analytics & Anomaly Detection** component acts as our **weather forecaster**.\n\nA good weather forecaster doesn't just report today's temperature; they:\n1. **Know historical patterns**: They understand that 85°F is normal for July but alarming for December.\n2. **Detect anomalies**: They spot a sudden pressure drop indicating an approaching storm (a latency spike).\n3. **Provide probabilistic forecasts**: They calculate there's a 90% chance of rain (a 90% likelihood this latency regression is real, not random noise).\n4. **Differentiate local vs. global phenomena**: They know a thunderstorm in one valley doesn't mean the entire continent is experiencing bad weather (a problem in one service vs. system-wide degradation).\n\nSimilarly, our analytics engine must:\n- **Calculate what's \"normal\"** by establishing baselines from historical data for each service and operation.\n- **Detect \"unusual weather\"** by comparing current performance against those baselines using statistical methods.\n- **Focus on the right signals** by distinguishing between expected variations (daily traffic patterns) and true anomalies (cascading failures).\n- **Provide actionable insights** by correlating anomalies with specific services, operations, and trace characteristics.\n\nThis mental model helps us understand why simply calculating averages isn't enough—we need context-aware, statistical analysis that understands both the current state and historical patterns of our distributed system's \"weather.\"\n\n### Algorithms: Percentile Calculation and Anomaly Detection\n\nThe analytics engine performs two core computations: **streaming percentile calculation** for real-time performance metrics and **statistical anomaly detection** to flag deviations from normal patterns.\n\n#### Percentile Calculation with T-Digest\n\nTraditional percentile calculation requires storing all data points, which is impossible for high-volume tracing systems. We need an algorithm that can provide accurate percentile estimates from streaming data with bounded memory.\n\n**The t-digest algorithm** solves this by clustering similar data points. Think of it as creating a histogram that automatically adjusts its bucket sizes: where data is dense (many similar latency values), buckets are narrow and precise; where data is sparse (outliers), buckets are wider but still capture the distribution tails accurately.\n\n| Algorithm Step | Description | Purpose |\n|----------------|-------------|---------|\n| 1. **Initialize t-digest** | Create an empty t-digest structure with a compression parameter (typically δ=100-1000). | Sets up the data structure with desired accuracy/memory trade-off. |\n| 2. **Add value** | For each incoming latency measurement, find the nearest centroid in the t-digest. If adding the value would exceed size limits for that centroid's weight, create a new centroid. | Incorporates new data while maintaining the size bounds of the data structure. |\n| 3. **Merge centroids** | Periodically merge adjacent centroids when their combined weight doesn't violate the size constraint based on the quantile they represent. | Maintains the compression guarantee and prevents unbounded growth. |\n| 4. **Query percentile** | To find the p-th percentile (e.g., p95), traverse the sorted centroids, summing weights until reaching p% of total weight, then interpolate between centroids. | Provides accurate percentile estimates without storing all raw data. |\n\nThe key advantage is **bounded memory**: a t-digest with compression parameter δ=100 uses roughly 100 centroids regardless of how many data points are added, making it ideal for long-running services that process millions of latency measurements.\n\n#### Anomaly Detection with Statistical Methods\n\nOnce we have current percentiles, we need to determine if they represent anomalous behavior. We use multiple statistical techniques in combination:\n\n**1. Z-Score Method for Point Anomalies**\nFor detecting sudden spikes or drops in metrics like error rate or latency.\n\n| Step | Description | Mathematical Formulation |\n|------|-------------|--------------------------|\n| 1. **Establish baseline** | Calculate mean (μ) and standard deviation (σ) from historical data for the same time window (e.g., same hour last week). | μ = Σx/n, σ = √(Σ(x-μ)²/(n-1)) |\n| 2. **Compute z-score** | For current value x, calculate how many standard deviations it is from the mean. | z = (x - μ) / σ |\n| 3. **Flag anomaly** | If |z| exceeds threshold (typically 2-3), flag as anomaly. | |z| > threshold |\n\n**2. Moving Average with Control Limits for Trend Anomalies**\nFor detecting sustained deviations rather than single-point spikes.\n\n| Component | Description | Purpose |\n|-----------|-------------|---------|\n| **Simple Moving Average (SMA)** | Average of last n values. | Smooths short-term fluctuations to reveal trends. |\n| **Exponential Moving Average (EMA)** | Gives more weight to recent values. | More responsive to recent changes than SMA. |\n| **Upper/Lower Control Limits** | Bands set at ±k standard deviations from the moving average. | Defines the \"normal\" range for the metric. |\n| **Anomaly Condition** | Current value outside control limits for m consecutive measurements. | Reduces false positives from transient spikes. |\n\n**3. Seasonal-Trend Decomposition for Periodic Patterns**\nFor systems with daily/weekly cycles (common in web applications).\n\n| Step | Description | Output |\n|------|-------------|--------|\n| 1. **Decompose time series** | Separate historical data into: Trend (T), Seasonal (S), and Residual (R) components. | xₜ = Tₜ + Sₜ + Rₜ |\n| 2. **Forecast expected value** | Project trend forward and add appropriate seasonal component. | ŷₜ = T̂ₜ + Ŝₜ |\n| 3. **Compare actual vs. forecast** | Compute residual: eₜ = xₜ - ŷₜ. | Difference between actual and expected. |\n| 4. **Flag large residuals** | If |eₜ| exceeds threshold × σᵣ (residual std dev), flag anomaly. | Accounts for expected patterns. |\n\nIn practice, we combine these methods: z-score for immediate spike detection, moving average for sustained deviations, and seasonal decomposition to avoid false alarms during expected traffic patterns.\n\n### ADR: Time-Series Storage for Aggregates\n\n> **Decision: Use Dual-Layer Storage with Rolling In-Memory Windows and External Time-Series Database**\n\n**Context**: The analytics engine needs to store two types of data: (1) real-time aggregates for the current time window (last 1-5 minutes) for immediate anomaly detection, and (2) historical aggregates (hours, days, weeks) for baseline calculation and trend analysis. We must choose storage strategies that balance performance, accuracy, and operational complexity.\n\n**Options Considered**:\n1. **Pure in-memory rolling windows**: Store all aggregates in memory with fixed-size circular buffers.\n2. **Pure external time-series database**: Write all aggregates to a dedicated TSDB (e.g., Prometheus, InfluxDB).\n3. **Hybrid approach**: In-memory for recent data with periodic flush to external TSDB.\n\n**Decision**: We chose **Option 3: Hybrid approach** with the following implementation:\n- **Short-term (last 1 hour)**: In-memory ring buffers per (service, operation) tuple, updated in real-time.\n- **Long-term (beyond 1 hour)**: Flushed to an external time-series database with configurable retention policies.\n\n**Rationale**:\n1. **Latency requirements**: Real-time anomaly detection needs sub-second query latency for the current window, which in-memory storage provides.\n2. **Historical analysis needs**: Baseline calculation requires days/weeks of data, which exceeds practical memory limits.\n3. **Cost-effectiveness**: External TSDBs optimize storage for time-series data (compression, downsampling) better than a custom solution.\n4. **Operational simplicity**: Using a battle-tested TSDB for long-term storage reduces maintenance burden compared to building our own durable storage layer.\n5. **Data durability**: In-memory data is volatile; periodic flushing to durable storage prevents data loss during restarts.\n\n**Consequences**:\n- ✅ **Low-latency real-time analytics** for current time window.\n- ✅ **Scalable historical storage** using specialized TSDB.\n- ✅ **Data persistence** across service restarts.\n- ⚠️ **Added complexity** of two storage layers with synchronization logic.\n- ⚠️ **Eventual consistency** for historical queries (data appears after flush interval).\n- ⚠️ **Dependency** on external TSDB for long-term data.\n\n| Storage Option | Pros | Cons | Chosen? |\n|----------------|------|------|---------|\n| **Pure in-memory rolling windows** | - Extremely fast reads/writes<br>- No external dependencies<br>- Simple implementation | - Limited history (memory-bound)<br>- Data lost on restart<br>- No downsampling for long retention | ❌ |\n| **Pure external time-series database** | - Unlimited history with retention policies<br>- Built-in downsampling/aggregation<br>- Durable storage | - Higher latency for real-time queries<br>- External dependency failure modes<br>- Network overhead for every write | ❌ |\n| **Hybrid approach (in-memory + TSDB)** | - Fast real-time window queries<br>- Scalable historical storage<br>- Data persistence through flushing<br>- Best of both worlds | - Two storage systems to maintain<br>- Synchronization complexity<br>- Slight delay for historical data availability | ✅ |\n\n### Common Pitfalls in Analytics\n\n⚠️ **Pitfall 1: The \"Percentile of Percentiles\" Fallacy**\n- **Description**: Calculating percentiles across services incorrectly by taking the p95 of each service's p95 latencies. For example: Service A has p95=100ms, Service B has p95=200ms, so you report \"system p95 = 150ms\" (average) or \"system p95 = 200ms\" (max).\n- **Why it's wrong**: Percentiles are not linear or commutative. The true p95 latency for requests flowing through both services requires analyzing the end-to-end latency distribution, not combining service-level percentiles. This fallacy gives misleading performance summaries.\n- **How to fix**: Calculate percentiles from the **root span durations** (end-to-end request time) or use statistical methods that properly combine distributions (like convolution or Monte Carlo simulation if you have the raw data).\n\n⚠️ **Pitfall 2: False Positives During Deployments and Traffic Changes**\n- **Description**: Anomaly detection systems triggering alerts during planned deployments, traffic spikes (flash sales), or daily cycles, even though these are expected events.\n- **Why it's wrong**: These false alarms cause \"alert fatigue\" where teams start ignoring alerts, potentially missing real issues. It wastes engineering time investigating expected behavior.\n- **How to fix**:\n  1. **Maintenance windows**: Suppress alerts during known deployment periods.\n  2. **Traffic-aware baselines**: Use seasonal decomposition to account for daily/weekly patterns.\n  3. **Change detection integration**: Correlate anomalies with deployment markers in the CI/CD pipeline.\n  4. **Adaptive thresholds**: Increase sensitivity during stable periods, decrease during known volatile periods.\n\n⚠️ **Pitfall 3: Baseline Drift Over Time**\n- **Description**: As systems evolve (new features, optimizations, infrastructure changes), what was \"normal\" last month may no longer be relevant. Using stale baselines causes either missed anomalies (if performance degrades gradually) or false positives (if improvements make old baselines too pessimistic).\n- **Why it's wrong**: Static baselines become increasingly inaccurate over time, reducing the effectiveness of anomaly detection.\n- **How to fix**:\n  1. **Exponential decay**: Weight recent data more heavily than old data when calculating baselines.\n  2. **Change point detection**: Automatically detect significant shifts in performance characteristics and reset baselines.\n  3. **Manual baseline updates**: Allow operators to mark periods as \"new normal\" after verified changes.\n  4. **Multiple baseline windows**: Compare against both recent (last 24h) and longer-term (last week) baselines to distinguish temporary shifts from permanent changes.\n\n⚠️ **Pitfall 4: Ignoring Statistical Power and Confidence**\n- **Description**: Making anomaly decisions with insufficient data. For example, flagging a \"500% increase in error rate\" when going from 1 error in 1000 requests to 5 errors in 1000 requests—statistically insignificant yet appears dramatic.\n- **Why it's wrong**: Small sample sizes lead to high variance and unreliable conclusions. A system might appear \"anomalous\" purely due to random chance with low traffic volumes.\n- **How to fix**:\n  1. **Minimum sample thresholds**: Require at least N requests (e.g., 100) in a time window before evaluating anomalies.\n  2. **Confidence intervals**: Calculate and display the uncertainty around metrics (e.g., \"error rate: 0.5% ± 0.2% with 95% confidence\").\n  3. **Bayesian methods**: Incorporate prior beliefs about expected rates, which naturally handles low-traffic services better than frequentist statistics.\n\n### Implementation Guidance for Analytics\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Percentile Algorithm** | Pre-implemented t-digest library (`github.com/caio/go-tdigest`) | Custom t-digest implementation with optimizations for sparse data |\n| **Time-Series Storage** | In-memory ring buffers + CSV file export | In-memory buffers + Prometheus remote write protocol |\n| **Anomaly Detection** | Z-score + moving average implemented manually | Statistical libraries (`github.com/montanaflynn/stats`) + machine learning (Isolation Forest) |\n| **Alerting** | Simple HTTP webhook notifications | Dedicated alert manager (Prometheus Alertmanager integration) |\n| **Visualization** | Built-in metrics endpoint returning JSON | Grafana dashboard with pre-configured panels |\n\n#### B. Recommended File/Module Structure\n\n```\nproject-root/\n├── cmd/\n│   └── analytics-engine/\n│       └── main.go                 # Analytics service entry point\n├── internal/\n│   ├── analytics/\n│   │   ├── aggregator.go           # Main percentile aggregator\n│   │   ├── tdigest.go              # T-digest wrapper/implementation\n│   │   ├── anomaly/\n│   │   │   ├── detector.go         # Anomaly detection coordinator\n│   │   │   ├── zscore.go           # Z-score detector\n│   │   │   ├── moving_avg.go       # Moving average detector\n│   │   │   └── seasonal.go         # Seasonal decomposition detector\n│   │   ├── storage/\n│   │   │   ├── interface.go        # Storage interface\n│   │   │   ├── memory_store.go     # In-memory ring buffer storage\n│   │   │   └── tsdb_client.go      # External TSDB client\n│   │   ├── baseline/\n│   │   │   ├── calculator.go       # Baseline calculation\n│   │   │   └── manager.go          # Baseline lifecycle management\n│   │   └── alert/\n│   │       ├── evaluator.go        # Alert condition evaluation\n│   │       └── notifier.go         # Alert notification dispatch\n│   └── models/                     # Shared data models\n│       └── analytics.go            # Analytics-specific types\n└── config/\n    └── analytics.yaml              # Analytics configuration\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete T-Digest Wrapper** (ready to use):\n\n```go\n// internal/analytics/tdigest.go\npackage analytics\n\nimport (\n    \"github.com/caio/go-tdigest\"\n    \"sync\"\n    \"time\"\n)\n\n// TDigestMetric maintains a t-digest for streaming percentile calculation\ntype TDigestMetric struct {\n    digest    *tdigest.TDigest\n    mu        sync.RWMutex\n    count     int64\n    lastReset time.Time\n}\n\n// NewTDigestMetric creates a new metric with specified compression\nfunc NewTDigestMetric(compression float64) (*TDigestMetric, error) {\n    digest, err := tdigest.New(tdigest.Compression(compression))\n    if err != nil {\n        return nil, err\n    }\n    return &TDigestMetric{\n        digest:    digest,\n        lastReset: time.Now(),\n    }, nil\n}\n\n// Add adds a value to the distribution\nfunc (t *TDigestMetric) Add(value float64) {\n    t.mu.Lock()\n    defer t.mu.Unlock()\n    t.digest.Add(value)\n    t.count++\n}\n\n// Quantile returns the estimated value at the given quantile (0.0-1.0)\nfunc (t *TDigestMetric) Quantile(q float64) float64 {\n    t.mu.RLock()\n    defer t.mu.RUnlock()\n    return t.digest.Quantile(q)\n}\n\n// Count returns the number of observations\nfunc (t *TDigestMetric) Count() int64 {\n    t.mu.RLock()\n    defer t.mu.RUnlock()\n    return t.count\n}\n\n// Reset clears the distribution and resets counters\nfunc (t *TDigestMetric) Reset() {\n    t.mu.Lock()\n    defer t.mu.Unlock()\n    t.digest.Reset()\n    t.count = 0\n    t.lastReset = time.Now()\n}\n```\n\n**Complete In-Memory Time-Series Storage** (ready to use):\n\n```go\n// internal/analytics/storage/memory_store.go\npackage storage\n\nimport (\n    \"container/ring\"\n    \"sync\"\n    \"time\"\n)\n\n// MetricPoint represents a single data point in a time series\ntype MetricPoint struct {\n    Timestamp time.Time\n    Value     float64\n    Labels    map[string]string // e.g., {\"service\": \"api\", \"operation\": \"GET /users\"}\n}\n\n// MemoryStore implements in-memory ring buffer storage for recent metrics\ntype MemoryStore struct {\n    buffers   map[string]*ring.Ring // key: metric+labels hash\n    mu        sync.RWMutex\n    maxPoints int\n    ttl       time.Duration\n}\n\n// NewMemoryStore creates a new in-memory store with given capacity\nfunc NewMemoryStore(maxPoints int, ttl time.Duration) *MemoryStore {\n    return &MemoryStore{\n        buffers:   make(map[string]*ring.Ring),\n        maxPoints: maxPoints,\n        ttl:       ttl,\n    }\n}\n\n// Write adds a metric point to the appropriate ring buffer\nfunc (m *MemoryStore) Write(point MetricPoint) error {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    \n    key := m.hashKey(point.Labels)\n    \n    // Get or create ring buffer\n    buffer, exists := m.buffers[key]\n    if !exists {\n        buffer = ring.New(m.maxPoints)\n        m.buffers[key] = buffer\n    }\n    \n    // Advance and set value\n    buffer = buffer.Next()\n    buffer.Value = point\n    m.buffers[key] = buffer\n    \n    return nil\n}\n\n// Read returns all points within the time range for given labels\nfunc (m *MemoryStore) Read(labels map[string]string, start, end time.Time) ([]MetricPoint, error) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    \n    key := m.hashKey(labels)\n    buffer, exists := m.buffers[key]\n    if !exists {\n        return []MetricPoint{}, nil\n    }\n    \n    var points []MetricPoint\n    buffer.Do(func(value interface{}) {\n        if value == nil {\n            return\n        }\n        point := value.(MetricPoint)\n        if !point.Timestamp.Before(start) && !point.Timestamp.After(end) {\n            points = append(points, point)\n        }\n    })\n    \n    return points, nil\n}\n\n// hashKey creates a simple string key from labels map\nfunc (m *MemoryStore) hashKey(labels map[string]string) string {\n    // Simple implementation - for production use a proper hash\n    var key string\n    for k, v := range labels {\n        key += k + \"=\" + v + \";\"\n    }\n    return key\n}\n\n// cleanup removes expired buffers (call this periodically)\nfunc (m *MemoryStore) cleanup() {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    \n    cutoff := time.Now().Add(-m.ttl)\n    for key, buffer := range m.buffers {\n        // Check if buffer has recent data\n        recent := false\n        buffer.Do(func(value interface{}) {\n            if value == nil {\n                return\n            }\n            point := value.(MetricPoint)\n            if point.Timestamp.After(cutoff) {\n                recent = true\n            }\n        })\n        \n        if !recent {\n            delete(m.buffers, key)\n        }\n    }\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**Percentile Aggregator** (learner implements TODOs):\n\n```go\n// internal/analytics/aggregator.go\npackage analytics\n\nimport (\n    \"context\"\n    \"time\"\n    \n    \"github.com/your-project/internal/models\"\n)\n\n// PercentileAggregator maintains t-digests for service/operation latency percentiles\ntype PercentileAggregator struct {\n    // digests is a map of key(service+operation) -> TDigestMetric\n    digests map[string]*TDigestMetric\n    mu      sync.RWMutex\n    window  time.Duration\n}\n\n// NewPercentileAggregator creates a new aggregator with the given time window\nfunc NewPercentileAggregator(window time.Duration) *PercentileAggregator {\n    // TODO 1: Initialize the digests map\n    // TODO 2: Set up a background goroutine to reset digests after each window\n    // TODO 3: Return the initialized aggregator\n    return nil\n}\n\n// ProcessSpan updates percentiles with data from a completed span\nfunc (p *PercentileAggregator) ProcessSpan(ctx context.Context, span models.Span) error {\n    // TODO 1: Extract service name and operation name from span\n    // TODO 2: Create a unique key from service+operation\n    // TODO 3: Get or create a TDigestMetric for this key\n    // TODO 4: Add the span's duration (converted to milliseconds) to the digest\n    // TODO 5: Update any internal statistics counters\n    // TODO 6: Return nil on success or appropriate error\n    return nil\n}\n\n// GetPercentiles returns current percentile values for a service/operation\nfunc (p *PercentileAggregator) GetPercentiles(ctx context.Context, service, operation string) (p50, p95, p99 time.Duration, err error) {\n    // TODO 1: Construct the lookup key from service+operation\n    // TODO 2: Acquire read lock on the digests map\n    // TODO 3: Find the TDigestMetric for this key\n    // TODO 4: If not found, return zero values with appropriate error\n    // TODO 5: Query the digest for 0.5, 0.95, and 0.99 quantiles\n    // TODO 6: Convert the float64 results back to time.Duration\n    // TODO 7: Return the three percentile values\n    return 0, 0, 0, nil\n}\n\n// ResetWindow clears all digests and starts a new aggregation window\nfunc (p *PercentileAggregator) ResetWindow() {\n    // TODO 1: Acquire write lock on digests map\n    // TODO 2: For each TDigestMetric in the map, call Reset()\n    // TODO 3: Optionally, log statistics about the completed window\n    // TODO 4: Release lock\n}\n```\n\n**Anomaly Detector** (learner implements TODOs):\n\n```go\n// internal/analytics/anomaly/detector.go\npackage anomaly\n\nimport (\n    \"context\"\n    \"time\"\n)\n\n// Detector evaluates metrics against baselines to detect anomalies\ntype Detector struct {\n    baselineCalc BaselineCalculator\n    methods      []DetectionMethod\n    thresholds   map[string]float64\n}\n\n// DetectionMethod is an interface for different anomaly detection algorithms\ntype DetectionMethod interface {\n    Detect(current, historical []float64) (bool, float64, error)\n    Name() string\n}\n\n// NewDetector creates a new anomaly detector with configured methods\nfunc NewDetector(baselineCalc BaselineCalculator) *Detector {\n    // TODO 1: Initialize with provided baseline calculator\n    // TODO 2: Set up default detection methods (z-score, moving average)\n    // TODO 3: Set default thresholds for each method\n    // TODO 4: Return initialized detector\n    return nil\n}\n\n// CheckMetric evaluates a current metric value for anomalies\nfunc (d *Detector) CheckMetric(ctx context.Context, metricName string, labels map[string]string, currentValue float64) ([]AnomalyResult, error) {\n    // TODO 1: Retrieve historical values for this metric+labels from storage\n    // TODO 2: If insufficient historical data, return empty result (no decision)\n    // TODO 3: For each detection method in d.methods:\n    //   a. Call Detect() with current value and historical values\n    //   b. If detection returns true, create AnomalyResult record\n    // TODO 4: Aggregate results from all methods (e.g., majority vote)\n    // TODO 5: Return slice of anomaly results\n    return nil, nil\n}\n\n// AnomalyResult represents a single anomaly detection outcome\ntype AnomalyResult struct {\n    Metric      string\n    Labels      map[string]string\n    Timestamp   time.Time\n    Value       float64\n    Expected    float64 // baseline value\n    Confidence  float64 // 0.0-1.0 confidence in detection\n    Method      string  // which detection method flagged it\n    Severity    string  // \"warning\", \"critical\"\n}\n\n// BaselineCalculator computes expected values from historical data\ntype BaselineCalculator interface {\n    Calculate(ctx context.Context, metricName string, labels map[string]string, t time.Time) (float64, error)\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **Go Concurrency Patterns**: Use `sync.RWMutex` for the percentile aggregator's digests map since reads (percentile queries) are more frequent than writes (span processing).\n\n2. **Time Handling**: Use `time.Duration` consistently for all latency values. Convert to `float64` milliseconds for t-digest storage: `ms := float64(span.Duration.Milliseconds())`.\n\n3. **Context Propagation**: Pass `context.Context` through all method calls to enable proper cancellation and timeout handling, especially for TSDB queries.\n\n4. **Error Wrapping**: Use `fmt.Errorf` with `%w` to wrap errors: `return fmt.Errorf(\"failed to query baseline: %w\", err)`.\n\n5. **Efficient Map Keys**: For the `digests` map key, use a precomputed string: `key := fmt.Sprintf(\"%s:%s\", service, operation)` or use a struct key with custom hash function for better performance.\n\n6. **Background Goroutines**: Use `time.Ticker` for periodic tasks like window resetting: \n   ```go\n   ticker := time.NewTicker(p.window)\n   defer ticker.Stop()\n   for range ticker.C {\n       p.ResetWindow()\n   }\n   ```\n\n#### F. Milestone Checkpoint\n\nAfter implementing the Performance Analytics component, verify functionality with these steps:\n\n1. **Start the analytics engine**:\n   ```bash\n   go run cmd/analytics-engine/main.go --config config/analytics.yaml\n   ```\n\n2. **Send test spans with varying latencies**:\n   ```bash\n   # Use a test script to send 1000 spans with latencies following normal distribution\n   ./scripts/send_test_spans.go --count 1000 --mean-latency 100ms --std-dev 20ms\n   ```\n\n3. **Query percentiles via API**:\n   ```bash\n   curl \"http://localhost:8081/analytics/percentiles?service=api&operation=GET%2Fusers\"\n   ```\n   **Expected output** (example):\n   ```json\n   {\n     \"service\": \"api\",\n     \"operation\": \"GET /users\",\n     \"p50\": \"98ms\",\n     \"p95\": \"142ms\",\n     \"p99\": \"165ms\",\n     \"sample_count\": 1000,\n     \"window_start\": \"2023-10-01T10:00:00Z\",\n     \"window_end\": \"2023-10-01T10:05:00Z\"\n   }\n   ```\n\n4. **Trigger an anomaly detection**:\n   ```bash\n   # Send spans with suddenly high latency\n   ./scripts/send_test_spans.go --count 50 --mean-latency 500ms --std-dev 100ms\n   ```\n   Check logs for anomaly alerts:\n   ```\n   INFO anomaly detected: service=api operation=GET /users current=512ms expected=105ms z-score=4.2\n   ```\n\n5. **Verify baseline calculation**:\n   ```bash\n   curl \"http://localhost:8081/analytics/baselines?service=api&operation=GET%2Fusers\"\n   ```\n   Should return historical percentiles for comparison.\n\n**Signs of issues**:\n- Percentiles stuck at 0: Likely span processing not working; check `ProcessSpan` implementation.\n- Anomaly alerts never firing: Check detection thresholds and baseline calculation.\n- Memory usage growing unbounded: Verify t-digest compression and ring buffer size limits.\n- \"No historical data\" errors: Ensure time-series storage is properly flushing to persistent storage.\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Percentiles don't match expected values** | Incorrect t-digest compression parameter or insufficient data | 1. Check sample count in aggregator<br>2. Verify span durations are being added correctly<br>3. Test t-digest with known dataset | Adjust compression parameter (higher = more accurate), ensure minimum samples before trusting percentiles |\n| **Anomaly detector fires during normal traffic patterns** | Baseline doesn't account for daily cycles | 1. Check if alerts cluster at same time daily<br>2. Compare current time to historical same-hour data | Implement seasonal decomposition or time-of-day aware baselines |\n| **High memory usage in analytics engine** | Too many t-digest instances or large ring buffers | 1. Check number of unique service+operation combinations<br>2. Monitor buffer sizes<br>3. Profile heap usage | Limit cardinality (e.g., ignore high-cardinality operation names), reduce buffer sizes, implement LRU eviction |\n| **\"No baseline data\" errors for valid services** | Flushing to TSDB failing or retention too short | 1. Check TSDB connection logs<br>2. Verify data exists in TSDB for time ranges<br>3. Check flush interval configuration | Fix TSDB connectivity, adjust retention policies, implement fallback to recent window if no history |\n| **Delayed anomaly detection (>5 minutes)** | Aggregation window too long or detection runs infrequently | 1. Check window duration configuration<br>2. Monitor detection cycle timing<br>3. Check for blocking operations in pipeline | Reduce window size, run detection more frequently, pipeline spans for lower latency |\n| **False positives during deployments** | Baseline includes pre-deployment performance | 1. Check if deployment timestamps correlate with alerts<br>2. Compare pre/post-deployment baselines | Implement deployment markers, suppress alerts during known changes, use shorter baseline windows during volatile periods |\n\n---\n\n\n> **Milestone(s):** This section corresponds to Milestone 5: APM SDK & Auto-Instrumentation, which designs the client-side library that automatically instruments application code to generate and propagate traces.\n\n## 9. Component Design: APM SDK & Auto-Instrumentation (Milestone 5)\n\nThe **APM SDK** is the client-side library embedded within each monitored service. Its primary responsibility is to automatically instrument application code—intercepting HTTP requests, database queries, and framework operations—to create **spans** and propagate the **trace context** across service boundaries without requiring significant manual code changes from developers. This component transforms opaque, unobserved service interactions into a rich stream of structured telemetry data that feeds the entire APM system.\n\n### Mental Model: The Invisible Flight Recorder\n\nImagine every application service as an aircraft equipped with a **Flight Data Recorder (FDR)**, commonly known as a \"black box.\" This recorder automatically and continuously monitors critical systems: engine performance, control surface positions, communication channels, and pilot inputs. It does not require the pilot to manually log each event; instead, it's always on, passively observing and recording. When investigating an incident or analyzing performance, engineers rely on this objective, detailed record of events to reconstruct exactly what happened.\n\nThe APM SDK functions as this **Invisible Flight Recorder** for your software. It is embedded within the application process and automatically \"records\" the journey of each request (the \"flight\") as it passes through various components (engines, controls). It captures:\n*   **Takeoff and Landing (Request Start/End):** When a request enters and leaves a service.\n*   **Control Inputs (Business Logic):** Key operations and decisions within the service.\n*   **Subsystem Interactions (Outgoing Calls):** Calls to databases, external APIs, or message queues.\n*   **Environmental Conditions (Context):** Metadata like user ID, deployment version, and hostname.\n\nJust as a flight recorder must be utterly reliable and add minimal weight to the aircraft, the SDK must be robust and have negligible performance overhead. It must also ensure that the recording (the **trace context**) is copied and carried forward whenever the aircraft (request) communicates with another vessel (service), creating a continuous, unbroken chain of evidence across the entire distributed system.\n\n### Instrumentation Techniques: Monkey Patching and Middleware\n\nAutomatic instrumentation works by intercepting normal application execution at strategic points. Two primary techniques are used, each suited to different layers of the stack.\n\n| Technique | Application Layer | How It Works | Key Consideration |\n| :--- | :--- | :--- | :--- |\n| **Middleware / Interceptors** | HTTP Frameworks (Gin, Express), gRPC, Message Queues | The SDK injects itself into the framework's request-handling pipeline. For incoming requests, it creates a root span, extracts the trace context from headers, and makes the context available to the application's handler. For outgoing requests, it wraps the HTTP client or gRPC stub to inject the current trace context into headers before sending. | This is the **preferred, non-invasive method**. It leverages the framework's own extension points (e.g., Gin's `Use()` method, `http.RoundTripper` interface in Go). |\n| **Monkey Patching** | Database Drivers, Low-level Networking Libraries | The SDK temporarily replaces (or \"wraps\") the original functions or methods of a library (e.g., `sql.DB.QueryContext`) with its own versions. The wrapper function creates a child span, records the operation (e.g., the SQL query), calls the original function, records the duration and any error, and then closes the span. | This technique is more **invasive and risky**. It must be done carefully to avoid breaking the original library's behavior, causing memory leaks, or losing the context in asynchronous operations. It's often used for libraries that don't provide a native middleware interface. |\n| **Code Generation / Compile-time Weaving** | All Layers (Advanced) | Instead of modifying behavior at runtime, instrumentation code is injected at compile time. This can be done via code generation (e.g., creating wrapped clients) or through compiler plugins. | This approach can offer **optimal performance and safety** as the instrumentation is \"baked in,\" but it requires more complex build tooling and is language/framework specific. For our initial SDK, we will focus on runtime techniques. |\n\nThe SDK's internal architecture for a Go service might look like this, coordinating these techniques:\n![Diagram Title](./diagrams/sdk-instrumentation-comp.svg)\n\n**The Core Tracer:** At the heart of the SDK is a singleton or factory-managed **Tracer** object. It is responsible for:\n1.  **Span Creation:** Generating new `Span` instances with unique IDs and linking them to a parent based on the current context.\n2.  **Context Management:** Maintaining a stack or bag of key-value pairs (the `Attributes`) and the current active span for the duration of a request.\n3.  **Span Export:** Batching completed spans and sending them asynchronously to the Collector via the configured transport (HTTP/gRPC).\n\n**The Instrumentation Process:**\n1.  **HTTP Server (Incoming Request):** A Gin middleware (`APMMiddleware`) is registered via `router.Use()`. For each request:\n    1.  It extracts the W3C Trace Context headers (`traceparent`, `tracestate`).\n    2.  It calls `tracer.StartSpanFromContext(ctx, \"HTTP GET /api/users\")` to create a server-side span. If headers are present, the span becomes a child of the remote parent; otherwise, it starts a new trace.\n    3.  It stores the new span in the Go `context.Context` and passes this context to the next handler.\n    4.  After the handler completes, the middleware records the HTTP status code as an attribute, sets the span status (error if 5xx), and calls `span.End()`.\n2.  **Database Query:** The `database/sql` driver is wrapped via monkey patching at SDK initialization.\n    1.  When the application calls `db.QueryContext(ctx, \"SELECT ...\")`, the wrapped driver intercepts the call.\n    2.  It uses the `ctx` to find the current active trace and calls `tracer.StartSpanFromContext(ctx, \"sql.query\")` to create a child span.\n    3.  It adds attributes: `db.system=\"postgresql\"`, `db.statement` (the sanitized query).\n    4.  It executes the original query, records the duration, adds an error attribute if the query failed, and ends the span.\n3.  **HTTP Client (Outgoing Request):** The SDK wraps the default `http.Client.Transport`.\n    1.  When the app makes an outgoing request via `http.Get`, the wrapped transport's `RoundTrip` method is called.\n    2.  It gets the current span context from the request's `context.Context`.\n    3.  It injects the trace context into the request headers (`traceparent`, `tracestate`).\n    4.  It creates a child \"http.client\" span, executes the request, records the duration and status, and ends the span.\n\n### ADR: Context Propagation Mechanism\n\n> **Decision: Use Go's Native `context.Context` for In-Process Propagation and W3C Trace Context for Cross-Service Propagation**\n>\n> *   **Context:** In a distributed trace, the `TraceID` and `ParentSpanID` must be carried from one span to its child, both within the same process (e.g., from an HTTP server span to a database span) and across process boundaries (e.g., from Service A's HTTP client span to Service B's HTTP server span). We need a mechanism that is idiomatic, efficient, and correct for concurrent Go code.\n> *   **Options Considered:**\n>     1.  **Explicit Parameter Passing:** Require developers to manually pass a `Trace` or `Span` object through every function call. This is explicit but burdensome and breaks existing code.\n>     2.  **Thread-Local Storage (TLS):** Use Goroutine-local storage (simulated via maps keyed by goroutine ID). This is fragile because goroutines are multiplexed and a single request may be handled by multiple goroutines. Context can easily be lost.\n>     3.  **Go's `context.Context`:** Use the standard library's `context.Context` interface to store and retrieve the current span. This is the idiomatic pattern for request-scoped values in Go and is designed to work with cancellation and deadlines.\n> *   **Decision:** We will use **Go's `context.Context`** for propagation within a single service. For propagation across service boundaries (over HTTP/gRPC), we will use the **W3C Trace Context** standard headers (`traceparent`, `tracestate`).\n> *   **Rationale:** `context.Context` is the canonical way to pass request-scoped data in Go. It is used by virtually all major frameworks and libraries (Gin, gRPC, `database/sql`), making integration seamless. It is concurrency-safe when passed correctly. The W3C standard ensures interoperability with other tracing systems and languages, future-proofing our implementation.\n> *   **Consequences:**\n>     *   **Enables:** Clean, framework-agnostic instrumentation. Developers can manually create spans in their business logic by calling `tracer.StartSpanFromContext(ctx, ...)`. The SDK automatically propagates context in instrumented HTTP/database calls.\n>     *   **Requires:** Application code must accept and pass a `context.Context` through its call chain, which is already a best practice in modern Go. The SDK must provide utilities to extract and inject the trace context from/to a `context.Context`.\n\nThe following table summarizes the key differences between the considered options:\n\n| Option | Pros | Cons | Viability |\n| :--- | :--- | :--- | :--- |\n| **Explicit Parameter Passing** | Utterly explicit, no magic. Easy to reason about. | Extremely invasive API. Requires massive refactoring of existing code. Breaks third-party library compatibility. | ❌ Rejected |\n| **Thread-Local Storage (Goroutine-local)** | Conceptually simple for linear, non-concurrent code. | Goroutines are not 1:1 with threads. Context is lost on any goroutine switch (e.g., using `go` keyword, `async`). Highly error-prone and anti-pattern in Go. | ❌ Rejected |\n| **Go's `context.Context`** | Idiomatic and standard. Supported by all major libraries. Designed for request-scoped values and cancellation. Integrates perfectly with middleware patterns. | Requires that the application uses `context.Context` (which is a best practice). Slight learning curve for developers unfamiliar with context. | ✅ **Chosen** |\n\n### Common Pitfalls in SDK Development\n\nBuilding a reliable, low-overhead auto-instrumentation SDK is fraught with subtle challenges. Awareness of these pitfalls is crucial.\n\n⚠️ **Pitfall 1: Performance Overhead from Excessive Allocation and Locking**\n*   **Description:** Creating a span involves allocating several objects (`SpanID`, `TraceID`, `Attributes` map, `Events` slice). If done naively for every database query in a high-throughput service, the garbage collection pressure and locking within the tracer can become significant, effectively slowing down the application it's meant to observe.\n*   **Why It's Wrong:** An APM tool should be observational, not impactful. High overhead makes developers reluctant to enable tracing in production, defeating its purpose.\n*   **How to Fix:**\n    *   **Object Pooling:** Use `sync.Pool` to reuse `Span` and auxiliary objects, reducing allocations.\n    *   **Asynchronous Export:** Never block the application thread to send spans to the collector. Use a buffered channel and a dedicated exporter goroutine.\n    *   **Sampling at the Source:** Integrate with the head-based sampler. If a trace is not sampled, avoid creating any span objects or attributes for it entirely.\n\n⚠️ **Pitfall 2: Context Loss in Concurrent and Asynchronous Code**\n*   **Description:** In Go, when you launch a new goroutine with `go myFunction()`, the new goroutine does not automatically inherit the `context.Context` (and thus the current span) from the parent goroutine. If `myFunction` makes a database call, it will appear as a new, rootless trace fragment, breaking the parent-child relationship.\n*   **Why It's Wrong:** This destroys the continuity of the trace, making it impossible to understand the causal relationship between the initial request and the work done in the goroutine. Critical debugging context is lost.\n*   **How to Fix:** The SDK must provide clear guidance and utilities. For example, provide a helper: `ctx := tracer.ContextWithSpan(context.Background(), currentSpan)` and instruct developers to pass this `ctx` to the new goroutine. For popular async frameworks or worker pools, the SDK can offer specific integrations that automatically propagate context.\n\n⚠️ **Pitfall 3: Unsafe Monkey Patching that Breaks Host Application**\n*   **Description:** Replacing a library's function pointer globally can have unintended side effects: it can break other parts of the application that rely on the original function's behavior, cause deadlocks if the wrapper introduces synchronization, or fail if the patching is not done atomically or at the right time (e.g., after another library has already patched the same function).\n*   **Why It's Wrong:** The SDK becomes a source of instability and weird bugs in the application, eroding trust.\n*   **How to Fix:**\n    *   **Prefer Public APIs:** Always use official middleware/interceptor interfaces if available.\n    *   **Patch Once, Lazily:** Implement patching logic that is idempotent and thread-safe. Often, this is done in an `init()` function or a dedicated `Instrument()` function called at application startup.\n    *   **Thorough Testing:** Test the wrapped behavior in isolation and in integration with the original library to ensure functional equivalence.\n\n⚠️ **Pitfall 4: Leaking Sensitive Data in Spans**\n*   **Description:** Automatically capturing all HTTP request parameters, headers, or full SQL statements can inadvertently record passwords, API keys, or personal data (PII) into the tracing system, creating a security and compliance risk.\n*   **Why It's Wrong:** This violates data privacy principles and regulations (like GDPR). The trace data, which may be viewed by many engineers or stored in less secure systems, becomes a data leak vector.\n*   **How to Fix:**\n    *   **Sanitization:** Provide built-in sanitizers for common data types. For SQL, use a parameter masking library to replace `?` placeholders with a placeholder. For HTTP, provide a configurable blocklist of headers (e.g., `Authorization`, `Cookie`) and query parameters (e.g., `password`) to omit.\n    *   **Customization:** Allow developers to define custom sanitization hooks for their application-specific sensitive fields.\n\n### Implementation Guidance for the APM SDK\n\nThis guidance provides the foundational code and structure to implement the APM SDK in Go, focusing on the patterns for middleware, context propagation, and safe monkey patching.\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (Starting Point) | Advanced Option (Production-ready) |\n| :--- | :--- | :--- |\n| **Tracer Core** | In-memory span processing with a buffered channel exporter. | Integrate with OpenTelemetry Go SDK as a provider, leveraging its battle-tested core, batching, and retry logic. |\n| **HTTP Server Middleware** | Custom middleware for the Gin framework. | Generic `net/http` middleware that works with any compatible framework (Gin, Echo, Gorilla Mux). |\n| **HTTP Client Wrapping** | Wrap the default `http.DefaultTransport`. | Implement a `http.RoundTripper` that can be set on any `http.Client`, supporting connection pooling and redirects. |\n| **Database Instrumentation** | Wrap `database/sql` driver using `sql.Register`. | Use the OpenTelemetry SQL driver wrapper (`go.opentelemetry.io/contrib/instrumentation/database/sql`). |\n| **Context Propagation** | Store current span in `context.Context` using a private key. | Implement the OpenTelemetry `propagation.TextMapPropagator` interface for W3C Trace Context. |\n\n**B. Recommended File/Module Structure**\n\nThe SDK should be organized as a separate Go module that applications can import.\n```\napm-sdk-go/                   # Root of the SDK module\n├── go.mod\n├── go.sum\n├── tracer/                   # Core tracing logic\n│   ├── tracer.go            # Main Tracer struct, Span creation\n│   ├── context.go           # Context propagation utilities (WithSpan, SpanFromContext)\n│   ├── exporter.go          # Interface and channel-based exporter to Collector\n│   └── config.go            # SDK configuration (service name, sampling rate, endpoint)\n├── instruments/             # Auto-instrumentation packages\n│   ├── http/               # HTTP instrumentation\n│   │   ├── server/         # Server-side middleware\n│   │   │   ├── gin.go      # Gin framework middleware\n│   │   │   └── middleware.go # Generic net/http middleware\n│   │   └── client/         # Client-side wrapper\n│   │       └── wrapper.go  # http.RoundTripper implementation\n│   ├── sql/                # Database instrumentation\n│   │   └── driver.go       # sql driver wrapper and registration\n│   └── grpc/               # gRPC interceptors (future)\n│       ├── client.go\n│       └── server.go\n├── propagation/            # Cross-service context propagation\n│   ├── w3c.go             # W3C Trace Context extract/inject\n│   └── propagator.go      # Propagator interface\n└── internal/              # Private utilities\n    ├── sanitize.go        # SQL/query sanitization\n    └── pool.go            # Object pools for Spans\n```\n\n**C. Infrastructure Starter Code**\n\nHere is a complete, ready-to-use implementation for the core context propagation utilities, which are a prerequisite for all instrumentation.\n\n```go\n// File: tracer/context.go\npackage tracer\n\nimport (\n    \"context\"\n)\n\ntype contextKey struct{}\n\nvar activeSpanKey = &contextKey{}\n\n// ContextWithSpan returns a new context derived from parentCtx that contains the given span.\n// This span becomes the \"active\" span for any span creation or instrumentation that uses this context.\nfunc ContextWithSpan(parentCtx context.Context, span *Span) context.Context {\n    return context.WithValue(parentCtx, activeSpanKey, span)\n}\n\n// SpanFromContext retrieves the active span from the given context.\n// It returns nil if no span is present in the context.\nfunc SpanFromContext(ctx context.Context) *Span {\n    if s, ok := ctx.Value(activeSpanKey).(*Span); ok {\n        return s\n    }\n    return nil\n}\n\n// File: propagation/w3c.go\npackage propagation\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"strings\"\n)\n\nconst (\n    TRACE_ID_HEADER = \"traceparent\"\n    // Note: SPAN_ID_HEADER is \"tracestate\" per naming conventions, but traceparent contains both trace and parent span ID.\n)\n\n// ExtractTraceContext reads the W3C Trace Context headers from a carrier (e.g., http.Request)\n// and returns a context containing the remote span context.\nfunc ExtractTraceContext(ctx context.Context, carrier TextMapCarrier) context.Context {\n    traceParent := carrier.Get(TRACE_ID_HEADER)\n    if traceParent == \"\" {\n        return ctx // No incoming context, will start a new trace.\n    }\n    // Parse traceParent format: version-traceId-parentSpanId-flags\n    parts := strings.Split(traceParent, \"-\")\n    if len(parts) != 4 {\n        // Malformed header, ignore.\n        return ctx\n    }\n    traceID := parts[1]\n    parentSpanID := parts[2]\n\n    // Here you would create a SpanContext object and attach it to the context.\n    // For simplicity, we return a context with a placeholder.\n    // In a full implementation, you would call tracer.StartSpan with the extracted parent.\n    return ctx\n}\n\n// InjectTraceContext writes the current span's context from the given context into the carrier\n// (e.g., http.Request headers) for propagation to the next service.\nfunc InjectTraceContext(ctx context.Context, carrier TextMapCarrier) error {\n    span := tracer.SpanFromContext(ctx)\n    if span == nil {\n        return nil // Nothing to inject\n    }\n    // Format: version-traceId-parentSpanId-flags (flags sampled = 01)\n    // For simplicity, we assume version 00 and sampled flag.\n    traceParent := fmt.Sprintf(\"00-%s-%s-01\", span.TraceID, span.SpanID)\n    carrier.Set(TRACE_ID_HEADER, traceParent)\n    return nil\n}\n\n// TextMapCarrier is an interface for objects that contain string key-value pairs (e.g., http.Header, metadata.MD).\ntype TextMapCarrier interface {\n    Get(key string) string\n    Set(key, value string)\n}\n```\n\n**D. Core Logic Skeleton Code**\n\nBelow is the skeleton for the core Tracer and key instrumentation components. The TODOs map directly to the algorithmic steps described in the prose.\n\n```go\n// File: tracer/tracer.go\npackage tracer\n\nimport (\n    \"context\"\n    \"crypto/rand\"\n    \"encoding/hex\"\n    \"time\"\n)\n\n// Tracer is the main entry point for creating spans and managing the export pipeline.\ntype Tracer struct {\n    serviceName string\n    exporter    SpanExporter\n    sampler     HeadSampler // Integrated head-based sampling\n}\n\n// StartSpanFromContext creates a new span as a child of the active span in the given context.\n// If no active span exists, it starts a new trace.\nfunc (t *Tracer) StartSpanFromContext(ctx context.Context, name string) (context.Context, *Span) {\n    // TODO 1: Check if the trace is already sampled (head-based decision).\n    //   - Get the traceID from the parent span if it exists, or generate a new one.\n    //   - Call t.sampler.Decide(traceID, t.serviceName) to get the sampling decision.\n    //   - If NOT sampled, return a \"no-op\" span that does nothing on End().\n\n    // TODO 2: Generate a unique SpanID (16 bytes random, hex encoded).\n\n    // TODO 3: Determine parent relationship.\n    //   - If parentSpan := SpanFromContext(ctx); parentSpan != nil, set this span's ParentSpanID and TraceID from parent.\n    //   - Otherwise, generate a new TraceID and set ParentSpanID to empty (root span).\n\n    // TODO 4: Create a new Span struct with StartTime = time.Now().\n\n    // TODO 5: Store this new span as the active span in a new context (using ContextWithSpan).\n\n    // TODO 6: Return the new context and the span.\n    return ctx, &Span{}\n}\n\n// Span represents an individual operation within a trace.\n// (Fields are defined per naming conventions; we add methods.)\ntype Span struct {\n    SpanID       string\n    TraceID      string\n    ParentSpanID string\n    Name         string\n    ServiceName  string\n    StartTime    time.Time\n    Duration     time.Duration\n    Attributes   map[string]string\n    Events       []SpanEvent\n    Status       SpanStatus\n}\n\n// End finalizes the span, records its duration, and schedules it for export.\nfunc (s *Span) End() {\n    // TODO 1: Calculate duration: time.Now() - s.StartTime.\n\n    // TODO 2: If this span is a no-op (not sampled), do nothing and return.\n\n    // TODO 3: Send the completed span to the exporter's buffer (e.g., via a channel).\n    //   - The exporter should run in a separate goroutine to batch and send spans asynchronously.\n}\n\n// File: instruments/http/client/wrapper.go\npackage http\n\nimport (\n    \"context\"\n    \"net/http\"\n    \"apm-sdk-go/tracer\"\n    \"apm-sdk-go/propagation\"\n)\n\n// WrappedTransport implements http.RoundTripper and injects trace context.\ntype WrappedTransport struct {\n    Base http.RoundTripper\n    Tracer *tracer.Tracer\n}\n\n// RoundTrip executes the HTTP request, creating a span and propagating context.\nfunc (wt *WrappedTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n    // TODO 1: Start a child span for this outgoing request.\n    //   - Use wt.Tracer.StartSpanFromContext(req.Context(), \"http.client\").\n    //   - Add attributes: \"http.method\", \"http.url\", \"peer.hostname\".\n\n    // TODO 2: Inject the current trace context into the request headers.\n    //   - Call propagation.InjectTraceContext(ctx, propagation.HeaderCarrier(req.Header)).\n\n    // TODO 3: Execute the underlying request using wt.Base.RoundTrip(req).\n\n    // TODO 4: Record the result.\n    //   - Add attribute \"http.status_code\".\n    //   - If the request failed or status >= 400, mark span status as error.\n\n    // TODO 5: End the span.\n\n    // TODO 6: Return the response and error.\n    return wt.Base.RoundTrip(req)\n}\n\n// File: instruments/sql/driver.go\npackage sql\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"database/sql/driver\"\n    \"apm-sdk-go/tracer\"\n)\n\n// WrapDriver returns a new SQL driver that instruments all queries.\nfunc WrapDriver(baseDriver driver.Driver, driverName string, tracer *tracer.Tracer) {\n    // TODO 1: Create a wrapped driver struct that implements driver.Driver interface.\n    //   - It should embed or wrap the baseDriver.\n\n    // TODO 2: Override the Open method to return a wrapped connection.\n\n    // TODO 3: Register this wrapped driver with a new name (e.g., \"instrumented-mysql\")\n    //   using sql.Register.\n\n    // The application then uses \"instrumented-mysql\" as the driver name in its DSN.\n}\n```\n\n**E. Language-Specific Hints**\n\n*   **Context is Key:** Always pass `context.Context` as the first parameter in your instrumentation functions. Use `context.TODO()` only as a placeholder during development.\n*   **Safe Concurrency with Channels:** Use a buffered channel (`chan *Span`) for the exporter. A dedicated goroutine should read from this channel, batch spans, and send them to the collector. This prevents the instrumentation from blocking the application.\n*   **Use `sync.Pool` for Spans:** Span creation is frequent. Pooling can drastically reduce allocation pressure.\n    ```go\n    var spanPool = sync.Pool{\n        New: func() interface{} { return &Span{Attributes: make(map[string]string)} },\n    }\n    ```\n*   **Monkey Patching with `sql.Register`:** The `database/sql` package is designed for wrapping. Implement the `driver.Driver` interface, wrap the original driver, and register your wrapper. This is safe and standard.\n\n**F. Milestone Checkpoint**\n\nAfter implementing the SDK and instrumenting a sample Go application (e.g., a simple Gin server that makes database calls and HTTP requests to another service), you should be able to verify:\n\n1.  **Start the instrumented application:** Run your app with the SDK initialized.\n2.  **Generate traffic:** Use `curl` or a load generator to send HTTP requests to your app.\n3.  **Check Collector logs:** Ensure spans are being received at the Collector's ingestion endpoint.\n4.  **Verify Trace Completeness:** Query the stored trace via the Collector's API. The trace should show:\n    *   A root span for the incoming HTTP request.\n    *   A child span for the database query.\n    *   A child span for any outgoing HTTP call, with the W3C headers present in the downstream service's logs.\n    *   All spans should have the same `TraceID`.\n5.  **Performance Baseline:** Measure the overhead. The 95th percentile (p95) latency of instrumented endpoints should not increase by more than 1-2% compared to non-instrumented code under load. Use a benchmark tool like `wrk` or `vegeta`.\n\n**Signs of Trouble:**\n*   **No spans in Collector:** Check that the SDK's exporter is running and can connect to the Collector endpoint. Verify the sampling rate is not 0%.\n*   **Spans are not linked (different TraceIDs):** Context propagation is broken. Verify the `SpanFromContext` and `ContextWithSpan` functions, and ensure the W3C headers are being injected and extracted correctly in HTTP clients/servers.\n*   **High memory or CPU usage in the app:** The SDK's exporter might be blocking or the object pools might be ineffective. Profile the application using `go tool pprof`.\n\n---\n\n\n## 10. Interactions and Data Flow\n\n> **Milestone(s):** This section synthesizes concepts from all five milestones (Trace Collection, Service Map, Trace Sampling, Performance Analytics, and APM SDK), illustrating how the entire system works together to transform raw instrumentation data into actionable insights. Understanding these interactions is critical for debugging the system itself and ensuring data flows correctly through the pipeline.\n\nAt its core, the APM Tracing System is a **data processing pipeline** that transforms individual spans emitted by instrumented applications into comprehensive traces, service maps, and performance insights. This section traces the complete journey of a single user request—from the moment it enters the first microservice until its performance data appears in dashboards and alerts. Think of this journey as a **documentary film crew following a character** through a complex city: the SDKs are the cameras that capture footage (spans), the collector is the editing studio that assembles the raw clips, and the analytics components are the producers who extract meaning from the final film.\n\n### Sequence: The Lifecycle of a Trace\n\nThe lifecycle of a trace can be broken down into eight distinct phases, each involving multiple system components. The following diagram illustrates the high-level component interactions:\n\n![APM System Component Diagram](./diagrams/sys-comp-diagram.svg)\n\n**Phase 1: Instrumentation and Span Creation**\n\nWhen a user request hits the first service (e.g., an API gateway), the auto-instrumented HTTP server middleware detects the incoming request and begins the trace lifecycle:\n\n1. **Context Extraction**: The SDK's HTTP middleware examines the incoming request headers for W3C Trace Context headers (`traceparent` and `tracestate`). If present, it extracts the `TraceID`, `ParentSpanID`, and trace flags. If absent (indicating this is the root of a new trace), it generates a new 128-bit `TraceID` using a cryptographically secure random number generator.\n\n2. **Root Span Creation**: The middleware creates a new `Span` object with:\n   - `SpanID`: A new 64-bit identifier for this span\n   - `TraceID`: Either extracted from headers or newly generated\n   - `ParentSpanID`: Empty for root spans, or the extracted parent span ID\n   - `Name`: The HTTP route (e.g., `GET /api/orders`)\n   - `ServiceName`: The name of the current service (from configuration)\n   - `StartTime`: Current timestamp with nanosecond precision\n   - `Attributes`: HTTP method, URL, user agent, and other request metadata\n\n3. **Context Storage**: The SDK stores this span in Go's `context.Context` using the private key `activeSpanKey`, making it accessible to all downstream function calls within the same request processing chain. This context is passed through the application's call stack.\n\n4. **Head-Based Sampling Decision**: Before adding substantial overhead, the SDK consults the configured `HeadSampler` by calling `Decide(ctx, traceID, serviceName)`. The sampler uses consistent hashing on the `TraceID` to make a deterministic decision:\n   - If the decision is **DROP**, the span is marked as `Sampled = false` and will only record minimal metadata (trace ID, span ID, sampling decision).\n   - If the decision is **KEEP**, the span proceeds with full instrumentation.\n\n**Phase 2: Context Propagation and Child Span Creation**\n\nAs the request flows through the service's internal components and makes outbound calls, the SDK automatically creates child spans:\n\n1. **Database Call**: When the service executes a SQL query through the instrumented database driver:\n   - The driver wrapper extracts the active span from the `context.Context`\n   - Creates a child span with `ParentSpanID` set to the current span's ID\n   - Records the SQL operation type, table name, and sanitized query parameters\n   - Measures query execution time from request to response\n   - On completion, calls `End()` on the span, which records the duration\n\n2. **Outbound HTTP Call**: When the service calls another microservice:\n   - The instrumented HTTP client wrapper extracts the active span context\n   - Creates a child span for the outbound request\n   - Injects the trace context into HTTP headers using `InjectTraceContext()`, setting `traceparent` header with format `00-{TraceID}-{SpanID}-{TraceFlags}`\n   - Sends the request and records response status code and timing\n   - On the receiving service, the server middleware extracts this context (as described in Phase 1), maintaining the parent-child relationship across service boundaries\n\n3. **Async Operations**: For asynchronous operations (goroutines, message queue processing), the SDK provides mechanisms to preserve trace context across async boundaries. In Go, this typically involves creating a new context from the parent span and passing it explicitly to the goroutine.\n\n**Phase 3: Span Export to Collector**\n\nWhen a span completes (via `End()` method), the SDK's `SpanExporter` component queues it for export. The export process follows this sequence:\n\n1. **Batch Assembly**: The exporter collects completed spans into batches (typically 100 spans or every 5 seconds, whichever comes first) to optimize network utilization.\n\n2. **Transport Selection**: The batch is serialized into OpenTelemetry Protocol (OTLP) format and sent via either HTTP/JSON or gRPC/protobuf to the Collector's ingestion endpoint. The diagram below shows this ingestion sequence:\n\n![Sequence: Trace Ingestion and Processing](./diagrams/ingestion-sequence.svg)\n\n3. **Network Dispatch**: The SDK transmits the batch asynchronously, with retry logic for transient network failures. If the Collector is unavailable, spans may be buffered in memory (with size limits) or written to local disk to prevent memory exhaustion.\n\n**Phase 4: Collector Ingestion and Buffering**\n\nUpon receiving a batch of spans, the Collector's ingestion pipeline processes each span through a multi-stage pipeline:\n\n1. **Request Handling**: The Collector's HTTP or gRPC server receives the batch, validates authentication/authorization (if configured), and parses the OTLP payload into internal `Span` objects.\n\n2. **Validation and Enrichment**: Each span undergoes validation:\n   - Required fields (`TraceID`, `SpanID`) must be present and properly formatted\n   - Timestamps must be within acceptable bounds (not too far in future or past)\n   - Span duration must be non-negative\n   - Malformed spans are logged and discarded, but the batch continues processing\n\n3. **Head Sampling Verification**: The Collector verifies the head sampling decision by recalculating the hash-based decision. This ensures consistency between SDK and Collector (important for edge cases where SDK configuration differs). If the Collector's decision differs from the span's `Sampled` flag, it respects the SDK's decision but logs a warning.\n\n4. **Buffer Management**: The validated span is passed to the `BufferManager` via `AddSpan(ctx, span)`. The manager:\n   - Looks up the trace buffer for the span's `TraceID`\n   - If no buffer exists, creates a new `TraceBuffer` with `firstSeen` set to current time\n   - Appends the span to the buffer's `spans` slice\n   - Updates the buffer's `lastSeen` timestamp\n   - Triggers eviction if total buffers exceed `maxSize` (oldest or least-recently-used traces are removed based on `evictionPolicy`)\n\n5. **Write-Ahead Logging**: For durability, the span is simultaneously appended to the `WALWriter` via `Append()`. The WAL record contains the span data plus metadata (arrival timestamp, source service). This allows recovery of in-flight traces after Collector restart.\n\n**Phase 5: Trace Assembly and Storage**\n\nWhen certain conditions are met, traces are assembled from their constituent spans and persisted to storage:\n\n1. **Trace Completion Detection**: The `TraceAssembler` periodically scans buffers to identify complete traces:\n   - A trace is considered **potentially complete** if `current_time - buffer.lastSeen > maxTraceDuration` (e.g., 5 minutes)\n   - The assembler calls `IsTraceComplete()` which examines span parent-child relationships to check for missing spans\n   - For incomplete traces with expired timeout, the system proceeds anyway (handling late arrivals via the WAL recovery mechanism)\n\n2. **Tail-Based Sampling Evaluation**: For each potentially complete trace, the `TailSampler` evaluates whether to keep it:\n   - The trace is passed to `EvaluateTrace(ctx, trace, headDecision)`\n   - Each `TailSamplingRule` is evaluated in priority order:\n     - Rule 1: Keep all traces with error status codes (HTTP 5xx, span status = ERROR)\n     - Rule 2: Keep traces with latency above the 99th percentile for their service/operation\n     - Rule 3: Random sampling for \"normal\" traces to maintain baseline coverage\n   - If any rule matches with `KeepIfMatch = true`, the trace is kept regardless of head decision\n   - Statistics are updated in `TailSamplerStats`\n\n3. **Trace Assembly**: For traces selected for storage, `AssembleTrace(ctx, spans)` constructs a hierarchical `Trace` object:\n   - Sorts spans by `StartTime`\n   - Reconstructs parent-child relationships using `ParentSpanID` references\n   - Calculates trace-level `StartTime` (earliest span start) and `EndTime` (latest span end)\n   - Validates temporal consistency (child spans must start after parent and end before parent)\n\n4. **Storage Persistence**: The assembled trace is written to the storage backend:\n   - **Primary Storage**: All spans are written with `TraceID` as the primary index, enabling efficient retrieval of all spans for a trace\n   - **Secondary Indexes**: Index entries are created for:\n     - `ServiceName` + `StartTime` range (for service-specific queries)\n     - `StartTime` alone (for time-range queries)\n     - `Attributes` (for specific tag queries, if supported)\n   - **Aggregation Updates**: The span data is simultaneously sent to the analytics pipeline\n\n**Phase 6: Service Map Construction**\n\nAs traces are assembled, service dependency information is extracted and aggregated:\n\n1. **Edge Extraction**: For each inter-service span (where parent and child spans have different `ServiceName` values), the `EdgeAggregator` extracts a service call relationship:\n   - `CallerService`: The service name from the parent span\n   - `CalleeService`: The service name from the child span\n   - Latency, error status, and other metadata from the child span\n\n2. **Windowed Aggregation**: The aggregator's `ProcessSpan(ctx, span)` method updates in-memory aggregates for the current time window (e.g., 1 minute):\n   - Maintains `TotalCalls`, `ErrorCount`, latency histograms for each unique caller-callee pair\n   - Tracks a sample of `TraceID` values for each edge (for drill-down capability)\n\n3. **Window Flush**: At the end of each aggregation window, `FlushWindow(ctx, windowStart)`:\n   - Calculates final metrics: `ErrorRate = ErrorCount / TotalCalls`, latency percentiles (p50, p95, p99)\n   - Persists the aggregated `ServiceEdge` to the `EdgeStorage`\n   - Resets in-memory aggregates for the next window\n\n4. **Graph Construction**: The `GraphBuilder` periodically calls `BuildCurrentGraph(ctx, windowSize)` to construct a complete `ServiceGraph`:\n   - Retrieves all edges from the specified time window\n   - Deduplicates nodes (services) and creates `ServiceNode` entries\n   - Detects topology changes by comparing with previous graph via `DetectTopologyChanges()`\n   - Updates the visualization layer with the new graph\n\n**Phase 7: Performance Analytics Processing**\n\nSimultaneously with trace storage and service map construction, spans flow through the performance analytics pipeline:\n\n1. **Latency Aggregation**: For each span with duration information, the `PercentileAggregator` updates its t-digest structures:\n   - Creates or retrieves a `TDigestMetric` for the key `service:operation`\n   - Calls `Add(float64(span.Duration))` to incorporate the latency measurement\n   - Maintains separate aggregations per time window (e.g., 1-minute windows)\n\n2. **Anomaly Detection**: At regular intervals (e.g., every 10 seconds), the `Detector` evaluates current metrics against historical baselines:\n   - For each service-operation pair, retrieves current p95 latency via `GetPercentiles()`\n   - Calls `CheckMetric(ctx, \"latency_p95\", labels, currentValue)` which:\n     - Calculates expected value using `BaselineCalculator.Calculate()` (considering time-of-day, day-of-week patterns)\n     - Computes z-score: `(current - expected) / standard_deviation`\n     - If z-score exceeds threshold (e.g., 3.0), generates an `AnomalyResult`\n   - For high-severity anomalies, triggers alert notifications\n\n3. **Time-Series Storage**: Aggregated metrics (percentiles, call counts, error rates) are written to the time-series database at regular intervals (e.g., every minute) for long-term retention and trend analysis.\n\n**Phase 8: Query and Visualization**\n\nWhen an engineer needs to investigate an issue, they interact with the system through the Web UI and Query Service:\n\n1. **Trace Search**: The engineer queries for traces by service, time range, or attributes:\n   - Query Service translates the UI request into storage queries:\n     - `GetTracesByService(ctx, \"payment-service\", startTime, endTime, 100)`\n     - `GetTracesByTimeRange(ctx, startTime, endTime, 50)`\n   - Storage retrieves trace IDs from secondary indexes, then fetches full span data\n   - Traces are returned in chronological order with hierarchical span display\n\n2. **Service Map Visualization**: The UI requests the current service map:\n   - Query Service calls `BuildCurrentGraph(ctx, \"5m\")` or retrieves a pre-computed graph\n   - Returns nodes (services) and edges (calls with metrics) to the UI\n   - UI renders interactive graph with node size proportional to request volume and edge color indicating error rate\n\n3. **Performance Dashboard**: The UI queries time-series metrics for display:\n   - Historical latency percentiles (p50, p95, p99) for selected services\n   - Error rate trends and anomaly alerts\n   - Comparison views (this week vs. last week)\n\n4. **Drill-Down Investigation**: From any visualization, engineers can drill down to individual traces:\n   - Clicking a service map edge shows sample traces for that service pair\n   - Clicking an anomaly alert shows the affected traces with high latency\n   - The trace detail view shows the complete waterfall diagram of spans with timing and error information\n\n### Key Message and Wire Formats\n\nThe system uses several well-defined wire formats for communication between components. Understanding these formats is essential for debugging interoperability issues and extending the system.\n\n#### OpenTelemetry Protocol (OTLP) Span Format\n\nThe primary external interface uses the OpenTelemetry Protocol (OTLP), which supports both HTTP/JSON and gRPC/protobuf encodings. The following table describes the key fields in the OTLP span representation and their mapping to our internal `Span` type:\n\n| OTLP Field | Type | Description | Mapping to `Span` Field |\n|------------|------|-------------|--------------------------|\n| `trace_id` | bytes (16 bytes) | Unique identifier for the trace, represented as 32 hex characters when encoded as text | `TraceID` (string hex representation) |\n| `span_id` | bytes (8 bytes) | Unique identifier for the span within the trace, 16 hex characters as text | `SpanID` (string hex representation) |\n| `trace_state` | string | Comma-separated list of key-value pairs representing vendor-specific trace state | Not directly mapped; stored in `Attributes` under `\"w3c.tracestate\"` |\n| `parent_span_id` | bytes (8 bytes) | Identifier of the parent span; empty for root spans | `ParentSpanID` (string hex representation) |\n| `name` | string | Span name (operation name) | `Name` |\n| `kind` | enum | Span kind: INTERNAL, SERVER, CLIENT, PRODUCER, CONSUMER | Derived into `Attributes[\"span.kind\"]` |\n| `start_time_unix_nano` | fixed64 | Start time in nanoseconds since Unix epoch | `StartTime` (converted from nanoseconds to `time.Time`) |\n| `end_time_unix_nano` | fixed64 | End time in nanoseconds since Unix epoch | `Duration` = `EndTime - StartTime` |\n| `attributes` | key-value list | Span attributes (tags) as string, bool, int, double, or array values | `Attributes` (string values only; complex types stringified) |\n| `dropped_attributes_count` | uint32 | Count of attributes that were dropped due to limits | Logged but not stored |\n| `events` | event list | Time-stamped events with attributes | `Events` (mapped to `SpanEvent` list) |\n| `dropped_events_count` | uint32 | Count of events that were dropped | Logged but not stored |\n| `links` | link list | Links to other spans (for batch operations) | Not directly supported in current model |\n| `dropped_links_count` | uint32 | Count of links that were dropped | Logged but not stored |\n| `status` | Status | Span status: code (Ok, Error, Unset) and optional description | `Status.Code` and `Status.Message` |\n\n**HTTP Endpoint Example:** The Collector exposes an HTTP endpoint at `POST /v1/traces` accepting JSON with this structure:\n```json\n{\n  \"resourceSpans\": [{\n    \"resource\": {\"attributes\": [{\"key\": \"service.name\", \"value\": {\"stringValue\": \"payment-service\"}}]},\n    \"scopeSpans\": [{\n      \"spans\": [{\n        \"traceId\": \"4bf92f3577b34da6a3ce929d0e0e4736\",\n        \"spanId\": \"00f067aa0ba902b7\",\n        \"parentSpanId\": \"\",\n        \"name\": \"process_payment\",\n        \"kind\": \"SPAN_KIND_INTERNAL\",\n        \"startTimeUnixNano\": \"1616234190000000000\",\n        \"endTimeUnixNano\": \"1616234190500000000\",\n        \"attributes\": [{\"key\": \"http.method\", \"value\": {\"stringValue\": \"POST\"}}],\n        \"status\": {\"code\": \"STATUS_CODE_OK\"}\n      }]\n    }]\n  }]\n}\n```\n\n#### Internal Span Representation\n\nWhile the Collector accepts OTLP format, it immediately converts spans to the internal representation defined in Section 4. The following table shows the complete internal `Span` structure and its persistence format:\n\n| Field | Type in Go | Storage Format | Description |\n|-------|------------|----------------|-------------|\n| `SpanID` | `string` | UTF-8 string (16 chars) | Hex representation of 8-byte span ID |\n| `TraceID` | `string` | UTF-8 string (32 chars) | Hex representation of 16-byte trace ID |\n| `ParentSpanID` | `string` | UTF-8 string (0 or 16 chars) | Empty for root spans, otherwise hex representation |\n| `Name` | `string` | UTF-8 string | Operation name, max 255 characters |\n| `ServiceName` | `string` | UTF-8 string | Service identifier, max 100 characters |\n| `StartTime` | `time.Time` | int64 (nanoseconds) | Nanoseconds since Unix epoch, UTC |\n| `Duration` | `time.Duration` | int64 (nanoseconds) | Duration in nanoseconds |\n| `Attributes` | `map[string]string` | JSON object | Key-value pairs, keys max 255 chars, values max 1024 chars |\n| `Events` | `[]SpanEvent` | JSON array | List of timed events during span execution |\n| `Status.Code` | `int` | int32 | 0=Unset, 1=Ok, 2=Error |\n| `Status.Message` | `string` | UTF-8 string | Optional status description |\n| `Sampled` | `bool` | boolean | Whether this trace was sampled (not part of OTLP) |\n| `ReceivedAt` | `time.Time` | int64 (nanoseconds) | When collector received the span (internal use) |\n\n**Storage Optimization:** In the storage layer, spans are typically stored in a columnar format with compression. Frequently queried fields (`TraceID`, `ServiceName`, `StartTime`) are stored in separate columns with dictionary encoding, while larger fields (`Attributes`, `Events`) are stored in a compressed JSON blob.\n\n#### Collector Internal Messages\n\nBetween internal Collector components, spans are passed as in-memory `Span` objects, but several key internal APIs use structured messages. The most important is the **Trace Completion Notification** sent from the `BufferManager` to the `TraceAssembler`:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `TraceID` | `string` | The trace identifier |\n| `SpanCount` | `int` | Number of spans in the trace |\n| `FirstSeen` | `time.Time` | When the first span for this trace arrived |\n| `LastSeen` | `time.Time` | When the most recent span arrived |\n| `IsTimedOut` | `bool` | Whether trace completion is due to timeout (vs. explicit completion) |\n| `BufferSize` | `int` | Current memory usage of this trace's buffer |\n\n#### Query Service APIs\n\nThe Query Service exposes RESTful endpoints for trace retrieval. The key endpoints and their request/response formats are:\n\n**GET /api/traces/{traceId}**\n*Request:* Path parameter `traceId` (32-character hex string)\n*Response:*\n```json\n{\n  \"traceId\": \"4bf92f3577b34da6a3ce929d0e0e4736\",\n  \"spans\": [\n    {\n      \"spanId\": \"00f067aa0ba902b7\",\n      \"parentSpanId\": \"\",\n      \"name\": \"process_payment\",\n      \"serviceName\": \"payment-service\",\n      \"startTime\": \"2021-03-20T10:56:30Z\",\n      \"durationMs\": 50,\n      \"attributes\": {\"http.method\": \"POST\"},\n      \"status\": {\"code\": 1}\n    }\n  ],\n  \"startTime\": \"2021-03-20T10:56:30Z\",\n  \"endTime\": \"2021-03-20T10:56:30.050Z\",\n  \"durationMs\": 50,\n  \"serviceCount\": 1\n}\n```\n\n**GET /api/traces**\n*Query Parameters:*\n- `service` (optional): Filter by service name\n- `operation` (optional): Filter by operation name\n- `start` (required): Start time in ISO 8601 or Unix milliseconds\n- `end` (required): End time in ISO 8601 or Unix milliseconds\n- `limit` (optional, default=100): Maximum number of traces to return\n- `minDuration` (optional): Filter by minimum trace duration (ms)\n- `maxDuration` (optional): Filter by maximum trace duration (ms)\n- `tags` (optional): Key-value pairs to match in span attributes\n\n*Response:* Array of trace summaries (not full span details):\n```json\n{\n  \"traces\": [\n    {\n      \"traceId\": \"4bf92f3577b34da6a3ce929d0e0e4736\",\n      \"rootService\": \"payment-service\",\n      \"rootOperation\": \"process_payment\",\n      \"startTime\": \"2021-03-20T10:56:30Z\",\n      \"durationMs\": 50,\n      \"spanCount\": 3,\n      \"serviceCount\": 2,\n      \"hasError\": false\n    }\n  ],\n  \"total\": 1,\n  \"limit\": 100,\n  \"offset\": 0\n}\n```\n\n**GET /api/services/{serviceName}/operations**\n*Request:* Path parameter `serviceName`\n*Response:*\n```json\n{\n  \"service\": \"payment-service\",\n  \"operations\": [\n    {\"name\": \"process_payment\", \"count\": 1500},\n    {\"name\": \"validate_card\", \"count\": 1500},\n    {\"name\": \"update_inventory\", \"count\": 800}\n  ]\n}\n```\n\n**GET /api/services/{serviceName}/latency**\n*Query Parameters:*\n- `operation` (optional): Specific operation name\n- `start` (required): Start time\n- `end` (required): End time\n- `percentile` (optional, default=95): Percentile to calculate (50, 95, 99)\n\n*Response:*\n```json\n{\n  \"service\": \"payment-service\",\n  \"operation\": \"process_payment\",\n  \"percentiles\": {\n    \"p50\": 45.2,\n    \"p95\": 128.7,\n    \"p99\": 245.3\n  },\n  \"unit\": \"milliseconds\",\n  \"sampleSize\": 1500,\n  \"timeWindow\": {\n    \"start\": \"2021-03-20T10:00:00Z\",\n    \"end\": \"2021-03-20T11:00:00Z\"\n  }\n}\n```\n\n**GET /api/service-map**\n*Query Parameters:*\n- `window` (optional, default=\"5m\"): Time window for aggregation (e.g., \"5m\", \"1h\", \"1d\")\n- `time` (optional): Reference time for the window (defaults to now)\n\n*Response:* Complete service graph:\n```json\n{\n  \"generatedAt\": \"2021-03-20T11:05:00Z\",\n  \"windowSize\": \"5m\",\n  \"nodes\": [\n    {\"name\": \"payment-service\", \"totalCalls\": 1500},\n    {\"name\": \"inventory-service\", \"totalCalls\": 800},\n    {\"name\": \"user-service\", \"totalCalls\": 700}\n  ],\n  \"edges\": [\n    {\n      \"caller\": \"payment-service\",\n      \"callee\": \"inventory-service\",\n      \"totalCalls\": 800,\n      \"errorCount\": 12,\n      \"errorRate\": 0.015,\n      \"p50LatencyMs\": 25.4,\n      \"p95LatencyMs\": 89.1,\n      \"p99LatencyMs\": 210.5,\n      \"sampleTraceIds\": [\"4bf92f3577b34da6...\", \"5ac93e4688c45eb7...\"]\n    }\n  ]\n}\n```\n\n#### W3C Trace Context Propagation\n\nFor context propagation between services, the system uses W3C Trace Context headers:\n\n| Header | Format | Description |\n|--------|--------|-------------|\n| `traceparent` | `00-{trace-id}-{span-id}-{flags}` | Required header with version (00), trace ID (32 hex), span ID (16 hex), and flags (2 hex) |\n| `tracestate` | `key1=value1,key2=value2` | Optional comma-separated list of vendor-specific tracing system states |\n| `traceresponse` | (Proposed) | Future header for returning trace context from server to client |\n\n**Example traceparent:** `00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01`\n\n- `00`: Version (current version is 00)\n- `0af7651916cd43dd8448eb211c80319c`: 32-character hex trace ID (16 bytes)\n- `b7ad6b7169203331`: 16-character hex parent span ID (8 bytes)\n- `01`: Flags (bit field: 01 = sampled, 02 = debug, etc.)\n\nThe SDK's `TextMapCarrier` interface abstracts these headers for both HTTP and other propagation mechanisms (gRPC metadata, message queues, etc.).\n\n### Implementation Guidance\n\n> **Note:** This section provides practical guidance for implementing the data flow and wire format handling described above.\n\n#### A. Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Span Transport** | HTTP/JSON with `net/http` | gRPC with Protocol Buffers using OpenTelemetry protobuf definitions |\n| **JSON Serialization** | Standard `encoding/json` | `json-iterator/go` for faster serialization with compatibility |\n| **Protocol Buffers** | Manually defined .proto files | Import `opentelemetry-proto` from GitHub for official OTLP definitions |\n| **HTTP Server** | `net/http` with Gorilla Mux | `chi` router for lightweight routing with middleware support |\n| **WAL Format** | JSON lines with newline delimiter | Binary format with length-prefixed protobuf messages |\n| **Context Propagation** | Manual header manipulation | OpenTelemetry Go SDK's `propagation` package |\n\n#### B. Recommended File/Module Structure\n\n```\napm-tracing-system/\n├── cmd/\n│   ├── collector/                 # Collector main binary\n│   │   └── main.go\n│   ├── query-service/             # Query service main binary  \n│   │   └── main.go\n│   └── web-ui/                    # Web UI server (optional)\n│       └── main.go\n├── internal/\n│   ├── apm/                       # Shared APM data structures\n│   │   ├── span.go               # Span, Trace, Service types\n│   │   ├── wire_formats.go       # OTLP JSON/protobuf marshal/unmarshal\n│   │   └── w3c_trace_context.go  # Trace context header handling\n│   ├── collector/                 # Collector component\n│   │   ├── server/\n│   │   │   ├── http_server.go    # HTTP ingestion endpoint\n│   │   │   └── grpc_server.go    # gRPC ingestion endpoint\n│   │   ├── ingestion/\n│   │   │   ├── pipeline.go       # Main ingestion pipeline\n│   │   │   ├── validator.go      # Span validation logic\n│   │   │   └── buffer_manager.go # Trace buffering\n│   │   ├── sampling/\n│   │   │   ├── head_sampler.go   # Head-based sampling\n│   │   │   └── tail_sampler.go   # Tail-based sampling\n│   │   └── storage/\n│   │       ├── writer.go         # Storage interface implementation\n│   │       └── wal.go            # Write-ahead log\n│   ├── query/                     # Query service component\n│   │   ├── handler.go            # HTTP request handlers\n│   │   ├── service.go            # Business logic for queries\n│   │   └── storage_reader.go     # Storage read interface\n│   ├── servicemap/               # Service map component (Milestone 2)\n│   │   ├── edge_aggregator.go\n│   │   ├── graph_builder.go\n│   │   └── storage.go\n│   ├── analytics/                # Analytics component (Milestone 4)\n│   │   ├── percentile_aggregator.go\n│   │   ├── anomaly_detector.go\n│   │   └── timeseries_store.go\n│   └── sdk/                      # APM SDK (Milestone 5)\n│       ├── tracer.go\n│       ├── instrumentation/\n│       │   ├── http.go\n│       │   ├── database.go\n│       │   └── middleware.go\n│       └── propagation/\n│           └── w3c.go\n└── pkg/\n    ├── otlp/                     # OpenTelemetry protocol handling\n    │   ├── models.pb.go          # Generated protobuf code\n    │   └── marshal.go            # Conversion utilities\n    └── storage/                  # Storage abstractions\n        ├── interface.go\n        ├── elasticsearch.go      # Elasticsearch implementation\n        └── cassandra.go          # Cassandra implementation\n```\n\n#### C. OTLP HTTP Handler Implementation\n\nHere's a complete, working implementation of the Collector's OTLP HTTP ingestion endpoint:\n\n```go\npackage server\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"time\"\n\n    \"github.com/gorilla/mux\"\n    \"go.uber.org/zap\"\n\n    \"apm-tracing-system/internal/apm\"\n    \"apm-tracing-system/internal/collector/ingestion\"\n)\n\n// OTLPHandler handles OpenTelemetry Protocol over HTTP requests\ntype OTLPHandler struct {\n    pipeline *ingestion.Pipeline\n    logger   *zap.Logger\n}\n\n// NewOTLPHandler creates a new HTTP handler for OTLP\nfunc NewOTLPHandler(pipeline *ingestion.Pipeline, logger *zap.Logger) *OTLPHandler {\n    return &OTLPHandler{\n        pipeline: pipeline,\n        logger:   logger,\n    }\n}\n\n// ServeHTTP implements http.Handler\nfunc (h *OTLPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    start := time.Now()\n    \n    // Only accept POST requests\n    if r.Method != http.MethodPost {\n        h.respondWithError(w, http.StatusMethodNotAllowed, \"Method not allowed\")\n        return\n    }\n\n    // Check content type\n    contentType := r.Header.Get(\"Content-Type\")\n    if contentType != \"application/json\" && contentType != \"application/x-protobuf\" {\n        h.respondWithError(w, http.StatusUnsupportedMediaType, \n            fmt.Sprintf(\"Unsupported content type: %s\", contentType))\n        return\n    }\n\n    // Read and parse request body\n    body, err := io.ReadAll(r.Body)\n    if err != nil {\n        h.logger.Error(\"Failed to read request body\", zap.Error(err))\n        h.respondWithError(w, http.StatusBadRequest, \"Failed to read request body\")\n        return\n    }\n    defer r.Body.Close()\n\n    var spans []apm.Span\n    if contentType == \"application/json\" {\n        // Parse OTLP JSON format\n        spans, err = h.parseOTLPJSON(body)\n    } else {\n        // Parse OTLP protobuf format\n        spans, err = h.parseOTLPProtobuf(body)\n    }\n\n    if err != nil {\n        h.logger.Error(\"Failed to parse request\", zap.Error(err))\n        h.respondWithError(w, http.StatusBadRequest, \n            fmt.Sprintf(\"Invalid request format: %v\", err))\n        return\n    }\n\n    // Process spans through the ingestion pipeline\n    processedCount := 0\n    for _, span := range spans {\n        if err := h.pipeline.ProcessSpan(r.Context(), span); err != nil {\n            h.logger.Warn(\"Failed to process span\", \n                zap.String(\"trace_id\", span.TraceID),\n                zap.String(\"span_id\", span.SpanID),\n                zap.Error(err))\n            // Continue processing other spans even if one fails\n        } else {\n            processedCount++\n        }\n    }\n\n    // Send success response\n    response := map[string]interface{}{\n        \"status\": \"success\",\n        \"processed_spans\": processedCount,\n        \"total_spans\": len(spans),\n        \"processing_time_ms\": time.Since(start).Milliseconds(),\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusOK)\n    if err := json.NewEncoder(w).Encode(response); err != nil {\n        h.logger.Error(\"Failed to encode response\", zap.Error(err))\n    }\n    \n    h.logger.Info(\"Processed OTLP batch\",\n        zap.Int(\"processed\", processedCount),\n        zap.Int(\"total\", len(spans)),\n        zap.Duration(\"duration\", time.Since(start)))\n}\n\n// parseOTLPJSON parses OTLP JSON format into internal Span objects\nfunc (h *OTLPHandler) parseOTLPJSON(data []byte) ([]apm.Span, error) {\n    var otlpRequest OTLPJSONRequest\n    if err := json.Unmarshal(data, &otlpRequest); err != nil {\n        return nil, fmt.Errorf(\"JSON unmarshal failed: %w\", err)\n    }\n    \n    // Convert OTLP spans to internal representation\n    var spans []apm.Span\n    for _, resourceSpan := range otlpRequest.ResourceSpans {\n        serviceName := extractServiceName(resourceSpan.Resource)\n        \n        for _, scopeSpan := range resourceSpan.ScopeSpans {\n            for _, otlpSpan := range scopeSpan.Spans {\n                span, err := convertOTLPSpan(otlpSpan, serviceName)\n                if err != nil {\n                    h.logger.Warn(\"Failed to convert OTLP span\", \n                        zap.Error(err),\n                        zap.String(\"span_name\", otlpSpan.Name))\n                    continue\n                }\n                spans = append(spans, span)\n            }\n        }\n    }\n    \n    return spans, nil\n}\n\n// parseOTLPProtobuf parses OTLP protobuf format\nfunc (h *OTLPHandler) parseOTLPProtobuf(data []byte) ([]apm.Span, error) {\n    // Implementation would use generated protobuf code\n    // For simplicity, we show a placeholder\n    return nil, fmt.Errorf(\"protobuf parsing not implemented in this example\")\n}\n\n// respondWithError sends an error response\nfunc (h *OTLPHandler) respondWithError(w http.ResponseWriter, code int, message string) {\n    response := map[string]interface{}{\n        \"status\":  \"error\",\n        \"code\":    code,\n        \"message\": message,\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(code)\n    if err := json.NewEncoder(w).Encode(response); err != nil {\n        h.logger.Error(\"Failed to encode error response\", zap.Error(err))\n    }\n}\n\n// OTLPJSONRequest represents the OTLP JSON structure\ntype OTLPJSONRequest struct {\n    ResourceSpans []ResourceSpan `json:\"resourceSpans\"`\n}\n\n// ResourceSpan represents OTLP ResourceSpans\ntype ResourceSpan struct {\n    Resource   Resource   `json:\"resource\"`\n    ScopeSpans []ScopeSpan `json:\"scopeSpans\"`\n}\n\n// Resource represents OTLP Resource\ntype Resource struct {\n    Attributes []KeyValue `json:\"attributes\"`\n}\n\n// ScopeSpan represents OTLP ScopeSpans\ntype ScopeSpan struct {\n    Spans []OTLPSpan `json:\"spans\"`\n}\n\n// OTLPSpan represents an OTLP span in JSON format\ntype OTLPSpan struct {\n    TraceID           string      `json:\"traceId\"`\n    SpanID            string      `json:\"spanId\"`\n    ParentSpanID      string      `json:\"parentSpanId\"`\n    Name              string      `json:\"name\"`\n    Kind              string      `json:\"kind\"`\n    StartTimeUnixNano string      `json:\"startTimeUnixNano\"` // string to handle large numbers\n    EndTimeUnixNano   string      `json:\"endTimeUnixNano\"`\n    Attributes        []KeyValue  `json:\"attributes\"`\n    Status            OTLPStatus  `json:\"status\"`\n}\n\n// KeyValue represents OTLP KeyValue\ntype KeyValue struct {\n    Key   string      `json:\"key\"`\n    Value Value       `json:\"value\"`\n}\n\n// Value represents OTLP AnyValue\ntype Value struct {\n    StringValue  string    `json:\"stringValue,omitempty\"`\n    BoolValue    bool      `json:\"boolValue,omitempty\"`\n    IntValue     int64     `json:\"intValue,omitempty\"`\n    DoubleValue  float64   `json:\"doubleValue,omitempty\"`\n    ArrayValue   []Value   `json:\"arrayValue,omitempty\"`\n}\n\n// OTLPStatus represents OTLP Status\ntype OTLPStatus struct {\n    Code    string `json:\"code\"`\n    Message string `json:\"message,omitempty\"`\n}\n\n// extractServiceName extracts service name from OTLP resource attributes\nfunc extractServiceName(resource Resource) string {\n    for _, attr := range resource.Attributes {\n        if attr.Key == \"service.name\" {\n            return attr.Value.StringValue\n        }\n    }\n    return \"unknown-service\"\n}\n\n// convertOTLPSpan converts OTLP span to internal Span representation\nfunc convertOTLPSpan(otlpSpan OTLPSpan, serviceName string) (apm.Span, error) {\n    // Parse timestamps from nanosecond strings\n    startTime, err := parseUnixNano(otlpSpan.StartTimeUnixNano)\n    if err != nil {\n        return apm.Span{}, fmt.Errorf(\"invalid start time: %w\", err)\n    }\n    \n    endTime, err := parseUnixNano(otlpSpan.EndTimeUnixNano)\n    if err != nil {\n        return apm.Span{}, fmt.Errorf(\"invalid end time: %w\", err)\n    }\n    \n    duration := endTime.Sub(startTime)\n    if duration < 0 {\n        return apm.Span{}, fmt.Errorf(\"negative duration: start=%v, end=%v\", startTime, endTime)\n    }\n    \n    // Convert attributes to map\n    attributes := make(map[string]string)\n    for _, attr := range otlpSpan.Attributes {\n        // Convert value to string representation\n        attributes[attr.Key] = valueToString(attr.Value)\n    }\n    \n    // Add span.kind from OTLP kind field\n    if otlpSpan.Kind != \"\" {\n        attributes[\"span.kind\"] = otlpSpan.Kind\n    }\n    \n    // Convert status code\n    statusCode := 0 // Unset\n    if otlpSpan.Status.Code == \"STATUS_CODE_OK\" {\n        statusCode = 1\n    } else if otlpSpan.Status.Code == \"STATUS_CODE_ERROR\" {\n        statusCode = 2\n    }\n    \n    return apm.Span{\n        SpanID:       otlpSpan.SpanID,\n        TraceID:      otlpSpan.TraceID,\n        ParentSpanID: otlpSpan.ParentSpanID,\n        Name:         otlpSpan.Name,\n        ServiceName:  serviceName,\n        StartTime:    startTime,\n        Duration:     duration,\n        Attributes:   attributes,\n        Status: apm.SpanStatus{\n            Code:    statusCode,\n            Message: otlpSpan.Status.Message,\n        },\n        ReceivedAt: time.Now(),\n    }, nil\n}\n\n// parseUnixNano parses a string representing nanoseconds since Unix epoch\nfunc parseUnixNano(nsStr string) (time.Time, error) {\n    // Implementation parses string to int64 then converts to time.Time\n    // Simplified for this example\n    return time.Now(), nil\n}\n\n// valueToString converts OTLP AnyValue to string\nfunc valueToString(v Value) string {\n    if v.StringValue != \"\" {\n        return v.StringValue\n    }\n    if v.BoolValue {\n        return \"true\"\n    }\n    if v.IntValue != 0 {\n        return fmt.Sprintf(\"%d\", v.IntValue)\n    }\n    if v.DoubleValue != 0 {\n        return fmt.Sprintf(\"%f\", v.DoubleValue)\n    }\n    return \"\"\n}\n\n// RegisterRoutes registers the OTLP handler with the router\nfunc RegisterRoutes(router *mux.Router, pipeline *ingestion.Pipeline, logger *zap.Logger) {\n    handler := NewOTLPHandler(pipeline, logger)\n    router.Handle(\"/v1/traces\", handler).Methods(\"POST\")\n    router.Handle(\"/api/v2/spans\", handler).Methods(\"POST\") // Legacy Jaeger endpoint\n}\n```\n\n#### D. Span Processing Pipeline Skeleton\n\nHere's the skeleton for the core ingestion pipeline that processes spans through validation, buffering, and sampling:\n\n```go\npackage ingestion\n\nimport (\n    \"context\"\n    \"time\"\n\n    \"apm-tracing-system/internal/apm\"\n)\n\n// Pipeline is the main ingestion pipeline for processing spans\ntype Pipeline struct {\n    validator      *SpanValidator\n    bufferManager  *BufferManager\n    headSampler    *sampling.HeadSampler\n    tailSampler    *sampling.TailSampler\n    storageWriter  storage.Writer\n    metrics        *PipelineMetrics\n}\n\n// NewPipeline creates a new ingestion pipeline\nfunc NewPipeline(config *Config) (*Pipeline, error) {\n    // TODO 1: Initialize span validator with config validation rules\n    // TODO 2: Create buffer manager with configured max size and TTL\n    // TODO 3: Initialize head sampler with sampling rates from config\n    // TODO 4: Initialize tail sampler with rules from config\n    // TODO 5: Create storage writer for the configured storage backend\n    // TODO 6: Set up metrics collection for pipeline statistics\n    // TODO 7: Start background goroutines for buffer eviction and trace assembly\n    return &Pipeline{}, nil\n}\n\n// ProcessSpan processes a single span through the ingestion pipeline\nfunc (p *Pipeline) ProcessSpan(ctx context.Context, span apm.Span) error {\n    // TODO 1: Validate span fields (trace ID, span ID, timestamps, etc.)\n    //         Return error if span is invalid (malformed data)\n    \n    // TODO 2: Apply head-based sampling decision if not already made by SDK\n    //         Use consistent hashing on trace ID for deterministic decision\n    \n    // TODO 3: If span is not sampled, only store minimal metadata for trace existence\n    //         Otherwise, proceed with full processing\n    \n    // TODO 4: Add span to buffer manager for its trace ID\n    //         Buffer manager will handle out-of-order arrival and trace assembly\n    \n    // TODO 5: Write span to Write-Ahead Log for durability\n    //         This ensures spans aren't lost if collector crashes before processing\n    \n    // TODO 6: Update pipeline metrics (counters for spans processed, errors, etc.)\n    \n    // TODO 7: Return nil on success, error if any step fails\n    return nil\n}\n\n// ProcessCompleteTrace is called when a trace is assembled and ready for tail sampling\nfunc (p *Pipeline) ProcessCompleteTrace(ctx context.Context, trace *apm.Trace) error {\n    // TODO 1: Apply tail-based sampling rules to the completed trace\n    //         Evaluate error status, latency percentiles, custom rules\n    \n    // TODO 2: If tail sampling overrides head decision to keep, mark trace as sampled\n    //         Otherwise, if head decision was drop, discard the trace\n    \n    // TODO 3: For sampled traces, write all spans to persistent storage\n    //         Use bulk write operations for efficiency\n    \n    // TODO 4: Extract service dependencies and send to service map builder\n    //         Each inter-service span creates an edge in the dependency graph\n    \n    // TODO 5: Send span metrics to analytics aggregator\n    //         Latency, error rates, operation counts for anomaly detection\n    \n    // TODO 6: Update sampling statistics for adaptive rate adjustment\n    return nil\n}\n\n// PipelineMetrics tracks ingestion pipeline performance\ntype PipelineMetrics struct {\n    SpansReceived   int64\n    SpansProcessed  int64\n    SpansDropped    int64\n    TracesAssembled int64\n    ProcessingTime  time.Duration\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **HTTP Server Best Practices:**\n   - Use `http.TimeoutHandler` to enforce request timeouts\n   - Implement middleware for CORS, authentication, and request logging\n   - Set `ReadTimeout` and `WriteTimeout` on the HTTP server to prevent resource exhaustion\n   - Use connection pooling with `http.Transport` for outgoing requests to storage\n\n2. **JSON Processing Optimization:**\n   - For high-throughput scenarios, consider `json-iterator/go` which is API-compatible with `encoding/json` but significantly faster\n   - Reuse JSON encoders/decoders where possible to reduce allocations\n   - Use `json.RawMessage` for deferred parsing of nested structures\n\n3. **Time Handling:**\n   - Always use `time.Time` for timestamps internally, but be careful with timezone conversions\n   - For nanosecond precision timestamps, use `time.Unix(0, nanoseconds)` and `time.UnixNano()`\n   - Consider using `monotonic` time for duration measurements within a process\n\n4. **Context Propagation:**\n   - Use `context.WithTimeout` for operations that should have time limits\n   - Pass context as first parameter to all functions that make I/O calls\n   - Store span in context using a private key type to avoid collisions: `type contextKey int; const spanKey contextKey = 0`\n\n5. **Concurrency Patterns:**\n   - Use `sync.Pool` for frequently allocated objects (like `Span` structs)\n   - Consider buffered channels for decoupling pipeline stages with backpressure\n   - Use `errgroup` for managing groups of goroutines with coordinated error handling\n\n#### F. Milestone Checkpoint\n\nAfter implementing the data flow pipeline, verify the complete trace lifecycle:\n\n1. **Start the Collector:**\n   ```bash\n   go run cmd/collector/main.go --config config.yaml\n   ```\n   Expected output: `Collector started on :4318 (HTTP) and :4317 (gRPC)`\n\n2. **Send Test Spans:**\n   ```bash\n   # Using curl to send OTLP JSON\n   curl -X POST http://localhost:4318/v1/traces \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n       \"resourceSpans\": [{\n         \"resource\": {\"attributes\": [{\"key\": \"service.name\", \"value\": {\"stringValue\": \"test-service\"}}]},\n         \"scopeSpans\": [{\n           \"spans\": [{\n             \"traceId\": \"4bf92f3577b34da6a3ce929d0e0e4736\",\n             \"spanId\": \"00f067aa0ba902b7\",\n             \"name\": \"test-operation\",\n             \"startTimeUnixNano\": \"'$(date +%s)000000000'\",\n             \"endTimeUnixNano\": \"'$(($(date +%s)+1))000000000'\",\n             \"attributes\": [],\n             \"status\": {\"code\": \"STATUS_CODE_OK\"}\n           }]\n         }]\n       }]\n     }'\n   ```\n   Expected response: `{\"status\":\"success\",\"processed_spans\":1,\"total_spans\":1,\"processing_time_ms\":5}`\n\n3. **Query for the Trace:**\n   ```bash\n   curl \"http://localhost:8080/api/traces/4bf92f3577b34da6a3ce929d0e0e4736\"\n   ```\n   Expected: JSON response with the trace containing your test span.\n\n4. **Check Service Map:**\n   ```bash\n   curl \"http://localhost:8080/api/service-map?window=1m\"\n   ```\n   Expected: Service map with `test-service` node (though no edges since only one span).\n\n5. **Verify Storage:**\n   - Check that spans appear in your storage backend (Elasticsearch, Cassandra, etc.)\n   - Verify indexes are created for trace ID and service name\n\n**Signs of Issues:**\n- **Spans not appearing in queries:** Check buffer manager eviction policy and trace assembly timeout\n- **High memory usage:** Buffer manager may not be evicting old traces; check `maxSize` configuration\n- **Slow response times:** Ingestion pipeline may be overloaded; implement rate limiting or increase batch sizes\n- **Missing parent-child relationships:** Verify context propagation headers are being injected/extracted correctly\n\n\n## 11. Error Handling and Edge Cases\n\n> **Milestone(s):** This section applies to all five milestones, as error handling and edge case management are cross-cutting concerns that affect the entire APM Tracing System's reliability and resilience.\n\n### Mental Model: The Fault-Tolerant Hospital\n\nThink of the APM system as a well-run hospital emergency room during a crisis. When everything functions normally, patients (traces) flow smoothly through triage (sampling), diagnosis (analysis), and treatment (storage/visualization). However, during a mass casualty event (traffic surge) or when critical equipment fails (storage outage), the hospital must adapt. It implements **triage protocols** (backpressure) to prioritize the most critical cases, activates **backup generators** (redundant storage), and maintains **patient records** (WAL) to ensure no critical information is lost even during power failures. This section defines how our system behaves when things go wrong, ensuring it degrades gracefully rather than collapsing catastrophically.\n\n### Failure Modes and Recovery Strategies\n\nA robust APM system must anticipate and handle failures at multiple layers. The following table categorizes the most critical failure modes, their detection mechanisms, and recovery strategies:\n\n| Failure Mode | Symptoms/Detection | Immediate Response | Recovery Strategy | Prevention |\n|--------------|-------------------|-------------------|------------------|------------|\n| **Collector Overload** (Traffic surge exceeding ingestion capacity) | • HTTP 503/429 responses from ingestion endpoints<br>• Growing memory consumption in `BufferManager`<br>• Increasing `PipelineMetrics.SpansDropped` counter<br>• High CPU utilization on collector nodes | 1. Return HTTP 429 (Too Many Requests) with Retry-After header<br>2. Activate head sampling at 100% drop rate temporarily<br>3. Shed load by rejecting spans from low-priority services<br>4. Emit high-priority alert | 1. Auto-scale collector pods based on queue depth<br>2. Gradually restore sampling rates as load decreases<br>3. Replay spans from Write-Ahead Log (WAL) if available | • Implement rate limiting per client IP/service<br>• Set memory bounds with automatic eviction<br>• Use load balancers with health checks |\n| **Storage Backend Unavailable** (Database/object store connection loss) | • Storage write timeouts exceeding `StorageConfig.Timeout`<br>• Exponential backoff in storage writer retries<br>• `GetTraceByID` returns \"storage unavailable\" errors<br>• Health check endpoint reports degraded status | 1. Buffer spans in memory up to safe limits<br>2. Write to local WAL for durability<br>3. Mark storage writer as degraded, continue processing<br>4. Switch to read-only mode for query endpoints | 1. Implement circuit breaker pattern for storage client<br>2. Retry with exponential backoff when connection restored<br>3. Replay WAL entries to catch up on missed writes<br>4. Validate data consistency after recovery | • Use multiple storage replicas with failover<br>• Implement storage health probes<br>• Set conservative timeouts with context cancellation |\n| **Network Partition** (Collector cluster split-brain) | • Leader election failures in distributed components<br>• Inconsistent service map views across nodes<br>• Duplicate span storage across partitions<br>• Clock skew exceeding allowed tolerance | 1. Continue operating independently in each partition<br>2. Mark data with partition identifier for later reconciliation<br>3. Disable distributed coordination features (global sampling rates)<br>4. Log partition events for manual intervention | 1. Use CRDTs for eventually consistent service maps<br>2. Implement last-write-wins for duplicate spans with timestamps<br>3. Run reconciliation job when network heals<br>4. Reset adaptive sampling state post-partition | • Use consensus algorithms (Raft) for critical state<br>• Implement anti-entropy protocols for background sync<br>• Monitor network latency and partition probability |\n| **Corrupt Span Data** (Malformed, invalid, or poisoned spans) | • `SpanValidator` returns validation errors<br>• JSON/protobuf parsing failures with specific error codes<br>• Span timestamps far in future/past (beyond `maxTraceDuration`)<br>• Trace ID format violations (wrong length/encoding) | 1. Reject individual malformed spans with 400 Bad Request<br>2. Continue processing other spans in same batch<br>3. Increment \"spans rejected\" metric with error type label<br>4. Optionally quarantine suspicious spans for analysis | 1. Implement strict validation with clear error messages<br>2. Provide validation error details in response (truncated)<br>3. Log full corrupt spans at DEBUG level for debugging<br>4. Auto-block repeat offenders after threshold | • Validate spans at SDK before transmission<br>• Use schema validation for OpenTelemetry formats<br>• Implement request size limits to prevent DoS |\n| **Clock Skew Across Services** (Span ordering inconsistencies) | • Child spans appearing to start before parent spans<br>• Negative span durations after timestamp normalization<br>• Service map edges with impossible latency values<br>• Trace visualization showing time travel | 1. Normalize timestamps using collector's clock on ingestion<br>2. Calculate durations using normalized times only<br>3. Apply heuristic corrections (child cannot start before parent)<br>4. Log clock skew warnings for investigation | 1. Implement NTP synchronization across all services<br>2. Store original and normalized timestamps separately<br>3. Use monotonic clocks for duration calculations where possible<br>4. Detect and report services with consistent clock issues | • Require SDKs to send monotonic clock readings alongside wall time<br>• Implement timestamp bounds checking in validator<br>• Educate users about time synchronization best practices |\n| **Memory Exhaustion** (Unbounded buffer growth) | • `BufferManager` eviction running constantly<br>• Go runtime reporting \"out of memory\"<br>• High GC pressure affecting throughput<br>• `TraceBuffer` count exceeding `maxSize` despite eviction | 1. Trigger aggressive eviction of oldest/incomplete traces<br>2. Temporarily increase head sampling drop rate to 100%<br>3. Spill over to disk if disk buffer configured<br>4. Restart process with clean state as last resort | 1. Implement multiple eviction policies (LRU, by age, by size)<br>2. Add memory limits with hard boundaries<br>3. Monitor buffer metrics with alerting thresholds<br>4. Adjust `maxTraceDuration` based on memory pressure | • Set conservative default buffer sizes<br>• Implement proactive monitoring of memory trends<br>• Use off-heap storage for large trace buffers |\n| **Late-Arriving Spans** (Spans arriving after trace assembly) | • `TraceAssembler.IsTraceComplete` returning false for assembled traces<br>• Spans with timestamps outside assembly window<br>• Orphan spans without parent in storage<br>• Incomplete traces in query results | 1. Extend buffer TTL for traces expecting late children<br>2. Store late spans separately for manual attachment<br>3. Mark traces as \"potentially incomplete\" in query results<br>4. Update service map with partial information | 1. Implement watermark-based trace completion detection<br>2. Use asynchronous trace assembly with configurable wait time<br>3. Provide admin API to force assembly of specific traces<br>4. Re-process buffers periodically to attach late spans | • Set realistic `maxTraceDuration` based on network latency<br>• Implement span batching with deadlines at SDK<br>• Use synchronous tracing for critical paths where possible |\n\n> **Key Insight:** The system's error handling follows the principle of **graceful degradation** rather than all-or-nothing availability. When components fail, the system continues operating with reduced functionality (e.g., storing spans locally when storage is unavailable) rather than rejecting all incoming data.\n\n#### ADR: Storage Failure Recovery Strategy\n\n**Decision: WAL + Delayed Retry with Exponential Backoff for Storage Failures**\n\n- **Context**: The storage backend (database, object store) is a critical dependency that may experience temporary outages lasting from seconds to hours. During outages, we must preserve incoming span data without overwhelming memory, and ensure eventual consistency when storage recovers.\n\n- **Options Considered**:\n  1. **Drop spans during outage**: Simple but loses critical debugging data precisely when needed most (during system failures).\n  2. **In-memory buffering only**: Preserves data but risks memory exhaustion during prolonged outages.\n  3. **WAL to local disk with retry**: Writes spans to local disk Write-Ahead Log during outages, retries when storage recovers.\n\n- **Decision**: Implement a hybrid approach using **bounded in-memory buffering** (for short outages) combined with **WAL to local disk** (for prolonged outages), with automatic retry using exponential backoff when storage recovers.\n\n- **Rationale**: \n  - WAL provides durability guarantees similar to databases—spans are fsynced to disk before acknowledging receipt.\n  - Local disk storage is typically larger and more reliable than memory for temporary storage.\n  - Exponential backoff prevents overwhelming recovering storage with backlog.\n  - Bounded memory buffer handles short blips without disk I/O overhead.\n\n- **Consequences**:\n  - **Positive**: No data loss during storage outages of arbitrary length (assuming disk space).\n  - **Positive**: Self-healing—automatically catches up when storage recovers.\n  - **Negative**: Requires disk space provisioning on collector nodes.\n  - **Negative**: Adds complexity with WAL rotation, cleanup, and replay logic.\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| Drop spans during outage | Simple implementation, no resource pressure | Unacceptable data loss, violates APM's core purpose | Data loss is catastrophic for debugging production issues |\n| In-memory buffering only | Fast, no disk I/O overhead | Bounded by RAM, data loss on process restart | Memory is precious and expensive; outages may last longer than RAM can buffer |\n| **WAL + delayed retry** | Durable, handles arbitrary outage length, self-healing | Disk I/O overhead, cleanup complexity | **CHOSEN** - Provides strongest durability with manageable operational complexity |\n\n### Backpressure and Degraded Modes\n\n#### Mental Model: The Pressure Release Valve\n\nImagine a steam boiler with multiple safety valves. Under normal pressure, all valves remain closed. As pressure increases, smaller valves open first to relieve minor overpressure. In extreme conditions, the main rupture disk bursts to prevent catastrophic explosion, sacrificing the disk to save the boiler. Our APM system implements similar **cascading backpressure mechanisms**: starting with gentle load shedding (adjusting sampling rates) and escalating to aggressive measures (dropping all low-priority data) when under extreme load.\n\n#### Cascading Backpressure Strategy\n\nThe system implements a multi-tiered approach to handle load, with each tier activating at progressively severe conditions:\n\n**Tier 1: Adaptive Sampling Adjustment** (Load > 80% capacity)\n- Automatically reduce head sampling rates for high-traffic services\n- Increase tail sampling thresholds to keep only critical errors\n- Adjust based on real-time throughput measurements\n- **Activation**: When ingestion queue depth exceeds 80% of buffer capacity\n\n**Tier 2: Selective Load Shedding** (Load > 95% capacity)\n- Reject spans from pre-configured low-priority services\n- Implement per-client rate limiting with 429 responses\n- Temporarily disable expensive processing (detailed attribute indexing)\n- **Activation**: When memory utilization exceeds 90% or CPU > 85%\n\n**Tier 3: Aggressive Degradation** (Load > 100% capacity, system unstable)\n- Drop all head sampling (100% drop rate)\n- Process only tail sampling for critical errors\n- Disable service map updates and analytics aggregation\n- Return \"degraded service\" status from health endpoints\n- **Activation**: When system is at risk of OOM kill or complete unresponsiveness\n\n**Tier 4: Fail-Safe Mode** (Complete overload, preserving core function)\n- Write spans directly to WAL without processing\n- Disable all HTTP/gRPC endpoints except health check\n- Log detailed diagnostics for post-mortem analysis\n- **Activation**: Manual trigger or automatic when multiple collectors fail\n\n#### Degraded Modes Operation\n\nWhen the system enters a degraded mode, it maintains transparency through:\n\n1. **Health Endpoint Status Levels**:\n   - `/healthz` returns HTTP 200 with `{\"status\": \"healthy\"}`\n   - `/healthz` returns HTTP 200 with `{\"status\": \"degraded\", \"affected_components\": [\"sampling\", \"analytics\"]}`\n   - `/healthz` returns HTTP 503 with `{\"status\": \"unhealthy\", \"reason\": \"storage_unavailable\"}`\n\n2. **Client Notification**:\n   - HTTP 429 responses include `Retry-After: 30` header\n   - gRPC status codes with `RESOURCE_EXHAUSTED` and retry hints\n   - SDKs receive backpressure signals and apply client-side sampling\n\n3. **Monitoring and Alerting**:\n   - Each backpressure tier activation emits structured log event\n   - Metrics track time spent in each degraded state\n   - Alert managers notified of state transitions for operator intervention\n\n#### ADR: Backpressure Implementation Pattern\n\n**Decision: Client-Responsive Backpressure with Progressive Degradation**\n\n- **Context**: Under extreme load, the system must protect itself while providing the best possible service. Simply rejecting all requests leads to \"goodput collapse\" where useful work drops to zero. We need a strategy that maximizes valuable output (error traces, high-latency traces) while shedding less important load.\n\n- **Options Considered**:\n  1. **Random drop**: Simple random selection of requests to reject.\n  2. **Queue-based backpressure**: Use bounded queues that block when full, pushing back on clients.\n  3. **Adaptive priority-based shedding**: Intelligently select which traces to process based on their likely value.\n\n- **Decision**: Implement **adaptive priority-based shedding** using a combination of:\n   - Client-side sampling adjustments (via response headers)\n   - Server-side priority queues\n   - Value-based trace selection (errors, high latency first)\n\n- **Rationale**:\n  - Random drop wastes capacity on unimportant traces while potentially dropping critical ones.\n  - Queue-based backpressure can cause cascading failures upstream when clients block.\n  - Priority-based shedding maximizes the value of processed traces during overload, acting like a triage system that prioritizes the most medically critical patients during an emergency.\n\n- **Consequences**:\n  - **Positive**: Maximizes retention of operationally valuable traces during overload.\n  - **Positive**: Clients automatically adjust their sampling rates based on server feedback.\n  - **Negative**: More complex to implement than simple random drop.\n  - **Negative**: Requires coordination between client SDKs and collector.\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| Random drop | Trivial to implement, predictable load reduction | Wastes capacity on low-value traces, drops critical data | Poor utilization of limited resources during crisis |\n| Queue-based backpressure | Simple, preserves order, no data loss | Can cause upstream cascading failures, clients may timeout | Backpressure should propagate intelligently, not just block |\n| **Adaptive priority-based shedding** | Maximizes value retention, adapts to load | Complex implementation, requires client cooperation | **CHOSEN** - Provides optimal trade-off between self-protection and service value |\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Circuit Breaker | Manual state tracking with counters | `github.com/sony/gobreaker` for production-ready circuit breaker |\n| Rate Limiting | Token bucket using `time.Ticker` | `golang.org/x/time/rate` for sophisticated limiting |\n| Health Checks | Simple HTTP handler with status flags | `github.com/heptiolabs/healthcheck` with Kubernetes probes |\n| WAL Implementation | Custom file rotation with fsync | `github.com/tidwall/wal` for production-grade WAL |\n| Backpressure Signals | HTTP 429 with Retry-After header | gRPC flow control with `RESOURCE_EXHAUSTED` status |\n\n#### Recommended File/Module Structure\n\n```\nproject-root/\n  cmd/collector/main.go                    # Entry point with graceful shutdown\n  internal/\n    apm/\n      collector/\n        health/                            # Health check subsystem\n          health.go                        # Health status tracking\n          handler.go                       # HTTP health endpoint\n        backpressure/                      # Backpressure management\n          manager.go                       # Backpressure tier management\n          signals.go                       # Client backpressure signaling\n        degradation/                       # Degraded mode handling\n          modes.go                         # Degraded mode state machine\n          monitor.go                       # Mode transition monitoring\n      resilience/\n        circuitbreaker/                    # Circuit breaker implementation\n          breaker.go                       # Storage client circuit breaker\n          metrics.go                       # Breaker state metrics\n        ratelimiter/                       # Rate limiting\n          limiter.go                       # Token bucket rate limiter\n          middleware.go                    # HTTP/gRPC rate limit middleware\n        wal/                               # Write-Ahead Log\n          writer.go                        # WAL writer with rotation\n          replayer.go                      # WAL replay on recovery\n          cleaner.go                       # WAL file cleanup\n      errors/                              # Error types and handling\n        errors.go                          # Custom error types\n        recovery.go                        # Error recovery utilities\n  pkg/\n    api/\n      middlewares/                         # HTTP/gRPC middlewares\n        recovery.go                        # Panic recovery middleware\n        backpressure.go                    # Backpressure injection middleware\n```\n\n#### Infrastructure Starter Code\n\n**Complete WAL Implementation for Storage Failures:**\n\n```go\n// internal/apm/resilience/wal/writer.go\npackage wal\n\nimport (\n    \"encoding/binary\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"sync\"\n    \"time\"\n)\n\n// WALWriter provides durable write-ahead logging for spans during storage outages\ntype WALWriter struct {\n    mu           sync.RWMutex\n    file         *os.File\n    filePath     string\n    offset       int64\n    maxFileSize  int64\n    currentSize  int64\n    rotateSignal chan struct{}\n    done         chan struct{}\n}\n\n// NewWALWriter creates a new WAL writer with automatic rotation\nfunc NewWALWriter(dataDir string, maxFileSize int64) (*WALWriter, error) {\n    if err := os.MkdirAll(dataDir, 0755); err != nil {\n        return nil, fmt.Errorf(\"failed to create WAL directory: %w\", err)\n    }\n    \n    filePath := filepath.Join(dataDir, fmt.Sprintf(\"wal-%d.bin\", time.Now().UnixNano()))\n    file, err := os.OpenFile(filePath, os.O_CREATE|os.O_RDWR|os.O_APPEND, 0644)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create WAL file: %w\", err)\n    }\n    \n    stat, err := file.Stat()\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to stat WAL file: %w\", err)\n    }\n    \n    w := &WALWriter{\n        file:         file,\n        filePath:     filePath,\n        offset:       0,\n        maxFileSize:  maxFileSize,\n        currentSize:  stat.Size(),\n        rotateSignal: make(chan struct{}, 1),\n        done:         make(chan struct{}),\n    }\n    \n    // Start background rotation monitor\n    go w.rotationMonitor()\n    \n    return w, nil\n}\n\n// Append writes a record to WAL with length-prefixed format\nfunc (w *WALWriter) Append(data []byte) (int64, error) {\n    w.mu.Lock()\n    defer w.mu.Unlock()\n    \n    // Check if we need to rotate\n    if w.currentSize+int64(len(data))+8 > w.maxFileSize {\n        if err := w.rotate(); err != nil {\n            return 0, fmt.Errorf(\"failed to rotate WAL: %w\", err)\n        }\n    }\n    \n    // Write length prefix (8 bytes)\n    length := uint64(len(data))\n    if err := binary.Write(w.file, binary.LittleEndian, length); err != nil {\n        return 0, fmt.Errorf(\"failed to write length prefix: %w\", err)\n    }\n    \n    // Write data\n    n, err := w.file.Write(data)\n    if err != nil {\n        return 0, fmt.Errorf(\"failed to write WAL data: %w\", err)\n    }\n    \n    // Sync for durability\n    if err := w.file.Sync(); err != nil {\n        return 0, fmt.Errorf(\"failed to sync WAL: %w\", err)\n    }\n    \n    currentOffset := w.offset\n    w.offset += int64(n + 8) // Include length prefix\n    w.currentSize += int64(n + 8)\n    \n    return currentOffset, nil\n}\n\n// rotate creates a new WAL file and closes the old one\nfunc (w *WALWriter) rotate() error {\n    oldFile := w.file\n    \n    // Create new file\n    newFilePath := filepath.Join(filepath.Dir(w.filePath), \n        fmt.Sprintf(\"wal-%d.bin\", time.Now().UnixNano()))\n    newFile, err := os.OpenFile(newFilePath, os.O_CREATE|os.O_RDWR|os.O_APPEND, 0644)\n    if err != nil {\n        return fmt.Errorf(\"failed to create new WAL file: %w\", err)\n    }\n    \n    // Update state\n    w.file = newFile\n    w.filePath = newFilePath\n    w.offset = 0\n    w.currentSize = 0\n    \n    // Close old file\n    if err := oldFile.Close(); err != nil {\n        return fmt.Errorf(\"failed to close old WAL file: %w\", err)\n    }\n    \n    // Signal cleanup goroutine\n    select {\n    case w.rotateSignal <- struct{}{}:\n    default:\n    }\n    \n    return nil\n}\n\n// Close gracefully closes the WAL writer\nfunc (w *WALWriter) Close() error {\n    close(w.done)\n    w.mu.Lock()\n    defer w.mu.Unlock()\n    return w.file.Close()\n}\n\n// rotationMonitor handles cleanup of old WAL files\nfunc (w *WALWriter) rotationMonitor() {\n    ticker := time.NewTicker(5 * time.Minute)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case <-w.rotateSignal:\n            w.cleanupOldFiles()\n        case <-ticker.C:\n            w.cleanupOldFiles()\n        case <-w.done:\n            return\n        }\n    }\n}\n\n// cleanupOldFiles removes WAL files older than retention period\nfunc (w *WALWriter) cleanupOldFiles() {\n    // Implementation for cleaning up old WAL files\n    // Keep last 24 hours of WAL files for recovery\n}\n\n// WALReader reads records from WAL file for replay\ntype WALReader struct {\n    file *os.File\n}\n\n// NewWALReader creates a reader for replaying WAL entries\nfunc NewWALReader(filePath string) (*WALReader, error) {\n    file, err := os.Open(filePath)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open WAL file: %w\", err)\n    }\n    return &WALReader{file: file}, nil\n}\n\n// ReadNext reads the next record from WAL\nfunc (r *WALReader) ReadNext() ([]byte, error) {\n    // Read length prefix\n    var length uint64\n    if err := binary.Read(r.file, binary.LittleEndian, &length); err != nil {\n        return nil, err // EOF or error\n    }\n    \n    // Read data\n    data := make([]byte, length)\n    n, err := r.file.Read(data)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read WAL data: %w\", err)\n    }\n    if uint64(n) != length {\n        return nil, fmt.Errorf(\"short read: expected %d, got %d\", length, n)\n    }\n    \n    return data, nil\n}\n```\n\n**Circuit Breaker for Storage Client:**\n\n```go\n// internal/apm/resilience/circuitbreaker/breaker.go\npackage circuitbreaker\n\nimport (\n    \"context\"\n    \"errors\"\n    \"sync\"\n    \"sync/atomic\"\n    \"time\"\n)\n\nvar (\n    ErrCircuitOpen    = errors.New(\"circuit breaker is open\")\n    ErrTooManyRequests = errors.New(\"too many requests in half-open state\")\n)\n\n// State represents circuit breaker state\ntype State int32\n\nconst (\n    StateClosed State = iota\n    StateOpen\n    StateHalfOpen\n)\n\n// CircuitBreaker implements the circuit breaker pattern\ntype CircuitBreaker struct {\n    mu                sync.RWMutex\n    state             State\n    failureThreshold  int\n    successThreshold  int\n    failureCount      int\n    successCount      int\n    timeout           time.Duration\n    lastFailure       time.Time\n    halfOpenMax       int\n    halfOpenCount     int32\n    onStateChange     func(from, to State)\n}\n\n// Config holds circuit breaker configuration\ntype Config struct {\n    FailureThreshold int           // Failures before opening circuit\n    SuccessThreshold int           // Successes before closing circuit\n    Timeout          time.Duration // How long to stay open before half-open\n    HalfOpenMax      int           // Max requests allowed in half-open state\n}\n\n// NewCircuitBreaker creates a new circuit breaker\nfunc NewCircuitBreaker(config Config) *CircuitBreaker {\n    return &CircuitBreaker{\n        state:            StateClosed,\n        failureThreshold: config.FailureThreshold,\n        successThreshold: config.SuccessThreshold,\n        timeout:          config.Timeout,\n        halfOpenMax:      config.HalfOpenMax,\n    }\n}\n\n// Execute runs the operation with circuit breaker protection\nfunc (cb *CircuitBreaker) Execute(ctx context.Context, operation func() error) error {\n    // Check if we should allow the request\n    if !cb.allowRequest() {\n        return ErrCircuitOpen\n    }\n    \n    // Execute the operation\n    err := operation()\n    \n    // Record the result\n    cb.recordResult(err)\n    \n    return err\n}\n\n// allowRequest determines if a request should be allowed\nfunc (cb *CircuitBreaker) allowRequest() bool {\n    cb.mu.RLock()\n    defer cb.mu.RUnlock()\n    \n    switch cb.state {\n    case StateClosed:\n        return true\n    case StateOpen:\n        // Check if timeout has elapsed\n        if time.Since(cb.lastFailure) > cb.timeout {\n            cb.mu.RUnlock()\n            cb.mu.Lock()\n            // Double-check after acquiring write lock\n            if cb.state == StateOpen && time.Since(cb.lastFailure) > cb.timeout {\n                cb.state = StateHalfOpen\n                cb.halfOpenCount = 0\n                if cb.onStateChange != nil {\n                    cb.onStateChange(StateOpen, StateHalfOpen)\n                }\n            }\n            cb.mu.Unlock()\n            cb.mu.RLock()\n            // Now recheck state\n        }\n        return false\n    case StateHalfOpen:\n        // Allow only limited number of requests in half-open state\n        if atomic.LoadInt32(&cb.halfOpenCount) >= int32(cb.halfOpenMax) {\n            return false\n        }\n        atomic.AddInt32(&cb.halfOpenCount, 1)\n        return true\n    default:\n        return false\n    }\n}\n\n// recordResult updates circuit breaker state based on operation result\nfunc (cb *CircuitBreaker) recordResult(err error) {\n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n    \n    switch cb.state {\n    case StateClosed:\n        if err != nil {\n            cb.failureCount++\n            if cb.failureCount >= cb.failureThreshold {\n                cb.state = StateOpen\n                cb.lastFailure = time.Now()\n                if cb.onStateChange != nil {\n                    cb.onStateChange(StateClosed, StateOpen)\n                }\n            }\n        } else {\n            cb.failureCount = 0 // Reset on success\n        }\n    case StateHalfOpen:\n        if err != nil {\n            // Failure in half-open state -> back to open\n            cb.state = StateOpen\n            cb.lastFailure = time.Now()\n            cb.failureCount = 1\n            if cb.onStateChange != nil {\n                cb.onStateChange(StateHalfOpen, StateOpen)\n            }\n        } else {\n            cb.successCount++\n            if cb.successCount >= cb.successThreshold {\n                // Enough successes -> close the circuit\n                cb.state = StateClosed\n                cb.failureCount = 0\n                cb.successCount = 0\n                if cb.onStateChange != nil {\n                    cb.onStateChange(StateHalfOpen, StateClosed)\n                }\n            }\n        }\n    }\n}\n\n// State returns current circuit breaker state\nfunc (cb *CircuitBreaker) State() State {\n    cb.mu.RLock()\n    defer cb.mu.RUnlock()\n    return cb.state\n}\n\n// SetStateChangeCallback sets a callback for state changes\nfunc (cb *CircuitBreaker) SetStateChangeCallback(callback func(from, to State)) {\n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n    cb.onStateChange = callback\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Backpressure Manager Implementation:**\n\n```go\n// internal/apm/collector/backpressure/manager.go\npackage backpressure\n\nimport (\n    \"context\"\n    \"sync\"\n    \"time\"\n)\n\n// Tier represents a backpressure tier with activation thresholds\ntype Tier int\n\nconst (\n    TierNormal Tier = iota\n    TierAdaptiveSampling\n    TierSelectiveShedding\n    TierAggressiveDegradation\n    TierFailSafe\n)\n\n// Thresholds define when to transition between tiers\ntype Thresholds struct {\n    MemoryPercent      float64\n    CPULoadPercent     float64\n    QueueDepthPercent  float64\n    StorageLatencyMS   int64\n}\n\n// BackpressureManager manages system backpressure state\ntype BackpressureManager struct {\n    mu           sync.RWMutex\n    currentTier  Tier\n    thresholds   map[Tier]Thresholds\n    metrics      *SystemMetrics\n    stateChan    chan<- StateChange\n    lastCheck    time.Time\n    checkInterval time.Duration\n}\n\n// SystemMetrics contains system metrics for tier decisions\ntype SystemMetrics struct {\n    MemoryUsedPercent  float64\n    CPULoadPercent     float64\n    QueueDepthPercent  float64\n    StorageLatencyMS   int64\n    SpansDroppedPerSec int64\n    ActiveTraces       int64\n}\n\n// StateChange represents a backpressure state transition\ntype StateChange struct {\n    Timestamp time.Time\n    FromTier  Tier\n    ToTier    Tier\n    Reason    string\n    Metrics   SystemMetrics\n}\n\n// NewBackpressureManager creates a new backpressure manager\nfunc NewBackpressureManager(initialThresholds map[Tier]Thresholds, \n                          checkInterval time.Duration) *BackpressureManager {\n    return &BackpressureManager{\n        currentTier:  TierNormal,\n        thresholds:   initialThresholds,\n        checkInterval: checkInterval,\n    }\n}\n\n// Start begins monitoring and tier adjustment\nfunc (bm *BackpressureManager) Start(ctx context.Context) error {\n    ticker := time.NewTicker(bm.checkInterval)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case <-ticker.C:\n            bm.evaluateAndAdjust(ctx)\n        case <-ctx.Done():\n            return ctx.Err()\n        }\n    }\n}\n\n// evaluateAndAdjust evaluates current metrics and adjusts tier if needed\nfunc (bm *BackpressureManager) evaluateAndAdjust(ctx context.Context) {\n    // TODO 1: Gather current system metrics\n    //   - Memory usage from runtime.MemStats\n    //   - CPU load from gopsutil or runtime metrics\n    //   - Queue depth from BufferManager\n    //   - Storage latency from storage client metrics\n    \n    // TODO 2: Determine target tier based on thresholds\n    //   - Compare each metric against thresholds for each tier\n    //   - Select highest (most severe) tier where any threshold is exceeded\n    //   - Apply hysteresis: require sustained violation before tier increase\n    \n    // TODO 3: If tier change is needed:\n    //   - Log state transition with metrics snapshot\n    //   - Update currentTier with write lock\n    //   - Send StateChange to stateChan if configured\n    //   - Apply tier-specific actions (call applyTierActions)\n    \n    // TODO 4: If staying in same tier, check if we can downgrade\n    //   - Check if metrics have been below downgrade thresholds for cooldown period\n    //   - Gradually step down through tiers (don't jump from Tier 4 to Tier 0 directly)\n    \n    // TODO 5: Update lastCheck timestamp\n}\n\n// applyTierActions applies actions specific to the new tier\nfunc (bm *BackpressureManager) applyTierActions(ctx context.Context, newTier Tier) {\n    bm.mu.Lock()\n    defer bm.mu.Unlock()\n    \n    // TODO 1: For each component that needs adjustment, apply tier-specific changes:\n    //   - HeadSampler: adjust sampling rates (Tier 1-4)\n    //   - TailSampler: adjust evaluation thresholds (Tier 2-4)\n    //   - BufferManager: adjust eviction policy (Tier 2-4)\n    //   - Pipeline: disable expensive processing (Tier 3-4)\n    \n    // TODO 2: Update health endpoint status\n    //   - Set degraded status with affected components\n    \n    // TODO 3: Emit metrics for backpressure state\n    //   - Gauge for current tier\n    //   - Counter for tier transitions\n    \n    // TODO 4: Log transition at appropriate level\n    //   - INFO for Tier 0-2 transitions\n    //   - WARN for Tier 3 transitions\n    //   - ERROR for Tier 4 transitions\n}\n\n// CurrentTier returns the current backpressure tier\nfunc (bm *BackpressureManager) CurrentTier() Tier {\n    bm.mu.RLock()\n    defer bm.mu.RUnlock()\n    return bm.currentTier\n}\n\n// SetStateChangeChannel sets the channel for state change notifications\nfunc (bm *BackpressureManager) SetStateChangeChannel(ch chan<- StateChange) {\n    bm.mu.Lock()\n    defer bm.mu.Unlock()\n    bm.stateChan = ch\n}\n\n// GetRecommendedSamplingRate returns sampling rate recommendation for current tier\nfunc (bm *BackpressureManager) GetRecommendedSamplingRate(service string) float64 {\n    // TODO: Return appropriate sampling rate based on:\n    //   - Current tier\n    //   - Service priority (from configuration)\n    //   - Historical error rate for this service\n    //   - System-wide load metrics\n    return 1.0 // Default: keep all traces\n}\n\n// ShouldProcessSpan determines if a span should be processed in current tier\nfunc (bm *BackpressureManager) ShouldProcessSpan(span models.Span) bool {\n    tier := bm.CurrentTier()\n    \n    // TODO 1: For higher tiers, implement filtering logic:\n    //   - Tier 2: Check if service is in priority whitelist\n    //   - Tier 3: Check if span has error status or high latency\n    //   - Tier 4: Only process spans marked as critical\n    \n    // TODO 2: Apply sampling based on tier-specific rates\n    //   - Use consistent hashing for deterministic decisions\n    \n    // TODO 3: Return true if span should be processed, false to drop\n    return true\n}\n```\n\n**Health Check Endpoint with Degraded States:**\n\n```go\n// internal/apm/collector/health/handler.go\npackage health\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n)\n\n// HealthStatus represents system health status\ntype HealthStatus string\n\nconst (\n    StatusHealthy   HealthStatus = \"healthy\"\n    StatusDegraded  HealthStatus = \"degraded\"\n    StatusUnhealthy HealthStatus = \"unhealthy\"\n)\n\n// ComponentStatus represents status of an individual component\ntype ComponentStatus struct {\n    Name    string       `json:\"name\"`\n    Status  HealthStatus `json:\"status\"`\n    Details string       `json:\"details,omitempty\"`\n    Since   time.Time    `json:\"since\"`\n}\n\n// HealthResponse is the JSON response from health endpoint\ntype HealthResponse struct {\n    Status      HealthStatus      `json:\"status\"`\n    Timestamp   time.Time         `json:\"timestamp\"`\n    Components  []ComponentStatus `json:\"components,omitempty\"`\n    Message     string            `json:\"message,omitempty\"`\n    DegradedSince *time.Time      `json:\"degraded_since,omitempty\"`\n}\n\n// HealthRegistry manages component health status\ntype HealthRegistry struct {\n    mu         sync.RWMutex\n    components map[string]ComponentStatus\n    overrides  map[string]func() ComponentStatus\n    startTime  time.Time\n}\n\n// NewHealthRegistry creates a new health registry\nfunc NewHealthRegistry() *HealthRegistry {\n    return &HealthRegistry{\n        components: make(map[string]ComponentStatus),\n        overrides:  make(map[string]func() ComponentStatus),\n        startTime:  time.Now(),\n    }\n}\n\n// RegisterComponent adds a component to health checks\nfunc (r *HealthRegistry) RegisterComponent(name string, \n                                         checkFunc func() ComponentStatus) {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    r.overrides[name] = checkFunc\n}\n\n// SetComponentStatus manually sets a component's status\nfunc (r *HealthRegistry) SetComponentStatus(name string, status HealthStatus, \n                                          details string) {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    r.components[name] = ComponentStatus{\n        Name:    name,\n        Status:  status,\n        Details: details,\n        Since:   time.Now(),\n    }\n}\n\n// HealthHandler implements the HTTP health check endpoint\nfunc (r *HealthRegistry) HealthHandler(w http.ResponseWriter, req *http.Request) {\n    status := r.calculateOverallStatus()\n    response := r.buildHealthResponse(status)\n    \n    // Set appropriate HTTP status code\n    var httpStatus int\n    switch status {\n    case StatusHealthy:\n        httpStatus = http.StatusOK\n    case StatusDegraded:\n        httpStatus = http.StatusOK // 200 for degraded, body indicates issue\n    case StatusUnhealthy:\n        httpStatus = http.StatusServiceUnavailable\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(httpStatus)\n    json.NewEncoder(w).Encode(response)\n}\n\n// calculateOverallStatus determines overall system health\nfunc (r *HealthRegistry) calculateOverallStatus() HealthStatus {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n    \n    // TODO 1: Check all registered components\n    //   - Execute override functions for dynamic checks\n    //   - Merge with manually set component statuses\n    \n    // TODO 2: Apply health aggregation logic:\n    //   - If ANY component is \"unhealthy\", overall is \"unhealthy\"\n    //   - If ANY component is \"degraded\" but none are \"unhealthy\", overall is \"degraded\"\n    //   - Otherwise, \"healthy\"\n    \n    // TODO 3: Apply minimum uptime requirement\n    //   - If system started less than 30 seconds ago, return \"degraded\"\n    \n    return StatusHealthy\n}\n\n// buildHealthResponse constructs the health response JSON\nfunc (r *HealthRegistry) buildHealthResponse(overallStatus HealthStatus) HealthResponse {\n    // TODO: Build complete health response with:\n    //   - Overall status\n    //   - Timestamp\n    //   - All component statuses\n    //   - Uptime\n    //   - Version information\n    //   - Any degradation messages\n    \n    return HealthResponse{\n        Status:    overallStatus,\n        Timestamp: time.Now(),\n        Message:   \"System operational\",\n    }\n}\n\n// LivenessHandler returns simple liveness check (for Kubernetes)\nfunc (r *HealthRegistry) LivenessHandler(w http.ResponseWriter, req *http.Request) {\n    // TODO: Simple check - is the process running?\n    // Always return 200 unless process is terminally broken\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(\"ok\"))\n}\n\n// ReadinessHandler returns readiness check (for Kubernetes)\nfunc (r *HealthRegistry) ReadinessHandler(w http.ResponseWriter, req *http.Request) {\n    // TODO: Check if system is ready to receive traffic\n    // Return 200 if ready, 503 if not\n    status := r.calculateOverallStatus()\n    if status == StatusUnhealthy {\n        w.WriteHeader(http.StatusServiceUnavailable)\n        w.Write([]byte(\"not ready\"))\n    } else {\n        w.WriteHeader(http.StatusOK)\n        w.Write([]byte(\"ready\"))\n    }\n}\n```\n\n#### Language-Specific Hints\n\n**Go-Specific Error Handling Patterns:**\n\n1. **Context Cancellation for Timeouts**:\n   ```go\n   // Always pass context through call chains\n   func (c *Collector) StoreSpan(ctx context.Context, span models.Span) error {\n       // Use context for timeouts and cancellation\n       ctx, cancel := context.WithTimeout(ctx, c.config.Storage.Timeout)\n       defer cancel()\n       \n       return c.storage.WriteSpan(ctx, span)\n   }\n   ```\n\n2. **Error Wrapping with Context**:\n   ```go\n   // Use fmt.Errorf with %w for wrapping errors\n   func processBatch(batch []byte) error {\n       spans, err := parseSpans(batch)\n       if err != nil {\n           return fmt.Errorf(\"failed to parse batch: %w\", err)\n       }\n       \n       for _, span := range spans {\n           if err := validateSpan(span); err != nil {\n               // Add span context to error\n               return fmt.Errorf(\"invalid span %s: %w\", span.SpanID, err)\n           }\n       }\n       return nil\n   }\n   ```\n\n3. **Structured Error Types**:\n   ```go\n   // Define error types for different failure modes\n   type StorageError struct {\n       Op      string\n       Err     error\n       RetryAfter time.Duration\n   }\n   \n   func (e *StorageError) Error() string {\n       return fmt.Sprintf(\"storage error during %s: %v\", e.Op, e.Err)\n   }\n   \n   func (e *StorageError) Unwrap() error {\n       return e.Err\n   }\n   \n   // Check error types for recovery decisions\n   if errors.Is(err, &StorageError{}) {\n       var storageErr *StorageError\n       if errors.As(err, &storageErr) {\n           time.Sleep(storageErr.RetryAfter)\n           // Retry the operation\n       }\n   }\n   ```\n\n4. **Graceful Shutdown with Context**:\n   ```go\n   // Implement graceful shutdown in main\n   func main() {\n       collector, err := collector.New(config)\n       if err != nil { /* handle */ }\n       \n       // Start collector in background\n       ctx, cancel := context.WithCancel(context.Background())\n       go func() {\n           if err := collector.Start(ctx); err != nil {\n               log.Fatalf(\"Collector failed: %v\", err)\n           }\n       }()\n       \n       // Handle OS signals\n       sigChan := make(chan os.Signal, 1)\n       signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n       \n       <-sigChan // Wait for signal\n       \n       // Start graceful shutdown\n       log.Println(\"Shutting down gracefully...\")\n       cancel()\n       \n       // Give components time to clean up\n       shutdownCtx, shutdownCancel := context.WithTimeout(\n           context.Background(), 30*time.Second)\n       defer shutdownCancel()\n       \n       // Wait for shutdown or timeout\n       <-shutdownCtx.Done()\n       log.Println(\"Shutdown complete\")\n   }\n   ```\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Spans being dropped under load** | Backpressure tier activation | 1. Check `/healthz` endpoint for degraded status<br>2. Examine backpressure manager logs for tier transitions<br>3. Monitor `apm_backpressure_current_tier` metric | 1. Increase collector resources<br>2. Adjust backpressure thresholds<br>3. Optimize span processing pipeline |\n| **High memory usage with frequent GC** | Buffer growth or memory leak | 1. Use `pprof` to capture heap profile<br>2. Check `BufferManager` trace count<br>3. Look for unbounded maps or slices | 1. Reduce `maxTraceDuration`<br>2. Implement more aggressive eviction<br>3. Fix memory leaks in span processing |\n| **Storage timeouts causing cascading failures** | Storage overload or network issues | 1. Check storage health metrics<br>2. Examine circuit breaker state<br>3. Look for WAL growth indicating write failures | 1. Increase storage capacity<br>2. Adjust circuit breaker thresholds<br>3. Implement storage connection pooling |\n| **Clock skew warnings in logs** | NTP sync issues or VM clock drift | 1. Compare timestamps from different services in same trace<br>2. Check system clock sync status<br>3. Look for negative durations | 1. Implement NTP on all hosts<br>2. Use collector clock normalization<br>3. Warn users about misconfigured hosts |\n| **Service map showing impossible latencies** | Async spans or incorrect parent-child links | 1. Examine span parent relationships<br>2. Check for async operation markers<br>3. Look for clock correction artifacts | 1. Improve async span detection<br>2. Implement span relationship validation<br>3. Apply timestamp normalization corrections |\n| **WAL files accumulating without cleanup** | Storage recovery failures or configuration issues | 1. Check WAL replayer logs for errors<br>2. Verify storage connectivity<br>3. Check disk space on collector nodes | 1. Fix storage connection issues<br>2. Implement WAL cleanup job<br>3. Monitor disk usage with alerts |\n\n#### Milestone Checkpoint\n\nAfter implementing error handling and backpressure mechanisms, verify resilience with these tests:\n\n1. **Storage Failure Simulation**:\n   ```bash\n   # Stop storage backend\n   docker-compose stop apm-storage\n   \n   # Send spans - should see WAL writes but no errors\n   go run test/loadgen/main.go --spans-per-sec=100 --duration=30s\n   \n   # Check WAL directory for new files\n   ls -la /var/lib/apm/wal/\n   \n   # Restart storage\n   docker-compose start apm-storage\n   \n   # Verify spans are replayed from WAL\n   tail -f /var/log/apm/collector.log | grep \"WAL replay\"\n   \n   # Query for test traces - should appear within 60 seconds\n   curl \"http://localhost:8080/api/traces?service=test-service\"\n   ```\n\n2. **Backpressure Activation Test**:\n   ```bash\n   # Generate overload traffic\n   go run test/loadgen/main.go --spans-per-sec=5000 --duration=60s\n   \n   # Monitor health endpoint for tier transitions\n   watch -n1 'curl -s http://localhost:8080/healthz | jq .'\n   \n   # Check metrics for backpressure state\n   curl -s http://localhost:8080/metrics | grep backpressure\n   \n   # Verify spans are being sampled more aggressively\n   curl -s http://localhost:8080/metrics | grep spans_dropped\n   ```\n\n3. **Error Recovery Verification**:\n   ```bash\n   # Send malformed spans\n   curl -X POST http://localhost:8080/v1/traces \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"invalid\": \"data\"}'\n   \n   # Should receive 400 with error details\n   # Collector should continue processing other requests\n   \n   # Send valid spans after error\n   go run test/loadgen/main.go --spans-per-sec=10 --duration=5s\n   \n   # Verify normal processing resumes\n   ```\n\nExpected signs of correct implementation:\n- Collector remains responsive during storage outages\n- Memory usage stays within configured bounds under load\n- Health endpoint accurately reflects system state\n- WAL files are created during outages and cleaned up after recovery\n- No panics or deadlocks under stress conditions\n\nSigns of incorrect implementation:\n- Collector crashes or becomes unresponsive under load\n- Memory grows unbounded until OOM kill\n- Spans are lost permanently during storage outages\n- Health endpoint shows \"healthy\" when components are failing\n- WAL files accumulate indefinitely without cleanup\n\n---\n\n\n> **Milestone(s):** This section applies to all five milestones, providing a comprehensive testing strategy that verifies each component and the system as a whole.\n\n## 12. Testing Strategy\n\nThe APM Tracing System is a complex distributed application that must be reliable under heavy load, process data correctly even when it arrives out of order, and degrade gracefully when stressed. A robust testing strategy is not a luxury but a necessity. We must verify not only that the system works under ideal conditions, but that it handles the messy reality of production—network failures, clock skew, malformed data, and traffic spikes—without data loss or cascading failures.\n\nThis strategy is built on a foundation of **property-based testing** for core data invariants, **chaos testing** for resilience, and **concrete milestone checkpoints** that provide clear, binary pass/fail criteria for each development stage.\n\n### Testing Approaches: Unit, Integration, and Load\n\nTesting in the APM system occurs at three complementary levels, each with distinct goals and techniques.\n\n**Mental Model: The Building Inspection, Fire Drill, and Stress Test**\nThink of testing our system like ensuring a new skyscraper is safe. **Unit tests** are like inspecting individual steel beams and concrete pillars—verifying each component in isolation meets its specification. **Integration tests** are like a fire drill—testing how people (components) move through stairwells and exits (APIs and data flows) in a coordinated way under simulated emergency (failure) conditions. **Load tests** are the structural stress test—applying massive weight (traffic) to see if the building sways within acceptable limits or collapses, revealing bottlenecks and breaking points.\n\n#### Unit Testing: Verifying Component Invariants\nUnit tests focus on the smallest testable units of code—typically individual functions or methods—in complete isolation. Mocks and stubs are used heavily to control the environment and dependencies.\n\n**Key Areas for Unit Testing:**\n1.  **Data Structure Validation:** Ensure that `Span`, `Trace`, and other core types enforce their invariants (e.g., a `Span`'s `EndTime` must be after its `StartTime`).\n2.  **Algorithm Correctness:** Test the step-by-step logic of critical algorithms with known inputs and expected outputs.\n    *   **Trace Assembly:** Given a specific, unordered set of `Span` objects, verify that `TraceAssembler.AssembleTrace` produces the correct hierarchical tree structure.\n    *   **Sampling Decisions:** For a given `traceID` and sampling rate, the `ConsistentSampler.ShouldSample` method must return a deterministic, predictable result.\n    *   **Percentile Calculation:** Feed a known sequence of latency values into `TDigestMetric` and verify that `Quantile(0.95)` returns a value within an acceptable error margin.\n3.  **State Machine Transitions:** Test that the `CircuitBreaker` and `BackpressureManager` transition between states (`StateClosed`, `StateOpen`, `TierNormal`, `TierAdaptiveSampling`) exactly when the defined thresholds are crossed.\n4.  **Error Handling:** Verify that functions return the expected errors for invalid inputs (e.g., `StoreSpan` with an empty `TraceID`) or when dependencies fail (e.g., a mocked storage layer returns `io.EOF`).\n\n**Property-Based Testing for Core Logic:**\nFor algorithms where the output space is large or complex, we employ property-based testing (using a library like `github.com/leanovate/gopter` for Go). Instead of writing individual example-based tests, we define *properties* that must *always* hold true for any valid input, and the framework generates hundreds of random test cases.\n\n| Component | Property to Test | Description |\n| :--- | :--- | :--- |\n| `TraceAssembler` | **Trace Completeness:** | For any generated set of spans belonging to the same trace, if `IsTraceComplete` returns `true`, then the assembled trace must contain exactly those spans, and the trace's `StartTime` must be the earliest span start, and `EndTime` the latest span end. |\n| `ConsistentSampler` | **Determinism & Rate Adherence:** | For any `traceID` and sampling `rate`, the `ShouldSample` decision must be identical for all calls. Over a large number of random `traceID`s, the ratio of `true` decisions must converge to `rate` within a small statistical error. |\n| `TDigestMetric` | **Percentile Monotonicity:** | For any set of added values, the computed quantiles must be monotonically non-decreasing: `Quantile(0.50)` ≤ `Quantile(0.95)` ≤ `Quantile(0.99)`. |\n| `BufferManager` | **Capacity Bound:** | No matter the order or timing of `AddSpan` calls, the total number of spans stored in the `BufferManager` must never exceed its configured `maxSize`. |\n\n**ADR: Mocking Strategy for External Dependencies**\n> **Decision: Use Interface-Based Mocking with Generated Test Doubles**\n> - **Context:** Our components depend on external systems (storage, network) and other internal modules. We need to isolate units for testing without bringing up entire systems.\n> - **Options Considered:**\n>     1.  **Hand-written mocks:** Create concrete test types that implement our defined interfaces (e.g., `storage.Writer`).\n>     2.  **Mock generation tools:** Use a tool like `mockgen` (for Go) to automatically generate mock implementations from interfaces.\n>     3.  **Integration-heavy unit tests:** Use lightweight, real implementations (e.g., an in-memory map for storage).\n> - **Decision:** Use **interface-based design** combined with **generated mocks** for complex dependencies, and **lightweight real implementations** (fakes) for simpler ones.\n> - **Rationale:** Generated mocks reduce boilerplate and are consistent. They allow us to easily set expectations (e.g., \"`StoreSpan` should be called exactly once with these arguments\") and simulate failures. For simpler dependencies like an in-memory store, a fake is easier to reason about and can be used in integration tests as well.\n> - **Consequences:** Developers must define clear interfaces. The build process requires a mock generation step. Tests become tightly coupled to mock expectations, which can make them brittle if interactions change frequently.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| Hand-written mocks | Full control, no extra tooling. | High boilerplate, tedious to maintain for large interfaces. | For simple, stable interfaces. |\n| Generated mocks (mockgen) | Low maintenance, consistent patterns, powerful expectation API. | Adds build step, can produce verbose tests, learning curve. | **Yes**, for core external dependencies (Storage, WAL). |\n| Lightweight real implementations (Fakes) | Realistic behavior, can be used in integration tests. | May hide bugs if the fake doesn't perfectly emulate the real component. | **Yes**, for internal abstractions like `EdgeStorage`. |\n\n#### Integration Testing: Verifying Component Interaction\nIntegration tests verify that multiple components work together correctly. They use real implementations for some components and mocked or faked versions for others (like external services).\n\n**Key Integration Test Scenarios:**\n1.  **End-to-End Ingestion Pipeline:** Send a batch of OTLP-formatted spans via HTTP to the `OTLPHandler`. Verify that they flow through the `Pipeline` (validation, buffering, sampling) and are eventually persisted by the `storage.Writer` (using an in-memory or test-database implementation).\n2.  **Service Map Construction:** Feed a set of spans representing calls between services `A->B` and `B->C` into the `GraphBuilder`. Verify that `BuildCurrentGraph` produces a `ServiceGraph` with three `ServiceNode`s and two `ServiceEdge`s with correct aggregated metrics.\n3.  **Cross-Component Error Propagation:** Simulate a failure in the storage layer and verify that the `CircuitBreaker` on the `Pipeline` trips open, causing subsequent span processing attempts to fail fast with `ErrCircuitOpen`, and that the system's health endpoint (`HealthHandler`) reflects a `StatusDegraded` state.\n4.  **Context Propagation:** Use the `APM SDK`'s `Tracer` to instrument a simple HTTP client and server in the same test process. Verify that the `TraceID` created on the client is correctly propagated via headers and appears in the span generated by the server, linking them in the collected trace.\n\n**Chaos Testing for Resilience:**\nChaos testing involves deliberately injecting failures into a running system to verify its resilience and recovery mechanisms. These are run less frequently, often in a dedicated staging environment.\n\n| Failure Injection | Expected System Behavior | Verification Method |\n| :--- | :--- | :--- |\n| **Kill the `Collector` process** while spans are being ingested. | The WAL (`WALWriter`) should have recorded spans before the crash. Upon restart, the `WALReader` should replay unprocessed spans, and no data should be lost. | Compare span count before crash and after recovery. |\n| **Introduce network latency or packet loss** between the SDK and Collector. | The SDK's `SpanExporter` should implement retries with exponential backoff. The `CircuitBreaker` in the Collector's ingress may open if failures persist, shedding load gracefully. | Verify spans are eventually received despite temporary network issues. |\n| **Fill the disk** used by the storage backend. | The storage layer should return errors. The `BackpressureManager` should escalate to `TierAggressiveDegradation` or `TierFailSafe`, dramatically increasing sampling rates or rejecting non-critical traffic, preventing a complete crash. | Monitor system logs for escalation events and verify it remains responsive for health checks. |\n| **Simulate clock skew** by feeding spans with timestamps from wildly different system times. | The `TraceAssembler` should use a watermark algorithm or buffer TTL to eventually assemble traces correctly, albeit with delay. Late-arriving spans beyond the `maxTraceDuration` should be logged and discarded. | Verify that traces with correct internal relationships are still assembled, even if out-of-order. |\n\n#### Load and Performance Testing: Verifying Scalability\nLoad tests verify that the system meets its performance requirements (e.g., 1000 spans/sec) and identify bottlenecks under stress. These tests require careful planning and monitoring.\n\n**Key Performance Tests:**\n1.  **Ingestion Throughput:** Ramp up the rate of span submission to the Collector's OTLP endpoint until the system's response latency exceeds the 100ms SLA or spans start being dropped (monitored via `PipelineMetrics.SpansDropped`). Plot the relationship between input rate, CPU/memory usage, and latency.\n2.  **Concurrent Trace Assembly:** Generate a high volume of complex, multi-span traces where spans arrive out of order. Measure the memory footprint of the `BufferManager` and the accuracy of trace completion decisions.\n3.  **Sampling Overhead:** Measure the CPU cost of `HeadSampler.Decide` and `TailSampler.EvaluateTrace` at high decision rates. Ensure sampling logic does not become the bottleneck.\n4.  **Query Performance:** With a large dataset of stored traces, measure the latency of `GetTraceByID`, `GetTracesByService`, and `BuildCurrentGraph` for service maps under increasing data volumes.\n\n**Tooling:** Use tools like Apache Bench (`ab`), `wrk`, or custom Go load-test clients to generate traffic. Use the application's own metrics (`PipelineMetrics`, `HeadSamplerStats`) and system-level profiling (Go's `pprof`) to identify hotspots.\n\n### Milestone Checkpoints and Verification\nEach milestone has concrete acceptance criteria. The following checklists provide verifiable, binary steps to confirm functionality before moving on. Treat these as the \"definition of done\" for each phase.\n\n#### Milestone 1: Trace Collection\n| Checkpoint | Verification Steps | Expected Outcome / Pass Criteria |\n| :--- | :--- | :--- |\n| **Ingestion API Accepts Spans** | 1. Start the Collector with an in-memory storage backend.<br>2. Use `curl` or a test client to send a valid OTLP/JSON span payload to `POST /v1/traces`.<br>3. Check the HTTP response status and timing. | Response status is `200 OK`. Response time is < 100ms. |\n| **Spans are Parsed & Validated** | 1. Send a span with an invalid `TraceID` (e.g., empty string).<br>2. Send a span with a future `StartTime`.<br>3. Send a valid span with attributes and events. | Invalid spans are rejected with `400 Bad Request`. Valid span is accepted and its internal representation matches the sent data. |\n| **Spans are Indexed & Retrievable** | 1. Send 10 spans belonging to 2 different traces.<br>2. Call `GetTraceByID` for each trace ID via a test client or admin API.<br>3. Call `GetTracesByService` for the involved service name. | Each call returns the correct, complete set of spans for that trace or service. Spans maintain their parent-child relationships. |\n| **Throughput Requirement Met** | 1. Write a load test client that sustains 1000 spans/sec for 60 seconds.<br>2. Monitor the Collector's logs and metrics for errors or drops.<br>3. After the test, query for the total number of spans stored. | No errors or warnings in logs. `SpansDropped` metric is zero. Total stored span count is within 1% of 60,000 (accounting for sampling if enabled). |\n| **Late-Arriving Span Handling** | 1. Send Span B (child) before Span A (parent).<br>2. Wait longer than the buffer's typical flush time.<br>3. Send Span A.<br>4. Query for the complete trace. | The trace is eventually assembled and returned correctly, demonstrating the buffer held Span B until its parent arrived. |\n\n#### Milestone 2: Service Map\n| Checkpoint | Verification Steps | Expected Outcome / Pass Criteria |\n| :--- | :--- | :--- |\n| **Dependency Extraction** | 1. Feed spans representing a chain of calls: `ServiceA -> ServiceB -> ServiceC`.<br>2. Run the `EdgeAggregator.ProcessSpan` logic offline or via test.<br>3. Inspect the generated `ServiceEdge` objects. | Two edges are created: (`ServiceA`, `ServiceB`) and (`ServiceB`, `ServiceC`). Each edge's `TotalCalls` is correct. |\n| **Graph Construction** | 1. Feed a more complex set of spans with multiple callers to the same service and some error responses.<br>2. Call `GraphBuilder.BuildCurrentGraph`.<br>3. Inspect the resulting `ServiceGraph`. | The graph contains the correct number of nodes and edges. Edges for calls with errors have `ErrorRate` > 0. The `P95Latency` field is populated. |\n| **Topology Change Detection** | 1. Build a graph for time window T1.<br>2. Feed new spans where a new `ServiceD` appears and calls `ServiceA`.<br>3. Build a graph for the next window T2.<br>4. Call `DetectTopologyChanges`. | The change detection correctly identifies `ServiceD` as a new node and a new edge (`ServiceD`, `ServiceA`). |\n| **Real-Time Update** | 1. Start a live visualization endpoint or test that consumes the graph.<br>2. Continuously feed spans from a changing service topology.<br>3. Monitor the graph output. | The graph updates within the configured refresh interval (e.g., 1 minute) to reflect new services and dependencies. |\n\n#### Milestone 3: Trace Sampling\n| Checkpoint | Verification Steps | Expected Outcome / Pass Criteria |\n| :--- | :--- | :--- |\n| **Head-Based Sampling Rate Adherence** | 1. Configure a `HeadSampler` with a global rate of 0.1 (10%).<br>2. Send 10,000 traces with unique IDs.<br>3. Collect the `HeadSamplerStats`. | The ratio of `TracesSampled` to `TotalTraces` is between 9% and 11%. |\n| **Consistent Sampling per Trace** | 1. Send all spans for a single trace (5 spans) one by one.<br>2. Check the sampling decision logged for each span (or a tag on the span). | All 5 spans have the same sampling decision (`keep`/`drop`). |\n| **Tail-Based Sampling Override** | 1. Configure a `TailSampler` with a rule to keep traces with `Status.Code` = `ERROR`.<br>2. Send a trace that was initially dropped by head-sampling (rate=0) but contains an error span.<br>3. Check the final storage. | The error trace is present in storage, demonstrating the tail-sampler overrode the head decision. |\n| **Per-Service Sampling Configuration** | 1. Configure `serviceRates`: `\"frontend\"`: 1.0, `\"backend\"`: 0.01.<br>2. Send 1000 traces from each service.<br>3. Check stats per service. | Nearly all `frontend` traces are kept; only ~1% of `backend` traces are kept. |\n\n#### Milestone 4: Performance Analytics & Anomaly Detection\n| Checkpoint | Verification Steps | Expected Outcome / Pass Criteria |\n| :--- | :--- | :--- |\n| **Percentile Calculation (t-digest)** | 1. Feed 10,000 latency values with a known distribution (e.g., uniformly distributed between 100ms and 1000ms) into a `TDigestMetric`.<br>2. Query `p50`, `p95`, `p99`.<br>3. Compare to theoretical values. | Calculated percentiles are within 1% of the expected values (e.g., p95 ~= 955ms). |\n| **Anomaly Detection Trigger** | 1. Establish a baseline of latencies for a service (~100ms).<br>2. Inject a series of latencies spiking to 500ms.<br>3. Run `Detector.CheckMetric`.<br>4. Inspect `AnomalyResult`. | Anomalies are detected with high `Confidence`. The `Severity` is appropriate (e.g., `\"high\"`). |\n| **Time-Series Storage & Retrieval** | 1. Write `MetricPoint`s for various services over a 1-hour period.<br>2. Query the `MemoryStore` for a specific 15-minute window.<br>3. Query for a service that has no data in that window. | The correct subset of points is returned for the first query. The second query returns an empty slice (not an error). |\n| **Regression Alerting** | 1. Set up a test alerting channel (e.g., log file).<br>2. Trigger an anomaly as above.<br>3. Monitor the channel. | An alert message containing the `AnomalyResult` details is emitted. |\n\n#### Milestone 5: APM SDK & Auto-Instrumentation\n| Checkpoint | Verification Steps | Expected Outcome / Pass Criteria |\n| :--- | :--- | :--- |\n| **HTTP Context Propagation** | 1. Instrument an HTTP client and server using the SDK.<br>2. Make a request from client to server.<br>3. Collect the trace from the Collector.<br>4. Inspect the trace structure. | The trace contains two spans (client and server) linked by parent-child relationship. The `TraceID` is identical in both spans. |\n| **Database Query Tracing** | 1. Instrument a SQL database driver.<br>2. Execute a `SELECT` query.<br>3. Collect the resulting span. | A span is created with the `Name` containing the SQL operation. The span's attributes contain the sanitized query string and execution time. |\n| **Framework Middleware** | 1. Add the Gin middleware to a simple Go web server.<br>2. Make an HTTP request to a registered route.<br>3. Collect the trace. | A span is created for the incoming request, with the `Name` as the route path (e.g., `GET /api/users`). The span's duration matches the request handling time. |\n| **Async Context Propagation** | 1. In an instrumented handler, launch a goroutine that creates a child span.<br>2. Collect the trace. | The child span created in the goroutine is correctly linked as a child of the handler span, demonstrating the context was propagated. |\n\n---\n### Implementation Guidance\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (For Learning) | Advanced Option (For Production) |\n| :--- | :--- | :--- |\n| Unit Testing Framework | Go's built-in `testing` package + `testify/assert` | Go's `testing` + `testify/suite` for test suites |\n| Mock Generation | Hand-written fakes for key interfaces | `mockgen` (from `github.com/golang/mock`) |\n| Property-Based Testing | `github.com/leanovate/gopter` | `github.com/leanovate/gopter` with custom generators |\n| Load Testing | Custom Go program using goroutines | `k6` or `ghz` (for gRPC) |\n| Code Coverage | `go test -cover` | `go test -coverprofile` + `go tool cover -html=` |\n| Benchmarking | Go's built-in benchmarking (`go test -bench .`) | `go test -bench . -benchmem` + pprof profiling |\n\n**B. Recommended File/Module Structure for Tests**\n\n```\napm-tracing-system/\n├── cmd/\n│   └── collector/\n│       └── main.go\n├── internal/\n│   ├── ingestion/               # Milestone 1\n│   │   ├── pipeline.go\n│   │   ├── pipeline_test.go     # Unit tests\n│   │   ├── handler_otlp.go\n│   │   └── handler_otlp_test.go\n│   ├── storage/\n│   │   ├── memory.go            # Fake for testing\n│   │   ├── memory_test.go\n│   │   └── writer.go            # Interface\n│   ├── sampling/                # Milestone 3\n│   │   ├── head_sampler.go\n│   │   ├── head_sampler_test.go\n│   │   ├── property_test.go     # Property-based tests\n│   │   └── tail_sampler.go\n│   ├── servicegraph/            # Milestone 2\n│   │   ├── builder.go\n│   │   ├── builder_integration_test.go\n│   │   └── aggregator_test.go\n│   ├── analytics/               # Milestone 4\n│   │   ├── tdigest_metric.go\n│   │   ├── tdigest_metric_test.go\n│   │   └── detector_test.go\n│   └── sdk/                     # Milestone 5\n│       ├── tracer.go\n│       ├── tracer_integration_test.go\n│       └── http_client_test.go\n├── test/                        # Integration & load tests\n│   ├── integration/\n│   │   ├── collector_test.go    # Spans ingestion -> storage\n│   │   └── service_map_test.go\n│   ├── load/\n│   │   └── span_throughput.go   # Load test program\n│   └── chaos/\n│       └── kill_collector_test.go\n└── pkg/\n    └── models/                  # Data models\n        ├── span.go\n        └── span_test.go         # Validation logic tests\n```\n\n**C. Infrastructure Starter Code: Mock Span Generator**\n\n```go\n// testutils/generator.go\npackage testutils\n\nimport (\n    \"crypto/rand\"\n    \"encoding/hex\"\n    \"time\"\n\n    \"github.com/your-org/apm-tracing-system/pkg/models\"\n)\n\n// GenerateSpan creates a deterministic or random span for testing.\nfunc GenerateSpan(traceID, parentSpanID, serviceName, operation string) models.Span {\n    if traceID == \"\" {\n        traceID = generateID(16)\n    }\n    spanID := generateID(8)\n    start := time.Now().Add(-time.Duration(randomInt(100)) * time.Millisecond)\n    duration := time.Duration(randomInt(500)+50) * time.Millisecond\n\n    return models.Span{\n        SpanID:       spanID,\n        TraceID:      traceID,\n        ParentSpanID: parentSpanID,\n        Name:         operation,\n        ServiceName:  serviceName,\n        StartTime:    start,\n        Duration:     duration,\n        Attributes:   map[string]string{\"test\": \"true\"},\n        Status:       models.SpanStatus{Code: 0}, // OK\n    }\n}\n\n// GenerateTrace generates a complete trace with a root span and n children.\nfunc GenerateTrace(serviceName string, childCount int) []models.Span {\n    traceID := generateID(16)\n    root := GenerateSpan(traceID, \"\", serviceName, \"root-operation\")\n    spans := []models.Span{root}\n\n    for i := 0; i < childCount; i++ {\n        child := GenerateSpan(traceID, root.SpanID, serviceName, \n                             \"child-operation\")\n        spans = append(spans, child)\n    }\n    return spans\n}\n\nfunc generateID(length int) string {\n    bytes := make([]byte, length/2) // 2 hex chars per byte\n    rand.Read(bytes)\n    return hex.EncodeToString(bytes)\n}\n\nfunc randomInt(max int) int {\n    // simplified deterministic random for tests\n    return int(time.Now().UnixNano()) % max\n}\n```\n\n**D. Core Logic Skeleton Code for Key Unit Tests**\n\n```go\n// internal/sampling/head_sampler_property_test.go\npackage sampling\n\nimport (\n    \"testing\"\n    \"github.com/leanovate/gopter\"\n    \"github.com/leanovate/gopter/gen\"\n    \"github.com/leanovate/gopter/prop\"\n)\n\nfunc TestConsistentSampler_PropertyBased(t *testing.T) {\n    parameters := gopter.DefaultTestParameters()\n    parameters.MinSuccessfulTests = 1000\n    properties := gopter.NewProperties(parameters)\n\n    properties.Property(\"deterministic sampling for same traceID\", \n        prop.ForAll(\n            func(traceID string, rate float64) bool {\n                sampler := NewConsistentSampler(rate)\n                decision1 := sampler.ShouldSample(traceID)\n                decision2 := sampler.ShouldSample(traceID)\n                // TODO 1: The decision for the same traceID should be identical\n                return decision1 == decision2\n            },\n            gen.AlphaString(),  // Generates random traceIDs\n            gen.Float64Range(0.0, 1.0), // Generates random rates\n        ))\n\n    properties.Property(\"sampling rate converges to configured rate\",\n        prop.ForAll(\n            func(rate float64) bool {\n                sampler := NewConsistentSampler(rate)\n                samples := 10000\n                kept := 0\n                // TODO 2: Generate a large set of unique traceIDs\n                // TODO 3: Call ShouldSample for each traceID\n                // TODO 4: Count how many were kept\n                // TODO 5: The ratio kept/samples should be within 1% of 'rate'\n                // return math.Abs(float64(kept)/float64(samples) - rate) < 0.01\n                return true\n            },\n            gen.Float64Range(0.05, 0.95), // Avoid extremes for meaningful test\n        ))\n\n    properties.TestingRun(t)\n}\n```\n\n```go\n// internal/ingestion/pipeline_integration_test.go\npackage ingestion\n\nimport (\n    \"context\"\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n    \"github.com/your-org/apm-tracing-system/pkg/models\"\n    \"github.com/your-org/apm-tracing-system/testutils\"\n)\n\nfunc TestPipeline_EndToEnd(t *testing.T) {\n    // TODO 1: Create an in-memory storage fake\n    // storage := memory.NewStorage()\n    \n    // TODO 2: Create a Pipeline with a head sampler (rate=1.0) and the fake storage\n    // pipeline, err := NewPipeline(config)\n    // require.NoError(t, err)\n    \n    // TODO 3: Generate a test trace with 3 spans\n    // spans := testutils.GenerateTrace(\"test-service\", 2)\n    \n    // TODO 4: Process each span through the pipeline\n    // for _, span := range spans {\n    //     err := pipeline.ProcessSpan(context.Background(), span)\n    //     assert.NoError(t, err)\n    // }\n    \n    // TODO 5: Query the storage for the complete trace by TraceID\n    // trace, err := storage.GetTraceByID(context.Background(), spans[0].TraceID)\n    \n    // TODO 6: Assert the trace contains all 3 spans\n    // assert.Len(t, trace.Spans, 3)\n    // assert.Equal(t, spans[0].TraceID, trace.TraceID)\n}\n```\n\n**E. Language-Specific Hints (Go)**\n- **Use `t.Helper()`:** Mark helper functions in tests so the failure line points to the actual test, not the helper.\n- **Table-Driven Tests:** Use for testing multiple input/output combinations for the same function.\n    ```go\n    func TestSpanValidation(t *testing.T) {\n        tests := []struct{\n            name string\n            span models.Span\n            wantErr bool\n        }{\n            {\"valid span\", models.Span{TraceID: \"abc\", ...}, false},\n            {\"missing traceid\", models.Span{}, true},\n        }\n        for _, tt := range tests {\n            t.Run(tt.name, func(t *testing.T){\n                err := tt.span.Validate()\n                if tt.wantErr {\n                    assert.Error(t, err)\n                } else {\n                    assert.NoError(t, err)\n                }\n            })\n        }\n    }\n    ```\n- **Parallel Tests:** Use `t.Parallel()` in independent tests to speed up execution.\n- **Test Main:** Use `func TestMain(m *testing.M)` for global setup/teardown (e.g., starting a test database container).\n- **Benchmarks:** Place benchmarks in `_test.go` files with functions starting with `Benchmark`. Use `b.ResetTimer()` and `b.StopTimer()` to exclude setup time.\n\n**F. Milestone Checkpoint Execution**\nFor each milestone, after implementing the components, run the relevant test suite:\n1.  **Milestone 1:** `go test ./internal/ingestion/... -v -count=1`\n2.  **Milestone 2:** `go test ./internal/servicegraph/... -v`\n3.  **Milestone 3:** `go test ./internal/sampling/... -v`\n4.  **Milestone 4:** `go test ./internal/analytics/... -v`\n5.  **Milestone 5:** `go test ./internal/sdk/... -v`\n\nThen, run the integration tests: `go test ./test/integration/... -v`\n\n**Expected Output:** All tests pass (exit code 0). For property-based tests, you'll see output like `\"OK: 1000 passed\"`.\n\n**Signs of Trouble:**\n- **Tests hang:** Check for deadlocks in concurrent code (use `-timeout` flag).\n- **High memory in tests:** May indicate a leak in `BufferManager` or `WALReader`; run with `-memprofile`.\n- **Flaky tests:** Usually a concurrency bug or reliance on system time. Use fake clocks and synchronized channels.\n\n**G. Debugging Tips for Test Failures**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n| :--- | :--- | :--- | :--- |\n| **Span linking fails** in trace assembly test. | Incorrect parent-child relationship logic or `SpanID` generation. | Log the `TraceID`, `SpanID`, and `ParentSpanID` of all spans in the test. Draw the expected tree. | Verify `NewTraceFromSpans` groups by `TraceID` and builds the tree correctly. |\n| **Sampling rate test fails** (ratio is 0% or 100%). | Hash function in `ConsistentSampler` is incorrectly mapped to the rate. | Print the hash value for a few `traceID`s and the threshold. | Ensure hash is uniformly distributed and comparison is `hash % 10000 < rate*10000`. |\n| **Service map missing edges.** | `EdgeAggregator` is not extracting caller/callee from spans correctly. | Check that spans representing cross-service calls have different `ServiceName` and correct parent links. | In `ProcessSpan`, ensure you extract the caller's service from the parent span. |\n| **Anomaly detector floods alerts.** | Baseline calculation is wrong or detection threshold is too sensitive. | Log the historical baseline values and the current value with z-score. | Adjust the `thresholds` in `Detector` or increase the baseline window size. |\n| **Integration test passes alone but fails in suite.** | Shared global state (like a package-level variable) is not reset. | Look for `init()` functions or `var` declarations that hold state. | Use dependency injection, not globals. Reset state in a `TestMain` or `setup/teardown`. |\n\n\n## 13. Debugging Guide\n\n> **Milestone(s):** This section applies to all five milestones, providing a practical manual for diagnosing and fixing common issues encountered while building and running the APM Tracing System.\n\nBuilding a distributed tracing system involves multiple interconnected components that process high-volume data streams in real-time. When things go wrong—spans disappear, performance degrades, or metrics become inaccurate—the complexity can make debugging daunting. This guide provides a structured approach to diagnosing and resolving common issues, along with practical techniques and tools that will help you navigate the system's inner workings.\n\n### Common Bugs: Symptom → Cause → Fix\n\nThink of debugging the APM system like being a **systems detective**. Each symptom is a clue, each cause is a suspect, and your diagnosis steps are the investigative process to eliminate possibilities until you find the culprit. The following table organizes common issues by symptom, with concrete steps to identify root causes and implement fixes.\n\n| Symptom | Likely Cause | Diagnosis Steps | Fix |\n|---------|--------------|-----------------|-----|\n| **Spans are not linked into traces** (spans with the same `TraceID` appear as separate, incomplete traces) | 1. **Parent-child linking logic error** in `TraceAssembler.AssembleTrace()`<br>2. **Missing or incorrect `ParentSpanID`** in incoming spans<br>3. **Clock skew** between services causing incorrect span ordering<br>4. **Late-arriving spans** evicted from `BufferManager` before assembly | 1. Check `TraceAssembler` logs for assembly errors<br>2. Verify span JSON/protobuf payloads contain correct `ParentSpanID`<br>3. Compare timestamps across services—look for negative durations<br>4. Monitor `BufferManager` eviction metrics and trace completion rates | 1. Add validation to ensure `ParentSpanID` format matches `SpanID`<br>2. Implement clock skew compensation in `TraceAssembler`<br>3. Increase `BufferManager` TTL or adjust eviction policy<br>4. Add telemetry to track span arrival latency relative to trace start |\n| **Service map is empty or missing edges** (dependency graph shows no connections between services) | 1. **Edge extraction logic** failing to identify caller-callee relationships<br>2. **Aggregation window misalignment** causing edges to be discarded<br>3. **Sampling dropping all inter-service traces**<br>4. **`ServiceName` extraction incorrect** from OTLP resource attributes | 1. Inspect raw spans to verify they contain cross-service references<br>2. Check `EdgeAggregator` window boundaries and flush timing<br>3. Review `HeadSampler` and `TailSampler` statistics for service<br>4. Validate `extractServiceName()` logic against actual OTLP payloads | 1. Enhance `EdgeAggregator.ProcessSpan()` to log extracted edges for debugging<br>2. Align aggregation windows with trace collection windows<br>3. Adjust sampling rates or add sampling bypass for test traffic<br>4. Update `extractServiceName()` to handle multiple attribute formats |\n| **High memory usage in collector** (memory grows unbounded, leads to OOM crashes) | 1. **Incomplete trace accumulation** in `BufferManager` without eviction<br>2. **Memory leak** in WAL or pipeline components<br>3. **Backpressure failure** causing queue buildup<br>4. **Large attribute values** stored in span `Attributes` maps | 1. Monitor `BufferManager.traces` map size and age distribution<br>2. Use Go pprof heap profiling to identify allocation hotspots<br>3. Check `BackpressureManager` tier transitions and sampling adjustments<br>4. Inspect span sizes in storage—look for exceptionally large attributes | 1. Implement more aggressive `BufferManager` eviction based on trace age<br>2. Add periodic resource cleanup in long-lived goroutines<br>3. Tune `BackpressureManager` thresholds for earlier intervention<br>4. Enforce attribute size limits in `SpanValidator` |\n| **Slow trace queries** (`GetTraceByID` takes >1s even for small traces) | 1. **Missing or inefficient indexes** on trace storage<br>2. **N+1 query problem** fetching spans individually<br>3. **Storage layer contention** from high ingestion volume<br>4. **Cache misses** in query service layer | 1. Examine query execution plans in storage backend<br>2. Profile query service to identify repeated round-trips<br>3. Monitor storage latency metrics during peak ingestion<br>4. Check cache hit rates for frequently accessed traces | 1. Ensure composite index on (`TraceID`, `StartTime`) in storage<br>2. Implement batch span fetching in `GetTraceByID`<br>3. Add read replicas or query-side caching for trace data<br>4. Implement query result caching with TTL based on trace age |\n| **Sampling rate not being respected** (too many/few traces stored vs. configured probability) | 1. **Inconsistent hashing** across sampler instances<br>2. **Race condition** updating `ConsistentSampler.rate`<br>3. **Tail-based sampling overriding** too many head decisions<br>4. **Configuration propagation delay** across collector instances | 1. Compare hash outputs for same `TraceID` across sampler instances<br>2. Check for concurrent `SetRate()` calls without proper synchronization<br>3. Review `TailSampler` statistics—high `TailOverrides` indicates aggressive overriding<br>4. Monitor configuration timestamps vs. sampling decision timestamps | 1. Use deterministic hash function (e.g., xxHash) with fixed seed<br>2. Add mutex protection in `ConsistentSampler.SetRate()`<br>3. Adjust `TailSamplingRule` priorities and thresholds<br>4. Implement configuration versioning with decision logging |\n| **Anomaly detection producing too many false positives** (alerts fire during normal operation) | 1. **Insufficient historical baseline** for comparison<br>2. **Statistical method sensitivity** too high (low z-score threshold)<br>3. **Seasonal patterns** not accounted for in baseline<br>4. **Metric aggregation window** misaligned with traffic patterns | 1. Check baseline calculation—minimum data points required<br>2. Review anomaly `Confidence` scores—consistently low indicates weak signal<br>3. Plot metric history to identify daily/weekly patterns<br>4. Compare aggregation window with natural traffic cycles | 1. Increase baseline training period before enabling detection<br>2. Adjust `Detector.thresholds` based on observed false positive rate<br>3. Implement seasonal decomposition in `BaselineCalculator`<br>4. Experiment with different aggregation windows (1m vs 5m vs 15m) |\n| **SDK causing performance overhead** (instrumented application shows >5% latency increase) | 1. **Synchronous span export** blocking request processing<br>2. **Excessive attribute collection** on hot code paths<br>3. **Context propagation overhead** in deep call chains<br>4. **Lock contention** in shared `Tracer` structures | 1. Profile application with and without SDK to isolate overhead<br>2. Measure time spent in `End()` and span export operations<br>3. Count context propagation operations per request<br>4. Check goroutine profiles for lock wait times | 1. Implement asynchronous batched span export in SDK<br>2. Add sampling to attribute collection on high-volume operations<br>3. Optimize `context.Context` value storage/retrieval<br>4. Use `sync.Pool` for reusable span objects |\n| **Clock skew making span ordering incorrect** (child spans appear to start before parents) | 1. **System clock differences** between services (seconds/minutes offset)<br>2. **NTP synchronization issues** causing drift<br>3. **Virtual machine clock skew** in containerized environments<br>4. **Timestamp normalization logic** not accounting for timezone | 1. Compare `StartTime` of parent and child spans across services<br>2. Check system clock synchronization status on collector and services<br>3. Monitor for gradual drift in span timing over hours/days<br>4. Verify timestamp parsing handles UTC conversion correctly | 1. Implement relative timestamp adjustment in `TraceAssembler`<br>2. Add NTP client to collector to maintain accurate time<br>3. Use monotonic clocks for duration calculations where possible<br>4. Normalize all timestamps to UTC at ingestion point |\n| **Backpressure not engaging under load** (system becomes unresponsive instead of degrading gracefully) | 1. **Threshold detection lag**—metrics don't reflect reality quickly enough<br>2. **Tier transition logic** too conservative<br>3. **Sampling rate adjustment** insufficient to reduce load<br>4. **Feedback loop delay** between action and effect | 1. Monitor `SystemMetrics` vs. `BackpressureManager` tier decisions<br>2. Check tier transition history for delayed responses to load spikes<br>3. Compare sampling rate changes with span ingestion rate changes<br>4. Measure time from tier change to metric improvement | 1. Reduce `checkInterval` and use more sensitive thresholds<br>2. Implement predictive tier transitions based on trend analysis<br>3. Add exponential backoff to sampling rate reductions<br>4. Create faster feedback loop with direct metric-to-action coupling |\n| **WAL recovery losing spans** after collector restart | 1. **WAL corruption** due to improper file rotation<br>2. **Incomplete records** written before crash<br>3. **Race condition** between write and rotation<br>4. **Disk space exhaustion** during WAL append | 1. Check WAL file integrity—look for malformed length prefixes<br>2. Verify last few records in WAL are complete<br>3. Examine rotation timing relative to crash time<br>4. Monitor disk usage metrics before restart | 1. Add record checksums to detect corruption<br>2. Implement atomic record writing with fsync<br>3. Use file locking during rotation<br>4. Add disk space monitoring and proactive WAL cleanup |\n\n> **Key Insight:** Many APM system bugs manifest as **data quality issues**—missing links, incorrect timing, or inaccurate aggregations. Always start your investigation by examining the raw data flowing through the system. Add debug logging to capture a sample of problematic spans before and after each processing stage.\n\n### Debugging Techniques and Tools\n\nEffective debugging requires both systematic methodology and the right tools. Think of this as your **detective's toolkit**—each tool serves a specific purpose in uncovering different types of issues.\n\n#### Strategic Logging\n\nWell-placed logs are your first line of defense. Unlike metrics that aggregate, logs preserve individual request context, which is crucial for debugging trace assembly, sampling decisions, and edge cases.\n\n**Where to Add Diagnostic Logging:**\n\n| Component | Critical Log Points | What to Log |\n|-----------|---------------------|-------------|\n| `OTLPHandler` | Request parsing errors, payload size anomalies | `traceID`, `spanID`, error details, payload size |\n| `Pipeline.ProcessSpan()` | Span validation failures, sampling decisions | `traceID`, `spanID`, validation error, sampler decision |\n| `BufferManager.AddSpan()` | Trace completion, eviction events | `traceID`, span count, buffer size, eviction reason |\n| `EdgeAggregator.ProcessSpan()` | Edge extraction, window flushes | caller/callee services, extracted edge metrics |\n| `HeadSampler.Decide()` | Sampling decisions, rate changes | `traceID`, service, rate, decision |\n| `TailSampler.EvaluateTrace()` | Rule evaluations, override decisions | `traceID`, rule matches, final decision |\n| `CircuitBreaker.Execute()` | State transitions, operation failures | operation name, state change, error |\n\n**Implementing Structured Logging:**\n```go\n// Use a structured logger like zap or logrus\nlogger.Info(\"Span processing completed\",\n    zap.String(\"trace_id\", span.TraceID),\n    zap.String(\"span_id\", span.SpanID),\n    zap.String(\"service\", span.ServiceName),\n    zap.Duration(\"duration\", span.Duration),\n    zap.Int(\"buffer_size\", bufferSize))\n```\n\n**Log Sampling for High Volume:** Enable debug logging only for a percentage of traces to avoid overwhelming the log system. Use the same `ConsistentSampler` mechanism to ensure the same traces are logged across components.\n\n#### Performance Profiling with pprof\n\nWhen the system experiences high CPU, memory leaks, or goroutine explosions, Go's built-in profiling tools (`pprof`) are indispensable. Think of pprof as an **X-ray machine** for your running application—it reveals internal structures and hotspots invisible from the outside.\n\n**Enabling pprof in Your Collector:**\n```go\n// Add to your HTTP server setup\nimport _ \"net/http/pprof\"\n\ngo func() {\n    log.Println(http.ListenAndServe(\"localhost:6060\", nil))\n}()\n```\n\n**Common pprof Investigations:**\n\n| Symptom | Profile Type | What to Look For |\n|---------|--------------|------------------|\n| High CPU usage | `cpu` profile | Functions with highest `cumulative` time; often reveals hot loops or expensive serialization |\n| Memory leaks | `heap` profile | Objects with increasing `inuse_space` over time; check for retained references in global maps |\n| Goroutine leaks | `goroutine` profile | Growing goroutine count; look for blocked goroutines in sync primitives or channel operations |\n| Contention | `mutex` profile | Functions with high lock contention; indicates scalability bottlenecks |\n| Blocking | `block` profile | Operations causing goroutines to wait; often I/O or channel operations |\n\n**Diagnostic Workflow:**\n1. **Reproduce the issue** under load (use simulation tools below)\n2. **Collect profiles** during the problematic behavior:\n   ```bash\n   # CPU profile (30 seconds)\n   go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n   \n   # Heap snapshot\n   go tool pprof http://localhost:6060/debug/pprof/heap\n   \n   # Goroutine dump\n   curl http://localhost:6060/debug/pprof/goroutine?debug=2 > goroutines.txt\n   ```\n3. **Analyze with pprof web interface:**\n   ```bash\n   # Launch interactive web UI\n   go tool pprof -http=:8080 profile.pprof\n   ```\n4. **Look for patterns:** Repeated allocation patterns, deep call stacks with many allocations, or single functions dominating CPU time.\n\n> **Pro Tip:** Use **comparative profiling**—take profiles before and after a code change, or during normal vs. degraded operation. The differences often reveal the root cause more clearly than absolute profiles.\n\n#### Simulating Production Traffic for Testing\n\nYou cannot debug what you cannot reproduce. Creating realistic test traffic is essential for diagnosing issues that only appear under production-like load.\n\n**Traffic Simulation Approaches:**\n\n| Technique | Best For | Implementation |\n|-----------|----------|----------------|\n| **Replay from WAL** | Reproducing specific failure scenarios | Use `WALReader.ReadNext()` to replay spans exactly as they arrived |\n| **Synthetic trace generation** | Load testing and stress scenarios | Programmatically generate traces with realistic service call patterns |\n| **Record-and-replay** | Capturing production patterns without PII | Capture trace samples (anonymized) and replay through test collector |\n| **Chaos injection** | Testing resilience and failure recovery | Randomly drop spans, introduce delays, or corrupt data |\n\n**Building a Trace Generator for Testing:**\n```go\n// Generate a realistic multi-service trace\nfunc generateTestTrace(traceID string) []models.Span {\n    spans := []models.Span{}\n    \n    // Root span (web request)\n    spans = append(spans, models.Span{\n        TraceID: traceID,\n        SpanID: generateID(),\n        ParentSpanID: \"\",\n        Name: \"HTTP GET /api/users\",\n        ServiceName: \"frontend\",\n        StartTime: time.Now(),\n        Duration: 120 * time.Millisecond,\n    })\n    \n    // Database call child span\n    spans = append(spans, models.Span{\n        TraceID: traceID,\n        SpanID: generateID(),\n        ParentSpanID: spans[0].SpanID,\n        Name: \"SELECT users\",\n        ServiceName: \"users-db\",\n        StartTime: time.Now().Add(10 * time.Millisecond),\n        Duration: 45 * time.Millisecond,\n    })\n    \n    // External API call child span\n    spans = append(spans, models.Span{\n        TraceID: traceID,\n        SpanID: generateID(),\n        ParentSpanID: spans[0].SpanID,\n        Name: \"GET /recommendations\",\n        ServiceName: \"recommendation-service\",\n        StartTime: time.Now().Add(20 * time.Millisecond),\n        Duration: 80 * time.Millisecond,\n    })\n    \n    return spans\n}\n```\n\n**Load Testing Script Pattern:**\n```bash\n#!/bin/bash\n# Run a controlled load test with increasing volume\nfor rate in 100 500 1000 2000 5000; do\n    echo \"Testing at ${rate} spans/sec\"\n    ./trace-generator --rate=$rate --duration=60s \\\n        --collector-endpoint=\"http://localhost:4318/v1/traces\"\n    \n    # Wait for system to stabilize and collect metrics\n    sleep 10\n    curl http://localhost:6060/debug/pprof/heap > heap_${rate}.pprof\ndone\n```\n\n#### Using the System to Debug Itself (Dogfooding)\n\nThe most powerful debugging technique for an APM system is to **use it to monitor itself**. Instrument your collector, query service, and storage layer with the same SDK you provide to applications. This creates a virtuous cycle where debugging improvements benefit both the system and its users.\n\n**Self-Instrumentation Strategy:**\n\n1. **Add tracing to collector ingress/egress:** Wrap `OTLPHandler.ServeHTTP()` with spans to track request handling latency and errors.\n2. **Trace internal pipeline operations:** Add spans around `BufferManager` operations, `EdgeAggregator` processing, and `TailSampler` evaluations.\n3. **Monitor system health with built-in analytics:** Feed collector metrics into your own anomaly detection system to get early warnings of degradation.\n4. **Build service maps of internal components:** Visualize data flow between pipeline stages to identify bottlenecks.\n\n**Example Collector Self-Instrumentation:**\n```go\nfunc (h *OTLPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    // Create a span for this request\n    ctx, span := h.tracer.StartSpanFromContext(r.Context(), \"OTLPHandler.ServeHTTP\")\n    defer span.End()\n    \n    span.SetAttribute(\"http.method\", r.Method)\n    span.SetAttribute(\"http.url\", r.URL.Path)\n    span.SetAttribute(\"content.type\", r.Header.Get(\"Content-Type\"))\n    \n    // Process the request with the context containing the span\n    h.processRequestWithContext(ctx, w, r)\n    \n    span.SetAttribute(\"http.status_code\", statusCode)\n    if statusCode >= 400 {\n        span.SetStatus(models.SpanStatus{Code: 2, Message: \"HTTP error\"})\n    }\n}\n```\n\n> **Design Principle:** A well-instrumented system is a debuggable system. The effort you invest in adding observability to your APM system pays dividends every time you need to diagnose a production issue.\n\n#### Diagnostic Endpoints and Health Checks\n\nBeyond pprof, build custom diagnostic endpoints that expose internal state. These are your **system vitals monitor**—quick ways to check pulse, respiration, and other critical signs.\n\n**Essential Diagnostic Endpoints:**\n\n| Endpoint | Purpose | Response Fields |\n|----------|---------|-----------------|\n| `GET /debug/state/buffer` | `BufferManager` status | `total_traces`, `total_spans`, `oldest_trace_age`, `eviction_count` |\n| `GET /debug/state/sampling` | Sampler statistics | `head_sampled_rate`, `tail_overrides`, `per_service_decisions` |\n| `GET /debug/state/edges` | Service map construction | `edge_count`, `last_flush_time`, `pending_edges` |\n| `GET /debug/trace/:id` | Manual trace inspection | Complete trace with all spans (bypasses normal query path) |\n| `POST /debug/inject-fault` | Chaos engineering | Inject delays, errors, or data corruption for testing resilience |\n\n**Example Diagnostic Handler:**\n```go\nfunc (m *BufferManager) DebugHandler(w http.ResponseWriter, r *http.Request) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    \n    stats := map[string]interface{}{\n        \"traces_count\": len(m.traces),\n        \"spans_count\":  m.totalSpans(),\n        \"max_size\":     m.maxSize,\n        \"ttl\":          m.ttl.String(),\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(stats)\n}\n```\n\n#### Systematic Diagnosis Workflow\n\nWhen faced with an unknown issue, follow this **systematic diagnosis workflow** to avoid rabbit holes and confirmation bias:\n\n1. **Reproduce Consistently:** Can you make it happen on demand? If not, add logging to capture it next time.\n2. **Isolate the Component:** Use the architecture diagram to identify which component is likely responsible. Check component health endpoints.\n3. **Examine Inputs/Outputs:** Compare what enters the component vs. what leaves. Add debug logging at boundaries.\n4. **Check Internal State:** Use diagnostic endpoints to inspect internal data structures and counters.\n5. **Simplify and Test:** Create a minimal test case that reproduces the issue with controlled inputs.\n6. **Hypothesize and Verify:** Form a hypothesis about the root cause, make a prediction, and test it.\n7. **Fix and Monitor:** Implement the fix, then monitor to ensure the issue is resolved and doesn't regress.\n\nRemember that in distributed tracing systems, many issues are **timing-related** (race conditions, late arrivals, clock skew) or **data quality issues** (malformed spans, incorrect context propagation). Always consider these categories early in your diagnosis.\n\n### Implementation Guidance\n\nThis section provides concrete code patterns and tools to implement the debugging techniques described above.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Structured Logging | `log/slog` (Go 1.21+) | `uber-go/zap` with sampling and hooks |\n| Profiling | `net/http/pprof` embedded | Custom profiling endpoints with filtering |\n| Metrics Collection | `expvar` for basic metrics | `prometheus/client_golang` for rich metrics |\n| Trace Generation | Custom Go generator | OpenTelemetry Collector test data generator |\n| Health Checks | Simple HTTP endpoint | Kubernetes-ready liveness/readiness probes |\n| Diagnostic UI | pprof web interface | Custom React dashboard aggregating all debug endpoints |\n\n#### B. Diagnostic Endpoint Implementation\n\nCreate a dedicated debugging module that exposes system state without affecting production performance:\n\n**File Structure:**\n```\nproject-root/\n  internal/debug/\n    handler.go           # HTTP handlers for debug endpoints\n    pprof_wrapper.go     # Enhanced pprof with authentication\n    state_dumper.go      # Component state inspection\n    metrics.go           # Debug-specific metrics collection\n  cmd/debug-tool/\n    main.go              # CLI tool for offline diagnostics\n```\n\n**Complete State Dumper Implementation:**\n```go\n// internal/debug/state_dumper.go\npackage debug\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n)\n\n// ComponentState represents a component's internal state for debugging\ntype ComponentState struct {\n    Name        string                 `json:\"name\"`\n    Health      string                 `json:\"health\"`\n    Metrics     map[string]interface{} `json:\"metrics\"`\n    LastUpdated time.Time              `json:\"last_updated\"`\n}\n\n// StateDumper collects and serves debug state from all registered components\ntype StateDumper struct {\n    mu         sync.RWMutex\n    components map[string]func() ComponentState\n}\n\n// NewStateDumper creates a new state dumper\nfunc NewStateDumper() *StateDumper {\n    return &StateDumper{\n        components: make(map[string]func() ComponentState),\n    }\n}\n\n// RegisterComponent adds a component state provider\nfunc (d *StateDumper) RegisterComponent(name string, provider func() ComponentState) {\n    d.mu.Lock()\n    defer d.mu.Unlock()\n    d.components[name] = provider\n}\n\n// ServeHTTP implements http.Handler\nfunc (d *StateDumper) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    d.mu.RLock()\n    defer d.mu.RUnlock()\n    \n    states := make(map[string]ComponentState)\n    for name, provider := range d.components {\n        states[name] = provider()\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    if err := json.NewEncoder(w).Encode(states); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}\n\n// BufferManagerStateProvider example\nfunc BufferManagerStateProvider(bm *BufferManager) func() ComponentState {\n    return func() ComponentState {\n        bm.mu.RLock()\n        defer bm.mu.RUnlock()\n        \n        return ComponentState{\n            Name:   \"buffer_manager\",\n            Health: \"healthy\",\n            Metrics: map[string]interface{}{\n                \"traces_count\":      len(bm.traces),\n                \"spans_count\":       bm.totalSpans(),\n                \"oldest_trace_age\":  time.Since(bm.oldestTraceTime()).String(),\n                \"evictions_total\":   bm.evictionCount,\n                \"evictions_recent\":  bm.recentEvictionCount,\n            },\n            LastUpdated: time.Now(),\n        }\n    }\n}\n```\n\n#### C. Strategic Logging Skeleton\n\nImplement a logging wrapper that adds trace context to all log messages automatically:\n\n```go\n// internal/telemetry/logger.go\npackage telemetry\n\nimport (\n    \"context\"\n    \"time\"\n    \n    \"go.uber.org/zap\"\n    \"go.uber.org/zap/zapcore\"\n)\n\n// ContextLogger wraps a zap logger with context awareness\ntype ContextLogger struct {\n    logger *zap.Logger\n}\n\n// NewContextLogger creates a new context-aware logger\nfunc NewContextLogger(level zapcore.Level) (*ContextLogger, error) {\n    config := zap.NewProductionConfig()\n    config.Level = zap.NewAtomicLevelAt(level)\n    config.EncoderConfig.TimeKey = \"timestamp\"\n    config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder\n    \n    logger, err := config.Build()\n    if err != nil {\n        return nil, err\n    }\n    \n    return &ContextLogger{logger: logger}, nil\n}\n\n// WithContext returns a logger with trace context fields added\nfunc (cl *ContextLogger) WithContext(ctx context.Context) *zap.Logger {\n    logger := cl.logger\n    \n    // Extract trace context from context\n    if span := SpanFromContext(ctx); span != nil {\n        logger = logger.With(\n            zap.String(\"trace_id\", span.TraceID),\n            zap.String(\"span_id\", span.SpanID),\n        )\n    }\n    \n    return logger\n}\n\n// SampledDebug logs debug messages only for sampled traces\nfunc (cl *ContextLogger) SampledDebug(ctx context.Context, msg string, fields ...zap.Field) {\n    if span := SpanFromContext(ctx); span != nil {\n        // Sample 1% of traces for debug logging\n        if hashTraceID(span.TraceID)%100 == 0 {\n            cl.WithContext(ctx).Debug(msg, fields...)\n        }\n    }\n}\n\n// hashTraceID helper for consistent sampling\nfunc hashTraceID(traceID string) uint64 {\n    // Use xxHash for fast, consistent hashing\n    // Implementation omitted for brevity\n    return 0\n}\n```\n\n#### D. Load Test Generator Skeleton\n\nCreate a trace generator that can simulate realistic production traffic patterns:\n\n```go\n// cmd/trace-generator/main.go\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"log\"\n    \"time\"\n    \n    \"github.com/your-project/internal/models\"\n)\n\ntype GeneratorConfig struct {\n    Rate        int           // Spans per second\n    Duration    time.Duration // How long to run\n    Services    []string      // Service names to include\n    ErrorRate   float64       // Percentage of spans with errors\n    MaxDepth    int           // Maximum call depth in traces\n}\n\n// TraceGenerator creates synthetic traces\ntype TraceGenerator struct {\n    config GeneratorConfig\n    stats  GeneratorStats\n}\n\n// GenerateTrace creates a single trace with realistic structure\nfunc (tg *TraceGenerator) GenerateTrace() *models.Trace {\n    traceID := generateUUID()\n    \n    // TODO 1: Create root span for entry point (e.g., \"HTTP GET /api\")\n    // TODO 2: Randomly determine trace depth (1 to MaxDepth)\n    // TODO 3: For each level, create child spans for different services\n    // TODO 4: Apply ErrorRate to randomly mark some spans as errors\n    // TODO 5: Add realistic durations (parent > sum of children)\n    // TODO 6: Include attributes (URL paths, DB queries, status codes)\n    \n    return &models.Trace{\n        TraceID:   traceID,\n        Spans:     []models.Span{/* populated spans */},\n        StartTime: time.Now(),\n        EndTime:   time.Now().Add(100 * time.Millisecond),\n    }\n}\n\n// Run generates traces at the configured rate\nfunc (tg *TraceGenerator) Run(ctx context.Context) error {\n    ticker := time.NewTicker(time.Second / time.Duration(tg.config.Rate))\n    defer ticker.Stop()\n    \n    deadline := time.After(tg.config.Duration)\n    \n    for {\n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        case <-deadline:\n            log.Printf(\"Generation complete. Sent %d traces\", tg.stats.TracesGenerated)\n            return nil\n        case <-ticker.C:\n            trace := tg.GenerateTrace()\n            // TODO 7: Send trace to collector via OTLP\n            tg.stats.TracesGenerated++\n        }\n    }\n}\n\nfunc main() {\n    var rate int\n    var duration time.Duration\n    flag.IntVar(&rate, \"rate\", 100, \"Spans per second\")\n    flag.DurationVar(&duration, \"duration\", 30*time.Second, \"Test duration\")\n    flag.Parse()\n    \n    config := GeneratorConfig{\n        Rate:      rate,\n        Duration:  duration,\n        Services:  []string{\"frontend\", \"users-service\", \"orders-service\", \"payments-service\", \"database\"},\n        ErrorRate: 0.01, // 1% error rate\n        MaxDepth:  4,\n    }\n    \n    generator := &TraceGenerator{config: config}\n    ctx := context.Background()\n    \n    if err := generator.Run(ctx); err != nil {\n        log.Fatal(err)\n    }\n}\n```\n\n#### E. Language-Specific Hints\n\n- **Go pprof:** Use `go tool pprof -http=:8080 profile.pprof` to launch the web UI. The flame graph view is particularly useful for identifying CPU hotspots.\n- **Memory profiling:** Run your tests with `-memprofile=mem.pprof` and `-memprofilerate=1` to get detailed allocation data.\n- **Race detection:** Always run tests with `-race` flag during development to catch data races early.\n- **Goroutine leaks:** Use `runtime.NumGoroutine()` in your health checks to monitor goroutine counts.\n- **Block profiling:** Enable with `runtime.SetBlockProfileRate(1)` to capture all blocking operations.\n\n#### F. Debugging Workflow Checkpoint\n\nAfter implementing the debugging infrastructure, verify it works:\n\n1. **Start the collector** with debug endpoints enabled:\n   ```bash\n   ./collector --debug-addr=:6060\n   ```\n\n2. **Check debug endpoints:**\n   ```bash\n   # Basic health\n   curl http://localhost:6060/health\n   \n   # Buffer manager state\n   curl http://localhost:6060/debug/state/buffer\n   \n   # pprof interface (open in browser)\n   open http://localhost:6060/debug/pprof/\n   ```\n\n3. **Generate test traffic:**\n   ```bash\n   go run cmd/trace-generator/main.go --rate=500 --duration=1m\n   ```\n\n4. **Monitor during load:**\n   ```bash\n   # Take a CPU profile during load\n   go tool pprof http://localhost:6060/debug/pprof/profile?seconds=10\n   \n   # Check memory growth\n   go tool pprof http://localhost:6060/debug/pprof/heap\n   ```\n\n5. **Verify self-instrumentation:** Check that the collector's own traces appear in the trace query interface.\n\n**Expected Results:** You should be able to see internal spans from the collector, monitor buffer sizes in real-time, and capture performance profiles under load. If debug endpoints don't respond or show empty data, check that components are properly registered with the `StateDumper`.\n\n#### G. Debugging Tips Quick Reference\n\n| Symptom | Immediate Action | Long-term Solution |\n|---------|-----------------|-------------------|\n| Collector OOM | 1. Check `BufferManager` size<br>2. Profile heap with pprof | Implement smarter eviction, add memory limits |\n| High CPU | 1. Capture CPU profile<br>2. Check for hot loops in serialization | Optimize hot paths, add caching, use pooling |\n| Slow queries | 1. Check storage indexes<br>2. Profile query execution | Add query caching, optimize indexes, partition data |\n| Missing traces | 1. Verify sampling decisions<br>2. Check WAL for lost spans | Improve sampling debug logging, enhance WAL durability |\n| Incorrect service map | 1. Inspect edge extraction logic<br>2. Check `ServiceName` extraction | Add validation, improve attribute parsing |\n\nRemember that the most effective debugging comes from **understanding normal behavior first**. Establish baselines for key metrics (memory usage, processing latency, trace completion rates) so you can recognize anomalies when they occur.\n\n\n## 14. Future Extensions\n\n> **Milestone(s):** This section looks beyond the current five milestones, exploring potential enhancements that could build upon the existing APM Tracing System. These ideas are not part of the current scope but illustrate how the system can evolve to address more complex observability challenges, leverage emerging technologies, and provide deeper insights into distributed system behavior.\n\n### Potential Enhancements\n\nThe current APM Tracing System provides a solid foundation for distributed tracing, service dependency visualization, intelligent sampling, performance analytics, and automatic instrumentation. However, the world of observability is rapidly evolving. This section explores several natural extensions that could build upon our existing architecture, demonstrating how the system's modular design and clear data flow enable future enhancements without requiring major re-architecting.\n\n#### 14.1 Continuous Profiling Integration\n\n**Mental Model: The X-Ray Machine for Code Execution**\n> While traces show you *what* happened (the request flow) and *when* (timing), profiling shows you *why* (which specific lines of code consumed CPU or memory). Integrating continuous profiling is like adding an X-ray machine to our diagnostic toolkit—it reveals the internal structure and hotspots that surface metrics and traces can only hint at.\n\nContinuous profiling involves periodically capturing CPU flame graphs, memory allocation profiles, and goroutine/thread stacks from production services, then correlating this data with trace information to identify performance bottlenecks at the code level. Our APM system is uniquely positioned to integrate profiling because we already understand service boundaries and can correlate profiles with specific operations and trace contexts.\n\n**Integration Approach:**\n1. **Profile Collection Extension:** Extend the existing APM SDK to include a lightweight profiler that captures stack samples at configurable intervals (e.g., every 10 seconds for 5 seconds).\n2. **Profile-Execution Correlation:** Tag each profile sample with the current trace context (when available) so profiles can be filtered to specific operations or services.\n3. **Dedicated Profile Storage:** Add a new storage backend optimized for profile data (which is larger and more hierarchical than span data), potentially using columnar formats for efficient querying.\n4. **Profile Analysis Engine:** Implement analysis that identifies resource-intensive functions and correlates them with high-latency traces or error conditions.\n\n**Required Architecture Changes:**\n- New `Profiler` component in the SDK with methods `StartProfiling()` and `StopProfiling()`\n- Extended `Span` type to optionally include `ProfileID` reference\n- New `ProfileStorage` interface with implementations for different backends\n- Enhanced Query Service to support profile queries by service, operation, or trace ID\n\n**Benefits and Challenges:**\n| Benefit | Challenge |\n|---------|-----------|\n| Pinpoint exact code causing latency spikes | Profile data volume is 10-100× larger than trace data |\n| Correlate resource usage with business transactions | Profiling overhead must be minimal (<2% CPU) |\n| Identify memory leaks by tracking heap growth over time | Stack trace symbolization requires debug symbols |\n\n**Example Workflow:** When the anomaly detector flags elevated p99 latency for the `payment-service`'s `ProcessPayment` operation, engineers could query for CPU profiles collected during those high-latency traces, immediately seeing that 40% of CPU time was spent in a specific encryption library function that was recently updated.\n\n#### 14.2 AI-Powered Root Cause Analysis\n\n**Mental Model: The Distributed Systems Detective with Machine Learning Intuition**\n> Our current anomaly detection identifies *when* something is wrong. AI-powered root cause analysis would answer *why* and *what* caused it by learning normal patterns across thousands of dimensions and identifying the most probable culprit when deviations occur—like a seasoned detective who instantly recognizes which clue matters most.\n\nThis enhancement would apply machine learning models to the rich correlation data already flowing through our system: service dependencies, latency patterns, error rates, and topology changes. By training models on historical incident data (what changed before an outage), the system could automatically suggest root causes when anomalies are detected.\n\n**Integration Approach:**\n1. **Feature Extraction Pipeline:** Extend the existing analytics engine to compute additional features from trace data: service call graphs, latency distributions across dependency chains, error propagation patterns, and deployment timestamps.\n2. **Model Training Infrastructure:** Add a batch processing pipeline that trains models on historical data labeled with known incidents (requires integration with incident management systems).\n3. **Real-Time Inference:** Integrate trained models into the anomaly detection pipeline to provide root cause suggestions alongside anomaly alerts.\n4. **Feedback Loop:** Allow engineers to validate or correct root cause suggestions, creating labeled data for continuous model improvement.\n\n**Implementation Components:**\n- `RootCauseAnalyzer` interface with `Analyze(anomalies []AnomalyResult, currentGraph ServiceGraph) RootCauseSuggestion`\n- `ModelTrainingPipeline` for offline training on historical trace and incident data\n- Enhanced `AnomalyResult` type with `SuggestedRootCauses []RootCauseSuggestion` field\n\n**Data Flow Enhancement:**\n```\nAnomaly Detector → [New: Root Cause Analyzer] → Alert with suggested root cause\n                              ↓\n                   [New: Model Store] (periodically updated)\n                              ↓\n                   [New: Training Pipeline] (runs daily on historical data)\n```\n\n**Key Algorithms to Consider:**\n- **Graph-based algorithms** to identify service dependency changes coinciding with anomalies\n- **Time-series correlation** to find services whose metrics deviated first\n- **Change point detection** in deployment logs to correlate with performance regressions\n\n> **Architecture Decision: Offline vs. Online Learning**\n> - **Context:** We need to decide whether root cause models should be trained offline (batch) or online (continuously).\n> - **Option 1: Offline Batch Training:** Train daily/weekly on historical data.\n>   - *Pros:* Simpler infrastructure, easier model validation, predictable resource usage\n>   - *Cons:* Latency in adapting to new patterns, requires labeled historical data\n> - **Option 2: Online Continuous Learning:** Update models incrementally as new data arrives.\n>   - *Pros:* Rapid adaptation to system changes, no manual retraining needed\n>   - *Cons:* Complex to implement correctly, risk of model drift, harder to debug\n> - **Decision:** Start with offline batch training for initial implementation.\n> - **Rationale:** The primary goal is to prove value with simpler infrastructure. Offline training allows for careful validation of model suggestions before deployment. We can transition to online learning once the feature proves valuable and we understand the patterns better.\n> - **Consequences:** Root cause suggestions may be slightly stale (up to 24 hours) but this is acceptable for initial implementation.\n\n#### 14.3 eBPF-Based Instrumentation\n\n**Mental Model: The Universal System Tap**\n> eBPF (extended Berkeley Packet Filter) allows us to insert instrumentation directly into the Linux kernel or application runtime without modifying source code—like installing microscopic sensors throughout a building's infrastructure (pipes, electrical, HVAC) that can monitor flow and performance without touching the rooms themselves.\n\nWhile our current APM SDK requires language-specific instrumentation (Go, Python, Java), eBPF-based instrumentation could provide universal, zero-code-change tracing for any application, including those written in languages we don't yet support or legacy systems where adding an SDK is impractical. This would dramatically expand the observability surface with minimal performance overhead.\n\n**Integration Approach:**\n1. **eBPF Collector Sidecar:** Deploy a lightweight daemon (e.g., using `libbpf` or `bcc` tools) alongside each service that captures system calls, network traffic, and application runtime events.\n2. **Span Generation from Kernel Events:** Transform eBPF events into spans, inferring service boundaries from network connections and process relationships.\n3. **Hybrid Instrumentation Strategy:** Combine eBPF spans with SDK-generated spans for complete coverage, using consistent trace IDs.\n4. **Resource-Aware Sampling:** Apply intelligent sampling at the eBPF level to manage the potentially massive volume of kernel-level events.\n\n**Technical Architecture:**\n```\n[Application Process] ← eBPF probes → [eBPF Collector Sidecar] → Spans → [Existing Collector]\n       ↓                                       ↓\n [APM SDK spans]                        [Kernel/System spans]\n```\n\n**eBPF Event Types to Capture:**\n| Event Type | Span Conversion | Information Gained |\n|------------|----------------|-------------------|\n| `sys_enter`/`sys_exit` for `connect`, `accept`, `send`, `recv` | Network call spans | Cross-service calls without SDK |\n| `sys_enter`/`sys_exit` for file I/O, disk operations | Storage I/O spans | Database/disk latency breakdown |\n| Application function entry/exit via USDT probes | Function-level spans | Code path visibility without source modification |\n| TCP retransmissions, congestion window changes | Network quality spans | Infrastructure-level issues affecting application |\n\n**Required New Components:**\n- `eBPFCollector` implementing `SpanExporter` interface\n- `eBPFSpanGenerator` converting eBPF events to `Span` objects\n- `KernelEventBuffer` with ring buffer for high-volume event handling\n\n**Performance Considerations:**\n- eBPF programs run in the kernel with JIT compilation for near-native speed\n- Event filtering at the kernel level reduces userspace overhead\n- Still requires careful sampling for high-throughput systems\n\n#### 14.4 Real User Monitoring (RUM) Integration\n\n**Mental Model: The Frontend Flight Recorder**\n> While our current system monitors backend services, Real User Monitoring captures the actual user experience in browsers and mobile apps—like adding cockpit voice recorders and control inputs to our existing flight data recorders, giving us the complete picture from pilot intent to aircraft response.\n\nRUM extends tracing to the client side, capturing browser performance metrics (First Contentful Paint, Largest Contentful Paint), JavaScript errors, and user interaction timing. Integrating RUM with our existing backend traces creates end-to-end visibility from user click to database query and back.\n\n**Integration Strategy:**\n1. **Browser SDK Extension:** Develop a lightweight JavaScript library that instruments page load, resource timing, and user interactions.\n2. **Trace Context Propagation:** Extend W3C Trace Context to include frontend-originated trace IDs, ensuring seamless correlation with backend traces.\n3. **Session-Based Analysis:** Group RUM events by user session to understand complete user journeys.\n4. **Synthetic Monitoring Baseline:** Compare real user data with synthetic tests to distinguish network issues from application problems.\n\n**Data Model Extensions:**\n```go\n// Extended Span type for RUM-specific data\ntype RUMSpan struct {\n    models.Span                   // Embedded base span\n    BrowserInfo      BrowserInfo  // Browser version, viewport size\n    PageURL          string       // URL where span occurred\n    UserInteraction  string       // \"click\", \"scroll\", \"input\"\n    WebVitals        WebVitals    // Core Web Vitals metrics\n}\n\ntype WebVitals struct {\n    FCP    time.Duration  // First Contentful Paint\n    LCP    time.Duration  // Largest Contentful Paint\n    FID    time.Duration  // First Input Delay\n    CLS    float64        // Cumulative Layout Shift\n}\n```\n\n**Correlation Enhancement:**\nWhen a user reports \"the checkout page is slow,\" engineers could:\n1. Query RUM spans for the checkout page to see if it's a frontend issue (slow LCP)\n2. Follow the trace ID to see backend processing time\n3. Identify whether the bottleneck is in JavaScript execution, network latency, or service processing\n\n#### 14.5 Business Transaction Tracing\n\n**Mental Model: The Business Process Map Overlay**\n> While technical traces show service calls, business transaction tracing overlays business semantics (customer journeys, order flows, payment processing) onto the technical infrastructure—like adding labeled \"shipping routes\" and \"warehouse operations\" to a map of roads and buildings.\n\nThis enhancement allows tagging traces with business context (user ID, order value, transaction type) and defining key business transactions (e.g., \"new user signup,\" \"premium checkout\") that can be monitored for SLAs, error rates, and performance against business objectives.\n\n**Implementation Approach:**\n1. **Business Context Propagation:** Extend trace context to include business key-value pairs that flow with the request.\n2. **Transaction Definition DSL:** Create a domain-specific language for defining business transactions as patterns of spans with specific attributes.\n3. **Business Metrics Aggregation:** Extend the analytics engine to compute metrics per business transaction rather than just per service/operation.\n4. **Business SLA Monitoring:** Alert when business transactions violate defined SLAs (e.g., \"gold-tier checkout must complete under 2 seconds 99% of the time\").\n\n**Example Business Transaction Definition:**\n```yaml\nbusiness_transactions:\n  - name: \"premium_checkout\"\n    description: \"Checkout flow for premium users\"\n    match:\n      - span.service: \"checkout-service\"\n        span.operation: \"process_payment\"\n        span.attributes.user_tier: \"premium\"\n      - span.service: \"inventory-service\"\n        span.operation: \"reserve_item\"\n    sla:\n      p99_latency: \"2s\"\n      error_rate: \"0.1%\"\n```\n\n**Required System Changes:**\n- Enhanced `Span` type with `BusinessAttributes map[string]string`\n- New `BusinessTransactionMonitor` component\n- Extended Query Service API for querying traces by business attributes\n- New visualization layer showing business transaction flow across services\n\n#### 14.6 Trace Data Enrichment with Logs and Metrics\n\n**Mental Model: The Unified Observability Timeline**\n> Currently, traces, logs, and metrics exist in separate silos. Enrichment creates bidirectional links between them—like adding cross-references between a detective's case notes (logs), crime scene photos (metrics), and witness interview transcripts (traces), creating a unified case file.\n\nThis enhancement would correlate trace data with log entries and infrastructure metrics, allowing engineers to pivot from a slow trace to the corresponding application logs (to see error messages) and system metrics (to see CPU spikes) from the same time period.\n\n**Integration Architecture:**\n1. **Unified Storage Backend:** Extend storage to support logs and metrics alongside traces, or implement connectors to existing log/metric systems.\n2. **Correlation Index:** Create an index by timestamp and service to quickly find related telemetry data.\n3. **Query Language Enhancement:** Extend the query language to support joins across trace, log, and metric data.\n4. **Unified Visualization:** Create a single UI that shows traces alongside related logs and metrics.\n\n**Correlation Strategies:**\n| Correlation Method | Implementation | Use Case |\n|-------------------|----------------|----------|\n| **Timestamp Proximity** | Find logs/metrics within ±100ms of span timestamps | General debugging |\n| **Trace Context Injection** | Inject trace ID into log messages (via structured logging) | Precise log-to-trace linking |\n| **Resource Attributes** | Match by service name, host, container ID | Infrastructure issue correlation |\n\n**Example Enhancement to Storage Layer:**\n```go\n// Extended storage interface supporting multi-signal queries\ntype UnifiedStorage interface {\n    GetTraceWithContext(ctx context.Context, traceID string) (*TraceWithContext, error)\n}\n\ntype TraceWithContext struct {\n    Trace   *models.Trace\n    Logs    []LogEntry          // Related log entries\n    Metrics []MetricSample      // Related metric samples\n    Events  []InfrastructureEvent // Deployment, scaling events\n}\n```\n\n#### 14.7 Multi-Tenancy and Data Isolation\n\n**Mental Model: The Observability Apartment Building**\n> Currently, our system treats all data as belonging to a single organization. Multi-tenancy adds separate \"apartments\" (tenants) with soundproof walls and separate entrances—each tenant's data is fully isolated, but they share the same building infrastructure (collectors, storage, query engines).\n\nThis enhancement would enable serving multiple independent organizations or internal teams from a single APM deployment, with strict data isolation, tenant-specific configurations, and usage-based billing.\n\n**Implementation Considerations:**\n1. **Tenant Identification:** Add tenant ID to all spans, either via authentication tokens or request headers.\n2. **Storage Isolation:** Implement storage backends that support tenant partitioning at the data layer.\n3. **Query Isolation:** Extend all query APIs to filter by tenant ID, enforced at the API gateway.\n4. **Rate Limiting and Quotas:** Apply tenant-specific limits on ingestion rate, storage usage, and query frequency.\n5. **Administrative UI:** Add tenant management interfaces for provisioning, configuration, and usage monitoring.\n\n**Data Flow Changes:**\n```\n[Tenant A App] → [Collector] → [Storage with Tenant Partitioning]\n[Tenant B App] ↗        ↓\n           [Query Service with Tenant Filtering] → [Tenant-Specific UI]\n```\n\n**Security Considerations:**\n- Tenant isolation must be enforced at every layer (API, storage, cache)\n- No cross-tenant data leakage in aggregations or sampling decisions\n- Audit logging of all tenant data access\n\n#### 14.8 Advanced Visualization: Flame Graphs and Heat Maps\n\n**Mental Model: The Performance Topographical Map**\n> While our current service map shows service relationships, flame graphs show time distribution within a service, and heat maps show request density patterns—like adding elevation contours (flame graphs) and population density shading (heat maps) to a geographical map, revealing not just locations but intensity and distribution.\n\nThese visualization enhancements would help engineers quickly identify hotspots in their code (flame graphs) and understand temporal patterns of request flow (heat maps).\n\n**Flame Graph Implementation:**\n1. **Span Stack Construction:** Convert parent-child span relationships into call stacks for flame graph rendering.\n2. **Time-Aggregated Views:** Aggregate spans from multiple traces to show typical execution patterns.\n3. **Interactive Exploration:** Allow drilling into specific functions or time ranges.\n\n**Heat Map Implementation:**\n1. **Request Density Calculation:** Compute requests per second across services and time buckets.\n2. **Latency Coloring:** Color cells by average latency or error rate.\n3. **Anomaly Highlighting:** Visually flag time periods with anomalies.\n\n**Visualization Integration:**\n- Extend the existing Web UI with new visualization components\n- Add new API endpoints for flame graph and heat map data\n- Support exporting visualizations for incident reports\n\n#### 14.9 Predictive Capacity Planning\n\n**Mental Model: The Observability Crystal Ball**\n> While current analytics tell us what *is* happening and what *did* happen, predictive capacity planning forecasts what *will* happen—like using weather radar patterns to predict storm paths and intensities hours in advance.\n\nThis enhancement would apply time-series forecasting algorithms to historical performance data to predict future resource needs, identify capacity bottlenecks before they cause outages, and recommend scaling actions.\n\n**Forecasting Algorithms:**\n- **ARIMA/SARIMA** for seasonal patterns\n- **Prophet** for handling holidays and changepoints\n- **LSTM neural networks** for complex multi-variate patterns\n\n**Integration Points:**\n1. **Forecasting Pipeline:** Extend the analytics engine with forecasting modules that run periodically.\n2. **Capacity Recommendations:** Generate actionable recommendations (e.g., \"Increase payment-service instances by 2 before Black Friday\").\n3. **What-If Analysis:** Simulate the impact of traffic increases or infrastructure changes.\n\n**Example Output:**\n```json\n{\n  \"service\": \"payment-service\",\n  \"metric\": \"p95_latency\",\n  \"current_value\": \"145ms\",\n  \"forecast\": {\n    \"1_hour\": \"152ms (±8ms)\",\n    \"24_hours\": \"210ms (±25ms)\",\n    \"7_days\": \"Will exceed 500ms SLA in 4.3 days at current growth rate\"\n  },\n  \"recommendation\": \"Add 2 instances within 48 hours\"\n}\n```\n\n#### 14.10 Enhancement Prioritization Framework\n\nTo help prioritize which enhancements to implement first, consider this decision matrix:\n\n| Enhancement | Business Value | Implementation Complexity | Data Volume Impact | User Impact |\n|-------------|---------------|--------------------------|-------------------|-------------|\n| Continuous Profiling | High (pinpoints code issues) | Medium (new data type) | High (large profiles) | Medium (developers) |\n| AI Root Cause Analysis | Very High (reduces MTTR) | High (ML expertise) | Low (metadata only) | High (on-call engineers) |\n| eBPF Instrumentation | High (universal coverage) | Very High (kernel expertise) | Very High (raw events) | Medium (platform teams) |\n| RUM Integration | High (end-to-end visibility) | Medium (new SDK) | Medium (browser data) | High (frontend teams) |\n| Business Transaction Tracing | High (aligns with business) | Low (metadata addition) | Low (small attributes) | High (product managers) |\n| Multi-Tenancy | Medium (enables SaaS) | High (security critical) | Medium (partitioning) | Medium (operations) |\n\n> **Key Insight:** The most valuable enhancements often build upon existing capabilities with minimal disruption. Business Transaction Tracing and RUM Integration offer high value with moderate complexity, making them excellent candidates for near-term implementation.\n\n### Implementation Guidance for Future Extensions\n\n**A. Technology Recommendations for Extensions**\n\n| Extension | Core Technology | Integration Point |\n|-----------|----------------|-------------------|\n| Continuous Profiling | **pprof** (Go), **py-spy** (Python), **async-profiler** (Java) | Extend `Tracer` to optionally capture profiles |\n| AI Root Cause Analysis | **scikit-learn**, **TensorFlow**, or **H2O.ai** for ML; **Jupyter** for analysis | New `RootCauseAnalyzer` component in analytics layer |\n| eBPF Instrumentation | **libbpf** (C library), **bcc** (Python tools), **cilium/ebpf** (Go library) | New `eBPFCollector` sidecar process |\n| RUM Integration | **Web Performance API**, **Error Tracking API** | New JavaScript SDK extending W3C Trace Context |\n| Business Transaction Tracing | **YAML/JSON DSL** for definitions | Extend `Span` attributes and add `BusinessTransactionMonitor` |\n| Multi-Tenancy | **JWT/OAuth2** for auth, **PostgreSQL Row Security** or storage partitioning | Tenant ID propagation throughout data pipeline |\n\n**B. Recommended File Structure for Extensible Design**\n\nTo accommodate future extensions without major refactoring, organize the codebase with clear interfaces and plugin points:\n\n```\nproject-root/\n  cmd/\n    collector/           # Main collector binary\n    query-service/       # Query service binary\n    web-ui/             # Web UI server\n  internal/\n    # Core components (existing)\n    ingestion/          # Pipeline, validation, buffering\n    storage/            # Span storage interfaces and implementations\n    sampling/           # Head and tail sampling\n    analytics/          # Percentiles, anomaly detection\n    sdk/                # Auto-instrumentation libraries\n    \n    # Extension points (new directories)\n    extensions/         # Interfaces and registries for extensions\n      profiler/         # Profiling extension interfaces\n      rum/              # RUM extension interfaces  \n      ebpf/             # eBPF collection interfaces\n      business/         # Business transaction interfaces\n    \n    # Implementation of specific extensions (when built)\n    extensions/impl/\n      profiler-pprof/   # pprof-based profiler\n      rum-js/           # JavaScript RUM SDK\n      ebpf-collector/   # eBPF event collector\n      \n  pkg/\n    api/                # Public APIs for external integration\n    models/             # Core data types (Span, Trace, etc.)\n    plugin/             # Plugin framework interfaces\n```\n\n**C. Extension Point Interfaces**\n\nTo ensure the system can be extended without modification to core components, define these key interfaces:\n\n```go\n// Extension point for adding new telemetry sources\ntype TelemetrySource interface {\n    Name() string\n    Start(ctx context.Context) error\n    Stop() error\n    TelemetryChan() <-chan models.Span\n}\n\n// Extension point for adding new analysis modules  \ntype AnalysisModule interface {\n    Name() string\n    Analyze(ctx context.Context, trace *models.Trace) (AnalysisResult, error)\n    RequiredFields() []string // Span fields needed for analysis\n}\n\n// Extension point for adding new visualizations\ntype VisualizationProvider interface {\n    Name() string\n    Type() string // \"flamegraph\", \"heatmap\", etc.\n    DataQuery(ctx context.Context, params map[string]string) ([]byte, error)\n    RenderOptions() map[string]interface{}\n}\n\n// Registry for extensions (simplified example)\ntype ExtensionRegistry struct {\n    mu          sync.RWMutex\n    sources     map[string]TelemetrySource\n    analyzers   map[string]AnalysisModule\n    visualizers map[string]VisualizationProvider\n}\n\nfunc (r *ExtensionRegistry) RegisterSource(source TelemetrySource) {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    r.sources[source.Name()] = source\n}\n\n// Initialize extensions in main()\nfunc main() {\n    registry := NewExtensionRegistry()\n    \n    // Register built-in extensions based on configuration\n    if config.EnableProfiling {\n        registry.RegisterSource(NewPProfProfiler(config.Profiling))\n    }\n    \n    if config.EnableRUM {\n        registry.RegisterSource(NewRUMSource(config.RUM))\n    }\n    \n    // Start all registered extensions\n    for _, source := range registry.Sources() {\n        go source.Start(ctx)\n    }\n}\n```\n\n**D. Design for Extension: Span Enrichment Pattern**\n\nMany extensions (business tracing, multi-tenancy, log correlation) need to add metadata to spans. Instead of modifying the core `Span` type for each extension, use an extensible attributes pattern:\n\n```go\n// Current Span type already has Attributes map[string]string\n// Use a namespacing convention for extension attributes:\n// \"extension.attribute_name\" → \"value\"\n\n// Business transaction attributes\nspan.Attributes[\"business.transaction\"] = \"premium_checkout\"\nspan.Attributes[\"business.customer_tier\"] = \"gold\"\n\n// RUM attributes  \nspan.Attributes[\"rum.browser\"] = \"Chrome 91\"\nspan.Attributes[\"rum.page_url\"] = \"https://example.com/checkout\"\n\n// Multi-tenancy attributes\nspan.Attributes[\"tenant.id\"] = \"acme-corp\"\nspan.Attributes[\"tenant.environment\"] = \"production\"\n\n// Helper functions for extension authors\nfunc AddBusinessContext(span *models.Span, transaction string, attributes map[string]string) {\n    span.Attributes[\"business.transaction\"] = transaction\n    for k, v := range attributes {\n        span.Attributes[\"business.\"+k] = v\n    }\n}\n\n// Query support for extension attributes\nfunc GetTracesByBusinessTransaction(ctx context.Context, transaction string) ([]*models.Trace, error) {\n    // Storage layer should index extension.* attributes for efficient querying\n    return storage.GetTracesByAttribute(ctx, \"business.transaction\", transaction)\n}\n```\n\n**E. Migration Strategy for Extensions**\n\nWhen implementing extensions that change data schemas or require new storage formats:\n\n1. **Versioned Data Formats:** Always include a version field in stored data.\n2. **Dual-Write During Migration:** Write both old and new formats during transition.\n3. **Backward Compatibility:** Ensure queries work with old data formats.\n4. **Gradual Rollout:** Enable extensions per-service or per-tenant initially.\n\n```go\n// Example: Adding profile storage\ntype StorageV1 struct { /* existing span storage */ }\n\ntype StorageV2 struct {\n    StorageV1                    // embedded for backward compatibility\n    profileStorage ProfileStorage // new capability\n}\n\n// During migration period\nif config.UseProfilingExtension {\n    // Store profiles in new storage\n    storageV2.profileStorage.StoreProfile(profile)\n}\n// Always store spans in V1-compatible format\nstorageV1.StoreSpan(span)\n```\n\n**F. Testing Extension Points**\n\nCreate test helpers for extension developers:\n\n```go\n// Extension test suite\nfunc TestExtensionContract(t *testing.T) {\n    // Verify extension implements required interface\n    var _ extensions.TelemetrySource = &MyExtension{}\n    \n    // Test integration with core pipeline\n    pipeline := ingestion.NewTestPipeline()\n    extension := NewMyExtension()\n    \n    // Start extension\n    err := extension.Start(context.Background())\n    require.NoError(t, err)\n    \n    // Verify it produces valid spans\n    select {\n    case span := <-extension.TelemetryChan():\n        assert.NotEmpty(t, span.TraceID)\n        assert.NotEmpty(t, span.ServiceName)\n    case <-time.After(1 * time.Second):\n        t.Fatal(\"Extension didn't produce telemetry within 1 second\")\n    }\n}\n```\n\n**G. Performance Monitoring for Extensions**\n\nExtensions should include their own performance monitoring:\n\n```go\ntype ExtensionMetrics struct {\n    SpansGenerated   prometheus.Counter\n    ProcessingTime   prometheus.Histogram\n    Errors           prometheus.Counter\n    QueueLength      prometheus.Gauge\n}\n\n// Register with central metrics registry\nfunc (e *MyExtension) registerMetrics() {\n    metrics.ExtensionMetrics.WithLabelValues(e.Name()).Inc()\n}\n```\n\n> **Key Implementation Insight:** The most important design principle for future extensions is **dependency inversion**—core components should depend on abstractions (interfaces) that extensions implement, not the other way around. This allows adding new capabilities without modifying tested core code.\n\nBy designing with these extension points in mind, the APM Tracing System can evolve gracefully to incorporate new observability capabilities as they emerge, ensuring the system remains valuable and relevant as technology and requirements change.\n\n\n> **Milestone(s):** This section provides a comprehensive reference for terminology used throughout all five milestones of the APM Tracing System, ensuring consistent understanding across the design document.\n\n## 15. Glossary\n\nAs you navigate the design of the APM Tracing System, you'll encounter specialized terms that carry precise technical meanings. This glossary serves as a definitive reference, clarifying terminology used across all system components. Think of it as the **legend for a complex map**—it doesn't change the territory, but makes it readable. Having a shared vocabulary is essential for clear communication among team members and for understanding the architectural decisions documented throughout this design.\n\n### Terminology Reference\n\nThe following table defines key terms used in this design document, organized alphabetically for quick reference.\n\n| Term | Definition | Context & Significance |\n|------|------------|------------------------|\n| **Adaptive Sampling** | A sampling strategy that dynamically adjusts sampling rates based on system load, trace value, or other real-time metrics. | Used in **Milestone 3** to balance data volume with insight preservation. Unlike fixed-rate sampling, adaptive sampling responds to changing conditions—for example, lowering rates during traffic surges to protect storage, or increasing rates when error rates spike to capture more debugging data. |\n| **Anomaly** | A data point or pattern in metrics that deviates significantly from expected, historical behavior. | The target of detection in **Milestone 4**. Anomalies in APM systems typically manifest as sudden latency spikes, error rate increases, or throughput drops. Distinguishing true anomalies from expected variations (like daily traffic patterns) is a core challenge. |\n| **APM (Application Performance Monitoring)** | The practice and technology for monitoring software applications for performance, availability, and user experience. | The overarching domain of this project. APM systems combine distributed tracing, metrics, and sometimes logs to provide holistic visibility into application behavior. Our system focuses specifically on the tracing pillar. |\n| **Backpressure** | A flow control mechanism where a downstream component signals upstream components to slow down or stop sending data when it cannot keep up. | A critical resilience concept discussed in **Section 11**. When the collector is overwhelmed, it must apply backpressure (e.g., via aggressive sampling or connection refusal) to prevent cascading failures and data loss. |\n| **Baseline** | Historical performance data (e.g., latency percentiles, error rates) used as a reference for comparison when detecting anomalies. | Established in **Milestone 4** through analysis of past metrics. Baselines can be simple (like a rolling average) or sophisticated (accounting for weekly seasonality). Comparing current metrics against baselines allows the system to identify deviations that warrant investigation. |\n| **Buffer Eviction** | The process of removing items from an in-memory buffer when it reaches capacity or when items have exceeded their time-to-live (TTL). | A key mechanism in **Milestone 1's** `BufferManager`. Since we cannot buffer spans indefinitely while waiting for late-arriving spans, we must evict old, incomplete traces. The eviction policy (e.g., LRU, based on first-seen time) directly impacts trace completeness. |\n| **Business Transaction Tracing** | Tagging traces with business context (e.g., customer ID, transaction type) to enable monitoring and analysis of business processes rather than just technical operations. | A **Future Extension** from Section 14. This allows correlating performance issues with business impact—for example, seeing that checkout latency increases are affecting premium customers. |\n| **Cascading Failures** | A failure mode where the failure of one component causes failures in dependent components, potentially leading to system-wide outage. | A risk mitigated by patterns like circuit breakers and backpressure. In our APM system, if the storage backend becomes slow, the collector could exhaust memory buffering spans, then become unresponsive to new spans, causing instrumentation SDKs to block or drop data. |\n| **Chaos Testing** | A testing methodology that deliberately injects failures (network partitions, process kills, latency spikes) into a system to verify its resilience. | Part of the **Testing Strategy** in Section 12. For our APM system, chaos testing might involve randomly killing collector instances or introducing high latency to storage to verify that sampling degrades gracefully and data isn't lost. |\n| **Circuit Breaker Pattern** | A design pattern that prevents calls to a failing service by opening a \"circuit\" after failure thresholds are exceeded, failing fast instead of waiting for timeouts. | Used in **Section 11** for protecting interactions between components (e.g., collector to storage). The `CircuitBreaker` struct implements states (`StateClosed`, `StateOpen`, `StateHalfOpen`) to prevent overloading already-struggling dependencies. |\n| **Clock Skew** | The difference in system clock times between different machines in a distributed system. | A **Common Pitfall** in **Milestone 1**. Since spans arrive from multiple services with potentially unsynchronized clocks, relying solely on span timestamps for ordering can produce incorrect trace sequences. The system must handle or normalize for clock skew. |\n| **Columnar Storage** | A storage format that organizes data by columns rather than rows, optimizing for analytical queries that aggregate over specific fields. | Mentioned as an optimization for trace storage. Storing all `Duration` values contiguously enables faster percentile calculations across many traces, compared to row-oriented storage that would load entire spans. |\n| **Consistent Hashing** | A hash function that ensures the same input (e.g., trace ID) always maps to the same output, enabling deterministic decisions across distributed components. | Critical for **head-based sampling** in **Milestone 3**. Using `ConsistentSampler.ShouldSample(traceID)` with a hash function guarantees that all spans from the same trace receive the same sampling decision, even if they arrive at different collectors. |\n| **Context Propagation** | The mechanism for carrying trace context (trace ID, span ID, sampling decision) across process and service boundaries, typically via HTTP headers or RPC metadata. | A core concept in **Milestone 5**. The SDK's `InjectTraceContext` and `ExtractTraceContext` methods implement the W3C Trace Context standard, allowing traces to continue seamlessly across service calls. |\n| **Continuous Profiling** | The practice of periodically capturing and analyzing application profiles (CPU, memory allocation) to identify performance bottlenecks over time. | A **Future Extension** that could integrate with the APM system. While tracing shows *what* happened and *when*, profiling shows *why* certain code paths are slow by revealing hot functions and allocation patterns. |\n| **Cycle Detection** | An algorithm to identify circular dependencies in service calls (e.g., Service A → Service B → Service A), which can indicate architectural issues or cause infinite loops. | Part of **service map construction** in **Milestone 2**. The `ServiceGraph` should identify cycles to alert developers about potentially problematic dependency patterns that could lead to cascading failures. |\n| **Dictionary Encoding** | A compression technique that replaces repeated string values (like service names or operation names) with integer IDs in storage, reducing disk usage and improving query performance. | An optimization for trace storage. Since `ServiceName` and `Span.Name` fields often have high repetition, dictionary encoding can significantly reduce the storage footprint of the `Attributes` map and other string-heavy fields. |\n| **Distributed Tracing** | A method of tracking requests as they propagate through a distributed system, recording timing data and metadata at each step (span) to form a complete timeline (trace). | The foundational technique of this entire project. It addresses the observability challenge in microservices by providing request-centric visibility, as opposed to metric- or log-centric views. |\n| **Edge Aggregation** | The process of combining multiple individual service call observations (spans) into summarized metrics (call count, error rate, latency percentiles) for a specific caller-callee pair over a time window. | The core operation in **Milestone 2's** `EdgeAggregator`. Instead of storing every call, we aggregate spans into `ServiceEdge` records that represent the communication pattern between two services during a specific time window. |\n| **eBPF (Extended Berkeley Packet Filter)** | A technology for running sandboxed programs in the Linux kernel, enabling observability, networking, and security functionality without modifying kernel source code or loading kernel modules. | A **Future Extension** for zero-instrumentation tracing. An `eBPFCollector` could automatically trace system calls, network traffic, or application functions without requiring code changes, complementing the SDK-based instrumentation. |\n| **Flame Graph** | A visualization of hierarchical data, typically call stacks, where the width of each element represents its resource consumption (CPU time, memory allocations). | A potential visualization for performance analytics. While not part of the core milestones, flame graphs could be generated from trace data to show which code paths contribute most to latency. |\n| **Graceful Degradation** | A design principle where a system continues to operate with reduced functionality rather than failing completely when under stress or partial failure. | A guiding principle for **Error Handling**. For example, when storage is unavailable, the collector might switch to a \"degraded mode\" where it samples traces more aggressively but still provides some visibility, rather than rejecting all spans. |\n| **Head-Based Sampling** | A sampling strategy where the decision to keep or drop a trace is made at the very beginning of the trace (when the root span is created), using only initial context (trace ID, service name). | Implemented by the `HeadSampler` in **Milestone 3**. This is efficient (no buffering required) but risks dropping interesting traces that only become \"interesting\" later (e.g., due to an error in a downstream service). |\n| **Head-of-Line Blocking** | A performance issue where processing of one item is delayed, causing all subsequent items in the queue to wait, even if they could be processed independently. | A potential pitfall in the ingestion pipeline. If one malformed span requires expensive validation or blocking I/O, it shouldn't stall the processing of all other spans. The pipeline design uses buffered channels and parallel processing to avoid this. |\n| **Health Check** | An endpoint or probe that reports the operational status of a component or system, typically used by load balancers and orchestration systems to determine if an instance should receive traffic. | Implemented via `HealthRegistry` and its handlers (`HealthHandler`, `LivenessHandler`, `ReadinessHandler`) in **Section 11**. The health check aggregates status from all components (collector, buffer manager, storage connection) to give a holistic view. |\n| **Infrastructure Metrics** | System-level measurements like CPU utilization, memory usage, disk I/O, and network bandwidth, as opposed to application-level metrics (request latency, error rates). | A **Non-Goal** of this APM system (we focus on application traces), but mentioned as a complementary observability signal. In a unified observability platform, infrastructure metrics would correlate with trace data to identify root causes. |\n| **Integration Test** | A test that verifies multiple components work together correctly by testing their interactions through real or simulated interfaces. | Part of the **Testing Strategy**. For example, an integration test might start a collector, send spans via the OTLP endpoint, and verify they appear in storage and affect the service map. |\n| **Load Test** | A test that measures system performance (throughput, latency, resource usage) under expected or peak load conditions. | Essential for verifying **Milestone 1** acceptance criteria (handling 1000 spans/second). Load tests simulate production traffic patterns to identify bottlenecks and validate scaling assumptions. |\n| **Log Aggregation** | The practice of centralized collection, indexing, and search of unstructured log data from multiple services. | A **Non-Goal**—our system focuses on structured trace data, not unstructured logs. However, traces can be correlated with logs via trace IDs injected into log messages, creating a unified debugging experience. |\n| **Liveness Probe** | A type of health check that indicates whether a process is running (alive), without guaranteeing it's ready to handle work. | Simpler than a readiness check. The `LivenessHandler` typically returns success as long as the process hasn't crashed. Kubernetes uses this to decide when to restart a container. |\n| **Microservices** | An architectural style that structures an application as a collection of loosely coupled, independently deployable services that communicate via APIs. | The primary architectural context for distributed tracing. Microservices introduce the observability challenge that tracing solves: a single user request may traverse dozens of services, making debugging without traces nearly impossible. |\n| **Middleware** | A software layer that intercepts requests and responses in a framework's processing pipeline, enabling cross-cutting concerns like logging, authentication, and—in our case—tracing. | The primary instrumentation technique in **Milestone 5** for web frameworks. The SDK provides middleware for Gin (Go), Express (Node.js), and Flask (Python) that automatically creates spans for incoming HTTP requests. |\n| **Mock** | A simulated object that mimics the behavior of a real component in controlled ways for testing purposes. | Used extensively in unit tests. For example, we mock the `storage.Writer` interface to test the collector without needing a real database, verifying that `StoreSpan` is called with expected parameters. |\n| **Monkey Patching** | A technique to modify or extend the behavior of a library at runtime by replacing its functions or methods. | One method for **auto-instrumentation** in **Milestone 5**, particularly in dynamic languages like Python. The SDK might monkey-patch the `requests` library to automatically inject trace headers into all HTTP requests. Must be done carefully to avoid breaking original behavior. |\n| **Moving Average** | A calculation to analyze data points by creating a series of averages of different subsets of the full data set, often used to smooth short-term fluctuations and highlight longer-term trends. | One statistical method for **anomaly detection** in **Milestone 4**. By comparing current latency to a moving average of recent latencies, we can detect deviations from recent norms. |\n| **Multi-Tenancy** | An architectural pattern where a single deployment of software serves multiple independent customers (tenants), with data and configuration isolated between them. | A **Future Extension** consideration. The APM system could be enhanced to support multiple teams or external customers, requiring isolation of trace data, sampling configurations, and service maps per tenant. |\n| **OpenTelemetry** | A vendor-neutral, open-source collection of APIs, SDKs, and tools for instrumenting, generating, collecting, and exporting telemetry data (traces, metrics, logs). | The standard we adopt for trace format and context propagation. Our collector accepts spans in **OpenTelemetry Protocol (OTLP)** format via the `OTLPHandler`, ensuring compatibility with a wide ecosystem of instrumentation libraries. |\n| **OpenTelemetry Protocol (OTLP)** | The standard protocol defined by OpenTelemetry for telemetry data exchange between clients and collectors, supporting both gRPC and HTTP/JSON transports. | The wire format for span ingestion. The `parseOTLPJSON` and `parseOTLPProtobuf` methods convert OTLP payloads into our internal `Span` representation, ensuring we can receive data from any OpenTelemetry-compliant SDK. |\n| **Percentile** | A value below which a given percentage of observations in a group of observations falls. For example, the 95th percentile (p95) latency is the value below which 95% of observed latencies fall. | A core metric in **Milestone 4**. Percentiles (p50, p95, p99) are more informative than averages for performance analysis because they reveal tail latency behavior that affects user experience. |\n| **PID Controller** | A control loop mechanism that uses proportional, integral, and derivative terms to calculate an error value as the difference between a desired setpoint and a measured process variable. | One possible algorithm for **adaptive sampling** in **Milestone 3**. A PID controller could adjust sampling rates to maintain a target span ingestion rate, smoothly responding to traffic changes without oscillation. |\n| **pipes and filters** | An architectural pattern where data flows through a sequence of processing components (filters), each performing a specific transformation, connected by pipes (channels, queues). | The pattern used in the ingestion `Pipeline`. Spans flow through: validator → buffer manager → head sampler → (later) tail sampler → storage writer. This design promotes separation of concerns and easy component replacement. |\n| **Predictive Capacity Planning** | Using historical performance data and trends to forecast future resource needs (CPU, memory, storage) for a system. | A **Future Extension** leveraging the analytics engine. By analyzing trace volume growth and latency trends, the system could predict when storage capacity will be exhausted or when additional collector instances will be needed. |\n| **Property-Based Testing** | A testing methodology that verifies properties or invariants hold for a large number of randomly generated inputs, rather than testing specific examples. | Useful for testing complex logic like trace assembly. For example, a property-based test could generate random spans with valid parent-child relationships and verify that `TraceAssembler.AssembleTrace` always produces a properly structured trace hierarchy. |\n| **Readiness Probe** | A type of health check that indicates whether a component is ready to handle work (e.g., dependencies connected, caches warmed). | More comprehensive than a liveness probe. The `ReadinessHandler` might check that the collector can connect to storage and that the buffer manager is not overloaded. Kubernetes uses this to control when to send traffic to a pod. |\n| **Real User Monitoring (RUM)** | Instrumenting client-side web applications to capture browser performance metrics, user interactions, and frontend errors experienced by real users. | A **Non-Goal**—our system focuses on server-side tracing. However, the data model includes `RUMSpan` as a potential extension, showing how client-side spans could integrate with server-side traces for full-stack visibility. |\n| **Ring Buffer** | A circular buffer data structure that uses a single, fixed-size buffer as if it were connected end-to-end, providing efficient FIFO semantics for streaming data. | Used in the `MemoryStore` for metric aggregation in **Milestone 4**. Ring buffers naturally evict old data as new data arrives, making them ideal for sliding window calculations without explicit cleanup logic. |\n| **Seasonal Decomposition** | A time series analysis method that separates data into trend, seasonal (periodic), and residual components, useful for detecting anomalies in data with regular patterns (like daily or weekly cycles). | An advanced technique for **baseline calculation** in **Milestone 4**. By accounting for regular patterns (e.g., lower traffic on weekends), seasonal decomposition reduces false positives in anomaly detection. |\n| **Service** | A logical component in a distributed system that emits spans. In our data model, a `Service` has a name and a list of operations (endpoints) it performs. | A fundamental entity in service maps and sampling configuration. Services are extracted from spans' `ServiceName` field, and sampling rates can be configured per service via `SamplingConfig.PerService`. |\n| **Service Map** | A visual representation of service dependencies in a distributed system, typically shown as a directed graph where nodes are services and edges represent calls between them, annotated with metrics. | The primary deliverable of **Milestone 2**. The `ServiceGraph` is constructed from trace data and provides an at-a-glance view of system topology and health, helping engineers understand communication patterns and identify bottlenecks. |\n| **Span** | A named, timed operation representing a unit of work within a trace. Spans have a parent-child relationship structure and contain timing data, attributes, and status. Defined as the `Span` struct with fields like `SpanID`, `TraceID`, `ParentSpanID`, `Name`, `ServiceName`, `StartTime`, `Duration`, etc. | The atomic unit of tracing data. Everything in the APM system revolves around spans—they are ingested, buffered, sampled, stored, and analyzed. A trace is composed of one or more spans. |\n| **SpanExporter** | A component in the SDK that sends completed spans to the collector, typically batching them for efficiency. | Part of the SDK architecture in **Milestone 5**. The exporter handles the network communication, retry logic, and backoff, allowing the instrumentation code to be non-blocking. |\n| **Synthetic Monitoring** | Proactive simulation of user traffic (e.g., via scripted browser sessions or API calls) to measure availability and performance from predefined locations. | A **Non-Goal** but mentioned as complementary to tracing. Synthetic traces could be generated by monitoring scripts and would flow through the same collection pipeline, providing baseline performance measurements. |\n| **t-digest** | A probabilistic data structure for computing approximate percentiles from streaming data with high accuracy, especially in the tails of the distribution, using limited memory. | The algorithm used in `TDigestMetric` for **percentile calculation** in **Milestone 4**. t-digest allows us to maintain rolling percentiles across millions of spans without storing every individual latency value. |\n| **Tail-Based Sampling** | A sampling strategy where the decision to keep or drop a trace is made after the trace is complete (or nearly complete), allowing evaluation based on the full trace content (errors, latency, patterns). | Implemented by the `TailSampler` in **Milestone 3**. This approach can override head-based sampling decisions to retain \"interesting\" traces (e.g., those with errors or high latency) even if they were initially sampled out, but requires buffering traces until completion. |\n| **TextMapCarrier** | An interface for reading and writing trace context to arbitrary carrier formats (HTTP headers, gRPC metadata, message queue properties) during context propagation. | Used by the SDK's `InjectTraceContext` and `ExtractTraceContext` methods in **Milestone 5**. The carrier abstraction allows the same propagation logic to work across different transport protocols. |\n| **Time Series Database (TSDB)** | A database optimized for storing and retrieving time-stamped data, typically supporting efficient range queries and aggregations over time intervals. | Considered for storing aggregated metrics in **Milestone 4**. While our design uses an in-memory `MemoryStore` for simplicity, a production system might offload historical metrics to a dedicated TSDB like Prometheus or InfluxDB for long-term retention. |\n| **Time Window** | A fixed period (e.g., 1 minute, 5 minutes) over which metrics are aggregated or analyzed. Windows can be tumbling (non-overlapping) or sliding (overlapping). | Used throughout the system: for edge aggregation in service maps (`EdgeAggregator.windowSize`), for percentile calculations (`PercentileAggregator.window`), and for anomaly detection baselines. Windows balance temporal granularity with statistical significance. |\n| **Topology Change** | The addition, removal, or modification of service dependencies in the system, detected by comparing service graphs across time windows. | A key insight from the service map. The `DetectTopologyChanges` function compares current and previous `ServiceGraph` instances to identify new services, removed dependencies, or changed communication patterns, which can indicate deployments or issues. |\n| **Trace** | A collection of spans that represent a single request's path through a distributed system, sharing a common `TraceID`. Defined as the `Trace` struct with fields `TraceID`, `Spans`, `StartTime`, and `EndTime`. | The unit of analysis for debugging. While spans are collected individually, they are assembled into traces for visualization and analysis. A trace shows the complete lifecycle of a request, including parallel and sequential operations across services. |\n| **Unified Observability** | The practice of correlating traces, logs, and metrics for complete system understanding, allowing engineers to move seamlessly between signals during debugging. | A **Future Extension** vision. The `TraceWithContext` struct shows how trace data could be enriched with related logs and metrics, while the `UnifiedStorage` interface suggests a backend that stores all telemetry types. |\n| **W3C Trace Context** | A W3C standard specification for HTTP headers (`traceparent`, `tracestate`) that propagate trace context across service boundaries, ensuring interoperability between different tracing systems. | The propagation standard adopted by OpenTelemetry and implemented in our SDK. The `TRACE_ID_HEADER` and `SPAN_ID_HEADER` constants correspond to these standard headers, enabling traces to cross service boundaries even when services use different tracing implementations. |\n| **Watermark Algorithm** | An algorithm that marks a point in a data stream after which no earlier data is expected, used for handling out-of-order data in streaming systems. | Relevant for **trace assembly** in **Milestone 1**. Since spans arrive out-of-order, we need a heuristic to decide when we've received all spans for a trace (or enough to make a decision). A watermark based on span timestamps plus a max delay tolerance helps determine when to flush incomplete traces. |\n| **Wire Format** | The serialized representation of data (e.g., spans) for transmission over a network. Our system supports both OTLP/JSON and OTLP/Protobuf wire formats. | Defined by the OpenTelemetry specification. The `OTLPJSONRequest` and related types model the JSON structure, while `parseOTLPProtobuf` handles the binary protobuf format. Choosing a standard wire format ensures interoperability. |\n| **Write-Ahead Log (WAL)** | A durability mechanism where changes (incoming spans) are written to a sequential log file before being processed and acknowledged, allowing recovery after crashes. | Implemented by `WALWriter` and `WALReader` in **Milestone 1** as part of the buffering strategy. If the collector crashes before spans are processed, they can be replayed from the WAL, preventing data loss at the cost of increased I/O. |\n| **z-score** | A statistical measurement describing a value's relationship to the mean of a group of values, expressed in terms of standard deviations. Used to detect anomalies. | One method in the `Detector` for **anomaly detection** in **Milestone 4**. A latency value with a high absolute z-score (e.g., >3) is far from the historical mean and likely an anomaly, assuming the data is normally distributed. |\n\nThis glossary provides a shared vocabulary for discussing the APM Tracing System. When reviewing the design document, refer back to these definitions to ensure precise understanding of each concept's role and implementation.\n\n---\n"}