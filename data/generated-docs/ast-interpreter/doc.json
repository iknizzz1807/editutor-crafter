{"html":"<h1 id=\"ast-tree-walking-interpreter-design-document\">AST Tree-Walking Interpreter: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This document outlines the design of a tree-walking interpreter that directly executes code by traversing its Abstract Syntax Tree (AST). The key architectural challenge is managing the evaluation environment—a dynamic mapping of names to values—and correctly implementing lexical scoping, function calls, and closures within a simple, recursive evaluator framework.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section establishes the foundational concepts for the entire project, providing context and rationale that underpins all four milestones of the AST Tree-Walking Interpreter.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<p>The core challenge of building an interpreter is to bridge the gap between the <strong>static text</strong> of a source program and the <strong>dynamic behavior</strong> it is intended to produce. An interpreter must transform inert code into live computation, faithfully executing the programmer&#39;s intent—calculating values, managing changing state, and controlling the flow of execution. This document outlines the design of a <strong>tree-walking interpreter</strong>, a classic and pedagogically valuable architecture that directly evaluates a program by traversing its Abstract Syntax Tree (AST). The primary architectural challenge in this design is not merely processing syntax, but correctly modeling and managing the <strong>runtime environment</strong>—a dynamic, nested mapping of variable names to their values—which is the essence of how programs remember and manipulate state across different scopes and function calls. This section explains the problem space, introduces a foundational mental model, and contrasts our chosen approach with viable alternatives.</p>\n<h3 id=\"mental-model-the-math-homework-grader\">Mental Model: The Math Homework Grader</h3>\n<p>Imagine you are a teacher grading a complex arithmetic assignment. A student has written down an expression like <code>(5 + 3) * (10 - 2) / 4</code>. Your task is to compute the final answer. You don&#39;t just glance at it and guess; you follow a systematic, step-by-step process dictated by mathematical rules:</p>\n<ol>\n<li>You first locate and solve any sub-expressions inside parentheses: <code>(5 + 3)</code> becomes <code>8</code> and <code>(10 - 2)</code> becomes <code>8</code>.</li>\n<li>You then apply multiplication and division from left to right: <code>8 * 8</code> becomes <code>64</code>, then <code>64 / 4</code> becomes <code>16</code>.</li>\n<li>Throughout this process, you hold intermediate results in your working memory.</li>\n</ol>\n<p>Now, suppose the student&#39;s homework includes <strong>variables</strong>: &quot;Let <code>x = 5</code>. Calculate <code>x * (x + 2)</code>.&quot; Your process becomes more involved. You must first write down in a notebook—a <strong>ledger</strong>—that <code>x</code> is <code>5</code>. When you encounter the variable <code>x</code> in the expression, you pause your calculation, look up its current value in your ledger, and substitute it (<code>5 * (5 + 2)</code>). If the problem defines a new <code>x</code> inside a sub-problem, you might start a fresh page in your notebook for that sub-problem, knowing you can look back to previous pages if a variable isn&#39;t found locally.</p>\n<p>Finally, imagine the assignment includes <strong>procedures</strong>: &quot;To compute the area of a rectangle, use the formula: <code>length * width</code>.&quot; The student then writes <code>area(10, 3)</code>. As the grader, you now have a <strong>recipe</strong> (the formula) and specific <strong>ingredients</strong> (<code>10</code> and <code>3</code>). You create a new, temporary workspace, assign <code>length = 10</code> and <code>width = 3</code>, perform the multiplication, report the result <code>30</code>, and then discard that temporary workspace, returning to the main problem.</p>\n<p><strong>The tree-walking interpreter is this teacher.</strong> The <strong>AST</strong> is the structured, unambiguous representation of the student&#39;s homework. The <strong>evaluator</strong> is the step-by-step grading procedure, recursively descending into sub-expressions. The <strong>environment</strong> is the notebook of ledgers, tracking variable bindings across different scopes. This mental model captures the essence of interpretation: a meticulous, rule-governed walk through a tree of instructions, consulting and updating a memory of state along the way.</p>\n<h3 id=\"the-interpretation-problem\">The Interpretation Problem</h3>\n<p>Formally, the interpretation problem is: <strong>Given a string of source code, produce the corresponding runtime behavior.</strong> This involves several distinct sub-problems:</p>\n<ol>\n<li><p><strong>Structural Disambiguation:</strong> Source code is a linear sequence of characters. The interpreter must first resolve this into a hierarchical structure that explicitly represents nesting, precedence, and statement boundaries. This is the role of the <strong>parser</strong>, which produces the AST—a data structure our interpreter will walk. The AST is a static, immutable representation of the program&#39;s <em>syntax</em>.</p>\n</li>\n<li><p><strong>Semantic Evaluation:</strong> Each node in the AST corresponds to a language construct with defined <em>semantics</em> (meaning). A literal number <code>42</code> means the numeric value forty-two. A <code>+</code> operator means the mathematical addition of its two operand values. The interpreter must implement the semantics for every type of node. This is not a simple translation; it involves <strong>recursive computation</strong>. To evaluate <code>a + b</code>, you must first evaluate the subtrees for <code>a</code> and <code>b</code>. This recursive evaluation is the &quot;tree-walking&quot; process.</p>\n</li>\n<li><p><strong>State Management:</strong> The most complex aspect of interpretation is managing mutable, named state—<strong>variables</strong>. A program is not a pure function from input to output; it is a sequence of operations that read and write to memory. The interpreter must provide a mechanism to:</p>\n<ul>\n<li><strong>Bind</strong> a name to a value (<code>x = 10</code>).</li>\n<li><strong>Look up</strong> the value associated with a name when it is used (<code>print x + 1</code>).</li>\n<li><strong>Re-bind</strong> a name to a new value (<code>x = 20</code>).</li>\n<li><strong>Scope</strong> these bindings so that a variable defined inside a function does not leak out, and a variable defined outside a function is accessible within it (lexical scoping).</li>\n</ul>\n<p>This is the domain of the <strong>environment</strong>, a runtime data structure that exists alongside and is manipulated by the evaluator. The design of the environment—how it models nesting, lookup, and assignment—is critical to implementing correct language semantics.</p>\n</li>\n<li><p><strong>Control Flow Management:</strong> Programs are not linear. They branch with <code>if</code> statements, loop with <code>while</code> and <code>for</code>, and jump with <code>break</code>, <code>continue</code>, and <code>return</code>. The interpreter must orchestrate the order of evaluation, deciding which branch of the AST to walk down next based on computed conditions. This requires the evaluator to manage its own traversal path, not just compute values.</p>\n</li>\n<li><p><strong>Abstraction and Encapsulation:</strong> Functions allow programmers to define reusable blocks of code. Interpreting a function call involves suspending the current execution context, creating a new isolated environment for the function&#39;s parameters and local variables, executing the function body, obtaining a result, and then resuming the original context. Supporting <strong>closures</strong>—where a function &quot;remembers&quot; the environment in which it was created—adds another layer of complexity to environment management.</p>\n</li>\n</ol>\n<p>The tree-walking interpreter tackles these sub-problems in a direct, intuitive way: write a recursive function that takes an AST node and an environment, and contains a large <code>switch</code> statement (or equivalent) to handle each node type. This approach shines in its conceptual clarity and closeness to the language specification, making it an ideal vehicle for learning. However, it is not the only architectural option, and its trade-offs must be understood.</p>\n<h3 id=\"existing-approaches-and-trade-offs\">Existing Approaches and Trade-offs</h3>\n<p>When building an interpreter, the primary architectural decision is the choice of <strong>intermediate representation (IR)</strong>—the data structure that drives execution. The two most common patterns are the <strong>Abstract Syntax Tree (AST) Walker</strong>, which we have chosen, and the <strong>Bytecode Virtual Machine (VM)</strong>. A third, more advanced approach is <strong>Just-In-Time (JIT) Compilation</strong> to native machine code. The following table compares these approaches across dimensions critical to our learning project: implementation complexity, runtime performance, educational value, and flexibility.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Approach</th>\n<th align=\"left\">Core Idea</th>\n<th align=\"left\">How Execution Works</th>\n<th align=\"left\">Key Data Structures</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>AST Tree-Walker</strong></td>\n<td align=\"left\">Directly interpret the parse tree.</td>\n<td align=\"left\">A recursive function traverses the AST, evaluating nodes in post-order.</td>\n<td align=\"left\">AST node hierarchy, Environment chain (stack of dictionaries).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Bytecode VM</strong></td>\n<td align=\"left\">Compile the AST to a linear sequence of dense, simple instructions (bytecode).</td>\n<td align=\"left\">A virtual CPU (interpreter loop) fetches and executes bytecode instructions, operating on a stack.</td>\n<td align=\"left\">Bytecode array, Value stack, Constant pool, Frame stack.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>JIT Compiler</strong></td>\n<td align=\"left\">Dynamically compile &quot;hot&quot; code paths to optimized native machine code.</td>\n<td align=\"left\">A runtime profiling system identifies hot loops/functions, a compiler generates machine code, and execution jumps to it.</td>\n<td align=\"left\">Intermediate Representation (IR), Native code cache, Runtime profiling data.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Use an AST Tree-Walking Interpreter Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: We are building an interpreter for an educational project with the primary goals of understanding core language implementation concepts (evaluation, environments, scoping, closures) and achieving a working system within an intermediate-level time frame.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>AST Tree-Walker</strong>: Implement a recursive <code>evaluate</code> function that dispatches on AST node types.</li>\n<li><strong>Bytecode Virtual Machine</strong>: Build a compiler from AST to a custom bytecode, then implement a stack-based VM to run it.</li>\n<li><strong>JIT Compilation (Theoretical)</strong>: Use a library like LLVM to generate native code on the fly.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We will implement an AST Tree-Walking Interpreter.</li>\n<li><strong>Rationale</strong>:<ol>\n<li><strong>Conceptual Transparency</strong>: The evaluator&#39;s logic maps directly to the language grammar. Seeing <code>evaluateIfStatement</code> handle an <code>If</code> node makes the connection between syntax and semantics obvious. There is no intermediate transformation to learn.</li>\n<li><strong>Lower Initial Complexity</strong>: A tree-walker can be built incrementally, feature by feature. Adding a new expression type often just means adding a new branch to the <code>evaluate</code> function. A VM requires designing an instruction set, a compiler, and the VM itself before any code runs.</li>\n<li><strong>Focus on Language Semantics, Not Optimization</strong>: Our goal is to learn about scoping, closures, and evaluation—not about bytecode design or register allocation. The tree-walker keeps the focus on these high-level semantics.</li>\n<li><strong>Sufficient Performance for Learning</strong>: While slower, a tree-walker&#39;s performance is adequate for running the small to medium-sized test programs typical in a learning project. The performance bottleneck is not a primary educational concern.</li>\n</ol>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: We will have a clear, debuggable system where the runtime stack mirrors the AST structure. Stepping through the recursive evaluator with a debugger is an excellent learning tool.</li>\n<li><strong>Negative</strong>: The interpreter will be slower than a bytecode VM, especially for loop-heavy code, due to the overhead of tree traversal and repeated dispatch. It is not suitable for production performance needs.</li>\n<li><strong>Neutral</strong>: The design naturally supports dynamic features and metaprogramming but may require more careful design for complex control flow (e.g., <code>break</code>/<code>continue</code>).</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The trade-offs between these approaches are summarized below:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Approach</th>\n<th align=\"left\">Pros (Why choose it?)</th>\n<th align=\"left\">Cons (Why avoid it?)</th>\n<th align=\"left\">Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>AST Tree-Walker</strong></td>\n<td align=\"left\"><ul><li><strong>Simple to implement and understand.</strong> The code is a direct translation of language semantics.</li><li><strong>Fast to prototype.</strong> New language features can be added with minimal boilerplate.</li><li><strong>Excellent for education.</strong> The runtime structure (AST, environment chain) is visible and tangible.</li><li><strong>No separate compilation phase.</strong> Execution begins immediately after parsing.</li></ul></td>\n<td align=\"left\"><ul><li><strong>Slow execution.</strong> High overhead per operation due to tree traversal, recursion, and type dispatch.</li><li><strong>Poor cache locality.</strong> AST nodes are typically heap-allocated objects scattered in memory.</li><li><strong>Hard to optimize.</strong> Difficult to apply low-level optimizations common in VMs (e.g., stack-based operations, JIT).</li></ul></td>\n<td align=\"left\"><strong>Learning projects, prototyping, scripting languages where simplicity is valued over raw speed (e.g., early versions of Ruby, PHP).</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Bytecode VM</strong></td>\n<td align=\"left\"><ul><li><strong>Much faster execution.</strong> Bytecode is dense, linear, and easy to cache; the interpreter loop is tight and efficient.</li><li><strong>Easier to optimize.</strong> Enables classic compiler optimizations on bytecode and efficient stack-based operand management.</li><li><strong>Clear separation of concerns.</strong> Compiler front-end (parsing, AST) is distinct from back-end (code gen, execution).</li><li><strong>Foundation for JIT.</strong> Bytecode is a natural input for a JIT compiler.</li></ul></td>\n<td align=\"left\"><ul><li><strong>Higher complexity.</strong> Requires designing an instruction set and building both a compiler <em>and</em> a VM.</li><li><strong>Indirect mapping.</strong> The relationship between source code and bytecode is less obvious for debugging.</li><li><strong>Slower startup.</strong> Requires a full compilation pass before any code runs.</li></ul></td>\n<td align=\"left\"><strong>Production interpreters (e.g., CPython, Lua, the Java VM), where performance is critical.</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>JIT Compilation</strong></td>\n<td align=\"left\"><ul><li><strong>Highest performance.</strong> Executes native machine code, can rival or exceed static compilation for dynamic languages.</li><li><strong>Advanced optimizations.</strong> Can perform runtime profiling and specialization (e.g., type-specialized code, inlining).</li></ul></td>\n<td align=\"left\"><ul><li><strong>Extreme complexity.</strong> Requires deep knowledge of compiler backends, instruction selection, and runtime systems.</li><li><strong>Large memory overhead.</strong> Maintaining profiling data and multiple code versions consumes memory.</li><li><strong>&quot;Warm-up&quot; time.</strong> Peak performance is only achieved after repeated execution of code paths.</li></ul></td>\n<td align=\"left\"><strong>High-performance runtimes (e.g., JavaScript V8, Java HotSpot, PyPy) where execution speed is paramount.</strong></td>\n</tr>\n</tbody></table>\n<p>Given our project&#39;s goals—<strong>learning</strong> the fundamentals of interpreters, <strong>completing</strong> a working system at an intermediate difficulty level, and <strong>understanding</strong> environments and closures—the AST tree-walking approach offers the optimal balance of pedagogical value and implementability. It allows us to focus on the core challenge: managing dynamic runtime state through the environment model, which is elegantly visualized in the system component diagram.</p>\n<p><img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fsys-component.svg\" alt=\"System Component Diagram\"></p>\n<p>As shown, the <strong>Evaluator</strong> component is the heart of the system. It reads the static program structure from the <strong>AST</strong> and interacts with the dynamic <strong>Environment Chain</strong> to read and update variable state. This clear separation of concerns—syntax, evaluation logic, and runtime state—forms the backbone of our design. The subsequent sections will delve into the detailed design of each component, starting with the data model for runtime values and environments.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 2, 3, 4</p>\n</blockquote>\n<p>This section establishes the explicit boundaries of the interpreter project. A clearly defined scope prevents feature creep and ensures focused effort on the core learning objectives: understanding tree-walking evaluation, lexical scoping, and function execution. We delineate what the interpreter <strong>must</strong> do to be considered complete versus what it <strong>explicitly will not</strong> implement, even if such features are common in production languages.</p>\n<h3 id=\"goals-what-we-must-implement\">Goals (What we must implement)</h3>\n<p>The interpreter&#39;s primary purpose is pedagogical—to provide a hands-on understanding of language implementation fundamentals through a complete, working example. The following capabilities represent the minimum feature set required to demonstrate the core concepts.</p>\n<blockquote>\n<p><strong>Design Principle: Completeness over Complexity</strong>\nThe interpreter should implement a <em>coherent subset</em> of language features that interact meaningfully, rather than many shallow features. Each implemented feature must correctly integrate with the evaluation model, scoping rules, and control flow.</p>\n</blockquote>\n<ol>\n<li><p><strong>Expression Evaluation</strong>\nThe interpreter must evaluate all basic expressions, forming the foundation for every computation. This includes:</p>\n<ul>\n<li><strong>Literal values</strong>: Direct evaluation of numbers (integers and floats), strings, booleans (<code>true</code>, <code>false</code>), and the <code>nil</code> value representing absence.</li>\n<li><strong>Arithmetic operations</strong>: Binary operators for addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), and division (<code>/</code>), with proper operator precedence and support for unary negation (<code>-</code>).</li>\n<li><strong>Comparison and equality</strong>: Operators for relative comparison (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) and equality (<code>==</code>, <code>!=</code>), returning boolean results.</li>\n<li><strong>Logical operators</strong>: Support for <code>and</code> and <code>or</code> with <strong>short-circuit evaluation</strong>, where the right operand is only evaluated if the left operand doesn&#39;t determine the result.</li>\n<li><strong>Grouping</strong>: Parentheses <code>()</code> must override default precedence, requiring correct handling of nested expression trees.</li>\n</ul>\n</li>\n<li><p><strong>Variables and Lexical Scoping</strong>\nThe interpreter must support named storage locations whose visibility follows <strong>lexical (static) scoping</strong> rules.</p>\n<ul>\n<li><strong>Variable declaration</strong>: A statement (e.g., <code>var x = 5;</code>) that introduces a new name into the current scope, binding it to an initial value.</li>\n<li><strong>Variable assignment</strong>: An expression (e.g., <code>x = 10;</code>) that updates the value of an existing variable, searching outward through enclosing scopes.</li>\n<li><strong>Variable lookup</strong>: Reading a variable&#39;s value by its name, resolving it by searching the current environment, then its parent, recursively.</li>\n<li><strong>Nested block scopes</strong>: Code blocks (e.g., inside <code>{ }</code>) create new nested scopes. Variables declared inside a block shadow outer ones and are inaccessible after the block exits.</li>\n</ul>\n</li>\n<li><p><strong>Control Flow</strong>\nThe interpreter must direct the path of execution based on conditions and loops.</p>\n<ul>\n<li><strong>Conditional execution</strong>: An <code>if</code> statement that evaluates a condition and executes one branch or another. An <code>else</code> clause must be optional.</li>\n<li><strong>Looping constructs</strong>:<ul>\n<li><code>while</code> loops that repeatedly execute a body while a condition remains truthy.</li>\n<li><code>for</code> loops (converted/desugared into <code>while</code> loops) with an initializer, condition, and increment expression.</li>\n</ul>\n</li>\n<li><strong>Loop control</strong>: <code>break</code> to exit the nearest enclosing loop immediately, and <code>continue</code> to skip to the next iteration.</li>\n<li><strong>Truthiness</strong>: A consistent rule set for determining if a non-boolean value (like <code>0</code>, <code>&quot;&quot;</code>, or <code>nil</code>) counts as <code>true</code> or <code>false</code> in conditional contexts.</li>\n</ul>\n</li>\n<li><p><strong>First-Class Functions and Closures</strong>\nFunctions must be <strong>first-class values</strong> that can be stored, passed, and returned, with proper support for <strong>lexical closures</strong>.</p>\n<ul>\n<li><strong>Function definition</strong>: A declaration (e.g., <code>fun add(a, b) { return a + b; }</code>) that creates a function object and binds it to a name.</li>\n<li><strong>Function calls</strong>: Invocation syntax (e.g., <code>add(1, 2)</code>) that evaluates arguments, creates a new local environment for parameters, and executes the body.</li>\n<li><strong>Return mechanism</strong>: A <code>return</code> statement that terminates function execution and provides a value back to the caller, even from nested blocks.</li>\n<li><strong>Closure capture</strong>: When a function is defined, it must capture a reference to its <em>defining</em> environment, allowing it to access variables from outer scopes even after those scopes have exited.</li>\n<li><strong>Recursion</strong>: Functions must be able to call themselves by name, requiring the function&#39;s name to be bound in its own local environment.</li>\n</ul>\n</li>\n</ol>\n<p>The successful implementation of these four pillars creates a Turing-complete, dynamically-typed language with lexical scope—a significant and educationally complete achievement.</p>\n<h3 id=\"non-goals-what-we-explicitly-omit\">Non-Goals (What we explicitly omit)</h3>\n<p>To maintain focus on the core learning objectives and avoid project sprawl, we deliberately exclude several common language features and implementation optimizations. These are valuable topics but belong to more advanced study.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Feature Category</th>\n<th align=\"left\">Specific Omissions</th>\n<th align=\"left\">Rationale for Exclusion</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Memory Management</strong></td>\n<td align=\"left\">Automatic garbage collection, reference counting.</td>\n<td align=\"left\">Adds significant complexity (tracing, cycle detection) and is orthogonal to the evaluation model. The interpreter can rely on the host language&#39;s garbage collector for its own data structures.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Modularity</strong></td>\n<td align=\"left\">Modules, imports, separate compilation units, <code>include</code> statements.</td>\n<td align=\"left\">Introduces file I/O, dependency resolution, and global namespace management. The interpreter evaluates a single program text.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Object-Oriented Programming</strong></td>\n<td align=\"left\">Classes, inheritance, prototypes, <code>this</code>/<code>self</code> context, methods.</td>\n<td align=\"left\">Represents a major paradigm with distinct dispatch semantics (late binding, inheritance chains) that would double the project&#39;s scope.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Advanced Types</strong></td>\n<td align=\"left\">Static type checking, user-defined types, type annotations, generics.</td>\n<td align=\"left\">The interpreter is dynamically typed for simplicity. Type systems are a deep, separate subject area.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Optimization</strong></td>\n<td align=\"left\">Just-In-Time (JIT) compilation, tail-call optimization (TCO), bytecode compilation, constant folding.</td>\n<td align=\"left\">These are performance optimizations that obscure the clear tree-walking algorithm. The goal is clarity of semantics, not speed.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Standard Library</strong></td>\n<td align=\"left\">Built-in functions for I/O (print, read), mathematics (sin, sqrt), data structures (arrays, maps), system interaction.</td>\n<td align=\"left\">While useful, a standard library is a large addition. A single <code>print</code> statement may be added for debugging, but extensive libraries are out of scope.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Error Recovery &amp; Debugging</strong></td>\n<td align=\"left\">Stack traces, line number reporting in errors, debugger integration, REPL history.</td>\n<td align=\"left\">Basic error detection (e.g., &quot;Undefined variable &#39;x&#39;&quot;) is required, but sophisticated tooling is a project in itself.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Concurrency</strong></td>\n<td align=\"left\">Threads, async/await, promises, coroutines, parallelism.</td>\n<td align=\"left\">Concurrency introduces entirely new dimensions of complexity (race conditions, schedulers) far beyond the sequential evaluation model.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Syntax Sugar</strong></td>\n<td align=\"left\">Increment/decrement operators (<code>++</code>, <code>--</code>), assignment operators (<code>+=</code>, <code>-=</code>), ternary operator (<code>?:</code>), switch statements.</td>\n<td align=\"left\">These can be desugared into existing constructs and do not introduce new semantic concepts.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Metaprogramming</strong></td>\n<td align=\"left\">Macros, reflection, eval at runtime.</td>\n<td align=\"left\">These features fundamentally change the evaluation model (code-as-data) and require a more sophisticated interpreter architecture.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architectural Decision: Focused Pedagogical Scope</strong>\n<strong>Context</strong>: The project aims to teach core interpreter concepts within a limited timeframe. Every additional feature increases implementation complexity and cognitive load for the learner.\n<strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Minimal Core</strong>: Implement only the essential features listed in Goals.</li>\n<li><strong>Expressive Language</strong>: Add commonly requested features like arrays, a basic standard library, and classes.</li>\n<li><strong>Extensible Framework</strong>: Build a minimal core with plug-in points for optional features.\n<strong>Decision</strong>: Adopt the <strong>Minimal Core</strong> approach.\n<strong>Rationale</strong>: The primary success criterion is a deep understanding of tree-walking evaluation, environments, and closures. A minimal, complete implementation achieves this without distraction. Additional features can be built as separate, advanced projects once fundamentals are mastered.\n<strong>Consequences</strong>: The interpreter will feel &quot;spartan&quot; compared to production languages, but it will be fully functional for algorithms, recursion, and closure-based abstraction. Learners can confidently extend it later using the same architectural patterns.</li>\n</ol>\n</blockquote>\n<p>This explicit list of non-goals serves as a guardrail. When encountering a potential feature not listed above (e.g., &quot;should we add arrays?&quot;), the answer is &quot;not in this version.&quot; The design document&#39;s subsequent sections assume this bounded scope.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<p>For this project, the technology stack is intentionally simple, focusing on the host language&#39;s standard data structures and control flow.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Recommended)</th>\n<th align=\"left\">Advanced Option (Optional)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Runtime Value Representation</strong></td>\n<td align=\"left\">Built-in Python/JS/Java types (<code>int</code>, <code>str</code>, <code>bool</code>, <code>None</code>/<code>null</code>).</td>\n<td align=\"left\">Custom <code>Value</code> class hierarchy with explicit type tags.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Environment Storage</strong></td>\n<td align=\"left\">Dictionary/HashMap for the store, with a parent reference.</td>\n<td align=\"left\">Persistent data structures for environment snapshots (useful for advanced debugging).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Control Flow Jump (break/continue/return)</strong></td>\n<td align=\"left\">Python exceptions, JS <code>throw</code> with custom error types, Java custom exceptions.</td>\n<td align=\"left\">Explicit <code>Result</code> object returned from every evaluation, carrying a value or jump signal.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Function Representation</strong></td>\n<td align=\"left\">Plain class/object storing parameters, body AST, and closure environment.</td>\n<td align=\"left\">Compiling to host-language closures (advanced, blends semantics).</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<p>Organizing code into logical modules improves readability and mirrors the separation of concerns in the design.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>treewalk_interpreter/\n├── ast.py               # AST node class definitions (from previous parser milestone)\n├── evaluator.py         # Core Evaluator class (handles expression/statement evaluation)\n├── environment.py       # Environment class (variable storage and scoping)\n├── runtime_values.py    # Runtime value definitions (Function, maybe built-in callables)\n├── errors.py            # Custom runtime error types (RuntimeError, UndefinedVariable, etc.)\n├── interpreter.py       # Main entry point: parses source and runs evaluator\n└── test_interpreter.py  # Comprehensive test suite</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-runtime-error-types\">Infrastructure Starter Code: Runtime Error Types</h4>\n<p>Proper error handling is crucial for debugging. These custom exception classes provide clear, actionable error messages.</p>\n<p><strong>File: <code>errors.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Custom runtime error types for the tree-walking interpreter.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">All errors include the token (or line number) for context.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all runtime errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, token</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.token:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"[line </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.token.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">] RuntimeError: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"RuntimeError: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UndefinedVariableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when trying to access a variable that is not defined.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, variable_name, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Undefined variable '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">variable_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'.\"</span><span style=\"color:#E1E4E8\">, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when an operation is applied to an incompatible type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DivisionByZeroError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised on division by zero.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Division by zero.\"</span><span style=\"color:#E1E4E8\">, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArgumentError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised on function call argument mismatch.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected, got, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments but got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">got</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.\"</span><span style=\"color:#E1E4E8\">, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ControlFlowSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Base for non-local jumps (break, continue, return).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    These are caught by loop/function evaluators.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreakSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a 'break' statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ContinueSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a 'continue' statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ReturnSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a 'return' statement. Carries the return value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-main-interpreter-entry-point\">Core Logic Skeleton: Main Interpreter Entry Point</h4>\n<p>The main entry point ties together the parser (from a previous milestone) and the evaluator.</p>\n<p><strong>File: <code>interpreter.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Main interpreter entry point.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Assumes an existing parser that produces an AST from source code.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ast </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Program  </span><span style=\"color:#6A737D\"># Assume this is the root AST node from parser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> evaluator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Evaluator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> RuntimeError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.evaluator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Evaluator()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.global_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment()  </span><span style=\"color:#6A737D\"># The outermost environment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> interpret</span><span style=\"color:#E1E4E8\">(self, source_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse and execute the given source code.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Parse source_code into an AST (using existing parser).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Evaluate the AST with the global environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Print any result (if the program is an expression).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Catch and report runtime errors.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call your existing parser to convert source_code to an AST.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   The parser should return a Program node (or a list of statements).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   For now, we assume `parse(source_code)` exists.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Example: ast_root = parse(source_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ast_root </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Placeholder</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Evaluate the program AST starting from the global environment.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   The evaluator's evaluate method should be called on the root node.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.evaluator.evaluate(ast_root, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.global_env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If the result is not None (i.e., the program was an expression),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   print it for user visibility, mimicking a REPL.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._stringify(result))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Report runtime errors to the user with line information.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(e, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Optionally, set an error flag or exit code.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _stringify</span><span style=\"color:#E1E4E8\">(self, value) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert a runtime value to a readable string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"nil\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(value, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(value).lower()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(value, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Show integer values without decimal if possible</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            text </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> text.endswith(</span><span style=\"color:#9ECBFF\">'.0'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text[:</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For strings, numbers, etc.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> \"__main__\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Simple REPL or file execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Interpreter()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(sys.argv) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # REPL mode</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Tree-walking interpreter (exit with Ctrl+D)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                line </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> input</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"> \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                interpreter.interpret(line)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> EOFError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Goodbye!\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> KeyboardInterrupt</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Interrupted.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # File mode: read and execute the entire file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(sys.argv[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            source </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> f.read()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        success </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> interpreter.interpret(source)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sys.exit(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> success </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li><strong>Python</strong>: Use <code>isinstance()</code> for runtime type checks. Be careful with <code>None</code> (use <code>is</code>/<code>is not</code> for identity). The <code>math.isclose()</code> function is better for floating-point equality than <code>==</code>.</li>\n<li><strong>JavaScript</strong>: Use <code>===</code> for equality to avoid type coercion. <code>undefined</code> can serve as <code>nil</code>. Use <code>Map</code> or plain objects for environment stores.</li>\n<li><strong>Java</strong>: Define an abstract <code>Value</code> class or use <code>Object</code> references with careful casting. Use <code>HashMap&lt;String, Object&gt;</code> for environment stores.</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After reading this section, before writing any code, you should be able to articulate the exact boundaries of your project.</p>\n<p><strong>Verification Questions:</strong></p>\n<ol>\n<li>Will your interpreter support <code>for</code> loops? (Yes, as a desugared form)</li>\n<li>Will your interpreter support arrays and hash maps? (No, non-goal)</li>\n<li>Will your interpreter automatically free unused memory? (No, relies on host GC)</li>\n<li>Will your interpreter support defining functions inside other functions? (Yes, and they must correctly capture closures)</li>\n</ol>\n<p>A correct understanding of these boundaries will guide all subsequent implementation decisions.</p>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<p>Early mis-scoping is a common source of subtle bugs.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom</th>\n<th align=\"left\">Likely Cause</th>\n<th align=\"left\">How to Diagnose</th>\n<th align=\"left\">Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Variable is <code>nil</code> when it should have a value.</td>\n<td align=\"left\">Variable was declared in an inner scope and is not visible where accessed.</td>\n<td align=\"left\">Print the environment chain during lookup. Check if the variable&#39;s name exists in any parent environment.</td>\n<td align=\"left\">Ensure variable is declared in a scope that encloses all usage points.</td>\n</tr>\n<tr>\n<td align=\"left\">Changing a variable inside a function doesn&#39;t affect the outer variable.</td>\n<td align=\"left\">Assignment is creating a new local binding instead of updating the outer one.</td>\n<td align=\"left\">Trace the <code>assign</code> method in the environment. Is it walking the parent chain?</td>\n<td align=\"left\">Implement assignment to search through the environment chain, not just the current environment.</td>\n</tr>\n<tr>\n<td align=\"left\">Function cannot access variables from its defining scope.</td>\n<td align=\"left\">Closure environment was not captured or is incorrectly set as parent.</td>\n<td align=\"left\">Print the function&#39;s closure environment when created and when called.</td>\n<td align=\"left\">Store the <em>defining</em> environment as the function&#39;s closure, not the global environment.</td>\n</tr>\n</tbody></table>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 2, 3, 4<br>This section provides the architectural blueprint for the entire interpreter system. Understanding this component breakdown and data flow is essential before diving into implementation details for any specific milestone.</p>\n</blockquote>\n<p>The AST tree-walking interpreter follows a classic three-tier architecture that cleanly separates static program structure from dynamic runtime execution. This design enables straightforward implementation of lexical scoping, function calls, and control flow while maintaining conceptual clarity—critical for an educational project. The architecture centers on three core components that interact through well-defined interfaces.</p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>Think of the interpreter as a <strong>theater production</strong>:</p>\n<ul>\n<li>The <strong>AST Nodes</strong> are the script—a static, structured document containing all the dialogue and stage directions</li>\n<li>The <strong>Evaluator</strong> is the director—reading the script and instructing actors on what to do next</li>\n<li>The <strong>Environment Chain</strong> is the stage with multiple backdrops—each scene (scope) has its own props (variables), and actors can look for props on the current stage or behind it in previous scenes</li>\n</ul>\n<p>This metaphor captures the essence: the script doesn&#39;t change during performance (AST is immutable), the director follows the script step-by-step (recursive evaluation), and the stage setup evolves as scenes change (environments track runtime state).</p>\n<p>The three architectural pillars are:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Primary Responsibility</th>\n<th>Key Data Structures</th>\n<th>Statefulness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>AST (Abstract Syntax Tree)</strong></td>\n<td>Represents the program&#39;s syntactic structure as a hierarchy of nodes</td>\n<td><code>LiteralNode</code>, <code>BinaryNode</code>, <code>VariableNode</code>, <code>IfNode</code>, <code>FunctionNode</code>, etc.</td>\n<td>Immutable (parsed once, never modified)</td>\n</tr>\n<tr>\n<td><strong>Evaluator</strong></td>\n<td>Recursively traverses AST nodes, executing their semantics</td>\n<td><code>evaluate()</code> function with node-type dispatch logic, maintains current execution context</td>\n<td>Stateless per call (receives environment as parameter)</td>\n</tr>\n<tr>\n<td><strong>Environment Chain</strong></td>\n<td>Manages variable storage with lexical scoping via parent links</td>\n<td><code>Environment</code> objects with <code>store</code> dictionary and <code>parent</code> reference</td>\n<td>Mutable (bindings change during execution)</td>\n</tr>\n</tbody></table>\n<p>These components interact in a specific data flow pattern: the Evaluator reads instructions from the AST and reads/writes variable state from/to the current Environment. Environments themselves form a linked chain that mirrors the program&#39;s lexical structure. </p>\n<p><img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fsys-component.svg\" alt=\"System Component Diagram\"></p>\n<h4 id=\"ast-the-static-blueprint\">AST: The Static Blueprint</h4>\n<p>The AST serves as the interpreter&#39;s immutable source of truth about program structure. Each node type encapsulates a specific language construct with fields representing its components:</p>\n<table>\n<thead>\n<tr>\n<th>AST Node Category</th>\n<th>Example Node Types</th>\n<th>Key Fields (per node type)</th>\n<th>Runtime Semantics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Expressions (produce values)</td>\n<td><code>LiteralNode</code>, <code>BinaryNode</code>, <code>UnaryNode</code>, <code>VariableNode</code>, <code>CallNode</code></td>\n<td><code>value</code> (for literals), <code>left</code>/<code>right</code> (for binary), <code>operator</code>, <code>operand</code></td>\n<td>Evaluate to a runtime value</td>\n</tr>\n<tr>\n<td>Statements (produce effects)</td>\n<td><code>ExpressionStmtNode</code>, <code>VarDeclNode</code>, <code>BlockNode</code>, <code>IfNode</code>, <code>WhileNode</code></td>\n<td><code>expression</code>, <code>identifier</code>, <code>body</code>, <code>condition</code>, <code>thenBranch</code>/<code>elseBranch</code></td>\n<td>Execute side effects, control flow</td>\n</tr>\n<tr>\n<td>Declarations</td>\n<td><code>FunctionDeclNode</code></td>\n<td><code>name</code>, <code>parameters</code>, <code>body</code></td>\n<td>Create bindings in environment</td>\n</tr>\n</tbody></table>\n<p>The AST is generated once by the parser and remains unchanged throughout execution. This immutability is crucial—it means the same AST can be evaluated multiple times with different environments (as in function calls) without interference.</p>\n<h4 id=\"evaluator-the-recursive-director\">Evaluator: The Recursive Director</h4>\n<p>The Evaluator implements the tree-walking algorithm—a depth-first, recursive traversal of the AST that executes operations in the correct order. Its core design follows the <strong>Interpreter Pattern</strong> from design patterns literature, where each AST node type has a corresponding evaluation method. The Evaluator maintains no persistent state of its own; instead, it receives the current <code>Environment</code> as a parameter and returns runtime values or control flow signals.</p>\n<p>The Evaluator&#39;s key characteristic is <strong>single-threaded, synchronous execution</strong>—it processes one node at a time, completely finishing its evaluation before moving to siblings. This simplifies reasoning about program behavior but imposes the performance limitations typical of tree-walkers.</p>\n<h4 id=\"environment-chain-the-layered-storage\">Environment Chain: The Layered Storage</h4>\n<p>The Environment system implements lexical (static) scoping through a chain of binding tables. Each <code>Environment</code> represents one scope level (global, function, block) and links to its parent scope. This creates a dynamic runtime structure that mirrors the program&#39;s static nesting:</p>\n<table>\n<thead>\n<tr>\n<th>Scope Type</th>\n<th>Created When</th>\n<th>Parent Environment</th>\n<th>Typical Lifespan</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Global</td>\n<td>Interpreter initialization</td>\n<td><code>None</code> (end of chain)</td>\n<td>Entire program execution</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>Function call</td>\n<td>The closure environment (where function was defined)</td>\n<td>Duration of function call</td>\n</tr>\n<tr>\n<td>Block</td>\n<td>Entering <code>{}</code> blocks, control flow bodies</td>\n<td>The enclosing environment</td>\n<td>Duration of block execution</td>\n</tr>\n</tbody></table>\n<p>The chain structure enables variable lookup to follow lexical rules: search starts in the current environment and proceeds up the parent chain until the variable is found or the global scope is reached. This design naturally supports variable shadowing—inner scopes can redefine names that hide outer definitions.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> The separation between immutable AST and mutable Environments is what enables powerful language features like recursion and closures. Multiple function calls create new Environments but share the same function body AST, allowing efficient reuse of code structure while maintaining independent variable instances.</p>\n</blockquote>\n<h3 id=\"execution-flow\">Execution Flow</h3>\n<p>The interpreter follows a linear pipeline from source code to execution result. Understanding this flow clarifies how components hand off responsibilities at each stage:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>flowchart TD\n    A[Source Code String] --&gt; B[Parser]\n    B --&gt; C[AST Root Node]\n    C --&gt; D[Interpreter.interpret]\n    D --&gt; E[Create Global Environment]\n    E --&gt; F[Evaluator.evaluate&lt;br/&gt;root, global_env]\n    F --&gt; G{Node Type?}\n    G --&gt; H[Expression]\n    G --&gt; I[Statement]\n    H --&gt; J[Return Runtime Value]\n    I --&gt; K[Execute Side Effects]\n    J --&gt; L[Final Result]\n    K --&gt; L</code></pre></div>\n\n<h4 id=\"step-by-step-processing-pipeline\">Step-by-Step Processing Pipeline</h4>\n<ol>\n<li><p><strong>Source Input</strong></p>\n<ul>\n<li>The interpreter receives a string containing program source code</li>\n<li>Example: <code>&quot;var x = 5; print x + 3;&quot;</code></li>\n</ul>\n</li>\n<li><p><strong>Parsing Phase</strong> (outside interpreter proper but prerequisite)</p>\n<ul>\n<li>The parser (lexer + syntax analyzer) converts the source string into an AST</li>\n<li>Syntax validation occurs here—malformed programs fail before evaluation begins</li>\n<li>The parser produces a root node (typically a <code>ProgramNode</code> containing statement list)</li>\n</ul>\n</li>\n<li><p><strong>Initialization</strong></p>\n<ul>\n<li>The <code>Interpreter</code> class creates the initial <code>global_env</code> (empty Environment with no parent)</li>\n<li>Any built-in functions (like <code>print</code>, <code>clock</code>) are defined in this global environment</li>\n</ul>\n</li>\n<li><p><strong>Evaluation Dispatch</strong></p>\n<ul>\n<li>The interpreter calls <code>evaluate(root_node, global_env)</code> to begin execution</li>\n<li>The Evaluator examines the node type and dispatches to the appropriate handler method</li>\n</ul>\n</li>\n<li><p><strong>Recursive Tree Traversal</strong></p>\n<ul>\n<li>For each node, the Evaluator recursively evaluates child nodes as needed</li>\n<li>Expression evaluation flows upward: leaves (literals/variables) → internal nodes → root</li>\n<li>Statement execution proceeds sequentially with potential jumps (loops, returns)</li>\n</ul>\n</li>\n<li><p><strong>Environment Interaction</strong></p>\n<ul>\n<li>Variable lookups: <code>evaluate(VariableNode)</code> calls <code>environment.get(name)</code></li>\n<li>Assignments: <code>evaluate(AssignNode)</code> calls <code>environment.assign(name, value)</code></li>\n<li>New scopes: Block execution creates a child Environment with current as parent</li>\n</ul>\n</li>\n<li><p><strong>Result Propagation</strong></p>\n<ul>\n<li>Expression evaluation returns a runtime value to its parent node</li>\n<li>Statement evaluation typically returns <code>None</code> (except return statements)</li>\n<li>The final value of the program is the value of the last expression evaluated</li>\n</ul>\n</li>\n<li><p><strong>Error Handling</strong></p>\n<ul>\n<li>Runtime errors (type mismatches, undefined variables) halt evaluation</li>\n<li>The interpreter reports the error with location information from the AST node&#39;s token</li>\n<li>No recovery attempted—program execution stops</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"phase-separation-parse-vs-evaluate\">Phase Separation: Parse vs. Evaluate</h4>\n<p>A critical architectural decision is maintaining strict separation between parsing and evaluation phases:</p>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Input</th>\n<th>Output</th>\n<th>Error Types</th>\n<th>When Occur</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Parsing</strong></td>\n<td>Source code string</td>\n<td>AST nodes</td>\n<td>Syntax errors, parse errors</td>\n<td>Before any execution</td>\n</tr>\n<tr>\n<td><strong>Evaluation</strong></td>\n<td>AST nodes + Environment</td>\n<td>Runtime values + side effects</td>\n<td>Runtime errors, type errors</td>\n<td>During program execution</td>\n</tr>\n</tbody></table>\n<p>This separation provides several benefits:</p>\n<ul>\n<li><strong>Single parse, multiple executions</strong>: The AST can be evaluated repeatedly (useful for REPLs or loops)</li>\n<li><strong>Clear error categorization</strong>: Users get distinct feedback for syntax vs. logic errors</li>\n<li><strong>Testing simplicity</strong>: ASTs can be constructed programmatically for unit tests</li>\n<li><strong>Potential optimization</strong>: The AST could be optimized/transformed before evaluation</li>\n</ul>\n<blockquote>\n<p><strong>Design Principle:</strong> The interpreter follows a &quot;parse completely, then execute&quot; model rather than &quot;parse and execute interleaved.&quot; This ensures all syntax errors are caught before any code runs, providing better developer experience.</p>\n</blockquote>\n<h4 id=\"control-flow-and-unwinding\">Control Flow and Unwinding</h4>\n<p>Special handling is required for control flow statements that break the linear recursion:</p>\n<ol>\n<li><p><strong>Conditionals (<code>if/else</code>)</strong></p>\n<ul>\n<li>Evaluate condition expression to boolean (with truthiness conversion)</li>\n<li>Execute only the chosen branch, skipping the other entirely</li>\n</ul>\n</li>\n<li><p><strong>Loops (<code>while</code>, <code>for</code>)</strong></p>\n<ul>\n<li>Create a loop execution context that can intercept <code>break</code>/<code>continue</code></li>\n<li>Repeatedly evaluate condition and body until condition becomes falsey</li>\n</ul>\n</li>\n<li><p><strong>Function Calls</strong></p>\n<ul>\n<li>Create new Environment with closure as parent</li>\n<li>Bind parameters to argument values</li>\n<li>Execute function body, catching <code>return</code> signals to unwind</li>\n</ul>\n</li>\n<li><p><strong>Return Statements</strong></p>\n<ul>\n<li>Use a non-local exit mechanism (exception/sentinel) to propagate return values up through nested calls</li>\n</ul>\n</li>\n</ol>\n<p>This control flow management requires the Evaluator to be aware of context—whether it&#39;s evaluating an expression (must return value) or statement (may trigger jumps).</p>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>A well-organized codebase significantly reduces implementation complexity. The following structure separates concerns logically, making the system easier to understand, test, and extend:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>tree_walker_interpreter/\n├── __init__.py\n├── interpreter.py              # Main Interpreter class, entry point\n├── evaluator.py               # Core Evaluator class with dispatch logic\n├── environment.py             # Environment class and scope management\n├── runtime_values.py          # Runtime value representations\n├── errors.py                  # Runtime error classes and handling\n├── control_flow.py            # Break/Continue/Return signal classes\n│\n├── ast/                       # AST node definitions (from parser)\n│   ├── __init__.py\n│   ├── nodes.py               # Base Node class and all concrete node types\n│   └── visitor.py             # Optional: Visitor pattern infrastructure\n│\n├── builtins/                  # Standard library functions\n│   ├── __init__.py\n│   └── functions.py           # print(), clock(), etc.\n│\n└── tests/                     # Test suite organized by milestone\n    ├── __init__.py\n    ├── test_expressions.py    # Milestone 1: Expression evaluation\n    ├── test_variables.py      # Milestone 2: Variables and scoping\n    ├── test_control_flow.py   # Milestone 3: Conditionals and loops\n    └── test_functions.py      # Milestone 4: Functions and closures</code></pre></div>\n\n<h4 id=\"module-responsibilities-and-dependencies\">Module Responsibilities and Dependencies</h4>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Primary Exports</th>\n<th>Dependencies</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>interpreter.py</code></td>\n<td><code>Interpreter</code> class with <code>interpret()</code> method</td>\n<td><code>evaluator</code>, <code>environment</code>, <code>builtins</code>, <code>errors</code></td>\n<td>End-user API, REPL</td>\n</tr>\n<tr>\n<td><code>evaluator.py</code></td>\n<td><code>Evaluator</code> class with <code>evaluate()</code> method</td>\n<td><code>environment</code>, <code>runtime_values</code>, <code>control_flow</code>, <code>errors</code>, <code>ast.nodes</code></td>\n<td><code>interpreter</code>, test suites</td>\n</tr>\n<tr>\n<td><code>environment.py</code></td>\n<td><code>Environment</code> class, <code>UndefinedVariableError</code></td>\n<td><code>errors</code></td>\n<td><code>evaluator</code>, <code>interpreter</code></td>\n</tr>\n<tr>\n<td><code>runtime_values.py</code></td>\n<td><code>RuntimeValue</code> base, <code>NumberValue</code>, <code>StringValue</code>, <code>BooleanValue</code>, <code>NilValue</code>, <code>FunctionValue</code></td>\n<td>(none)</td>\n<td><code>evaluator</code>, <code>environment</code>, <code>builtins</code></td>\n</tr>\n<tr>\n<td><code>errors.py</code></td>\n<td><code>RuntimeError</code>, <code>TypeError</code>, <code>DivisionByZeroError</code>, <code>ArgumentError</code></td>\n<td><code>ast.nodes</code> (for token)</td>\n<td>All modules</td>\n</tr>\n<tr>\n<td><code>control_flow.py</code></td>\n<td><code>ControlFlowSignal</code>, <code>BreakSignal</code>, <code>ContinueSignal</code>, <code>ReturnSignal</code></td>\n<td><code>runtime_values</code></td>\n<td><code>evaluator</code></td>\n</tr>\n<tr>\n<td><code>ast/nodes.py</code></td>\n<td>All AST node classes (<code>LiteralNode</code>, <code>BinaryNode</code>, etc.)</td>\n<td>(none)</td>\n<td><code>evaluator</code>, parser, tests</td>\n</tr>\n<tr>\n<td><code>builtins/functions.py</code></td>\n<td>Built-in function implementations</td>\n<td><code>runtime_values</code></td>\n<td><code>interpreter</code> (initialization)</td>\n</tr>\n</tbody></table>\n<p>This structure enforces clear boundaries:</p>\n<ul>\n<li><strong>AST module</strong> contains only data definitions, no logic</li>\n<li><strong>Evaluator</strong> contains all execution logic but no storage</li>\n<li><strong>Environment</strong> contains all storage logic but no execution</li>\n<li><strong>Errors</strong> centralizes all error types for consistent handling</li>\n</ul>\n<h4 id=\"import-strategy-to-avoid-circular-dependencies\">Import Strategy to Avoid Circular Dependencies</h4>\n<p>The dependency graph must remain acyclic. Follow these import rules:</p>\n<ol>\n<li><strong>AST nodes</strong> import nothing from other interpreter modules</li>\n<li><strong>Runtime values</strong> import nothing (base types only)</li>\n<li><strong>Environment</strong> imports only <code>errors</code></li>\n<li><strong>Evaluator</strong> imports everything else as needed</li>\n<li><strong>Interpreter</strong> imports all components</li>\n</ol>\n<p>If using a visitor pattern, the <code>ast/visitor.py</code> would define the visitor interface, which <code>evaluator.py</code> would implement. This adds indirection but provides cleaner separation.</p>\n<blockquote>\n<p><strong>Implementation Tip:</strong> Use Python&#39;s <code>__all__</code> in each module&#39;s <code>__init__.py</code> to control what gets exported. This prevents internal helper classes from leaking into the public API and keeps imports clean.</p>\n</blockquote>\n<h4 id=\"configuration-and-entry-points\">Configuration and Entry Points</h4>\n<p>For different usage scenarios, provide multiple entry points:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Direct API usage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tree_walker_interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Interpreter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Interpreter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> interpreter.interpret(</span><span style=\"color:#9ECBFF\">\"print 'Hello, World!';\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># REPL mode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">python </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">m tree_walker_interpreter.repl</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># File execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">python </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">m tree_walker_interpreter.run path</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">to</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">script.tl</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test runner</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">python </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">m pytest tests</span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">v</span></span></code></pre></div>\n\n<p>This modular structure scales well as features are added. Each milestone naturally maps to specific modules:</p>\n<ul>\n<li><strong>Milestone 1</strong>: Implement <code>evaluator.py</code> for expressions</li>\n<li><strong>Milestone 2</strong>: Implement <code>environment.py</code> and extend <code>evaluator.py</code> for variables</li>\n<li><strong>Milestone 3</strong>: Extend <code>evaluator.py</code> with control flow, add <code>control_flow.py</code></li>\n<li><strong>Milestone 4</strong>: Implement <code>runtime_values.py</code> for functions, extend all components</li>\n</ul>\n<p>The separation also enables incremental testing—you can test the Environment class independently before integrating it with the Evaluator.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Recommended)</th>\n<th>Advanced Option (Alternative)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>AST Representation</strong></td>\n<td>Plain Python classes with fields</td>\n<td>Dataclasses (<code>@dataclass</code>) or namedtuples</td>\n</tr>\n<tr>\n<td><strong>Node Type Dispatch</strong></td>\n<td>if-elif chain in <code>evaluate()</code></td>\n<td>Visitor pattern with double dispatch</td>\n</tr>\n<tr>\n<td><strong>Environment Chain</strong></td>\n<td>Linked list of dict wrappers</td>\n<td>Flat array with static distance indexing</td>\n</tr>\n<tr>\n<td><strong>Runtime Values</strong></td>\n<td>Python native types (int, str, bool, None)</td>\n<td>Wrapper classes with type tags</td>\n</tr>\n<tr>\n<td><strong>Error Propagation</strong></td>\n<td>Python exceptions</td>\n<td>Return value with error flag (Result type)</td>\n</tr>\n<tr>\n<td><strong>Control Flow Signals</strong></td>\n<td>Python exceptions for break/continue/return</td>\n<td>State flag in Evaluator context object</td>\n</tr>\n</tbody></table>\n<p>For this educational project, the Simple Options are strongly recommended—they minimize cognitive overhead and let learners focus on the interpreter concepts rather than Python patterns.</p>\n<h4 id=\"b-recommended-file-structure-implementation\">B. Recommended File Structure Implementation</h4>\n<p>Create the following files with their basic skeletons:</p>\n<p><strong><code>tree_walker_interpreter/__init__.py</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">AST Tree-Walking Interpreter - Educational Implementation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Interpreter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">, UndefinedVariableError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">__version__</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"0.1.0\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">__all__</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"Interpreter\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"RuntimeError\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TypeError\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"UndefinedVariableError\"</span><span style=\"color:#E1E4E8\">]</span></span></code></pre></div>\n\n<p><strong><code>tree_walker_interpreter/interpreter.py</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Main interpreter entry point and public API.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .evaluator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Evaluator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .builtins.functions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_global_environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> RuntimeError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main interpreter class providing the public interpret() method.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.evaluator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Evaluator()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.global_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_global_environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> interpret</span><span style=\"color:#E1E4E8\">(self, source_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse and execute source code.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            source_code: The program source as a string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if execution completed successfully, False if a runtime error occurred</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            SyntaxError: If the source code has syntax errors (from parser)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Integrate with parser when available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For now, we'll assume AST is passed differently for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _stringify</span><span style=\"color:#E1E4E8\">(self, value: Any) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Convert a runtime value to a display string.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            value: Any runtime value (number, string, boolean, nil, function)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            String representation for output</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"nil\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(value, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(value).lower()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> callable</span><span style=\"color:#E1E4E8\">(value):  </span><span style=\"color:#6A737D\"># Function value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"&#x3C;fn>\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(value)</span></span></code></pre></div>\n\n<p><strong><code>tree_walker_interpreter/environment.py</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Environment chain for lexical scoping.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Optional, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> UndefinedVariableError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Maps variable names to values with support for nested scopes via parent chain.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Attributes:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        store: Dictionary of name -> value bindings in this scope</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        parent: Parent environment for variable lookup chain (None for global)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, parent: Optional[</span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.store: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create a new variable binding in the current environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Variable name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            value: Initial value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Note:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            This always creates binding in current environment, even if name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            exists in parent scope (shadowing).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement variable definition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Retrieve a variable's value by walking the environment chain.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Variable name to look up</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            The value bound to this name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            UndefinedVariableError: If name is not found in any environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement chain lookup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assign</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Update an existing variable's value in the nearest enclosing scope.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Variable name to assign to</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            value: New value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            UndefinedVariableError: If name is not defined in any environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement assignment with scope walking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong><code>tree_walker_interpreter/errors.py</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Runtime error classes for the interpreter.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all runtime errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.token:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"[Line </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.token.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">] RuntimeError: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"RuntimeError: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UndefinedVariableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when accessing an undefined variable.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when operations are applied to incompatible types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DivisionByZeroError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when dividing by zero.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArgumentError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when function is called with wrong number of arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong><code>tree_walker_interpreter/runtime_values.py</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Runtime value representations and type utilities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># For Milestone 4:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FunctionValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Runtime representation of a user-defined function.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Attributes:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        name: Function name (or None for anonymous/lambda)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        parameters: List of parameter names</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        body: The function body AST node</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        closure: Environment captured when function was defined</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], parameters: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], body, closure: Environment):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parameters </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parameters</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> body</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.closure </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> closure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">(self, arguments: List[Any]) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute the function with given arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement in Milestone 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.name:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;fn </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">>\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"&#x3C;anonymous fn>\"</span></span></code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete parser integration helper</strong> (when parser is available):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tree_walker_interpreter/parser_integration.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Bridge between parser output and interpreter evaluation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Interpreter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> RuntimeError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Assuming parser module provides parse(source) -> AST</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse, ParseError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#79B8FF\"> ImportError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Stub for when parser isn't available yet</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(source):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> NotImplementedError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Parser not integrated yet\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> run_source</span><span style=\"color:#E1E4E8\">(source: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, interpreter: Optional[Interpreter] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Complete pipeline: parse source and interpret it.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns True on success, prints errors and returns False on failure.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> interpreter </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Interpreter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ast </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse(source)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        interpreter.interpret(ast)  </span><span style=\"color:#6A737D\"># Assuming interpret accepts AST directly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> ParseError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Syntax error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Runtime error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Evaluator skeleton</strong> (to be filled in across milestones):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tree_walker_interpreter/evaluator.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core recursive evaluator for AST nodes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">, DivisionByZeroError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .control_flow </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BreakSignal, ContinueSignal, ReturnSignal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recursively evaluates AST nodes in the context of an environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main dispatch method - evaluates any AST node.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: Any AST node from the parser</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current environment for variable lookup</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Runtime value resulting from evaluating the node</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            RuntimeError: For any runtime error during evaluation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement node type dispatch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This will grow as we implement more node types across milestones</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Example structure:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> type</span><span style=\"color:#E1E4E8\">(node).</span><span style=\"color:#79B8FF\">__name__</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"LiteralNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 1: Return literal value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"BinaryNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 1: Evaluate left and right, apply operator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"UnaryNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 1: Evaluate operand, apply unary operator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"GroupingNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 1: Evaluate expression inside parentheses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"VariableNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 2: Look up variable in environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"VarDeclNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 2: Evaluate initializer, define in environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"AssignNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 2: Evaluate value, assign to existing variable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"IfNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 3: Evaluate condition, execute appropriate branch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"WhileNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 3: Loop while condition is truthy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"FunctionDeclNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 4: Create function value, define in environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"CallNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 4: Evaluate callee and arguments, call function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"ReturnNode\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> Milestone 4: Evaluate expression, raise ReturnSignal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unhandled node type: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-for-python\">E. Language-Specific Hints for Python</h4>\n<ol>\n<li><strong>Truthiness Conversion</strong>: Use Python&#39;s <code>bool()</code> but treat <code>None</code> (nil) and <code>0</code> as falsey for language consistency:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   def</span><span style=\"color:#B392F0\"> is_truthy</span><span style=\"color:#E1E4E8\">(value):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(value, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           return</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#6A737D\">  # Everything else is truthy (including 0, empty string)</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Type Checking</strong>: Use <code>isinstance()</code> for runtime type checks rather than <code>type()</code> to handle inheritance:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(left, (</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">)):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Operand must be a number, got </span><span style=\"color:#79B8FF\">{type</span><span style=\"color:#E1E4E8\">(left).</span><span style=\"color:#79B8FF\">__name__}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Environment Chain</strong>: Implement parent traversal with a simple while loop:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   current </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   while</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> current.store:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           return</span><span style=\"color:#E1E4E8\"> current.store[name]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current.parent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   raise</span><span style=\"color:#E1E4E8\"> UndefinedVariableError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Undefined variable '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Control Flow Signals</strong>: Use custom exceptions for non-local exits:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   class</span><span style=\"color:#B392F0\"> ReturnSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">           self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # In function evaluation:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       self</span><span style=\"color:#E1E4E8\">.evaluate(function_body, call_env)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Implicit return nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   except</span><span style=\"color:#E1E4E8\"> ReturnSignal </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> ret:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#E1E4E8\"> ret.value  </span><span style=\"color:#6A737D\"># Explicit return value</span></span></code></pre></div>\n\n<ol start=\"5\">\n<li><strong>Function Value Equality</strong>: For testing, you may want function values to compare equal if they refer to the same AST node and closure. Implement <code>__eq__</code> method in <code>FunctionValue</code>.</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After setting up the file structure, verify your foundation:</p>\n<ol>\n<li><strong>Run basic imports test</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   from tree_walker_interpreter import Interpreter</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   from tree_walker_interpreter.environment import Environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   from tree_walker_interpreter.errors import RuntimeError</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   print('✓ All imports successful')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   \"</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><p><strong>Expected output</strong>: <code>✓ All imports successful</code></p>\n</li>\n<li><p><strong>Create a simple test</strong> to verify component creation:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # test_architecture.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> tree_walker_interpreter.environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Test environment chain creation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   global_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   local_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment(global_env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   assert</span><span style=\"color:#E1E4E8\"> local_env.parent </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> global_env</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   assert</span><span style=\"color:#E1E4E8\"> global_env.parent </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Environment chain created correctly\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Common early issues</strong>:<ul>\n<li><strong>Circular import errors</strong>: Ensure modules follow the dependency order above</li>\n<li><strong>Missing <code>__init__.py</code></strong>: Each directory needs this file to be a package</li>\n<li><strong>Relative import issues</strong>: Use absolute imports within the package</li>\n</ul>\n</li>\n</ol>\n<p>This architectural foundation will support all four milestones. The clean separation allows you to implement and test each component independently before integration.</p>\n<hr>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 2, 3, 4</p>\n</blockquote>\n<p>This section defines the fundamental building blocks the interpreter uses to represent both static program structure and dynamic runtime state. It is the interpreter&#39;s &quot;type system&quot; in the broadest sense, encompassing the values that can be manipulated, the storage for those values as the program runs, and the syntactic structures that are evaluated to produce them. Getting this model clear and consistent is critical before implementing the evaluation logic, as it defines the contracts between all components.</p>\n<h3 id=\"runtime-values-and-types\">Runtime Values and Types</h3>\n<p><strong>Mental Model: The Toy Box with Labeled Compartments</strong>\nThink of the interpreter&#39;s memory as a toy box with separate, clearly marked compartments for different types of toys: one for <code>Number</code> blocks, one for <code>String</code> jump ropes, one for <code>Boolean</code> light switches, one for <code>Nil</code> (an empty space), and a special shelf for <code>Function</code> instruction manuals. When you evaluate an expression, you reach into the box and pull out a toy. The evaluator must know which compartment it came from because you can&#39;t stack blocks with a jump rope or flip a light switch that&#39;s actually a block. This compartmentalization—the <strong>runtime type</strong>—defines what operations are allowed.</p>\n<p>The interpreter is dynamically typed; types are associated with values, not variables. A variable can hold a <code>Number</code> at one moment and a <code>String</code> the next. However, operations are type-aware: you cannot add a <code>Boolean</code> to a <code>Number</code>. The set of <strong>runtime value</strong> types is intentionally minimal to match the language&#39;s expressiveness defined in the goals.</p>\n<p>The following table enumerates all possible runtime value types and their concrete representation in the implementation. The representation is designed to be simple and to leverage the host language&#39;s (Python&#39;s) native types where possible, while requiring a custom type for functions to capture their lexical environment.</p>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Internal Representation</th>\n<th>Description &amp; Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Number</code></td>\n<td>Python&#39;s <code>float</code> or <code>int</code></td>\n<td>All numeric literals. Internally, we use Python&#39;s numeric types. For simplicity, we treat all numbers as floating-point (<code>float</code>), but an integer subtype can be added later. Example: <code>42</code>, <code>3.14</code>.</td>\n</tr>\n<tr>\n<td><code>String</code></td>\n<td>Python&#39;s <code>str</code></td>\n<td>Text literals enclosed in double quotes. Example: <code>&quot;hello world&quot;</code>.</td>\n</tr>\n<tr>\n<td><code>Boolean</code></td>\n<td>Python&#39;s <code>bool</code></td>\n<td>The logical values <code>true</code> and <code>false</code>.</td>\n</tr>\n<tr>\n<td><code>Nil</code></td>\n<td>The singleton <code>None</code></td>\n<td>Represents the absence of a value. The result of an expression like <code>print(&quot;hi&quot;)</code> or an uninitialized variable.</td>\n</tr>\n<tr>\n<td><code>Function</code></td>\n<td>Instance of <code>FunctionValue</code> class</td>\n<td>A callable unit of execution. It is not a native Python function but a custom object storing the function&#39;s definition (parameters, body) and its <strong>closure environment</strong>—a reference to the environment active when the function was declared. This is the key to implementing lexical scoping and closures.</td>\n</tr>\n</tbody></table>\n<p>The <code>FunctionValue</code> is a critical custom type. Its structure is detailed below, as it must be explicitly defined to support closures.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>name</code></td>\n<td><code>Optional[str]</code></td>\n<td>The function&#39;s name as declared in the source code. This is optional to support anonymous/lambda functions. Used for better error reporting and recursion (a function can refer to its own name in its body).</td>\n</tr>\n<tr>\n<td><code>parameters</code></td>\n<td><code>List[str]</code></td>\n<td>An ordered list of parameter names (as strings). The length of this list defines the function&#39;s arity.</td>\n</tr>\n<tr>\n<td><code>body</code></td>\n<td><code>ASTNode</code> (typically a <code>Block</code> statement)</td>\n<td>The abstract syntax tree of the function&#39;s body. This is the static code that will be evaluated each time the function is called.</td>\n</tr>\n<tr>\n<td><code>closure</code></td>\n<td><code>Environment</code></td>\n<td>A reference to the <strong>environment in effect at the moment the function was declared</strong>, not when it is called. This is the &quot;captured&quot; environment that allows the function to access variables from its surrounding scope, enabling closures.</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fdata-type-relationship.svg\" alt=\"Data Model: Type Relationships\"></p>\n<p><strong>Architecture Decision Record: Runtime Value Representation</strong></p>\n<blockquote>\n<p><strong>Decision: Use Host Language Types with a Custom Function Wrapper</strong></p>\n<ul>\n<li><strong>Context</strong>: We need a simple, efficient way to represent values during interpretation. The interpreter must support basic operations (arithmetic, comparison) and first-class functions with closures.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Tagged Union / Sum Type</strong>: Create a dedicated <code>Value</code> class or enum with a type tag and a union field for each possible type (number, string, etc.). Functions would be one variant of this union.</li>\n<li><strong>Host Language Primitives + Custom Class</strong>: Use the host language&#39;s built-in types (int, str, bool, None) for primitive values, and a custom <code>FunctionValue</code> class for functions.</li>\n<li><strong>Fully Custom Wrapper for All Types</strong>: Create a base <code>RuntimeValue</code> class with subclasses for each type (NumberValue, StringValue, etc.), providing a uniform interface.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Option 2 (Host Language Primitives + Custom Class).</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Simplicity &amp; Performance</strong>: Using native types for primitives (e.g., Python&#39;s <code>int</code>, <code>str</code>) is straightforward and leverages the host&#39;s efficient operations. There is no need to wrap a number in a custom class just to add a type tag when Python&#39;s <code>type()</code> serves that purpose.</li>\n<li><strong>Clear Demarcation for Complex Types</strong>: Functions require additional metadata (parameters, body, closure). A custom class is a natural and explicit way to bundle this data. This creates a clear conceptual boundary: primitives are &quot;just values,&quot; while functions are &quot;executable objects with state.&quot;</li>\n<li><strong>Easier Debugging and Testing</strong>: Printing a native Python string shows its value directly. A custom wrapper would require a <code>__repr__</code> method to be equally readable.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Pros</strong>: Cleaner code, less boilerplate, faster execution for primitive operations.</li>\n<li><strong>Cons</strong>: Requires careful type checking in the evaluator, as the type system is implicit (e.g., <code>isinstance(value, str)</code> for strings). The mix of native and custom types can feel inconsistent, but the conceptual separation (function vs. primitive) mitigates this.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tagged Union</td>\n<td>Uniform interface, explicit type tags, easy to extend</td>\n<td>Boilerplate for every operation, slower due to indirection, memory overhead</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Host Primitives + Custom Class</td>\n<td>Fast, simple, leverages host language</td>\n<td>Inconsistent representation, requires explicit type checks</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Fully Custom Wrapper</td>\n<td>Ultimate consistency and control, easy to add metadata to all types</td>\n<td>Maximum boilerplate, inefficient for primitives, over-engineering</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"the-environment-model\">The Environment Model</h3>\n<p><strong>Mental Model: A Stack of Ledgers in a Library</strong>\nImagine a library with a main ledger (the global scope) on a central desk. When you enter a study room (a new block or function), you take a fresh, empty ledger and place it on top of the main one. You can write new entries (define variables) in this top ledger. When you need to look up a value, you first check the top ledger. If it&#39;s not there, you look in the ledger beneath it, and so on, until you reach the main desk&#39;s ledger. When you leave the study room, you discard the top ledger—all entries made there vanish—and you&#39;re back to using only the lower ledgers. This is <strong>lexical (static) scoping</strong>: the visibility of a name depends on the static, nested structure of the code, not the dynamic call flow.</p>\n<p>The <code>Environment</code> class implements this stack-of-ledgers model as a linked chain. Each <code>Environment</code> object represents one scope or ledger. It contains a dictionary (<code>store</code>) mapping variable names to their current runtime values and a reference (<code>parent</code>) to the environment that encloses it (the next ledger down). The chain starts at the <strong>global environment</strong>, which has no parent (<code>parent = None</code>).</p>\n<p>The core operations are:</p>\n<ol>\n<li><strong>Define (<code>define</code>)</strong> : Write a new name-value binding in the <em>current</em> ledger (environment). This is used for variable declarations (<code>var x = 5;</code>).</li>\n<li><strong>Get (<code>get</code>)</strong> : Read a value by name. Start at the current ledger and walk up the parent chain until the name is found. If the chain ends (reached the global scope with no parent) and the name is still not found, the variable is <strong>undefined</strong>.</li>\n<li><strong>Assign (<code>assign</code>)</strong> : Update the value of an <em>existing</em> binding. Walk the parent chain to find the <em>first</em> ledger where the name exists, then update its value there. If the name is not found in any ledger, it&#39;s an error (cannot assign to an undefined variable). This implements the rule that assignment modifies the variable in the nearest enclosing scope where it is defined, which may not be the current scope.</li>\n</ol>\n<p>The structure and interface of the <code>Environment</code> class are formally defined below.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>store</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>The dictionary holding variable bindings for this specific scope. Keys are variable names (strings), values are runtime values (Number, String, Boolean, Nil, or FunctionValue).</td>\n</tr>\n<tr>\n<td><code>parent</code></td>\n<td><code>Optional[Environment]</code></td>\n<td>A reference to the environment that encloses this one. The global environment&#39;s <code>parent</code> is <code>None</code>.</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>Method Signature</th>\n<th>Description &amp; Algorithm</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>define(name: str, value: Any) -&gt; None</code></td>\n<td>Creates a new binding in the current environment&#39;s <code>store</code>. This operation does <strong>not</strong> check for existing bindings—it allows <strong>shadowing</strong> (a new binding with the same name hides an outer one).</td>\n</tr>\n<tr>\n<td><code>get(name: str) -&gt; Any</code></td>\n<td>1. Check if <code>name</code> exists as a key in the current environment&#39;s <code>store</code>. <br> 2. If found, return the associated value. <br> 3. If not found and <code>parent</code> is not <code>None</code>, recursively call <code>parent.get(name)</code>. <br> 4. If <code>parent</code> is <code>None</code> (we are in the global scope and didn&#39;t find it), raise an <code>UndefinedVariableError</code>.</td>\n</tr>\n<tr>\n<td><code>assign(name: str, value: Any) -&gt; None</code></td>\n<td>1. Check if <code>name</code> exists as a key in the current environment&#39;s <code>store</code>. <br> 2. If found, update the value for that key in <code>store</code>. <br> 3. If not found and <code>parent</code> is not <code>None</code>, recursively call <code>parent.assign(name, value)</code>. <br> 4. If <code>parent</code> is <code>None</code> (name not found in any scope), raise an <code>UndefinedVariableError</code> (similar to <code>get</code>).</td>\n</tr>\n</tbody></table>\n<p><strong>Common Pitfalls: Environment Chain</strong>\n⚠️ <strong>Pitfall: Forgetting to walk the parent chain in <code>get</code> or <code>assign</code></strong></p>\n<ul>\n<li><strong>Description</strong>: Implementing <code>get</code> by only checking the current environment&#39;s <code>store</code> without consulting the <code>parent</code>.</li>\n<li><strong>Why it&#39;s wrong</strong>: This breaks lexical scoping. A function would be unable to see variables from its outer scope, making closures impossible and rendering most programs invalid.</li>\n<li><strong>Fix</strong>: Always implement the recursive walk. The base case is either finding the name or reaching an environment with a <code>None</code> parent.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Confusing <code>define</code> with <code>assign</code></strong></p>\n<ul>\n<li><strong>Description</strong>: Using <code>assign</code> for variable declaration (e.g., on a <code>var</code> statement). This will incorrectly try to update an existing binding and will raise an <code>UndefinedVariableError</code> if the variable hasn&#39;t been declared in an outer scope.</li>\n<li><strong>Why it&#39;s wrong</strong>: Declaration (<code>var x</code>) should <em>create</em> a new binding in the <em>current</em> scope, even if a same-named variable exists in an outer scope (shadowing). Assignment (<code>x = 5</code>) should <em>modify</em> an existing binding, searching outward.</li>\n<li><strong>Fix</strong>: Map the AST&#39;s <code>VariableDeclaration</code> node to <code>environment.define(...)</code> and the <code>Assignment</code> node to <code>environment.assign(...)</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrectly setting the parent for a new function environment</strong></p>\n<ul>\n<li><strong>Description</strong>: When creating a new environment for a function call, setting its <code>parent</code> to the <em>caller&#39;s</em> current environment instead of the function&#39;s own <code>closure</code> environment.</li>\n<li><strong>Why it&#39;s wrong</strong>: This would implement <strong>dynamic scoping</strong>, where a function sees the variables of its caller, not the variables in place where it was defined. This is contrary to the language&#39;s goal of lexical scoping and makes programs very difficult to reason about.</li>\n<li><strong>Fix</strong>: The new call environment&#39;s <code>parent</code> must be the <code>closure</code> field of the <code>FunctionValue</code> being called.</li>\n</ul>\n<p><img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fenv-chain-lookup.svg\" alt=\"Diagram: Environment Chain Lookup\"></p>\n<h3 id=\"key-ast-node-types-for-evaluation\">Key AST Node Types for Evaluation</h3>\n<p><strong>Mental Model: The Recipe Card Box</strong>\nThe AST is a box of indexed recipe cards (nodes). Each card has a specific type (<code>Literal</code>, <code>Binary</code>, etc.) printed at the top and a set of blank fields to fill in (like &quot;left ingredient,&quot; &quot;operator,&quot; &quot;right ingredient&quot;). The evaluator&#39;s job is to take a card, follow its instructions (defined by its type), retrieve the values for its fields (which might involve pulling other cards), and produce a final dish (a runtime value). The semantics—<em>what to do</em> when you see a given card type—are fixed and must be implemented in the evaluator.</p>\n<p>This subsection lists the essential AST node types produced by the parser that the evaluator must handle. It focuses on their <em>runtime semantics</em>: what the node evaluates to and any side effects it causes. The exact field names may vary slightly depending on the parser implementation, but the core concepts are consistent.</p>\n<table>\n<thead>\n<tr>\n<th>AST Node Type</th>\n<th>Key Fields</th>\n<th>Evaluation Semantics &amp; Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Literal</code></td>\n<td><code>value: Any</code> (raw Python value)</td>\n<td>Evaluates directly to the corresponding runtime value. For example, a <code>Literal</code> node with <code>value=42</code> evaluates to the runtime <code>Number</code> 42. This is a leaf node in the AST.</td>\n</tr>\n<tr>\n<td><code>Grouping</code></td>\n<td><code>expression: ASTNode</code></td>\n<td>Evaluates its inner <code>expression</code> and returns that result. Its sole purpose is to override default precedence; it has no runtime effect beyond forcing a specific evaluation order.</td>\n</tr>\n<tr>\n<td><code>Unary</code></td>\n<td><code>operator: Token</code>, <code>right: ASTNode</code></td>\n<td>1. Evaluate the <code>right</code> operand to a value. <br> 2. Apply the unary operator to that value. The <code>-</code> operator expects a <code>Number</code> operand and returns its negation. The <code>!</code> operator performs logical NOT on any value, following <strong>truthiness</strong> rules (e.g., <code>nil</code> and <code>false</code> are falsey; everything else is truthy).</td>\n</tr>\n<tr>\n<td><code>Binary</code></td>\n<td><code>left: ASTNode</code>, <code>operator: Token</code>, <code>right: ASTNode</code></td>\n<td>1. Evaluate the <code>left</code> operand to a value. <br> 2. Evaluate the <code>right</code> operand to a value. <br> 3. Apply the binary operator to the two values. This includes arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>), comparison (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>), and equality (<code>==</code>, <code>!=</code>) operators. The <code>+</code> operator also performs string concatenation if both operands are strings. <code>/</code> must check for division by zero.</td>\n</tr>\n<tr>\n<td><code>Logical</code></td>\n<td><code>left: ASTNode</code>, <code>operator: Token</code> (<code>and</code>, <code>or</code>), <code>right: ASTNode</code></td>\n<td>Implements <strong>short-circuit evaluation</strong>. For <code>and</code>: Evaluate <code>left</code>. If it&#39;s falsey, return the <code>left</code> value immediately. Otherwise, evaluate and return the <code>right</code> value. For <code>or</code>: Evaluate <code>left</code>. If it&#39;s truthy, return the <code>left</code> value immediately. Otherwise, evaluate and return the <code>right</code> value.</td>\n</tr>\n<tr>\n<td><code>Variable</code></td>\n<td><code>name: Token</code> (with lexeme)</td>\n<td>Represents an identifier usage. Evaluates to the value bound to the variable&#39;s name in the current environment chain. Triggers a <code>get</code> operation.</td>\n</tr>\n<tr>\n<td><code>Assignment</code></td>\n<td><code>name: Token</code>, <code>value: ASTNode</code></td>\n<td>1. Evaluate the <code>value</code> expression. <br> 2. Perform an <code>assign</code> operation on the environment with the <code>name</code>&#39;s lexeme and the computed value. Returns the assigned value.</td>\n</tr>\n<tr>\n<td><code>VariableDeclaration</code></td>\n<td><code>name: Token</code>, <code>initializer: Optional[ASTNode]</code></td>\n<td>1. Evaluate the <code>initializer</code> expression (if present), otherwise use <code>nil</code>. <br> 2. Perform a <code>define</code> operation on the current environment with the <code>name</code>&#39;s lexeme and the initial value. Returns the initial value.</td>\n</tr>\n<tr>\n<td><code>Block</code></td>\n<td><code>statements: List[ASTNode]</code></td>\n<td>Evaluates each statement in sequence, in a new nested environment whose parent is the current environment. Returns the value of the last statement evaluated, or <code>nil</code> if the block is empty. This creates a new lexical scope.</td>\n</tr>\n<tr>\n<td><code>If</code></td>\n<td><code>condition: ASTNode</code>, <code>then_branch: ASTNode</code>, <code>else_branch: Optional[ASTNode]</code></td>\n<td>1. Evaluate the <code>condition</code>. <br> 2. If the condition is <strong>truthy</strong>, evaluate and return the value of the <code>then_branch</code>. <br> 3. Otherwise, if an <code>else_branch</code> exists, evaluate and return its value. If no <code>else_branch</code>, return <code>nil</code>.</td>\n</tr>\n<tr>\n<td><code>While</code></td>\n<td><code>condition: ASTNode</code>, <code>body: ASTNode</code></td>\n<td>1. Evaluate the <code>condition</code>. <br> 2. If the condition is falsey, exit the loop and return <code>nil</code>. <br> 3. If truthy, evaluate the <code>body</code>. If a <code>BreakSignal</code> is raised, exit the loop and return <code>nil</code>. If a <code>ContinueSignal</code> is raised, jump back to step 1. <br> 4. After executing the body (with no jump signal), loop back to step 1.</td>\n</tr>\n<tr>\n<td><code>For</code></td>\n<td><code>initializer: Optional[ASTNode]</code>, <code>condition: Optional[ASTNode]</code>, <code>increment: Optional[ASTNode]</code>, <code>body: ASTNode</code></td>\n<td>This is typically <strong>desugared</strong> (transformed) in the parser or evaluator into an equivalent <code>Block</code> containing the <code>initializer</code>, a <code>While</code> loop with the <code>condition</code>, and the <code>increment</code> statement at the end of the loop body. The evaluator can thus treat it as this desugared form.</td>\n</tr>\n<tr>\n<td><code>FunctionDeclaration</code></td>\n<td><code>name: Token</code>, <code>parameters: List[Token]</code>, <code>body: ASTNode</code></td>\n<td>1. Create a new <code>FunctionValue</code> object. Its <code>name</code> is the token&#39;s lexeme, <code>parameters</code> are the list of parameter name strings, <code>body</code> is the function body AST node, and <code>closure</code> is a reference to the <em>current environment</em> at the time of declaration. <br> 2. Perform a <code>define</code> operation in the current environment, binding the function&#39;s name to this <code>FunctionValue</code>. Returns the <code>FunctionValue</code>.</td>\n</tr>\n<tr>\n<td><code>Call</code></td>\n<td><code>callee: ASTNode</code>, <code>arguments: List[ASTNode]</code></td>\n<td>1. Evaluate the <code>callee</code> expression. It must result in a <code>FunctionValue</code> or another callable (though we only have functions). <br> 2. Evaluate each argument expression in order, from left to right. <br> 3. Call the <code>call(arguments)</code> method on the <code>FunctionValue</code>, passing the list of evaluated argument values. This method creates a new environment for the call, binds parameters, executes the body, and returns the result. The result of the <code>Call</code> node is the return value from the function.</td>\n</tr>\n<tr>\n<td><code>Return</code></td>\n<td><code>value: Optional[ASTNode]</code></td>\n<td>1. Evaluate the <code>value</code> expression (if present), otherwise use <code>nil</code>. <br> 2. Raise a <code>ReturnSignal</code> containing this value. This signal is a <strong>non-local exit</strong> that unwinds the call stack until it is caught by the function call evaluator, which then returns the value as the result of the call.</td>\n</tr>\n<tr>\n<td><code>ExpressionStatement</code></td>\n<td><code>expression: ASTNode</code></td>\n<td>Evaluates the inner expression for its side effects (e.g., a function call) and discards its value. Returns <code>nil</code>.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> AST nodes are <strong>immutable</strong>. They are created by the parser and never modified. Evaluation traverses this static structure and produces dynamic values, but the tree itself does not change. This separation simplifies reasoning and prevents accidental state corruption.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete starter code for the foundational data model components. The <code>Environment</code> class is a prerequisite for evaluation and is provided in full. The representation of runtime values is mostly implicit, but the <code>FunctionValue</code> class is provided as a complete building block.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Runtime Values</strong></td>\n<td>Python&#39;s built-in types (<code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>None</code>) + custom <code>FunctionValue</code> class.</td>\n<td>Use a <code>dataclass</code> or <code>NamedTuple</code> for <code>FunctionValue</code> for cleaner attribute definition.</td>\n</tr>\n<tr>\n<td><strong>Environment Chain</strong></td>\n<td>Simple class with <code>dict</code> and <code>parent</code> reference.</td>\n<td>Use a <code>collections.ChainMap</code> for the lookup logic, though implementing the chain manually is more educational.</td>\n</tr>\n<tr>\n<td><strong>Error Types</strong></td>\n<td>Simple exception classes inheriting from a base <code>RuntimeError</code>.</td>\n<td>Add more context like stack traces or line numbers to error objects.</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Place the data model in a dedicated module to keep the project organized.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>treewalk_interpreter/\n├── ast_nodes.py          # AST node class definitions (from parser)\n├── environment.py        # Environment and FunctionValue classes\n├── errors.py            # Custom exception classes (RuntimeError, etc.)\n├── evaluator.py         # Main Evaluator class (next section)\n└── interpreter.py       # Top-level Interpreter class (orchestrates parse &amp; evaluate)</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code-complete\">C. Infrastructure Starter Code (COMPLETE)</h4>\n<p>The following code for <code>errors.py</code> and the core of <code>environment.py</code> is complete and ready to use. The learner should integrate these files as-is.</p>\n<p><strong>File: <code>errors.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Custom exceptions for the tree-walking interpreter.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all runtime errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token  </span><span style=\"color:#6A737D\"># The Token object from the lexer (should have line, column info)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"[Line </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.token.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UndefinedVariableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when trying to access a variable that is not defined in any accessible scope.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when an operation is applied to an operand of an inappropriate type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DivisionByZeroError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when dividing by zero.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArgumentError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when a function is called with the wrong number of arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ControlFlowSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for non-local control flow signals (break, continue, return).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreakSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals that a break statement was executed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ContinueSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals that a continue statement was executed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ReturnSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals that a return statement was executed. Carries the return value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span></code></pre></div>\n\n<p><strong>File: <code>environment.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Environment and FunctionValue classes for variable storage and closures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ast_nodes  </span><span style=\"color:#6A737D\"># Assuming your AST node types are in ast_nodes module</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A lexical scoping environment mapping variable names to values.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, parent: Optional[</span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.store: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parent: Optional[</span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Define a new variable in the current environment. Allows shadowing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.store[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve the value of a variable. Walks up the parent chain.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Check current scope</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.store:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.store[name]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Walk up the chain</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parent </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parent.get(name)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Not found anywhere</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> UndefinedVariableError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Undefined variable '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'.\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Token will be added in evaluator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assign</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Update the value of an existing variable. Walks up the parent chain to find it.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Check current scope</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.store:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.store[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Walk up the chain</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parent </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.parent.assign(name, value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Not found anywhere</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> UndefinedVariableError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot assign to undefined variable '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'.\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Token added in evaluator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FunctionValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Runtime representation of a function. Captures its definition environment for closures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], parameters: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], body: </span><span style=\"color:#9ECBFF\">'ast_nodes.Block'</span><span style=\"color:#E1E4E8\">, closure: Environment):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name  </span><span style=\"color:#6A737D\"># Can be None for anonymous functions</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parameters </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parameters</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> body</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.closure </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> closure  </span><span style=\"color:#6A737D\"># The environment where the function was defined</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">(self, arguments: List[Any]) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute the function with the given arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Validate argument count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(arguments) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.parameters):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> ArgumentError(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"Function '</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' expected </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.parameters)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments but got </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(arguments)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                token</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#6A737D\">  # Token will be added in evaluator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Create a new environment for this function call.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    Its parent is the function's closure environment, NOT the caller's environment.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        call_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment(</span><span style=\"color:#FFAB70\">parent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.closure)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Bind parameters to arguments in the new environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> param_name, arg_value </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.parameters, arguments):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            call_env.define(param_name, arg_value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 4. Execute the function body in the new environment.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    The evaluator will catch ReturnSignal and return its value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    This requires the evaluator to be available here, which introduces a circular dependency.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    We'll solve this in the Component Design: Function Manager section.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    For now, we leave this method as a skeleton.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Actually evaluate the body using the global evaluator.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> else</span><span style=\"color:#9ECBFF\"> \"&#x3C;anonymous>\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;function </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">>\"</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>The <code>FunctionValue.call</code> method depends on the evaluator, which hasn&#39;t been built yet. Its completion is left as a guided TODO in the next section (Component Design: Function Manager). The <code>Environment</code> class is complete.</p>\n<h4 id=\"e-language-specific-hints-python\">E. Language-Specific Hints (Python)</h4>\n<ul>\n<li>Use <code>isinstance(value, (int, float))</code> to check for numbers, as Python&#39;s <code>int</code> and <code>float</code> are distinct types but both represent our <code>Number</code> runtime type.</li>\n<li>For <code>Nil</code>, the singleton <code>None</code> is perfect. Check for it using <code>value is None</code>.</li>\n<li>The <code>FunctionValue</code> class&#39;s <code>__repr__</code> method is helpful for debugging. Use it to print functions in a readable way.</li>\n<li>The <code>Environment</code> class uses recursion for <code>get</code> and <code>assign</code>. Ensure the base case (<code>parent is None</code>) is correctly handled to avoid infinite recursion.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the <code>Environment</code> class, you should be able to run a simple test to verify its chain behavior.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_environment.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">global_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">global_env.define(</span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">global_env.define(</span><span style=\"color:#9ECBFF\">\"b\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">local_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment(</span><span style=\"color:#FFAB70\">parent</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">global_env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">local_env.define(</span><span style=\"color:#9ECBFF\">\"b\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Shadows global b</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">local_env.define(</span><span style=\"color:#9ECBFF\">\"c\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(local_env.get(</span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">))  </span><span style=\"color:#6A737D\"># Should print 1 (found in parent)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(local_env.get(</span><span style=\"color:#9ECBFF\">\"b\"</span><span style=\"color:#E1E4E8\">))  </span><span style=\"color:#6A737D\"># Should print 20 (found in current, shadowing)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(local_env.get(</span><span style=\"color:#9ECBFF\">\"c\"</span><span style=\"color:#E1E4E8\">))  </span><span style=\"color:#6A737D\"># Should print 30 (found in current)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(local_env.get(</span><span style=\"color:#9ECBFF\">\"d\"</span><span style=\"color:#E1E4E8\">))  </span><span style=\"color:#6A737D\"># Should raise UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> UndefinedVariableError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Caught expected error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">local_env.assign(</span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Modifies the binding in global_env</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(global_env.get(</span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">))  </span><span style=\"color:#6A737D\"># Should now print 100</span></span></code></pre></div>\n\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Variable lookup always returns <code>nil</code> or raises &quot;undefined&quot; for names you know exist.</td>\n<td>The <code>get</code> method is not walking the parent chain. It only checks <code>self.store</code>.</td>\n<td>Add a print statement in <code>get</code> to show which environment is being checked and whether it proceeds to the parent.</td>\n<td>Implement the recursive walk: if name not in <code>self.store</code> and <code>self.parent</code> is not <code>None</code>, return <code>self.parent.get(name)</code>.</td>\n</tr>\n<tr>\n<td>Changing a variable inside a function affects a variable with the same name outside, unexpectedly.</td>\n<td>The function&#39;s call environment has its <code>parent</code> set to the caller&#39;s environment (dynamic scoping) instead of the function&#39;s <code>closure</code>.</td>\n<td>Print the <code>parent</code> of the new call environment when a function is called.</td>\n<td>Ensure <code>call_env = Environment(parent=self.closure)</code>, where <code>self.closure</code> is the environment saved when the function was declared.</td>\n</tr>\n<tr>\n<td>&quot;Cannot assign to undefined variable&quot; error on a <code>var</code> declaration.</td>\n<td>You are using <code>assign</code> instead of <code>define</code> for variable declarations.</td>\n<td>Check which method you call for <code>VariableDeclaration</code> nodes in your evaluator.</td>\n<td>Use <code>environment.define(...)</code> for declarations, <code>environment.assign(...)</code> for assignments.</td>\n</tr>\n</tbody></table>\n<h2 id=\"component-design-core-evaluator\">Component Design: Core Evaluator</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 3, 4</p>\n</blockquote>\n<p>This section details the heart of the interpreter: the recursive <code>evaluate</code> function that traverses the Abstract Syntax Tree (AST), transforming syntactic nodes into runtime values. The evaluator embodies the principle of <strong>tree-walking</strong>: it starts at the root of the AST and recursively descends into child nodes, computing values and applying operations until the entire program is reduced to a final result. Its design must gracefully handle the diverse categories of language constructs—from simple literals to complex function calls—while maintaining a clear separation between the static AST structure and the dynamic environment of variable bindings.</p>\n<h3 id=\"mental-model-the-dom-tree-walker\">Mental Model: The DOM Tree Walker</h3>\n<p>Think of the AST as a detailed map of a city (the program), with different districts representing expression types (arithmetic, logic, function calls). The evaluator is like a tour bus driver following this map. At each intersection (node), the driver consults a rulebook (the evaluation logic) that says, &quot;If you see a <code>BinaryExpression</code> node, first visit the left street (evaluate left operand), then visit the right street (evaluate right operand), then apply the operation (e.g., add them).&quot; The bus recursively navigates deeper into neighborhoods (sub-expressions) until it reaches a dead-end—a literal value like a house number (e.g., <code>5</code>). Then it backs out, combining results along the way.</p>\n<p>This is analogous to traversing a Document Object Model (DOM) tree in a web browser. A script that walks the DOM to collect all paragraph text starts at the root <code>&lt;html&gt;</code> element, checks if the current node is a <code>&lt;p&gt;</code>, and if so, extracts its text. Then it recursively visits each child node. Similarly, the evaluator visits each AST node, applies a specific action based on the node&#39;s type, and recursively processes its children. The key insight is that the structure of the traversal mirrors the structure of the tree, and the operations are applied in an order that respects language semantics (e.g., operator precedence, parentheses).</p>\n<h3 id=\"interface-and-dispatch\">Interface and Dispatch</h3>\n<p>The evaluator&#39;s primary interface is a single, stateless function that accepts an AST node and the current <strong>environment</strong> (the mapping of variable names to values) and returns a runtime value. This function acts as a central dispatch router, examining the node&#39;s type and delegating to specialized handling logic.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Evaluator.evaluate</code></td>\n<td><code>node: ASTNode</code>, <code>env: Environment</code></td>\n<td><code>Any</code> (a runtime value)</td>\n<td>The main entry point for evaluation. Inspects the <code>node.type</code> and calls the appropriate internal handler method (e.g., <code>_visit_literal</code>). It is recursively called for child nodes.</td>\n</tr>\n</tbody></table>\n<p>The dispatch strategy is intentionally straightforward: a large <code>if</code>/<code>elif</code>/<code>else</code> chain (or a dictionary mapping node types to handler methods) that directly calls the corresponding method. This approach, known as <strong>single dispatch</strong>, is chosen for its transparency and ease of debugging for learners. When <code>evaluate</code> encounters a <code>BinaryExpression</code> node, it will:</p>\n<ol>\n<li>Recursively call <code>evaluate</code> on the <code>left</code> child node to obtain its value.</li>\n<li>Recursively call <code>evaluate</code> on the <code>right</code> child node to obtain its value.</li>\n<li>Apply the specific operator (e.g., <code>+</code>, <code>*</code>) to those two values, performing necessary type checks.</li>\n</ol>\n<p>The <code>environment</code> parameter is passed through every recursive call, allowing all nodes access to the current set of variable bindings. For certain constructs (like blocks or function calls), a new environment will be created and passed down for the evaluation of specific sub-trees.</p>\n<h3 id=\"internal-behavior-and-algorithm\">Internal Behavior and Algorithm</h3>\n<p>The evaluator&#39;s internal logic is organized around the different categories of AST nodes. The following numbered steps describe the generic algorithms for each major category. These steps are implemented in the handler methods that <code>evaluate</code> dispatches to.</p>\n<p><strong>1. Literal Nodes (e.g., <code>Literal</code> for <code>5</code>, <code>&quot;hello&quot;</code>, <code>true</code>, <code>nil</code>)</strong></p>\n<ul>\n<li><strong>Input</strong>: A node containing a raw value.</li>\n<li><strong>Process</strong>: No computation is needed. The value stored in the node is the runtime value.</li>\n<li><strong>Output</strong>: Return the node&#39;s value directly.</li>\n</ul>\n<p><strong>2. Grouping Expressions (e.g., <code>Grouping</code> for <code>(5 + 3)</code>)</strong></p>\n<ul>\n<li><strong>Input</strong>: A node with a single <code>expression</code> child.</li>\n<li><strong>Process</strong>: The parentheses themselves don&#39;t alter the semantics; they only affect parsing precedence. Therefore, evaluate the inner expression.</li>\n<li><strong>Algorithm</strong>:<ol>\n<li>Call <code>evaluate</code> on the <code>expression</code> child node.</li>\n<li>Return the result from that evaluation.</li>\n</ol>\n</li>\n<li><strong>Output</strong>: The value of the inner expression.</li>\n</ul>\n<p><strong>3. Unary Expressions (e.g., <code>Unary</code> for <code>-5</code> or <code>!true</code>)</strong></p>\n<ul>\n<li><strong>Input</strong>: A node with an <code>operator</code> (e.g., <code>-</code>, <code>!</code>) and a <code>right</code> operand child.</li>\n<li><strong>Process</strong>: Evaluate the operand, then apply the unary operator.</li>\n<li><strong>Algorithm</strong>:<ol>\n<li>Call <code>evaluate</code> on the <code>right</code> child node to obtain the operand value.</li>\n<li><strong>Type Check</strong>: Verify the operand type is valid for the operator (e.g., <code>-</code> requires a number).</li>\n<li><strong>Apply Operator</strong>:<ul>\n<li>For <code>-</code> (negation): Return the arithmetic negation of the operand (<code>-operand_value</code>).</li>\n<li>For <code>!</code> (logical NOT): Return the logical negation according to the language&#39;s <strong>truthiness</strong> rules (typically, <code>false</code> for truthy values, <code>true</code> for falsy values like <code>nil</code> and <code>false</code>).</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><strong>Output</strong>: The resulting value.</li>\n</ul>\n<p><strong>4. Binary Expressions (e.g., <code>Binary</code> for <code>3 + 4</code>, <code>5 &gt; 2</code>, <code>&quot;a&quot; == &quot;a&quot;</code>)</strong></p>\n<ul>\n<li><strong>Input</strong>: A node with <code>left</code> and <code>right</code> child nodes and an <code>operator</code>.</li>\n<li><strong>Process</strong>: Evaluate both operands, then apply the binary operator, which may be arithmetic, comparison, or equality.</li>\n<li><strong>Algorithm</strong>:<ol>\n<li>Call <code>evaluate</code> on the <code>left</code> child node.</li>\n<li>Call <code>evaluate</code> on the <code>right</code> child node.</li>\n<li><strong>Type Check</strong>: Verify the operand types are compatible with the operator (e.g., <code>+</code> works on numbers or strings, <code>&lt;</code> works on numbers).</li>\n<li><strong>Apply Operator</strong>:<ul>\n<li><strong>Arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)</strong>: Perform the corresponding mathematical operation. For <code>+</code>, if both operands are strings, perform concatenation. For <code>/</code>, check for division by zero.</li>\n<li><strong>Comparison (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>)</strong>: Compare the operands and return a boolean.</li>\n<li><strong>Equality (<code>==</code>, <code>!=</code>)</strong>: Compare for equality based on value and type. <code>nil</code> is only equal to <code>nil</code>.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><strong>Output</strong>: The result (a number, string, or boolean).</li>\n</ul>\n<p><strong>5. Logical Expressions (e.g., <code>Logical</code> for <code>a and b</code>, <code>x or y</code>)</strong></p>\n<ul>\n<li><strong>Input</strong>: A node with <code>left</code> and <code>right</code> child nodes and an <code>operator</code> (<code>and</code> or <code>or</code>).</li>\n<li><strong>Process</strong>: Implement <strong>short-circuit evaluation</strong>. The right operand is only evaluated if necessary.</li>\n<li><strong>Algorithm</strong>:<ol>\n<li>Call <code>evaluate</code> on the <code>left</code> child node.</li>\n<li>Determine the <strong>truthiness</strong> of the left result.</li>\n<li>For <code>and</code>: If the left is falsy, return the left value immediately (short-circuit). Otherwise, evaluate the right operand and return its value.</li>\n<li>For <code>or</code>: If the left is truthy, return the left value immediately (short-circuit). Otherwise, evaluate the right operand and return its value.</li>\n</ol>\n</li>\n<li><strong>Output</strong>: The value of the left or right operand (not necessarily a boolean; the operator returns the operand value that determined the outcome, which preserves semantics for values like <code>nil</code> or <code>0</code>).</li>\n</ul>\n<p><strong>6. Variable Expressions (e.g., <code>Variable</code> for <code>x</code>)</strong></p>\n<ul>\n<li><strong>Input</strong>: A node with a variable <code>name</code>.</li>\n<li><strong>Process</strong>: Look up the variable&#39;s value in the current environment chain.</li>\n<li><strong>Algorithm</strong>:<ol>\n<li>Call <code>env.get(name)</code>.</li>\n<li>If the name is found in the environment chain, return the associated value.</li>\n<li>If the name is not defined in any enclosing environment, raise an <code>UndefinedVariableError</code> with the variable name.</li>\n</ol>\n</li>\n<li><strong>Output</strong>: The value bound to the variable.</li>\n</ul>\n<p><strong>7. Assignment Expressions (e.g., <code>Assign</code> for <code>x = 10</code>)</strong></p>\n<ul>\n<li><strong>Input</strong>: A node with a variable <code>name</code> and a <code>value</code> expression child.</li>\n<li><strong>Process</strong>: Evaluate the right-hand side expression and update the variable&#39;s binding in the environment.</li>\n<li><strong>Algorithm</strong>:<ol>\n<li>Call <code>evaluate</code> on the <code>value</code> child node to obtain the value to assign.</li>\n<li>Call <code>env.assign(name, value)</code> to update the existing variable binding in the nearest enclosing scope where <code>name</code> is defined.</li>\n<li>If <code>env.assign</code> raises an error (variable not defined), propagate it.</li>\n<li>Return the assigned value (this allows assignments to be used within larger expressions, e.g., <code>y = (x = 5) + 2</code>).</li>\n</ol>\n</li>\n<li><strong>Output</strong>: The assigned value.</li>\n</ul>\n<p><strong>8. Call Expressions (e.g., <code>Call</code> for <code>add(1, 2)</code>)</strong></p>\n<ul>\n<li><strong>Input</strong>: A node with a <code>callee</code> expression (usually a <code>Variable</code> referring to a function), a list of <code>arguments</code> expression nodes, and a closing parenthesis token (for error reporting).</li>\n<li><strong>Process</strong>: Evaluate the callee and each argument, then invoke the function.</li>\n<li><strong>Algorithm</strong>:<ol>\n<li>Call <code>evaluate</code> on the <code>callee</code> node. The result should be a <code>FunctionValue</code> (or other callable). If not, raise a <code>TypeError</code>.</li>\n<li>For each argument expression in <code>arguments</code>, call <code>evaluate</code> to get its value, resulting in a list of argument values.</li>\n<li><strong>Arity Check</strong>: Compare the number of argument values to the number of parameters in the function. If they don&#39;t match, raise an <code>ArgumentError</code>.</li>\n<li>Invoke the function&#39;s <code>call</code> method, passing the list of argument values. This method will handle creating a new environment, binding parameters, and executing the function body.</li>\n</ol>\n</li>\n<li><strong>Output</strong>: The value returned by the function call.</li>\n</ul>\n<p><strong>9. Control Flow Statements (e.g., <code>If</code>, <code>While</code>, <code>For</code>, <code>Return</code>)</strong></p>\n<ul>\n<li>These are technically &quot;statements&quot; that do not produce a value in the same way expressions do. Their evaluation is detailed in the <strong>Control Flow Executor</strong> component section. However, the core evaluator&#39;s dispatch will route to handlers for these nodes, which typically evaluate conditions and manage the execution of statement blocks, possibly signaling <strong>non-local exits</strong> (like <code>return</code>).</li>\n</ul>\n<blockquote>\n<p>The recursive descent is visually captured in the flowchart: <img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fflowchart-eval-expr.svg\" alt=\"Flowchart: Expression Evaluation Dispatch\">. The flow starts at <code>Evaluate(node, env)</code>, branches based on <code>node.type</code>, and shows the recursive calls for operands before applying the operator.</p>\n</blockquote>\n<h3 id=\"adr-expression-dispatch-strategy\">ADR: Expression Dispatch Strategy</h3>\n<blockquote>\n<p><strong>Decision: Single Dispatch via Type Checking in <code>evaluate</code></strong></p>\n<ul>\n<li><strong>Context</strong>: The evaluator must handle over a dozen distinct AST node types, each requiring different evaluation logic. We need a clear, maintainable way to route nodes to the correct handler that is appropriate for an educational implementation.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Single Dispatch Function</strong>: A central <code>evaluate</code> function with a large <code>if</code>/<code>elif</code> chain (or dictionary lookup) that checks <code>node.type</code> and calls a corresponding method (e.g., <code>_visit_binary</code>).</li>\n<li><strong>Visitor Pattern</strong>: Define a <code>Visitor</code> interface with a <code>visit_X</code> method for each node type. Each AST node class has an <code>accept(visitor)</code> method that calls the appropriate <code>visit_X</code> on the visitor. The evaluator implements this visitor interface.</li>\n<li><strong>Double Dispatch (Dynamic Dispatch)</strong>: Rely on the language&#39;s method overriding. Define an abstract <code>evaluate</code> method on the base <code>ASTNode</code> class and override it in each concrete node subclass. The evaluator would just call <code>node.evaluate(env)</code>.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We chose <strong>Option 1 (Single Dispatch Function)</strong>.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Simplicity and Transparency</strong>: For learners, seeing all dispatch logic in one place (<code>evaluate</code>) is easier to understand and debug than the indirection of the Visitor pattern or the distributed logic of double dispatch. The control flow is explicit.</li>\n<li><strong>Separation of Concerns</strong>: The AST nodes remain plain data structures (immutable AST), free of any evaluation logic. This keeps the parser simple and the data model clean. The evaluation logic is centralized in the <code>Evaluator</code> class.</li>\n<li><strong>Avoiding Language Pitfalls</strong>: In dynamically-typed languages like Python or JavaScript, implementing double dispatch requires careful setup of class hierarchies and can be confusing. The single dispatch function is idiomatic and straightforward.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Pros</strong>: Easy to follow, modify, and log. The evaluator is self-contained. Adding a new node type requires adding one branch to the <code>if</code> chain and one handler method.</li>\n<li><strong>Cons</strong>: The <code>evaluate</code> function can become long (though it remains linear). It violates the Open/Closed principle if we were building a large, extensible system—but for a learner&#39;s interpreter, this is acceptable.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single Dispatch Function</td>\n<td>Simple, transparent, keeps nodes as data.</td>\n<td>Large dispatch function, manual type checking.</td>\n<td>✅ Yes</td>\n</tr>\n<tr>\n<td>Visitor Pattern</td>\n<td>Extensible, clean separation, encapsulates logic.</td>\n<td>More complex, indirect, requires visitor interface.</td>\n<td></td>\n</tr>\n<tr>\n<td>Double Dispatch (Dynamic)</td>\n<td>Polymorphic, elegant.</td>\n<td>Evaluation logic scattered across node classes, complicates AST data model.</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚡ <strong>Pitfall: Forgetting to Return Values from Handlers</strong></p>\n<ul>\n<li><strong>Description</strong>: In the handler for a binary expression, you correctly evaluate the left and right operands but forget to <code>return</code> the result of the operation, causing the function to implicitly return <code>None</code> (or <code>nil</code>).</li>\n<li><strong>Why it&#39;s wrong</strong>: This leads to mysterious <code>None</code> values propagating up the tree, causing type errors or incorrect program output. For example, <code>5 + 3</code> evaluates to <code>None</code>.</li>\n<li><strong>Fix</strong>: Ensure every branch of the <code>evaluate</code> function and every handler method explicitly returns a value. For statement nodes that don&#39;t produce a value (like <code>print</code>), return a designated <code>nil</code> value.</li>\n</ul>\n<p>⚡ <strong>Pitfall: Incorrect Recursion Base Case</strong></p>\n<ul>\n<li><strong>Description</strong>: The recursive <code>evaluate</code> function lacks a proper base case for literal nodes, causing infinite recursion (e.g., trying to treat a literal as a compound node with children).</li>\n<li><strong>Why it&#39;s wrong</strong>: The program crashes with a stack overflow or infinite loop.</li>\n<li><strong>Fix</strong>: Literal nodes (and other primitive nodes like <code>Variable</code>) are the leaves of the AST. Their handlers should return a value without making further recursive calls to <code>evaluate</code> on non-existent children.</li>\n</ul>\n<p>⚡ <strong>Pitfall: Misunderstanding Truthiness Rules</strong></p>\n<ul>\n<li><strong>Description</strong>: Implementing logical operators (<code>and</code>, <code>or</code>) or conditionals (<code>if</code>, <code>while</code>) using strict boolean-only checks, rather than the language&#39;s defined <strong>truthiness</strong> (where <code>0</code>, <code>&quot;&quot;</code>, <code>nil</code> are falsy, everything else is truthy).</li>\n<li><strong>Why it&#39;s wrong</strong>: Programs behave incorrectly. For example, <code>if (0) { print &quot;true&quot;; }</code> might incorrectly execute the block.</li>\n<li><strong>Fix</strong>: Implement a helper function <code>is_truthy(value)</code> that returns a boolean based on the language&#39;s truthiness rules. Use this function consistently for all logical and conditional evaluations.</li>\n</ul>\n<p>⚡ <strong>Pitfall: Not Propagating the Environment</strong></p>\n<ul>\n<li><strong>Description</strong>: Forgetting to pass the current <code>environment</code> parameter in a recursive call to <code>evaluate</code> for a child node, or creating a new environment for a block but not passing it down.</li>\n<li><strong>Why it&#39;s wrong</strong>: Variable lookup fails because child nodes cannot access the correct bindings, leading to undefined variable errors even for defined variables.</li>\n<li><strong>Fix</strong>: Ensure every recursive call to <code>evaluate</code> includes the appropriate environment object. For constructs that create a new scope (like a block), create the new environment and use it for evaluating the block&#39;s statements.</li>\n</ul>\n<p>⚡ <strong>Pitfall: Side-Effecting Operators on Immutable Values</strong></p>\n<ul>\n<li><strong>Description</strong>: In languages like Python, some values (e.g., numbers, strings) are immutable. However, a learner might incorrectly try to modify the value returned from a child evaluation, expecting it to change the original variable.</li>\n<li><strong>Why it&#39;s wrong</strong>: This misunderstanding doesn&#39;t cause runtime errors but leads to incorrect mental models. The evaluator should treat all values as immutable; assignment is handled by updating the environment, not the value itself.</li>\n<li><strong>Fix</strong>: Emphasize that evaluation produces <em>new</em> values, not modifying existing ones. For example, <code>a + 1</code> evaluates to a new number; it does not change the value stored in <code>a</code>.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Expression Dispatch</td>\n<td>Large <code>if</code>/<code>elif</code> chain in <code>evaluate</code></td>\n<td>Dictionary mapping node type strings to method objects</td>\n</tr>\n<tr>\n<td>Value Representation</td>\n<td>Python&#39;s built-in types (<code>int</code>, <code>str</code>, <code>bool</code>, <code>None</code>)</td>\n<td>Custom <code>RuntimeValue</code> wrapper classes with type tags</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Raise custom exception classes (<code>RuntimeError</code> subclasses)</td>\n<td>Use a result type (e.g., <code>Result</code> monad) to propagate errors</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>The Core Evaluator resides in its own module, separate from parsing and environment management.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>tree_walker/\n  interpreter.py          # Main Interpreter class, coordinates parsing and evaluation\n  evaluator.py            # Evaluator class (this component)\n  environment.py          # Environment class\n  ast_nodes.py            # AST node class definitions (from parser)\n  errors.py               # Custom exception definitions (RuntimeError, etc.)\n  main.py                 # CLI entry point</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>Here is the complete, ready-to-use code for the custom exception classes, which are prerequisites for the evaluator. Place this in <code>errors.py</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all runtime errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.message)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UndefinedVariableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when trying to access a variable that is not defined.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, variable_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Undefined variable '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">variable_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'.\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when an operation is applied to an inappropriate type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DivisionByZeroError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised on division by zero.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, token):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Division by zero.\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArgumentError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when a function is called with wrong number of arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments but got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ControlFlowSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base for non-local control flow (break, continue, return).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreakSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a break statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ContinueSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a continue statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ReturnSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a return statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>Below is the skeleton for the <code>Evaluator</code> class in <code>evaluator.py</code>. It includes the main dispatch method and stubs for each node type handler, with detailed TODO comments mapping to the algorithm steps described earlier.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># evaluator.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RuntimeError</span><span style=\"color:#E1E4E8\">, UndefinedVariableError, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DivisionByZeroError, ArgumentError, ControlFlowSignal,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BreakSignal, ContinueSignal, ReturnSignal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Assume AST node classes are imported, e.g.:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># from ast_nodes import (</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#     Literal, Grouping, Unary, Binary, Logical,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#     Variable, Assign, Call, If, While, For, Return, ...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recursively evaluates AST nodes to produce runtime values.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Main dispatch method. Routes based on node type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement dispatch based on node.type.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Use a large if/elif chain or a dictionary mapping.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For each node type, call the corresponding _visit_ method.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Example:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # if node.type == 'literal':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     return self._visit_literal(node, env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # elif node.type == 'binary':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     return self._visit_binary(node, env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # ...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Remember to pass the environment `env` to each handler.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # --- Expression Handlers ---</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_literal</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a literal node (number, string, boolean, nil).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Literal nodes already contain the value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return node.value directly.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_grouping</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a grouping node (parenthesized expression).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: The grouping node has an 'expression' child.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Recursively evaluate that expression by calling self.evaluate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return the result.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_unary</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a unary expression (-, !).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate the right operand (node.right) by calling self.evaluate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check the operator (node.operator).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   If operator is '-':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     - Ensure the operand is a number (int or float). If not, raise TypeError.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     - Return -operand.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   If operator is '!':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     - Return the logical NOT of the operand using the language's truthiness rules.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #       (Hint: Use a helper `is_truthy` method.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_binary</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a binary expression (+, -, *, /, ==, !=, &#x3C;, &#x3C;=, >, >=).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate left operand (node.left) by calling self.evaluate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Evaluate right operand (node.right) by calling self.evaluate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check the operator (node.operator).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Arithmetic operators (+, -, *, /):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     - For +, if both operands are numbers, add; if both are strings, concatenate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #       Otherwise, raise TypeError.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     - For -, *, /: Ensure both operands are numbers. For /, check for division by zero.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Comparison operators (&#x3C;, &#x3C;=, >, >=):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     - Ensure both operands are numbers. Compare and return boolean.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Equality operators (==, !=):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     - Compare values for equality. Note: nil is only equal to nil.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return the result.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_logical</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a logical expression (and, or) with short-circuiting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate left operand (node.left) by calling self.evaluate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Determine truthiness of left value (use `is_truthy` helper).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If operator is 'and':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If left is falsy, return left value (short-circuit).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Otherwise, evaluate right operand and return its value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If operator is 'or':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If left is truthy, return left value (short-circuit).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Otherwise, evaluate right operand and return its value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_variable</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a variable expression (look up by name).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get variable name from node.name.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call env.get(name) to retrieve the value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If env.get raises an UndefinedVariableError, propagate it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return the value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_assign</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate an assignment expression (name = value).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate the value expression (node.value) by calling self.evaluate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call env.assign(node.name, value) to update the variable binding.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return the assigned value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # --- Statement Handlers (Milestone 3 &#x26; 4) ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # These are often called by evaluate but may return None (or a control flow signal).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_if</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate an if statement (with optional else).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate the condition expression (node.condition) by calling self.evaluate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check truthiness of the condition result.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If truthy, evaluate the then branch (node.then_branch).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Otherwise, if an else branch exists (node.else_branch), evaluate it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return None (or the value of the last executed statement if you want to support expression statements).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_while</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a while loop.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: While True:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Evaluate the condition (node.condition). If falsy, break.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Try to evaluate the body (node.body) in a try-except that catches BreakSignal and ContinueSignal.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If BreakSignal is caught, break out of the loop.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If ContinueSignal is caught, continue to next iteration (skip any remaining code in body).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return None.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Note: For loops are typically desugared into while loops in the parser or evaluator.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # If you implement _visit_for, it would create a while loop structure and evaluate it.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _visit_return</span><span style=\"color:#E1E4E8\">(self, node, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a return statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: If node.value exists, evaluate it to get the return value; otherwise use nil.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Raise a ReturnSignal with the value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This signal will be caught by the function call handler.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # --- Helper Methods ---</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_truthy</span><span style=\"color:#E1E4E8\">(self, value) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Determine truthiness of a runtime value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return False for nil and False, True for everything else.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # (Adjust based on your language's truthiness rules; e.g., 0 and \"\" might be truthy.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For simplicity, we follow Lox/Python-like rules: nil and false are falsy.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-python\">E. Language-Specific Hints (Python)</h4>\n<ul>\n<li><strong>Type Checking</strong>: Use <code>isinstance(value, (int, float))</code> to check for numbers. For strings, use <code>isinstance(value, str)</code>. Avoid checking for exact <code>type(value) == int</code> to allow floats.</li>\n<li><strong>Error Reporting</strong>: The <code>token</code> parameter in exceptions should be the token from the AST node (often stored as <code>node.token</code>). Use it to report line numbers in error messages.</li>\n<li><strong>Truthiness Helper</strong>: In <code>is_truthy</code>, you can simply return <code>value not in (None, False)</code>. Note: In Python, <code>0</code> and <code>&quot;&quot;</code> are falsy, but many interpreter implementations treat them as truthy to match the target language&#39;s semantics. Choose your rule and be consistent.</li>\n<li><strong>Handling <code>nil</code></strong>: Represent <code>nil</code> as Python&#39;s <code>None</code>.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint-milestone-1-expression-evaluation\">F. Milestone Checkpoint (Milestone 1: Expression Evaluation)</h4>\n<p>After implementing the expression handlers (<code>_visit_literal</code>, <code>_visit_grouping</code>, <code>_visit_unary</code>, <code>_visit_binary</code>, <code>_visit_logical</code>), you should be able to evaluate arithmetic and logical expressions.</p>\n<p><strong>Test Program:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;        </span><span style=\"color:#6A737D\">// Should print 16</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">print</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> ></span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">);           </span><span style=\"color:#6A737D\">// Should print false</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> ></span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">and</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// Should print true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#9ECBFF\">\"Hello, \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#9ECBFF\"> \"world!\"</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Should print \"Hello, world!\"</span></span></code></pre></div>\n\n<p><strong>Expected Output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>16\nfalse\ntrue\nHello, world!</code></pre></div>\n\n<p><strong>Signs of Trouble:</strong></p>\n<ul>\n<li>If you get <code>None</code> printed, check that your handlers are returning values.</li>\n<li>If you get a type error on string concatenation, verify your <code>+</code> operator handling.</li>\n<li>If logical operators don&#39;t short-circuit, ensure you are using <code>is_truthy</code> and returning the operand value, not a forced boolean.</li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>All expressions evaluate to <code>None</code></td>\n<td>Forgetting to <code>return</code> values in handlers.</td>\n<td>Add print statements at the start and end of each handler to see what is returned.</td>\n<td>Ensure every handler ends with <code>return some_value</code>.</td>\n</tr>\n<tr>\n<td>Infinite recursion on literals</td>\n<td>Missing base case in <code>evaluate</code>; literal nodes incorrectly treated as compound.</td>\n<td>Check the dispatch logic: is <code>node.type</code> being compared correctly?</td>\n<td>Add a clause for <code>&#39;literal&#39;</code> that returns <code>node.value</code>.</td>\n</tr>\n<tr>\n<td>Variable lookup fails inside binary expression</td>\n<td>Environment not passed to child evaluations.</td>\n<td>In <code>_visit_binary</code>, print the <code>env</code> before evaluating left and right.</td>\n<td>Pass <code>env</code> to the recursive <code>self.evaluate</code> calls.</td>\n</tr>\n<tr>\n<td><code>and</code>/<code>or</code> always evaluate both sides</td>\n<td>Not implementing short-circuiting.</td>\n<td>Check if <code>_visit_logical</code> evaluates the right operand unconditionally.</td>\n<td>Only evaluate the right operand if the left does not determine the outcome.</td>\n</tr>\n</tbody></table>\n<h2 id=\"component-design-environment-manager\">Component Design: Environment Manager</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 2</p>\n</blockquote>\n<p>The Environment Manager is the <strong>dynamic memory</strong> of our interpreter—the system responsible for storing, retrieving, and managing the lifetime of all named values (variables) as the program executes. While the AST represents the static structure of the program and the evaluator represents the execution logic, the environment represents the <strong>mutable runtime state</strong> that changes with every assignment and function call. The central architectural challenge is implementing <strong>lexical scoping</strong>—the rule that a variable&#39;s visibility is determined by its position in the source code&#39;s nested block structure—in a way that is both correct and intuitive for learners.</p>\n<h3 id=\"mental-model-stack-of-ledgers\">Mental Model: Stack of Ledgers</h3>\n<p>Imagine you&#39;re an accountant working with a <strong>stack of accounting ledgers</strong>. Each ledger represents a distinct scope in your program: the topmost ledger is your current workspace (like the function you&#39;re inside), beneath it is the ledger for the enclosing function, and at the bottom is the master company ledger (the global scope). When you need to look up a transaction (variable), you first check the topmost ledger. If it&#39;s not there, you look in the ledger below it, continuing down the stack until you find the transaction or reach the bottom (resulting in an &quot;undefined variable&quot; error).</p>\n<p>When you start a new project (enter a new scope), you place a fresh, empty ledger on top of the stack. You record new transactions (define variables) in this top ledger. When the project finishes (scope exits), you remove that ledger from the stack—all transactions recorded there are forgotten, but transactions in lower ledgers remain intact. This model elegantly captures <strong>lexical scoping</strong>: inner scopes can see outer scopes&#39; variables (by looking down the stack), but outer scopes cannot see inner scopes&#39; variables (ledgers above them are inaccessible). The model also explains <strong>shadowing</strong>: if you record a transaction with the same name in an inner ledger, it hides (shadows) any transaction with that name in lower ledgers.</p>\n<h3 id=\"interface-define-get-set\">Interface: Define, Get, Set</h3>\n<p>The Environment Manager exposes three fundamental operations that correspond to the three ways a program interacts with variables: declaring a new variable (<code>var x = 5</code>), reading a variable&#39;s value (<code>print x</code>), and updating an existing variable (<code>x = 10</code>). Each operation has specific semantics and error conditions that enforce the language&#39;s scoping rules.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>define(name, value)</code></td>\n<td><code>name: str</code><br><code>value: RuntimeValue</code></td>\n<td><code>None</code></td>\n<td>Creates a new binding of <code>name</code> to <code>value</code> in the <em>current</em> environment&#39;s store. This corresponds to variable declaration (<code>var</code>, <code>let</code>, or function parameter binding). The operation always succeeds—it will overwrite any existing binding of the same name in the current environment (shadowing).</td>\n</tr>\n<tr>\n<td><code>get(name)</code></td>\n<td><code>name: str</code></td>\n<td><code>RuntimeValue</code></td>\n<td>Retrieves the value bound to <code>name</code> by searching the environment chain. Starts in the current environment; if not found, recursively searches the parent environment (and its parents) until the name is found. If the name is not bound in any environment in the chain, raises an <code>UndefinedVariableError</code> with the name and token location.</td>\n</tr>\n<tr>\n<td><code>assign(name, value)</code></td>\n<td><code>name: str</code><br><code>value: RuntimeValue</code></td>\n<td><code>None</code></td>\n<td>Updates the binding of an <em>existing</em> variable named <code>name</code> to a new <code>value</code>. Searches the environment chain (same as <code>get</code>) to find the <em>first</em> environment where <code>name</code> is defined, then updates that binding. If <code>name</code> is not defined in any environment in the chain, raises an <code>UndefinedVariableError</code>. This corresponds to assignment statements (<code>x = 10</code>).</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The critical distinction between <code>define</code> and <code>assign</code> is that <code>define</code> creates a binding in the <em>current</em> environment regardless of what exists in outer scopes (enabling shadowing), while <code>assign</code> updates an existing binding by walking the chain (respecting lexical scoping). This separation is what makes lexical scoping work correctly.</p>\n</blockquote>\n<h3 id=\"internal-behavior\">Internal Behavior</h3>\n<p>The environment manager implements lexical scoping through a <strong>linked chain of dictionaries</strong>. Each environment object contains a dictionary (<code>store</code>) mapping names to values, and an optional reference to a <code>parent</code> environment. The chain forms a tree structure, typically linear during simple execution but branching when multiple functions are defined in the same scope.</p>\n<h4 id=\"variable-resolution-algorithm-walking-the-chain\">Variable Resolution Algorithm (Walking the Chain)</h4>\n<p>When looking up a variable (for <code>get</code> or <code>assign</code>), the interpreter follows this recursive procedure:</p>\n<ol>\n<li><strong>Check current store:</strong> Look for <code>name</code> in the current environment&#39;s <code>store</code> dictionary.</li>\n<li><strong>Found locally:</strong> If present, return the associated value (for <code>get</code>) or update it (for <code>assign</code>).</li>\n<li><strong>Not found locally:</strong> If <code>name</code> is not in the current store, check if the environment has a <code>parent</code>.</li>\n<li><strong>Recurse upward:</strong> If a parent exists, repeat the process in the parent environment (effectively walking up the chain).</li>\n<li><strong>Reach global scope:</strong> If no parent exists (we&#39;re at the global environment) and the name is not found, the variable is undefined.</li>\n</ol>\n<p>This algorithm naturally implements lexical scoping because the parent relationship mirrors the syntactic nesting of scopes in the source code. The environment chain is constructed such that each new scope&#39;s environment has its enclosing scope&#39;s environment as its parent.</p>\n<h4 id=\"scope-creation-and-teardown\">Scope Creation and Teardown</h4>\n<p>Scopes are created and destroyed dynamically during execution:</p>\n<ul>\n<li><strong>Entering a block/function:</strong> When a block (like a function body or <code>if</code> branch) is entered, the evaluator creates a new environment with the current environment as its parent, then evaluates statements within that new environment.</li>\n<li><strong>Exiting a block/function:</strong> When the block finishes, the evaluator discards the environment (by returning to the previous environment). All variable bindings local to that block become inaccessible—this is how local variables are automatically &quot;cleaned up.&quot;</li>\n<li><strong>Function calls:</strong> A function call creates a new environment whose parent is the function&#39;s <strong>closure environment</strong> (the environment where the function was <em>defined</em>, not where it was <em>called</em>). This is the mechanism that enables closures.</li>\n</ul>\n<p>The following diagram illustrates how variable lookup traverses the environment chain:</p>\n<p><img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fenv-chain-lookup.svg\" alt=\"Environment Chain Lookup\"></p>\n<h3 id=\"adr-environment-chain-vs-flat-frame\">ADR: Environment Chain vs. Flat Frame</h3>\n<blockquote>\n<p><strong>Decision: Implement Lexical Scoping via Linked Environment Chain</strong></p>\n</blockquote>\n<ul>\n<li><p><strong>Context:</strong> We need a mechanism to manage variable bindings that correctly implements lexical (static) scoping. The interpreter must support nested scopes (blocks, functions), variable shadowing, and closures. The implementation should be clear and educational for learners.</p>\n</li>\n<li><p><strong>Options Considered:</strong></p>\n<ol>\n<li><strong>Linked Environment Chain:</strong> Each scope is represented by an <code>Environment</code> object with a <code>store</code> dictionary and a <code>parent</code> pointer. Variable lookup walks the parent chain.</li>\n<li><strong>Flat Frame with Display Array:</strong> All local variables for all active scopes are stored in a single contiguous array (frame). A separate &quot;display&quot; array stores pointers to the start of each lexical level&#39;s segment. Variable access calculates offsets.</li>\n<li><strong>Single Global Dictionary with Lexical Depth Tags:</strong> A single dictionary maps <code>(name, lexical_depth)</code> pairs to values. The current lexical depth is tracked during evaluation.</li>\n</ol>\n</li>\n<li><p><strong>Decision:</strong> Implement the <strong>Linked Environment Chain</strong> (Option 1).</p>\n</li>\n<li><p><strong>Rationale:</strong></p>\n<ul>\n<li><strong>Conceptual clarity:</strong> The chain directly mirrors the mental model of nested scopes as a stack of ledgers. Learners can easily visualize and debug by following parent pointers.</li>\n<li><strong>Implementation simplicity:</strong> The chain requires minimal infrastructure—just a dictionary and a parent pointer. No complex offset calculations or depth tracking.</li>\n<li><strong>Natural support for closures:</strong> Storing the defining environment as a parent pointer in function objects directly implements closure capture without additional machinery.</li>\n<li><strong>Educational value:</strong> Understanding this model prepares learners for similar designs in real interpreters (like Python&#39;s frame objects) and introduces the important concept of parent-linked data structures.</li>\n</ul>\n</li>\n<li><p><strong>Consequences:</strong></p>\n<ul>\n<li><strong>Performance:</strong> Lookup time is O(n) where n is the depth of nesting (linear search up the chain). For deeply nested scopes, this is slower than the O(1) offset calculation of a flat frame.</li>\n<li><strong>Memory overhead:</strong> Each environment object incurs overhead for the dictionary and parent pointer. However, for an educational interpreter, this is acceptable.</li>\n<li><strong>Ease of debugging:</strong> The chain structure is easy to inspect—printing the chain shows all active bindings at each level.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Linked Environment Chain</td>\n<td>Intuitive, simple implementation, natural closures</td>\n<td>O(n) lookup time, per-environment overhead</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Flat Frame with Display</td>\n<td>O(1) lookup, memory-efficient</td>\n<td>Complex to implement, harder to debug</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Single Dictionary with Depth Tags</td>\n<td>Simple storage model</td>\n<td>Complex depth tracking, inefficient updates</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Incorrect Parent Chain Traversal</strong></p>\n<ul>\n<li><strong>Description:</strong> Forgetting to recursively check parent environments when a variable is not found locally, leading to &quot;undefined variable&quot; errors for variables that exist in outer scopes.</li>\n<li><strong>Why it&#39;s wrong:</strong> Breaks lexical scoping—inner scopes cannot access outer variables, making functions and nested blocks unusable.</li>\n<li><strong>Fix:</strong> Ensure <code>get</code> and <code>assign</code> methods contain a loop or recursion that continues searching via the <code>parent</code> pointer until either the variable is found or <code>parent</code> is <code>None</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Confusing Assignment with Definition</strong></p>\n<ul>\n<li><strong>Description:</strong> Using <code>define</code> instead of <code>assign</code> in assignment statements, causing a new local variable to be created that shadows an outer variable rather than updating the existing one.</li>\n<li><strong>Why it&#39;s wrong:</strong> Changes program semantics. For example, <code>x = x + 1</code> inside a function would create a new local <code>x</code> instead of updating the outer <code>x</code>, potentially causing unexpected behavior and infinite recursion in some cases.</li>\n<li><strong>Fix:</strong> Strictly separate the two operations: <code>define</code> only for variable declarations (<code>var</code>, <code>let</code>, parameters) and <code>assign</code> for assignment expressions (<code>=</code>).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Improper Scope Creation/Teardown</strong></p>\n<ul>\n<li><strong>Description:</strong> Forgetting to create a new environment when entering a block or function, or failing to restore the previous environment after exiting, causing variable bindings to leak or be lost.</li>\n<li><strong>Why it&#39;s wrong:</strong> Variables from different scopes interfere with each other, breaking isolation. Local variables might persist after their scope ends or overwrite outer variables.</li>\n<li><strong>Fix:</strong> Use a consistent pattern: before evaluating a block, create <code>new_env = Environment(parent=current_env)</code>, evaluate statements with <code>new_env</code>, then discard <code>new_env</code> (return to <code>current_env</code>). Consider implementing a context manager or try-finally pattern to ensure cleanup.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Mishandling Closure Environment Capture</strong></p>\n<ul>\n<li><strong>Description:</strong> Setting the parent of a function call&#39;s environment to the <em>caller&#39;s</em> environment instead of the function&#39;s <em>defining</em> environment.</li>\n<li><strong>Why it&#39;s wrong:</strong> Breaks closures—functions cannot access variables from their lexical scope if called from a different location.</li>\n<li><strong>Fix:</strong> Store the environment active when the function is <em>defined</em> as the function&#39;s <code>closure</code> property. When calling, create a new environment with <code>function.closure</code> as its parent.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Handling Undefined Variables Gracefully</strong></p>\n<ul>\n<li><strong>Description:</strong> Raising a generic exception or crashing with a stack trace when a variable is not found, making debugging difficult.</li>\n<li><strong>Why it&#39;s wrong:</strong> Learners need clear, actionable error messages that point to the exact location and name of the undefined variable.</li>\n<li><strong>Fix:</strong> Raise an <code>UndefinedVariableError</code> with a descriptive message including the variable name and line number (from the token). Ensure this exception is caught and presented cleanly by the interpreter.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Environment Storage</td>\n<td>Python <code>dict</code> for <code>store</code>, class attribute for <code>parent</code></td>\n<td>Custom hash map for performance, weak references for parent</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td>Raise custom exception classes with token context</td>\n<td>Add error code, suggestion hints, multilingual messages</td>\n</tr>\n<tr>\n<td>Debug Visualization</td>\n<td>Simple <code>__repr__</code> method printing store contents</td>\n<td>Interactive debugger with environment chain inspection</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>Add the environment manager to your project structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>tree-walker-interpreter/\n├── src/\n│   ├── interpreter.py          # Main Interpreter class\n│   ├── evaluator.py            # Core Evaluator class (from previous section)\n│   ├── environment.py          # Environment class (this component)\n│   ├── ast_nodes.py            # AST node definitions\n│   ├── runtime_errors.py       # Custom exception classes\n│   └── tokens.py               # Token class (from lexer)\n└── tests/\n    ├── test_environment.py\n    └── test_evaluation.py</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>The following complete code provides the foundation for the Environment Manager, including all custom error classes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># runtime_errors.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Custom runtime error classes for the interpreter.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all runtime errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.token:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"[Line </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.token.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">] RuntimeError: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"RuntimeError: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UndefinedVariableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when trying to access a variable that is not defined.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, variable_name, token):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Undefined variable '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">variable_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'.\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when operations are applied to incorrect types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DivisionByZeroError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when dividing by zero.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, token):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Division by zero.\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArgumentError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when function is called with wrong number of arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, token)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ControlFlowSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for non-local control flow (break, continue, return).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreakSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a break statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ContinueSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a continue statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ReturnSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a return statement with a value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># environment.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Environment manager for variable storage with lexical scoping.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> runtime_errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tokens </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Token</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    A lexical scoping environment mapping variable names to values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Attributes:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        store: Dictionary of variable bindings in this scope.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        parent: Parent environment (None for global scope).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, parent: Optional[</span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize a new environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            parent: The enclosing environment (for lexical scoping).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.store: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parent: Optional[Environment] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Define a new variable in the current environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Creates or overwrites a binding for `name` in this environment's store.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This corresponds to variable declaration (var, let, function parameters).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Variable name.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            value: Initial value.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement variable definition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Store the value in self.store with name as key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. No need to check for existing binding - shadowing is allowed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Retrieve the value of a variable by walking the environment chain.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Searches the current environment, then parent environments recursively.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Variable name to look up.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            The value bound to the variable.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            UndefinedVariableError: If the variable is not found in any environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                in the chain.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement variable lookup with chain walking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Check if name exists in self.store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. If found, return the value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. If not found and self.parent is not None, delegate to parent.get(name)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 4. If not found and self.parent is None, raise UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    Note: You'll need a Token to raise the error - for now use None,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    the evaluator will pass the actual token.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assign</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Update an existing variable's value by walking the environment chain.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Searches for the variable in the current environment, then parent</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        environments recursively, and updates the first binding found.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Variable name to assign to.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            value: New value.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            UndefinedVariableError: If the variable is not found in any environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                in the chain.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement variable assignment with chain walking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Check if name exists in self.store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. If found, update the value in self.store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. If not found and self.parent is not None, delegate to parent.assign(name, value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 4. If not found and self.parent is None, raise UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_at</span><span style=\"color:#E1E4E8\">(self, distance: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Advanced: Get a variable at a specific lexical depth.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This method is used for optimizing variable access in closures and is</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        not required for the basic implementation. It enables O(1) lookups</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        when the lexical depth is known (from resolver pass).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            distance: Number of environments to walk up (0 = current).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Variable name.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            The value bound to the variable at that depth.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Optional enhancement for later optimization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(distance):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> environment.parent </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> environment.parent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> environment.store.get(name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"String representation for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parent_repr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" -> </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.parent</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parent </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Environment(</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.store</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">parent_repr</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>Here&#39;s how to integrate the environment with variable and block nodes in the evaluator:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># evaluator.py (additions to the existing Evaluator class)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> runtime_errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> VariableExpr, BlockStmt, VarStmt, AssignExpr</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... existing code from previous section ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(self, node: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main dispatch method for AST evaluation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: The AST node to evaluate.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: The current environment for variable lookup.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            The result of evaluating the node.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add cases for variable-related nodes to the existing dispatch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(node, VariableExpr):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._evaluate_variable_expr(node, env)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(node, AssignExpr):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._evaluate_assign_expr(node, env)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(node, VarStmt):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._evaluate_var_stmt(node, env)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(node, BlockStmt):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._evaluate_block_stmt(node, env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # ... handle other node types from previous section ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_variable_expr</span><span style=\"color:#E1E4E8\">(self, node: VariableExpr, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate a variable expression (just the name).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: Variable expression node with 'name' and 'token' attributes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            The value bound to the variable name.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement variable expression evaluation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Call env.get(node.name) to retrieve the value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. If UndefinedVariableError is raised, catch it and re-raise with node.token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Return the retrieved value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_assign_expr</span><span style=\"color:#E1E4E8\">(self, node: AssignExpr, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate an assignment expression (name = value).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: Assignment expression with 'name', 'value', and 'token' attributes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            The assigned value (right-hand side).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement assignment expression evaluation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Evaluate the right-hand side expression (node.value) using self.evaluate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Call env.assign(node.name, value) to update the variable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. If UndefinedVariableError is raised, catch it and re-raise with node.token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 4. Return the assigned value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_var_stmt</span><span style=\"color:#E1E4E8\">(self, node: VarStmt, env: Environment) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate a variable declaration statement (var x = value).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: Variable statement with 'name', 'initializer', and 'token' attributes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            None (statements don't produce values).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement variable declaration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Evaluate the initializer expression if present (node.initializer)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    - If no initializer, use None/nil value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Call env.define(node.name, value) to create the binding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Return None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_block_stmt</span><span style=\"color:#E1E4E8\">(self, node: BlockStmt, env: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate a block of statements in a new nested environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: Block statement with 'statements' list attribute.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current environment (will become parent of new environment).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            The result of the last statement executed, or None if block is empty.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement block evaluation with scope creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Create a new environment with env as parent: block_env = Environment(env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Iterate through each statement in node.statements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Evaluate each statement using self.evaluate(statement, block_env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 4. If a statement raises ReturnSignal, BreakSignal, or ContinueSignal,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #    propagate it upward (don't catch it here)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 5. Return the result of the last statement, or None if no statements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li><strong>Python dictionaries:</strong> Use Python&#39;s built-in <code>dict</code> for the store—it&#39;s perfect for variable name to value mapping. Remember that dictionary keys must be strings (variable names).</li>\n<li><strong>None vs. nil:</strong> In Python, we can use <code>None</code> to represent the language&#39;s <code>nil</code> value. Be consistent throughout the interpreter.</li>\n<li><strong>Exception handling:</strong> When catching <code>UndefinedVariableError</code> in the evaluator to add token context, use <code>try-except</code> and re-raise with the node&#39;s token: <code>raise UndefinedVariableError(e.message, node.token) from e</code>.</li>\n<li><strong>Recursive parent traversal:</strong> Implement <code>get</code> and <code>assign</code> recursively for clarity, or use a while loop. Recursive implementation closely matches the algorithm description.</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the Environment Manager and integrating it with variable-related AST nodes, test with this program:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  var</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\">;  </span><span style=\"color:#6A737D\">// Shadows outer x</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  print x;     </span><span style=\"color:#6A737D\">// Should print 30</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  y </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 40</span><span style=\"color:#E1E4E8\">;      </span><span style=\"color:#6A737D\">// Updates outer y</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print x;       </span><span style=\"color:#6A737D\">// Should print 10 (outer x unchanged)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print y;       </span><span style=\"color:#6A737D\">// Should print 40</span></span></code></pre></div>\n\n<p><strong>Expected output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>30\n10\n40</code></pre></div>\n\n<p><strong>Run the test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/interpreter.py</span><span style=\"color:#9ECBFF\"> test_program.txt</span></span></code></pre></div>\n\n<p><strong>Signs of success:</strong></p>\n<ul>\n<li>Program executes without errors.</li>\n<li>Output matches exactly the expected values.</li>\n<li>The inner <code>x</code> shadows but doesn&#39;t affect the outer <code>x</code>.</li>\n<li>The assignment to <code>y</code> inside the block updates the outer <code>y</code>.</li>\n</ul>\n<p><strong>If something is wrong:</strong></p>\n<ul>\n<li><strong>Variable not found:</strong> Check that <code>get</code> walks the parent chain correctly.</li>\n<li><strong>Wrong value printed:</strong> Verify that <code>define</code> creates in current environment, <code>assign</code> updates in the correct environment.</li>\n<li><strong>Scope leak:</strong> Ensure the block creates a new environment with the correct parent.</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Undefined variable&quot; for variable that exists in outer scope</td>\n<td><code>get</code> not checking parent environments</td>\n<td>Add debug prints to <code>get</code> showing which environment is being checked</td>\n<td>Implement recursive parent lookup</td>\n</tr>\n<tr>\n<td>Assignment creates new variable instead of updating outer one</td>\n<td>Using <code>define</code> instead of <code>assign</code> in assignment evaluation</td>\n<td>Check <code>_evaluate_assign_expr</code> calls <code>env.assign</code> not <code>env.define</code></td>\n<td>Use correct method for assignment</td>\n</tr>\n<tr>\n<td>Variable value persists after block exits</td>\n<td>Not creating new environment for blocks</td>\n<td>Check <code>_evaluate_block_stmt</code> creates <code>Environment(env)</code></td>\n<td>Create new environment for each block</td>\n</tr>\n<tr>\n<td>Inner scope cannot access its own variables</td>\n<td>Parent chain reversed (child points to wrong parent)</td>\n<td>Print environment chain during lookup</td>\n<td>Ensure <code>Environment(parent)</code> gets correct parent</td>\n</tr>\n<tr>\n<td>All variables return <code>nil</code></td>\n<td>Forgetting to evaluate initializer expressions</td>\n<td>Check <code>_evaluate_var_stmt</code> evaluates <code>node.initializer</code></td>\n<td>Evaluate initializer before defining</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> 3</p>\n<p>This section details the component responsible for altering the linear flow of program execution. While the Core Evaluator processes expressions in a straightforward recursive descent, real programs require branching, repetition, and non-local jumps. The Control Flow Executor introduces these capabilities, allowing the interpreter to make decisions, loop over code blocks, and exit loops or functions early. This component must integrate seamlessly with the Environment Manager for scoped variable access and the Core Evaluator for condition evaluation, while handling disruptive jumps that violate the normal call-and-return pattern of recursion.</p>\n</blockquote>\n<h2 id=\"component-design-control-flow-executor\">Component Design: Control Flow Executor</h2>\n<h3 id=\"mental-model-railroad-switching-yard\">Mental Model: Railroad Switching Yard</h3>\n<p>Think of program execution as a train traveling along a single track—the sequence of statements. The <strong>Control Flow Executor</strong> acts as the <strong>railroad switching yard</strong>, dynamically rerouting the train based on signal conditions. A conditional (<code>if</code>/<code>else</code>) is a <strong>track switch</strong>: the condition is a signal light—if green (truthy), the train takes the main branch; if red (falsy), it takes the alternative siding (or proceeds straight if no <code>else</code> exists). Loops are <strong>circular spurs</strong>: the train enters a loop section, completes a lap (executes the loop body), and then returns to the loop&#39;s entrance checkpoint (the condition) to receive a new signal. If the signal remains green, it performs another lap; if red, it exits the spur and continues down the main line. Jump statements (<code>break</code>, <code>continue</code>, <code>return</code>) are <strong>emergency rerouting commands</strong> that override the normal track logic: a <code>break</code> command immediately escorts the train out of the entire loop spur and back to the main line, a <code>continue</code> command teleports it back to the loop&#39;s entrance checkpoint for the next signal check, and a <code>return</code> command stops the current train entirely and sends a result package back to the previous station (the calling function).</p>\n<p>This model clarifies the key challenge: normal recursion provides a simple &quot;enter, evaluate, exit&quot; linear path, but control flow requires short-circuiting this recursion. We need a mechanism to <em>signal</em> these emergency reroutes and <em>unwind</em> the execution stack until a component (the loop executor or function caller) catches the signal and acts accordingly.</p>\n<h3 id=\"interface-for-statements-and-jumps\">Interface for Statements and Jumps</h3>\n<p>Statement evaluation differs fundamentally from expression evaluation. Expressions <em>produce a value</em> (e.g., <code>3 + 4</code> yields <code>7</code>), while statements <em>perform an action</em> (e.g., <code>if (x) print(&quot;hi&quot;)</code>) and typically do not produce a value for the surrounding context. Consequently, the <code>Evaluator.evaluate</code> method, when processing a statement node, will usually return <code>None</code> (or <code>nil</code> in the runtime) to indicate the statement completed without a meaningful result. However, jump statements are special: they must communicate a <em>command</em> to alter the control flow, which cannot be represented by a normal return value.</p>\n<p>To handle this, we introduce a family of <strong>control flow signal objects</strong> that are thrown (using exception mechanisms in the implementation language) to unwind the call stack. This is a form of <strong>non-local exit</strong>. The <code>Evaluator.evaluate</code> method, when encountering a <code>break</code>, <code>continue</code>, or <code>return</code> statement, will raise a corresponding signal object instead of returning normally. The signal propagates up through the recursive evaluation calls until it is caught by a dedicated handler—a loop construct catches <code>BreakSignal</code> and <code>ContinueSignal</code>, while a function call catches <code>ReturnSignal</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Signal Type</th>\n<th>Purpose</th>\n<th>Carried Data</th>\n<th>Caught By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>BreakSignal</code></td>\n<td>Exit the nearest enclosing loop immediately.</td>\n<td>None</td>\n<td>Loop executor (<code>while</code>, <code>for</code>)</td>\n</tr>\n<tr>\n<td><code>ContinueSignal</code></td>\n<td>Skip the remainder of the current loop iteration and jump to the next condition check.</td>\n<td>None</td>\n<td>Loop executor (<code>while</code>, <code>for</code>)</td>\n</tr>\n<tr>\n<td><code>ReturnSignal</code></td>\n<td>Exit the current function immediately, providing a return value.</td>\n<td><code>value</code> (the return value, may be <code>nil</code>)</td>\n<td>Function call execution in <code>Evaluator._evaluate_call_expr</code></td>\n</tr>\n</tbody></table>\n<p>This table defines the core interface for jumps. The evaluator&#39;s method for statements (<code>_evaluate_if_stmt</code>, <code>_evaluate_while_stmt</code>, etc.) do not return these signals; they either complete normally (returning <code>None</code>) or raise a signal, which bubbles up. The loop and function call handlers are responsible for catching the appropriate signals and acting on them.</p>\n<h3 id=\"internal-behavior-for-loops-and-jumps\">Internal Behavior for Loops and Jumps</h3>\n<p>The control flow executor is not a separate class but a set of behaviors within the <code>Evaluator</code> class. The following numbered algorithms describe how the evaluator processes each control flow construct. These steps assume the evaluator is already inside the <code>evaluate</code> method and has dispatched to the specific handler based on the AST node type.</p>\n<h4 id=\"algorithm-for-if-statement-evaluation\">Algorithm for <code>if</code> Statement Evaluation</h4>\n<ol>\n<li><strong>Evaluate Condition:</strong> Call <code>evaluate(node.condition, env)</code>. This returns a runtime value.</li>\n<li><strong>Determine Truthiness:</strong> Apply the interpreter&#39;s <strong>truthiness</strong> rules to the condition value. In our language, the rules are: <code>nil</code> and <code>false</code> are falsy; every other value (including <code>0</code>, <code>&quot;&quot;</code>, and <code>true</code>) is truthy.</li>\n<li><strong>Choose Branch:</strong> If the condition is truthy, set <code>branch_to_execute = node.then_branch</code>. Otherwise, if an <code>else</code> branch exists (<code>node.else_branch</code> is not <code>None</code>), set <code>branch_to_execute = node.else_branch</code>. If no <code>else</code> branch exists, the <code>if</code> statement is complete; return <code>None</code>.</li>\n<li><strong>Execute Chosen Branch:</strong> Call <code>evaluate(branch_to_execute, env)</code>. This may be a single statement or a block. The result of this evaluation (which could be a raised signal) is returned/propagated directly.</li>\n</ol>\n<h4 id=\"algorithm-for-while-loop-evaluation\">Algorithm for <code>while</code> Loop Evaluation</h4>\n<p>Refer to the state machine diagram for a visual overview of this process: <img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fstate-machine-loop.svg\" alt=\"State Machine: While Loop Execution\"></p>\n<ol>\n<li><strong>Check Condition:</strong> Evaluate <code>node.condition</code> in the current environment. If the result is falsy, exit the loop (proceed to step 5).</li>\n<li><strong>Execute Body:</strong> Evaluate <code>node.body</code> in the current environment. This execution occurs within a <strong>protected context</strong> that catches <code>BreakSignal</code> and <code>ContinueSignal</code>.<ul>\n<li>If the body completes normally, proceed to step 3.</li>\n<li>If a <code>BreakSignal</code> is raised, catch it and immediately exit the loop (proceed to step 5). Do not propagate the signal further.</li>\n<li>If a <code>ContinueSignal</code> is raised, catch it and proceed directly to step 3 (next iteration). Do not propagate the signal further.</li>\n<li>If a <code>ReturnSignal</code> (or any other unhandled exception) is raised, do not catch it; allow it to propagate outward (this will exit the enclosing function).</li>\n</ul>\n</li>\n<li><strong>Loop Continuation:</strong> After completing the body (or catching a <code>continue</code>), the loop naturally returns to step 1 to re-evaluate the condition.</li>\n<li><strong>Loop Termination:</strong> When the condition evaluates to falsy, proceed to the next step.</li>\n<li><strong>Post-Loop:</strong> The <code>while</code> statement completes. Return <code>None</code>.</li>\n</ol>\n<h4 id=\"algorithm-for-for-loop-evaluation-via-desugaring\">Algorithm for <code>for</code> Loop Evaluation (via Desugaring)</h4>\n<p>Our interpreter implements <code>for</code> loops by <strong>desugaring</strong> them into equivalent <code>while</code> loop AST structures during the parsing phase (not during evaluation). This simplifies the evaluator, as it only needs to handle the primitive <code>while</code> construct. The desugaring follows this pattern:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>// Original: for (initializer; condition; increment) { body; }\n// Desugared:\n{\n    initializer;\n    while (condition) {\n        body;\n        increment;\n    }\n}</code></pre></div>\n<p>Note the addition of an outer block <code>{ ... }</code> to ensure any variables declared in the <code>initializer</code> are scoped to the loop. Therefore, the evaluator&#39;s <code>_evaluate_for_stmt</code> method simply evaluates the already-desugared AST. If the parser performs the desugaring, this method may not be needed at all. However, if evaluation-time desugaring is preferred, the algorithm is:</p>\n<ol>\n<li><strong>Create New Scope:</strong> Create a new environment <code>loop_env</code> with the current environment as its parent. This ensures the loop variable (if declared in the initializer) is scoped to the loop.</li>\n<li><strong>Execute Initializer:</strong> If <code>node.initializer</code> exists, evaluate it within <code>loop_env</code>.</li>\n<li><strong>Construct While Loop:</strong> Build a <code>while</code> loop AST node where:<ul>\n<li><code>condition</code> is <code>node.condition</code> (or a literal <code>true</code> if absent).</li>\n<li><code>body</code> is a block containing the original <code>node.body</code> followed by <code>node.increment</code> (if present).</li>\n</ul>\n</li>\n<li><strong>Evaluate While Loop:</strong> Evaluate the constructed <code>while</code> node within <code>loop_env</code>.</li>\n<li><strong>Return Result:</strong> Return the result (typically <code>None</code>) from the while loop evaluation.</li>\n</ol>\n<h4 id=\"algorithm-for-handling-return-statement\">Algorithm for Handling <code>return</code> Statement</h4>\n<p>The <code>return</code> statement is evaluated within the body of a function.</p>\n<ol>\n<li><strong>Evaluate Value:</strong> If <code>node.value</code> exists, evaluate it in the current environment to obtain the <code>return_value</code>. Otherwise, <code>return_value</code> is <code>nil</code>.</li>\n<li><strong>Raise Signal:</strong> Raise a <code>ReturnSignal</code> object, storing the <code>return_value</code> within it. This signal will propagate up through any nested blocks and loops until caught by the function call handler.</li>\n</ol>\n<h3 id=\"adr-handling-breakcontinue\">ADR: Handling Break/Continue</h3>\n<blockquote>\n<p><strong>Decision: Use Exception Mechanism for Control Flow Jumps</strong></p>\n<ul>\n<li><strong>Context</strong>: We need a way for <code>break</code> and <code>continue</code> statements inside a loop body to immediately affect the loop&#39;s execution, bypassing the normal sequential completion of the remaining statements in the body. This requires exiting multiple levels of nested AST evaluation calls (e.g., a <code>break</code> inside a block inside an <code>if</code> inside a loop must exit the loop, not just the <code>if</code>). We must choose a mechanism that cleanly unwinds the execution stack to the loop handler.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Exception/Signal Objects</strong>: Raise a special object (e.g., <code>BreakSignal</code>) and catch it at the loop level. This leverages the language&#39;s native stack-unwinding mechanism.</li>\n<li><strong>Explicit Status Flag Propagation</strong>: Have each evaluator method return a tuple <code>(value, status)</code>, where <code>status</code> indicates &quot;break&quot;, &quot;continue&quot;, &quot;normal&quot;, etc. The caller checks the status and propagates it upward manually.</li>\n<li><strong>Continuation Passing Style (CPS)</strong>: Transform the evaluator to accept explicit success and &quot;jump&quot; callbacks, completely avoiding deep call stacks. This is a more advanced functional technique.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We will use <strong>exception/signal objects</strong> (Option 1).</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Simplicity for Learners</strong>: Exception handling is a common, well-understood control flow mechanism in most imperative languages. The concept of &quot;throwing&quot; a signal and &quot;catching&quot; it at a higher level is intuitive for the railroad switching yard mental model.</li>\n<li><strong>Clean Separation of Concerns</strong>: The loop evaluation logic can be written as a clear <code>try-catch</code> block, isolating the jump-handling code. This makes the control flow explicit and easy to debug.</li>\n<li><strong>Performance is Secondary</strong>: For an educational tree-walking interpreter, raw performance is less critical than clarity. While exceptions can be slower than flag checking in tight loops, the overhead is acceptable for our goals.</li>\n<li><strong>Consistency with <code>return</code></strong>: The same mechanism naturally extends to <code>return</code> statements, which must unwind even further (out of function bodies). Using a unified signal class hierarchy (<code>ControlFlowSignal</code>) provides consistency.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Clear, idiomatic code; easy to implement and understand; matches the &quot;non-local exit&quot; semantics perfectly.</li>\n<li><strong>Negative</strong>: Requires careful design to ensure signals are not accidentally caught by the wrong handler (e.g., a <code>BreakSignal</code> escaping a function). Must ensure only loops catch <code>break</code>/<code>continue</code> and only function calls catch <code>return</code>.</li>\n<li><strong>Language Dependency</strong>: The implementation relies on the host language&#39;s exception mechanism (try/catch in Python/JavaScript/Java). This is portable across our target languages.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The following table compares the options:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Suitable for Learning?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Exception/Signal Objects</strong></td>\n<td>Clean stack unwinding; Intuitive analogy; Easy to implement; Consistent with <code>return</code>.</td>\n<td>Slight performance overhead; Requires careful catch-scoping to avoid mishandling.</td>\n<td>✅ <strong>Yes</strong> – clear, common pattern.</td>\n</tr>\n<tr>\n<td><strong>Explicit Status Flag</strong></td>\n<td>No exception overhead; Full control flow visible in return values.</td>\n<td>Significantly more complex code; Every evaluator method must check and propagate status; Obscures main logic.</td>\n<td>❌ No – adds pervasive boilerplate that distracts from core concepts.</td>\n</tr>\n<tr>\n<td><strong>Continuation Passing Style</strong></td>\n<td>No deep call stacks; Enables advanced features (coroutines, true tail-calls).</td>\n<td>Major paradigm shift; Highly complex to implement and understand; Overkill for simple loops.</td>\n<td>❌ No – too advanced for an intermediate project.</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Infinite Loops from Non-Mutating Conditions</strong></p>\n<ul>\n<li><strong>Description</strong>: Writing a <code>while</code> loop whose condition expression never becomes falsy because no variable inside it changes within the loop body. For example, <code>while (x &gt; 0) { print(&quot;hi&quot;); }</code> where <code>x</code> is never decremented.</li>\n<li><strong>Why It&#39;s Wrong</strong>: The interpreter will hang, repeatedly evaluating the same truthy condition. This is a logical error in the user&#39;s program, but our interpreter must still be able to run it (and the user must be able to stop it with Ctrl+C).</li>\n<li><strong>How to Avoid</strong>: This is a programmer error, not an interpreter bug. However, during testing, ensure your evaluator doesn&#39;t have an infinite loop due to incorrectly <em>evaluating</em> the condition (e.g., always returning <code>true</code>). Use a timeout in your test harness for safety.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrect Truthiness Rules</strong></p>\n<ul>\n<li><strong>Description</strong>: Implementing custom truthiness rules that differ from the language specification. For example, treating the number <code>0</code> or empty string <code>&quot;&quot;</code> as falsy (like in some languages) when our spec defines them as truthy.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Programs will behave unexpectedly, causing subtle bugs in conditionals and loops. Consistency with the defined language semantics is critical.</li>\n<li><strong>How to Fix</strong>: Implement a dedicated <code>_is_truthy(value)</code> helper function that encodes exactly: return <code>False</code> only if the value is <code>nil</code> or the boolean <code>False</code>; return <code>True</code> for all other values (numbers, strings, <code>True</code>, functions, etc.).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Mis-scoping Loop Variables (The &quot;For Loop Variable Leak&quot;)</strong></p>\n<ul>\n<li><strong>Description</strong>: When evaluating a <code>for</code> loop, failing to create a new nested environment for the initializer. This causes a variable declared in the <code>for (var i = 0; ...)</code> to persist in the outer scope after the loop ends, and worse, if the loop is nested, inner loops may incorrectly share the same <code>i</code> variable.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Violates lexical scoping principles. The loop variable should be local to the loop. This can lead to unintended variable shadowing or modification.</li>\n<li><strong>How to Fix</strong>: Ensure the <code>for</code> loop&#39;s initializer (if it&#39;s a variable declaration) is executed inside a new environment whose parent is the surrounding scope. The <code>while</code> loop condition and body must also use this new environment. This is handled automatically if you desugar correctly with an outer block.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Accidentally Catching the Wrong Signal</strong></p>\n<ul>\n<li><strong>Description</strong>: Using a generic <code>except ControlFlowSignal:</code> clause in a loop handler, which catches <code>ReturnSignal</code> as well as <code>BreakSignal</code>/<code>ContinueSignal</code>. This would prevent a <code>return</code> statement inside a loop from exiting the enclosing function.</li>\n<li><strong>Why It&#39;s Wrong</strong>: <code>return</code> must propagate out of loops to the function call. Catching it traps the function, causing it to incorrectly continue looping or return <code>nil</code>.</li>\n<li><strong>How to Fix</strong>: Catch only the specific signal types (<code>BreakSignal</code>, <code>ContinueSignal</code>) in the loop handler. Let <code>ReturnSignal</code> and other exceptions propagate upward. Use separate <code>except</code> clauses or explicit type checking.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to Return a Value from <code>_evaluate_if_stmt</code></strong></p>\n<ul>\n<li><strong>Description</strong>: The <code>if</code> statement handler evaluates the chosen branch but does not explicitly return the result of that evaluation. In many languages, a function/method without a return statement implicitly returns <code>None</code>. This can break if the branch contains a <code>return</code> statement whose <code>ReturnSignal</code> needs to be propagated.</li>\n<li><strong>Why It&#39;s Wrong</strong>: If the branch raises a <code>ReturnSignal</code>, the <code>if</code> statement handler must re-raise it (or let it propagate). If the handler simply returns <code>None</code> after catching the signal (or doesn&#39;t propagate it), the return is lost and the function won&#39;t exit.</li>\n<li><strong>How to Fix</strong>: Ensure the result of evaluating the branch (<code>evaluate(branch_to_execute, env)</code>) is returned directly from the <code>if</code> handler. Do not catch signals unless you intend to handle them.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Control Flow Signals</td>\n<td>Custom exception classes inheriting from <code>Exception</code> (Python) or <code>Error</code> (JavaScript).</td>\n<td>A dedicated <code>ControlFlowSignal</code> base class with a <code>type</code> enum to avoid many subclasses (less Pythonic).</td>\n</tr>\n<tr>\n<td>Loop Control</td>\n<td><code>try...except</code> blocks with precise exception types.</td>\n<td>A custom <code>LoopContext</code> manager class that encapsulates signal handling, enabling <code>with</code> statement usage.</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>interpreter/\n├── ast.py               # AST node class definitions (already exists)\n├── environment.py       # Environment class (already exists)\n├── evaluator.py         # Evaluator class (add control flow methods here)\n├── interpreter.py       # Main Interpreter class (orchestrates parsing/evaluation)\n└── exceptions.py        # New file: RuntimeError and ControlFlowSignal definitions</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (COMPLETE - exceptions.py):</strong>\nThis file defines the signal classes used for non-local exits. Place this in <code>exceptions.py</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all runtime errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, token):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.message)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UndefinedVariableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DivisionByZeroError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArgumentError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># --- Control Flow Signals (NOT errors, but use same exception mechanism) ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ControlFlowSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base for break, continue, return signals. Not an error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreakSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised to break out of a loop.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ContinueSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised to skip to next loop iteration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ReturnSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised to return from a function.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code (Evaluator methods in evaluator.py):</strong>\nAdd these methods to the <code>Evaluator</code> class. They assume the AST node classes have attributes like <code>condition</code>, <code>then_branch</code>, <code>else_branch</code>, <code>body</code>, <code>initializer</code>, <code>increment</code>, and <code>value</code>. Also assume a helper <code>_is_truthy(value)</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _evaluate_if_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Evaluate an if/else statement.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns: The result of executing the chosen branch (may be a raised signal).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate the condition expression using self.evaluate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use self._is_truthy to test the condition result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If truthy, set branch = node.then_branch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Else, if node.else_branch exists, set branch = node.else_branch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If no else branch and condition falsy, return None (if statement completes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If a branch was selected, evaluate it with self.evaluate and return that result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _evaluate_while_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Evaluate a while loop.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns: None (loops do not produce a value).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Enter a loop: while True:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2:   Evaluate the condition expression using self.evaluate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3:   If condition is falsy (not self._is_truthy), break out of the loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4:   Try to evaluate the body (node.body) using self.evaluate within a try-except</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5:     If a BreakSignal is caught, break out of the outer loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6:     If a ContinueSignal is caught, continue to the next iteration (skip rest of body)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7:     If a ReturnSignal is caught, re-raise it (propagate upward)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8:     If any other exception is raised, let it propagate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: After loop exits, return None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _evaluate_for_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Evaluate a for loop (by desugaring into a while loop).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This assumes the parser did NOT desugar; we do it at evaluation time.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    For simplicity, we recommend parser-level desugaring; if so, this method is not needed.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create a new environment loop_env with parent 'env'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If node.initializer exists, evaluate it in loop_env</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Build a while loop AST node (may need to construct manually):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #         condition = node.condition if exists, else a literal True node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #         body_ast = a block containing [node.body, node.increment] (if increment exists)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Evaluate the constructed while loop node in loop_env</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return the result (should be None)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _evaluate_break_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Evaluate a break statement by raising a BreakSignal.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Raise BreakSignal()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _evaluate_continue_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Evaluate a continue statement by raising a ContinueSignal.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Raise ContinueSignal()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _evaluate_return_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Evaluate a return statement by raising a ReturnSignal with the value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: If node.value exists, evaluate it to get return_value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Else, set return_value = None (or nil)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Raise ReturnSignal(return_value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Helper method for truthiness</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _is_truthy</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Determine truthiness of a runtime value.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns: False only for nil and False; True for everything else.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: If value is None (nil) or False, return False</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Otherwise, return True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints (Python):</strong></p>\n<ul>\n<li>Use <code>try:</code> ... <code>except BreakSignal:</code> ... <code>except ContinueSignal:</code> to catch specific signals.</li>\n<li>When re-raising a <code>ReturnSignal</code>, simply use <code>raise</code> without arguments inside the <code>except ReturnSignal:</code> block, or don&#39;t catch it at all.</li>\n<li>Remember that <code>0</code>, <code>&quot;&quot;</code>, and <code>[]</code> are truthy in our language, so <code>bool(value)</code> is NOT sufficient for <code>_is_truthy</code>. Implement the exact rule.</li>\n<li>For constructing AST nodes during desugaring, you may need to import the AST node classes from your <code>ast</code> module and create instances manually (e.g., <code>ast.While(condition, body)</code>). This is advanced; parser desugaring is simpler.</li>\n</ul>\n<p><strong>Milestone Checkpoint (Testing Control Flow):</strong>\nAfter implementing the above, run a test program that exercises all control flow features. For example:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_control_flow.lox (or similar)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        print </span><span style=\"color:#9ECBFF\">\"Skipping 1\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    print i;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        print </span><span style=\"color:#9ECBFF\">\"Breaking at 2\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#9ECBFF\">\"Loop finished\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Skipping 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Breaking at 2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Loop finished</span></span></code></pre></div>\n<p>Also test nested loops, <code>return</code> inside a loop, and <code>for</code> loop variable scoping. Use your interpreter&#39;s <code>interpret</code> method and verify the output matches. If you get an infinite loop, check your condition evaluation and variable updates. If <code>break</code> or <code>continue</code> doesn&#39;t work, ensure you are raising and catching the correct signals.</p>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Loop runs forever, no output.</td>\n<td>Condition never becomes falsy.</td>\n<td>Print the condition value each iteration. Check if variables in condition are being updated.</td>\n<td>Ensure loop body modifies variables used in condition.</td>\n</tr>\n<tr>\n<td><code>break</code> or <code>continue</code> is ignored; loop continues as normal.</td>\n<td>Signal not being raised, or being caught by wrong handler.</td>\n<td>Add print before raising signal. Add print in loop&#39;s except block to see if caught.</td>\n<td>Ensure <code>_evaluate_break_stmt</code> raises <code>BreakSignal()</code>, and loop handler catches it.</td>\n</tr>\n<tr>\n<td><code>return</code> inside a loop causes function to return wrong value or not exit.</td>\n<td>Loop handler catching <code>ReturnSignal</code>.</td>\n<td>Check your <code>except</code> clauses; you may have a generic <code>except ControlFlowSignal</code>.</td>\n<td>Catch only <code>BreakSignal</code> and <code>ContinueSignal</code> in loop. Let <code>ReturnSignal</code> propagate.</td>\n</tr>\n<tr>\n<td>Variable declared in <code>for</code> loop persists after loop.</td>\n<td>No new environment created for loop initializer.</td>\n<td>Print environment chain before/after loop. See if variable exists in outer env.</td>\n<td>Ensure <code>for</code> loop desugaring creates a new block scope.</td>\n</tr>\n</tbody></table>\n<h2 id=\"component-design-function-manager\">Component Design: Function Manager</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 4</p>\n</blockquote>\n<p>The Function Manager is the component that breathes life into our interpreter by enabling reusable, parameterized blocks of code. This system transforms static function definitions into dynamic, callable values that can capture and remember their surrounding context, enabling powerful programming patterns like recursion, higher-order functions, and closures. Implementing this component requires carefully weaving together the <strong>Environment chain</strong> for lexical scoping with the <strong>Evaluator</strong>&#39;s recursive traversal and the <strong>AST</strong>&#39;s representation of function bodies.</p>\n<h3 id=\"mental-model-recipe-with-personal-ingredients\">Mental Model: Recipe with Personal Ingredients</h3>\n<p>Imagine a function as a <strong>recipe card</strong> you write while cooking in your kitchen. The recipe has:</p>\n<ol>\n<li><strong>A name</strong> (optional, like &quot;Grandma&#39;s Cookies&quot;)</li>\n<li><strong>A list of ingredients you need to provide</strong> (the parameters)</li>\n<li><strong>Step-by-step instructions</strong> (the function body)</li>\n</ol>\n<p>When you decide to follow the recipe (call the function), you:</p>\n<ul>\n<li><strong>Grab a fresh mixing bowl</strong> (create a new local environment)</li>\n<li><strong>Measure out your specific ingredients</strong> (bind arguments to parameters in that bowl)</li>\n<li><strong>Follow the steps</strong> (execute the body in the new environment)</li>\n</ul>\n<p>Crucially, while following the recipe, you can also <strong>reach into your own pantry</strong> (access variables from the surrounding kitchen/closure environment). Even if you later move to a different kitchen, you remember which pantry you were using when you wrote down the recipe. This &quot;pantry capture&quot; is what makes closures work: the function remembers the environment where it was defined, not where it&#39;s called.</p>\n<p>This model illustrates three key concepts:</p>\n<ul>\n<li><strong>Definition vs. Call</strong>: Writing the recipe vs. actually baking</li>\n<li><strong>Parameter Binding</strong>: Each call gets its own fresh set of ingredients</li>\n<li><strong>Closure Capture</strong>: The function remembers the environment (pantry) it came from</li>\n</ul>\n<h3 id=\"interface-callable-values-and-closure\">Interface: Callable Values and Closure</h3>\n<p>Functions are <strong>first-class values</strong> in our interpreter, meaning they can be assigned to variables, passed as arguments, and returned from other functions. This requires a runtime representation that encapsulates everything needed to execute the function later.</p>\n<h4 id=\"functionvalue-data-structure\">FunctionValue Data Structure</h4>\n<p>The <code>FunctionValue</code> type represents a callable function at runtime:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>name</code></td>\n<td><code>Optional[str]</code></td>\n<td>The function&#39;s declared name (for recursion and debugging). Anonymous functions have <code>None</code>.</td>\n</tr>\n<tr>\n<td><code>parameters</code></td>\n<td><code>List[str]</code></td>\n<td>Ordered list of parameter names. Empty list for functions that take no arguments.</td>\n</tr>\n<tr>\n<td><code>body</code></td>\n<td><code>ASTNode</code></td>\n<td>The function body, typically a <code>Block</code> statement containing the code to execute.</td>\n</tr>\n<tr>\n<td><code>closure</code></td>\n<td><code>Environment</code></td>\n<td>The <strong>defining environment</strong>—the environment active when the function was created. This enables lexical closures.</td>\n</tr>\n</tbody></table>\n<h4 id=\"callable-interface\">Callable Interface</h4>\n<p>The <code>FunctionValue</code> implements a single public operation:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>call</code></td>\n<td><code>arguments: List[Any]</code></td>\n<td><code>Any</code> (the return value)</td>\n<td>Executes the function with the provided arguments. Creates a new environment, binds arguments to parameters, evaluates the body, and returns the result.</td>\n</tr>\n</tbody></table>\n<p>This simple interface hides the complexity of environment creation, argument binding, and body evaluation behind a single method call.</p>\n<h3 id=\"internal-behavior-call-and-return\">Internal Behavior: Call and Return</h3>\n<p>Executing a function call involves multiple coordinated steps across the evaluator, environment system, and AST. Here&#39;s the complete algorithm:</p>\n<h4 id=\"1-function-definition-evaluation\">1. Function Definition Evaluation</h4>\n<p>When the evaluator encounters a function declaration statement:</p>\n<ol>\n<li><strong>Extract definition components</strong>: From the AST node, get the function name, parameter list, and body statement.</li>\n<li><strong>Create a FunctionValue</strong>: Instantiate a new <code>FunctionValue</code> with:<ul>\n<li>The extracted name and parameters</li>\n<li>The body AST node</li>\n<li>The <strong>current environment</strong> as the <code>closure</code> field (this captures the defining scope)</li>\n</ul>\n</li>\n<li><strong>Bind to name</strong>: In the current environment, call <code>Environment.define()</code> to create a binding between the function name and the <code>FunctionValue</code>.</li>\n<li><strong>Return nothing</strong>: Function declarations don&#39;t produce a value at the statement level (they return <code>None</code>/nil).</li>\n</ol>\n<h4 id=\"2-function-call-evaluation\">2. Function Call Evaluation</h4>\n<p>When evaluating a call expression like <code>add(2, 3)</code>:</p>\n<ol>\n<li><strong>Evaluate the callee</strong>: Recursively evaluate the expression before the parentheses (could be a variable name, property access, or another call).</li>\n<li><strong>Validate callee type</strong>: Ensure the result is a <code>FunctionValue</code>. If not, raise a <code>TypeError</code>.</li>\n<li><strong>Evaluate arguments</strong>: For each argument expression in the parentheses, evaluate it in the <strong>caller&#39;s environment</strong> (left-to-right evaluation order).</li>\n<li><strong>Check arity</strong>: Compare the number of arguments to the number of parameters. If they don&#39;t match, raise an <code>ArgumentError</code>.</li>\n<li><strong>Create call environment</strong>: Instantiate a new <code>Environment</code> with the function&#39;s <code>closure</code> environment as its parent. This establishes the lexical scope chain.</li>\n<li><strong>Bind parameters</strong>: For each parameter name at index <code>i</code>, call <code>Environment.define()</code> in the new environment to bind it to the corresponding argument value.</li>\n<li><strong>Execute the body</strong>: Call <code>Evaluator.evaluate()</code> on the function&#39;s body node, passing the new call environment.</li>\n<li><strong>Handle the return</strong>: The body evaluation may complete normally or exit early via a <code>ReturnSignal</code>. <ul>\n<li>If a <code>ReturnSignal</code> is caught, extract and return its value.</li>\n<li>If the body completes without a return statement, return <code>nil</code> (implicit return).</li>\n</ul>\n</li>\n<li><strong>Clean up</strong>: The call environment becomes eligible for garbage collection (though Python handles this automatically).</li>\n</ol>\n<h4 id=\"3-return-statement-handling\">3. Return Statement Handling</h4>\n<p>The <code>return</code> statement introduces <strong>non-local exit</strong>—it needs to unwind through potentially multiple nested evaluations to deliver a value back to the original call site. Our implementation uses an exception-like control flow signal:</p>\n<ol>\n<li><strong>Evaluate return value</strong>: If the return statement has an expression, evaluate it in the current environment.</li>\n<li><strong>Raise ReturnSignal</strong>: Create a <code>ReturnSignal</code> with the return value and raise it (as an exception in Python).</li>\n<li><strong>Unwind through scopes</strong>: The signal propagates up through nested block evaluations until caught by the function call handler.</li>\n<li><strong>Stop propagation</strong>: Once caught, the signal is not re-raised; the function returns the value.</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight</strong>: The <code>ReturnSignal</code> must only be catchable by the function call evaluation logic—not by loop constructs or other control flow handlers. This ensures <code>return</code> works correctly inside nested loops and conditionals within a function body.</p>\n</blockquote>\n<p><img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fseq-function-call.svg\" alt=\"Sequence Diagram: Function Call with Closure\"></p>\n<h3 id=\"adr-closure-capture-strategy\">ADR: Closure Capture Strategy</h3>\n<blockquote>\n<p><strong>Decision: Store Defining Environment in Function Object</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to support lexical closures where functions can access variables from their surrounding scope, even after that scope has exited. The interpreter must decide which environment to use as the parent when creating the call environment.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Dynamic Scoping</strong>: Use the caller&#39;s environment as the parent for the call environment.</li>\n<li><strong>Lexical Closures</strong>: Store the environment where the function was <em>defined</em> and use that as the parent for all calls.</li>\n<li><strong>Hybrid Approach</strong>: Store both defining and calling environments with complex resolution rules.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement <strong>lexical closures</strong> by storing the defining environment in the <code>FunctionValue.closure</code> field.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Predictability</strong>: Lexical scoping is what modern programmers expect—variable resolution depends on where the function was written, not where it&#39;s called.</li>\n<li><strong>Encapsulation</strong>: Functions maintain consistent behavior regardless of calling context, enabling reliable abstraction.</li>\n<li><strong>Industry Standard</strong>: JavaScript, Python, and most modern languages use lexical closures.</li>\n<li><strong>Simplicity</strong>: The implementation is straightforward—capture one environment reference at definition time.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Enables powerful functional programming patterns (closures, higher-order functions).</li>\n<li><strong>Positive</strong>: Functions behave consistently, aiding debuggability.</li>\n<li><strong>Negative</strong>: The defining environment must stay alive as long as any function referencing it exists (memory consideration).</li>\n<li><strong>Negative</strong>: Slightly more complex than dynamic scoping but much more useful.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dynamic Scoping</td>\n<td>Simpler implementation, smaller memory footprint</td>\n<td>Unintuitive behavior, breaks encapsulation, not standard</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Lexical Closures</td>\n<td>Predictable, enables powerful patterns, industry standard</td>\n<td>Must maintain environment references, slightly more complex</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Hybrid Approach</td>\n<td>Maximum flexibility, can simulate both</td>\n<td>Very complex, confusing semantics, hard to debug</td>\n<td>❌</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Forgetting to Capture the Defining Environment</strong></p>\n<ul>\n<li><strong>Description</strong>: Creating a <code>FunctionValue</code> with <code>closure=None</code> or using the global environment for all functions.</li>\n<li><strong>Why it&#39;s wrong</strong>: Functions won&#39;t be able to access variables from their surrounding scope, breaking closure behavior. <code>inner()</code> in nested functions will fail.</li>\n<li><strong>Fix</strong>: Always pass the <strong>current environment at definition time</strong> as the <code>closure</code> parameter when creating a <code>FunctionValue</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Using the Wrong Parent for Call Environment</strong></p>\n<ul>\n<li><strong>Description</strong>: Setting the new call environment&#39;s parent to the caller&#39;s current environment instead of the function&#39;s closure environment.</li>\n<li><strong>Why it&#39;s wrong</strong>: Breaks lexical scoping—functions see variables from where they&#39;re called, not where they&#39;re defined.</li>\n<li><strong>Fix</strong>: Always create the call environment with <code>parent=function_value.closure</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Mishandling Implicit Returns</strong></p>\n<ul>\n<li><strong>Description</strong>: Forgetting that functions should return <code>nil</code> when execution reaches the end without encountering a <code>return</code> statement.</li>\n<li><strong>Why it&#39;s wrong</strong>: Function calls that don&#39;t explicitly return a value will return whatever the last expression evaluated to (which might be a statement value like <code>None</code> from a variable declaration).</li>\n<li><strong>Fix</strong>: After evaluating the function body, if no <code>ReturnSignal</code> was caught, explicitly return <code>nil</code> (or <code>None</code> in Python).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrect Return Signal Propagation</strong></p>\n<ul>\n<li><strong>Description</strong>: Catching <code>ReturnSignal</code> in the wrong place (e.g., in loop handlers) or failing to re-raise it after catching.</li>\n<li><strong>Why it&#39;s wrong</strong>: <code>return</code> statements inside loops won&#39;t work properly, or return signals might escape function boundaries.</li>\n<li><strong>Fix</strong>: Only catch <code>ReturnSignal</code> in the function call evaluation logic. Don&#39;t catch it in block, loop, or conditional evaluation.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Validating Argument Count</strong></p>\n<ul>\n<li><strong>Description</strong>: Allowing calls with too few or too many arguments without error checking.</li>\n<li><strong>Why it&#39;s wrong</strong>: Functions with missing parameters will reference undefined variables; extra arguments are silently ignored.</li>\n<li><strong>Fix</strong>: Before binding arguments, compare <code>len(arguments)</code> with <code>len(function_value.parameters)</code>. Raise an <code>ArgumentError</code> on mismatch.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Evaluating Arguments in Wrong Environment</strong></p>\n<ul>\n<li><strong>Description</strong>: Evaluating argument expressions in the new call environment instead of the caller&#39;s environment.</li>\n<li><strong>Why it&#39;s wrong</strong>: Arguments can&#39;t reference the function&#39;s own parameters (which aren&#39;t bound yet), breaking patterns like <code>func(x, x*2)</code>.</li>\n<li><strong>Fix</strong>: Evaluate all argument expressions in the <strong>caller&#39;s current environment</strong> before creating the call environment.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Function Representation</td>\n<td>Python class with fields</td>\n<td>Named tuple or dataclass</td>\n</tr>\n<tr>\n<td>Closure Capture</td>\n<td>Store environment reference</td>\n<td>Environment copying for security</td>\n</tr>\n<tr>\n<td>Return Mechanism</td>\n<td>Python exceptions for non-local exit</td>\n<td>Return value propagation with explicit stack</td>\n</tr>\n<tr>\n<td>Arity Checking</td>\n<td>Simple length comparison</td>\n<td>Default parameters, variadic functions</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>interpreter/\n├── __init__.py\n├── ast_nodes.py           # AST node definitions (from previous milestone)\n├── environment.py         # Environment class (from Milestone 2)\n├── evaluator.py           # Core Evaluator class (from Milestone 1)\n├── function_value.py      # NEW: FunctionValue class and call logic\n├── control_flow.py        # Control flow signals (from Milestone 3)\n├── runtime_errors.py      # Error classes (RuntimeError, TypeError, etc.)\n├── interpreter.py         # Main Interpreter class tying everything together\n└── tests/\n    ├── test_evaluator.py\n    ├── test_environment.py\n    └── test_functions.py  # NEW: Tests for functions and closures</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete <code>runtime_errors.py</code> (expanded for function errors):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Runtime error classes for the interpreter.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all runtime errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, token</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.message)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UndefinedVariableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when trying to access an undefined variable.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when operations are applied to incorrect types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DivisionByZeroError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when dividing by zero.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArgumentError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when function is called with wrong number of arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Control flow signals (from Milestone 3, kept for completeness)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ControlFlowSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for break/continue/return signals.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreakSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a break statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ContinueSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a continue statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ReturnSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a return statement with a value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span></code></pre></div>\n\n<p><strong>Complete <code>function_value.py</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Function value representation and call logic.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> runtime_errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ArgumentError, </span><span style=\"color:#79B8FF\">TypeError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FunctionValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Runtime representation of a function.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], parameters: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 body: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">, closure: Environment):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name  </span><span style=\"color:#6A737D\"># Optional function name for recursion</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parameters </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parameters  </span><span style=\"color:#6A737D\"># List of parameter names</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> body  </span><span style=\"color:#6A737D\"># AST node for the function body</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.closure </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> closure  </span><span style=\"color:#6A737D\"># The environment where the function was defined</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">(self, arguments: List[Any]) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Execute the function with given arguments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            arguments: Evaluated argument values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            The function's return value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ArgumentError: If argument count doesn't match parameter count</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check argument count matches parameter count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create new environment with closure as parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Bind each parameter to corresponding argument</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Evaluate the body in the new environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return the result (or nil if no return statement)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"String representation for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.name:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;function </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">>\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"&#x3C;anonymous function>\"</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>In <code>evaluator.py</code> (add to existing Evaluator class):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Add these imports at the top</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> function_value </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FunctionValue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> runtime_errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ReturnSignal, ArgumentError, </span><span style=\"color:#79B8FF\">TypeError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... existing code from previous milestones ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_function_decl</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate a function declaration statement.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: FunctionDecl AST node with fields:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                - name: str (function name)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                - params: List[str] (parameter names)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                - body: ASTNode (function body)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            None (function declarations don't produce values)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract function name, parameters, and body from node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create a FunctionValue with:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - The extracted name and parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - The body node  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Current environment as closure (for lexical scope)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Define the function name in the current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         env.define(function_name, function_value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return None (function declarations are statements)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_call_expr</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate a function call expression.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: CallExpr AST node with fields:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                - callee: ASTNode (expression evaluating to function)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                - args: List[ASTNode] (argument expressions)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            The return value from the function call</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            TypeError: If callee is not a function</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ArgumentError: If argument count mismatch</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate the callee expression to get the function value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if callee is a FunctionValue, raise TypeError if not</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Evaluate ALL argument expressions in the current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         (left to right, store in a list)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Call function_value.call(arguments) and return the result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: The call() method handles environment creation and body evaluation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_return_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate a return statement.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: ReturnStmt AST node with field:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                - value: Optional[ASTNode] (return value expression)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Never returns normally—always raises ReturnSignal</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ReturnSignal: With the return value (or nil)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if return has a value expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If yes, evaluate it in the current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If no, use nil/None as the return value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise ReturnSignal(value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Important: This method should NOT catch ReturnSignal itself</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<p><strong>Python Tips:</strong></p>\n<ul>\n<li>Use <code>isinstance(value, FunctionValue)</code> for type checking</li>\n<li>Catch <code>ReturnSignal</code> with <code>except ReturnSignal as signal:</code> and access <code>signal.value</code></li>\n<li>Remember Python&#39;s <code>None</code> represents our <code>nil</code> value</li>\n<li>For recursion: functions call themselves by name, which works because the function name is bound in the environment before the function value is fully created</li>\n</ul>\n<p><strong>Key Implementation Pattern for Recursion:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># When evaluating a function declaration:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">function_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FunctionValue(name, params, body, env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Define the name IN THE SAME ENVIRONMENT (env.define)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This allows the function to reference itself in its body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">env.define(name, function_value)</span></span></code></pre></div>\n\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the Function Manager, test with this program:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test program: functions_test.lox</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> factorial</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">n</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> factorial</span><span style=\"color:#E1E4E8\">(n </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#B392F0\">factorial</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">);  </span><span style=\"color:#6A737D\">// Should print: 120</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> makeCounter</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    function</span><span style=\"color:#B392F0\"> count</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> counter </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> makeCounter</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#B392F0\">counter</span><span style=\"color:#E1E4E8\">();  </span><span style=\"color:#6A737D\">// 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#B392F0\">counter</span><span style=\"color:#E1E4E8\">();  </span><span style=\"color:#6A737D\">// 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#B392F0\">counter</span><span style=\"color:#E1E4E8\">();  </span><span style=\"color:#6A737D\">// 3</span></span></code></pre></div>\n\n<p><strong>Expected behavior:</strong></p>\n<ol>\n<li>The interpreter should parse and execute without errors</li>\n<li><code>factorial(5)</code> should calculate and print <code>120</code> (recursion works)</li>\n<li><code>makeCounter()</code> returns a closure that increments and remembers <code>i</code></li>\n<li>Each call to <code>counter()</code> returns the next integer (1, 2, 3)</li>\n</ol>\n<p><strong>Signs of problems:</strong></p>\n<ul>\n<li>Recursion fails with &quot;undefined variable &#39;factorial&#39;&quot;: Function name not bound in its own environment</li>\n<li>Counter always returns 1: Closure not capturing <code>i</code>, or new environment created incorrectly</li>\n<li>&quot;Too many/few arguments&quot; error when correct: Argument count checking too strict</li>\n<li>Return value is <code>None</code> when expecting a number: Forgetting to extract value from <code>ReturnSignal</code></li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Function can&#39;t access outer variables</td>\n<td>Closure not captured</td>\n<td>Print function_value.closure during definition</td>\n<td>Pass current environment as closure</td>\n</tr>\n<tr>\n<td>Recursion fails: &quot;undefined variable&quot;</td>\n<td>Function name not bound before body</td>\n<td>Check order of definition vs. environment binding</td>\n<td>Define function name in SAME environment used as closure</td>\n</tr>\n<tr>\n<td>Return value always nil</td>\n<td>ReturnSignal caught in wrong place</td>\n<td>Add print before/after try-catch in call evaluation</td>\n<td>Only catch ReturnSignal in _evaluate_call_expr</td>\n</tr>\n<tr>\n<td>Arguments evaluate to wrong values</td>\n<td>Evaluating args in call environment</td>\n<td>Check which environment is used for arg evaluation</td>\n<td>Evaluate args in caller&#39;s environment, not new one</td>\n</tr>\n<tr>\n<td>Function called as method fails</td>\n<td>Callee not a FunctionValue</td>\n<td>Print type of callee before call</td>\n<td>Ensure variable lookup returns FunctionValue, not raw value</td>\n</tr>\n</tbody></table>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 2, 3, 4</p>\n</blockquote>\n<p>This section illustrates the dynamic collaboration between the interpreter&#39;s core components during execution. While previous sections described each component&#39;s static design, here we trace the concrete flow of control and data as the interpreter evaluates real programs. Understanding these interactions is critical for debugging and for appreciating how lexical scoping, closures, and control flow jumps are realized through the interplay of the immutable AST, the recursive Evaluator, and the chained Environment objects.</p>\n<p>We will examine three foundational scenarios that demonstrate increasing complexity: a simple variable lookup illustrating the environment chain, a function call with closure capture showing how functions preserve their defining scope, and a loop with a <code>break</code> statement demonstrating non-local control flow. Each scenario will be narrated step-by-step, highlighting the components involved, the messages passed, and the state transformations.</p>\n<h3 id=\"sequence-of-operations\">Sequence of Operations</h3>\n<p>The interpreter&#39;s execution follows a consistent pattern: the <code>Evaluator</code> receives an AST node and an <code>Environment</code> context, dispatches to a specific handler method based on the node type, and returns a result. This simple protocol enables complex behaviors through recursion and state mutation. The following walkthroughs make these abstract interactions concrete.</p>\n<h4 id=\"scenario-1-variable-lookup-across-nested-scopes\">Scenario 1: Variable Lookup Across Nested Scopes</h4>\n<p><strong>Program:</strong> <code>{ var x = 10; { var y = x + 5; } }</code>\n<strong>Goal:</strong> Illustrate environment chain creation and lexical variable resolution.</p>\n<p>This program contains a block statement with a variable <code>x</code>, nested inside another block that defines <code>y</code> and references <code>x</code>. This demonstrates how the environment chain enables inner scopes to access outer bindings.</p>\n<p><strong>Step-by-Step Walkthrough:</strong></p>\n<ol>\n<li><p><strong>Initialization:</strong> The <code>Interpreter</code> creates a global <code>Environment</code> (call it <code>env_global</code>) with no parent. It parses the source code into an AST, resulting in a <code>Block</code> node containing two statements: a <code>Var</code> statement for <code>x</code> and an inner <code>Block</code> statement.</p>\n</li>\n<li><p><strong>Outer Block Evaluation:</strong> The <code>Interpreter</code> calls <code>Evaluator.evaluate(outer_block, env_global)</code>. The <code>_evaluate_block_stmt</code> method is invoked.</p>\n</li>\n<li><p><strong>Defining <code>x</code>:</strong> The evaluator processes the first statement, a <code>Var</code> node for <code>x</code>. It evaluates the initializer expression (the literal <code>10</code>), yielding the runtime value <code>10</code>. It then calls <code>env_global.define(&quot;x&quot;, 10)</code>, which inserts the binding <code>&quot;x&quot;: 10</code> into <code>env_global.store</code>.</p>\n</li>\n<li><p><strong>Creating Nested Scope:</strong> The evaluator moves to the second statement, another <code>Block</code> node. To evaluate it, <code>_evaluate_block_stmt</code> creates a new <code>Environment</code> (call it <code>env_inner</code>) with its <code>parent</code> field set to <code>env_global</code>.</p>\n</li>\n<li><p><strong>Inner Block Execution:</strong> Inside <code>env_inner</code>, the evaluator processes its single <code>Var</code> statement for <code>y</code>. The initializer is a <code>Binary</code> expression <code>x + 5</code>.</p>\n</li>\n<li><p><strong>Resolving <code>x</code> for the Addition:</strong> To evaluate the <code>Binary</code> node&#39;s left operand (a <code>Variable</code> node for <code>x</code>), the evaluator calls <code>_evaluate_variable_expr</code>. This method calls <code>env_inner.get(&quot;x&quot;)</code>.</p>\n<ol>\n<li><code>env_inner</code> checks its own <code>store</code>; <code>x</code> is not found.</li>\n<li>It follows its <code>parent</code> pointer to <code>env_global</code>.</li>\n<li><code>env_global</code> finds <code>&quot;x&quot;: 10</code> in its store and returns the value <code>10</code>.</li>\n</ol>\n</li>\n<li><p><strong>Completing the Binding:</strong> The binary expression evaluates to <code>15</code>. The evaluator calls <code>env_inner.define(&quot;y&quot;, 15)</code>, creating a binding local to the inner block. The inner block completes, and its environment (<code>env_inner</code>) is discarded. The outer block completes, returning <code>None</code>.</p>\n</li>\n</ol>\n<p><img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fenv-chain-lookup.svg\" alt=\"Diagram: Environment Chain Lookup\"></p>\n<p><strong>Key Interaction Insight:</strong> The <code>get</code> operation recursively traverses the environment chain via parent links. The <code>Evaluator</code> is unaware of the chain&#39;s length; it simply requests a value from the current environment, which handles the lookup. This clean separation of concerns makes lexical scoping straightforward to implement and reason about.</p>\n<h4 id=\"scenario-2-function-call-with-closure-capture\">Scenario 2: Function Call with Closure Capture</h4>\n<p><strong>Program:</strong> <code>var a = 1; fun makeAdder(b) { fun adder(c) { return a + b + c; } return adder; } var addTwo = makeAdder(2); print(addTwo(3)); // prints 6</code>\n<strong>Goal:</strong> Demonstrate function definition, closure environment capture, and the call stack simulation using environments.</p>\n<p>This classic closure example shows how a function (<code>adder</code>) retains access to variables (<code>a</code> and <code>b</code>) from its defining scope, even after that scope has exited.</p>\n<p><strong>Step-by-Step Walkthrough:</strong></p>\n<ol>\n<li><p><strong>Global Setup:</strong> The global environment <code>env_global</code> is created. <code>a</code> is defined as <code>1</code>. The <code>makeAdder</code> function is defined: a <code>FunctionValue</code> object <code>F1</code> is created with <code>parameters=[&quot;b&quot;]</code>, <code>body</code> (the function&#39;s block), and <code>closure=env_global</code>. <code>env_global.define(&quot;makeAdder&quot;, F1)</code>.</p>\n</li>\n<li><p><strong>Calling <code>makeAdder(2)</code>:</strong> The evaluator encounters the call <code>makeAdder(2)</code>. It evaluates the callee to <code>F1</code> and the argument to <code>2</code>. It then executes <code>F1.call([2])</code>.</p>\n<ol>\n<li><strong>New Function Environment:</strong> <code>call</code> creates a new environment <code>env_makeAdder</code> with its <code>parent</code> set to <code>F1.closure</code> (which is <code>env_global</code>). This establishes the function&#39;s local scope.</li>\n<li><strong>Parameter Binding:</strong> <code>env_makeAdder.define(&quot;b&quot;, 2)</code> is called.</li>\n<li><strong>Body Execution:</strong> The evaluator runs <code>F1.body</code> (a block containing a function declaration and a return statement) within <code>env_makeAdder</code>.</li>\n<li><strong>Defining <code>adder</code>:</strong> The inner function declaration creates a new <code>FunctionValue</code> <code>F2</code> with <code>parameters=[&quot;c&quot;]</code>, <code>body</code> (the return statement <code>a + b + c</code>), and <strong>crucially</strong> <code>closure=env_makeAdder</code>. This captures the <em>entire</em> environment active at its definition, including the binding for <code>b</code>.</li>\n<li><strong>Returning <code>adder</code>:</strong> The <code>return adder;</code> statement is evaluated. The evaluator&#39;s <code>_evaluate_return_stmt</code> raises a <code>ReturnSignal</code> containing the value <code>F2</code>. This signal propagates out of the <code>call</code> method, which catches it and returns <code>F2</code> to the original call site. The <code>env_makeAdder</code> environment is <em>retained</em> because <code>F2</code> holds a reference to it as its closure.</li>\n</ol>\n</li>\n<li><p><strong>Binding <code>addTwo</code>:</strong> The returned function <code>F2</code> is assigned to the global variable <code>addTwo</code>.</p>\n</li>\n<li><p><strong>Calling <code>addTwo(3)</code>:</strong> The evaluator encounters <code>addTwo(3)</code>. It evaluates the callee to <code>F2</code> and the argument to <code>3</code>. It executes <code>F2.call([3])</code>.</p>\n<ol>\n<li><strong>New Closure Environment:</strong> <code>call</code> creates a new environment <code>env_adder</code> with its <code>parent</code> set to <code>F2.closure</code> (which is <code>env_makeAdder</code>). This is the key to closure: <code>env_adder</code>&#39;s parent chain is <code>env_makeAdder</code> → <code>env_global</code>.</li>\n<li><strong>Parameter Binding:</strong> <code>env_adder.define(&quot;c&quot;, 3)</code>.</li>\n<li><strong>Body Execution:</strong> The evaluator runs <code>F2.body</code> (the return expression <code>a + b + c</code>). To resolve these variables:<ul>\n<li><code>c</code>: Found in <code>env_adder.store</code> as <code>3</code>.</li>\n<li><code>b</code>: Not in <code>env_adder</code>. Lookup goes to parent <code>env_makeAdder</code>, where <code>b</code> is found as <code>2</code>.</li>\n<li><code>a</code>: Not in <code>env_adder</code> or <code>env_makeAdder</code>. Lookup goes to <code>env_global</code>, where <code>a</code> is found as <code>1</code>.</li>\n</ul>\n</li>\n<li>The sum <code>1 + 2 + 3 = 6</code> is computed. A <code>ReturnSignal(6)</code> is raised, caught by <code>call</code>, and returned as the result of <code>addTwo(3)</code>. The <code>print</code> statement outputs <code>6</code>.</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fseq-function-call.svg\" alt=\"Sequence Diagram: Function Call with Closure\"></p>\n<p><strong>Key Interaction Insight:</strong> The closure is implemented by storing a reference to the <em>defining</em> environment within the function object. When the function is called, this stored environment becomes the parent of the new call-site environment. This creates a persistent scope chain that outlives the execution of the outer function, enabling closure. The <code>Evaluator</code> treats all function calls identically; the magic is in the environment link.</p>\n<h4 id=\"scenario-3-loop-execution-with-a-break-statement\">Scenario 3: Loop Execution with a Break Statement</h4>\n<p><strong>Program:</strong> <code>var i = 0; while (i &lt; 10) { if (i == 5) { break; } i = i + 1; }</code>\n<strong>Goal:</strong> Demonstrate how loop evaluation interacts with control flow signals and the environment.</p>\n<p>This shows the <code>while</code> loop&#39;s repetitive evaluation and how a <code>break</code> statement causes an early, non-local exit from the loop&#39;s body.</p>\n<p><strong>Step-by-Step Walkthrough:</strong></p>\n<ol>\n<li><p><strong>Initialization:</strong> <code>env_global</code> defines <code>i = 0</code>. The AST contains a <code>While</code> node with a condition <code>(i &lt; 10)</code> and a body <code>Block</code>.</p>\n</li>\n<li><p><strong>Entering the Loop:</strong> <code>Evaluator._evaluate_while_stmt</code> is called with the <code>While</code> node and <code>env_global</code>.</p>\n<ol>\n<li><strong>Condition Check:</strong> It evaluates the condition <code>i &lt; 10</code> by calling <code>evaluate(condition, env_global)</code>. This involves looking up <code>i</code> (value <code>0</code>) and performing the comparison, yielding <code>True</code>.</li>\n<li><strong>Body Execution (Iteration 1):</strong> Since the condition is truthy, it calls <code>evaluate(body, env_global)</code> to execute the loop&#39;s block. The block contains an <code>If</code> statement and an assignment.<ul>\n<li>The <code>If</code> condition <code>i == 5</code> evaluates to <code>False</code>, so its then-branch (containing the <code>Break</code> node) is skipped.</li>\n<li>The assignment <code>i = i + 1</code> is evaluated, updating <code>i</code> to <code>1</code> in <code>env_global</code>.</li>\n</ul>\n</li>\n<li>The loop iterates, repeating steps 2a and 2b, with <code>i</code> incrementing to <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>.</li>\n</ol>\n</li>\n<li><p><strong>Triggering the Break (Iteration where i == 5):</strong></p>\n<ol>\n<li><strong>Condition Check:</strong> <code>i &lt; 10</code> is still <code>True</code>.</li>\n<li><strong>Body Execution:</strong> The <code>If</code> condition <code>i == 5</code> is now <code>True</code>. The evaluator proceeds to evaluate the then-branch, which is a block containing a <code>Break</code> statement.</li>\n<li><strong>Break Signal Raised:</strong> <code>Evaluator._evaluate_break_stmt</code> is called. It does <strong>not</strong> return normally. Instead, it raises a <code>BreakSignal</code> exception (a subclass of <code>ControlFlowSignal</code>).</li>\n</ol>\n</li>\n<li><p><strong>Signal Propagation and Loop Termination:</strong></p>\n<ol>\n<li>The <code>BreakSignal</code> propagates out of the <code>evaluate(body, ...)</code> call. The <code>_evaluate_while_stmt</code> method is specifically designed to catch <code>BreakSignal</code> exceptions.</li>\n<li>Upon catching the <code>BreakSignal</code>, the loop evaluator <strong>immediately stops iteration</strong>. It does not evaluate any remaining statements in the loop body (the assignment <code>i = i + 1</code> is skipped for this iteration). It then exits, returning <code>None</code>.</li>\n<li>The <code>BreakSignal</code> is caught and consumed by the loop evaluator; it does not propagate further up the call stack.</li>\n</ol>\n</li>\n<li><p><strong>Post-Loop State:</strong> The loop has terminated. The variable <code>i</code> remains with the value <code>5</code>, as the increment was skipped on the iteration where the break occurred.</p>\n</li>\n</ol>\n<p><img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fstate-machine-loop.svg\" alt=\"State Machine: While Loop Execution\"></p>\n<p><strong>Key Interaction Insight:</strong> Control flow jumps like <code>break</code> are implemented as exceptions (or a similar non-local exit mechanism) that unwind the evaluator&#39;s recursion until caught by the appropriate handler (the nearest enclosing loop construct). This separates the signaling of the jump (in <code>_evaluate_break_stmt</code>) from the handling logic (in <code>_evaluate_while_stmt</code>), making the control flow explicit and avoiding the need for complex flag-passing throughout the recursion.</p>\n<h3 id=\"message-and-value-formats\">Message and Value Formats</h3>\n<p>During the sequences described above, components communicate through method calls and return values. The data structures passed are simple, yet they must carry all necessary information for correct execution. The following tables catalog these formats.</p>\n<p><strong>Primary Evaluation Protocol:</strong>\nThe core interaction is the <code>Evaluator.evaluate(node, environment)</code> call and its return. The <code>node</code> is an immutable AST node, and the <code>environment</code> is the current lexical scope. The return value is a runtime value or <code>None</code>.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Message</th>\n<th align=\"left\">Direction</th>\n<th align=\"left\">Format (Type)</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Evaluation Request</strong></td>\n<td align=\"left\">Caller → <code>Evaluator</code></td>\n<td align=\"left\"><code>(ASTNode, Environment)</code></td>\n<td align=\"left\">A request to evaluate a given AST node within a specific environment context.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Runtime Value Result</strong></td>\n<td align=\"left\"><code>Evaluator</code> → Caller</td>\n<td align=\"left\"><code>Any</code> (Number, String, Boolean, Nil, <code>FunctionValue</code>)</td>\n<td align=\"left\">The result of evaluating an expression. For statement evaluation, the result is often <code>None</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Control Flow Signal</strong></td>\n<td align=\"left\"><code>Evaluator</code> (deep in recursion) → Loop/Function Handler</td>\n<td align=\"left\"><code>ControlFlowSignal</code> subclass (<code>BreakSignal</code>, <code>ContinueSignal</code>, <code>ReturnSignal</code>)</td>\n<td align=\"left\">A non-local exit signal raised by statements like <code>break</code>, <code>continue</code>, or <code>return</code>. Carries optional data (e.g., a return value).</td>\n</tr>\n</tbody></table>\n<p><strong>Environment Management Messages:</strong>\nThe <code>Environment</code> API is called by the <code>Evaluator</code> to manage variable bindings.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Method Call</th>\n<th align=\"left\">Invoked By</th>\n<th align=\"left\">Parameters</th>\n<th align=\"left\">Returns / Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Environment.define(name, value)</code></td>\n<td align=\"left\"><code>Evaluator._evaluate_var_stmt</code></td>\n<td align=\"left\"><code>name: str</code>, <code>value: Any</code></td>\n<td align=\"left\">Creates a new binding in the current environment&#39;s store. Fails silently if name already exists (allowing redefinition in our simple interpreter).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Environment.get(name)</code></td>\n<td align=\"left\"><code>Evaluator._evaluate_variable_expr</code></td>\n<td align=\"left\"><code>name: str</code></td>\n<td align=\"left\">Returns the value bound to <code>name</code> by walking the parent chain. Raises <code>UndefinedVariableError</code> if not found.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Environment.assign(name, value)</code></td>\n<td align=\"left\"><code>Evaluator._evaluate_assign_expr</code></td>\n<td align=\"left\"><code>name: str</code>, <code>value: Any</code></td>\n<td align=\"left\">Updates the binding for <code>name</code> in the nearest enclosing environment where it is defined. Raises <code>UndefinedVariableError</code> if no binding exists.</td>\n</tr>\n</tbody></table>\n<p><strong>Function Call Protocol:</strong>\nWhen a <code>FunctionValue</code> is called, a specific sequence of messages creates and populates a new scope.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Step</th>\n<th align=\"left\">Message</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1. <strong>Call Initiation</strong></td>\n<td align=\"left\"><code>Evaluator</code> → <code>FunctionValue</code>: <code>call(arguments)</code></td>\n<td align=\"left\">The evaluator, after evaluating the callee and arguments, invokes the function&#39;s <code>call</code> method.</td>\n</tr>\n<tr>\n<td align=\"left\">2. <strong>Environment Creation</strong></td>\n<td align=\"left\"><code>FunctionValue</code> creates a new <code>Environment</code> with <code>parent = self.closure</code>.</td>\n<td align=\"left\">This establishes the lexical scope link for the function call.</td>\n</tr>\n<tr>\n<td align=\"left\">3. <strong>Parameter Binding</strong></td>\n<td align=\"left\"><code>FunctionValue</code> → new <code>Environment</code>: <code>define(param_name, argument_value)</code> for each parameter/argument pair.</td>\n<td align=\"left\">Binds the call&#39;s arguments to the function&#39;s parameter names in the new local environment.</td>\n</tr>\n<tr>\n<td align=\"left\">4. <strong>Body Evaluation</strong></td>\n<td align=\"left\"><code>FunctionValue</code> → <code>Evaluator</code>: <code>evaluate(self.body, new_environment)</code></td>\n<td align=\"left\">Executes the function body within the newly created and populated environment.</td>\n</tr>\n<tr>\n<td align=\"left\">5. <strong>Result Return</strong></td>\n<td align=\"left\"><code>Evaluator</code> → <code>FunctionValue</code>: Returns a value or raises <code>ReturnSignal</code>.</td>\n<td align=\"left\">The body&#39;s result is captured. <code>ReturnSignal</code> is caught and its value is extracted.</td>\n</tr>\n<tr>\n<td align=\"left\">6. <strong>Call Completion</strong></td>\n<td align=\"left\"><code>FunctionValue</code> → <code>Evaluator</code>: Returns the extracted value.</td>\n<td align=\"left\">The result of the function call is delivered to the original call site in the evaluator.</td>\n</tr>\n</tbody></table>\n<p><strong>Control Flow Signal Formats:</strong>\nThese signals are implemented as exception classes (or a similar mechanism) to facilitate non-local exit. Their fields carry necessary information.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Signal Class</th>\n<th align=\"left\">Fields</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>BreakSignal</code></td>\n<td align=\"left\">None</td>\n<td align=\"left\">Signals that the nearest enclosing loop should terminate immediately.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ContinueSignal</code></td>\n<td align=\"left\">None</td>\n<td align=\"left\">Signals that the nearest enclosing loop should skip to the next iteration.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ReturnSignal</code></td>\n<td align=\"left\"><code>value: Any</code></td>\n<td align=\"left\">Signals that a function should exit and return the attached <code>value</code>.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The uniformity of the <code>evaluate(node, environment)</code> interface is the interpreter&#39;s greatest strength. Every piece of code, from a simple literal to a complex loop, is evaluated through the same recursive doorway. This consistency simplifies the architecture and makes it easy to extend with new node types.</p>\n</blockquote>\n<p><strong>ADR: Control Flow via Exceptions</strong></p>\n<blockquote>\n<p><strong>Decision: Use exceptions for non-local control flow (break, continue, return).</strong></p>\n<ul>\n<li><strong>Context</strong>: Statements like <code>break</code> and <code>return</code> need to exit multiple levels of nested evaluation (e.g., break out of a loop that is deep inside several block statements). The evaluator uses deep recursion; returning normally would require every intermediate function to check for and propagate a special flag.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Exception Mechanism</strong>: Raise a special signal (<code>BreakSignal</code>) that unwinds the stack until caught by the loop evaluator.</li>\n<li><strong>Explicit Status Propagation</strong>: Have <code>evaluate</code> return a tuple <code>(status, value)</code> where <code>status</code> indicates normal completion, break, continue, or return. Each caller must check and propagate this status.</li>\n<li><strong>Continuation Passing Style (CPS)</strong>: Transform the evaluator to manage control flow explicitly via callbacks. This is more powerful but significantly more complex.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use the Exception Mechanism (Option 1).</li>\n<li><strong>Rationale</strong>: Exceptions are a language feature designed precisely for non-local exit. They cleanly separate the point where a control flow event is triggered from the point where it is handled, without polluting the return type of every evaluation method. This leads to simpler, more readable core logic. The performance overhead is negligible for a learning-focused tree-walking interpreter.</li>\n<li><strong>Consequences</strong>: The loop and function evaluation methods must be wrapped in try-catch blocks. Control flow signals must be distinct from actual runtime errors (like <code>TypeError</code>). This approach is idiomatic in many languages (Python, Java, C#) for implementing interpreters.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Exceptions</strong></td>\n<td align=\"left\">Clean separation, minimal code pollution, idiomatic.</td>\n<td align=\"left\">Can be confused with real errors, requires careful catch blocks.</td>\n<td align=\"left\"><strong>Yes</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Status Propagation</strong></td>\n<td align=\"left\">Explicit control flow, no language-specific mechanism.</td>\n<td align=\"left\">Clutters every function signature and call site with status checks.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>CPS</strong></td>\n<td align=\"left\">Ultimate control flow flexibility, enables advanced features.</td>\n<td align=\"left\">Extreme complexity, fundamental rewrite of the evaluator.</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides the skeleton code and integration points for the interaction patterns described above. The focus is on how the components connect, not on re-implementing their internal logic.</p>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option</th>\n<th align=\"left\">Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Control Flow Signals</td>\n<td align=\"left\">Custom Exception classes (inherit from <code>Exception</code>).</td>\n<td align=\"left\">A dedicated <code>Result</code> monad type that encapsulates both value and control flow state (more functional, but complex).</td>\n</tr>\n<tr>\n<td align=\"left\">Environment Chain</td>\n<td align=\"left\">Python dictionaries with an explicit <code>parent</code> reference.</td>\n<td align=\"left\">A persistent immutable hash map (like <code>pyrsistent</code>) for efficient snapshots and undo, useful for advanced debugging or time-travel.</td>\n</tr>\n<tr>\n<td align=\"left\">Function Call Management</td>\n<td align=\"left\">Direct recursion within the <code>Evaluator</code>.</td>\n<td align=\"left\">An explicit call stack list storing <code>(function, environment, return_address)</code> tuples, which would allow for future features like stack traces and tail-call optimization.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong>\nThe interactions span multiple files. Ensure your project structure keeps related components together.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>tree_walk_interpreter/\n│\n├── interpreter.py           # Main Interpreter class (orchestrates parsing and evaluation)\n├── evaluator.py             # Evaluator class (core dispatch logic)\n├── environment.py           # Environment class and runtime error definitions\n├── ast_nodes.py             # AST node class definitions (from parser)\n├── values.py                # Runtime value wrappers (e.g., FunctionValue)\n└── control_flow.py          # ControlFlowSignal and its subclasses (BreakSignal, etc.)</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code: Control Flow Signals</strong>\nThese exception classes are complete and ready to use. They form the messaging system for non-local exits.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># control_flow.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Signals for non-local control flow within the interpreter.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">These are raised as exceptions and caught by the appropriate handler.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ControlFlowSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all non-local control flow signals.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreakSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised by a `break` statement. Caught by the nearest enclosing loop evaluator.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ContinueSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised by a `continue` statement. Caught by the nearest enclosing loop evaluator.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ReturnSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised by a `return` statement. Carries the return value back to the function call.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code: Integrating Signals and Calls</strong>\nThe following code snippets show key integration points in the <code>Evaluator</code> where the components interact. Fill in the TODOs based on the sequence walkthroughs.</p>\n<p><strong>1. Loop Evaluation with Break/Continue Handling</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># evaluator.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... other methods ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_while_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate a while loop statement.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Handles break and continue signals.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Enter a loop: Evaluate the condition expression using self.evaluate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: While the condition result is truthy (use self._is_truthy):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2a: Try to evaluate the loop body statement(s) using self.evaluate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2b: If a BreakSignal is raised, break out of the while loop entirely</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2c: If a ContinueSignal is raised, simply continue to the next iteration (skip any remainder of the body)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2d: Re-evaluate the condition for the next iteration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Loop finished (condition false or break). Return None.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_break_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a break statement by raising the signal.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Simply raise BreakSignal()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_continue_stmt</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a continue statement by raising the signal.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Simply raise ContinueSignal()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>2. Function Call Evaluation and Return Handling</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># evaluator.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... other methods ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_call_expr</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a function call expression.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate the callee expression (node.callee) to get the callable (should be a FunctionValue)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Evaluate each argument expression in node.arguments, producing a list of argument values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify the callee is callable (e.g., isinstance(callee, FunctionValue))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check arity: len(arguments) should equal len(callee.parameters). Raise ArgumentError if not.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Call callee.call(arguments) and return its result.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># values.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FunctionValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name, parameters, body, closure):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name          </span><span style=\"color:#6A737D\"># Optional, for debugging</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parameters </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parameters  </span><span style=\"color:#6A737D\"># List of parameter name strings</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> body          </span><span style=\"color:#6A737D\"># The AST block or statement for the function body</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.closure </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> closure    </span><span style=\"color:#6A737D\"># The Environment where the function was defined</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">(self, arguments):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute the function with the given arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create a new Environment for this function call. Set its parent to self.closure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each parameter name and corresponding argument value, define the binding in the new environment.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Try to evaluate self.body within the new environment.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If a ReturnSignal is raised during evaluation, catch it and return its .value attribute.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If evaluation completes without a ReturnSignal (i.e., falls off the end of the function), return None (implicit nil return).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Python)</strong></p>\n<ul>\n<li><strong>Catching Multiple Exceptions:</strong> Use separate <code>except</code> clauses for <code>BreakSignal</code>, <code>ContinueSignal</code>, and <code>ReturnSignal</code> to handle them differently. You can also catch the base <code>ControlFlowSignal</code> and then check its type.</li>\n<li><strong>Maintaining Clean Stack Traces:</strong> When raising a custom <code>RuntimeError</code>, include the relevant token information (like line number) for user-friendly error messages. The <code>ControlFlowSignal</code> exceptions are for internal control and should not be reported as user errors.</li>\n<li><strong>Environment References:</strong> Be mindful of circular references (e.g., an environment stored in a closure). Python&#39;s garbage collector will handle it, but for long-running programs, ensure you&#39;re not accidentally holding onto large environment chains unnecessarily.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint: Integration Test</strong>\nAfter implementing the components and their interactions, run this integration test to verify the scenarios from this section work correctly.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_integration.py (simple script)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Interpreter</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">source </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">var a = 1;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">fun makeAdder(b) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    fun adder(c) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        return a + b + c;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    return adder;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">var addTwo = makeAdder(2);</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(addTwo(3)); // Should print 6</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">var i = 0;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">while (i &#x3C; 10) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    if (i == 5) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        break;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    i = i + 1;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(i); // Should print 5</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Interpreter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">success </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> interpreter.interpret(source)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Interpretation succeeded:\"</span><span style=\"color:#E1E4E8\">, success)</span></span></code></pre></div>\n<p><strong>Expected Output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>6\n5\nInterpretation succeeded: True</code></pre></div>\n\n<p><strong>G. Debugging Tips for Interactions</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom</th>\n<th align=\"left\">Likely Cause</th>\n<th align=\"left\">How to Diagnose</th>\n<th align=\"left\">Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Variable lookup returns <code>nil</code> or wrong value from outer scope.</td>\n<td align=\"left\">The environment chain link (<code>parent</code>) is broken or not set when creating a new scope.</td>\n<td align=\"left\">Add debug prints to <code>Environment.get</code> to log each step of the lookup chain. Check that inner environment creation correctly sets <code>parent</code>.</td>\n<td align=\"left\">Ensure <code>Environment(parent=...)</code> is called when creating block, function, or loop bodies.</td>\n</tr>\n<tr>\n<td align=\"left\">Function does not remember variables from its outer scope (closure broken).</td>\n<td align=\"left\">The <code>FunctionValue.closure</code> field is set to the wrong environment (e.g., the global env instead of the defining one).</td>\n<td align=\"left\">Print the <code>closure</code> field when a function is created and when it&#39;s called. Verify it&#39;s the environment active at definition time.</td>\n<td align=\"left\">When evaluating a function declaration, capture the <em>current</em> environment (<code>env</code>) as the closure.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>break</code> or <code>return</code> causes the entire interpreter to crash with an uncaught exception.</td>\n<td align=\"left\">The corresponding signal is not being caught by the appropriate handler (loop or function call).</td>\n<td align=\"left\">Check that <code>_evaluate_while_stmt</code> and <code>FunctionValue.call</code> have try-catch blocks for the relevant signals.</td>\n<td align=\"left\">Wrap the loop body evaluation in a try-catch for <code>BreakSignal</code>. Wrap the function body evaluation in a try-catch for <code>ReturnSignal</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Loop runs forever even after <code>break</code> is executed.</td>\n<td align=\"left\">The <code>BreakSignal</code> is being caught by a handler <em>outside</em> the loop (e.g., a block evaluator), preventing the loop from seeing it.</td>\n<td align=\"left\">Ensure only the loop evaluator catches <code>BreakSignal</code>. Block evaluators should not catch it; they should let it propagate.</td>\n<td align=\"left\">Remove any <code>except BreakSignal</code> from <code>_evaluate_block_stmt</code> and similar non-loop statement evaluators.</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 2, 3, 4</p>\n<p>This section defines the interpreter&#39;s approach to runtime failures and exceptional conditions. Unlike compiled languages that catch many errors during compilation, an interpreter must validate operations at runtime, making robust error handling critical. We&#39;ll catalog expected failure modes, define detection strategies, and establish recovery behaviors—most of which involve halting execution with a clear diagnostic message.</p>\n</blockquote>\n<h3 id=\"runtime-error-types\">Runtime Error Types</h3>\n<p>In a tree-walking interpreter, <strong>runtime errors</strong> represent invalid operations that cannot be detected until execution time. Think of these as &quot;math errors&quot; that occur when you actually perform calculations, not when you write the equations. For example, dividing by zero isn&#39;t wrong in the syntax <code>10 / 0</code>, but becomes invalid when you attempt the division operation.</p>\n<p>Our interpreter recognizes five core error categories, each represented by a dedicated exception class that inherits from a common base:</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Trigger Condition</th>\n<th>Typical Location in AST</th>\n<th>Example Source</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Type Error</strong></td>\n<td>Operation applied to incompatible operand types</td>\n<td>Binary/unary expression evaluation</td>\n<td><code>&quot;hello&quot; + 42</code></td>\n</tr>\n<tr>\n<td><strong>Undefined Variable Error</strong></td>\n<td>Attempt to read or assign to undeclared variable</td>\n<td>Variable expression or assignment</td>\n<td><code>x = 10; print y;</code></td>\n</tr>\n<tr>\n<td><strong>Division By Zero Error</strong></td>\n<td>Division operator with right operand of zero</td>\n<td>Binary expression (division operator)</td>\n<td><code>10 / 0</code></td>\n</tr>\n<tr>\n<td><strong>Argument Error</strong></td>\n<td>Function call with incorrect argument count</td>\n<td>Function call expression</td>\n<td><code>fn add(a,b){a+b}; add(1);</code></td>\n</tr>\n<tr>\n<td><strong>Control Flow Error</strong></td>\n<td><code>break</code>/<code>continue</code> outside loop context</td>\n<td>Break/continue statement</td>\n<td><code>if true { break; }</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: We separate <code>DivisionByZeroError</code> from <code>TypeError</code> because division by zero is a <em>domain</em> error (mathematically invalid) rather than a <em>type</em> error (operand-type mismatch). This distinction helps users understand whether they used the wrong operator or the wrong value.</p>\n</blockquote>\n<p>Each error class extends a common base <code>RuntimeError</code> with standardized fields:</p>\n<table>\n<thead>\n<tr>\n<th>Error Class</th>\n<th>Parent</th>\n<th>Fields (beyond inherited)</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RuntimeError</code></td>\n<td>(Base class)</td>\n<td><code>message: str</code>, <code>token: Token</code></td>\n<td>Base for all runtime errors</td>\n</tr>\n<tr>\n<td><code>TypeError</code></td>\n<td><code>RuntimeError</code></td>\n<td>(none)</td>\n<td>Operation on incompatible types</td>\n</tr>\n<tr>\n<td><code>UndefinedVariableError</code></td>\n<td><code>RuntimeError</code></td>\n<td>(none)</td>\n<td>Reference to undefined variable</td>\n</tr>\n<tr>\n<td><code>DivisionByZeroError</code></td>\n<td><code>RuntimeError</code></td>\n<td>(none)</td>\n<td>Division by numeric zero</td>\n</tr>\n<tr>\n<td><code>ArgumentError</code></td>\n<td><code>RuntimeError</code></td>\n<td>(none)</td>\n<td>Incorrect function argument count</td>\n</tr>\n</tbody></table>\n<p><strong>Mental Model: Traffic Violation Tickets</strong>\nThink of each error type as a specific traffic violation. A <code>TypeError</code> is like trying to drive a car on a train track—wrong vehicle for the infrastructure. An <code>UndefinedVariableError</code> is like trying to deliver a package to a non-existent address. A <code>DivisionByZeroError</code> is like trying to split a pizza among zero people—mathematically undefined. Each violation requires a specific citation (error message) explaining what rule was broken.</p>\n<p>The <code>RuntimeError</code> base class provides consistent error reporting through its fields:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>message</code></td>\n<td><code>str</code></td>\n<td>Human-readable error description including contextual details</td>\n</tr>\n<tr>\n<td><code>token</code></td>\n<td><code>Token</code></td>\n<td>The token from the source code where the error occurred (contains line/column)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>ADR: Granular Error Types vs. Single Generic Error</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to decide how specifically to categorize runtime failures for better debugging and error messages.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Single generic <code>RuntimeError</code></strong>: One class with a string error code</li>\n<li><strong>Granular error hierarchy</strong>: Separate classes for each error category (chosen)</li>\n<li><strong>Error codes in base class</strong>: Single class with enum error codes</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement granular error hierarchy with dedicated classes</li>\n<li><strong>Rationale</strong>: <ol>\n<li><strong>Better debugging</strong>: Catch specific error types during testing</li>\n<li><strong>Clearer error messages</strong>: Each class can generate tailored messages</li>\n<li><strong>Future extensibility</strong>: Easy to add new error types without modifying existing code</li>\n<li><strong>Educational value</strong>: Helps learners understand different failure modes</li>\n</ol>\n</li>\n<li><strong>Consequences</strong>: <ul>\n<li>More classes to maintain</li>\n<li>Slightly more complex error handling code</li>\n<li>Better user experience with specific error diagnostics</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single generic error</td>\n<td>Simple implementation, fewer classes</td>\n<td>Vague error messages, harder to test specific cases</td>\n<td>✗</td>\n</tr>\n<tr>\n<td>Granular hierarchy</td>\n<td>Specific error handling, better debugging</td>\n<td>More boilerplate, multiple exception classes</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>Error codes enum</td>\n<td>Middle ground, single class structure</td>\n<td>Still requires switch statements, less type safety</td>\n<td>✗</td>\n</tr>\n</tbody></table>\n<h3 id=\"detection-and-reporting\">Detection and Reporting</h3>\n<p>Runtime error detection follows a <strong>proactive validation</strong> strategy: before performing any operation that could fail, we check preconditions and raise the appropriate error if conditions aren&#39;t met. This happens at specific points in the evaluation process, typically within operator evaluation methods and environment lookup operations.</p>\n<h4 id=\"detection-points-and-strategies\">Detection Points and Strategies</h4>\n<p>Each error type has specific detection logic:</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Point</th>\n<th>Validation Logic</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Type Error</strong></td>\n<td>Binary/unary operator evaluation</td>\n<td>Check operand types before operation using type predicates</td>\n</tr>\n<tr>\n<td><strong>Undefined Variable</strong></td>\n<td><code>Environment.get()</code> method</td>\n<td>Walk parent chain; if name not found, raise error</td>\n</tr>\n<tr>\n<td><strong>Division By Zero</strong></td>\n<td>Division operator evaluation</td>\n<td>Check right operand equals numeric zero before division</td>\n</tr>\n<tr>\n<td><strong>Argument Error</strong></td>\n<td>Function call execution</td>\n<td>Compare argument count to parameter count before binding</td>\n</tr>\n<tr>\n<td><strong>Control Flow Error</strong></td>\n<td>Break/continue statement evaluation</td>\n<td>Check if executing within loop context via flag or environment</td>\n</tr>\n</tbody></table>\n<p><strong>Concrete Example Walkthrough</strong>: Consider evaluating the expression <code>&quot;hello&quot; * 3</code>:</p>\n<ol>\n<li><code>Evaluator._evaluate_binary_expr()</code> is called with a <code>Binary</code> node (operator: <code>*</code>, left: <code>&quot;hello&quot;</code>, right: <code>3</code>)</li>\n<li>Both operands are evaluated recursively: left yields string <code>&quot;hello&quot;</code>, right yields number <code>3</code></li>\n<li>Before applying multiplication, the method checks: <code>isinstance(left, str) and isinstance(right, (int, float))</code></li>\n<li>This check fails because string multiplication isn&#39;t supported (only numeric multiplication)</li>\n<li>Raise <code>TypeError(&quot;Operands must be numbers for multiplication&quot;)</code> with the <code>*</code> operator token</li>\n</ol>\n<h4 id=\"error-message-guidelines\">Error Message Guidelines</h4>\n<p>Effective error messages follow these principles:</p>\n<ol>\n<li><strong>Specificity</strong>: State exactly what went wrong, not just &quot;error&quot;</li>\n<li><strong>Context</strong>: Include the problematic operation and values involved</li>\n<li><strong>Location</strong>: Reference source line and column from the token</li>\n<li><strong>Actionable</strong>: Suggest possible fixes when obvious</li>\n</ol>\n<p>Error message templates for each error type:</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Message Template</th>\n<th>Example Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Type Error</td>\n<td><code>&quot;Operand TYPE_A for OPERATOR must be TYPE_B&quot;</code></td>\n<td><code>&quot;Operand &#39;hello&#39; for * must be a number at line 1:15&quot;</code></td>\n</tr>\n<tr>\n<td>Undefined Variable</td>\n<td><code>&quot;Undefined variable &#39;NAME&#39;&quot;</code></td>\n<td><code>&quot;Undefined variable &#39;count&#39; at line 3:8&quot;</code></td>\n</tr>\n<tr>\n<td>Division By Zero</td>\n<td><code>&quot;Division by zero&quot;</code></td>\n<td><code>&quot;Division by zero at line 2:12&quot;</code></td>\n</tr>\n<tr>\n<td>Argument Error</td>\n<td><code>&quot;Expected ARITY arguments but got COUNT&quot;</code></td>\n<td><code>&quot;Expected 2 arguments but got 1 at line 5:3&quot;</code></td>\n</tr>\n<tr>\n<td>Control Flow Error</td>\n<td><code>&quot;BREAK/CONTINUE outside loop&quot;</code></td>\n<td><code>&quot;break outside loop at line 4:5&quot;</code></td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Algorithm for Type Checking</strong>:</p>\n<ol>\n<li><p>When evaluating a binary operation:</p>\n<ol>\n<li>Evaluate left and right operands recursively</li>\n<li>Determine required types based on operator (e.g., <code>+</code> accepts numbers or strings, <code>*</code> only numbers)</li>\n<li>If operands don&#39;t match required types, construct error message with:<ul>\n<li>Operator symbol from token</li>\n<li>Actual types of operands</li>\n<li>Expected types</li>\n<li>Source location from operator token</li>\n</ul>\n</li>\n<li>Raise <code>TypeError</code> with constructed message</li>\n</ol>\n</li>\n<li><p>When looking up a variable:</p>\n<ol>\n<li>Start at current environment</li>\n<li>Walk parent chain checking <code>store</code> dictionary for name</li>\n<li>If chain exhausted without finding name:<ul>\n<li>Construct message: <code>f&quot;Undefined variable &#39;{name}&#39;&quot;</code></li>\n<li>Use variable name token for location</li>\n<li>Raise <code>UndefinedVariableError</code></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight</strong>: Use the <code>token</code> field from AST nodes (provided by the parser) for error location. Every expression and statement node should store its relevant token (operator token for expressions, name token for variables, etc.).</p>\n</blockquote>\n<h4 id=\"recovery-behavior\">Recovery Behavior</h4>\n<p>The interpreter implements a <strong>fail-fast</strong> recovery strategy: when any runtime error occurs, execution halts immediately, the error is reported, and the interpreter returns to a clean state (ready for the next input). This mimics how most scripting languages handle runtime errors.</p>\n<p><strong>Recovery Process</strong>:</p>\n<ol>\n<li>Error raised in <code>Evaluator.evaluate()</code> or any handler method</li>\n<li>Error propagates up call stack through recursive evaluations</li>\n<li>Caught at top level in <code>Interpreter.interpret()</code> method</li>\n<li>Error message printed to stderr with format: <code>[RUNTIME ERROR] Message at line X:Y</code></li>\n<li><code>Interpreter.interpret()</code> returns <code>False</code> indicating failed execution</li>\n<li>Environment chain remains unchanged (no partial state corruption)</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Error Cascading</strong></p>\n<ul>\n<li><strong>Problem</strong>: After catching one error, continuing execution often leads to more confusing errors (e.g., undefined variables from previous failed assignment)</li>\n<li><strong>Why it&#39;s wrong</strong>: Masks the root cause and creates debugging confusion</li>\n<li><strong>Fix</strong>: Implement fail-fast—stop at first error and provide clear diagnostics</li>\n</ul>\n<h3 id=\"special-edge-cases\">Special Edge Cases</h3>\n<p>Beyond explicit runtime errors, several language semantics require careful handling of special values and conditions. These edge cases define the &quot;personality&quot; of the language and must be implemented consistently.</p>\n<h4 id=\"nil-handling\">Nil Handling</h4>\n<p><code>nil</code> represents the absence of a value (similar to <code>null</code> or <code>None</code>). Its semantics include:</p>\n<table>\n<thead>\n<tr>\n<th>Context</th>\n<th>Behavior</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Arithmetic operations</strong></td>\n<td><code>TypeError</code> (nil is not numeric)</td>\n<td>Prevents silent bugs from uninitialized variables</td>\n</tr>\n<tr>\n<td><strong>Comparison</strong></td>\n<td><code>nil == nil</code> → <code>true</code>, <code>nil == anything_else</code> → <code>false</code></td>\n<td>Follows equality semantics of &quot;no value&quot;</td>\n</tr>\n<tr>\n<td><strong>Logical operators</strong></td>\n<td><code>nil</code> is falsy</td>\n<td>Consistent with &quot;absence&quot; being falsey</td>\n</tr>\n<tr>\n<td><strong>String concatenation</strong></td>\n<td>Convert to <code>&quot;nil&quot;</code> string</td>\n<td>Allows <code>print</code> to display nil values</td>\n</tr>\n<tr>\n<td><strong>Function return</strong></td>\n<td>Default return value when no <code>return</code> statement</td>\n<td>Functions always return something</td>\n</tr>\n</tbody></table>\n<p><strong>Algorithm for Nil Propagation</strong>:</p>\n<ol>\n<li>When a variable is declared without initializer: <code>var x;</code> → binds <code>nil</code> to <code>x</code></li>\n<li>When accessing undefined variable: raises <code>UndefinedVariableError</code> (different from nil)</li>\n<li>When function reaches end without return: implicitly returns <code>nil</code></li>\n<li>When printing nil: <code>Interpreter._stringify(nil)</code> returns <code>&quot;nil&quot;</code></li>\n</ol>\n<h4 id=\"truthiness-rules\">Truthiness Rules</h4>\n<p><strong>Truthiness</strong> determines which values count as &quot;true&quot; in boolean contexts (if conditions, while loops, logical operators). Our rules follow the principle of <strong>minimal surprise</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Value Type</th>\n<th>Truthiness</th>\n<th>Reasoning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Boolean <code>true</code></td>\n<td><code>true</code></td>\n<td>Literal true</td>\n</tr>\n<tr>\n<td>Boolean <code>false</code></td>\n<td><code>false</code></td>\n<td>Literal false</td>\n</tr>\n<tr>\n<td><code>nil</code></td>\n<td><code>false</code></td>\n<td>Absence of value is falsey</td>\n</tr>\n<tr>\n<td>Number <code>0</code></td>\n<td><code>true</code></td>\n<td>Unlike some languages, zero is truthy</td>\n</tr>\n<tr>\n<td>Empty string <code>&quot;&quot;</code></td>\n<td><code>true</code></td>\n<td>String exists, even if empty</td>\n</tr>\n<tr>\n<td>All other values</td>\n<td><code>true</code></td>\n<td>Default: everything exists is truthy</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Algorithm</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># In Evaluator._is_truthy(value):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> or</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#6A737D\">  # Everything else is truthy</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>ADR: Zero/Empty String Truthiness</strong></p>\n<ul>\n<li><strong>Context</strong>: Need consistent rules for what values count as false in boolean contexts</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>JavaScript-style</strong>: <code>0</code>, <code>&quot;&quot;</code>, <code>null</code>, <code>undefined</code>, <code>false</code>, <code>NaN</code> are falsey</li>\n<li><strong>Python-style</strong>: <code>0</code>, <code>0.0</code>, <code>False</code>, <code>None</code>, empty collections are falsey  </li>\n<li><strong>Simple strict</strong>: Only <code>false</code> and <code>nil</code> are falsey (chosen)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Only <code>false</code> and <code>nil</code> are falsey</li>\n<li><strong>Rationale</strong>:<ol>\n<li><strong>Simplicity</strong>: Easy to remember and explain</li>\n<li><strong>Predictability</strong>: <code>if (0)</code> and <code>if (&quot;&quot;)</code> work as intuitively expected</li>\n<li><strong>Consistency</strong>: Numbers and strings always behave uniformly</li>\n<li><strong>Avoids bugs</strong>: Common error <code>if (x)</code> where <code>x</code> is <code>0</code> still executes</li>\n</ol>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Different from many mainstream languages</li>\n<li>Requires explicit <code>x == 0</code> checks for numeric zero conditions</li>\n<li>Fewer surprises for beginners</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"empty-statement-blocks\">Empty Statement Blocks</h4>\n<p>An empty block <code>{}</code> or statement list evaluates to <code>nil</code>:</p>\n<ol>\n<li><strong>Empty block evaluation</strong>: <code>Evaluator._evaluate_block_stmt()</code> returns <code>nil</code> when no statements</li>\n<li><strong>Empty if/else branches</strong>: Missing else clause implicitly returns <code>nil</code></li>\n<li><strong>Empty function body</strong>: Returns <code>nil</code> when called</li>\n</ol>\n<p><strong>Example Walkthrough</strong>: Evaluating <code>if (false) { 10; }</code></p>\n<ol>\n<li>Condition evaluates to <code>false</code></li>\n<li>Then branch is skipped (not evaluated at all)</li>\n<li>No else branch exists</li>\n<li>Entire <code>if</code> statement returns <code>nil</code></li>\n</ol>\n<h4 id=\"implicit-return-from-functions\">Implicit Return from Functions</h4>\n<p>When a function execution reaches the end of its body without encountering a <code>return</code> statement, it <strong>implicitly returns <code>nil</code></strong>. This ensures all function calls produce a value.</p>\n<p><strong>Execution Flow</strong>:</p>\n<ol>\n<li>Function body is evaluated as a block statement</li>\n<li>If block completes normally (no <code>ReturnSignal</code> raised), evaluation returns <code>nil</code></li>\n<li>This <code>nil</code> becomes the return value of the function call</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Forgetting Return in Recursive Base Case</strong></p>\n<ul>\n<li><strong>Problem</strong>: Recursive function without return in base case returns <code>nil</code>, contaminating result</li>\n<li><strong>Example</strong>: <code>function fact(n) { if (n &lt;= 1) { 1; } else { n * fact(n-1); } }</code> (missing <code>return</code>)</li>\n<li><strong>Why it&#39;s wrong</strong>: Base case returns <code>nil</code>, making whole expression <code>n * nil</code> → <code>TypeError</code></li>\n<li><strong>Fix</strong>: Always use explicit <code>return</code> statements in functions</li>\n</ul>\n<h4 id=\"short-circuit-evaluation-edge-cases\">Short-Circuit Evaluation Edge Cases</h4>\n<p>Logical operators <code>and</code> and <code>or</code> use short-circuit evaluation, which has subtle edge cases:</p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Evaluation Behavior</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>false and (1/0)</code></td>\n<td>Right operand never evaluated</td>\n<td><code>false</code> (no division error)</td>\n</tr>\n<tr>\n<td><code>true or (x = 10)</code></td>\n<td>Right operand never evaluated</td>\n<td><code>true</code> (assignment doesn&#39;t happen)</td>\n</tr>\n<tr>\n<td><code>nil or &quot;default&quot;</code></td>\n<td>Right operand evaluated (nil is falsey)</td>\n<td><code>&quot;default&quot;</code></td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Algorithm</strong>:</p>\n<ol>\n<li>Evaluate left operand</li>\n<li>For <code>and</code>: if left is falsey, return left (skip right)</li>\n<li>For <code>or</code>: if left is truthy, return left (skip right)  </li>\n<li>Otherwise, evaluate and return right operand</li>\n</ol>\n<h4 id=\"variable-shadowing-and-redeclaration\">Variable Shadowing and Redeclaration</h4>\n<p>Variable <strong>shadowing</strong> (inner scope redefining outer variable) is allowed, but redeclaration in same scope should be detected:</p>\n<table>\n<thead>\n<tr>\n<th>Case</th>\n<th>Behavior</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>var x = 1; { var x = 2; }</code></td>\n<td>Allowed (shadowing)</td>\n<td><code>Environment.define()</code> always succeeds</td>\n</tr>\n<tr>\n<td><code>var x = 1; var x = 2;</code></td>\n<td>Allowed (redeclaration)</td>\n<td>Overwrites existing binding</td>\n</tr>\n<tr>\n<td><code>x = 1;</code> (no prior <code>var</code>)</td>\n<td><code>UndefinedVariableError</code></td>\n<td><code>Environment.assign()</code> fails if not found</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Choice</strong>: We allow redeclaration in same scope for simplicity, though some languages prohibit it. This matches JavaScript&#39;s <code>var</code> semantics rather than <code>let</code>.</p>\n</blockquote>\n<h4 id=\"division-and-modulo-by-zero\">Division and Modulo by Zero</h4>\n<p>While <code>DivisionByZeroError</code> catches <code>/ 0</code>, we must also handle:</p>\n<ol>\n<li><strong>Integer division by zero</strong>: Same error (mathematically undefined)</li>\n<li><strong>Modulo by zero</strong>: <code>10 % 0</code> should also raise <code>DivisionByZeroError</code> </li>\n<li><strong>Negative zero</strong>: <code>-0</code> is still zero numerically, triggers error</li>\n</ol>\n<p><strong>Algorithm for Division Operators</strong>:</p>\n<ol>\n<li>Evaluate right operand</li>\n<li>If right operand is numeric zero (0 or 0.0 or -0.0):<ul>\n<li>Construct message: <code>&quot;Division by zero&quot;</code></li>\n<li>Use operator token for location</li>\n<li>Raise <code>DivisionByZeroError</code></li>\n</ul>\n</li>\n<li>Otherwise, perform operation normally</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Types</td>\n<td>Custom exception classes with message/token</td>\n<td>Rich error hierarchy with error codes, suggestions</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td>Simple print to stderr</td>\n<td>Structured logging with context capture</td>\n</tr>\n<tr>\n<td>Validation</td>\n<td>Manual type checks in each operator</td>\n<td>Visitor pattern with type validation decorators</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>interpreter/\n├── __init__.py\n├── ast.py              # AST node definitions\n├── parser.py           # Parser (generates AST)\n├── interpreter.py      # Main Interpreter class\n├── evaluator.py        # Evaluator class with evaluation logic\n├── environment.py      # Environment class hierarchy\n├── errors.py           # Error class definitions ← NEW FILE\n└── values.py           # Runtime value wrappers (optional)</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-error-classes\">Infrastructure Starter Code: Error Classes</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Runtime error definitions for the tree-walking interpreter.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">All errors include source location via token reference.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all runtime errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize a runtime error.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            message: Human-readable error description</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            token: The Token from source where error occurred</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format error for display including line number.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.token:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"[RUNTIME ERROR] </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> at line </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.token.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.token.column</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"[RUNTIME ERROR] </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Operation on incompatible types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UndefinedVariableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Reference to undefined variable.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DivisionByZeroError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Division or modulo by zero.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArgumentError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">RuntimeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Incorrect number of function arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Control flow signals (not errors, but exceptional flow)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ControlFlowSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base for break/continue/return signals.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreakSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a break statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ContinueSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a continue statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ReturnSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signals a return statement with value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-error-detection-in-evaluator\">Core Logic Skeleton: Error Detection in Evaluator</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># evaluator.py (partial)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TypeError</span><span style=\"color:#E1E4E8\">, UndefinedVariableError, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DivisionByZeroError, ArgumentError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recursive AST evaluator with error checking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_binary_expr</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate binary expression with type checking.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: Binary expression AST node</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current evaluation environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Result of binary operation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            TypeError: If operands have incompatible types</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            DivisionByZeroError: If division by zero</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate left and right operands recursively</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # left_val = self.evaluate(node.left, env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # right_val = self.evaluate(node.right, env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for division by zero for / and % operators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # if node.operator.type in (TokenType.SLASH, TokenType.PERCENT):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     if self._is_zero(right_val):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         raise DivisionByZeroError(</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #             \"Division by zero\", </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #             node.operator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Determine expected types based on operator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For +: numbers or strings (but both same type)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For -, *, /, %: numbers only</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For comparisons: numbers or strings (comparable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For equality: any types allowed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate operand types match expected types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # if not self._check_types(left_val, right_val, node.operator):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     actual_types = (type(left_val).__name__, type(right_val).__name__)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     raise TypeError(</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         f\"Operands {actual_types[0]} and {actual_types[1]} \"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         f\"for {node.operator.lexeme} must be compatible\",</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         node.operator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Perform the operation based on operator type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Use Python's operators with appropriate type conversions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_call_expr</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate function call expression.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: Call expression AST node</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            env: Current evaluation environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Function return value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ArgumentError: If argument count doesn't match parameter count</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate the callee (function) expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Evaluate all argument expressions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify callee is callable (FunctionValue)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check argument count matches parameter count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # if len(arguments) != len(function.parameters):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     raise ArgumentError(</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         f\"Expected {len(function.parameters)} arguments \"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         f\"but got {len(arguments)}\",</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         node.paren  # Use closing parenthesis token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Call the function with arguments</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _is_truthy</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Determine truthiness of a runtime value.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            value: Any runtime value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if value is truthy, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return False for nil and False boolean</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return True for all other values (including 0, \"\")</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _is_zero</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if value is numeric zero (including negative zero).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            value: Any runtime value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if value is numeric zero</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if value is int or float</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return True if value == 0 (works for 0.0 and -0.0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"environment-with-error-detection\">Environment with Error Detection</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># environment.py (partial)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> UndefinedVariableError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Lexical scope environment with error checking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(self, name_token):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Retrieve variable value by name, walking parent chain.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name_token: Token containing variable name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Variable value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            UndefinedVariableError: If variable not found in any scope</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check current environment's store for name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # if name_token.lexeme in self.store:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     return self.store[name_token.lexeme]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If not found and has parent, delegate to parent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If no parent (global) and not found, raise error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # raise UndefinedVariableError(</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     f\"Undefined variable '{name_token.lexeme}'\",</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     name_token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assign</span><span style=\"color:#E1E4E8\">(self, name_token, value):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Update existing variable binding.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name_token: Token containing variable name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            value: New value to assign</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            UndefinedVariableError: If variable not found in any scope</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check current environment for variable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If found, update value in current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If not found and has parent, delegate to parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If no parent and not found, raise UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-python\">Language-Specific Hints (Python)</h4>\n<ol>\n<li><strong>Exception Inheritance</strong>: Use <code>class TypeError(RuntimeError): pass</code> for minimal boilerplate</li>\n<li><strong>Token Storage</strong>: Store the full token object, not just line/column, for future extensions</li>\n<li><strong>Type Checking</strong>: Use <code>isinstance(value, (int, float))</code> for numeric checks, not <code>type(value) == int</code></li>\n<li><strong>Zero Detection</strong>: <code>value == 0</code> works for both <code>int</code> and <code>float</code> (including <code>-0.0</code>)</li>\n<li><strong>String Formatting</strong>: Use f-strings for error messages: <code>f&quot;Expected {expected} but got {actual}&quot;</code></li>\n</ol>\n<h4 id=\"testing-error-handling\">Testing Error Handling</h4>\n<p>Create test programs that trigger each error type:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_errors.py</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">test_cases </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#9ECBFF\">\"1 + 'hello'\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TypeError\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#9ECBFF\">\"print(undefined)\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"UndefinedVariableError\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#9ECBFF\">\"10 / 0\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DivisionByZeroError\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#9ECBFF\">\"function f(a,b){return a+b}; f(1)\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ArgumentError\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#9ECBFF\">\"break;\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ControlFlowError\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> source, expected_error </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> test_cases:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        interpreter.interpret(source)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"FAIL: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">source</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> should raise </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected_error</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> type</span><span style=\"color:#E1E4E8\">(e).</span><span style=\"color:#79B8FF\">__name__</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> error_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> expected_error:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"PASS: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">source</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> raised </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">error_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"FAIL: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">source</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> raised </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">error_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected_error</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Expected Output</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>PASS: 1 + 'hello' raised TypeError\nPASS: print(undefined) raised UndefinedVariableError  \nPASS: 10 / 0 raised DivisionByZeroError\nPASS: function f(a,b){return a+b}; f(1) raised ArgumentError\nPASS: break; raised ControlFlowError</code></pre></div>\n\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error message shows wrong line number</td>\n<td>Token not passed correctly to error</td>\n<td>Print token line/column in error handler</td>\n<td>Ensure all error raises include the relevant token</td>\n</tr>\n<tr>\n<td>Type error on valid operation</td>\n<td>Missing type check for specific operator</td>\n<td>Add debug print to show operand types</td>\n<td>Add type validation for that operator</td>\n</tr>\n<tr>\n<td>Undefined variable when variable exists</td>\n<td>Environment chain traversal bug</td>\n<td>Print environment chain during lookup</td>\n<td>Fix parent traversal logic in <code>Environment.get()</code></td>\n</tr>\n<tr>\n<td>Division by zero not caught</td>\n<td>Float -0.0 not recognized as zero</td>\n<td>Print value and <code>value == 0</code> check</td>\n<td>Use <code>value == 0</code> not <code>value is 0</code></td>\n</tr>\n<tr>\n<td>Implicit return returns wrong value</td>\n<td>Block evaluation returns last statement, not nil</td>\n<td>Trace block statement evaluation</td>\n<td>Ensure empty block returns <code>nil</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 2, 3, 4</p>\n</blockquote>\n<p>A robust testing strategy is essential for building confidence in the interpreter&#39;s correctness and for catching regressions as features are added. This section outlines a comprehensive approach that combines <strong>unit tests</strong> for individual components with <strong>integration tests</strong> for complete programs, organized by the four project milestones. The testing philosophy follows a <strong>fail-fast</strong> approach, where the interpreter halts at the first detected error, making it easier to isolate and diagnose issues during development.</p>\n<h3 id=\"testing-approach-and-tools\">Testing Approach and Tools</h3>\n<p><strong>Mental Model: The Watchful Factory Inspector</strong><br>Think of testing as a quality control inspector in a factory assembly line. Unit tests are like inspecting individual machine parts (e.g., testing that a gear turns correctly in isolation). Integration tests are like running the entire assembly line with sample materials to verify the final product works as expected. The test suite acts as the inspector&#39;s checklist, systematically verifying each component and interaction.</p>\n<p>The recommended testing approach uses a <strong>pyramid structure</strong>: many fast, focused unit tests for core components, supplemented by fewer but comprehensive integration tests that exercise the entire interpreter on complete programs. This balance ensures both deep component validation and end-to-end system correctness.</p>\n<p><strong>Testing Framework Selection</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Test Framework</strong></td>\n<td>Built-in <code>unittest</code> module</td>\n<td><code>pytest</code> with richer features</td>\n</tr>\n<tr>\n<td><strong>Test Organization</strong></td>\n<td>One test file per component/module</td>\n<td>Feature-based test directories</td>\n</tr>\n<tr>\n<td><strong>Test Runner</strong></td>\n<td>IDE integration or command line</td>\n<td>CI/CD pipeline with coverage</td>\n</tr>\n</tbody></table>\n<p>For the primary Python implementation, we recommend starting with Python&#39;s built-in <code>unittest</code> framework for its simplicity and zero dependencies. As the project grows, teams may transition to <code>pytest</code> for its concise syntax and powerful fixtures, but the initial focus should remain on test coverage rather than framework sophistication.</p>\n<p><strong>Test Organization by Language Feature</strong></p>\n<p>Tests should be organized to mirror the project&#39;s milestones and the interpreter&#39;s feature progression:</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Corresponding Milestone</th>\n<th>Focus Areas</th>\n<th>Example Test Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Expression Evaluation</strong></td>\n<td>Milestone 1</td>\n<td>Literals, arithmetic, comparisons, logical operators</td>\n<td><code>2 + 3 * 4</code>, <code>!(true == false)</code>, <code>&quot;hello&quot; + &quot;world&quot;</code></td>\n</tr>\n<tr>\n<td><strong>Variable and Scope</strong></td>\n<td>Milestone 2</td>\n<td>Declaration, assignment, shadowing, nested environments</td>\n<td><code>var x = 5; { var x = 10; } print x;</code></td>\n</tr>\n<tr>\n<td><strong>Control Flow</strong></td>\n<td>Milestone 3</td>\n<td>Conditionals, loops, break/continue, return</td>\n<td><code>while (i &lt; 5) { if (i == 2) break; i = i + 1; }</code></td>\n</tr>\n<tr>\n<td><strong>Functions and Closures</strong></td>\n<td>Milestone 4</td>\n<td>Function definition, calls, parameters, closures, recursion</td>\n<td><code>fun makeCounter() { var i = 0; fun count() { i = i + 1; return i; } return count; }</code></td>\n</tr>\n</tbody></table>\n<p><strong>Test Structure Pattern</strong></p>\n<p>Each test follows a consistent pattern:</p>\n<ol>\n<li><strong>Setup</strong>: Initialize the interpreter with a clean <code>global_env</code></li>\n<li><strong>Execution</strong>: Call <code>Interpreter.interpret(source_code)</code> or directly invoke evaluator methods</li>\n<li><strong>Verification</strong>: Check returned values, printed output, or expected error conditions</li>\n<li><strong>Teardown</strong>: Reset any shared state to ensure test isolation</li>\n</ol>\n<p><strong>Special Considerations for Runtime Errors</strong></p>\n<p>Since the interpreter must detect and report various runtime errors, test cases should verify both successful execution and proper error handling:</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Test Approach</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>UndefinedVariableError</code></td>\n<td>Attempt to use undeclared variable</td>\n<td>Assert exception raised with correct token</td>\n</tr>\n<tr>\n<td><code>TypeError</code></td>\n<td>Apply operator to incompatible types</td>\n<td>Assert exception message mentions types</td>\n</tr>\n<tr>\n<td><code>DivisionByZeroError</code></td>\n<td>Divide by zero literal or variable</td>\n<td>Assert exception with division token</td>\n</tr>\n<tr>\n<td><code>ArgumentError</code></td>\n<td>Call function with wrong argument count</td>\n<td>Assert exception mentions expected vs actual</td>\n</tr>\n<tr>\n<td>Invalid <code>break</code>/<code>continue</code></td>\n<td>Use outside loop context</td>\n<td>Assert control flow signal caught appropriately</td>\n</tr>\n</tbody></table>\n<p>For error tests, the test should verify not just that an error occurs, but that it&#39;s the <em>correct</em> error type with an informative message containing the variable name, line number, or other diagnostic information.</p>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Each milestone has a <strong>verification checkpoint</strong>—a concrete test program that exercises the core acceptance criteria. These checkpoints serve as integration tests that validate the complete feature set for that milestone. When all checkpoint tests pass, the milestone can be considered complete.</p>\n<p><strong>Milestone 1 Checkpoint: Expression Evaluation</strong></p>\n<p>This test verifies all expression types work correctly, including operator precedence, type conversions, and short-circuit evaluation.</p>\n<p><strong>Test Program:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>// Basic literals\nprint 42;                         // Expect: 42\nprint &quot;hello&quot;;                    // Expect: hello\nprint true;                       // Expect: true\nprint nil;                        // Expect: nil\n\n// Arithmetic with precedence\nprint 2 + 3 * 4;                  // Expect: 14 (not 20)\nprint (2 + 3) * 4;                // Expect: 20\n\n// Comparisons\nprint 5 &gt; 3;                      // Expect: true\nprint 5 == 5;                     // Expect: true\nprint 5 != 5;                     // Expect: false\nprint &quot;abc&quot; == &quot;abc&quot;;             // Expect: true\nprint &quot;abc&quot; == &quot;def&quot;;             // Expect: false\n\n// Logical operators with short-circuit\nprint false and (1 / 0);          // Expect: false (no division by zero!)\nprint true or (1 / 0);            // Expect: true (no division by zero!)\n\n// Unary operators\nprint -(-5);                      // Expect: 5\nprint !true;                      // Expect: false\nprint !false;                     // Expect: true\nprint !!true;                     // Expect: true</code></pre></div>\n\n<p><strong>Expected Output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>42\nhello\ntrue\nnil\n14\n20\ntrue\ntrue\nfalse\ntrue\nfalse\nfalse\ntrue\n5\nfalse\ntrue\ntrue</code></pre></div>\n\n<p><strong>Verification Criteria:</strong></p>\n<ul>\n<li>All literals print their correct string representation</li>\n<li>Arithmetic follows standard precedence (multiplication before addition)</li>\n<li>Parentheses override precedence correctly</li>\n<li>Comparisons work for both numbers and strings</li>\n<li>Logical operators <code>and</code>/<code>or</code> short-circuit (no division by zero occurs)</li>\n<li>Unary operators correctly negate and invert values</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint: Variables and Environment</strong></p>\n<p>This test verifies variable declaration, assignment, scoping rules, and shadowing across nested blocks.</p>\n<p><strong>Test Program:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>// Global scope\nvar global = &quot;global&quot;;\nprint global;                     // Expect: global\n\n// Block creates new scope\n{\n  var local = &quot;local&quot;;\n  print local;                    // Expect: local\n  print global;                   // Expect: global (outer accessible)\n  \n  // Shadowing\n  var global = &quot;shadowed&quot;;\n  print global;                   // Expect: shadowed\n}\n\n// Outer scope unchanged\nprint global;                     // Expect: global\n\n// Assignment in correct scope\nvar x = 1;\n{\n  x = 2;                          // Modifies outer x\n}\nprint x;                          // Expect: 2\n\n// Undefined variable error (commented for test structure)\n// print not_defined;             // Should raise UndefinedVariableError</code></pre></div>\n\n<p><strong>Expected Output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>global\nlocal\nglobal\nshadowed\nglobal\n2</code></pre></div>\n\n<p><strong>Error Test (should raise exception):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># In test code, this should raise UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    interpreter.interpret(</span><span style=\"color:#9ECBFF\">\"print not_defined;\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Should have raised UndefinedVariableError\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> UndefinedVariableError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#9ECBFF\"> \"not_defined\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(e)</span></span></code></pre></div>\n\n<p><strong>Verification Criteria:</strong></p>\n<ul>\n<li>Variables can be declared and printed in their scope</li>\n<li>Inner blocks can access outer variables (lexical scoping)</li>\n<li>Inner declarations shadow outer variables without affecting them</li>\n<li>Assignment finds and modifies the nearest enclosing variable definition</li>\n<li>Accessing undefined variables raises a clear error with the variable name</li>\n</ul>\n<p><strong>Milestone 3 Checkpoint: Control Flow</strong></p>\n<p>This test verifies conditional execution, loops, and control flow jumps with proper scoping.</p>\n<p><strong>Test Program:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>// If/else statements\nvar result = &quot;&quot;;\nif (true) result = &quot;true&quot;; else result = &quot;false&quot;;\nprint result;                     // Expect: true\n\nif (false) result = &quot;wrong&quot;; else result = &quot;correct&quot;;\nprint result;                     // Expect: correct\n\n// While loop with break\nvar i = 0;\nwhile (i &lt; 5) {\n  if (i == 3) break;\n  i = i + 1;\n}\nprint i;                          // Expect: 3\n\n// For loop desugaring (should behave like while)\nvar sum = 0;\nfor (var j = 0; j &lt; 5; j = j + 1) {\n  if (j == 2) continue;          // Skip when j == 2\n  sum = sum + j;\n}\nprint sum;                        // Expect: 8 (0+1+3+4)\n\n// Loop variable scoping\nvar counter = 0;\nfor (var k = 0; k &lt; 3; k = k + 1) {\n  counter = counter + 1;\n}\n// k should not be accessible here (out of scope)\nprint counter;                    // Expect: 3\n// print k;                      // Should raise UndefinedVariableError</code></pre></div>\n\n<p><strong>Expected Output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>true\ncorrect\n3\n8\n3</code></pre></div>\n\n<p><strong>Verification Criteria:</strong></p>\n<ul>\n<li><code>if</code>/<code>else</code> executes correct branch based on condition truthiness</li>\n<li><code>while</code> loops execute while condition is truthy</li>\n<li><code>break</code> exits the innermost loop immediately</li>\n<li><code>for</code> loops execute initialization, condition check, and increment correctly</li>\n<li><code>continue</code> skips to next iteration without exiting loop</li>\n<li>Loop variables are scoped to the loop body (not accessible after)</li>\n<li>Control flow statements work correctly within nested blocks</li>\n</ul>\n<p><strong>Milestone 4 Checkpoint: Functions and Closures</strong></p>\n<p>This test verifies function definition, calls, parameters, return values, closures, and recursion.</p>\n<p><strong>Test Program:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>// Function definition and call\nfun sayHello(name) {\n  return &quot;Hello, &quot; + name + &quot;!&quot;;\n}\nprint sayHello(&quot;World&quot;);          // Expect: Hello, World!\n\n// Multiple parameters\nfun add(a, b) {\n  return a + b;\n}\nprint add(3, 4);                  // Expect: 7\n\n// Closure captures enclosing scope\nfun makeCounter() {\n  var i = 0;\n  fun count() {\n    i = i + 1;\n    return i;\n  }\n  return count;\n}\n\nvar counter = makeCounter();\nprint counter();                  // Expect: 1\nprint counter();                  // Expect: 2\nprint counter();                  // Expect: 3\n\n// Each closure gets its own environment\nvar counter2 = makeCounter();\nprint counter2();                 // Expect: 1 (independent of first counter)\n\n// Recursion\nfun factorial(n) {\n  if (n &lt;= 1) return 1;\n  return n * factorial(n - 1);\n}\nprint factorial(5);               // Expect: 120\n\n// Implicit return nil\nfun noReturn() {\n  var x = 1;\n  // No return statement\n}\nprint noReturn();                 // Expect: nil</code></pre></div>\n\n<p><strong>Expected Output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Hello, World!\n7\n1\n2\n3\n1\n120\nnil</code></pre></div>\n\n<p><strong>Error Tests (should raise exceptions):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Wrong argument count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    interpreter.interpret(</span><span style=\"color:#9ECBFF\">'fun f(a,b) { return a+b; } print f(1);'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Should have raised ArgumentError\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> ArgumentError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#9ECBFF\"> \"arguments\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(e).lower()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Return from top level (if supported, should error)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This depends on language design - may be allowed to return nil</span></span></code></pre></div>\n\n<p><strong>Verification Criteria:</strong></p>\n<ul>\n<li>Functions can be defined and called by name</li>\n<li>Parameters are bound to argument values in function scope</li>\n<li><code>return</code> statements immediately exit function with value</li>\n<li>Closures capture and maintain access to variables from defining scope</li>\n<li>Each closure instance maintains independent state</li>\n<li>Recursive functions work correctly (call themselves)</li>\n<li>Functions without explicit <code>return</code> statement implicitly return <code>nil</code></li>\n<li>Argument count mismatches raise clear errors</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Test Framework</strong></td>\n<td>Python <code>unittest</code></td>\n<td><code>pytest</code> with plugins</td>\n</tr>\n<tr>\n<td><strong>Test Organization</strong></td>\n<td>Separate test files per component</td>\n<td>Test directories mirroring source</td>\n</tr>\n<tr>\n<td><strong>Test Runner</strong></td>\n<td><code>python -m unittest discover</code></td>\n<td><code>pytest</code> with coverage reports</td>\n</tr>\n<tr>\n<td><strong>Mocking</strong></td>\n<td><code>unittest.mock</code> for isolation</td>\n<td>Custom test doubles</td>\n</tr>\n<tr>\n<td><strong>Assertion Style</strong></td>\n<td><code>self.assertEqual()</code></td>\n<td><code>assert</code> statements with <code>pytest</code></td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure</strong></p>\n<p>Organize tests to mirror the source code structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>interpreter_project/\n├── src/\n│   ├── interpreter.py           # Main Interpreter class\n│   ├── evaluator.py             # Evaluator class\n│   ├── environment.py           # Environment class\n│   ├── errors.py                # RuntimeError and subclasses\n│   └── ast_nodes.py             # AST node definitions\n└── tests/\n    ├── __init__.py\n    ├── test_evaluator.py        # Unit tests for Evaluator\n    ├── test_environment.py      # Unit tests for Environment\n    ├── test_interpreter.py      # Integration tests\n    ├── test_errors.py           # Error condition tests\n    └── milestone_checkpoints/   # Milestone verification tests\n        ├── test_milestone1.py\n        ├── test_milestone2.py\n        ├── test_milestone3.py\n        └── test_milestone4.py</code></pre></div>\n\n<p><strong>Infrastructure Starter Code</strong></p>\n<p>Here&#39;s a complete test helper module that sets up common test infrastructure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/test_helpers.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> unittest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Interpreter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">, UndefinedVariableError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InterpreterTestCase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">unittest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base test case with common setup and assertions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> setUp</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a fresh interpreter for each test.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Interpreter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertOutput</span><span style=\"color:#E1E4E8\">(self, source_code, expected_output_lines):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Run source code and compare printed output line by line.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            source_code: Program source as string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            expected_output_lines: List of expected output strings</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Capture printed output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        import</span><span style=\"color:#E1E4E8\"> io</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        old_stdout </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sys.stdout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sys.stdout </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> io.StringIO()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            success </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.interpreter.interpret(source_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            actual_output </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sys.stdout.getvalue().strip().split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.assertTrue(success, </span><span style=\"color:#9ECBFF\">\"Interpretation should succeed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.assertEqual(</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                len</span><span style=\"color:#E1E4E8\">(actual_output), </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                len</span><span style=\"color:#E1E4E8\">(expected_output_lines),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"Expected </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(expected_output_lines)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> output lines, got </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(actual_output)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> i, (actual, expected) </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">zip</span><span style=\"color:#E1E4E8\">(actual_output, expected_output_lines)):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.assertEqual(actual.strip(), expected.strip(), </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               f</span><span style=\"color:#9ECBFF\">\"Line </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">: expected '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">', got '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sys.stdout </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> old_stdout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertRaisesRuntimeError</span><span style=\"color:#E1E4E8\">(self, source_code, error_type, expected_message_substring</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Assert that interpreting source_code raises a specific runtime error.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            source_code: Program source as string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            error_type: Expected exception class</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            expected_message_substring: Optional substring that should be in error message</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.assertRaises(error_type) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> context:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.interpreter.interpret(source_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> expected_message_substring:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.assertIn(expected_message_substring, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(context.exception))</span></span></code></pre></div>\n\n<p><strong>Core Test Skeleton Code</strong></p>\n<p>Example unit test for the <code>Environment</code> class:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/test_environment.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> unittest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestEnvironment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">unittest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_define_and_get</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test basic variable definition and retrieval.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Define a variable 'x' with value 42</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Retrieve the value of 'x' and assert it equals 42</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Test that getting undefined variable raises UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_parent_chain_lookup</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test variable lookup walks up parent chain.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create parent environment with variable 'x' = 10</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create child environment with parent chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify child can retrieve parent's 'x'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Define 'x' in child (shadowing) and verify child gets shadowed value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Verify parent's 'x' remains unchanged</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_assignment_updates_nearest_scope</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test assignment modifies the nearest enclosing scope where defined.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create parent with 'x' = 1, child with no 'x'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: From child, assign 'x' = 2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify parent's 'x' now equals 2 (not child's)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Define 'x' in child, then assign to verify child's updates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p>Example integration test for milestone checkpoint:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/milestone_checkpoints/test_milestone2.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tests.test_helpers </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InterpreterTestCase</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestMilestone2Variables</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">InterpreterTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Integration tests for Milestone 2: Variables and Environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_variable_declaration_and_print</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test variable declaration and printing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        source </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            var x = 42;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            print x;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertOutput(source, [</span><span style=\"color:#9ECBFF\">\"42\"</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_scope_and_shadowing</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test nested scopes and variable shadowing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        source </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            var x = \"global\";</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                var x = \"local\";</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                print x;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            print x;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertOutput(source, [</span><span style=\"color:#9ECBFF\">\"local\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"global\"</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_undefined_variable_error</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test accessing undefined variable raises proper error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        source </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"print not_defined;\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.assertRaises(UndefinedVariableError) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> context:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.interpreter.interpret(source)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Verify error message contains variable name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertIn(</span><span style=\"color:#9ECBFF\">\"not_defined\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(context.exception))</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints for Python Testing</strong></p>\n<ul>\n<li>Use <code>unittest.TestCase</code> as base class for all test cases</li>\n<li>Set up fresh interpreter instances in <code>setUp()</code> method to ensure test isolation</li>\n<li>Use <code>self.assertRaises()</code> context manager for testing expected exceptions</li>\n<li>Capture standard output with <code>io.StringIO</code> when testing <code>print</code> statements</li>\n<li>Consider using <code>@unittest.skip(&quot;reason&quot;)</code> decorator for tests not yet implemented</li>\n<li>Run tests from command line with: <code>python -m unittest discover -s tests -v</code></li>\n</ul>\n<p><strong>Milestone Checkpoint Verification</strong></p>\n<p>For each milestone, after implementing the features, run the corresponding checkpoint test:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run all tests for a specific milestone</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> unittest</span><span style=\"color:#9ECBFF\"> tests.milestone_checkpoints.test_milestone1</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> unittest</span><span style=\"color:#9ECBFF\"> tests.milestone_checkpoints.test_milestone2</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> unittest</span><span style=\"color:#9ECBFF\"> tests.milestone_checkpoints.test_milestone3</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> unittest</span><span style=\"color:#9ECBFF\"> tests.milestone_checkpoints.test_milestone4</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run all tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> unittest</span><span style=\"color:#9ECBFF\"> discover</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> tests</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Expected Success Indicators:</strong></p>\n<ul>\n<li>All tests pass with &quot;OK&quot; status</li>\n<li>No unexpected errors or warnings</li>\n<li>Test output shows the correct number of tests run and passed</li>\n</ul>\n<p><strong>Common Failure Patterns and Diagnosis:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>All tests fail immediately</strong></td>\n<td>Import errors in test files</td>\n<td>Check Python path and imports</td>\n<td>Ensure <code>src/</code> is in <code>PYTHONPATH</code> or use relative imports</td>\n</tr>\n<tr>\n<td><strong>Variable tests pass but print wrong values</strong></td>\n<td><code>_stringify()</code> method incorrect</td>\n<td>Add debug prints in <code>_stringify()</code></td>\n<td>Ensure each value type converts to string properly</td>\n</tr>\n<tr>\n<td><strong>Scope tests fail intermittently</strong></td>\n<td>Environment parent chain broken</td>\n<td>Print environment chain during lookup</td>\n<td>Verify <code>parent</code> references are correctly maintained</td>\n</tr>\n<tr>\n<td><strong>Control flow tests hang</strong></td>\n<td>Infinite loop in test execution</td>\n<td>Add loop iteration counter with guard</td>\n<td>Ensure loop conditions eventually become false</td>\n</tr>\n<tr>\n<td><strong>Error tests don&#39;t raise exceptions</strong></td>\n<td>Exceptions caught somewhere in call chain</td>\n<td>Add try-catch in interpreter to see if error is swallowed</td>\n<td>Ensure errors propagate to test level</td>\n</tr>\n<tr>\n<td><strong>Closure tests show wrong values</strong></td>\n<td>Closure environment captured incorrectly</td>\n<td>Print closure environment at definition vs call</td>\n<td>Store defining environment, not current one</td>\n</tr>\n</tbody></table>\n<p><strong>Debugging Tips Table</strong></p>\n<table>\n<thead>\n<tr>\n<th>Debugging Technique</th>\n<th>How to Apply</th>\n<th>When to Use</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Strategic Print Logging</strong></td>\n<td>Add <code>print(f&quot;DEBUG: {variable}&quot;)</code> at key points</td>\n<td>When you need to see execution flow or variable values</td>\n</tr>\n<tr>\n<td><strong>AST Visualization</strong></td>\n<td>Print AST structure before evaluation</td>\n<td>When unsure how the parser is structuring the code</td>\n</tr>\n<tr>\n<td><strong>Environment Inspection</strong></td>\n<td>Add method to print entire environment chain</td>\n<td>When debugging scope or variable lookup issues</td>\n</tr>\n<tr>\n<td><strong>Step-by-Step Debugger</strong></td>\n<td>Use IDE debugger or <code>pdb.set_trace()</code></td>\n<td>For complex control flow or hard-to-find bugs</td>\n</tr>\n<tr>\n<td><strong>Minimal Test Case</strong></td>\n<td>Reduce failing test to smallest reproducing case</td>\n<td>When a large test fails and you need to isolate cause</td>\n</tr>\n<tr>\n<td><strong>Type Annotation Checking</strong></td>\n<td>Use <code>mypy</code> or IDE type hints</td>\n<td>When dealing with complex return types or value propagation</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Testing Principle:</strong> Write tests <strong>alongside</strong> implementation, not after. For each feature implemented, immediately write a test that verifies it works. This <strong>test-driven development</strong> approach ensures the interpreter remains correct at each step and makes debugging easier by catching errors close to their introduction point.</p>\n</blockquote>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 2, 3, 4</p>\n</blockquote>\n<p>Even the most carefully designed interpreters contain bugs during implementation. This section provides a systematic approach to diagnosing and fixing common issues that arise when building a tree-walking interpreter. Unlike compiled systems where bugs often manifest as crashes or incorrect outputs, interpreter bugs frequently involve subtle misunderstandings of evaluation order, environment chain traversal, or control flow semantics. This guide equips you with concrete diagnostic techniques and a symptom-based lookup table to efficiently troubleshoot your implementation.</p>\n<p>The core challenge in debugging a tree-walking interpreter is that you&#39;re building the very tool that would normally help you debug—there&#39;s no built-in debugger or elaborate logging system. Instead, you must instrument the interpreter itself to reveal its internal state. The key insight is to treat the interpreter as a <strong>black box that you can make transparent</strong> by adding observation points at critical junctions: before and after evaluating each node, during environment lookups, and when handling control flow jumps.</p>\n<h3 id=\"symptom-cause-fix-table\">Symptom → Cause → Fix Table</h3>\n<p>The following table catalogs the most common symptoms, their root causes, and systematic approaches to diagnosis and correction. Each entry follows a four-column structure: the observable symptom, the most likely underlying cause, a step-by-step diagnostic procedure to confirm the hypothesis, and the specific fix to apply.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Variable always returns <code>nil</code> or <code>undefined</code></strong></td>\n<td>The <code>Environment.get()</code> method is not correctly walking the parent chain, or the variable was never defined in the current or any enclosing scope.</td>\n<td>1. Insert print statements in <code>Environment.get()</code> showing the current environment&#39;s store and whether it has a parent.<br>2. Check that <code>Environment.define()</code> was called for this variable name during declaration evaluation.<br>3. Verify the environment chain structure: ensure inner scopes have their <code>parent</code> field set to the enclosing environment.</td>\n<td>In <code>Environment.get()</code>, ensure the while-loop correctly traverses from <code>self</code> to <code>self.parent</code> until finding the name or reaching <code>None</code>. Return <code>UndefinedVariableError</code> only after the entire chain is exhausted.</td>\n</tr>\n<tr>\n<td><strong>Assignment modifies wrong scope or creates new variable</strong></td>\n<td><code>Environment.assign()</code> is incorrectly creating a new binding instead of updating an existing one, or it&#39;s only checking the current environment without walking the chain.</td>\n<td>1. Log both <code>assign()</code> and <code>define()</code> calls with the environment&#39;s identifier (e.g., &quot;global&quot;, &quot;function local&quot;).<br>2. Check if <code>assign()</code> returns successfully without finding the variable—it should raise <code>UndefinedVariableError</code>.<br>3. Verify that <code>_evaluate_assign_expr()</code> calls <code>env.assign()</code> not <code>env.define()</code>.</td>\n<td>Implement <code>Environment.assign()</code> to recursively walk the parent chain exactly like <code>get()</code>. Only update if found; if the loop exits with <code>current is None</code>, raise <code>UndefinedVariableError</code>.</td>\n</tr>\n<tr>\n<td><strong>Binary operators work for numbers but not strings</strong></td>\n<td>The <code>_evaluate_binary_expr()</code> method has type-checking logic that only handles numeric operands, or the operator dispatch doesn&#39;t include string concatenation for <code>+</code>.</td>\n<td>1. Check the operator token type in your evaluation logic.<br>2. Print the types of left and right operands before applying the operator.<br>3. Verify that string concatenation is explicitly handled for <code>TokenType.PLUS</code> (or equivalent).</td>\n<td>Extend type-checking to allow string operands for <code>+</code> and possibly comparison operators. Implement explicit concatenation: <code>if operator == PLUS and isinstance(left, str) and isinstance(right, str): return left + right</code>.</td>\n</tr>\n<tr>\n<td><strong>If/else condition always executes the true branch</strong></td>\n<td>The <code>_is_truthy()</code> helper function incorrectly treats non-boolean values (like 0, &quot;&quot;, <code>nil</code>) as truthy, or the condition evaluation returns the AST node instead of its runtime value.</td>\n<td>1. Print the raw value passed to <code>_is_truthy()</code> and its output.<br>2. Verify that <code>_evaluate_if_stmt()</code> calls <code>_is_truthy()</code> on the evaluated condition result, not the condition node itself.<br>3. Test <code>_is_truthy()</code> with falsey values: <code>0</code>, <code>&quot;&quot;</code>, <code>false</code>, <code>nil</code>.</td>\n<td>Implement <code>_is_truthy()</code> following language semantics: <code>nil</code> and <code>false</code> are falsey; numbers are truthy except 0; strings are truthy except empty string. Ensure condition is fully evaluated via <code>self.evaluate(node.condition, env)</code>.</td>\n</tr>\n<tr>\n<td><strong>While loop runs infinitely</strong></td>\n<td>The loop condition is not being re-evaluated after each iteration, or the loop body fails to modify variables referenced in the condition.</td>\n<td>1. Add logging inside the while loop evaluation showing the condition value on each iteration.<br>2. Check that <code>_evaluate_while_stmt()</code> re-evaluates the condition node (not reusing the first result) before each iteration.<br>3. Trace variable modifications inside the loop body to ensure they affect the condition.</td>\n<td>In <code>_evaluate_while_stmt()</code>, ensure the condition is evaluated inside the while loop: <code>while self._is_truthy(self.evaluate(node.condition, env)): ...</code>.</td>\n</tr>\n<tr>\n<td><strong>Break or continue causes interpreter crash</strong></td>\n<td>The control flow signals (<code>BreakSignal</code>, <code>ContinueSignal</code>) are not being caught at the appropriate level (loop evaluators), or they&#39;re being propagated as regular values.</td>\n<td>1. Verify that <code>_evaluate_break_stmt()</code> and <code>_evaluate_continue_stmt()</code> raise the corresponding signal instances, not return them.<br>2. Check that <code>_evaluate_while_stmt()</code> and <code>_evaluate_for_stmt()</code> wrap the body evaluation in a try-catch that catches these signals.<br>3. Ensure signals aren&#39;t caught by generic exception handlers that treat them as errors.</td>\n<td>Wrap the loop body evaluation in a try-except block. Catch <code>BreakSignal</code> to exit the loop entirely; catch <code>ContinueSignal</code> to skip to the next iteration. Re-raise signals not intended for the current loop level.</td>\n</tr>\n<tr>\n<td><strong>Function call returns <code>nil</code> regardless of return statement</strong></td>\n<td>The <code>ReturnSignal</code> is not being properly caught and unpacked at the function call site, or the function body evaluation doesn&#39;t propagate the return value.</td>\n<td>1. Add logging in <code>_evaluate_call_expr()</code> showing the value returned from <code>function.call(arguments)</code>.<br>2. Check that <code>_evaluate_return_stmt()</code> raises a <code>ReturnSignal</code> with the value.<br>3. Verify that <code>FunctionValue.call()</code> catches <code>ReturnSignal</code> and returns its value, not the signal object.</td>\n<td>In <code>FunctionValue.call()</code>, wrap the body evaluation in a try-except that catches <code>ReturnSignal</code>. Extract the signal&#39;s <code>value</code> attribute and return it. Ensure uncaught exceptions (like <code>BreakSignal</code>) are not mistakenly caught.</td>\n</tr>\n<tr>\n<td><strong>Closure accesses wrong variable value (sees global instead of outer)</strong></td>\n<td>The <code>closure</code> field of <code>FunctionValue</code> is set incorrectly—likely to the global environment or the environment at call time instead of definition time.</td>\n<td>1. Print the closure environment&#39;s store when the function is defined and when it&#39;s called.<br>2. Verify that <code>_evaluate_function_decl()</code> captures the <em>current</em> environment (where the function is defined) as the closure.<br>3. Check that <code>FunctionValue.call()</code> creates the new environment with <code>self.closure</code> as parent, not the caller&#39;s environment.</td>\n<td>Store <code>env</code> (the environment active during function definition) in the <code>FunctionValue.closure</code> field. In <code>call()</code>, create the new environment with parent=<code>self.closure</code>.</td>\n</tr>\n<tr>\n<td>**Logical AND (<code>&amp;&amp;</code>) or OR (`</td>\n<td></td>\n<td>`) evaluates both operands always**</td>\n<td>Short-circuit evaluation is not implemented; both left and right operands are evaluated unconditionally before applying the logical operator.</td>\n</tr>\n<tr>\n<td><strong>Division by zero crashes with Python/Java exception instead of <code>DivisionByZeroError</code></strong></td>\n<td>The <code>_evaluate_binary_expr()</code> does not check for division by zero before performing the operation, letting the host language raise its own exception.</td>\n<td>1. Check the operator type for <code>TokenType.SLASH</code> and <code>TokenType.PERCENT</code>.<br>2. Verify that the right operand is checked against zero (using <code>_is_zero()</code> helper) before division.<br>3. Ensure the check uses interpreter&#39;s numeric representation, not host-language truthiness.</td>\n<td>Before performing division or modulo, call <code>self._is_zero(right)</code>. If true, raise a <code>DivisionByZeroError</code> with the operator token. Ensure <code>_is_zero()</code> handles the interpreter&#39;s number type (float/int).</td>\n</tr>\n<tr>\n<td><strong>Variable shadowing doesn&#39;t work—inner scope sees outer value</strong></td>\n<td>The environment chain lookup is incorrectly stopping at the first occurrence of the name, even if it&#39;s in a parent environment, when the name is redefined in the current environment.</td>\n<td>1. Log the store of each environment during a lookup.<br>2. Verify that <code>Environment.define()</code> adds the name to the current environment&#39;s store even if it exists in a parent.<br>3. Check that <code>Environment.get()</code> looks in the current store first, then recursively checks parent—this automatically implements shadowing.</td>\n<td>Ensure <code>Environment.get()</code> uses <code>while current:</code> and checks <code>if name in current.store: return current.store[name]</code>. This gives precedence to the innermost definition, shadowing outer ones.</td>\n</tr>\n<tr>\n<td><strong>Block statement doesn&#39;t create new scope</strong></td>\n<td>The <code>_evaluate_block_stmt()</code> evaluates statements in the same environment passed in, instead of creating a new child environment.</td>\n<td>1. Check if variable defined inside block is accessible outside it (should not be in lexical scoping).<br>2. Print environment identifiers before and after block execution.<br>3. Verify that <code>_evaluate_block_stmt()</code> creates a new <code>Environment</code> with the given env as parent.</td>\n<td>In <code>_evaluate_block_stmt()</code>, create a new environment with parent=<code>env</code>. Evaluate all block statements within this new environment. The outer environment remains unchanged.</td>\n</tr>\n<tr>\n<td><strong>For-loop variables leak into outer scope</strong></td>\n<td>The for-loop desugaring incorrectly uses the same environment for initializer, condition, increment, and body, rather than creating a enclosing block scope.</td>\n<td>1. Check if the loop variable (from the initializer) is accessible after the loop ends.<br>2. Examine your desugaring logic: does it wrap the while-loop in a new environment?<br>3. Verify that the initializer (often a <code>var</code> statement) is evaluated in the appropriate environment.</td>\n<td>When desugaring a for-loop, create a new environment for the entire loop. Place the initializer, condition, increment, and body inside this environment. This contains the loop variable.</td>\n</tr>\n<tr>\n<td><strong>Recursive function causes infinite recursion or stack overflow</strong></td>\n<td>The function&#39;s name is not bound in its own local environment, so recursive calls cannot find the function within its body. The function value exists only in the outer environment.</td>\n<td>1. Check if the function name is defined in the environment where the function body executes.<br>2. Print the environment store inside <code>FunctionValue.call()</code>—does it contain the function&#39;s name?<br>3. Verify that <code>_evaluate_function_decl()</code> both creates the <code>FunctionValue</code> <em>and</em> defines it in the current environment.</td>\n<td>In <code>_evaluate_function_decl()</code>, create the <code>FunctionValue</code> with the current environment as closure, then immediately call <code>env.define(node.name, function_value)</code>. This ensures the function name is bound in the scope where it&#39;s defined, enabling recursion.</td>\n</tr>\n<tr>\n<td><strong>Equality operator (<code>==</code>) returns false for identical values</strong></td>\n<td>The equality check is comparing object identity (like Python&#39;s <code>is</code>) instead of value equality, or it&#39;s not handling all runtime value types (numbers, strings, booleans, <code>nil</code>).</td>\n<td>1. Print the types and values of left and right operands.<br>2. Test equality with <code>nil == nil</code> (should be true).<br>3. Verify that the equality operator uses deep value comparison, not reference comparison.</td>\n<td>Implement type-specific equality: compare numbers numerically, strings character-wise, booleans directly. Treat <code>nil</code> as equal only to <code>nil</code>. Consider implementing a helper <code>_is_equal(a, b)</code> that handles all types.</td>\n</tr>\n<tr>\n<td><strong>Unary minus (<code>-</code>) applied to boolean or string crashes</strong></td>\n<td>The <code>_evaluate_unary_expr()</code> does not validate that the operand is a number for the negation operator.</td>\n<td>1. Check the operator type and operand type.<br>2. Verify that <code>_evaluate_unary_expr()</code> includes type checking similar to binary operators.<br>3. Test with <code>-&quot;string&quot;</code> or <code>-true</code>.</td>\n<td>Before applying unary minus, verify the operand is a number (using <code>isinstance(operand, (int, float))</code> or similar). If not, raise a <code>TypeError</code>.</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-techniques-and-tools\">Debugging Techniques and Tools</h3>\n<p>When systematic deduction from the symptom table isn&#39;t sufficient, you need to actively instrument your interpreter to observe its internal state. These techniques transform the interpreter from an opaque box into a transparent observatory of execution dynamics.</p>\n<h4 id=\"strategic-print-logging\">Strategic Print Logging</h4>\n<p>The most direct and effective debugging technique is to insert print statements at key points in the evaluation pipeline. This creates a trace of execution that reveals the flow through the AST, the values being computed, and the state of the environment chain.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> Think of print logging as installing security cameras throughout a factory assembly line. Each camera (print statement) shows what&#39;s happening at a specific workstation (component), allowing you to see where the product (program execution) goes off track.</p>\n</blockquote>\n<p>Create a consistent logging format that includes:</p>\n<ol>\n<li><strong>Node type and location</strong> (line number from token if available)</li>\n<li><strong>Evaluation phase</strong> (entering/exiting the node)</li>\n<li><strong>Current environment identifier</strong> (e.g., &quot;global&quot;, &quot;function:foo&quot;, &quot;block@line5&quot;)</li>\n<li><strong>Relevant values</strong> (operands, results, variable names)</li>\n</ol>\n<p>Example logging approach:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># In your Evaluator.evaluate() method</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"[EVAL] Entering </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.</span><span style=\"color:#79B8FF\">__class__</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__name__}</span><span style=\"color:#9ECBFF\"> at line </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.token.line </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'token'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> '?'</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"      Environment: </span><span style=\"color:#79B8FF\">{id</span><span style=\"color:#E1E4E8\">(env)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> parent: </span><span style=\"color:#79B8FF\">{id</span><span style=\"color:#E1E4E8\">(env.parent) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> env.parent </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._dispatch_evaluate(node, env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"[EVAL] Exiting </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.</span><span style=\"color:#79B8FF\">__class__</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__name__}</span><span style=\"color:#9ECBFF\"> -> </span><span style=\"color:#79B8FF\">{repr</span><span style=\"color:#E1E4E8\">(result)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span></code></pre></div>\n\n<p>For environment operations, add logging to <code>define</code>, <code>get</code>, and <code>assign</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(self, name):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"[ENV] Lookup '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' in env </span><span style=\"color:#79B8FF\">{id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> current:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> current.store:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"[ENV] Found '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' = </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">current.store[name]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> in env </span><span style=\"color:#79B8FF\">{id</span><span style=\"color:#E1E4E8\">(current)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> current.store[name]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"[ENV] Not in env </span><span style=\"color:#79B8FF\">{id</span><span style=\"color:#E1E4E8\">(current)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, moving to parent </span><span style=\"color:#79B8FF\">{id</span><span style=\"color:#E1E4E8\">(current.parent) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> current.parent </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current.parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... error handling</span></span></code></pre></div>\n\n<p>This trace will show you exactly how variable lookups traverse the environment chain, where values are defined, and when shadowing occurs.</p>\n<h4 id=\"ast-and-environment-visualization\">AST and Environment Visualization</h4>\n<p>Sometimes you need to see the structure of the program and the runtime state simultaneously. Create simple visualization utilities that dump the AST as an indented tree and display the environment chain as nested dictionaries.</p>\n<p><strong>AST Visualizer:</strong> Write a recursive function that prints each node with increasing indentation. This helps verify that the parser produces the expected structure, especially for complex expressions and nested statements.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Program\n  Block\n    VarStmt (x)\n      Literal: 5\n    WhileStmt\n      Binary (&lt;)\n        Variable: x\n        Literal: 10\n      Block\n        ExpressionStmt\n          Assign (=)\n            Variable: x\n            Binary (+)\n              Variable: x\n              Literal: 1</code></pre></div>\n\n<p><strong>Environment Chain Dumper:</strong> Create a function that walks from the current environment up to the global environment, printing each level&#39;s bindings:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Environment @0x7f8a (global)\n  store: {'PI': 3.14159, 'print': &lt;Function&gt;}\nEnvironment @0x7f9b (parent=0x7f8a) [function:fib]\n  store: {'n': 5}\nEnvironment @0x7fac (parent=0x7f9b) [block]\n  store: {'a': 1, 'b': 1}</code></pre></div>\n\n<p>Seeing both the static structure (AST) and dynamic state (environment chain) side-by-side often reveals mismatches between what you think should happen and what actually happens.</p>\n<h4 id=\"interactive-debugger-via-repl-hook\">Interactive Debugger via REPL Hook</h4>\n<p>For the most powerful debugging, extend your interpreter&#39;s REPL (Read-Eval-Print Loop) to include inspection commands. Even if your interpreter doesn&#39;t have a full REPL, you can add a debug mode that pauses execution at breakpoints.</p>\n<p>Implement a simple debug command interface:</p>\n<ul>\n<li><code>env</code> - show current environment chain</li>\n<li><code>step</code> - evaluate next AST node</li>\n<li><code>continue</code> - run to completion</li>\n<li><code>print &lt;expr&gt;</code> - evaluate expression in current environment</li>\n</ul>\n<p>This approach requires modifying the evaluator to accept callbacks or check for debug flags, but it pays dividends when debugging complex control flow or closure issues. The mental model here is that of a <strong>surgical microscope</strong>—you can pause execution at any moment, examine the precise state, and then proceed incrementally.</p>\n<h4 id=\"using-your-language39s-debugger\">Using Your Language&#39;s Debugger</h4>\n<p>Don&#39;t forget that you&#39;re writing the interpreter in a host language (Python, JavaScript, etc.) that likely has its own debugger. You can use pdb (Python), debugger statements (JavaScript), or IDE debuggers to step through your interpreter&#39;s code.</p>\n<p><strong>Key breakpoints to set:</strong></p>\n<ol>\n<li>At the entry to <code>Evaluator.evaluate()</code> to catch every node evaluation</li>\n<li>Inside <code>Environment.get()</code> when a specific variable name is looked up</li>\n<li>Inside <code>FunctionValue.call()</code> to observe function invocation</li>\n<li>Around the try-catch blocks that handle control flow signals</li>\n</ol>\n<p>When using a host-language debugger, pay attention to the call stack—it will mirror the interpreter&#39;s own call stack as it recursively evaluates nodes. This can help identify missing base cases or infinite recursion.</p>\n<h4 id=\"differential-testing-against-known-implementations\">Differential Testing Against Known Implementations</h4>\n<p>When a bug is particularly elusive, create a test suite of small programs and compare your interpreter&#39;s output against a known correct implementation (like JavaScript for a JavaScript-like syntax, or Python for a Python-like syntax). This can help isolate semantic differences in edge cases.</p>\n<ol>\n<li>Write a minimal program that exhibits the bug</li>\n<li>Run it through a reference interpreter (if available)</li>\n<li>Compare outputs step-by-step</li>\n<li>Isolate the first point of divergence—this is where your bug lies</li>\n</ol>\n<p>This technique is especially useful for verifying subtle semantics of closure capture, variable hoisting (if implemented), and truthiness rules.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The following implementation guidance provides concrete code for debugging utilities and integration points to help you instrument your interpreter effectively.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging</td>\n<td>Print statements with manual formatting</td>\n<td>Python&#39;s <code>logging</code> module with configurable levels</td>\n</tr>\n<tr>\n<td>AST Visualization</td>\n<td>Recursive print function with indentation</td>\n<td>Graphviz output for graphical tree representation</td>\n</tr>\n<tr>\n<td>Environment Inspection</td>\n<td>Manual store dumping</td>\n<td>Interactive debugger with readline support</td>\n</tr>\n<tr>\n<td>Tracing</td>\n<td>Conditional <code>DEBUG</code> flag in evaluator</td>\n<td>Decorator-based tracing that can be enabled/disabled per module</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Add debugging utilities in a separate module to keep your core interpreter clean:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>interpreter/\n  ast/                    # AST node definitions\n  parser/                 # Parser components\n  interpreter.py          # Main Interpreter class\n  evaluator.py            # Core Evaluator class\n  environment.py          # Environment class\n  debug/                  # Debugging utilities\n    __init__.py\n    tracer.py             # Evaluation tracer with indented logs\n    visualizer.py         # AST and environment visualizers\n    repl_debugger.py      # Interactive debugger extension\n  errors.py               # Runtime error definitions\n  main.py                 # CLI entry point</code></pre></div>\n\n<h4 id=\"c-complete-debug-tracer-ready-to-use\">C. Complete Debug Tracer (Ready to Use)</h4>\n<p>Here&#39;s a complete tracer class that can be wrapped around your evaluator to log all evaluation steps:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># debug/tracer.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DebugTracer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, enabled</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, output</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stdout):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enabled</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.output </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> output</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.indent_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_line </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> trace</span><span style=\"color:#E1E4E8\">(self, message, node</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Update line number if node has token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> node </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'token'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> node.token:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.current_line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node.token.line</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"  \"</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.indent_level</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        line_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"line </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.current_line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: \"</span><span style=\"color:#F97583\"> if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_line </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.output.write(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">indent</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">[TRACE] </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">line_info</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#79B8FF\">}\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enter_node</span><span style=\"color:#E1E4E8\">(self, node_type, description</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.trace(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"--> </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#79B8FF\"> {</span><span style=\"color:#E1E4E8\">description</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.indent_level </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> exit_node</span><span style=\"color:#E1E4E8\">(self, node_type, result</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.indent_level </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" -> </span><span style=\"color:#79B8FF\">{repr</span><span style=\"color:#E1E4E8\">(result)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> else</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.trace(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"&#x3C;-- </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node_type</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">result_str</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> env_operation</span><span style=\"color:#E1E4E8\">(self, op, name, value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, env_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" env=</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">env_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> env_id </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" = </span><span style=\"color:#79B8FF\">{repr</span><span style=\"color:#E1E4E8\">(value)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> else</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.trace(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"[ENV] </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">op</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">value_str</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">env_str</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"d-core-evaluator-integration-with-tracer\">D. Core Evaluator Integration with Tracer</h4>\n<p>Modify your Evaluator to optionally use the tracer:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># evaluator.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> debug.tracer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DebugTracer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, debug</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tracer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DebugTracer(</span><span style=\"color:#FFAB70\">enabled</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">debug)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Trace entering this node (use node.__class__.__name__)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call the appropriate evaluation method based on node type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Trace exiting this node with the result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_binary_expr</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Trace entering binary expression with operator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Evaluate left operand</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Evaluate right operand  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Apply operator with type checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Trace exiting with result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... other evaluation methods with similar tracing</span></span></code></pre></div>\n\n<h4 id=\"e-environment-class-with-debug-support\">E. Environment Class with Debug Support</h4>\n<p>Augment your Environment class to support debugging:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># environment.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, parent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"anonymous\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.store </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># For debugging identification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(self, name, value):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Add tracing: self.tracer.env_operation('DEFINE', name, value, self.id)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Store the name-value pair in self.store</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(self, name):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Trace the lookup attempt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Walk the parent chain, tracing each step</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If found, trace the successful find and return value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If not found, raise UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assign</span><span style=\"color:#E1E4E8\">(self, name, value):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Trace the assignment attempt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Walk the parent chain to find existing binding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If found, update and trace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If not found, raise UndefinedVariableError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"f-debugging-tips-for-specific-languages\">F. Debugging Tips for Specific Languages</h4>\n<p><strong>Python:</strong></p>\n<ul>\n<li>Use <code>f-string</code> formatting for concise debug output</li>\n<li>The <code>id()</code> function returns a unique identifier for objects—useful for distinguishing environment instances</li>\n<li><code>repr(value)</code> gives a programmer-friendly string representation</li>\n<li>Consider using <code>contextlib.redirect_stdout</code> to capture debug output in tests</li>\n</ul>\n<p><strong>JavaScript:</strong></p>\n<ul>\n<li><code>console.group()</code> and <code>console.groupEnd()</code> create indented debug groups</li>\n<li>Use <code>performance.now()</code> for timing specific operations</li>\n<li><code>JSON.stringify()</code> with a replacer function can help inspect circular structures</li>\n</ul>\n<p><strong>Java:</strong></p>\n<ul>\n<li>Use <code>System.identityHashCode()</code> for object identifiers</li>\n<li>Override <code>toString()</code> in AST nodes and Environment for better debug output</li>\n<li>Consider using a logging framework like SLF4J with different log levels</li>\n</ul>\n<h4 id=\"g-milestone-debugging-checkpoints\">G. Milestone Debugging Checkpoints</h4>\n<p>After implementing each milestone, run these diagnostic programs to verify core functionality:</p>\n<p><strong>Milestone 1 (Expressions):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">;        </span><span style=\"color:#6A737D\">// Should print 7, not 9</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">;      </span><span style=\"color:#6A737D\">// Should print 9</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#F97583\">!</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;   </span><span style=\"color:#6A737D\">// Should print true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;            </span><span style=\"color:#6A737D\">// Should raise DivisionByZeroError</span></span></code></pre></div>\n\n<p><strong>Milestone 2 (Variables):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  var</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  print x;  </span><span style=\"color:#6A737D\">// Should print 20</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print x;    </span><span style=\"color:#6A737D\">// Should print 10 (shadowing works)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print y;    </span><span style=\"color:#6A737D\">// Should raise UndefinedVariableError</span></span></code></pre></div>\n\n<p><strong>Milestone 3 (Control Flow):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  print i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should print 0 only (break works)</span></span></code></pre></div>\n\n<p><strong>Milestone 4 (Functions):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"global\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> outer</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  var</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"outer\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  function</span><span style=\"color:#B392F0\"> inner</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> x;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> inner;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> fn </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> outer</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">print </span><span style=\"color:#B392F0\">fn</span><span style=\"color:#E1E4E8\">();  </span><span style=\"color:#6A737D\">// Should print \"outer\" (closure works)</span></span></code></pre></div>\n\n<p>If any test produces unexpected output, use the debugging techniques above to trace through the execution step by step.</p>\n<h4 id=\"h-common-debug-workflow\">H. Common Debug Workflow</h4>\n<p>When confronted with a bug, follow this systematic workflow:</p>\n<ol>\n<li><strong>Minimize</strong>: Create the smallest possible program that reproduces the bug</li>\n<li><strong>Observe</strong>: Run with debug tracing enabled, capturing all output</li>\n<li><strong>Hypothesize</strong>: Based on the trace, form a hypothesis about the root cause</li>\n<li><strong>Test</strong>: Add additional logging to confirm or refute your hypothesis</li>\n<li><strong>Fix</strong>: Implement the correction</li>\n<li><strong>Verify</strong>: Run the minimized test and all existing tests to ensure no regressions</li>\n</ol>\n<p>Remember that most interpreter bugs stem from a few recurring themes: incorrect environment chain traversal, mishandled control flow signals, missing type checks, or improper closure capture. By methodically applying these debugging techniques, you&#39;ll develop both the skills to fix bugs and the intuition to avoid them in the first place.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section explores potential enhancements beyond the four core milestones, providing a roadmap for extending the interpreter&#39;s capabilities and evolving its architecture.</p>\n</blockquote>\n<p>While the current interpreter implements the essential features of a dynamic, lexically-scoped language with first-class functions, its design intentionally leaves room for growth. This section outlines natural extensions that build upon the existing architecture, showing how each enhancement fits into—or requires modification of—the current component design. These extensions provide excellent pathways for deepening understanding of language implementation and interpreter architecture.</p>\n<h3 id=\"language-feature-extensions\">Language Feature Extensions</h3>\n<p>The interpreter&#39;s core evaluation engine and environment model provide a solid foundation for adding more sophisticated language features. These extensions would make the language more practical and expressive while demonstrating important programming language concepts.</p>\n<h4 id=\"arrays-and-hashes-composite-data-types\">Arrays and Hashes (Composite Data Types)</h4>\n<p><strong>Mental Model: The Filing Cabinet and Key-Ring Box</strong>\nThink of arrays as numbered filing cabinets where each drawer (index) holds a value, accessible by its numerical position. Hashes (or dictionaries) are like a key-ring box where each unique key unlocks a specific compartment holding a value. Both are <strong>compound values</strong>—single runtime objects that contain multiple other values, requiring the interpreter to manage collections as first-class entities.</p>\n<p><strong>Design Impact and Integration Strategy</strong>\nAdding arrays and hashes requires extending several interconnected components:</p>\n<ol>\n<li><p><strong>Runtime Value System</strong>: New <code>ArrayValue</code> and <code>HashValue</code> classes would join the existing runtime value hierarchy. These must be immutable (by the AST) but mutable at runtime through operations.</p>\n</li>\n<li><p><strong>Literal Syntax and AST Nodes</strong>: The parser would need to recognize <code>[1, 2, 3]</code> and <code>{&quot;key&quot;: &quot;value&quot;}</code> syntax, creating new <code>ArrayLiteral</code> and <code>HashLiteral</code> AST nodes containing their element expressions.</p>\n</li>\n<li><p><strong>Indexing Operations</strong>: Both get (<code>array[0]</code>) and set (<code>array[0] = 5</code>) operations require new expression node types and evaluation logic that integrates with the existing <code>Evaluator._evaluate_binary_expr</code> or a new specialized handler.</p>\n</li>\n<li><p><strong>Built-in Methods</strong>: Practical arrays and hashes need operations like <code>push</code>, <code>length</code>, <code>keys</code>, etc., which could be implemented as built-in functions or as methods on the value objects themselves.</p>\n</li>\n</ol>\n<p><strong>Data Structure Extensions Table</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Current Design</th>\n<th>Extended Design for Collections</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Runtime Values</td>\n<td><code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Nil</code>, <code>FunctionValue</code></td>\n<td>Add <code>ArrayValue</code> (stores <code>list</code>), <code>HashValue</code> (stores <code>dict</code>)</td>\n</tr>\n<tr>\n<td>AST Nodes</td>\n<td><code>Literal</code>, <code>Binary</code>, <code>Unary</code>, <code>Call</code>, etc.</td>\n<td>Add <code>ArrayLiteral</code>, <code>HashLiteral</code>, <code>SubscriptExpr</code>, <code>SubscriptAssign</code></td>\n</tr>\n<tr>\n<td>Environment Storage</td>\n<td>Any primitive value or <code>FunctionValue</code></td>\n<td>Can now store <code>ArrayValue</code> and <code>HashValue</code> references</td>\n</tr>\n<tr>\n<td>Equality Comparison</td>\n<td>Works for primitives</td>\n<td>Need reference vs. value semantics decision for collections</td>\n</tr>\n</tbody></table>\n<p><strong>&gt; Decision: Reference Semantics for Compound Types</strong></p>\n<blockquote>\n<ul>\n<li><strong>Context</strong>: When arrays and hashes are assigned to variables or passed as arguments, we must decide whether copies are made (value semantics) or references are shared (reference semantics).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Value Semantics</strong>: Each assignment creates a deep copy of the entire collection</li>\n<li><strong>Reference Semantics</strong>: Variables hold references to the same underlying collection object</li>\n<li><strong>Copy-on-Write Hybrid</strong>: References until modification, then copy</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: <strong>Reference semantics</strong> (option 2)</li>\n<li><strong>Rationale</strong>: Most dynamic languages (JavaScript, Python, Ruby) use reference semantics for collections for performance and consistency. Value semantics would require expensive deep copying on every assignment and function call. The mental model of &quot;variables hold references to objects&quot; is consistent with function objects already implemented.</li>\n<li><strong>Consequences</strong>: Variables can alias the same array, modifications through one variable affect all references. This requires careful implementation of equality operators (typically reference equality unless implementing deep equality).</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Suitable For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Value Semantics</td>\n<td>No aliasing surprises, simpler reasoning</td>\n<td>Performance cost on assignment/calls, memory overhead</td>\n<td>Languages emphasizing immutability</td>\n</tr>\n<tr>\n<td>Reference Semantics</td>\n<td>Fast assignment/passing, matches industry norms</td>\n<td>Aliasing can cause bugs, requires GC consideration</td>\n<td>Most imperative dynamic languages</td>\n</tr>\n<tr>\n<td>Copy-on-Write</td>\n<td>Best of both worlds when reading</td>\n<td>Complex implementation, still has copy cost on write</td>\n<td>Specialized use cases</td>\n</tr>\n</tbody></table>\n<p><strong>Common Implementation Pitfalls</strong></p>\n<ol>\n<li><p>⚠️ <strong>Pitfall: Forgetting to Clone Arrays in Literals</strong><br><strong>Description</strong>: Using the same list object for multiple array literals due to Python&#39;s mutable default arguments or object reuse.<br><strong>Why Wrong</strong>: Modifying one array would affect all arrays created with the same literal syntax.<br><strong>Fix</strong>: Always create fresh <code>list</code>/<code>dict</code> objects when evaluating array/hash literals.</p>\n</li>\n<li><p>⚠️ <strong>Pitfall: Index Type Checking at Runtime</strong><br><strong>Description</strong>: Allowing non-integer indices for arrays or non-hashable keys for dictionaries without error.<br><strong>Why Wrong</strong>: <code>array[&quot;string&quot;]</code> should raise a <code>TypeError</code>, not silently fail or behave unpredictably.<br><strong>Fix</strong>: In <code>Evaluator._evaluate_subscript_expr</code>, validate index types before access.</p>\n</li>\n</ol>\n<h4 id=\"classes-and-object-oriented-programming\">Classes and Object-Oriented Programming</h4>\n<p><strong>Mental Model: The Factory Blueprint and Instance Stamp</strong>\nA class is like a factory blueprint that defines (1) what attributes every object made from it contains, and (2) the operations (methods) those objects can perform. Each object instance is a stamped copy from that blueprint with its own set of attribute values. Methods are special functions that implicitly receive the instance (<code>this</code>/<code>self</code>) as their first argument.</p>\n<p><strong>Design Impact and Integration Strategy</strong>\nAdding classes represents the most significant language extension, touching nearly every component:</p>\n<ol>\n<li><p><strong>Runtime Value System</strong>: New <code>ClassValue</code> and <code>InstanceValue</code> types. <code>ClassValue</code> stores method definitions and inheritance chain; <code>InstanceValue</code> stores instance fields and class reference.</p>\n</li>\n<li><p><strong>Environment Model Extension</strong>: Methods need access to both instance fields (through <code>self</code>) and class-level static members. This may require a specialized environment chain linking instance → class → parent class → global.</p>\n</li>\n<li><p><strong>Method Invocation</strong>: The call mechanism must handle the implicit <code>self</code> binding. This could extend the existing <code>FunctionValue.call</code> or create a new <code>MethodValue</code> wrapper.</p>\n</li>\n<li><p><strong>Inheritance</strong>: Requires implementing property/method lookup along the prototype chain, analogous to environment chain lookup but for properties.</p>\n</li>\n</ol>\n<p><strong>ADR: Class Implementation Strategy</strong></p>\n<blockquote>\n<p><strong>Decision: Prototype-Based vs. Class-Based OOP</strong></p>\n<ul>\n<li><strong>Context</strong>: We must choose between class-based inheritance (Java, Python) and prototype-based delegation (JavaScript, Lua).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Class-Based (Classical)</strong>: Explicit class definitions with <code>class</code> keyword, constructor methods, and fixed inheritance hierarchies</li>\n<li><strong>Prototype-Based</strong>: Objects inherit directly from other objects via prototype chain, more dynamic but less structured</li>\n<li><strong>Hybrid</strong>: Class syntax that compiles to prototype chains (like JavaScript ES6)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: <strong>Class-based with explicit syntax</strong> (option 1)</li>\n<li><strong>Rationale</strong>: More intuitive for learners coming from Java, Python, or C++. The mental model of blueprints and instances is straightforward. The implementation aligns well with the existing <code>Environment</code> chain concept (inheritance chain is similar to parent environment lookup).</li>\n<li><strong>Consequences</strong>: Requires new syntax (<code>class</code>, <code>new</code>, <code>this</code>), constructor handling, and explicit inheritance resolution. Less dynamic than prototypes but more structured.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Class-Based</td>\n<td>Familiar syntax, clear mental model</td>\n<td>Less dynamic, more syntax to parse</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Prototype-Based</td>\n<td>Extremely flexible, minimal syntax</td>\n<td>Unfamiliar to many, &quot;magical&quot; behavior</td>\n<td>Medium-High</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>Modern feel, backward compatibility</td>\n<td>Complex transformation step</td>\n<td>High</td>\n</tr>\n</tbody></table>\n<p><strong>Example Class Evaluation Steps</strong></p>\n<ol>\n<li>When encountering a <code>ClassStatement</code>, the evaluator creates a <code>ClassValue</code> object storing:<ul>\n<li>Class name</li>\n<li>Methods dictionary (mapping method names to <code>FunctionValue</code> objects)</li>\n<li>Parent class reference (for inheritance)</li>\n</ul>\n</li>\n<li>The class is bound to its name in the current environment</li>\n<li>When evaluating <code>new ClassName(args)</code>:<ul>\n<li>Create an <code>InstanceValue</code> with a reference to its class</li>\n<li>Create a new environment for the instance (for <code>this</code> access)</li>\n<li>Call the constructor method with the instance as implicit <code>self</code></li>\n<li>Return the instance</li>\n</ul>\n</li>\n<li>Method calls <code>obj.method(arg)</code>:<ul>\n<li>Look up method in the instance&#39;s class (walking inheritance chain)</li>\n<li>Bind <code>self</code> to the instance (creating a bound method or adjusting call context)</li>\n<li>Call with remaining arguments</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"exception-handling\">Exception Handling</h4>\n<p><strong>Mental Model: The Emergency Exit Rope</strong>\nExceptions are like emergency exit ropes in a building—when something goes wrong deep inside nested rooms (function calls), you can pull the rope to immediately exit multiple levels until reaching a designated rescue station (catch block). The rope carries information about what went wrong (exception object).</p>\n<p><strong>Design Impact and Integration Strategy</strong>\nException handling requires non-local control flow that jumps out of multiple nested environments, similar to but more general than <code>return</code>:</p>\n<ol>\n<li><p><strong>Exception Value Type</strong>: New <code>ExceptionValue</code> runtime type to carry error messages, types, and stack traces.</p>\n</li>\n<li><p><strong>Control Flow Extension</strong>: Beyond <code>BreakSignal</code>, <code>ContinueSignal</code>, and <code>ReturnSignal</code>, we&#39;d need <code>ThrowSignal</code> carrying an exception value.</p>\n</li>\n<li><p><strong>Unwinding Mechanism</strong>: The evaluator must catch <code>ThrowSignal</code> at appropriate points (in <code>try</code> blocks) and unwind the evaluation stack until finding a matching <code>catch</code>.</p>\n</li>\n<li><p><strong>Stack Trace Collection</strong>: To provide useful error messages, the interpreter needs to track the call stack during evaluation.</p>\n</li>\n</ol>\n<p><strong>&gt; Decision: Exception Handling Implementation Strategy</strong></p>\n<blockquote>\n<ul>\n<li><strong>Context</strong>: We need to implement non-local exit from arbitrary depth with resumable execution at catch blocks.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Exception Signals</strong>: Extend the existing control flow signal system with <code>ThrowSignal</code> and try/catch handlers in the evaluator</li>\n<li><strong>Return Code Propagation</strong>: Each evaluation method returns a <code>(value, exception)</code> pair that callers must check</li>\n<li><strong>True Stack Unwinding</strong>: Maintain an explicit evaluation stack and unwind it when exceptions occur</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: <strong>Exception Signals</strong> (option 1)</li>\n<li><strong>Rationale</strong>: Consistent with the existing <code>ReturnSignal</code>, <code>BreakSignal</code>, and <code>ContinueSignal</code> pattern. The evaluator already has infrastructure to catch these signals at appropriate boundaries. Minimal disruption to existing evaluation methods.</li>\n<li><strong>Consequences</strong>: All statement evaluation methods must properly propagate uncaught <code>ThrowSignal</code>. Try/catch blocks become special statement nodes that catch these signals.</li>\n</ul>\n</blockquote>\n<p><strong>Exception Handling Algorithm Overview</strong></p>\n<ol>\n<li><code>throw expression</code> evaluates the expression to get an exception value, then raises <code>ThrowSignal(value)</code></li>\n<li><code>try { block } catch (identifier) { handler }</code> statement evaluation:<ul>\n<li>Wrap block evaluation in a try-catch that catches <code>ThrowSignal</code></li>\n<li>If signal caught, create new environment for catch block with identifier bound to exception value</li>\n<li>Evaluate handler in that environment</li>\n</ul>\n</li>\n<li>The evaluator&#39;s top level catches any uncaught <code>ThrowSignal</code> and reports it as a runtime error</li>\n</ol>\n<h4 id=\"standard-library-functions\">Standard Library Functions</h4>\n<p><strong>Mental Model: The Toolbox Included with the Workshop</strong>\nA standard library is like a toolbox that comes with a workshop—basic tools (functions) for common tasks that would be tedious to build from scratch every time. These are built-in functions that are always available in the global environment.</p>\n<p><strong>Design Impact and Integration Strategy</strong>\nAdding standard library functions is one of the easiest extensions:</p>\n<ol>\n<li><p><strong>Native Function Type</strong>: Create a <code>NativeFunctionValue</code> that wraps Python/JavaScript/Java functions, distinct from user-defined <code>FunctionValue</code>.</p>\n</li>\n<li><p><strong>Global Environment Initialization</strong>: Populate the initial global environment with useful functions like <code>print</code>, <code>clock</code>, <code>input</code>, <code>toString</code>, <code>length</code> (for strings/arrays), etc.</p>\n</li>\n<li><p><strong>Variadic Functions</strong>: Some built-ins (like <code>print</code>) accept any number of arguments, requiring flexible argument handling.</p>\n</li>\n<li><p><strong>Type Coercion Helpers</strong>: Functions for converting between types (string to number, etc.).</p>\n</li>\n</ol>\n<p><strong>Built-in Function Table Example</strong></p>\n<table>\n<thead>\n<tr>\n<th>Function Name</th>\n<th>Arguments</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>print</code></td>\n<td>Any number of values</td>\n<td><code>nil</code></td>\n<td>Converts each value to string and outputs</td>\n</tr>\n<tr>\n<td><code>clock</code></td>\n<td>None</td>\n<td>Number</td>\n<td>Returns current time in seconds</td>\n</tr>\n<tr>\n<td><code>length</code></td>\n<td>String or Array</td>\n<td>Number</td>\n<td>Returns character count or element count</td>\n</tr>\n<tr>\n<td><code>substring</code></td>\n<td>String, start, end</td>\n<td>String</td>\n<td>Extracts portion of string</td>\n</tr>\n<tr>\n<td><code>arrayPush</code></td>\n<td>Array, value</td>\n<td><code>nil</code></td>\n<td>Appends value to array</td>\n</tr>\n<tr>\n<td><code>toNumber</code></td>\n<td>String</td>\n<td>Number or <code>nil</code></td>\n<td>Converts string to number if possible</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Simplicity</strong>: Each built-in can be implemented as a regular function in the host language that&#39;s wrapped in a <code>NativeFunctionValue</code> and added to the global environment during interpreter initialization.</p>\n<h4 id=\"tail-call-optimization\">Tail-Call Optimization</h4>\n<p><strong>Mental Model: The Recycling Elevator</strong>\nNormally, each function call is like taking a new elevator car up a floor—you accumulate more cars (stack frames) as you nest calls. Tail-call optimization is like having a recycling elevator that reuses the same car when you immediately return to go up another floor, preventing the accumulation of cars (stack overflow) during deep recursion.</p>\n<p><strong>Design Impact and Integration Strategy</strong>\nTail-call optimization (TCO) allows recursive function calls in tail position to reuse the current stack frame:</p>\n<ol>\n<li><p><strong>Tail Position Identification</strong>: A call is in tail position if its value is immediately returned (e.g., <code>return f(x)</code> or <code>f(x)</code> at end of function).</p>\n</li>\n<li><p><strong>Evaluation Strategy Modification</strong>: Instead of recursively calling <code>Evaluator.evaluate</code> for the tail call, the evaluator would:</p>\n<ul>\n<li>Reuse the current environment (after updating parameters)</li>\n<li>Jump back to function body evaluation instead of nesting deeper</li>\n</ul>\n</li>\n<li><p><strong>Implementation Approaches</strong>:</p>\n<ul>\n<li><strong>Trampoline</strong>: Transform evaluation to iterative loop with explicit continuation passing</li>\n<li><strong>Direct Optimization</strong>: Special handling in <code>ReturnSignal</code> and function call evaluation</li>\n<li><strong>Source Transformation</strong>: Rewrite tail calls during parsing/compilation</li>\n</ul>\n</li>\n</ol>\n<p><strong>Challenges and Considerations</strong></p>\n<ul>\n<li>TCO changes stack trace behavior (fewer frames available for debugging)</li>\n<li>Requires careful analysis of tail positions</li>\n<li>Makes infinite recursion safe from stack overflow but still infinite loops</li>\n<li>Could be implemented as optional optimization flag</li>\n</ul>\n<h3 id=\"architectural-evolutions\">Architectural Evolutions</h3>\n<p>Beyond adding language features, the interpreter&#39;s architecture itself can evolve in significant ways. These transformations demonstrate how real-world language implementations grow in sophistication.</p>\n<h4 id=\"from-tree-walking-to-bytecode-compilation-and-virtual-machine\">From Tree-Walking to Bytecode Compilation and Virtual Machine</h4>\n<p><strong>Mental Model: From Interpreting Sheet Music to Playing a Recording</strong>\nA tree-walking interpreter is like a musician reading sheet music (AST) and playing each note as they see it. A bytecode compiler translates that sheet music into a piano roll (bytecode) that can be fed into a player piano (VM) for faster, more predictable execution. The piano roll is a denser, linear representation optimized for efficient execution.</p>\n<p><strong>Why Transform the Architecture?</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Tree-Walking Interpreter</th>\n<th>Bytecode VM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Performance</td>\n<td>Slow: repeated AST traversal, interpreter overhead</td>\n<td>Faster: linear bytecode, direct instruction dispatch</td>\n</tr>\n<tr>\n<td>Memory Use</td>\n<td>High: AST stays in memory, recursion overhead</td>\n<td>Lower: compact bytecode, explicit stack</td>\n</tr>\n<tr>\n<td>Optimization Opportunities</td>\n<td>Few: AST is high-level</td>\n<td>Many: peephole, constant folding, JIT potential</td>\n</tr>\n<tr>\n<td>Implementation Complexity</td>\n<td>Lower: direct mapping to language semantics</td>\n<td>Higher: compiler + VM dual components</td>\n</tr>\n<tr>\n<td>Educational Value</td>\n<td>Excellent for understanding semantics</td>\n<td>Excellent for understanding execution models</td>\n</tr>\n</tbody></table>\n<p><strong>Migration Strategy: Incremental Compilation</strong>\nThe current design can evolve incrementally toward a bytecode system:</p>\n<ol>\n<li><p><strong>Phase 1: AST to Bytecode Compiler</strong>  </p>\n<ul>\n<li>Add a <code>Compiler</code> component that walks the AST and emits bytecode instructions</li>\n<li>Keep the existing <code>Evaluator</code> but have it interpret bytecode instead of AST nodes</li>\n<li>Initially compile each function/block to bytecode on first execution (lazy compilation)</li>\n</ul>\n</li>\n<li><p><strong>Phase 2: Virtual Machine Core</strong>  </p>\n<ul>\n<li>Replace the <code>Evaluator</code> with a <code>VM</code> class with:<ul>\n<li>Instruction pointer (IP)</li>\n<li>Value stack (operand stack)</li>\n<li>Call stack (return addresses, frames)</li>\n</ul>\n</li>\n<li>Implement instruction dispatch loop (giant switch on opcode)</li>\n</ul>\n</li>\n<li><p><strong>Phase 3: Optimization Passes</strong>  </p>\n<ul>\n<li>Add constant folding during compilation</li>\n<li>Implement basic block analysis</li>\n<li>Add simple peephole optimizations</li>\n</ul>\n</li>\n</ol>\n<p><strong>Bytecode Instruction Set Example</strong></p>\n<table>\n<thead>\n<tr>\n<th>Instruction</th>\n<th>Operands</th>\n<th>Description</th>\n<th>Stack Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CONSTANT</code></td>\n<td>index</td>\n<td>Push constant from pool</td>\n<td><code>[] → [value]</code></td>\n</tr>\n<tr>\n<td><code>ADD</code></td>\n<td>-</td>\n<td>Pop two values, push sum</td>\n<td><code>[a, b] → [a+b]</code></td>\n</tr>\n<tr>\n<td><code>GET_LOCAL</code></td>\n<td>slot</td>\n<td>Push local variable value</td>\n<td><code>[] → [value]</code></td>\n</tr>\n<tr>\n<td><code>SET_LOCAL</code></td>\n<td>slot</td>\n<td>Pop value, store in local</td>\n<td><code>[value] → []</code></td>\n</tr>\n<tr>\n<td><code>CALL</code></td>\n<td>arg_count</td>\n<td>Call function with args</td>\n<td><code>[fn, arg1...argN] → [result]</code></td>\n</tr>\n<tr>\n<td><code>RETURN</code></td>\n<td>-</td>\n<td>Return from function</td>\n<td><code>[value] → []</code> (in caller)</td>\n</tr>\n</tbody></table>\n<p><strong>Data Flow Transformation</strong>\nCurrent: <code>Source → Parser → AST → Evaluator (recursive) → Result</code><br>Future: <code>Source → Parser → AST → Compiler → Bytecode → VM (iterative) → Result</code></p>\n<p><strong>&gt; Decision: Stack-Based vs. Register-Based VM</strong></p>\n<blockquote>\n<ul>\n<li><strong>Context</strong>: When designing the bytecode VM, we must choose between stack-based architecture (Java JVM, Python) and register-based architecture (Lua, Dalvik).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Stack-Based</strong>: Instructions implicitly operate on top of value stack</li>\n<li><strong>Register-Based</strong>: Instructions explicitly reference virtual registers</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: <strong>Stack-based architecture</strong> (option 1)</li>\n<li><strong>Rationale</strong>: Simpler to implement and generate code for. The operand stack concept naturally matches expression evaluation order. Most educational VMs (including from Crafting Interpreters) use stack-based design, making resources more applicable.</li>\n<li><strong>Consequences</strong>: More instructions may be needed (due to stack manipulation), but each instruction is simpler. Easier to reason about and debug.</li>\n</ul>\n</blockquote>\n<h4 id=\"adding-a-repl-and-debugger\">Adding a REPL and Debugger</h4>\n<p><strong>Mental Model: The Conversation Partner and X-Ray Glasses</strong>\nA REPL (Read-Eval-Print Loop) transforms the interpreter from a batch processor into a conversational partner—you give it a piece of code, it responds immediately with the result. A debugger adds X-ray glasses that let you see inside the running program: variable values, call stack, and execution flow.</p>\n<p><strong>REPL Design and Implementation</strong>\nA REPL is surprisingly simple to add to the existing architecture:</p>\n<ol>\n<li><p><strong>Interactive Loop</strong>: Wrap the interpreter in a loop that:</p>\n<ul>\n<li>Prints a prompt (<code>&gt; </code>)</li>\n<li>Reads a line of input</li>\n<li>Parses and evaluates it</li>\n<li>Prints the result (using <code>Interpreter._stringify</code>)</li>\n<li>Repeats</li>\n</ul>\n</li>\n<li><p><strong>Special REPL Behavior</strong>:</p>\n<ul>\n<li>Allow multi-line input (e.g., function definitions spanning lines)</li>\n<li>Handle incomplete expressions gracefully</li>\n<li>Maintain environment state across inputs (persistent global environment)</li>\n<li>Support special commands (like <code>.exit</code>, <code>.reset</code>)</li>\n</ul>\n</li>\n<li><p><strong>Implementation Integration</strong>:</p>\n<ul>\n<li>The REPL shares the same <code>Interpreter</code>, <code>Evaluator</code>, and global <code>Environment</code></li>\n<li>Each input is parsed and evaluated in the same context</li>\n<li>Variable definitions persist across inputs</li>\n</ul>\n</li>\n</ol>\n<p><strong>Debugger Architecture</strong>\nA debugger is more complex but builds naturally on existing components:</p>\n<ol>\n<li><p><strong>Breakpoint System</strong>:</p>\n<ul>\n<li>Store breakpoints (source line numbers or function names)</li>\n<li>Check before each statement evaluation if at breakpoint</li>\n<li>Pause execution and enter debugger loop</li>\n</ul>\n</li>\n<li><p><strong>Inspection Interface</strong>:</p>\n<ul>\n<li>Access to current environment chain</li>\n<li>Call stack inspection (requires maintaining evaluation stack trace)</li>\n<li>Step-by-step execution control</li>\n</ul>\n</li>\n<li><p><strong>Debugger Commands</strong>:</p>\n<ul>\n<li><code>step</code> (execute next statement)</li>\n<li><code>continue</code> (resume execution)</li>\n<li><code>print &lt;expression&gt;</code> (evaluate expression in current context)</li>\n<li><code>backtrace</code> (show call stack)</li>\n<li><code>locals</code> (show current environment variables)</li>\n</ul>\n</li>\n<li><p><strong>Implementation Approaches</strong>:</p>\n<ul>\n<li><strong>Passive Debugging</strong>: Add instrumentation that can be toggled, pausing at breakpoints</li>\n<li><strong>Active Debugging</strong>: Run interpreter in a separate thread/process with control channel</li>\n<li><strong>Source Mapping</strong>: Map execution position back to source code for meaningful breakpoints</li>\n</ul>\n</li>\n</ol>\n<p><strong>Example REPL Session Flow</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>&gt; var x = 10\nnil\n&gt; x + 5\n15\n&gt; fun add(a, b) { return a + b; }\nnil\n&gt; add(3, 4)\n7\n&gt; .exit</code></pre></div>\n\n<p><strong>The Debugger-Enhanced Evaluator</strong>\nThe <code>Evaluator.evaluate</code> method would gain additional logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(self, node, env):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Debugger hook: check if we should break here</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.debugger.should_break(node):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.debugger.enter_debug_mode(node, env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Original evaluation logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ...</span></span></code></pre></div>\n\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical starting points for implementing the extensions discussed above, focusing on the Python implementation as the primary language.</p>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Array/Hash Values</td>\n<td>Python <code>list</code>/<code>dict</code> as backing store</td>\n<td>Custom collection classes with copy-on-write</td>\n</tr>\n<tr>\n<td>Class System</td>\n<td>Single inheritance with explicit <code>super</code></td>\n<td>Multiple inheritance with C3 linearization</td>\n</tr>\n<tr>\n<td>Exceptions</td>\n<td>Control flow signals (extending existing system)</td>\n<td>True stack unwinding with traceback objects</td>\n</tr>\n<tr>\n<td>Bytecode Compiler</td>\n<td>Simple linear bytecode generation</td>\n<td>Basic block analysis with optimization passes</td>\n</tr>\n<tr>\n<td>VM Implementation</td>\n<td>Stack-based with switch dispatch</td>\n<td>Register-based with computed goto (C extension)</td>\n</tr>\n<tr>\n<td>REPL Interface</td>\n<td>Basic line-by-line input with <code>readline</code></td>\n<td>Full terminal UI with syntax highlighting</td>\n</tr>\n<tr>\n<td>Debugger</td>\n<td>Simple breakpoint inspection</td>\n<td>Remote debugging protocol with IDE integration</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<p>For a project extending the interpreter with these features, consider this expanded structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>tree_walker/\n├── __init__.py\n├── interpreter.py          # Main Interpreter class, REPL integration\n├── parser/\n│   ├── __init__.py\n│   ├── parser.py          # Extended parser with new syntax\n│   └── ast_nodes.py       # New AST nodes for classes, try/catch, etc.\n├── compiler/              # For bytecode evolution\n│   ├── __init__.py\n│   ├── compiler.py        # AST → Bytecode compiler\n│   └── bytecode.py        # Bytecode instruction definitions\n├── vm/                    # For bytecode evolution\n│   ├── __init__.py\n│   └── virtual_machine.py # Stack-based VM implementation\n├── runtime/\n│   ├── __init__.py\n│   ├── values.py          # Extended runtime values (ArrayValue, ClassValue, etc.)\n│   ├── environment.py     # Enhanced for class inheritance chains\n│   └── builtins.py        # Standard library function implementations\n├── eval/\n│   ├── __init__.py\n│   ├── evaluator.py       # Extended Evaluator with new statement handlers\n│   ├── control_flow.py    # Exception signal handling\n│   └── debugger.py        # Debugger integration hooks\n└── repl/\n    ├── __init__.py\n    └── interactive.py     # REPL implementation with line editing</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-native-function-wrapper\">Infrastructure Starter Code: Native Function Wrapper</h4>\n<p>Here&#39;s complete starter code for implementing built-in standard library functions, a prerequisite for many extensions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># runtime/builtins.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Built-in standard library functions.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> runtime.values </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Value, NativeFunctionValue, NumberValue, StringValue, ArrayValue</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Builtins</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Registry of built-in functions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> clock</span><span style=\"color:#E1E4E8\">(args: List[Value]) -> Value:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return current time in seconds since epoch.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> NumberValue(time.time())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> print</span><span style=\"color:#E1E4E8\">(args: List[Value]) -> Value:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Print all arguments converted to strings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Interpreter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        strings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [Interpreter._stringify(arg) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> args]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" \"</span><span style=\"color:#E1E4E8\">.join(strings))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> NilValue()  </span><span style=\"color:#6A737D\"># Assuming NilValue is defined elsewhere</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> length</span><span style=\"color:#E1E4E8\">(args: List[Value]) -> Value:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return length of string or array.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"length() expects exactly 1 argument\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(val, StringValue):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> NumberValue(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(val.value))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(val, ArrayValue):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> NumberValue(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(val.elements))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"length() expects string or array\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> array_push</span><span style=\"color:#E1E4E8\">(args: List[Value]) -> Value:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Append value to array. Returns nil.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"array_push() expects 2 arguments (array, value)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        array, value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], args[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(array, ArrayValue):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"First argument to array_push() must be array\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        array.elements.append(value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> NilValue()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # More built-in functions...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_all</span><span style=\"color:#E1E4E8\">(cls) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return dictionary of all built-in functions for global environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"clock\"</span><span style=\"color:#E1E4E8\">: NativeFunctionValue(</span><span style=\"color:#9ECBFF\">\"clock\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">cls</span><span style=\"color:#E1E4E8\">.clock, </span><span style=\"color:#FFAB70\">arity</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"print\"</span><span style=\"color:#E1E4E8\">: NativeFunctionValue(</span><span style=\"color:#9ECBFF\">\"print\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">cls</span><span style=\"color:#E1E4E8\">.print, </span><span style=\"color:#FFAB70\">arity</span><span style=\"color:#F97583\">=-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),  </span><span style=\"color:#6A737D\"># -1 = variadic</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"length\"</span><span style=\"color:#E1E4E8\">: NativeFunctionValue(</span><span style=\"color:#9ECBFF\">\"length\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">cls</span><span style=\"color:#E1E4E8\">.length, </span><span style=\"color:#FFAB70\">arity</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"array_push\"</span><span style=\"color:#E1E4E8\">: NativeFunctionValue(</span><span style=\"color:#9ECBFF\">\"array_push\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">cls</span><span style=\"color:#E1E4E8\">.array_push, </span><span style=\"color:#FFAB70\">arity</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># runtime/values.py addition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NativeFunctionValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Runtime value representing a built-in function implemented in host language.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, func: </span><span style=\"color:#79B8FF\">callable</span><span style=\"color:#E1E4E8\">, arity: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.func </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.arity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> arity  </span><span style=\"color:#6A737D\"># -1 for variadic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">(self, arguments: List[Value]) -> Value:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute the native function with given arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check arity unless variadic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.arity </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> and</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(arguments) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.arity:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">() expects </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.arity</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(arguments)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.func(arguments)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Convert host language exceptions to interpreter runtime errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Built-in function error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;native function </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">>\"</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code-class-evaluation\">Core Logic Skeleton Code: Class Evaluation</h4>\n<p>For implementing class-based OOP, here&#39;s skeleton code for the key evaluator methods:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># eval/evaluator.py additions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... existing code ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_class_stmt</span><span style=\"color:#E1E4E8\">(self, node: ClassStmt, env: Environment) -> Value:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate a class definition statement.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Evaluate parent class expression if present (must evaluate to ClassValue)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Create a new environment for the class's methods (parent is global/env?)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Evaluate all method definitions in the class's environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Create ClassValue with method dictionary and parent reference</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Bind class name in current environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Return nil</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle parent class inheritance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if node.parent is not None:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     parent = self.evaluate(node.parent, env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     if not isinstance(parent, ClassValue):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         raise TypeError(\"Parent must be a class\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   else:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     parent = None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create class environment for method definitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   class_env = Environment(store={}, parent=env)  # Or parent's class env?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Evaluate each method definition in class_env</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   methods = {}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   for method in node.methods:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     # method is a FunctionStmt node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     func_value = FunctionValue(</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         name=method.name,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         parameters=method.params,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         body=method.body,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         closure=class_env  # Methods close over class environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     )</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     methods[method.name] = func_value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create the ClassValue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   class_value = ClassValue(</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         name=node.name,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         methods=methods,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         parent=parent,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         class_env=class_env</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Bind class name in current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   env.define(node.name, class_value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> NilValue()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_new_expr</span><span style=\"color:#E1E4E8\">(self, node: NewExpr, env: Environment) -> Value:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate 'new ClassName(arguments)' expression.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Evaluate the class expression (should be a ClassValue)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Create a new InstanceValue with reference to the class</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Create a new environment for the instance (self)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. If class has constructor ('init' method), call it with arguments</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Return the instance</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate class expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   class_value = self.evaluate(node.class_expr, env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if not isinstance(class_value, ClassValue):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     raise TypeError(\"Can only instantiate classes\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create InstanceValue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   instance = InstanceValue(class_value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create instance environment for 'self'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   instance_env = Environment(store={}, parent=???)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   instance_env.define(\"self\", instance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Find and call constructor if exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if \"init\" in class_value.methods:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     constructor = class_value.methods[\"init\"]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     # Bind 'self' as implicit first argument</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     bound_args = [instance] + evaluated_args</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     constructor.call(bound_args, instance_env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return the instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_get_expr</span><span style=\"color:#E1E4E8\">(self, node: GetExpr, env: Environment) -> Value:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate 'object.property' expression.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Evaluate the object expression (should be InstanceValue)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Look up property name in instance fields first</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. If not found, look up in class methods (walking inheritance chain)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. If found as method, return it bound to the instance</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. If not found, raise runtime error</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate object expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   obj = self.evaluate(node.object, env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if not isinstance(obj, InstanceValue):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     raise TypeError(\"Only instances have properties\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check instance fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if node.property in obj.fields:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     return obj.fields[node.property]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Look up in class method chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   method = obj.klass.find_method(node.property)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if method is not None:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     # Return a bound method (function with self pre-bound)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     return BoundMethodValue(instance=obj, method=method)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise property error if not found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Undefined property '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.property</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code-exception-handling\">Core Logic Skeleton Code: Exception Handling</h4>\n<p>For implementing exceptions with the control flow signal pattern:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># eval/control_flow.py additions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ThrowSignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ControlFlowSignal</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signal raised when 'throw' statement is executed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value: Value):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># eval/evaluator.py additions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Evaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... existing code ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_throw_stmt</span><span style=\"color:#E1E4E8\">(self, node: ThrowStmt, env: Environment) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate 'throw expression' statement.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Evaluate the exception expression</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Raise ThrowSignal with the exception value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate the exception expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   exception_value = self.evaluate(node.expression, env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Raise ThrowSignal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   raise ThrowSignal(exception_value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_try_stmt</span><span style=\"color:#E1E4E8\">(self, node: TryStmt, env: Environment) -> Value:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Evaluate try-catch statement.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Wrap try block evaluation in try-except catching ThrowSignal</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. If ThrowSignal caught, evaluate catch block with exception bound</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. If no exception, just return try block result (or nil)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Always execute finally block if present</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Try to evaluate the try block</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   try:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     result = self.evaluate(node.try_block, env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   except ThrowSignal as e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     # Exception was thrown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If exception caught and catch block present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if node.catch_block is not None:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     # Create new environment for catch variable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     catch_env = Environment(store={}, parent=env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     catch_env.define(node.catch_var, e.value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     result = self.evaluate(node.catch_block, catch_env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If no catch or re-throw, propagate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Execute finally block if present (always)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if node.finally_block is not None:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     self.evaluate(node.finally_block, env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result  </span><span style=\"color:#6A737D\"># Or nil</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-python\">Language-Specific Hints: Python</h4>\n<ol>\n<li><p><strong>For Array/Hash Values</strong>: Use Python&#39;s <code>list</code> and <code>dict</code> as backing stores but wrap them in custom classes to control string representation and equality semantics.</p>\n</li>\n<li><p><strong>For Class Method Lookup</strong>: Implement method resolution order (MRO) similar to Python&#39;s C3 linearization for multiple inheritance, or simple depth-first search for single inheritance.</p>\n</li>\n<li><p><strong>For Bytecode VM</strong>: Use Python&#39;s <code>array(&#39;B&#39;)</code> or <code>bytes</code> for compact bytecode storage. For the dispatch loop, a <code>while True:</code> loop with a large <code>match</code> statement (Python 3.10+) or dictionary dispatch.</p>\n</li>\n<li><p><strong>For REPL History</strong>: Use the <code>readline</code> module on Unix or <code>pyreadline</code> on Windows for line editing and history. Handle <code>KeyboardInterrupt</code> (Ctrl+C) gracefully.</p>\n</li>\n<li><p><strong>For Debugger Inspection</strong>: Use the <code>inspect</code> module to examine Python call stack, but maintain your own interpreter call stack for meaningful source-level debugging.</p>\n</li>\n</ol>\n<h4 id=\"milestone-checkpoint-testing-extensions\">Milestone Checkpoint: Testing Extensions</h4>\n<p>After implementing any extension, verify with these test programs:</p>\n<p><strong>Arrays Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> arr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(arr[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);  </span><span style=\"color:#6A737D\">// Should print: 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">arr[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(arr[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);  </span><span style=\"color:#6A737D\">// Should print: 10</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">length</span><span style=\"color:#E1E4E8\">(arr));  </span><span style=\"color:#6A737D\">// Should print: 3</span></span></code></pre></div>\n\n<p><strong>Classes Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Counter</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  init</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  increment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Counter</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">c.</span><span style=\"color:#B392F0\">increment</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(c.value);  </span><span style=\"color:#6A737D\">// Should print: 1</span></span></code></pre></div>\n\n<p><strong>Exceptions Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  throw</span><span style=\"color:#9ECBFF\"> \"Something went wrong\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (e) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Caught:\"</span><span style=\"color:#E1E4E8\">, e);  </span><span style=\"color:#6A737D\">// Should print: Caught: Something went wrong</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>REPL Test:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>$ python interpreter.py --repl\n&gt; var x = 5\nnil\n&gt; x * 2\n10\n&gt; .exit</code></pre></div>\n\n<h4 id=\"debugging-tips-for-extensions\">Debugging Tips for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Array modifications affect unrelated variables</strong></td>\n<td>Reference semantics issue: multiple variables reference same list object</td>\n<td>Print object IDs or check <code>id(array)</code> in Python</td>\n<td>Ensure array literals create new lists: <code>ArrayValue(elements=list(node.elements))</code></td>\n</tr>\n<tr>\n<td><strong>Class method can&#39;t access <code>self</code> properties</strong></td>\n<td>Method closure environment not set correctly</td>\n<td>Check <code>FunctionValue.closure</code> field for methods</td>\n<td>Methods should close over class environment, which has <code>self</code> defined during calls</td>\n</tr>\n<tr>\n<td><strong>Exceptions not caught by correct <code>catch</code> block</strong></td>\n<td><code>ThrowSignal</code> caught at wrong level</td>\n<td>Add print statements showing signal propagation</td>\n<td>Ensure <code>TryStmt</code> evaluation catches <code>ThrowSignal</code> before parent evaluators</td>\n</tr>\n<tr>\n<td><strong>REL doesn&#39;t preserve variable state between inputs</strong></td>\n<td>New Environment created for each input</td>\n<td>Check if REPL reuses the same global environment</td>\n<td>Pass persistent environment to each evaluation in the REPL loop</td>\n</tr>\n<tr>\n<td><strong>Bytecode VM runs slower than tree-walker</strong></td>\n<td>Instruction dispatch overhead</td>\n<td>Profile to see time spent in switch/match statement</td>\n<td>Consider computed goto (C extension) or direct threading for performance</td>\n</tr>\n</tbody></table>\n<p>These extensions transform a simple educational interpreter into a more capable language implementation, providing excellent learning opportunities in language design, runtime systems, and software architecture. Each builds upon the solid foundation established in the core milestones while introducing new concepts and challenges.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 2, 3, 4</p>\n</blockquote>\n<p>This section defines key technical terms, acronyms, and domain-specific vocabulary used throughout this design document. Understanding this lexicon is essential for precise communication about the interpreter&#39;s architecture and behavior.</p>\n<hr>\n<p><strong>Abstract Syntax Tree (AST):</strong> A hierarchical, tree-like data structure that represents the syntactic structure of source code. Each node in the tree corresponds to a construct in the language (e.g., an expression, a statement). The AST discards irrelevant details like whitespace and parentheses (though grouping nodes preserve evaluation order). The interpreter executes programs by recursively &quot;walking&quot; this tree. Compare to a <em>parse tree</em>, which is more granular and includes every syntactic detail from the grammar.</p>\n<p><strong>Arity:</strong> The number of parameters a function or operation expects. For example, a binary operator has an arity of two. The interpreter checks that the number of arguments passed in a function call matches the function&#39;s declared arity, raising an <code>ArgumentError</code> if they differ.</p>\n<p><strong>Binding:</strong> The association between a variable name (an identifier) and its current runtime value. Binding occurs during variable declaration (e.g., <code>var x = 5;</code>) and reassignment (e.g., <code>x = 10;</code>). The <code>Environment</code> stores these name-to-value mappings.</p>\n<p><strong>Block:</strong> A sequence of statements enclosed by braces <code>{}</code>. A block introduces a new lexical scope. When evaluated, statements within a block are executed sequentially. The result of a block is the value of the last statement executed (often <code>nil</code> if the block ends without a return statement).</p>\n<p><strong>Bytecode:</strong> A compact, intermediate representation of a program designed for efficient execution by a virtual machine (VM). Bytecode is lower-level than an AST but higher-level than machine code. This design document focuses on a tree-walking interpreter, not a bytecode VM, but the Future Extensions section discusses evolving the design toward bytecode.</p>\n<p><strong>Closure:</strong> A <strong>first-class function</strong> that &quot;closes over&quot; or captures variables from its <strong>lexical scope</strong> at the time of its definition. A closure consists of the function&#39;s code (its parameters and body) and a reference to its <strong>defining environment</strong>. This allows the function to access those captured variables even when called outside their original scope. In our interpreter, a <code>FunctionValue</code> stores its <code>closure</code> environment, enabling true lexical closures.</p>\n<p><strong>Control Flow:</strong> The order in which individual statements, instructions, or function calls are executed or evaluated. Basic control flow is sequential. <strong>Control flow statements</strong> like <code>if</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, and <code>return</code> alter this sequence based on conditions or explicit jumps.</p>\n<p><strong>Control Flow Signal:</strong> A special exception-like mechanism used internally by the interpreter to implement non-local jumps such as <code>break</code>, <code>continue</code>, and <code>return</code>. Instead of unwinding the call stack through normal function returns, these signals are caught by designated handlers (e.g., a loop catcher for <code>break</code>/<code>continue</code>, the function call mechanism for <code>return</code>).</p>\n<p><strong>Desugaring:</strong> The process of translating syntactic sugar—convenient, higher-level syntax—into more primitive constructs already present in the core language. For example, a <code>for</code> loop can be <em>desugared</em> into an equivalent <code>while</code> loop plus some initialization and increment statements. This simplifies the interpreter&#39;s core evaluation logic by reducing the number of distinct node types it must handle directly.</p>\n<p><strong>Dispatch:</strong> The mechanism by which the <code>Evaluator</code> selects the appropriate evaluation logic for a given AST node type. Our design uses a single <code>evaluate</code> function that inspects the node&#39;s type and routes it to a corresponding internal method (e.g., <code>_evaluate_binary_expr</code>). This is a form of <em>single dispatch</em> based on the node type.</p>\n<p><strong>Environment:</strong> A runtime data structure that maps variable names to their current values. It represents a <strong>scope</strong>. Environments are linked in a chain via <code>parent</code> references, forming an <strong>environment chain</strong>. The <code>Environment</code> class provides three core operations: <code>define</code> (create a new binding), <code>get</code> (retrieve a value by name, walking the chain), and <code>assign</code> (update an existing binding, walking the chain to find it).</p>\n<p><strong>Environment Chain:</strong> A linked list of <code>Environment</code> objects, where each link represents a nested lexical scope. When looking up a variable, the interpreter starts in the innermost (current) environment and proceeds outward through parent links until the variable is found or the global scope (with no parent) is reached. This chain implements <strong>lexical scoping</strong>. <img src=\"/api/project/ast-interpreter/architecture-doc/asset?path=diagrams%2Fenv-chain-lookup.svg\" alt=\"Diagram: Environment Chain Lookup\"></p>\n<p><strong>Evaluator:</strong> The core component of the interpreter responsible for traversing the AST and computing results. It is a stateless class whose main entry point is the recursive <code>evaluate(node, environment)</code> method. The evaluator contains the semantic rules of the language—it knows how to add numbers, execute an <code>if</code> statement, call a function, etc.</p>\n<p><strong>First-Class Function:</strong> A function that can be treated like any other value in the language: it can be assigned to variables, stored in data structures, passed as an argument to other functions, and returned as a result from a function. Our interpreter implements first-class functions via <code>FunctionValue</code> objects.</p>\n<p><strong>Frame:</strong> Another term for an <strong>environment</strong> or scope, often used in the context of a call stack. Each function call typically creates a new frame/environment to hold its local variables.</p>\n<p><strong>Global Environment:</strong> The outermost environment in the <strong>environment chain</strong>. It has no parent. It typically holds built-in functions (like <code>print</code>) and globally declared variables. The global environment persists for the entire execution of the program.</p>\n<p><strong>Immutable AST:</strong> A design principle where AST nodes, once created by the parser, are never modified. The interpreter treats the AST as a read-only data structure, generating new runtime values but never altering the tree itself. This simplifies reasoning about program execution and enables potential future optimizations like caching.</p>\n<p><strong>Interpreter:</strong> In this context, the complete system that executes source code. Our <strong>tree-walking interpreter</strong> consists of a parser (which builds the AST from text) and the evaluation components (Evaluator, Environment Manager, etc.). The <code>Interpreter</code> class often serves as the public facade, with an <code>interpret(source_code)</code> method.</p>\n<p><strong>Lexical Scoping (Static Scoping):</strong> A scoping rule where the visibility of a variable is determined by its location in the source code—specifically, by the static, nested block structure. A variable defined in an outer scope is accessible in all inner scopes, unless it is <strong>shadowed</strong>. This contrasts with <em>dynamic scoping</em>, where visibility depends on the runtime call stack. Our interpreter implements lexical scoping via the <strong>environment chain</strong> captured in <strong>closures</strong>.</p>\n<p><strong>Literal:</strong> A syntactic representation of a fixed value in source code, such as a number (<code>42</code>), string (<code>&quot;hello&quot;</code>), boolean (<code>true</code>, <code>false</code>), or <code>nil</code>. In the AST, a literal node evaluates directly to the corresponding runtime value.</p>\n<p><strong>Lookup:</strong> The process of retrieving the value associated with a variable name by searching the <strong>environment chain</strong>. This is performed by the <code>Environment.get(name)</code> method.</p>\n<p><strong>Mental Model:</strong> An intuitive analogy or simplified conceptual framework used to understand a complex system without grappling with all its underlying details. This document uses mental models like &quot;The Math Homework Grader&quot; for the evaluator and &quot;Stack of Ledgers&quot; for environments to build reader intuition before presenting technical specifications.</p>\n<p><strong>Name Binding:</strong> See <strong>Binding</strong>.</p>\n<p><strong>Native Function:</strong> A function implemented in the interpreter&#39;s host language (e.g., Python) rather than in the interpreted language itself. Native functions, such as <code>Builtins.clock</code>, provide essential capabilities that would be inefficient or impossible to implement in the interpreted language. They are exposed as <code>NativeFunctionValue</code> objects.</p>\n<p><strong>Nil:</strong> A special value representing the absence of a meaningful value. It is analogous to <code>null</code> in many languages. In our interpreter, <code>nil</code> is falsy in boolean contexts and is the implicit return value of statements and functions that don&#39;t execute an explicit <code>return</code>.</p>\n<p><strong>Non-Local Exit:</strong> A control flow operation that transfers execution out of the current context, potentially skipping multiple levels of nested scopes or statements. <code>break</code>, <code>continue</code>, and <code>return</code> are examples. Our interpreter implements these using <strong>control flow signals</strong> that are caught by specific handlers higher up the call stack.</p>\n<p><strong>Operator Precedence:</strong> Rules that determine the order in which different operators in an expression are evaluated when parentheses are not present. For example, multiplication has higher precedence than addition. Precedence is handled during parsing, not evaluation; the resulting AST&#39;s structure implicitly encodes the correct order.</p>\n<p><strong>Parse Tree (Concrete Syntax Tree):</strong> A detailed tree representation of source code that includes every token and syntactic rule used during parsing, including punctuation and grammar artifacts. The <strong>AST</strong> is a simplified abstraction derived from the parse tree, focusing on semantic structure.</p>\n<p><strong>REPL (Read-Eval-Print Loop):</strong> An interactive programming environment that reads a user&#39;s input, evaluates it, prints the result, and then loops to wait for the next input. While not a core milestone, a REPL is a common extension for interpreters, useful for testing and exploration.</p>\n<p><strong>Runtime Error:</strong> An error that occurs during program execution (as opposed to a syntax error, which is caught during parsing). Our interpreter defines specific error types like <code>TypeError</code>, <code>UndefinedVariableError</code>, and <code>DivisionByZeroError</code>. The interpreter follows a <strong>fail-fast</strong> strategy, halting execution and reporting the error when one occurs.</p>\n<p><strong>Runtime Value:</strong> A piece of data that exists and can be manipulated during program execution. Our interpreter&#39;s runtime values include numbers, strings, booleans, <code>nil</code>, and <code>FunctionValue</code> objects (including <code>NativeFunctionValue</code>). These are distinct from AST nodes, which represent the static structure of the code.</p>\n<p><strong>Scope:</strong> A region of the source code where a variable binding is visible. Scopes are typically introduced by functions, blocks, or the global context. Our interpreter uses <strong>lexical scoping</strong>, meaning the scope is determined by the physical nesting of code structures.</p>\n<p><strong>Shadowing:</strong> The phenomenon where a variable declared in an inner scope has the same name as a variable in an outer scope. The inner variable &quot;shadows&quot; the outer one, making the outer variable inaccessible by its name within the inner scope. The <strong>environment chain</strong> lookup resolves to the innermost binding, thereby implementing shadowing.</p>\n<p><strong>Short-Circuit Evaluation:</strong> An optimization for logical operators <code>and</code> and <code>or</code> where the right operand is evaluated only if necessary to determine the result. For <code>and</code>, if the left operand is falsy, the result is falsy without evaluating the right. For <code>or</code>, if the left operand is truthy, the result is truthy without evaluating the right. This is both a performance optimization and a feature that allows expressions like <code>if (x != nil and x.value &gt; 0)</code> to avoid null pointer errors.</p>\n<p><strong>Statement:</strong> A unit of code that performs an action but does not produce a value (or produces a value of secondary importance). Examples include variable declarations, assignments, <code>if</code> statements, loops, and <code>return</code>. In our interpreter, statements are evaluated for their side effects; their evaluation typically returns <code>nil</code> unless they contain an expression that yields a value (like a function call inside a <code>print</code> statement).</p>\n<p><strong>Static vs. Dynamic:</strong>  </p>\n<ul>\n<li><strong>Static:</strong> Properties determined by analyzing the source code without executing it (e.g., syntax, lexical scope).  </li>\n<li><strong>Dynamic:</strong> Properties determined only at runtime (e.g., the value of a variable, the type of an expression&#39;s result). Our interpreter performs static parsing but dynamic evaluation.</li>\n</ul>\n<p><strong>Tail-Call Optimization (TCO):</strong> A compiler/interpreter optimization that reuses the current function&#39;s stack frame for a function call in <em>tail position</em> (the last action before returning). This allows infinite recursion without stack overflow for tail-recursive algorithms. Our interpreter does not implement TCO (it&#39;s a non-goal), but the architecture could be extended to support it.</p>\n<p><strong>Token:</strong> The smallest meaningful unit in the source code, produced by the lexer/scanner. Examples include identifiers, keywords, operators, literals, and punctuation. Tokens are used by the parser to build the AST. While not directly used during evaluation, tokens are attached to AST nodes and referenced in error messages for location information.</p>\n<p><strong>Tree-Walking:</strong> The evaluation strategy where the interpreter directly traverses the <strong>AST</strong>, executing operations at each node recursively. This is contrasted with compilation to <strong>bytecode</strong> or machine code. Tree-walking is simple to implement and understand but is typically slower than bytecode execution.</p>\n<p><strong>Truthiness:</strong> The boolean interpretation of a non-boolean value when used in a conditional context (e.g., <code>if (value)</code>). Our interpreter&#39;s truthiness rules are: <code>false</code> and <code>nil</code> are falsy; everything else (including <code>0</code>, empty string <code>&quot;&quot;</code>) is truthy. The <code>Evaluator._is_truthy(value)</code> method encapsulates this logic.</p>\n<p><strong>Type Checking:</strong> The process of verifying that the operands of an operation are of appropriate types before performing the operation. Our interpreter performs <em>dynamic type checking</em> at runtime. For example, the <code>+</code> operator checks that both operands are numbers or both are strings; if not, it raises a <code>TypeError</code>.</p>\n<p><strong>Undefined Variable:</strong> A variable that is referenced (in an expression or assignment) but has not been declared in any accessible scope. Attempting to evaluate such a variable raises an <code>UndefinedVariableError</code>.</p>\n<p><strong>Variable:</strong> A named reference to a <strong>runtime value</strong>. Variables are declared (which creates a <strong>binding</strong>) and can later be assigned new values. Variable lookup follows the <strong>environment chain</strong>.</p>\n<p><strong>Virtual Machine (VM):</strong> A software simulation of a computer that executes instructions. In language implementation, a <strong>bytecode VM</strong> executes a compact instruction set. Our tree-walking interpreter is not a VM in this sense, but the design could evolve into one by adding a compilation phase from AST to bytecode and an execution engine for that bytecode.</p>\n<hr>\n","toc":[{"level":1,"text":"AST Tree-Walking Interpreter: Design Document","id":"ast-tree-walking-interpreter-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Math Homework Grader","id":"mental-model-the-math-homework-grader"},{"level":3,"text":"The Interpretation Problem","id":"the-interpretation-problem"},{"level":3,"text":"Existing Approaches and Trade-offs","id":"existing-approaches-and-trade-offs"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Goals (What we must implement)","id":"goals-what-we-must-implement"},{"level":3,"text":"Non-Goals (What we explicitly omit)","id":"non-goals-what-we-explicitly-omit"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code: Runtime Error Types","id":"infrastructure-starter-code-runtime-error-types"},{"level":4,"text":"Core Logic Skeleton: Main Interpreter Entry Point","id":"core-logic-skeleton-main-interpreter-entry-point"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":4,"text":"AST: The Static Blueprint","id":"ast-the-static-blueprint"},{"level":4,"text":"Evaluator: The Recursive Director","id":"evaluator-the-recursive-director"},{"level":4,"text":"Environment Chain: The Layered Storage","id":"environment-chain-the-layered-storage"},{"level":3,"text":"Execution Flow","id":"execution-flow"},{"level":4,"text":"Step-by-Step Processing Pipeline","id":"step-by-step-processing-pipeline"},{"level":4,"text":"Phase Separation: Parse vs. Evaluate","id":"phase-separation-parse-vs-evaluate"},{"level":4,"text":"Control Flow and Unwinding","id":"control-flow-and-unwinding"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Module Responsibilities and Dependencies","id":"module-responsibilities-and-dependencies"},{"level":4,"text":"Import Strategy to Avoid Circular Dependencies","id":"import-strategy-to-avoid-circular-dependencies"},{"level":4,"text":"Configuration and Entry Points","id":"configuration-and-entry-points"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File Structure Implementation","id":"b-recommended-file-structure-implementation"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints for Python","id":"e-language-specific-hints-for-python"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Runtime Values and Types","id":"runtime-values-and-types"},{"level":3,"text":"The Environment Model","id":"the-environment-model"},{"level":3,"text":"Key AST Node Types for Evaluation","id":"key-ast-node-types-for-evaluation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code (COMPLETE)","id":"c-infrastructure-starter-code-complete"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints (Python)","id":"e-language-specific-hints-python"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Component Design: Core Evaluator","id":"component-design-core-evaluator"},{"level":3,"text":"Mental Model: The DOM Tree Walker","id":"mental-model-the-dom-tree-walker"},{"level":3,"text":"Interface and Dispatch","id":"interface-and-dispatch"},{"level":3,"text":"Internal Behavior and Algorithm","id":"internal-behavior-and-algorithm"},{"level":3,"text":"ADR: Expression Dispatch Strategy","id":"adr-expression-dispatch-strategy"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints (Python)","id":"e-language-specific-hints-python"},{"level":4,"text":"F. Milestone Checkpoint (Milestone 1: Expression Evaluation)","id":"f-milestone-checkpoint-milestone-1-expression-evaluation"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Component Design: Environment Manager","id":"component-design-environment-manager"},{"level":3,"text":"Mental Model: Stack of Ledgers","id":"mental-model-stack-of-ledgers"},{"level":3,"text":"Interface: Define, Get, Set","id":"interface-define-get-set"},{"level":3,"text":"Internal Behavior","id":"internal-behavior"},{"level":4,"text":"Variable Resolution Algorithm (Walking the Chain)","id":"variable-resolution-algorithm-walking-the-chain"},{"level":4,"text":"Scope Creation and Teardown","id":"scope-creation-and-teardown"},{"level":3,"text":"ADR: Environment Chain vs. Flat Frame","id":"adr-environment-chain-vs-flat-frame"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Component Design: Control Flow Executor","id":"component-design-control-flow-executor"},{"level":3,"text":"Mental Model: Railroad Switching Yard","id":"mental-model-railroad-switching-yard"},{"level":3,"text":"Interface for Statements and Jumps","id":"interface-for-statements-and-jumps"},{"level":3,"text":"Internal Behavior for Loops and Jumps","id":"internal-behavior-for-loops-and-jumps"},{"level":4,"text":"Algorithm for if Statement Evaluation","id":"algorithm-for-if-statement-evaluation"},{"level":4,"text":"Algorithm for while Loop Evaluation","id":"algorithm-for-while-loop-evaluation"},{"level":4,"text":"Algorithm for for Loop Evaluation (via Desugaring)","id":"algorithm-for-for-loop-evaluation-via-desugaring"},{"level":4,"text":"Algorithm for Handling return Statement","id":"algorithm-for-handling-return-statement"},{"level":3,"text":"ADR: Handling Break/Continue","id":"adr-handling-breakcontinue"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component Design: Function Manager","id":"component-design-function-manager"},{"level":3,"text":"Mental Model: Recipe with Personal Ingredients","id":"mental-model-recipe-with-personal-ingredients"},{"level":3,"text":"Interface: Callable Values and Closure","id":"interface-callable-values-and-closure"},{"level":4,"text":"FunctionValue Data Structure","id":"functionvalue-data-structure"},{"level":4,"text":"Callable Interface","id":"callable-interface"},{"level":3,"text":"Internal Behavior: Call and Return","id":"internal-behavior-call-and-return"},{"level":4,"text":"1. Function Definition Evaluation","id":"1-function-definition-evaluation"},{"level":4,"text":"2. Function Call Evaluation","id":"2-function-call-evaluation"},{"level":4,"text":"3. Return Statement Handling","id":"3-return-statement-handling"},{"level":3,"text":"ADR: Closure Capture Strategy","id":"adr-closure-capture-strategy"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Sequence of Operations","id":"sequence-of-operations"},{"level":4,"text":"Scenario 1: Variable Lookup Across Nested Scopes","id":"scenario-1-variable-lookup-across-nested-scopes"},{"level":4,"text":"Scenario 2: Function Call with Closure Capture","id":"scenario-2-function-call-with-closure-capture"},{"level":4,"text":"Scenario 3: Loop Execution with a Break Statement","id":"scenario-3-loop-execution-with-a-break-statement"},{"level":3,"text":"Message and Value Formats","id":"message-and-value-formats"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Runtime Error Types","id":"runtime-error-types"},{"level":3,"text":"Detection and Reporting","id":"detection-and-reporting"},{"level":4,"text":"Detection Points and Strategies","id":"detection-points-and-strategies"},{"level":4,"text":"Error Message Guidelines","id":"error-message-guidelines"},{"level":4,"text":"Recovery Behavior","id":"recovery-behavior"},{"level":3,"text":"Special Edge Cases","id":"special-edge-cases"},{"level":4,"text":"Nil Handling","id":"nil-handling"},{"level":4,"text":"Truthiness Rules","id":"truthiness-rules"},{"level":4,"text":"Empty Statement Blocks","id":"empty-statement-blocks"},{"level":4,"text":"Implicit Return from Functions","id":"implicit-return-from-functions"},{"level":4,"text":"Short-Circuit Evaluation Edge Cases","id":"short-circuit-evaluation-edge-cases"},{"level":4,"text":"Variable Shadowing and Redeclaration","id":"variable-shadowing-and-redeclaration"},{"level":4,"text":"Division and Modulo by Zero","id":"division-and-modulo-by-zero"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code: Error Classes","id":"infrastructure-starter-code-error-classes"},{"level":4,"text":"Core Logic Skeleton: Error Detection in Evaluator","id":"core-logic-skeleton-error-detection-in-evaluator"},{"level":4,"text":"Environment with Error Detection","id":"environment-with-error-detection"},{"level":4,"text":"Language-Specific Hints (Python)","id":"language-specific-hints-python"},{"level":4,"text":"Testing Error Handling","id":"testing-error-handling"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Testing Approach and Tools","id":"testing-approach-and-tools"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Symptom → Cause → Fix Table","id":"symptom-cause-fix-table"},{"level":3,"text":"Debugging Techniques and Tools","id":"debugging-techniques-and-tools"},{"level":4,"text":"Strategic Print Logging","id":"strategic-print-logging"},{"level":4,"text":"AST and Environment Visualization","id":"ast-and-environment-visualization"},{"level":4,"text":"Interactive Debugger via REPL Hook","id":"interactive-debugger-via-repl-hook"},{"level":4,"text":"Using Your Language&#39;s Debugger","id":"using-your-language39s-debugger"},{"level":4,"text":"Differential Testing Against Known Implementations","id":"differential-testing-against-known-implementations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Complete Debug Tracer (Ready to Use)","id":"c-complete-debug-tracer-ready-to-use"},{"level":4,"text":"D. Core Evaluator Integration with Tracer","id":"d-core-evaluator-integration-with-tracer"},{"level":4,"text":"E. Environment Class with Debug Support","id":"e-environment-class-with-debug-support"},{"level":4,"text":"F. Debugging Tips for Specific Languages","id":"f-debugging-tips-for-specific-languages"},{"level":4,"text":"G. Milestone Debugging Checkpoints","id":"g-milestone-debugging-checkpoints"},{"level":4,"text":"H. Common Debug Workflow","id":"h-common-debug-workflow"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Language Feature Extensions","id":"language-feature-extensions"},{"level":4,"text":"Arrays and Hashes (Composite Data Types)","id":"arrays-and-hashes-composite-data-types"},{"level":4,"text":"Classes and Object-Oriented Programming","id":"classes-and-object-oriented-programming"},{"level":4,"text":"Exception Handling","id":"exception-handling"},{"level":4,"text":"Standard Library Functions","id":"standard-library-functions"},{"level":4,"text":"Tail-Call Optimization","id":"tail-call-optimization"},{"level":3,"text":"Architectural Evolutions","id":"architectural-evolutions"},{"level":4,"text":"From Tree-Walking to Bytecode Compilation and Virtual Machine","id":"from-tree-walking-to-bytecode-compilation-and-virtual-machine"},{"level":4,"text":"Adding a REPL and Debugger","id":"adding-a-repl-and-debugger"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code: Native Function Wrapper","id":"infrastructure-starter-code-native-function-wrapper"},{"level":4,"text":"Core Logic Skeleton Code: Class Evaluation","id":"core-logic-skeleton-code-class-evaluation"},{"level":4,"text":"Core Logic Skeleton Code: Exception Handling","id":"core-logic-skeleton-code-exception-handling"},{"level":4,"text":"Language-Specific Hints: Python","id":"language-specific-hints-python"},{"level":4,"text":"Milestone Checkpoint: Testing Extensions","id":"milestone-checkpoint-testing-extensions"},{"level":4,"text":"Debugging Tips for Extensions","id":"debugging-tips-for-extensions"},{"level":2,"text":"Glossary","id":"glossary"}],"title":"AST Tree-Walking Interpreter: Design Document","markdown":"# AST Tree-Walking Interpreter: Design Document\n\n\n## Overview\n\nThis document outlines the design of a tree-walking interpreter that directly executes code by traversing its Abstract Syntax Tree (AST). The key architectural challenge is managing the evaluation environment—a dynamic mapping of names to values—and correctly implementing lexical scoping, function calls, and closures within a simple, recursive evaluator framework.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n> **Milestone(s):** This section establishes the foundational concepts for the entire project, providing context and rationale that underpins all four milestones of the AST Tree-Walking Interpreter.\n\n## Context and Problem Statement\n\nThe core challenge of building an interpreter is to bridge the gap between the **static text** of a source program and the **dynamic behavior** it is intended to produce. An interpreter must transform inert code into live computation, faithfully executing the programmer's intent—calculating values, managing changing state, and controlling the flow of execution. This document outlines the design of a **tree-walking interpreter**, a classic and pedagogically valuable architecture that directly evaluates a program by traversing its Abstract Syntax Tree (AST). The primary architectural challenge in this design is not merely processing syntax, but correctly modeling and managing the **runtime environment**—a dynamic, nested mapping of variable names to their values—which is the essence of how programs remember and manipulate state across different scopes and function calls. This section explains the problem space, introduces a foundational mental model, and contrasts our chosen approach with viable alternatives.\n\n### Mental Model: The Math Homework Grader\n\nImagine you are a teacher grading a complex arithmetic assignment. A student has written down an expression like `(5 + 3) * (10 - 2) / 4`. Your task is to compute the final answer. You don't just glance at it and guess; you follow a systematic, step-by-step process dictated by mathematical rules:\n\n1.  You first locate and solve any sub-expressions inside parentheses: `(5 + 3)` becomes `8` and `(10 - 2)` becomes `8`.\n2.  You then apply multiplication and division from left to right: `8 * 8` becomes `64`, then `64 / 4` becomes `16`.\n3.  Throughout this process, you hold intermediate results in your working memory.\n\nNow, suppose the student's homework includes **variables**: \"Let `x = 5`. Calculate `x * (x + 2)`.\" Your process becomes more involved. You must first write down in a notebook—a **ledger**—that `x` is `5`. When you encounter the variable `x` in the expression, you pause your calculation, look up its current value in your ledger, and substitute it (`5 * (5 + 2)`). If the problem defines a new `x` inside a sub-problem, you might start a fresh page in your notebook for that sub-problem, knowing you can look back to previous pages if a variable isn't found locally.\n\nFinally, imagine the assignment includes **procedures**: \"To compute the area of a rectangle, use the formula: `length * width`.\" The student then writes `area(10, 3)`. As the grader, you now have a **recipe** (the formula) and specific **ingredients** (`10` and `3`). You create a new, temporary workspace, assign `length = 10` and `width = 3`, perform the multiplication, report the result `30`, and then discard that temporary workspace, returning to the main problem.\n\n**The tree-walking interpreter is this teacher.** The **AST** is the structured, unambiguous representation of the student's homework. The **evaluator** is the step-by-step grading procedure, recursively descending into sub-expressions. The **environment** is the notebook of ledgers, tracking variable bindings across different scopes. This mental model captures the essence of interpretation: a meticulous, rule-governed walk through a tree of instructions, consulting and updating a memory of state along the way.\n\n### The Interpretation Problem\n\nFormally, the interpretation problem is: **Given a string of source code, produce the corresponding runtime behavior.** This involves several distinct sub-problems:\n\n1.  **Structural Disambiguation:** Source code is a linear sequence of characters. The interpreter must first resolve this into a hierarchical structure that explicitly represents nesting, precedence, and statement boundaries. This is the role of the **parser**, which produces the AST—a data structure our interpreter will walk. The AST is a static, immutable representation of the program's *syntax*.\n\n2.  **Semantic Evaluation:** Each node in the AST corresponds to a language construct with defined *semantics* (meaning). A literal number `42` means the numeric value forty-two. A `+` operator means the mathematical addition of its two operand values. The interpreter must implement the semantics for every type of node. This is not a simple translation; it involves **recursive computation**. To evaluate `a + b`, you must first evaluate the subtrees for `a` and `b`. This recursive evaluation is the \"tree-walking\" process.\n\n3.  **State Management:** The most complex aspect of interpretation is managing mutable, named state—**variables**. A program is not a pure function from input to output; it is a sequence of operations that read and write to memory. The interpreter must provide a mechanism to:\n    *   **Bind** a name to a value (`x = 10`).\n    *   **Look up** the value associated with a name when it is used (`print x + 1`).\n    *   **Re-bind** a name to a new value (`x = 20`).\n    *   **Scope** these bindings so that a variable defined inside a function does not leak out, and a variable defined outside a function is accessible within it (lexical scoping).\n\n    This is the domain of the **environment**, a runtime data structure that exists alongside and is manipulated by the evaluator. The design of the environment—how it models nesting, lookup, and assignment—is critical to implementing correct language semantics.\n\n4.  **Control Flow Management:** Programs are not linear. They branch with `if` statements, loop with `while` and `for`, and jump with `break`, `continue`, and `return`. The interpreter must orchestrate the order of evaluation, deciding which branch of the AST to walk down next based on computed conditions. This requires the evaluator to manage its own traversal path, not just compute values.\n\n5.  **Abstraction and Encapsulation:** Functions allow programmers to define reusable blocks of code. Interpreting a function call involves suspending the current execution context, creating a new isolated environment for the function's parameters and local variables, executing the function body, obtaining a result, and then resuming the original context. Supporting **closures**—where a function \"remembers\" the environment in which it was created—adds another layer of complexity to environment management.\n\nThe tree-walking interpreter tackles these sub-problems in a direct, intuitive way: write a recursive function that takes an AST node and an environment, and contains a large `switch` statement (or equivalent) to handle each node type. This approach shines in its conceptual clarity and closeness to the language specification, making it an ideal vehicle for learning. However, it is not the only architectural option, and its trade-offs must be understood.\n\n### Existing Approaches and Trade-offs\n\nWhen building an interpreter, the primary architectural decision is the choice of **intermediate representation (IR)**—the data structure that drives execution. The two most common patterns are the **Abstract Syntax Tree (AST) Walker**, which we have chosen, and the **Bytecode Virtual Machine (VM)**. A third, more advanced approach is **Just-In-Time (JIT) Compilation** to native machine code. The following table compares these approaches across dimensions critical to our learning project: implementation complexity, runtime performance, educational value, and flexibility.\n\n| Approach | Core Idea | How Execution Works | Key Data Structures |\n| :--- | :--- | :--- | :--- |\n| **AST Tree-Walker** | Directly interpret the parse tree. | A recursive function traverses the AST, evaluating nodes in post-order. | AST node hierarchy, Environment chain (stack of dictionaries). |\n| **Bytecode VM** | Compile the AST to a linear sequence of dense, simple instructions (bytecode). | A virtual CPU (interpreter loop) fetches and executes bytecode instructions, operating on a stack. | Bytecode array, Value stack, Constant pool, Frame stack. |\n| **JIT Compiler** | Dynamically compile \"hot\" code paths to optimized native machine code. | A runtime profiling system identifies hot loops/functions, a compiler generates machine code, and execution jumps to it. | Intermediate Representation (IR), Native code cache, Runtime profiling data. |\n\n> **Decision: Use an AST Tree-Walking Interpreter Architecture**\n> - **Context**: We are building an interpreter for an educational project with the primary goals of understanding core language implementation concepts (evaluation, environments, scoping, closures) and achieving a working system within an intermediate-level time frame.\n> - **Options Considered**:\n>     1.  **AST Tree-Walker**: Implement a recursive `evaluate` function that dispatches on AST node types.\n>     2.  **Bytecode Virtual Machine**: Build a compiler from AST to a custom bytecode, then implement a stack-based VM to run it.\n>     3.  **JIT Compilation (Theoretical)**: Use a library like LLVM to generate native code on the fly.\n> - **Decision**: We will implement an AST Tree-Walking Interpreter.\n> - **Rationale**:\n>     1.  **Conceptual Transparency**: The evaluator's logic maps directly to the language grammar. Seeing `evaluateIfStatement` handle an `If` node makes the connection between syntax and semantics obvious. There is no intermediate transformation to learn.\n>     2.  **Lower Initial Complexity**: A tree-walker can be built incrementally, feature by feature. Adding a new expression type often just means adding a new branch to the `evaluate` function. A VM requires designing an instruction set, a compiler, and the VM itself before any code runs.\n>     3.  **Focus on Language Semantics, Not Optimization**: Our goal is to learn about scoping, closures, and evaluation—not about bytecode design or register allocation. The tree-walker keeps the focus on these high-level semantics.\n>     4.  **Sufficient Performance for Learning**: While slower, a tree-walker's performance is adequate for running the small to medium-sized test programs typical in a learning project. The performance bottleneck is not a primary educational concern.\n> - **Consequences**:\n>     - **Positive**: We will have a clear, debuggable system where the runtime stack mirrors the AST structure. Stepping through the recursive evaluator with a debugger is an excellent learning tool.\n>     - **Negative**: The interpreter will be slower than a bytecode VM, especially for loop-heavy code, due to the overhead of tree traversal and repeated dispatch. It is not suitable for production performance needs.\n>     - **Neutral**: The design naturally supports dynamic features and metaprogramming but may require more careful design for complex control flow (e.g., `break`/`continue`).\n\nThe trade-offs between these approaches are summarized below:\n\n| Approach | Pros (Why choose it?) | Cons (Why avoid it?) | Best For |\n| :--- | :--- | :--- | :--- |\n| **AST Tree-Walker** | <ul><li>**Simple to implement and understand.** The code is a direct translation of language semantics.</li><li>**Fast to prototype.** New language features can be added with minimal boilerplate.</li><li>**Excellent for education.** The runtime structure (AST, environment chain) is visible and tangible.</li><li>**No separate compilation phase.** Execution begins immediately after parsing.</li></ul> | <ul><li>**Slow execution.** High overhead per operation due to tree traversal, recursion, and type dispatch.</li><li>**Poor cache locality.** AST nodes are typically heap-allocated objects scattered in memory.</li><li>**Hard to optimize.** Difficult to apply low-level optimizations common in VMs (e.g., stack-based operations, JIT).</li></ul> | **Learning projects, prototyping, scripting languages where simplicity is valued over raw speed (e.g., early versions of Ruby, PHP).** |\n| **Bytecode VM** | <ul><li>**Much faster execution.** Bytecode is dense, linear, and easy to cache; the interpreter loop is tight and efficient.</li><li>**Easier to optimize.** Enables classic compiler optimizations on bytecode and efficient stack-based operand management.</li><li>**Clear separation of concerns.** Compiler front-end (parsing, AST) is distinct from back-end (code gen, execution).</li><li>**Foundation for JIT.** Bytecode is a natural input for a JIT compiler.</li></ul> | <ul><li>**Higher complexity.** Requires designing an instruction set and building both a compiler *and* a VM.</li><li>**Indirect mapping.** The relationship between source code and bytecode is less obvious for debugging.</li><li>**Slower startup.** Requires a full compilation pass before any code runs.</li></ul> | **Production interpreters (e.g., CPython, Lua, the Java VM), where performance is critical.** |\n| **JIT Compilation** | <ul><li>**Highest performance.** Executes native machine code, can rival or exceed static compilation for dynamic languages.</li><li>**Advanced optimizations.** Can perform runtime profiling and specialization (e.g., type-specialized code, inlining).</li></ul> | <ul><li>**Extreme complexity.** Requires deep knowledge of compiler backends, instruction selection, and runtime systems.</li><li>**Large memory overhead.** Maintaining profiling data and multiple code versions consumes memory.</li><li>**\"Warm-up\" time.** Peak performance is only achieved after repeated execution of code paths.</li></ul> | **High-performance runtimes (e.g., JavaScript V8, Java HotSpot, PyPy) where execution speed is paramount.** |\n\nGiven our project's goals—**learning** the fundamentals of interpreters, **completing** a working system at an intermediate difficulty level, and **understanding** environments and closures—the AST tree-walking approach offers the optimal balance of pedagogical value and implementability. It allows us to focus on the core challenge: managing dynamic runtime state through the environment model, which is elegantly visualized in the system component diagram.\n\n![System Component Diagram](./diagrams/sys-component.svg)\n\nAs shown, the **Evaluator** component is the heart of the system. It reads the static program structure from the **AST** and interacts with the dynamic **Environment Chain** to read and update variable state. This clear separation of concerns—syntax, evaluation logic, and runtime state—forms the backbone of our design. The subsequent sections will delve into the detailed design of each component, starting with the data model for runtime values and environments.\n\n\n## Goals and Non-Goals\n> **Milestone(s):** 1, 2, 3, 4\n\nThis section establishes the explicit boundaries of the interpreter project. A clearly defined scope prevents feature creep and ensures focused effort on the core learning objectives: understanding tree-walking evaluation, lexical scoping, and function execution. We delineate what the interpreter **must** do to be considered complete versus what it **explicitly will not** implement, even if such features are common in production languages.\n\n### Goals (What we must implement)\n\nThe interpreter's primary purpose is pedagogical—to provide a hands-on understanding of language implementation fundamentals through a complete, working example. The following capabilities represent the minimum feature set required to demonstrate the core concepts.\n\n> **Design Principle: Completeness over Complexity**\n> The interpreter should implement a *coherent subset* of language features that interact meaningfully, rather than many shallow features. Each implemented feature must correctly integrate with the evaluation model, scoping rules, and control flow.\n\n1.  **Expression Evaluation**\n    The interpreter must evaluate all basic expressions, forming the foundation for every computation. This includes:\n    *   **Literal values**: Direct evaluation of numbers (integers and floats), strings, booleans (`true`, `false`), and the `nil` value representing absence.\n    *   **Arithmetic operations**: Binary operators for addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`), with proper operator precedence and support for unary negation (`-`).\n    *   **Comparison and equality**: Operators for relative comparison (`<`, `>`, `<=`, `>=`) and equality (`==`, `!=`), returning boolean results.\n    *   **Logical operators**: Support for `and` and `or` with **short-circuit evaluation**, where the right operand is only evaluated if the left operand doesn't determine the result.\n    *   **Grouping**: Parentheses `()` must override default precedence, requiring correct handling of nested expression trees.\n\n2.  **Variables and Lexical Scoping**\n    The interpreter must support named storage locations whose visibility follows **lexical (static) scoping** rules.\n    *   **Variable declaration**: A statement (e.g., `var x = 5;`) that introduces a new name into the current scope, binding it to an initial value.\n    *   **Variable assignment**: An expression (e.g., `x = 10;`) that updates the value of an existing variable, searching outward through enclosing scopes.\n    *   **Variable lookup**: Reading a variable's value by its name, resolving it by searching the current environment, then its parent, recursively.\n    *   **Nested block scopes**: Code blocks (e.g., inside `{ }`) create new nested scopes. Variables declared inside a block shadow outer ones and are inaccessible after the block exits.\n\n3.  **Control Flow**\n    The interpreter must direct the path of execution based on conditions and loops.\n    *   **Conditional execution**: An `if` statement that evaluates a condition and executes one branch or another. An `else` clause must be optional.\n    *   **Looping constructs**:\n        *   `while` loops that repeatedly execute a body while a condition remains truthy.\n        *   `for` loops (converted/desugared into `while` loops) with an initializer, condition, and increment expression.\n    *   **Loop control**: `break` to exit the nearest enclosing loop immediately, and `continue` to skip to the next iteration.\n    *   **Truthiness**: A consistent rule set for determining if a non-boolean value (like `0`, `\"\"`, or `nil`) counts as `true` or `false` in conditional contexts.\n\n4.  **First-Class Functions and Closures**\n    Functions must be **first-class values** that can be stored, passed, and returned, with proper support for **lexical closures**.\n    *   **Function definition**: A declaration (e.g., `fun add(a, b) { return a + b; }`) that creates a function object and binds it to a name.\n    *   **Function calls**: Invocation syntax (e.g., `add(1, 2)`) that evaluates arguments, creates a new local environment for parameters, and executes the body.\n    *   **Return mechanism**: A `return` statement that terminates function execution and provides a value back to the caller, even from nested blocks.\n    *   **Closure capture**: When a function is defined, it must capture a reference to its *defining* environment, allowing it to access variables from outer scopes even after those scopes have exited.\n    *   **Recursion**: Functions must be able to call themselves by name, requiring the function's name to be bound in its own local environment.\n\nThe successful implementation of these four pillars creates a Turing-complete, dynamically-typed language with lexical scope—a significant and educationally complete achievement.\n\n### Non-Goals (What we explicitly omit)\n\nTo maintain focus on the core learning objectives and avoid project sprawl, we deliberately exclude several common language features and implementation optimizations. These are valuable topics but belong to more advanced study.\n\n| Feature Category | Specific Omissions | Rationale for Exclusion |\n| :--- | :--- | :--- |\n| **Memory Management** | Automatic garbage collection, reference counting. | Adds significant complexity (tracing, cycle detection) and is orthogonal to the evaluation model. The interpreter can rely on the host language's garbage collector for its own data structures. |\n| **Modularity** | Modules, imports, separate compilation units, `include` statements. | Introduces file I/O, dependency resolution, and global namespace management. The interpreter evaluates a single program text. |\n| **Object-Oriented Programming** | Classes, inheritance, prototypes, `this`/`self` context, methods. | Represents a major paradigm with distinct dispatch semantics (late binding, inheritance chains) that would double the project's scope. |\n| **Advanced Types** | Static type checking, user-defined types, type annotations, generics. | The interpreter is dynamically typed for simplicity. Type systems are a deep, separate subject area. |\n| **Optimization** | Just-In-Time (JIT) compilation, tail-call optimization (TCO), bytecode compilation, constant folding. | These are performance optimizations that obscure the clear tree-walking algorithm. The goal is clarity of semantics, not speed. |\n| **Standard Library** | Built-in functions for I/O (print, read), mathematics (sin, sqrt), data structures (arrays, maps), system interaction. | While useful, a standard library is a large addition. A single `print` statement may be added for debugging, but extensive libraries are out of scope. |\n| **Error Recovery & Debugging** | Stack traces, line number reporting in errors, debugger integration, REPL history. | Basic error detection (e.g., \"Undefined variable 'x'\") is required, but sophisticated tooling is a project in itself. |\n| **Concurrency** | Threads, async/await, promises, coroutines, parallelism. | Concurrency introduces entirely new dimensions of complexity (race conditions, schedulers) far beyond the sequential evaluation model. |\n| **Syntax Sugar** | Increment/decrement operators (`++`, `--`), assignment operators (`+=`, `-=`), ternary operator (`?:`), switch statements. | These can be desugared into existing constructs and do not introduce new semantic concepts. |\n| **Metaprogramming** | Macros, reflection, eval at runtime. | These features fundamentally change the evaluation model (code-as-data) and require a more sophisticated interpreter architecture. |\n\n> **Architectural Decision: Focused Pedagogical Scope**\n> **Context**: The project aims to teach core interpreter concepts within a limited timeframe. Every additional feature increases implementation complexity and cognitive load for the learner.\n> **Options Considered**:\n> 1.  **Minimal Core**: Implement only the essential features listed in Goals.\n> 2.  **Expressive Language**: Add commonly requested features like arrays, a basic standard library, and classes.\n> 3.  **Extensible Framework**: Build a minimal core with plug-in points for optional features.\n> **Decision**: Adopt the **Minimal Core** approach.\n> **Rationale**: The primary success criterion is a deep understanding of tree-walking evaluation, environments, and closures. A minimal, complete implementation achieves this without distraction. Additional features can be built as separate, advanced projects once fundamentals are mastered.\n> **Consequences**: The interpreter will feel \"spartan\" compared to production languages, but it will be fully functional for algorithms, recursion, and closure-based abstraction. Learners can confidently extend it later using the same architectural patterns.\n\nThis explicit list of non-goals serves as a guardrail. When encountering a potential feature not listed above (e.g., \"should we add arrays?\"), the answer is \"not in this version.\" The design document's subsequent sections assume this bounded scope.\n\n### Implementation Guidance\n\n#### Technology Recommendations Table\nFor this project, the technology stack is intentionally simple, focusing on the host language's standard data structures and control flow.\n\n| Component | Simple Option (Recommended) | Advanced Option (Optional) |\n| :--- | :--- | :--- |\n| **Runtime Value Representation** | Built-in Python/JS/Java types (`int`, `str`, `bool`, `None`/`null`). | Custom `Value` class hierarchy with explicit type tags. |\n| **Environment Storage** | Dictionary/HashMap for the store, with a parent reference. | Persistent data structures for environment snapshots (useful for advanced debugging). |\n| **Control Flow Jump (break/continue/return)** | Python exceptions, JS `throw` with custom error types, Java custom exceptions. | Explicit `Result` object returned from every evaluation, carrying a value or jump signal. |\n| **Function Representation** | Plain class/object storing parameters, body AST, and closure environment. | Compiling to host-language closures (advanced, blends semantics). |\n\n#### Recommended File/Module Structure\nOrganizing code into logical modules improves readability and mirrors the separation of concerns in the design.\n\n```\ntreewalk_interpreter/\n├── ast.py               # AST node class definitions (from previous parser milestone)\n├── evaluator.py         # Core Evaluator class (handles expression/statement evaluation)\n├── environment.py       # Environment class (variable storage and scoping)\n├── runtime_values.py    # Runtime value definitions (Function, maybe built-in callables)\n├── errors.py            # Custom runtime error types (RuntimeError, UndefinedVariable, etc.)\n├── interpreter.py       # Main entry point: parses source and runs evaluator\n└── test_interpreter.py  # Comprehensive test suite\n```\n\n#### Infrastructure Starter Code: Runtime Error Types\nProper error handling is crucial for debugging. These custom exception classes provide clear, actionable error messages.\n\n**File: `errors.py`**\n```python\n\"\"\"\nCustom runtime error types for the tree-walking interpreter.\nAll errors include the token (or line number) for context.\n\"\"\"\n\nclass RuntimeError(Exception):\n    \"\"\"Base class for all runtime errors.\"\"\"\n    def __init__(self, message, token=None):\n        super().__init__(message)\n        self.message = message\n        self.token = token\n\n    def __str__(self):\n        if self.token:\n            return f\"[line {self.token.line}] RuntimeError: {self.message}\"\n        return f\"RuntimeError: {self.message}\"\n\n\nclass UndefinedVariableError(RuntimeError):\n    \"\"\"Raised when trying to access a variable that is not defined.\"\"\"\n    def __init__(self, variable_name, token):\n        super().__init__(f\"Undefined variable '{variable_name}'.\", token)\n\n\nclass TypeError(RuntimeError):\n    \"\"\"Raised when an operation is applied to an incompatible type.\"\"\"\n    def __init__(self, message, token):\n        super().__init__(message, token)\n\n\nclass DivisionByZeroError(RuntimeError):\n    \"\"\"Raised on division by zero.\"\"\"\n    def __init__(self, token):\n        super().__init__(\"Division by zero.\", token)\n\n\nclass ArgumentError(RuntimeError):\n    \"\"\"Raised on function call argument mismatch.\"\"\"\n    def __init__(self, expected, got, token):\n        super().__init__(f\"Expected {expected} arguments but got {got}.\", token)\n\n\nclass ControlFlowSignal(Exception):\n    \"\"\"\n    Base for non-local jumps (break, continue, return).\n    These are caught by loop/function evaluators.\n    \"\"\"\n    pass\n\n\nclass BreakSignal(ControlFlowSignal):\n    \"\"\"Signals a 'break' statement.\"\"\"\n    pass\n\n\nclass ContinueSignal(ControlFlowSignal):\n    \"\"\"Signals a 'continue' statement.\"\"\"\n    pass\n\n\nclass ReturnSignal(ControlFlowSignal):\n    \"\"\"Signals a 'return' statement. Carries the return value.\"\"\"\n    def __init__(self, value):\n        super().__init__()\n        self.value = value\n```\n\n#### Core Logic Skeleton: Main Interpreter Entry Point\nThe main entry point ties together the parser (from a previous milestone) and the evaluator.\n\n**File: `interpreter.py`**\n```python\n\"\"\"\nMain interpreter entry point.\nAssumes an existing parser that produces an AST from source code.\n\"\"\"\n\nimport sys\nfrom ast import Program  # Assume this is the root AST node from parser\nfrom evaluator import Evaluator\nfrom environment import Environment\nfrom errors import RuntimeError\n\nclass Interpreter:\n    def __init__(self):\n        self.evaluator = Evaluator()\n        self.global_env = Environment()  # The outermost environment\n\n    def interpret(self, source_code: str):\n        \"\"\"\n        Parse and execute the given source code.\n        \n        Steps:\n        1. Parse source_code into an AST (using existing parser).\n        2. Evaluate the AST with the global environment.\n        3. Print any result (if the program is an expression).\n        4. Catch and report runtime errors.\n        \"\"\"\n        # TODO 1: Call your existing parser to convert source_code to an AST.\n        #   The parser should return a Program node (or a list of statements).\n        #   For now, we assume `parse(source_code)` exists.\n        #   Example: ast_root = parse(source_code)\n        ast_root = None  # Placeholder\n\n        try:\n            # TODO 2: Evaluate the program AST starting from the global environment.\n            #   The evaluator's evaluate method should be called on the root node.\n            result = self.evaluator.evaluate(ast_root, self.global_env)\n            \n            # TODO 3: If the result is not None (i.e., the program was an expression),\n            #   print it for user visibility, mimicking a REPL.\n            if result is not None:\n                print(self._stringify(result))\n                \n        except RuntimeError as e:\n            # TODO 4: Report runtime errors to the user with line information.\n            print(e, file=sys.stderr)\n            # Optionally, set an error flag or exit code.\n            return False\n        \n        return True\n\n    def _stringify(self, value) -> str:\n        \"\"\"Convert a runtime value to a readable string.\"\"\"\n        if value is None:\n            return \"nil\"\n        if isinstance(value, bool):\n            return str(value).lower()\n        if isinstance(value, float):\n            # Show integer values without decimal if possible\n            text = str(value)\n            if text.endswith('.0'):\n                text = text[:-2]\n            return text\n        # For strings, numbers, etc.\n        return str(value)\n\n\nif __name__ == \"__main__\":\n    # Simple REPL or file execution\n    interpreter = Interpreter()\n    if len(sys.argv) == 1:\n        # REPL mode\n        print(\"Tree-walking interpreter (exit with Ctrl+D)\")\n        while True:\n            try:\n                line = input(\"> \")\n                interpreter.interpret(line)\n            except EOFError:\n                print(\"\\nGoodbye!\")\n                break\n            except KeyboardInterrupt:\n                print(\"\\nInterrupted.\")\n                continue\n    else:\n        # File mode: read and execute the entire file\n        with open(sys.argv[1], 'r') as f:\n            source = f.read()\n        success = interpreter.interpret(source)\n        sys.exit(0 if success else 1)\n```\n\n#### Language-Specific Hints\n*   **Python**: Use `isinstance()` for runtime type checks. Be careful with `None` (use `is`/`is not` for identity). The `math.isclose()` function is better for floating-point equality than `==`.\n*   **JavaScript**: Use `===` for equality to avoid type coercion. `undefined` can serve as `nil`. Use `Map` or plain objects for environment stores.\n*   **Java**: Define an abstract `Value` class or use `Object` references with careful casting. Use `HashMap<String, Object>` for environment stores.\n\n#### Milestone Checkpoint\nAfter reading this section, before writing any code, you should be able to articulate the exact boundaries of your project.\n\n**Verification Questions:**\n1.  Will your interpreter support `for` loops? (Yes, as a desugared form)\n2.  Will your interpreter support arrays and hash maps? (No, non-goal)\n3.  Will your interpreter automatically free unused memory? (No, relies on host GC)\n4.  Will your interpreter support defining functions inside other functions? (Yes, and they must correctly capture closures)\n\nA correct understanding of these boundaries will guide all subsequent implementation decisions.\n\n#### Debugging Tips\nEarly mis-scoping is a common source of subtle bugs.\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n| :--- | :--- | :--- | :--- |\n| Variable is `nil` when it should have a value. | Variable was declared in an inner scope and is not visible where accessed. | Print the environment chain during lookup. Check if the variable's name exists in any parent environment. | Ensure variable is declared in a scope that encloses all usage points. |\n| Changing a variable inside a function doesn't affect the outer variable. | Assignment is creating a new local binding instead of updating the outer one. | Trace the `assign` method in the environment. Is it walking the parent chain? | Implement assignment to search through the environment chain, not just the current environment. |\n| Function cannot access variables from its defining scope. | Closure environment was not captured or is incorrectly set as parent. | Print the function's closure environment when created and when called. | Store the *defining* environment as the function's closure, not the global environment. |\n\n\n## High-Level Architecture\n> **Milestone(s):** 1, 2, 3, 4  \n> This section provides the architectural blueprint for the entire interpreter system. Understanding this component breakdown and data flow is essential before diving into implementation details for any specific milestone.\n\nThe AST tree-walking interpreter follows a classic three-tier architecture that cleanly separates static program structure from dynamic runtime execution. This design enables straightforward implementation of lexical scoping, function calls, and control flow while maintaining conceptual clarity—critical for an educational project. The architecture centers on three core components that interact through well-defined interfaces.\n\n### Component Overview\n\nThink of the interpreter as a **theater production**:\n- The **AST Nodes** are the script—a static, structured document containing all the dialogue and stage directions\n- The **Evaluator** is the director—reading the script and instructing actors on what to do next\n- The **Environment Chain** is the stage with multiple backdrops—each scene (scope) has its own props (variables), and actors can look for props on the current stage or behind it in previous scenes\n\nThis metaphor captures the essence: the script doesn't change during performance (AST is immutable), the director follows the script step-by-step (recursive evaluation), and the stage setup evolves as scenes change (environments track runtime state).\n\nThe three architectural pillars are:\n\n| Component | Primary Responsibility | Key Data Structures | Statefulness |\n|-----------|------------------------|---------------------|--------------|\n| **AST (Abstract Syntax Tree)** | Represents the program's syntactic structure as a hierarchy of nodes | `LiteralNode`, `BinaryNode`, `VariableNode`, `IfNode`, `FunctionNode`, etc. | Immutable (parsed once, never modified) |\n| **Evaluator** | Recursively traverses AST nodes, executing their semantics | `evaluate()` function with node-type dispatch logic, maintains current execution context | Stateless per call (receives environment as parameter) |\n| **Environment Chain** | Manages variable storage with lexical scoping via parent links | `Environment` objects with `store` dictionary and `parent` reference | Mutable (bindings change during execution) |\n\nThese components interact in a specific data flow pattern: the Evaluator reads instructions from the AST and reads/writes variable state from/to the current Environment. Environments themselves form a linked chain that mirrors the program's lexical structure. \n\n![System Component Diagram](./diagrams/sys-component.svg)\n\n#### AST: The Static Blueprint\nThe AST serves as the interpreter's immutable source of truth about program structure. Each node type encapsulates a specific language construct with fields representing its components:\n\n| AST Node Category | Example Node Types | Key Fields (per node type) | Runtime Semantics |\n|-------------------|-------------------|----------------------------|-------------------|\n| Expressions (produce values) | `LiteralNode`, `BinaryNode`, `UnaryNode`, `VariableNode`, `CallNode` | `value` (for literals), `left`/`right` (for binary), `operator`, `operand` | Evaluate to a runtime value |\n| Statements (produce effects) | `ExpressionStmtNode`, `VarDeclNode`, `BlockNode`, `IfNode`, `WhileNode` | `expression`, `identifier`, `body`, `condition`, `thenBranch`/`elseBranch` | Execute side effects, control flow |\n| Declarations | `FunctionDeclNode` | `name`, `parameters`, `body` | Create bindings in environment |\n\nThe AST is generated once by the parser and remains unchanged throughout execution. This immutability is crucial—it means the same AST can be evaluated multiple times with different environments (as in function calls) without interference.\n\n#### Evaluator: The Recursive Director\nThe Evaluator implements the tree-walking algorithm—a depth-first, recursive traversal of the AST that executes operations in the correct order. Its core design follows the **Interpreter Pattern** from design patterns literature, where each AST node type has a corresponding evaluation method. The Evaluator maintains no persistent state of its own; instead, it receives the current `Environment` as a parameter and returns runtime values or control flow signals.\n\nThe Evaluator's key characteristic is **single-threaded, synchronous execution**—it processes one node at a time, completely finishing its evaluation before moving to siblings. This simplifies reasoning about program behavior but imposes the performance limitations typical of tree-walkers.\n\n#### Environment Chain: The Layered Storage\nThe Environment system implements lexical (static) scoping through a chain of binding tables. Each `Environment` represents one scope level (global, function, block) and links to its parent scope. This creates a dynamic runtime structure that mirrors the program's static nesting:\n\n| Scope Type | Created When | Parent Environment | Typical Lifespan |\n|------------|--------------|-------------------|------------------|\n| Global | Interpreter initialization | `None` (end of chain) | Entire program execution |\n| Function | Function call | The closure environment (where function was defined) | Duration of function call |\n| Block | Entering `{}` blocks, control flow bodies | The enclosing environment | Duration of block execution |\n\nThe chain structure enables variable lookup to follow lexical rules: search starts in the current environment and proceeds up the parent chain until the variable is found or the global scope is reached. This design naturally supports variable shadowing—inner scopes can redefine names that hide outer definitions.\n\n> **Key Insight:** The separation between immutable AST and mutable Environments is what enables powerful language features like recursion and closures. Multiple function calls create new Environments but share the same function body AST, allowing efficient reuse of code structure while maintaining independent variable instances.\n\n### Execution Flow\n\nThe interpreter follows a linear pipeline from source code to execution result. Understanding this flow clarifies how components hand off responsibilities at each stage:\n\n```mermaid\nflowchart TD\n    A[Source Code String] --> B[Parser]\n    B --> C[AST Root Node]\n    C --> D[Interpreter.interpret]\n    D --> E[Create Global Environment]\n    E --> F[Evaluator.evaluate<br/>root, global_env]\n    F --> G{Node Type?}\n    G --> H[Expression]\n    G --> I[Statement]\n    H --> J[Return Runtime Value]\n    I --> K[Execute Side Effects]\n    J --> L[Final Result]\n    K --> L\n```\n\n#### Step-by-Step Processing Pipeline\n\n1. **Source Input**\n   - The interpreter receives a string containing program source code\n   - Example: `\"var x = 5; print x + 3;\"`\n\n2. **Parsing Phase** (outside interpreter proper but prerequisite)\n   - The parser (lexer + syntax analyzer) converts the source string into an AST\n   - Syntax validation occurs here—malformed programs fail before evaluation begins\n   - The parser produces a root node (typically a `ProgramNode` containing statement list)\n\n3. **Initialization**\n   - The `Interpreter` class creates the initial `global_env` (empty Environment with no parent)\n   - Any built-in functions (like `print`, `clock`) are defined in this global environment\n\n4. **Evaluation Dispatch**\n   - The interpreter calls `evaluate(root_node, global_env)` to begin execution\n   - The Evaluator examines the node type and dispatches to the appropriate handler method\n\n5. **Recursive Tree Traversal**\n   - For each node, the Evaluator recursively evaluates child nodes as needed\n   - Expression evaluation flows upward: leaves (literals/variables) → internal nodes → root\n   - Statement execution proceeds sequentially with potential jumps (loops, returns)\n\n6. **Environment Interaction**\n   - Variable lookups: `evaluate(VariableNode)` calls `environment.get(name)`\n   - Assignments: `evaluate(AssignNode)` calls `environment.assign(name, value)`\n   - New scopes: Block execution creates a child Environment with current as parent\n\n7. **Result Propagation**\n   - Expression evaluation returns a runtime value to its parent node\n   - Statement evaluation typically returns `None` (except return statements)\n   - The final value of the program is the value of the last expression evaluated\n\n8. **Error Handling**\n   - Runtime errors (type mismatches, undefined variables) halt evaluation\n   - The interpreter reports the error with location information from the AST node's token\n   - No recovery attempted—program execution stops\n\n#### Phase Separation: Parse vs. Evaluate\nA critical architectural decision is maintaining strict separation between parsing and evaluation phases:\n\n| Phase | Input | Output | Error Types | When Occur |\n|-------|-------|--------|-------------|------------|\n| **Parsing** | Source code string | AST nodes | Syntax errors, parse errors | Before any execution |\n| **Evaluation** | AST nodes + Environment | Runtime values + side effects | Runtime errors, type errors | During program execution |\n\nThis separation provides several benefits:\n- **Single parse, multiple executions**: The AST can be evaluated repeatedly (useful for REPLs or loops)\n- **Clear error categorization**: Users get distinct feedback for syntax vs. logic errors\n- **Testing simplicity**: ASTs can be constructed programmatically for unit tests\n- **Potential optimization**: The AST could be optimized/transformed before evaluation\n\n> **Design Principle:** The interpreter follows a \"parse completely, then execute\" model rather than \"parse and execute interleaved.\" This ensures all syntax errors are caught before any code runs, providing better developer experience.\n\n#### Control Flow and Unwinding\nSpecial handling is required for control flow statements that break the linear recursion:\n\n1. **Conditionals (`if/else`)**\n   - Evaluate condition expression to boolean (with truthiness conversion)\n   - Execute only the chosen branch, skipping the other entirely\n\n2. **Loops (`while`, `for`)**\n   - Create a loop execution context that can intercept `break`/`continue`\n   - Repeatedly evaluate condition and body until condition becomes falsey\n\n3. **Function Calls**\n   - Create new Environment with closure as parent\n   - Bind parameters to argument values\n   - Execute function body, catching `return` signals to unwind\n\n4. **Return Statements**\n   - Use a non-local exit mechanism (exception/sentinel) to propagate return values up through nested calls\n\nThis control flow management requires the Evaluator to be aware of context—whether it's evaluating an expression (must return value) or statement (may trigger jumps).\n\n### Recommended File Structure\n\nA well-organized codebase significantly reduces implementation complexity. The following structure separates concerns logically, making the system easier to understand, test, and extend:\n\n```\ntree_walker_interpreter/\n├── __init__.py\n├── interpreter.py              # Main Interpreter class, entry point\n├── evaluator.py               # Core Evaluator class with dispatch logic\n├── environment.py             # Environment class and scope management\n├── runtime_values.py          # Runtime value representations\n├── errors.py                  # Runtime error classes and handling\n├── control_flow.py            # Break/Continue/Return signal classes\n│\n├── ast/                       # AST node definitions (from parser)\n│   ├── __init__.py\n│   ├── nodes.py               # Base Node class and all concrete node types\n│   └── visitor.py             # Optional: Visitor pattern infrastructure\n│\n├── builtins/                  # Standard library functions\n│   ├── __init__.py\n│   └── functions.py           # print(), clock(), etc.\n│\n└── tests/                     # Test suite organized by milestone\n    ├── __init__.py\n    ├── test_expressions.py    # Milestone 1: Expression evaluation\n    ├── test_variables.py      # Milestone 2: Variables and scoping\n    ├── test_control_flow.py   # Milestone 3: Conditionals and loops\n    └── test_functions.py      # Milestone 4: Functions and closures\n```\n\n#### Module Responsibilities and Dependencies\n\n| Module | Primary Exports | Dependencies | Used By |\n|--------|----------------|--------------|---------|\n| `interpreter.py` | `Interpreter` class with `interpret()` method | `evaluator`, `environment`, `builtins`, `errors` | End-user API, REPL |\n| `evaluator.py` | `Evaluator` class with `evaluate()` method | `environment`, `runtime_values`, `control_flow`, `errors`, `ast.nodes` | `interpreter`, test suites |\n| `environment.py` | `Environment` class, `UndefinedVariableError` | `errors` | `evaluator`, `interpreter` |\n| `runtime_values.py` | `RuntimeValue` base, `NumberValue`, `StringValue`, `BooleanValue`, `NilValue`, `FunctionValue` | (none) | `evaluator`, `environment`, `builtins` |\n| `errors.py` | `RuntimeError`, `TypeError`, `DivisionByZeroError`, `ArgumentError` | `ast.nodes` (for token) | All modules |\n| `control_flow.py` | `ControlFlowSignal`, `BreakSignal`, `ContinueSignal`, `ReturnSignal` | `runtime_values` | `evaluator` |\n| `ast/nodes.py` | All AST node classes (`LiteralNode`, `BinaryNode`, etc.) | (none) | `evaluator`, parser, tests |\n| `builtins/functions.py` | Built-in function implementations | `runtime_values` | `interpreter` (initialization) |\n\nThis structure enforces clear boundaries:\n- **AST module** contains only data definitions, no logic\n- **Evaluator** contains all execution logic but no storage\n- **Environment** contains all storage logic but no execution\n- **Errors** centralizes all error types for consistent handling\n\n#### Import Strategy to Avoid Circular Dependencies\nThe dependency graph must remain acyclic. Follow these import rules:\n\n1. **AST nodes** import nothing from other interpreter modules\n2. **Runtime values** import nothing (base types only)\n3. **Environment** imports only `errors`\n4. **Evaluator** imports everything else as needed\n5. **Interpreter** imports all components\n\nIf using a visitor pattern, the `ast/visitor.py` would define the visitor interface, which `evaluator.py` would implement. This adds indirection but provides cleaner separation.\n\n> **Implementation Tip:** Use Python's `__all__` in each module's `__init__.py` to control what gets exported. This prevents internal helper classes from leaking into the public API and keeps imports clean.\n\n#### Configuration and Entry Points\nFor different usage scenarios, provide multiple entry points:\n\n```python\n# Direct API usage\nfrom tree_walker_interpreter import Interpreter\ninterpreter = Interpreter()\nresult = interpreter.interpret(\"print 'Hello, World!';\")\n\n# REPL mode\npython -m tree_walker_interpreter.repl\n\n# File execution\npython -m tree_walker_interpreter.run path/to/script.tl\n\n# Test runner\npython -m pytest tests/ -v\n```\n\nThis modular structure scales well as features are added. Each milestone naturally maps to specific modules:\n- **Milestone 1**: Implement `evaluator.py` for expressions\n- **Milestone 2**: Implement `environment.py` and extend `evaluator.py` for variables\n- **Milestone 3**: Extend `evaluator.py` with control flow, add `control_flow.py`\n- **Milestone 4**: Implement `runtime_values.py` for functions, extend all components\n\nThe separation also enables incremental testing—you can test the Environment class independently before integrating it with the Evaluator.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Recommended) | Advanced Option (Alternative) |\n|-----------|-----------------------------|-------------------------------|\n| **AST Representation** | Plain Python classes with fields | Dataclasses (`@dataclass`) or namedtuples |\n| **Node Type Dispatch** | if-elif chain in `evaluate()` | Visitor pattern with double dispatch |\n| **Environment Chain** | Linked list of dict wrappers | Flat array with static distance indexing |\n| **Runtime Values** | Python native types (int, str, bool, None) | Wrapper classes with type tags |\n| **Error Propagation** | Python exceptions | Return value with error flag (Result type) |\n| **Control Flow Signals** | Python exceptions for break/continue/return | State flag in Evaluator context object |\n\nFor this educational project, the Simple Options are strongly recommended—they minimize cognitive overhead and let learners focus on the interpreter concepts rather than Python patterns.\n\n#### B. Recommended File Structure Implementation\n\nCreate the following files with their basic skeletons:\n\n**`tree_walker_interpreter/__init__.py`:**\n```python\n\"\"\"\nAST Tree-Walking Interpreter - Educational Implementation\n\"\"\"\n\nfrom .interpreter import Interpreter\nfrom .errors import RuntimeError, TypeError, UndefinedVariableError\n\n__version__ = \"0.1.0\"\n__all__ = [\"Interpreter\", \"RuntimeError\", \"TypeError\", \"UndefinedVariableError\"]\n```\n\n**`tree_walker_interpreter/interpreter.py`:**\n```python\n\"\"\"\nMain interpreter entry point and public API.\n\"\"\"\n\nfrom typing import Any, Optional\nfrom .evaluator import Evaluator\nfrom .environment import Environment\nfrom .builtins.functions import create_global_environment\nfrom .errors import RuntimeError\n\n\nclass Interpreter:\n    \"\"\"Main interpreter class providing the public interpret() method.\"\"\"\n    \n    def __init__(self):\n        self.evaluator = Evaluator()\n        self.global_env = create_global_environment()\n    \n    def interpret(self, source_code: str) -> bool:\n        \"\"\"\n        Parse and execute source code.\n        \n        Args:\n            source_code: The program source as a string\n            \n        Returns:\n            True if execution completed successfully, False if a runtime error occurred\n            \n        Raises:\n            SyntaxError: If the source code has syntax errors (from parser)\n        \"\"\"\n        # TODO: Integrate with parser when available\n        # For now, we'll assume AST is passed differently for testing\n        pass\n    \n    def _stringify(self, value: Any) -> str:\n        \"\"\"\n        Convert a runtime value to a display string.\n        \n        Args:\n            value: Any runtime value (number, string, boolean, nil, function)\n            \n        Returns:\n            String representation for output\n        \"\"\"\n        if value is None:\n            return \"nil\"\n        if isinstance(value, bool):\n            return str(value).lower()\n        if callable(value):  # Function value\n            return \"<fn>\"\n        return str(value)\n```\n\n**`tree_walker_interpreter/environment.py`:**\n```python\n\"\"\"\nEnvironment chain for lexical scoping.\n\"\"\"\n\nfrom typing import Any, Optional, Dict\nfrom .errors import UndefinedVariableError\n\n\nclass Environment:\n    \"\"\"\n    Maps variable names to values with support for nested scopes via parent chain.\n    \n    Attributes:\n        store: Dictionary of name -> value bindings in this scope\n        parent: Parent environment for variable lookup chain (None for global)\n    \"\"\"\n    \n    def __init__(self, parent: Optional['Environment'] = None):\n        self.store: Dict[str, Any] = {}\n        self.parent = parent\n    \n    def define(self, name: str, value: Any) -> None:\n        \"\"\"\n        Create a new variable binding in the current environment.\n        \n        Args:\n            name: Variable name\n            value: Initial value\n            \n        Note:\n            This always creates binding in current environment, even if name\n            exists in parent scope (shadowing).\n        \"\"\"\n        # TODO: Implement variable definition\n        pass\n    \n    def get(self, name: str) -> Any:\n        \"\"\"\n        Retrieve a variable's value by walking the environment chain.\n        \n        Args:\n            name: Variable name to look up\n            \n        Returns:\n            The value bound to this name\n            \n        Raises:\n            UndefinedVariableError: If name is not found in any environment\n        \"\"\"\n        # TODO: Implement chain lookup\n        pass\n    \n    def assign(self, name: str, value: Any) -> None:\n        \"\"\"\n        Update an existing variable's value in the nearest enclosing scope.\n        \n        Args:\n            name: Variable name to assign to\n            value: New value\n            \n        Raises:\n            UndefinedVariableError: If name is not defined in any environment\n        \"\"\"\n        # TODO: Implement assignment with scope walking\n        pass\n```\n\n**`tree_walker_interpreter/errors.py`:**\n```python\n\"\"\"\nRuntime error classes for the interpreter.\n\"\"\"\n\n\nclass RuntimeError(Exception):\n    \"\"\"Base class for all runtime errors.\"\"\"\n    \n    def __init__(self, message: str, token=None):\n        super().__init__(message)\n        self.message = message\n        self.token = token\n    \n    def __str__(self):\n        if self.token:\n            return f\"[Line {self.token.line}] RuntimeError: {self.message}\"\n        return f\"RuntimeError: {self.message}\"\n\n\nclass UndefinedVariableError(RuntimeError):\n    \"\"\"Raised when accessing an undefined variable.\"\"\"\n    pass\n\n\nclass TypeError(RuntimeError):\n    \"\"\"Raised when operations are applied to incompatible types.\"\"\"\n    pass\n\n\nclass DivisionByZeroError(RuntimeError):\n    \"\"\"Raised when dividing by zero.\"\"\"\n    pass\n\n\nclass ArgumentError(RuntimeError):\n    \"\"\"Raised when function is called with wrong number of arguments.\"\"\"\n    pass\n```\n\n**`tree_walker_interpreter/runtime_values.py`:**\n```python\n\"\"\"\nRuntime value representations and type utilities.\n\"\"\"\n\nfrom typing import Any, List, Optional\nfrom .environment import Environment\n\n\n# For Milestone 4:\nclass FunctionValue:\n    \"\"\"\n    Runtime representation of a user-defined function.\n    \n    Attributes:\n        name: Function name (or None for anonymous/lambda)\n        parameters: List of parameter names\n        body: The function body AST node\n        closure: Environment captured when function was defined\n    \"\"\"\n    \n    def __init__(self, name: Optional[str], parameters: List[str], body, closure: Environment):\n        self.name = name\n        self.parameters = parameters\n        self.body = body\n        self.closure = closure\n    \n    def call(self, arguments: List[Any]) -> Any:\n        \"\"\"Execute the function with given arguments.\"\"\"\n        # TODO: Implement in Milestone 4\n        pass\n    \n    def __str__(self):\n        if self.name:\n            return f\"<fn {self.name}>\"\n        return \"<anonymous fn>\"\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete parser integration helper** (when parser is available):\n\n```python\n# tree_walker_interpreter/parser_integration.py\n\"\"\"\nBridge between parser output and interpreter evaluation.\n\"\"\"\n\nimport sys\nfrom typing import Optional\nfrom .interpreter import Interpreter\nfrom .errors import RuntimeError\n\n# Assuming parser module provides parse(source) -> AST\ntry:\n    from parser import parse, ParseError\nexcept ImportError:\n    # Stub for when parser isn't available yet\n    class ParseError(Exception):\n        pass\n    \n    def parse(source):\n        raise NotImplementedError(\"Parser not integrated yet\")\n\n\ndef run_source(source: str, interpreter: Optional[Interpreter] = None) -> bool:\n    \"\"\"\n    Complete pipeline: parse source and interpret it.\n    \n    Returns True on success, prints errors and returns False on failure.\n    \"\"\"\n    if interpreter is None:\n        interpreter = Interpreter()\n    \n    try:\n        ast = parse(source)\n        interpreter.interpret(ast)  # Assuming interpret accepts AST directly\n        return True\n    except ParseError as e:\n        print(f\"Syntax error: {e}\", file=sys.stderr)\n        return False\n    except RuntimeError as e:\n        print(f\"Runtime error: {e}\", file=sys.stderr)\n        return False\n```\n\n#### D. Core Logic Skeleton Code\n\n**Evaluator skeleton** (to be filled in across milestones):\n\n```python\n# tree_walker_interpreter/evaluator.py\n\"\"\"\nCore recursive evaluator for AST nodes.\n\"\"\"\n\nfrom typing import Any\nfrom .environment import Environment\nfrom .errors import RuntimeError, TypeError, DivisionByZeroError\nfrom .control_flow import BreakSignal, ContinueSignal, ReturnSignal\n\n\nclass Evaluator:\n    \"\"\"Recursively evaluates AST nodes in the context of an environment.\"\"\"\n    \n    def evaluate(self, node, env: Environment) -> Any:\n        \"\"\"\n        Main dispatch method - evaluates any AST node.\n        \n        Args:\n            node: Any AST node from the parser\n            env: Current environment for variable lookup\n            \n        Returns:\n            Runtime value resulting from evaluating the node\n            \n        Raises:\n            RuntimeError: For any runtime error during evaluation\n        \"\"\"\n        # TODO: Implement node type dispatch\n        # This will grow as we implement more node types across milestones\n        \n        # Example structure:\n        node_type = type(node).__name__\n        \n        if node_type == \"LiteralNode\":\n            # TODO Milestone 1: Return literal value\n            pass\n        elif node_type == \"BinaryNode\":\n            # TODO Milestone 1: Evaluate left and right, apply operator\n            pass\n        elif node_type == \"UnaryNode\":\n            # TODO Milestone 1: Evaluate operand, apply unary operator\n            pass\n        elif node_type == \"GroupingNode\":\n            # TODO Milestone 1: Evaluate expression inside parentheses\n            pass\n        elif node_type == \"VariableNode\":\n            # TODO Milestone 2: Look up variable in environment\n            pass\n        elif node_type == \"VarDeclNode\":\n            # TODO Milestone 2: Evaluate initializer, define in environment\n            pass\n        elif node_type == \"AssignNode\":\n            # TODO Milestone 2: Evaluate value, assign to existing variable\n            pass\n        elif node_type == \"IfNode\":\n            # TODO Milestone 3: Evaluate condition, execute appropriate branch\n            pass\n        elif node_type == \"WhileNode\":\n            # TODO Milestone 3: Loop while condition is truthy\n            pass\n        elif node_type == \"FunctionDeclNode\":\n            # TODO Milestone 4: Create function value, define in environment\n            pass\n        elif node_type == \"CallNode\":\n            # TODO Milestone 4: Evaluate callee and arguments, call function\n            pass\n        elif node_type == \"ReturnNode\":\n            # TODO Milestone 4: Evaluate expression, raise ReturnSignal\n            pass\n        else:\n            raise RuntimeError(f\"Unhandled node type: {node_type}\")\n```\n\n#### E. Language-Specific Hints for Python\n\n1. **Truthiness Conversion**: Use Python's `bool()` but treat `None` (nil) and `0` as falsey for language consistency:\n   ```python\n   def is_truthy(value):\n       if value is None:\n           return False\n       if isinstance(value, bool):\n           return value\n       return True  # Everything else is truthy (including 0, empty string)\n   ```\n\n2. **Type Checking**: Use `isinstance()` for runtime type checks rather than `type()` to handle inheritance:\n   ```python\n   if not isinstance(left, (int, float)):\n       raise TypeError(f\"Operand must be a number, got {type(left).__name__}\")\n   ```\n\n3. **Environment Chain**: Implement parent traversal with a simple while loop:\n   ```python\n   current = self\n   while current is not None:\n       if name in current.store:\n           return current.store[name]\n       current = current.parent\n   raise UndefinedVariableError(f\"Undefined variable '{name}'\")\n   ```\n\n4. **Control Flow Signals**: Use custom exceptions for non-local exits:\n   ```python\n   class ReturnSignal(Exception):\n       def __init__(self, value):\n           self.value = value\n   \n   # In function evaluation:\n   try:\n       self.evaluate(function_body, call_env)\n       return None  # Implicit return nil\n   except ReturnSignal as ret:\n       return ret.value  # Explicit return value\n   ```\n\n5. **Function Value Equality**: For testing, you may want function values to compare equal if they refer to the same AST node and closure. Implement `__eq__` method in `FunctionValue`.\n\n#### F. Milestone Checkpoint\n\nAfter setting up the file structure, verify your foundation:\n\n1. **Run basic imports test**:\n   ```bash\n   python -c \"\n   from tree_walker_interpreter import Interpreter\n   from tree_walker_interpreter.environment import Environment\n   from tree_walker_interpreter.errors import RuntimeError\n   print('✓ All imports successful')\n   \"\n   ```\n\n2. **Expected output**: `✓ All imports successful`\n\n3. **Create a simple test** to verify component creation:\n   ```python\n   # test_architecture.py\n   from tree_walker_interpreter.environment import Environment\n   \n   # Test environment chain creation\n   global_env = Environment()\n   local_env = Environment(global_env)\n   \n   assert local_env.parent == global_env\n   assert global_env.parent is None\n   print(\"✓ Environment chain created correctly\")\n   ```\n\n4. **Common early issues**:\n   - **Circular import errors**: Ensure modules follow the dependency order above\n   - **Missing `__init__.py`**: Each directory needs this file to be a package\n   - **Relative import issues**: Use absolute imports within the package\n\nThis architectural foundation will support all four milestones. The clean separation allows you to implement and test each component independently before integration.\n\n---\n\n\n## Data Model\n> **Milestone(s):** 1, 2, 3, 4\n\nThis section defines the fundamental building blocks the interpreter uses to represent both static program structure and dynamic runtime state. It is the interpreter's \"type system\" in the broadest sense, encompassing the values that can be manipulated, the storage for those values as the program runs, and the syntactic structures that are evaluated to produce them. Getting this model clear and consistent is critical before implementing the evaluation logic, as it defines the contracts between all components.\n\n### Runtime Values and Types\n\n**Mental Model: The Toy Box with Labeled Compartments**\nThink of the interpreter's memory as a toy box with separate, clearly marked compartments for different types of toys: one for `Number` blocks, one for `String` jump ropes, one for `Boolean` light switches, one for `Nil` (an empty space), and a special shelf for `Function` instruction manuals. When you evaluate an expression, you reach into the box and pull out a toy. The evaluator must know which compartment it came from because you can't stack blocks with a jump rope or flip a light switch that's actually a block. This compartmentalization—the **runtime type**—defines what operations are allowed.\n\nThe interpreter is dynamically typed; types are associated with values, not variables. A variable can hold a `Number` at one moment and a `String` the next. However, operations are type-aware: you cannot add a `Boolean` to a `Number`. The set of **runtime value** types is intentionally minimal to match the language's expressiveness defined in the goals.\n\nThe following table enumerates all possible runtime value types and their concrete representation in the implementation. The representation is designed to be simple and to leverage the host language's (Python's) native types where possible, while requiring a custom type for functions to capture their lexical environment.\n\n| Type Name | Internal Representation | Description & Examples |\n|-----------|------------------------|------------------------|\n| `Number` | Python's `float` or `int` | All numeric literals. Internally, we use Python's numeric types. For simplicity, we treat all numbers as floating-point (`float`), but an integer subtype can be added later. Example: `42`, `3.14`. |\n| `String` | Python's `str` | Text literals enclosed in double quotes. Example: `\"hello world\"`. |\n| `Boolean` | Python's `bool` | The logical values `true` and `false`. |\n| `Nil` | The singleton `None` | Represents the absence of a value. The result of an expression like `print(\"hi\")` or an uninitialized variable. |\n| `Function` | Instance of `FunctionValue` class | A callable unit of execution. It is not a native Python function but a custom object storing the function's definition (parameters, body) and its **closure environment**—a reference to the environment active when the function was declared. This is the key to implementing lexical scoping and closures. |\n\nThe `FunctionValue` is a critical custom type. Its structure is detailed below, as it must be explicitly defined to support closures.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `name` | `Optional[str]` | The function's name as declared in the source code. This is optional to support anonymous/lambda functions. Used for better error reporting and recursion (a function can refer to its own name in its body). |\n| `parameters` | `List[str]` | An ordered list of parameter names (as strings). The length of this list defines the function's arity. |\n| `body` | `ASTNode` (typically a `Block` statement) | The abstract syntax tree of the function's body. This is the static code that will be evaluated each time the function is called. |\n| `closure` | `Environment` | A reference to the **environment in effect at the moment the function was declared**, not when it is called. This is the \"captured\" environment that allows the function to access variables from its surrounding scope, enabling closures. |\n\n![Data Model: Type Relationships](./diagrams/data-type-relationship.svg)\n\n**Architecture Decision Record: Runtime Value Representation**\n\n> **Decision: Use Host Language Types with a Custom Function Wrapper**\n> - **Context**: We need a simple, efficient way to represent values during interpretation. The interpreter must support basic operations (arithmetic, comparison) and first-class functions with closures.\n> - **Options Considered**:\n>     1. **Tagged Union / Sum Type**: Create a dedicated `Value` class or enum with a type tag and a union field for each possible type (number, string, etc.). Functions would be one variant of this union.\n>     2. **Host Language Primitives + Custom Class**: Use the host language's built-in types (int, str, bool, None) for primitive values, and a custom `FunctionValue` class for functions.\n>     3. **Fully Custom Wrapper for All Types**: Create a base `RuntimeValue` class with subclasses for each type (NumberValue, StringValue, etc.), providing a uniform interface.\n> - **Decision**: Option 2 (Host Language Primitives + Custom Class).\n> - **Rationale**:\n>     - **Simplicity & Performance**: Using native types for primitives (e.g., Python's `int`, `str`) is straightforward and leverages the host's efficient operations. There is no need to wrap a number in a custom class just to add a type tag when Python's `type()` serves that purpose.\n>     - **Clear Demarcation for Complex Types**: Functions require additional metadata (parameters, body, closure). A custom class is a natural and explicit way to bundle this data. This creates a clear conceptual boundary: primitives are \"just values,\" while functions are \"executable objects with state.\"\n>     - **Easier Debugging and Testing**: Printing a native Python string shows its value directly. A custom wrapper would require a `__repr__` method to be equally readable.\n> - **Consequences**:\n>     - **Pros**: Cleaner code, less boilerplate, faster execution for primitive operations.\n>     - **Cons**: Requires careful type checking in the evaluator, as the type system is implicit (e.g., `isinstance(value, str)` for strings). The mix of native and custom types can feel inconsistent, but the conceptual separation (function vs. primitive) mitigates this.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Tagged Union | Uniform interface, explicit type tags, easy to extend | Boilerplate for every operation, slower due to indirection, memory overhead | No |\n| Host Primitives + Custom Class | Fast, simple, leverages host language | Inconsistent representation, requires explicit type checks | **Yes** |\n| Fully Custom Wrapper | Ultimate consistency and control, easy to add metadata to all types | Maximum boilerplate, inefficient for primitives, over-engineering | No |\n\n### The Environment Model\n\n**Mental Model: A Stack of Ledgers in a Library**\nImagine a library with a main ledger (the global scope) on a central desk. When you enter a study room (a new block or function), you take a fresh, empty ledger and place it on top of the main one. You can write new entries (define variables) in this top ledger. When you need to look up a value, you first check the top ledger. If it's not there, you look in the ledger beneath it, and so on, until you reach the main desk's ledger. When you leave the study room, you discard the top ledger—all entries made there vanish—and you're back to using only the lower ledgers. This is **lexical (static) scoping**: the visibility of a name depends on the static, nested structure of the code, not the dynamic call flow.\n\nThe `Environment` class implements this stack-of-ledgers model as a linked chain. Each `Environment` object represents one scope or ledger. It contains a dictionary (`store`) mapping variable names to their current runtime values and a reference (`parent`) to the environment that encloses it (the next ledger down). The chain starts at the **global environment**, which has no parent (`parent = None`).\n\nThe core operations are:\n1.  **Define (`define`)** : Write a new name-value binding in the *current* ledger (environment). This is used for variable declarations (`var x = 5;`).\n2.  **Get (`get`)** : Read a value by name. Start at the current ledger and walk up the parent chain until the name is found. If the chain ends (reached the global scope with no parent) and the name is still not found, the variable is **undefined**.\n3.  **Assign (`assign`)** : Update the value of an *existing* binding. Walk the parent chain to find the *first* ledger where the name exists, then update its value there. If the name is not found in any ledger, it's an error (cannot assign to an undefined variable). This implements the rule that assignment modifies the variable in the nearest enclosing scope where it is defined, which may not be the current scope.\n\nThe structure and interface of the `Environment` class are formally defined below.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `store` | `Dict[str, Any]` | The dictionary holding variable bindings for this specific scope. Keys are variable names (strings), values are runtime values (Number, String, Boolean, Nil, or FunctionValue). |\n| `parent` | `Optional[Environment]` | A reference to the environment that encloses this one. The global environment's `parent` is `None`. |\n\n| Method Signature | Description & Algorithm |\n|------------------|-------------------------|\n| `define(name: str, value: Any) -> None` | Creates a new binding in the current environment's `store`. This operation does **not** check for existing bindings—it allows **shadowing** (a new binding with the same name hides an outer one). |\n| `get(name: str) -> Any` | 1. Check if `name` exists as a key in the current environment's `store`. <br> 2. If found, return the associated value. <br> 3. If not found and `parent` is not `None`, recursively call `parent.get(name)`. <br> 4. If `parent` is `None` (we are in the global scope and didn't find it), raise an `UndefinedVariableError`. |\n| `assign(name: str, value: Any) -> None` | 1. Check if `name` exists as a key in the current environment's `store`. <br> 2. If found, update the value for that key in `store`. <br> 3. If not found and `parent` is not `None`, recursively call `parent.assign(name, value)`. <br> 4. If `parent` is `None` (name not found in any scope), raise an `UndefinedVariableError` (similar to `get`). |\n\n**Common Pitfalls: Environment Chain**\n⚠️ **Pitfall: Forgetting to walk the parent chain in `get` or `assign`**\n*   **Description**: Implementing `get` by only checking the current environment's `store` without consulting the `parent`.\n*   **Why it's wrong**: This breaks lexical scoping. A function would be unable to see variables from its outer scope, making closures impossible and rendering most programs invalid.\n*   **Fix**: Always implement the recursive walk. The base case is either finding the name or reaching an environment with a `None` parent.\n\n⚠️ **Pitfall: Confusing `define` with `assign`**\n*   **Description**: Using `assign` for variable declaration (e.g., on a `var` statement). This will incorrectly try to update an existing binding and will raise an `UndefinedVariableError` if the variable hasn't been declared in an outer scope.\n*   **Why it's wrong**: Declaration (`var x`) should *create* a new binding in the *current* scope, even if a same-named variable exists in an outer scope (shadowing). Assignment (`x = 5`) should *modify* an existing binding, searching outward.\n*   **Fix**: Map the AST's `VariableDeclaration` node to `environment.define(...)` and the `Assignment` node to `environment.assign(...)`.\n\n⚠️ **Pitfall: Incorrectly setting the parent for a new function environment**\n*   **Description**: When creating a new environment for a function call, setting its `parent` to the *caller's* current environment instead of the function's own `closure` environment.\n*   **Why it's wrong**: This would implement **dynamic scoping**, where a function sees the variables of its caller, not the variables in place where it was defined. This is contrary to the language's goal of lexical scoping and makes programs very difficult to reason about.\n*   **Fix**: The new call environment's `parent` must be the `closure` field of the `FunctionValue` being called.\n\n![Diagram: Environment Chain Lookup](./diagrams/env-chain-lookup.svg)\n\n### Key AST Node Types for Evaluation\n\n**Mental Model: The Recipe Card Box**\nThe AST is a box of indexed recipe cards (nodes). Each card has a specific type (`Literal`, `Binary`, etc.) printed at the top and a set of blank fields to fill in (like \"left ingredient,\" \"operator,\" \"right ingredient\"). The evaluator's job is to take a card, follow its instructions (defined by its type), retrieve the values for its fields (which might involve pulling other cards), and produce a final dish (a runtime value). The semantics—*what to do* when you see a given card type—are fixed and must be implemented in the evaluator.\n\nThis subsection lists the essential AST node types produced by the parser that the evaluator must handle. It focuses on their *runtime semantics*: what the node evaluates to and any side effects it causes. The exact field names may vary slightly depending on the parser implementation, but the core concepts are consistent.\n\n| AST Node Type | Key Fields | Evaluation Semantics & Notes |\n|---------------|------------|------------------------------|\n| `Literal`     | `value: Any` (raw Python value) | Evaluates directly to the corresponding runtime value. For example, a `Literal` node with `value=42` evaluates to the runtime `Number` 42. This is a leaf node in the AST. |\n| `Grouping`    | `expression: ASTNode` | Evaluates its inner `expression` and returns that result. Its sole purpose is to override default precedence; it has no runtime effect beyond forcing a specific evaluation order. |\n| `Unary`       | `operator: Token`, `right: ASTNode` | 1. Evaluate the `right` operand to a value. <br> 2. Apply the unary operator to that value. The `-` operator expects a `Number` operand and returns its negation. The `!` operator performs logical NOT on any value, following **truthiness** rules (e.g., `nil` and `false` are falsey; everything else is truthy). |\n| `Binary`      | `left: ASTNode`, `operator: Token`, `right: ASTNode` | 1. Evaluate the `left` operand to a value. <br> 2. Evaluate the `right` operand to a value. <br> 3. Apply the binary operator to the two values. This includes arithmetic (`+`, `-`, `*`, `/`), comparison (`<`, `<=`, `>`, `>=`), and equality (`==`, `!=`) operators. The `+` operator also performs string concatenation if both operands are strings. `/` must check for division by zero. |\n| `Logical`     | `left: ASTNode`, `operator: Token` (`and`, `or`), `right: ASTNode` | Implements **short-circuit evaluation**. For `and`: Evaluate `left`. If it's falsey, return the `left` value immediately. Otherwise, evaluate and return the `right` value. For `or`: Evaluate `left`. If it's truthy, return the `left` value immediately. Otherwise, evaluate and return the `right` value. |\n| `Variable`    | `name: Token` (with lexeme) | Represents an identifier usage. Evaluates to the value bound to the variable's name in the current environment chain. Triggers a `get` operation. |\n| `Assignment`  | `name: Token`, `value: ASTNode` | 1. Evaluate the `value` expression. <br> 2. Perform an `assign` operation on the environment with the `name`'s lexeme and the computed value. Returns the assigned value. |\n| `VariableDeclaration` | `name: Token`, `initializer: Optional[ASTNode]` | 1. Evaluate the `initializer` expression (if present), otherwise use `nil`. <br> 2. Perform a `define` operation on the current environment with the `name`'s lexeme and the initial value. Returns the initial value. |\n| `Block`       | `statements: List[ASTNode]` | Evaluates each statement in sequence, in a new nested environment whose parent is the current environment. Returns the value of the last statement evaluated, or `nil` if the block is empty. This creates a new lexical scope. |\n| `If`          | `condition: ASTNode`, `then_branch: ASTNode`, `else_branch: Optional[ASTNode]` | 1. Evaluate the `condition`. <br> 2. If the condition is **truthy**, evaluate and return the value of the `then_branch`. <br> 3. Otherwise, if an `else_branch` exists, evaluate and return its value. If no `else_branch`, return `nil`. |\n| `While`       | `condition: ASTNode`, `body: ASTNode` | 1. Evaluate the `condition`. <br> 2. If the condition is falsey, exit the loop and return `nil`. <br> 3. If truthy, evaluate the `body`. If a `BreakSignal` is raised, exit the loop and return `nil`. If a `ContinueSignal` is raised, jump back to step 1. <br> 4. After executing the body (with no jump signal), loop back to step 1. |\n| `For`         | `initializer: Optional[ASTNode]`, `condition: Optional[ASTNode]`, `increment: Optional[ASTNode]`, `body: ASTNode` | This is typically **desugared** (transformed) in the parser or evaluator into an equivalent `Block` containing the `initializer`, a `While` loop with the `condition`, and the `increment` statement at the end of the loop body. The evaluator can thus treat it as this desugared form. |\n| `FunctionDeclaration` | `name: Token`, `parameters: List[Token]`, `body: ASTNode` | 1. Create a new `FunctionValue` object. Its `name` is the token's lexeme, `parameters` are the list of parameter name strings, `body` is the function body AST node, and `closure` is a reference to the *current environment* at the time of declaration. <br> 2. Perform a `define` operation in the current environment, binding the function's name to this `FunctionValue`. Returns the `FunctionValue`. |\n| `Call`        | `callee: ASTNode`, `arguments: List[ASTNode]` | 1. Evaluate the `callee` expression. It must result in a `FunctionValue` or another callable (though we only have functions). <br> 2. Evaluate each argument expression in order, from left to right. <br> 3. Call the `call(arguments)` method on the `FunctionValue`, passing the list of evaluated argument values. This method creates a new environment for the call, binds parameters, executes the body, and returns the result. The result of the `Call` node is the return value from the function. |\n| `Return`      | `value: Optional[ASTNode]` | 1. Evaluate the `value` expression (if present), otherwise use `nil`. <br> 2. Raise a `ReturnSignal` containing this value. This signal is a **non-local exit** that unwinds the call stack until it is caught by the function call evaluator, which then returns the value as the result of the call. |\n| `ExpressionStatement` | `expression: ASTNode` | Evaluates the inner expression for its side effects (e.g., a function call) and discards its value. Returns `nil`. |\n\n> **Key Insight:** AST nodes are **immutable**. They are created by the parser and never modified. Evaluation traverses this static structure and produces dynamic values, but the tree itself does not change. This separation simplifies reasoning and prevents accidental state corruption.\n\n### Implementation Guidance\n\nThis section provides concrete starter code for the foundational data model components. The `Environment` class is a prerequisite for evaluation and is provided in full. The representation of runtime values is mostly implicit, but the `FunctionValue` class is provided as a complete building block.\n\n#### A. Technology Recommendations Table\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Runtime Values** | Python's built-in types (`int`, `float`, `str`, `bool`, `None`) + custom `FunctionValue` class. | Use a `dataclass` or `NamedTuple` for `FunctionValue` for cleaner attribute definition. |\n| **Environment Chain** | Simple class with `dict` and `parent` reference. | Use a `collections.ChainMap` for the lookup logic, though implementing the chain manually is more educational. |\n| **Error Types** | Simple exception classes inheriting from a base `RuntimeError`. | Add more context like stack traces or line numbers to error objects. |\n\n#### B. Recommended File/Module Structure\nPlace the data model in a dedicated module to keep the project organized.\n```\ntreewalk_interpreter/\n├── ast_nodes.py          # AST node class definitions (from parser)\n├── environment.py        # Environment and FunctionValue classes\n├── errors.py            # Custom exception classes (RuntimeError, etc.)\n├── evaluator.py         # Main Evaluator class (next section)\n└── interpreter.py       # Top-level Interpreter class (orchestrates parse & evaluate)\n```\n\n#### C. Infrastructure Starter Code (COMPLETE)\nThe following code for `errors.py` and the core of `environment.py` is complete and ready to use. The learner should integrate these files as-is.\n\n**File: `errors.py`**\n```python\n\"\"\"Custom exceptions for the tree-walking interpreter.\"\"\"\n\nclass RuntimeError(Exception):\n    \"\"\"Base class for all runtime errors.\"\"\"\n    def __init__(self, message: str, token):\n        super().__init__(message)\n        self.message = message\n        self.token = token  # The Token object from the lexer (should have line, column info)\n\n    def __str__(self):\n        return f\"[Line {self.token.line}] {self.message}\"\n\nclass UndefinedVariableError(RuntimeError):\n    \"\"\"Raised when trying to access a variable that is not defined in any accessible scope.\"\"\"\n    def __init__(self, message: str, token):\n        super().__init__(message, token)\n\nclass TypeError(RuntimeError):\n    \"\"\"Raised when an operation is applied to an operand of an inappropriate type.\"\"\"\n    def __init__(self, message: str, token):\n        super().__init__(message, token)\n\nclass DivisionByZeroError(RuntimeError):\n    \"\"\"Raised when dividing by zero.\"\"\"\n    def __init__(self, message: str, token):\n        super().__init__(message, token)\n\nclass ArgumentError(RuntimeError):\n    \"\"\"Raised when a function is called with the wrong number of arguments.\"\"\"\n    def __init__(self, message: str, token):\n        super().__init__(message, token)\n\nclass ControlFlowSignal(Exception):\n    \"\"\"Base class for non-local control flow signals (break, continue, return).\"\"\"\n    pass\n\nclass BreakSignal(ControlFlowSignal):\n    \"\"\"Signals that a break statement was executed.\"\"\"\n    pass\n\nclass ContinueSignal(ControlFlowSignal):\n    \"\"\"Signals that a continue statement was executed.\"\"\"\n    pass\n\nclass ReturnSignal(ControlFlowSignal):\n    \"\"\"Signals that a return statement was executed. Carries the return value.\"\"\"\n    def __init__(self, value):\n        super().__init__()\n        self.value = value\n```\n\n**File: `environment.py`**\n```python\n\"\"\"Environment and FunctionValue classes for variable storage and closures.\"\"\"\nfrom typing import Dict, Any, Optional, List\nimport ast_nodes  # Assuming your AST node types are in ast_nodes module\n\nclass Environment:\n    \"\"\"A lexical scoping environment mapping variable names to values.\"\"\"\n    def __init__(self, parent: Optional['Environment'] = None):\n        self.store: Dict[str, Any] = {}\n        self.parent: Optional['Environment'] = parent\n\n    def define(self, name: str, value: Any) -> None:\n        \"\"\"Define a new variable in the current environment. Allows shadowing.\"\"\"\n        self.store[name] = value\n\n    def get(self, name: str) -> Any:\n        \"\"\"Retrieve the value of a variable. Walks up the parent chain.\"\"\"\n        # 1. Check current scope\n        if name in self.store:\n            return self.store[name]\n        # 2. Walk up the chain\n        if self.parent is not None:\n            return self.parent.get(name)\n        # 3. Not found anywhere\n        raise UndefinedVariableError(f\"Undefined variable '{name}'.\", token=None)  # Token will be added in evaluator\n\n    def assign(self, name: str, value: Any) -> None:\n        \"\"\"Update the value of an existing variable. Walks up the parent chain to find it.\"\"\"\n        # 1. Check current scope\n        if name in self.store:\n            self.store[name] = value\n            return\n        # 2. Walk up the chain\n        if self.parent is not None:\n            self.parent.assign(name, value)\n            return\n        # 3. Not found anywhere\n        raise UndefinedVariableError(f\"Cannot assign to undefined variable '{name}'.\", token=None)  # Token added in evaluator\n\n\nclass FunctionValue:\n    \"\"\"Runtime representation of a function. Captures its definition environment for closures.\"\"\"\n    def __init__(self, name: Optional[str], parameters: List[str], body: 'ast_nodes.Block', closure: Environment):\n        self.name = name  # Can be None for anonymous functions\n        self.parameters = parameters\n        self.body = body\n        self.closure = closure  # The environment where the function was defined\n\n    def call(self, arguments: List[Any]) -> Any:\n        \"\"\"Execute the function with the given arguments.\"\"\"\n        # 1. Validate argument count\n        if len(arguments) != len(self.parameters):\n            raise ArgumentError(\n                f\"Function '{self.name}' expected {len(self.parameters)} arguments but got {len(arguments)}.\",\n                token=None  # Token will be added in evaluator\n            )\n        # 2. Create a new environment for this function call.\n        #    Its parent is the function's closure environment, NOT the caller's environment.\n        call_env = Environment(parent=self.closure)\n        # 3. Bind parameters to arguments in the new environment\n        for param_name, arg_value in zip(self.parameters, arguments):\n            call_env.define(param_name, arg_value)\n        # 4. Execute the function body in the new environment.\n        #    The evaluator will catch ReturnSignal and return its value.\n        #    This requires the evaluator to be available here, which introduces a circular dependency.\n        #    We'll solve this in the Component Design: Function Manager section.\n        #    For now, we leave this method as a skeleton.\n        #    TODO: Actually evaluate the body using the global evaluator.\n        pass\n\n    def __repr__(self):\n        name = self.name if self.name is not None else \"<anonymous>\"\n        return f\"<function {name}>\"\n```\n\n#### D. Core Logic Skeleton Code\nThe `FunctionValue.call` method depends on the evaluator, which hasn't been built yet. Its completion is left as a guided TODO in the next section (Component Design: Function Manager). The `Environment` class is complete.\n\n#### E. Language-Specific Hints (Python)\n- Use `isinstance(value, (int, float))` to check for numbers, as Python's `int` and `float` are distinct types but both represent our `Number` runtime type.\n- For `Nil`, the singleton `None` is perfect. Check for it using `value is None`.\n- The `FunctionValue` class's `__repr__` method is helpful for debugging. Use it to print functions in a readable way.\n- The `Environment` class uses recursion for `get` and `assign`. Ensure the base case (`parent is None`) is correctly handled to avoid infinite recursion.\n\n#### F. Milestone Checkpoint\nAfter implementing the `Environment` class, you should be able to run a simple test to verify its chain behavior.\n```python\n# test_environment.py\nfrom environment import Environment\n\nglobal_env = Environment()\nglobal_env.define(\"a\", 1)\nglobal_env.define(\"b\", 2)\n\nlocal_env = Environment(parent=global_env)\nlocal_env.define(\"b\", 20)  # Shadows global b\nlocal_env.define(\"c\", 30)\n\nprint(local_env.get(\"a\"))  # Should print 1 (found in parent)\nprint(local_env.get(\"b\"))  # Should print 20 (found in current, shadowing)\nprint(local_env.get(\"c\"))  # Should print 30 (found in current)\ntry:\n    print(local_env.get(\"d\"))  # Should raise UndefinedVariableError\nexcept UndefinedVariableError as e:\n    print(f\"Caught expected error: {e}\")\n\nlocal_env.assign(\"a\", 100)  # Modifies the binding in global_env\nprint(global_env.get(\"a\"))  # Should now print 100\n```\n\n#### G. Debugging Tips\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Variable lookup always returns `nil` or raises \"undefined\" for names you know exist. | The `get` method is not walking the parent chain. It only checks `self.store`. | Add a print statement in `get` to show which environment is being checked and whether it proceeds to the parent. | Implement the recursive walk: if name not in `self.store` and `self.parent` is not `None`, return `self.parent.get(name)`. |\n| Changing a variable inside a function affects a variable with the same name outside, unexpectedly. | The function's call environment has its `parent` set to the caller's environment (dynamic scoping) instead of the function's `closure`. | Print the `parent` of the new call environment when a function is called. | Ensure `call_env = Environment(parent=self.closure)`, where `self.closure` is the environment saved when the function was declared. |\n| \"Cannot assign to undefined variable\" error on a `var` declaration. | You are using `assign` instead of `define` for variable declarations. | Check which method you call for `VariableDeclaration` nodes in your evaluator. | Use `environment.define(...)` for declarations, `environment.assign(...)` for assignments. |\n\n\n## Component Design: Core Evaluator\n> **Milestone(s):** 1, 3, 4\n\nThis section details the heart of the interpreter: the recursive `evaluate` function that traverses the Abstract Syntax Tree (AST), transforming syntactic nodes into runtime values. The evaluator embodies the principle of **tree-walking**: it starts at the root of the AST and recursively descends into child nodes, computing values and applying operations until the entire program is reduced to a final result. Its design must gracefully handle the diverse categories of language constructs—from simple literals to complex function calls—while maintaining a clear separation between the static AST structure and the dynamic environment of variable bindings.\n\n### Mental Model: The DOM Tree Walker\n\nThink of the AST as a detailed map of a city (the program), with different districts representing expression types (arithmetic, logic, function calls). The evaluator is like a tour bus driver following this map. At each intersection (node), the driver consults a rulebook (the evaluation logic) that says, \"If you see a `BinaryExpression` node, first visit the left street (evaluate left operand), then visit the right street (evaluate right operand), then apply the operation (e.g., add them).\" The bus recursively navigates deeper into neighborhoods (sub-expressions) until it reaches a dead-end—a literal value like a house number (e.g., `5`). Then it backs out, combining results along the way.\n\nThis is analogous to traversing a Document Object Model (DOM) tree in a web browser. A script that walks the DOM to collect all paragraph text starts at the root `<html>` element, checks if the current node is a `<p>`, and if so, extracts its text. Then it recursively visits each child node. Similarly, the evaluator visits each AST node, applies a specific action based on the node's type, and recursively processes its children. The key insight is that the structure of the traversal mirrors the structure of the tree, and the operations are applied in an order that respects language semantics (e.g., operator precedence, parentheses).\n\n### Interface and Dispatch\n\nThe evaluator's primary interface is a single, stateless function that accepts an AST node and the current **environment** (the mapping of variable names to values) and returns a runtime value. This function acts as a central dispatch router, examining the node's type and delegating to specialized handling logic.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `Evaluator.evaluate` | `node: ASTNode`, `env: Environment` | `Any` (a runtime value) | The main entry point for evaluation. Inspects the `node.type` and calls the appropriate internal handler method (e.g., `_visit_literal`). It is recursively called for child nodes. |\n\nThe dispatch strategy is intentionally straightforward: a large `if`/`elif`/`else` chain (or a dictionary mapping node types to handler methods) that directly calls the corresponding method. This approach, known as **single dispatch**, is chosen for its transparency and ease of debugging for learners. When `evaluate` encounters a `BinaryExpression` node, it will:\n1.  Recursively call `evaluate` on the `left` child node to obtain its value.\n2.  Recursively call `evaluate` on the `right` child node to obtain its value.\n3.  Apply the specific operator (e.g., `+`, `*`) to those two values, performing necessary type checks.\n\nThe `environment` parameter is passed through every recursive call, allowing all nodes access to the current set of variable bindings. For certain constructs (like blocks or function calls), a new environment will be created and passed down for the evaluation of specific sub-trees.\n\n### Internal Behavior and Algorithm\n\nThe evaluator's internal logic is organized around the different categories of AST nodes. The following numbered steps describe the generic algorithms for each major category. These steps are implemented in the handler methods that `evaluate` dispatches to.\n\n**1. Literal Nodes (e.g., `Literal` for `5`, `\"hello\"`, `true`, `nil`)**\n   - **Input**: A node containing a raw value.\n   - **Process**: No computation is needed. The value stored in the node is the runtime value.\n   - **Output**: Return the node's value directly.\n\n**2. Grouping Expressions (e.g., `Grouping` for `(5 + 3)`)**\n   - **Input**: A node with a single `expression` child.\n   - **Process**: The parentheses themselves don't alter the semantics; they only affect parsing precedence. Therefore, evaluate the inner expression.\n   - **Algorithm**:\n       1. Call `evaluate` on the `expression` child node.\n       2. Return the result from that evaluation.\n   - **Output**: The value of the inner expression.\n\n**3. Unary Expressions (e.g., `Unary` for `-5` or `!true`)**\n   - **Input**: A node with an `operator` (e.g., `-`, `!`) and a `right` operand child.\n   - **Process**: Evaluate the operand, then apply the unary operator.\n   - **Algorithm**:\n       1. Call `evaluate` on the `right` child node to obtain the operand value.\n       2. **Type Check**: Verify the operand type is valid for the operator (e.g., `-` requires a number).\n       3. **Apply Operator**:\n          - For `-` (negation): Return the arithmetic negation of the operand (`-operand_value`).\n          - For `!` (logical NOT): Return the logical negation according to the language's **truthiness** rules (typically, `false` for truthy values, `true` for falsy values like `nil` and `false`).\n   - **Output**: The resulting value.\n\n**4. Binary Expressions (e.g., `Binary` for `3 + 4`, `5 > 2`, `\"a\" == \"a\"`)**\n   - **Input**: A node with `left` and `right` child nodes and an `operator`.\n   - **Process**: Evaluate both operands, then apply the binary operator, which may be arithmetic, comparison, or equality.\n   - **Algorithm**:\n       1. Call `evaluate` on the `left` child node.\n       2. Call `evaluate` on the `right` child node.\n       3. **Type Check**: Verify the operand types are compatible with the operator (e.g., `+` works on numbers or strings, `<` works on numbers).\n       4. **Apply Operator**:\n          - **Arithmetic (`+`, `-`, `*`, `/`)**: Perform the corresponding mathematical operation. For `+`, if both operands are strings, perform concatenation. For `/`, check for division by zero.\n          - **Comparison (`<`, `>`, `<=`, `>=`)**: Compare the operands and return a boolean.\n          - **Equality (`==`, `!=`)**: Compare for equality based on value and type. `nil` is only equal to `nil`.\n   - **Output**: The result (a number, string, or boolean).\n\n**5. Logical Expressions (e.g., `Logical` for `a and b`, `x or y`)**\n   - **Input**: A node with `left` and `right` child nodes and an `operator` (`and` or `or`).\n   - **Process**: Implement **short-circuit evaluation**. The right operand is only evaluated if necessary.\n   - **Algorithm**:\n       1. Call `evaluate` on the `left` child node.\n       2. Determine the **truthiness** of the left result.\n       3. For `and`: If the left is falsy, return the left value immediately (short-circuit). Otherwise, evaluate the right operand and return its value.\n       4. For `or`: If the left is truthy, return the left value immediately (short-circuit). Otherwise, evaluate the right operand and return its value.\n   - **Output**: The value of the left or right operand (not necessarily a boolean; the operator returns the operand value that determined the outcome, which preserves semantics for values like `nil` or `0`).\n\n**6. Variable Expressions (e.g., `Variable` for `x`)**\n   - **Input**: A node with a variable `name`.\n   - **Process**: Look up the variable's value in the current environment chain.\n   - **Algorithm**:\n       1. Call `env.get(name)`.\n       2. If the name is found in the environment chain, return the associated value.\n       3. If the name is not defined in any enclosing environment, raise an `UndefinedVariableError` with the variable name.\n   - **Output**: The value bound to the variable.\n\n**7. Assignment Expressions (e.g., `Assign` for `x = 10`)**\n   - **Input**: A node with a variable `name` and a `value` expression child.\n   - **Process**: Evaluate the right-hand side expression and update the variable's binding in the environment.\n   - **Algorithm**:\n       1. Call `evaluate` on the `value` child node to obtain the value to assign.\n       2. Call `env.assign(name, value)` to update the existing variable binding in the nearest enclosing scope where `name` is defined.\n       3. If `env.assign` raises an error (variable not defined), propagate it.\n       4. Return the assigned value (this allows assignments to be used within larger expressions, e.g., `y = (x = 5) + 2`).\n   - **Output**: The assigned value.\n\n**8. Call Expressions (e.g., `Call` for `add(1, 2)`)**\n   - **Input**: A node with a `callee` expression (usually a `Variable` referring to a function), a list of `arguments` expression nodes, and a closing parenthesis token (for error reporting).\n   - **Process**: Evaluate the callee and each argument, then invoke the function.\n   - **Algorithm**:\n       1. Call `evaluate` on the `callee` node. The result should be a `FunctionValue` (or other callable). If not, raise a `TypeError`.\n       2. For each argument expression in `arguments`, call `evaluate` to get its value, resulting in a list of argument values.\n       3. **Arity Check**: Compare the number of argument values to the number of parameters in the function. If they don't match, raise an `ArgumentError`.\n       4. Invoke the function's `call` method, passing the list of argument values. This method will handle creating a new environment, binding parameters, and executing the function body.\n   - **Output**: The value returned by the function call.\n\n**9. Control Flow Statements (e.g., `If`, `While`, `For`, `Return`)**\n   - These are technically \"statements\" that do not produce a value in the same way expressions do. Their evaluation is detailed in the **Control Flow Executor** component section. However, the core evaluator's dispatch will route to handlers for these nodes, which typically evaluate conditions and manage the execution of statement blocks, possibly signaling **non-local exits** (like `return`).\n\n> The recursive descent is visually captured in the flowchart: ![Flowchart: Expression Evaluation Dispatch](./diagrams/flowchart-eval-expr.svg). The flow starts at `Evaluate(node, env)`, branches based on `node.type`, and shows the recursive calls for operands before applying the operator.\n\n### ADR: Expression Dispatch Strategy\n\n> **Decision: Single Dispatch via Type Checking in `evaluate`**\n> - **Context**: The evaluator must handle over a dozen distinct AST node types, each requiring different evaluation logic. We need a clear, maintainable way to route nodes to the correct handler that is appropriate for an educational implementation.\n> - **Options Considered**:\n>     1. **Single Dispatch Function**: A central `evaluate` function with a large `if`/`elif` chain (or dictionary lookup) that checks `node.type` and calls a corresponding method (e.g., `_visit_binary`).\n>     2. **Visitor Pattern**: Define a `Visitor` interface with a `visit_X` method for each node type. Each AST node class has an `accept(visitor)` method that calls the appropriate `visit_X` on the visitor. The evaluator implements this visitor interface.\n>     3. **Double Dispatch (Dynamic Dispatch)**: Rely on the language's method overriding. Define an abstract `evaluate` method on the base `ASTNode` class and override it in each concrete node subclass. The evaluator would just call `node.evaluate(env)`.\n> - **Decision**: We chose **Option 1 (Single Dispatch Function)**.\n> - **Rationale**:\n>     - **Simplicity and Transparency**: For learners, seeing all dispatch logic in one place (`evaluate`) is easier to understand and debug than the indirection of the Visitor pattern or the distributed logic of double dispatch. The control flow is explicit.\n>     - **Separation of Concerns**: The AST nodes remain plain data structures (immutable AST), free of any evaluation logic. This keeps the parser simple and the data model clean. The evaluation logic is centralized in the `Evaluator` class.\n>     - **Avoiding Language Pitfalls**: In dynamically-typed languages like Python or JavaScript, implementing double dispatch requires careful setup of class hierarchies and can be confusing. The single dispatch function is idiomatic and straightforward.\n> - **Consequences**:\n>     - **Pros**: Easy to follow, modify, and log. The evaluator is self-contained. Adding a new node type requires adding one branch to the `if` chain and one handler method.\n>     - **Cons**: The `evaluate` function can become long (though it remains linear). It violates the Open/Closed principle if we were building a large, extensible system—but for a learner's interpreter, this is acceptable.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Single Dispatch Function | Simple, transparent, keeps nodes as data. | Large dispatch function, manual type checking. | ✅ Yes |\n| Visitor Pattern | Extensible, clean separation, encapsulates logic. | More complex, indirect, requires visitor interface. | |\n| Double Dispatch (Dynamic) | Polymorphic, elegant. | Evaluation logic scattered across node classes, complicates AST data model. | |\n\n### Common Pitfalls\n\n⚡ **Pitfall: Forgetting to Return Values from Handlers**\n- **Description**: In the handler for a binary expression, you correctly evaluate the left and right operands but forget to `return` the result of the operation, causing the function to implicitly return `None` (or `nil`).\n- **Why it's wrong**: This leads to mysterious `None` values propagating up the tree, causing type errors or incorrect program output. For example, `5 + 3` evaluates to `None`.\n- **Fix**: Ensure every branch of the `evaluate` function and every handler method explicitly returns a value. For statement nodes that don't produce a value (like `print`), return a designated `nil` value.\n\n⚡ **Pitfall: Incorrect Recursion Base Case**\n- **Description**: The recursive `evaluate` function lacks a proper base case for literal nodes, causing infinite recursion (e.g., trying to treat a literal as a compound node with children).\n- **Why it's wrong**: The program crashes with a stack overflow or infinite loop.\n- **Fix**: Literal nodes (and other primitive nodes like `Variable`) are the leaves of the AST. Their handlers should return a value without making further recursive calls to `evaluate` on non-existent children.\n\n⚡ **Pitfall: Misunderstanding Truthiness Rules**\n- **Description**: Implementing logical operators (`and`, `or`) or conditionals (`if`, `while`) using strict boolean-only checks, rather than the language's defined **truthiness** (where `0`, `\"\"`, `nil` are falsy, everything else is truthy).\n- **Why it's wrong**: Programs behave incorrectly. For example, `if (0) { print \"true\"; }` might incorrectly execute the block.\n- **Fix**: Implement a helper function `is_truthy(value)` that returns a boolean based on the language's truthiness rules. Use this function consistently for all logical and conditional evaluations.\n\n⚡ **Pitfall: Not Propagating the Environment**\n- **Description**: Forgetting to pass the current `environment` parameter in a recursive call to `evaluate` for a child node, or creating a new environment for a block but not passing it down.\n- **Why it's wrong**: Variable lookup fails because child nodes cannot access the correct bindings, leading to undefined variable errors even for defined variables.\n- **Fix**: Ensure every recursive call to `evaluate` includes the appropriate environment object. For constructs that create a new scope (like a block), create the new environment and use it for evaluating the block's statements.\n\n⚡ **Pitfall: Side-Effecting Operators on Immutable Values**\n- **Description**: In languages like Python, some values (e.g., numbers, strings) are immutable. However, a learner might incorrectly try to modify the value returned from a child evaluation, expecting it to change the original variable.\n- **Why it's wrong**: This misunderstanding doesn't cause runtime errors but leads to incorrect mental models. The evaluator should treat all values as immutable; assignment is handled by updating the environment, not the value itself.\n- **Fix**: Emphasize that evaluation produces *new* values, not modifying existing ones. For example, `a + 1` evaluates to a new number; it does not change the value stored in `a`.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Expression Dispatch | Large `if`/`elif` chain in `evaluate` | Dictionary mapping node type strings to method objects |\n| Value Representation | Python's built-in types (`int`, `str`, `bool`, `None`) | Custom `RuntimeValue` wrapper classes with type tags |\n| Error Handling | Raise custom exception classes (`RuntimeError` subclasses) | Use a result type (e.g., `Result` monad) to propagate errors |\n\n#### B. Recommended File/Module Structure\nThe Core Evaluator resides in its own module, separate from parsing and environment management.\n\n```\ntree_walker/\n  interpreter.py          # Main Interpreter class, coordinates parsing and evaluation\n  evaluator.py            # Evaluator class (this component)\n  environment.py          # Environment class\n  ast_nodes.py            # AST node class definitions (from parser)\n  errors.py               # Custom exception definitions (RuntimeError, etc.)\n  main.py                 # CLI entry point\n```\n\n#### C. Infrastructure Starter Code\nHere is the complete, ready-to-use code for the custom exception classes, which are prerequisites for the evaluator. Place this in `errors.py`.\n\n```python\n# errors.py\nclass RuntimeError(Exception):\n    \"\"\"Base class for all runtime errors.\"\"\"\n    def __init__(self, message: str, token):\n        self.message = message\n        self.token = token\n        super().__init__(self.message)\n\nclass UndefinedVariableError(RuntimeError):\n    \"\"\"Raised when trying to access a variable that is not defined.\"\"\"\n    def __init__(self, variable_name: str, token):\n        message = f\"Undefined variable '{variable_name}'.\"\n        super().__init__(message, token)\n\nclass TypeError(RuntimeError):\n    \"\"\"Raised when an operation is applied to an inappropriate type.\"\"\"\n    def __init__(self, message: str, token):\n        super().__init__(message, token)\n\nclass DivisionByZeroError(RuntimeError):\n    \"\"\"Raised on division by zero.\"\"\"\n    def __init__(self, token):\n        message = \"Division by zero.\"\n        super().__init__(message, token)\n\nclass ArgumentError(RuntimeError):\n    \"\"\"Raised when a function is called with wrong number of arguments.\"\"\"\n    def __init__(self, expected: int, actual: int, token):\n        message = f\"Expected {expected} arguments but got {actual}.\"\n        super().__init__(message, token)\n\nclass ControlFlowSignal(Exception):\n    \"\"\"Base for non-local control flow (break, continue, return).\"\"\"\n    pass\n\nclass BreakSignal(ControlFlowSignal):\n    \"\"\"Signals a break statement.\"\"\"\n    pass\n\nclass ContinueSignal(ControlFlowSignal):\n    \"\"\"Signals a continue statement.\"\"\"\n    pass\n\nclass ReturnSignal(ControlFlowSignal):\n    \"\"\"Signals a return statement.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        super().__init__()\n```\n\n#### D. Core Logic Skeleton Code\nBelow is the skeleton for the `Evaluator` class in `evaluator.py`. It includes the main dispatch method and stubs for each node type handler, with detailed TODO comments mapping to the algorithm steps described earlier.\n\n```python\n# evaluator.py\nfrom typing import Any\nfrom errors import (\n    RuntimeError, UndefinedVariableError, TypeError,\n    DivisionByZeroError, ArgumentError, ControlFlowSignal,\n    BreakSignal, ContinueSignal, ReturnSignal\n)\nfrom environment import Environment\n# Assume AST node classes are imported, e.g.:\n# from ast_nodes import (\n#     Literal, Grouping, Unary, Binary, Logical,\n#     Variable, Assign, Call, If, While, For, Return, ...\n# )\n\nclass Evaluator:\n    \"\"\"Recursively evaluates AST nodes to produce runtime values.\"\"\"\n\n    def evaluate(self, node, env: Environment) -> Any:\n        \"\"\"Main dispatch method. Routes based on node type.\"\"\"\n        # TODO: Implement dispatch based on node.type.\n        # Use a large if/elif chain or a dictionary mapping.\n        # For each node type, call the corresponding _visit_ method.\n        # Example:\n        # if node.type == 'literal':\n        #     return self._visit_literal(node, env)\n        # elif node.type == 'binary':\n        #     return self._visit_binary(node, env)\n        # ...\n        # Remember to pass the environment `env` to each handler.\n        pass\n\n    # --- Expression Handlers ---\n\n    def _visit_literal(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate a literal node (number, string, boolean, nil).\"\"\"\n        # TODO 1: Literal nodes already contain the value.\n        # Return node.value directly.\n        pass\n\n    def _visit_grouping(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate a grouping node (parenthesized expression).\"\"\"\n        # TODO 1: The grouping node has an 'expression' child.\n        # Recursively evaluate that expression by calling self.evaluate.\n        # Return the result.\n        pass\n\n    def _visit_unary(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate a unary expression (-, !).\"\"\"\n        # TODO 1: Evaluate the right operand (node.right) by calling self.evaluate.\n        # TODO 2: Check the operator (node.operator).\n        #   If operator is '-':\n        #     - Ensure the operand is a number (int or float). If not, raise TypeError.\n        #     - Return -operand.\n        #   If operator is '!':\n        #     - Return the logical NOT of the operand using the language's truthiness rules.\n        #       (Hint: Use a helper `is_truthy` method.)\n        pass\n\n    def _visit_binary(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate a binary expression (+, -, *, /, ==, !=, <, <=, >, >=).\"\"\"\n        # TODO 1: Evaluate left operand (node.left) by calling self.evaluate.\n        # TODO 2: Evaluate right operand (node.right) by calling self.evaluate.\n        # TODO 3: Check the operator (node.operator).\n        #   Arithmetic operators (+, -, *, /):\n        #     - For +, if both operands are numbers, add; if both are strings, concatenate.\n        #       Otherwise, raise TypeError.\n        #     - For -, *, /: Ensure both operands are numbers. For /, check for division by zero.\n        #   Comparison operators (<, <=, >, >=):\n        #     - Ensure both operands are numbers. Compare and return boolean.\n        #   Equality operators (==, !=):\n        #     - Compare values for equality. Note: nil is only equal to nil.\n        # Return the result.\n        pass\n\n    def _visit_logical(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate a logical expression (and, or) with short-circuiting.\"\"\"\n        # TODO 1: Evaluate left operand (node.left) by calling self.evaluate.\n        # TODO 2: Determine truthiness of left value (use `is_truthy` helper).\n        # TODO 3: If operator is 'and':\n        #   - If left is falsy, return left value (short-circuit).\n        #   - Otherwise, evaluate right operand and return its value.\n        # TODO 4: If operator is 'or':\n        #   - If left is truthy, return left value (short-circuit).\n        #   - Otherwise, evaluate right operand and return its value.\n        pass\n\n    def _visit_variable(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate a variable expression (look up by name).\"\"\"\n        # TODO 1: Get variable name from node.name.\n        # TODO 2: Call env.get(name) to retrieve the value.\n        # TODO 3: If env.get raises an UndefinedVariableError, propagate it.\n        # Return the value.\n        pass\n\n    def _visit_assign(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate an assignment expression (name = value).\"\"\"\n        # TODO 1: Evaluate the value expression (node.value) by calling self.evaluate.\n        # TODO 2: Call env.assign(node.name, value) to update the variable binding.\n        # TODO 3: Return the assigned value.\n        pass\n\n    # --- Statement Handlers (Milestone 3 & 4) ---\n    # These are often called by evaluate but may return None (or a control flow signal).\n\n    def _visit_if(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate an if statement (with optional else).\"\"\"\n        # TODO 1: Evaluate the condition expression (node.condition) by calling self.evaluate.\n        # TODO 2: Check truthiness of the condition result.\n        # TODO 3: If truthy, evaluate the then branch (node.then_branch).\n        # TODO 4: Otherwise, if an else branch exists (node.else_branch), evaluate it.\n        # Return None (or the value of the last executed statement if you want to support expression statements).\n        pass\n\n    def _visit_while(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate a while loop.\"\"\"\n        # TODO 1: While True:\n        #   TODO 2: Evaluate the condition (node.condition). If falsy, break.\n        #   TODO 3: Try to evaluate the body (node.body) in a try-except that catches BreakSignal and ContinueSignal.\n        #   TODO 4: If BreakSignal is caught, break out of the loop.\n        #   TODO 5: If ContinueSignal is caught, continue to next iteration (skip any remaining code in body).\n        # Return None.\n        pass\n\n    # Note: For loops are typically desugared into while loops in the parser or evaluator.\n    # If you implement _visit_for, it would create a while loop structure and evaluate it.\n\n    def _visit_return(self, node, env: Environment) -> Any:\n        \"\"\"Evaluate a return statement.\"\"\"\n        # TODO 1: If node.value exists, evaluate it to get the return value; otherwise use nil.\n        # TODO 2: Raise a ReturnSignal with the value.\n        # This signal will be caught by the function call handler.\n        pass\n\n    # --- Helper Methods ---\n\n    def is_truthy(self, value) -> bool:\n        \"\"\"Determine truthiness of a runtime value.\"\"\"\n        # TODO: Return False for nil and False, True for everything else.\n        # (Adjust based on your language's truthiness rules; e.g., 0 and \"\" might be truthy.)\n        # For simplicity, we follow Lox/Python-like rules: nil and false are falsy.\n        pass\n```\n\n#### E. Language-Specific Hints (Python)\n- **Type Checking**: Use `isinstance(value, (int, float))` to check for numbers. For strings, use `isinstance(value, str)`. Avoid checking for exact `type(value) == int` to allow floats.\n- **Error Reporting**: The `token` parameter in exceptions should be the token from the AST node (often stored as `node.token`). Use it to report line numbers in error messages.\n- **Truthiness Helper**: In `is_truthy`, you can simply return `value not in (None, False)`. Note: In Python, `0` and `\"\"` are falsy, but many interpreter implementations treat them as truthy to match the target language's semantics. Choose your rule and be consistent.\n- **Handling `nil`**: Represent `nil` as Python's `None`.\n\n#### F. Milestone Checkpoint (Milestone 1: Expression Evaluation)\nAfter implementing the expression handlers (`_visit_literal`, `_visit_grouping`, `_visit_unary`, `_visit_binary`, `_visit_logical`), you should be able to evaluate arithmetic and logical expressions.\n\n**Test Program:**\n```javascript\nprint (5 + 3) * 2;        // Should print 16\nprint !(5 > 3);           // Should print false\nprint (5 > 3) and (2 < 4); // Should print true\nprint \"Hello, \" + \"world!\"; // Should print \"Hello, world!\"\n```\n\n**Expected Output:**\n```\n16\nfalse\ntrue\nHello, world!\n```\n\n**Signs of Trouble:**\n- If you get `None` printed, check that your handlers are returning values.\n- If you get a type error on string concatenation, verify your `+` operator handling.\n- If logical operators don't short-circuit, ensure you are using `is_truthy` and returning the operand value, not a forced boolean.\n\n#### G. Debugging Tips\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| All expressions evaluate to `None` | Forgetting to `return` values in handlers. | Add print statements at the start and end of each handler to see what is returned. | Ensure every handler ends with `return some_value`. |\n| Infinite recursion on literals | Missing base case in `evaluate`; literal nodes incorrectly treated as compound. | Check the dispatch logic: is `node.type` being compared correctly? | Add a clause for `'literal'` that returns `node.value`. |\n| Variable lookup fails inside binary expression | Environment not passed to child evaluations. | In `_visit_binary`, print the `env` before evaluating left and right. | Pass `env` to the recursive `self.evaluate` calls. |\n| `and`/`or` always evaluate both sides | Not implementing short-circuiting. | Check if `_visit_logical` evaluates the right operand unconditionally. | Only evaluate the right operand if the left does not determine the outcome. |\n\n\n## Component Design: Environment Manager\n\n> **Milestone(s):** 2\n\nThe Environment Manager is the **dynamic memory** of our interpreter—the system responsible for storing, retrieving, and managing the lifetime of all named values (variables) as the program executes. While the AST represents the static structure of the program and the evaluator represents the execution logic, the environment represents the **mutable runtime state** that changes with every assignment and function call. The central architectural challenge is implementing **lexical scoping**—the rule that a variable's visibility is determined by its position in the source code's nested block structure—in a way that is both correct and intuitive for learners.\n\n### Mental Model: Stack of Ledgers\n\nImagine you're an accountant working with a **stack of accounting ledgers**. Each ledger represents a distinct scope in your program: the topmost ledger is your current workspace (like the function you're inside), beneath it is the ledger for the enclosing function, and at the bottom is the master company ledger (the global scope). When you need to look up a transaction (variable), you first check the topmost ledger. If it's not there, you look in the ledger below it, continuing down the stack until you find the transaction or reach the bottom (resulting in an \"undefined variable\" error).\n\nWhen you start a new project (enter a new scope), you place a fresh, empty ledger on top of the stack. You record new transactions (define variables) in this top ledger. When the project finishes (scope exits), you remove that ledger from the stack—all transactions recorded there are forgotten, but transactions in lower ledgers remain intact. This model elegantly captures **lexical scoping**: inner scopes can see outer scopes' variables (by looking down the stack), but outer scopes cannot see inner scopes' variables (ledgers above them are inaccessible). The model also explains **shadowing**: if you record a transaction with the same name in an inner ledger, it hides (shadows) any transaction with that name in lower ledgers.\n\n### Interface: Define, Get, Set\n\nThe Environment Manager exposes three fundamental operations that correspond to the three ways a program interacts with variables: declaring a new variable (`var x = 5`), reading a variable's value (`print x`), and updating an existing variable (`x = 10`). Each operation has specific semantics and error conditions that enforce the language's scoping rules.\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `define(name, value)` | `name: str`<br>`value: RuntimeValue` | `None` | Creates a new binding of `name` to `value` in the *current* environment's store. This corresponds to variable declaration (`var`, `let`, or function parameter binding). The operation always succeeds—it will overwrite any existing binding of the same name in the current environment (shadowing). |\n| `get(name)` | `name: str` | `RuntimeValue` | Retrieves the value bound to `name` by searching the environment chain. Starts in the current environment; if not found, recursively searches the parent environment (and its parents) until the name is found. If the name is not bound in any environment in the chain, raises an `UndefinedVariableError` with the name and token location. |\n| `assign(name, value)` | `name: str`<br>`value: RuntimeValue` | `None` | Updates the binding of an *existing* variable named `name` to a new `value`. Searches the environment chain (same as `get`) to find the *first* environment where `name` is defined, then updates that binding. If `name` is not defined in any environment in the chain, raises an `UndefinedVariableError`. This corresponds to assignment statements (`x = 10`). |\n\n> **Key Insight:** The critical distinction between `define` and `assign` is that `define` creates a binding in the *current* environment regardless of what exists in outer scopes (enabling shadowing), while `assign` updates an existing binding by walking the chain (respecting lexical scoping). This separation is what makes lexical scoping work correctly.\n\n### Internal Behavior\n\nThe environment manager implements lexical scoping through a **linked chain of dictionaries**. Each environment object contains a dictionary (`store`) mapping names to values, and an optional reference to a `parent` environment. The chain forms a tree structure, typically linear during simple execution but branching when multiple functions are defined in the same scope.\n\n#### Variable Resolution Algorithm (Walking the Chain)\n\nWhen looking up a variable (for `get` or `assign`), the interpreter follows this recursive procedure:\n\n1. **Check current store:** Look for `name` in the current environment's `store` dictionary.\n2. **Found locally:** If present, return the associated value (for `get`) or update it (for `assign`).\n3. **Not found locally:** If `name` is not in the current store, check if the environment has a `parent`.\n4. **Recurse upward:** If a parent exists, repeat the process in the parent environment (effectively walking up the chain).\n5. **Reach global scope:** If no parent exists (we're at the global environment) and the name is not found, the variable is undefined.\n\nThis algorithm naturally implements lexical scoping because the parent relationship mirrors the syntactic nesting of scopes in the source code. The environment chain is constructed such that each new scope's environment has its enclosing scope's environment as its parent.\n\n#### Scope Creation and Teardown\n\nScopes are created and destroyed dynamically during execution:\n\n- **Entering a block/function:** When a block (like a function body or `if` branch) is entered, the evaluator creates a new environment with the current environment as its parent, then evaluates statements within that new environment.\n- **Exiting a block/function:** When the block finishes, the evaluator discards the environment (by returning to the previous environment). All variable bindings local to that block become inaccessible—this is how local variables are automatically \"cleaned up.\"\n- **Function calls:** A function call creates a new environment whose parent is the function's **closure environment** (the environment where the function was *defined*, not where it was *called*). This is the mechanism that enables closures.\n\nThe following diagram illustrates how variable lookup traverses the environment chain:\n\n![Environment Chain Lookup](./diagrams/env-chain-lookup.svg)\n\n### ADR: Environment Chain vs. Flat Frame\n\n> **Decision: Implement Lexical Scoping via Linked Environment Chain**\n\n- **Context:** We need a mechanism to manage variable bindings that correctly implements lexical (static) scoping. The interpreter must support nested scopes (blocks, functions), variable shadowing, and closures. The implementation should be clear and educational for learners.\n\n- **Options Considered:**\n  1. **Linked Environment Chain:** Each scope is represented by an `Environment` object with a `store` dictionary and a `parent` pointer. Variable lookup walks the parent chain.\n  2. **Flat Frame with Display Array:** All local variables for all active scopes are stored in a single contiguous array (frame). A separate \"display\" array stores pointers to the start of each lexical level's segment. Variable access calculates offsets.\n  3. **Single Global Dictionary with Lexical Depth Tags:** A single dictionary maps `(name, lexical_depth)` pairs to values. The current lexical depth is tracked during evaluation.\n\n- **Decision:** Implement the **Linked Environment Chain** (Option 1).\n\n- **Rationale:**\n  - **Conceptual clarity:** The chain directly mirrors the mental model of nested scopes as a stack of ledgers. Learners can easily visualize and debug by following parent pointers.\n  - **Implementation simplicity:** The chain requires minimal infrastructure—just a dictionary and a parent pointer. No complex offset calculations or depth tracking.\n  - **Natural support for closures:** Storing the defining environment as a parent pointer in function objects directly implements closure capture without additional machinery.\n  - **Educational value:** Understanding this model prepares learners for similar designs in real interpreters (like Python's frame objects) and introduces the important concept of parent-linked data structures.\n\n- **Consequences:**\n  - **Performance:** Lookup time is O(n) where n is the depth of nesting (linear search up the chain). For deeply nested scopes, this is slower than the O(1) offset calculation of a flat frame.\n  - **Memory overhead:** Each environment object incurs overhead for the dictionary and parent pointer. However, for an educational interpreter, this is acceptable.\n  - **Ease of debugging:** The chain structure is easy to inspect—printing the chain shows all active bindings at each level.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Linked Environment Chain | Intuitive, simple implementation, natural closures | O(n) lookup time, per-environment overhead | **Yes** |\n| Flat Frame with Display | O(1) lookup, memory-efficient | Complex to implement, harder to debug | No |\n| Single Dictionary with Depth Tags | Simple storage model | Complex depth tracking, inefficient updates | No |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Incorrect Parent Chain Traversal**\n- **Description:** Forgetting to recursively check parent environments when a variable is not found locally, leading to \"undefined variable\" errors for variables that exist in outer scopes.\n- **Why it's wrong:** Breaks lexical scoping—inner scopes cannot access outer variables, making functions and nested blocks unusable.\n- **Fix:** Ensure `get` and `assign` methods contain a loop or recursion that continues searching via the `parent` pointer until either the variable is found or `parent` is `None`.\n\n⚠️ **Pitfall: Confusing Assignment with Definition**\n- **Description:** Using `define` instead of `assign` in assignment statements, causing a new local variable to be created that shadows an outer variable rather than updating the existing one.\n- **Why it's wrong:** Changes program semantics. For example, `x = x + 1` inside a function would create a new local `x` instead of updating the outer `x`, potentially causing unexpected behavior and infinite recursion in some cases.\n- **Fix:** Strictly separate the two operations: `define` only for variable declarations (`var`, `let`, parameters) and `assign` for assignment expressions (`=`).\n\n⚠️ **Pitfall: Improper Scope Creation/Teardown**\n- **Description:** Forgetting to create a new environment when entering a block or function, or failing to restore the previous environment after exiting, causing variable bindings to leak or be lost.\n- **Why it's wrong:** Variables from different scopes interfere with each other, breaking isolation. Local variables might persist after their scope ends or overwrite outer variables.\n- **Fix:** Use a consistent pattern: before evaluating a block, create `new_env = Environment(parent=current_env)`, evaluate statements with `new_env`, then discard `new_env` (return to `current_env`). Consider implementing a context manager or try-finally pattern to ensure cleanup.\n\n⚠️ **Pitfall: Mishandling Closure Environment Capture**\n- **Description:** Setting the parent of a function call's environment to the *caller's* environment instead of the function's *defining* environment.\n- **Why it's wrong:** Breaks closures—functions cannot access variables from their lexical scope if called from a different location.\n- **Fix:** Store the environment active when the function is *defined* as the function's `closure` property. When calling, create a new environment with `function.closure` as its parent.\n\n⚠️ **Pitfall: Not Handling Undefined Variables Gracefully**\n- **Description:** Raising a generic exception or crashing with a stack trace when a variable is not found, making debugging difficult.\n- **Why it's wrong:** Learners need clear, actionable error messages that point to the exact location and name of the undefined variable.\n- **Fix:** Raise an `UndefinedVariableError` with a descriptive message including the variable name and line number (from the token). Ensure this exception is caught and presented cleanly by the interpreter.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Environment Storage | Python `dict` for `store`, class attribute for `parent` | Custom hash map for performance, weak references for parent |\n| Error Reporting | Raise custom exception classes with token context | Add error code, suggestion hints, multilingual messages |\n| Debug Visualization | Simple `__repr__` method printing store contents | Interactive debugger with environment chain inspection |\n\n#### Recommended File Structure\n\nAdd the environment manager to your project structure:\n\n```\ntree-walker-interpreter/\n├── src/\n│   ├── interpreter.py          # Main Interpreter class\n│   ├── evaluator.py            # Core Evaluator class (from previous section)\n│   ├── environment.py          # Environment class (this component)\n│   ├── ast_nodes.py            # AST node definitions\n│   ├── runtime_errors.py       # Custom exception classes\n│   └── tokens.py               # Token class (from lexer)\n└── tests/\n    ├── test_environment.py\n    └── test_evaluation.py\n```\n\n#### Infrastructure Starter Code\n\nThe following complete code provides the foundation for the Environment Manager, including all custom error classes:\n\n```python\n# runtime_errors.py\n\"\"\"Custom runtime error classes for the interpreter.\"\"\"\n\nclass RuntimeError(Exception):\n    \"\"\"Base class for all runtime errors.\"\"\"\n    def __init__(self, message, token):\n        super().__init__(message)\n        self.message = message\n        self.token = token\n    \n    def __str__(self):\n        if self.token:\n            return f\"[Line {self.token.line}] RuntimeError: {self.message}\"\n        return f\"RuntimeError: {self.message}\"\n\nclass UndefinedVariableError(RuntimeError):\n    \"\"\"Raised when trying to access a variable that is not defined.\"\"\"\n    def __init__(self, variable_name, token):\n        message = f\"Undefined variable '{variable_name}'.\"\n        super().__init__(message, token)\n\nclass TypeError(RuntimeError):\n    \"\"\"Raised when operations are applied to incorrect types.\"\"\"\n    def __init__(self, message, token):\n        super().__init__(message, token)\n\nclass DivisionByZeroError(RuntimeError):\n    \"\"\"Raised when dividing by zero.\"\"\"\n    def __init__(self, token):\n        message = \"Division by zero.\"\n        super().__init__(message, token)\n\nclass ArgumentError(RuntimeError):\n    \"\"\"Raised when function is called with wrong number of arguments.\"\"\"\n    def __init__(self, message, token):\n        super().__init__(message, token)\n\nclass ControlFlowSignal(Exception):\n    \"\"\"Base class for non-local control flow (break, continue, return).\"\"\"\n    pass\n\nclass BreakSignal(ControlFlowSignal):\n    \"\"\"Signals a break statement.\"\"\"\n    pass\n\nclass ContinueSignal(ControlFlowSignal):\n    \"\"\"Signals a continue statement.\"\"\"\n    pass\n\nclass ReturnSignal(ControlFlowSignal):\n    \"\"\"Signals a return statement with a value.\"\"\"\n    def __init__(self, value):\n        super().__init__()\n        self.value = value\n```\n\n```python\n# environment.py\n\"\"\"Environment manager for variable storage with lexical scoping.\"\"\"\n\nfrom typing import Any, Dict, Optional\nfrom runtime_errors import UndefinedVariableError\nfrom tokens import Token\n\nclass Environment:\n    \"\"\"\n    A lexical scoping environment mapping variable names to values.\n    \n    Attributes:\n        store: Dictionary of variable bindings in this scope.\n        parent: Parent environment (None for global scope).\n    \"\"\"\n    \n    def __init__(self, parent: Optional['Environment'] = None):\n        \"\"\"\n        Initialize a new environment.\n        \n        Args:\n            parent: The enclosing environment (for lexical scoping).\n        \"\"\"\n        self.store: Dict[str, Any] = {}\n        self.parent: Optional[Environment] = parent\n    \n    def define(self, name: str, value: Any) -> None:\n        \"\"\"\n        Define a new variable in the current environment.\n        \n        Creates or overwrites a binding for `name` in this environment's store.\n        This corresponds to variable declaration (var, let, function parameters).\n        \n        Args:\n            name: Variable name.\n            value: Initial value.\n        \"\"\"\n        # TODO: Implement variable definition\n        # 1. Store the value in self.store with name as key\n        # 2. No need to check for existing binding - shadowing is allowed\n        pass\n    \n    def get(self, name: str) -> Any:\n        \"\"\"\n        Retrieve the value of a variable by walking the environment chain.\n        \n        Searches the current environment, then parent environments recursively.\n        \n        Args:\n            name: Variable name to look up.\n            \n        Returns:\n            The value bound to the variable.\n            \n        Raises:\n            UndefinedVariableError: If the variable is not found in any environment\n                in the chain.\n        \"\"\"\n        # TODO: Implement variable lookup with chain walking\n        # 1. Check if name exists in self.store\n        # 2. If found, return the value\n        # 3. If not found and self.parent is not None, delegate to parent.get(name)\n        # 4. If not found and self.parent is None, raise UndefinedVariableError\n        #    Note: You'll need a Token to raise the error - for now use None,\n        #    the evaluator will pass the actual token.\n        pass\n    \n    def assign(self, name: str, value: Any) -> None:\n        \"\"\"\n        Update an existing variable's value by walking the environment chain.\n        \n        Searches for the variable in the current environment, then parent\n        environments recursively, and updates the first binding found.\n        \n        Args:\n            name: Variable name to assign to.\n            value: New value.\n            \n        Raises:\n            UndefinedVariableError: If the variable is not found in any environment\n                in the chain.\n        \"\"\"\n        # TODO: Implement variable assignment with chain walking\n        # 1. Check if name exists in self.store\n        # 2. If found, update the value in self.store\n        # 3. If not found and self.parent is not None, delegate to parent.assign(name, value)\n        # 4. If not found and self.parent is None, raise UndefinedVariableError\n        pass\n    \n    def get_at(self, distance: int, name: str) -> Any:\n        \"\"\"\n        Advanced: Get a variable at a specific lexical depth.\n        \n        This method is used for optimizing variable access in closures and is\n        not required for the basic implementation. It enables O(1) lookups\n        when the lexical depth is known (from resolver pass).\n        \n        Args:\n            distance: Number of environments to walk up (0 = current).\n            name: Variable name.\n            \n        Returns:\n            The value bound to the variable at that depth.\n        \"\"\"\n        # Optional enhancement for later optimization\n        environment = self\n        for _ in range(distance):\n            if environment.parent is None:\n                break\n            environment = environment.parent\n        return environment.store.get(name)\n    \n    def __repr__(self) -> str:\n        \"\"\"String representation for debugging.\"\"\"\n        parent_repr = f\" -> {self.parent}\" if self.parent else \"\"\n        return f\"Environment({self.store}{parent_repr})\"\n```\n\n#### Core Logic Skeleton Code\n\nHere's how to integrate the environment with variable and block nodes in the evaluator:\n\n```python\n# evaluator.py (additions to the existing Evaluator class)\nfrom environment import Environment\nfrom runtime_errors import UndefinedVariableError\nfrom ast_nodes import VariableExpr, BlockStmt, VarStmt, AssignExpr\n\nclass Evaluator:\n    # ... existing code from previous section ...\n    \n    def evaluate(self, node: 'ASTNode', env: Environment) -> Any:\n        \"\"\"\n        Main dispatch method for AST evaluation.\n        \n        Args:\n            node: The AST node to evaluate.\n            env: The current environment for variable lookup.\n            \n        Returns:\n            The result of evaluating the node.\n        \"\"\"\n        # TODO: Add cases for variable-related nodes to the existing dispatch\n        \n        if isinstance(node, VariableExpr):\n            return self._evaluate_variable_expr(node, env)\n        elif isinstance(node, AssignExpr):\n            return self._evaluate_assign_expr(node, env)\n        elif isinstance(node, VarStmt):\n            return self._evaluate_var_stmt(node, env)\n        elif isinstance(node, BlockStmt):\n            return self._evaluate_block_stmt(node, env)\n        # ... handle other node types from previous section ...\n    \n    def _evaluate_variable_expr(self, node: VariableExpr, env: Environment) -> Any:\n        \"\"\"\n        Evaluate a variable expression (just the name).\n        \n        Args:\n            node: Variable expression node with 'name' and 'token' attributes.\n            env: Current environment.\n            \n        Returns:\n            The value bound to the variable name.\n        \"\"\"\n        # TODO: Implement variable expression evaluation\n        # 1. Call env.get(node.name) to retrieve the value\n        # 2. If UndefinedVariableError is raised, catch it and re-raise with node.token\n        # 3. Return the retrieved value\n        pass\n    \n    def _evaluate_assign_expr(self, node: AssignExpr, env: Environment) -> Any:\n        \"\"\"\n        Evaluate an assignment expression (name = value).\n        \n        Args:\n            node: Assignment expression with 'name', 'value', and 'token' attributes.\n            env: Current environment.\n            \n        Returns:\n            The assigned value (right-hand side).\n        \"\"\"\n        # TODO: Implement assignment expression evaluation\n        # 1. Evaluate the right-hand side expression (node.value) using self.evaluate\n        # 2. Call env.assign(node.name, value) to update the variable\n        # 3. If UndefinedVariableError is raised, catch it and re-raise with node.token\n        # 4. Return the assigned value\n        pass\n    \n    def _evaluate_var_stmt(self, node: VarStmt, env: Environment) -> None:\n        \"\"\"\n        Evaluate a variable declaration statement (var x = value).\n        \n        Args:\n            node: Variable statement with 'name', 'initializer', and 'token' attributes.\n            env: Current environment.\n            \n        Returns:\n            None (statements don't produce values).\n        \"\"\"\n        # TODO: Implement variable declaration\n        # 1. Evaluate the initializer expression if present (node.initializer)\n        #    - If no initializer, use None/nil value\n        # 2. Call env.define(node.name, value) to create the binding\n        # 3. Return None\n        pass\n    \n    def _evaluate_block_stmt(self, node: BlockStmt, env: Environment) -> Any:\n        \"\"\"\n        Evaluate a block of statements in a new nested environment.\n        \n        Args:\n            node: Block statement with 'statements' list attribute.\n            env: Current environment (will become parent of new environment).\n            \n        Returns:\n            The result of the last statement executed, or None if block is empty.\n        \"\"\"\n        # TODO: Implement block evaluation with scope creation\n        # 1. Create a new environment with env as parent: block_env = Environment(env)\n        # 2. Iterate through each statement in node.statements\n        # 3. Evaluate each statement using self.evaluate(statement, block_env)\n        # 4. If a statement raises ReturnSignal, BreakSignal, or ContinueSignal,\n        #    propagate it upward (don't catch it here)\n        # 5. Return the result of the last statement, or None if no statements\n        pass\n```\n\n#### Language-Specific Hints\n\n- **Python dictionaries:** Use Python's built-in `dict` for the store—it's perfect for variable name to value mapping. Remember that dictionary keys must be strings (variable names).\n- **None vs. nil:** In Python, we can use `None` to represent the language's `nil` value. Be consistent throughout the interpreter.\n- **Exception handling:** When catching `UndefinedVariableError` in the evaluator to add token context, use `try-except` and re-raise with the node's token: `raise UndefinedVariableError(e.message, node.token) from e`.\n- **Recursive parent traversal:** Implement `get` and `assign` recursively for clarity, or use a while loop. Recursive implementation closely matches the algorithm description.\n\n#### Milestone Checkpoint\n\nAfter implementing the Environment Manager and integrating it with variable-related AST nodes, test with this program:\n\n```javascript\nvar x = 10;\nvar y = 20;\n{\n  var x = 30;  // Shadows outer x\n  print x;     // Should print 30\n  y = 40;      // Updates outer y\n}\nprint x;       // Should print 10 (outer x unchanged)\nprint y;       // Should print 40\n```\n\n**Expected output:**\n```\n30\n10\n40\n```\n\n**Run the test:**\n```bash\npython src/interpreter.py test_program.txt\n```\n\n**Signs of success:**\n- Program executes without errors.\n- Output matches exactly the expected values.\n- The inner `x` shadows but doesn't affect the outer `x`.\n- The assignment to `y` inside the block updates the outer `y`.\n\n**If something is wrong:**\n- **Variable not found:** Check that `get` walks the parent chain correctly.\n- **Wrong value printed:** Verify that `define` creates in current environment, `assign` updates in the correct environment.\n- **Scope leak:** Ensure the block creates a new environment with the correct parent.\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"Undefined variable\" for variable that exists in outer scope | `get` not checking parent environments | Add debug prints to `get` showing which environment is being checked | Implement recursive parent lookup |\n| Assignment creates new variable instead of updating outer one | Using `define` instead of `assign` in assignment evaluation | Check `_evaluate_assign_expr` calls `env.assign` not `env.define` | Use correct method for assignment |\n| Variable value persists after block exits | Not creating new environment for blocks | Check `_evaluate_block_stmt` creates `Environment(env)` | Create new environment for each block |\n| Inner scope cannot access its own variables | Parent chain reversed (child points to wrong parent) | Print environment chain during lookup | Ensure `Environment(parent)` gets correct parent |\n| All variables return `nil` | Forgetting to evaluate initializer expressions | Check `_evaluate_var_stmt` evaluates `node.initializer` | Evaluate initializer before defining |\n\n---\n\n\n> **Milestone(s):** 3\n>\n> This section details the component responsible for altering the linear flow of program execution. While the Core Evaluator processes expressions in a straightforward recursive descent, real programs require branching, repetition, and non-local jumps. The Control Flow Executor introduces these capabilities, allowing the interpreter to make decisions, loop over code blocks, and exit loops or functions early. This component must integrate seamlessly with the Environment Manager for scoped variable access and the Core Evaluator for condition evaluation, while handling disruptive jumps that violate the normal call-and-return pattern of recursion.\n\n## Component Design: Control Flow Executor\n\n### Mental Model: Railroad Switching Yard\n\nThink of program execution as a train traveling along a single track—the sequence of statements. The **Control Flow Executor** acts as the **railroad switching yard**, dynamically rerouting the train based on signal conditions. A conditional (`if`/`else`) is a **track switch**: the condition is a signal light—if green (truthy), the train takes the main branch; if red (falsy), it takes the alternative siding (or proceeds straight if no `else` exists). Loops are **circular spurs**: the train enters a loop section, completes a lap (executes the loop body), and then returns to the loop's entrance checkpoint (the condition) to receive a new signal. If the signal remains green, it performs another lap; if red, it exits the spur and continues down the main line. Jump statements (`break`, `continue`, `return`) are **emergency rerouting commands** that override the normal track logic: a `break` command immediately escorts the train out of the entire loop spur and back to the main line, a `continue` command teleports it back to the loop's entrance checkpoint for the next signal check, and a `return` command stops the current train entirely and sends a result package back to the previous station (the calling function).\n\nThis model clarifies the key challenge: normal recursion provides a simple \"enter, evaluate, exit\" linear path, but control flow requires short-circuiting this recursion. We need a mechanism to *signal* these emergency reroutes and *unwind* the execution stack until a component (the loop executor or function caller) catches the signal and acts accordingly.\n\n### Interface for Statements and Jumps\n\nStatement evaluation differs fundamentally from expression evaluation. Expressions *produce a value* (e.g., `3 + 4` yields `7`), while statements *perform an action* (e.g., `if (x) print(\"hi\")`) and typically do not produce a value for the surrounding context. Consequently, the `Evaluator.evaluate` method, when processing a statement node, will usually return `None` (or `nil` in the runtime) to indicate the statement completed without a meaningful result. However, jump statements are special: they must communicate a *command* to alter the control flow, which cannot be represented by a normal return value.\n\nTo handle this, we introduce a family of **control flow signal objects** that are thrown (using exception mechanisms in the implementation language) to unwind the call stack. This is a form of **non-local exit**. The `Evaluator.evaluate` method, when encountering a `break`, `continue`, or `return` statement, will raise a corresponding signal object instead of returning normally. The signal propagates up through the recursive evaluation calls until it is caught by a dedicated handler—a loop construct catches `BreakSignal` and `ContinueSignal`, while a function call catches `ReturnSignal`.\n\n| Signal Type | Purpose | Carried Data | Caught By |\n|-------------|---------|--------------|-----------|\n| `BreakSignal` | Exit the nearest enclosing loop immediately. | None | Loop executor (`while`, `for`) |\n| `ContinueSignal` | Skip the remainder of the current loop iteration and jump to the next condition check. | None | Loop executor (`while`, `for`) |\n| `ReturnSignal` | Exit the current function immediately, providing a return value. | `value` (the return value, may be `nil`) | Function call execution in `Evaluator._evaluate_call_expr` |\n\nThis table defines the core interface for jumps. The evaluator's method for statements (`_evaluate_if_stmt`, `_evaluate_while_stmt`, etc.) do not return these signals; they either complete normally (returning `None`) or raise a signal, which bubbles up. The loop and function call handlers are responsible for catching the appropriate signals and acting on them.\n\n### Internal Behavior for Loops and Jumps\n\nThe control flow executor is not a separate class but a set of behaviors within the `Evaluator` class. The following numbered algorithms describe how the evaluator processes each control flow construct. These steps assume the evaluator is already inside the `evaluate` method and has dispatched to the specific handler based on the AST node type.\n\n#### Algorithm for `if` Statement Evaluation\n1.  **Evaluate Condition:** Call `evaluate(node.condition, env)`. This returns a runtime value.\n2.  **Determine Truthiness:** Apply the interpreter's **truthiness** rules to the condition value. In our language, the rules are: `nil` and `false` are falsy; every other value (including `0`, `\"\"`, and `true`) is truthy.\n3.  **Choose Branch:** If the condition is truthy, set `branch_to_execute = node.then_branch`. Otherwise, if an `else` branch exists (`node.else_branch` is not `None`), set `branch_to_execute = node.else_branch`. If no `else` branch exists, the `if` statement is complete; return `None`.\n4.  **Execute Chosen Branch:** Call `evaluate(branch_to_execute, env)`. This may be a single statement or a block. The result of this evaluation (which could be a raised signal) is returned/propagated directly.\n\n#### Algorithm for `while` Loop Evaluation\nRefer to the state machine diagram for a visual overview of this process: ![State Machine: While Loop Execution](./diagrams/state-machine-loop.svg)\n\n1.  **Check Condition:** Evaluate `node.condition` in the current environment. If the result is falsy, exit the loop (proceed to step 5).\n2.  **Execute Body:** Evaluate `node.body` in the current environment. This execution occurs within a **protected context** that catches `BreakSignal` and `ContinueSignal`.\n    *   If the body completes normally, proceed to step 3.\n    *   If a `BreakSignal` is raised, catch it and immediately exit the loop (proceed to step 5). Do not propagate the signal further.\n    *   If a `ContinueSignal` is raised, catch it and proceed directly to step 3 (next iteration). Do not propagate the signal further.\n    *   If a `ReturnSignal` (or any other unhandled exception) is raised, do not catch it; allow it to propagate outward (this will exit the enclosing function).\n3.  **Loop Continuation:** After completing the body (or catching a `continue`), the loop naturally returns to step 1 to re-evaluate the condition.\n4.  **Loop Termination:** When the condition evaluates to falsy, proceed to the next step.\n5.  **Post-Loop:** The `while` statement completes. Return `None`.\n\n#### Algorithm for `for` Loop Evaluation (via Desugaring)\nOur interpreter implements `for` loops by **desugaring** them into equivalent `while` loop AST structures during the parsing phase (not during evaluation). This simplifies the evaluator, as it only needs to handle the primitive `while` construct. The desugaring follows this pattern:\n```\n// Original: for (initializer; condition; increment) { body; }\n// Desugared:\n{\n    initializer;\n    while (condition) {\n        body;\n        increment;\n    }\n}\n```\nNote the addition of an outer block `{ ... }` to ensure any variables declared in the `initializer` are scoped to the loop. Therefore, the evaluator's `_evaluate_for_stmt` method simply evaluates the already-desugared AST. If the parser performs the desugaring, this method may not be needed at all. However, if evaluation-time desugaring is preferred, the algorithm is:\n1.  **Create New Scope:** Create a new environment `loop_env` with the current environment as its parent. This ensures the loop variable (if declared in the initializer) is scoped to the loop.\n2.  **Execute Initializer:** If `node.initializer` exists, evaluate it within `loop_env`.\n3.  **Construct While Loop:** Build a `while` loop AST node where:\n    *   `condition` is `node.condition` (or a literal `true` if absent).\n    *   `body` is a block containing the original `node.body` followed by `node.increment` (if present).\n4.  **Evaluate While Loop:** Evaluate the constructed `while` node within `loop_env`.\n5.  **Return Result:** Return the result (typically `None`) from the while loop evaluation.\n\n#### Algorithm for Handling `return` Statement\nThe `return` statement is evaluated within the body of a function.\n1.  **Evaluate Value:** If `node.value` exists, evaluate it in the current environment to obtain the `return_value`. Otherwise, `return_value` is `nil`.\n2.  **Raise Signal:** Raise a `ReturnSignal` object, storing the `return_value` within it. This signal will propagate up through any nested blocks and loops until caught by the function call handler.\n\n### ADR: Handling Break/Continue\n\n> **Decision: Use Exception Mechanism for Control Flow Jumps**\n>\n> - **Context**: We need a way for `break` and `continue` statements inside a loop body to immediately affect the loop's execution, bypassing the normal sequential completion of the remaining statements in the body. This requires exiting multiple levels of nested AST evaluation calls (e.g., a `break` inside a block inside an `if` inside a loop must exit the loop, not just the `if`). We must choose a mechanism that cleanly unwinds the execution stack to the loop handler.\n> - **Options Considered**:\n>     1.  **Exception/Signal Objects**: Raise a special object (e.g., `BreakSignal`) and catch it at the loop level. This leverages the language's native stack-unwinding mechanism.\n>     2.  **Explicit Status Flag Propagation**: Have each evaluator method return a tuple `(value, status)`, where `status` indicates \"break\", \"continue\", \"normal\", etc. The caller checks the status and propagates it upward manually.\n>     3.  **Continuation Passing Style (CPS)**: Transform the evaluator to accept explicit success and \"jump\" callbacks, completely avoiding deep call stacks. This is a more advanced functional technique.\n> - **Decision**: We will use **exception/signal objects** (Option 1).\n> - **Rationale**:\n>     *   **Simplicity for Learners**: Exception handling is a common, well-understood control flow mechanism in most imperative languages. The concept of \"throwing\" a signal and \"catching\" it at a higher level is intuitive for the railroad switching yard mental model.\n>     *   **Clean Separation of Concerns**: The loop evaluation logic can be written as a clear `try-catch` block, isolating the jump-handling code. This makes the control flow explicit and easy to debug.\n>     *   **Performance is Secondary**: For an educational tree-walking interpreter, raw performance is less critical than clarity. While exceptions can be slower than flag checking in tight loops, the overhead is acceptable for our goals.\n>     *   **Consistency with `return`**: The same mechanism naturally extends to `return` statements, which must unwind even further (out of function bodies). Using a unified signal class hierarchy (`ControlFlowSignal`) provides consistency.\n> - **Consequences**:\n>     *   **Positive**: Clear, idiomatic code; easy to implement and understand; matches the \"non-local exit\" semantics perfectly.\n>     *   **Negative**: Requires careful design to ensure signals are not accidentally caught by the wrong handler (e.g., a `BreakSignal` escaping a function). Must ensure only loops catch `break`/`continue` and only function calls catch `return`.\n>     *   **Language Dependency**: The implementation relies on the host language's exception mechanism (try/catch in Python/JavaScript/Java). This is portable across our target languages.\n\nThe following table compares the options:\n\n| Option | Pros | Cons | Suitable for Learning? |\n|--------|------|------|------------------------|\n| **Exception/Signal Objects** | Clean stack unwinding; Intuitive analogy; Easy to implement; Consistent with `return`. | Slight performance overhead; Requires careful catch-scoping to avoid mishandling. | ✅ **Yes** – clear, common pattern. |\n| **Explicit Status Flag** | No exception overhead; Full control flow visible in return values. | Significantly more complex code; Every evaluator method must check and propagate status; Obscures main logic. | ❌ No – adds pervasive boilerplate that distracts from core concepts. |\n| **Continuation Passing Style** | No deep call stacks; Enables advanced features (coroutines, true tail-calls). | Major paradigm shift; Highly complex to implement and understand; Overkill for simple loops. | ❌ No – too advanced for an intermediate project. |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Infinite Loops from Non-Mutating Conditions**\n*   **Description**: Writing a `while` loop whose condition expression never becomes falsy because no variable inside it changes within the loop body. For example, `while (x > 0) { print(\"hi\"); }` where `x` is never decremented.\n*   **Why It's Wrong**: The interpreter will hang, repeatedly evaluating the same truthy condition. This is a logical error in the user's program, but our interpreter must still be able to run it (and the user must be able to stop it with Ctrl+C).\n*   **How to Avoid**: This is a programmer error, not an interpreter bug. However, during testing, ensure your evaluator doesn't have an infinite loop due to incorrectly *evaluating* the condition (e.g., always returning `true`). Use a timeout in your test harness for safety.\n\n⚠️ **Pitfall: Incorrect Truthiness Rules**\n*   **Description**: Implementing custom truthiness rules that differ from the language specification. For example, treating the number `0` or empty string `\"\"` as falsy (like in some languages) when our spec defines them as truthy.\n*   **Why It's Wrong**: Programs will behave unexpectedly, causing subtle bugs in conditionals and loops. Consistency with the defined language semantics is critical.\n*   **How to Fix**: Implement a dedicated `_is_truthy(value)` helper function that encodes exactly: return `False` only if the value is `nil` or the boolean `False`; return `True` for all other values (numbers, strings, `True`, functions, etc.).\n\n⚠️ **Pitfall: Mis-scoping Loop Variables (The \"For Loop Variable Leak\")**\n*   **Description**: When evaluating a `for` loop, failing to create a new nested environment for the initializer. This causes a variable declared in the `for (var i = 0; ...)` to persist in the outer scope after the loop ends, and worse, if the loop is nested, inner loops may incorrectly share the same `i` variable.\n*   **Why It's Wrong**: Violates lexical scoping principles. The loop variable should be local to the loop. This can lead to unintended variable shadowing or modification.\n*   **How to Fix**: Ensure the `for` loop's initializer (if it's a variable declaration) is executed inside a new environment whose parent is the surrounding scope. The `while` loop condition and body must also use this new environment. This is handled automatically if you desugar correctly with an outer block.\n\n⚠️ **Pitfall: Accidentally Catching the Wrong Signal**\n*   **Description**: Using a generic `except ControlFlowSignal:` clause in a loop handler, which catches `ReturnSignal` as well as `BreakSignal`/`ContinueSignal`. This would prevent a `return` statement inside a loop from exiting the enclosing function.\n*   **Why It's Wrong**: `return` must propagate out of loops to the function call. Catching it traps the function, causing it to incorrectly continue looping or return `nil`.\n*   **How to Fix**: Catch only the specific signal types (`BreakSignal`, `ContinueSignal`) in the loop handler. Let `ReturnSignal` and other exceptions propagate upward. Use separate `except` clauses or explicit type checking.\n\n⚠️ **Pitfall: Forgetting to Return a Value from `_evaluate_if_stmt`**\n*   **Description**: The `if` statement handler evaluates the chosen branch but does not explicitly return the result of that evaluation. In many languages, a function/method without a return statement implicitly returns `None`. This can break if the branch contains a `return` statement whose `ReturnSignal` needs to be propagated.\n*   **Why It's Wrong**: If the branch raises a `ReturnSignal`, the `if` statement handler must re-raise it (or let it propagate). If the handler simply returns `None` after catching the signal (or doesn't propagate it), the return is lost and the function won't exit.\n*   **How to Fix**: Ensure the result of evaluating the branch (`evaluate(branch_to_execute, env)`) is returned directly from the `if` handler. Do not catch signals unless you intend to handle them.\n\n### Implementation Guidance\n\n**Technology Recommendations:**\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Control Flow Signals | Custom exception classes inheriting from `Exception` (Python) or `Error` (JavaScript). | A dedicated `ControlFlowSignal` base class with a `type` enum to avoid many subclasses (less Pythonic). |\n| Loop Control | `try...except` blocks with precise exception types. | A custom `LoopContext` manager class that encapsulates signal handling, enabling `with` statement usage. |\n\n**Recommended File/Module Structure:**\n```\ninterpreter/\n├── ast.py               # AST node class definitions (already exists)\n├── environment.py       # Environment class (already exists)\n├── evaluator.py         # Evaluator class (add control flow methods here)\n├── interpreter.py       # Main Interpreter class (orchestrates parsing/evaluation)\n└── exceptions.py        # New file: RuntimeError and ControlFlowSignal definitions\n```\n\n**Infrastructure Starter Code (COMPLETE - exceptions.py):**\nThis file defines the signal classes used for non-local exits. Place this in `exceptions.py`.\n```python\nclass RuntimeError(Exception):\n    \"\"\"Base class for all runtime errors.\"\"\"\n    def __init__(self, message, token):\n        self.message = message\n        self.token = token\n        super().__init__(self.message)\n\nclass UndefinedVariableError(RuntimeError):\n    pass\n\nclass TypeError(RuntimeError):\n    pass\n\nclass DivisionByZeroError(RuntimeError):\n    pass\n\nclass ArgumentError(RuntimeError):\n    pass\n\n# --- Control Flow Signals (NOT errors, but use same exception mechanism) ---\nclass ControlFlowSignal(Exception):\n    \"\"\"Base for break, continue, return signals. Not an error.\"\"\"\n    pass\n\nclass BreakSignal(ControlFlowSignal):\n    \"\"\"Raised to break out of a loop.\"\"\"\n    pass\n\nclass ContinueSignal(ControlFlowSignal):\n    \"\"\"Raised to skip to next loop iteration.\"\"\"\n    pass\n\nclass ReturnSignal(ControlFlowSignal):\n    \"\"\"Raised to return from a function.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        super().__init__()\n```\n\n**Core Logic Skeleton Code (Evaluator methods in evaluator.py):**\nAdd these methods to the `Evaluator` class. They assume the AST node classes have attributes like `condition`, `then_branch`, `else_branch`, `body`, `initializer`, `increment`, and `value`. Also assume a helper `_is_truthy(value)`.\n\n```python\ndef _evaluate_if_stmt(self, node, env):\n    \"\"\"\n    Evaluate an if/else statement.\n    Returns: The result of executing the chosen branch (may be a raised signal).\n    \"\"\"\n    # TODO 1: Evaluate the condition expression using self.evaluate\n    # TODO 2: Use self._is_truthy to test the condition result\n    # TODO 3: If truthy, set branch = node.then_branch\n    # TODO 4: Else, if node.else_branch exists, set branch = node.else_branch\n    # TODO 5: If no else branch and condition falsy, return None (if statement completes)\n    # TODO 6: If a branch was selected, evaluate it with self.evaluate and return that result\n    pass\n\ndef _evaluate_while_stmt(self, node, env):\n    \"\"\"\n    Evaluate a while loop.\n    Returns: None (loops do not produce a value).\n    \"\"\"\n    # TODO 1: Enter a loop: while True:\n    # TODO 2:   Evaluate the condition expression using self.evaluate\n    # TODO 3:   If condition is falsy (not self._is_truthy), break out of the loop\n    # TODO 4:   Try to evaluate the body (node.body) using self.evaluate within a try-except\n    # TODO 5:     If a BreakSignal is caught, break out of the outer loop\n    # TODO 6:     If a ContinueSignal is caught, continue to the next iteration (skip rest of body)\n    # TODO 7:     If a ReturnSignal is caught, re-raise it (propagate upward)\n    # TODO 8:     If any other exception is raised, let it propagate\n    # TODO 9: After loop exits, return None\n    pass\n\ndef _evaluate_for_stmt(self, node, env):\n    \"\"\"\n    Evaluate a for loop (by desugaring into a while loop).\n    This assumes the parser did NOT desugar; we do it at evaluation time.\n    For simplicity, we recommend parser-level desugaring; if so, this method is not needed.\n    \"\"\"\n    # TODO 1: Create a new environment loop_env with parent 'env'\n    # TODO 2: If node.initializer exists, evaluate it in loop_env\n    # TODO 3: Build a while loop AST node (may need to construct manually):\n    #         condition = node.condition if exists, else a literal True node\n    #         body_ast = a block containing [node.body, node.increment] (if increment exists)\n    # TODO 4: Evaluate the constructed while loop node in loop_env\n    # TODO 5: Return the result (should be None)\n    pass\n\ndef _evaluate_break_stmt(self, node, env):\n    \"\"\"Evaluate a break statement by raising a BreakSignal.\"\"\"\n    # TODO 1: Raise BreakSignal()\n    pass\n\ndef _evaluate_continue_stmt(self, node, env):\n    \"\"\"Evaluate a continue statement by raising a ContinueSignal.\"\"\"\n    # TODO 1: Raise ContinueSignal()\n    pass\n\ndef _evaluate_return_stmt(self, node, env):\n    \"\"\"Evaluate a return statement by raising a ReturnSignal with the value.\"\"\"\n    # TODO 1: If node.value exists, evaluate it to get return_value\n    # TODO 2: Else, set return_value = None (or nil)\n    # TODO 3: Raise ReturnSignal(return_value)\n    pass\n\n# Helper method for truthiness\ndef _is_truthy(self, value):\n    \"\"\"\n    Determine truthiness of a runtime value.\n    Returns: False only for nil and False; True for everything else.\n    \"\"\"\n    # TODO 1: If value is None (nil) or False, return False\n    # TODO 2: Otherwise, return True\n    pass\n```\n\n**Language-Specific Hints (Python):**\n- Use `try:` ... `except BreakSignal:` ... `except ContinueSignal:` to catch specific signals.\n- When re-raising a `ReturnSignal`, simply use `raise` without arguments inside the `except ReturnSignal:` block, or don't catch it at all.\n- Remember that `0`, `\"\"`, and `[]` are truthy in our language, so `bool(value)` is NOT sufficient for `_is_truthy`. Implement the exact rule.\n- For constructing AST nodes during desugaring, you may need to import the AST node classes from your `ast` module and create instances manually (e.g., `ast.While(condition, body)`). This is advanced; parser desugaring is simpler.\n\n**Milestone Checkpoint (Testing Control Flow):**\nAfter implementing the above, run a test program that exercises all control flow features. For example:\n```javascript\n// test_control_flow.lox (or similar)\nvar i = 0;\nwhile (i < 3) {\n    if (i == 1) {\n        print \"Skipping 1\";\n        i = i + 1;\n        continue;\n    }\n    print i;\n    if (i == 2) {\n        print \"Breaking at 2\";\n        break;\n    }\n    i = i + 1;\n}\nprint \"Loop finished\";\n\n// Expected output:\n// 0\n// Skipping 1\n// 2\n// Breaking at 2\n// Loop finished\n```\nAlso test nested loops, `return` inside a loop, and `for` loop variable scoping. Use your interpreter's `interpret` method and verify the output matches. If you get an infinite loop, check your condition evaluation and variable updates. If `break` or `continue` doesn't work, ensure you are raising and catching the correct signals.\n\n**Debugging Tips:**\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Loop runs forever, no output. | Condition never becomes falsy. | Print the condition value each iteration. Check if variables in condition are being updated. | Ensure loop body modifies variables used in condition. |\n| `break` or `continue` is ignored; loop continues as normal. | Signal not being raised, or being caught by wrong handler. | Add print before raising signal. Add print in loop's except block to see if caught. | Ensure `_evaluate_break_stmt` raises `BreakSignal()`, and loop handler catches it. |\n| `return` inside a loop causes function to return wrong value or not exit. | Loop handler catching `ReturnSignal`. | Check your `except` clauses; you may have a generic `except ControlFlowSignal`. | Catch only `BreakSignal` and `ContinueSignal` in loop. Let `ReturnSignal` propagate. |\n| Variable declared in `for` loop persists after loop. | No new environment created for loop initializer. | Print environment chain before/after loop. See if variable exists in outer env. | Ensure `for` loop desugaring creates a new block scope. |\n\n\n## Component Design: Function Manager\n\n> **Milestone(s):** 4\n\nThe Function Manager is the component that breathes life into our interpreter by enabling reusable, parameterized blocks of code. This system transforms static function definitions into dynamic, callable values that can capture and remember their surrounding context, enabling powerful programming patterns like recursion, higher-order functions, and closures. Implementing this component requires carefully weaving together the **Environment chain** for lexical scoping with the **Evaluator**'s recursive traversal and the **AST**'s representation of function bodies.\n\n### Mental Model: Recipe with Personal Ingredients\n\nImagine a function as a **recipe card** you write while cooking in your kitchen. The recipe has:\n1. **A name** (optional, like \"Grandma's Cookies\")\n2. **A list of ingredients you need to provide** (the parameters)\n3. **Step-by-step instructions** (the function body)\n\nWhen you decide to follow the recipe (call the function), you:\n- **Grab a fresh mixing bowl** (create a new local environment)\n- **Measure out your specific ingredients** (bind arguments to parameters in that bowl)\n- **Follow the steps** (execute the body in the new environment)\n\nCrucially, while following the recipe, you can also **reach into your own pantry** (access variables from the surrounding kitchen/closure environment). Even if you later move to a different kitchen, you remember which pantry you were using when you wrote down the recipe. This \"pantry capture\" is what makes closures work: the function remembers the environment where it was defined, not where it's called.\n\nThis model illustrates three key concepts:\n- **Definition vs. Call**: Writing the recipe vs. actually baking\n- **Parameter Binding**: Each call gets its own fresh set of ingredients\n- **Closure Capture**: The function remembers the environment (pantry) it came from\n\n### Interface: Callable Values and Closure\n\nFunctions are **first-class values** in our interpreter, meaning they can be assigned to variables, passed as arguments, and returned from other functions. This requires a runtime representation that encapsulates everything needed to execute the function later.\n\n#### FunctionValue Data Structure\n\nThe `FunctionValue` type represents a callable function at runtime:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `name` | `Optional[str]` | The function's declared name (for recursion and debugging). Anonymous functions have `None`. |\n| `parameters` | `List[str]` | Ordered list of parameter names. Empty list for functions that take no arguments. |\n| `body` | `ASTNode` | The function body, typically a `Block` statement containing the code to execute. |\n| `closure` | `Environment` | The **defining environment**—the environment active when the function was created. This enables lexical closures. |\n\n#### Callable Interface\n\nThe `FunctionValue` implements a single public operation:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `call` | `arguments: List[Any]` | `Any` (the return value) | Executes the function with the provided arguments. Creates a new environment, binds arguments to parameters, evaluates the body, and returns the result. |\n\nThis simple interface hides the complexity of environment creation, argument binding, and body evaluation behind a single method call.\n\n### Internal Behavior: Call and Return\n\nExecuting a function call involves multiple coordinated steps across the evaluator, environment system, and AST. Here's the complete algorithm:\n\n#### 1. Function Definition Evaluation\n\nWhen the evaluator encounters a function declaration statement:\n\n1. **Extract definition components**: From the AST node, get the function name, parameter list, and body statement.\n2. **Create a FunctionValue**: Instantiate a new `FunctionValue` with:\n   - The extracted name and parameters\n   - The body AST node\n   - The **current environment** as the `closure` field (this captures the defining scope)\n3. **Bind to name**: In the current environment, call `Environment.define()` to create a binding between the function name and the `FunctionValue`.\n4. **Return nothing**: Function declarations don't produce a value at the statement level (they return `None`/nil).\n\n#### 2. Function Call Evaluation\n\nWhen evaluating a call expression like `add(2, 3)`:\n\n1. **Evaluate the callee**: Recursively evaluate the expression before the parentheses (could be a variable name, property access, or another call).\n2. **Validate callee type**: Ensure the result is a `FunctionValue`. If not, raise a `TypeError`.\n3. **Evaluate arguments**: For each argument expression in the parentheses, evaluate it in the **caller's environment** (left-to-right evaluation order).\n4. **Check arity**: Compare the number of arguments to the number of parameters. If they don't match, raise an `ArgumentError`.\n5. **Create call environment**: Instantiate a new `Environment` with the function's `closure` environment as its parent. This establishes the lexical scope chain.\n6. **Bind parameters**: For each parameter name at index `i`, call `Environment.define()` in the new environment to bind it to the corresponding argument value.\n7. **Execute the body**: Call `Evaluator.evaluate()` on the function's body node, passing the new call environment.\n8. **Handle the return**: The body evaluation may complete normally or exit early via a `ReturnSignal`. \n   - If a `ReturnSignal` is caught, extract and return its value.\n   - If the body completes without a return statement, return `nil` (implicit return).\n9. **Clean up**: The call environment becomes eligible for garbage collection (though Python handles this automatically).\n\n#### 3. Return Statement Handling\n\nThe `return` statement introduces **non-local exit**—it needs to unwind through potentially multiple nested evaluations to deliver a value back to the original call site. Our implementation uses an exception-like control flow signal:\n\n1. **Evaluate return value**: If the return statement has an expression, evaluate it in the current environment.\n2. **Raise ReturnSignal**: Create a `ReturnSignal` with the return value and raise it (as an exception in Python).\n3. **Unwind through scopes**: The signal propagates up through nested block evaluations until caught by the function call handler.\n4. **Stop propagation**: Once caught, the signal is not re-raised; the function returns the value.\n\n> **Key Insight**: The `ReturnSignal` must only be catchable by the function call evaluation logic—not by loop constructs or other control flow handlers. This ensures `return` works correctly inside nested loops and conditionals within a function body.\n\n![Sequence Diagram: Function Call with Closure](./diagrams/seq-function-call.svg)\n\n### ADR: Closure Capture Strategy\n\n> **Decision: Store Defining Environment in Function Object**\n> - **Context**: We need to support lexical closures where functions can access variables from their surrounding scope, even after that scope has exited. The interpreter must decide which environment to use as the parent when creating the call environment.\n> - **Options Considered**:\n>   1. **Dynamic Scoping**: Use the caller's environment as the parent for the call environment.\n>   2. **Lexical Closures**: Store the environment where the function was *defined* and use that as the parent for all calls.\n>   3. **Hybrid Approach**: Store both defining and calling environments with complex resolution rules.\n> - **Decision**: Implement **lexical closures** by storing the defining environment in the `FunctionValue.closure` field.\n> - **Rationale**:\n>   - **Predictability**: Lexical scoping is what modern programmers expect—variable resolution depends on where the function was written, not where it's called.\n>   - **Encapsulation**: Functions maintain consistent behavior regardless of calling context, enabling reliable abstraction.\n>   - **Industry Standard**: JavaScript, Python, and most modern languages use lexical closures.\n>   - **Simplicity**: The implementation is straightforward—capture one environment reference at definition time.\n> - **Consequences**:\n>   - **Positive**: Enables powerful functional programming patterns (closures, higher-order functions).\n>   - **Positive**: Functions behave consistently, aiding debuggability.\n>   - **Negative**: The defining environment must stay alive as long as any function referencing it exists (memory consideration).\n>   - **Negative**: Slightly more complex than dynamic scoping but much more useful.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Dynamic Scoping | Simpler implementation, smaller memory footprint | Unintuitive behavior, breaks encapsulation, not standard | ❌ |\n| Lexical Closures | Predictable, enables powerful patterns, industry standard | Must maintain environment references, slightly more complex | ✅ |\n| Hybrid Approach | Maximum flexibility, can simulate both | Very complex, confusing semantics, hard to debug | ❌ |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Forgetting to Capture the Defining Environment**\n- **Description**: Creating a `FunctionValue` with `closure=None` or using the global environment for all functions.\n- **Why it's wrong**: Functions won't be able to access variables from their surrounding scope, breaking closure behavior. `inner()` in nested functions will fail.\n- **Fix**: Always pass the **current environment at definition time** as the `closure` parameter when creating a `FunctionValue`.\n\n⚠️ **Pitfall: Using the Wrong Parent for Call Environment**\n- **Description**: Setting the new call environment's parent to the caller's current environment instead of the function's closure environment.\n- **Why it's wrong**: Breaks lexical scoping—functions see variables from where they're called, not where they're defined.\n- **Fix**: Always create the call environment with `parent=function_value.closure`.\n\n⚠️ **Pitfall: Mishandling Implicit Returns**\n- **Description**: Forgetting that functions should return `nil` when execution reaches the end without encountering a `return` statement.\n- **Why it's wrong**: Function calls that don't explicitly return a value will return whatever the last expression evaluated to (which might be a statement value like `None` from a variable declaration).\n- **Fix**: After evaluating the function body, if no `ReturnSignal` was caught, explicitly return `nil` (or `None` in Python).\n\n⚠️ **Pitfall: Incorrect Return Signal Propagation**\n- **Description**: Catching `ReturnSignal` in the wrong place (e.g., in loop handlers) or failing to re-raise it after catching.\n- **Why it's wrong**: `return` statements inside loops won't work properly, or return signals might escape function boundaries.\n- **Fix**: Only catch `ReturnSignal` in the function call evaluation logic. Don't catch it in block, loop, or conditional evaluation.\n\n⚠️ **Pitfall: Not Validating Argument Count**\n- **Description**: Allowing calls with too few or too many arguments without error checking.\n- **Why it's wrong**: Functions with missing parameters will reference undefined variables; extra arguments are silently ignored.\n- **Fix**: Before binding arguments, compare `len(arguments)` with `len(function_value.parameters)`. Raise an `ArgumentError` on mismatch.\n\n⚠️ **Pitfall: Evaluating Arguments in Wrong Environment**\n- **Description**: Evaluating argument expressions in the new call environment instead of the caller's environment.\n- **Why it's wrong**: Arguments can't reference the function's own parameters (which aren't bound yet), breaking patterns like `func(x, x*2)`.\n- **Fix**: Evaluate all argument expressions in the **caller's current environment** before creating the call environment.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Function Representation | Python class with fields | Named tuple or dataclass |\n| Closure Capture | Store environment reference | Environment copying for security |\n| Return Mechanism | Python exceptions for non-local exit | Return value propagation with explicit stack |\n| Arity Checking | Simple length comparison | Default parameters, variadic functions |\n\n#### B. Recommended File/Module Structure\n\n```\ninterpreter/\n├── __init__.py\n├── ast_nodes.py           # AST node definitions (from previous milestone)\n├── environment.py         # Environment class (from Milestone 2)\n├── evaluator.py           # Core Evaluator class (from Milestone 1)\n├── function_value.py      # NEW: FunctionValue class and call logic\n├── control_flow.py        # Control flow signals (from Milestone 3)\n├── runtime_errors.py      # Error classes (RuntimeError, TypeError, etc.)\n├── interpreter.py         # Main Interpreter class tying everything together\n└── tests/\n    ├── test_evaluator.py\n    ├── test_environment.py\n    └── test_functions.py  # NEW: Tests for functions and closures\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete `runtime_errors.py` (expanded for function errors):**\n\n```python\n\"\"\"Runtime error classes for the interpreter.\"\"\"\n\nclass RuntimeError(Exception):\n    \"\"\"Base class for all runtime errors.\"\"\"\n    def __init__(self, message, token=None):\n        self.message = message\n        self.token = token\n        super().__init__(self.message)\n\nclass UndefinedVariableError(RuntimeError):\n    \"\"\"Raised when trying to access an undefined variable.\"\"\"\n    pass\n\nclass TypeError(RuntimeError):\n    \"\"\"Raised when operations are applied to incorrect types.\"\"\"\n    pass\n\nclass DivisionByZeroError(RuntimeError):\n    \"\"\"Raised when dividing by zero.\"\"\"\n    pass\n\nclass ArgumentError(RuntimeError):\n    \"\"\"Raised when function is called with wrong number of arguments.\"\"\"\n    pass\n\n# Control flow signals (from Milestone 3, kept for completeness)\nclass ControlFlowSignal(Exception):\n    \"\"\"Base class for break/continue/return signals.\"\"\"\n    pass\n\nclass BreakSignal(ControlFlowSignal):\n    \"\"\"Signals a break statement.\"\"\"\n    pass\n\nclass ContinueSignal(ControlFlowSignal):\n    \"\"\"Signals a continue statement.\"\"\"\n    pass\n\nclass ReturnSignal(ControlFlowSignal):\n    \"\"\"Signals a return statement with a value.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        super().__init__()\n```\n\n**Complete `function_value.py`:**\n\n```python\n\"\"\"Function value representation and call logic.\"\"\"\n\nfrom typing import List, Optional, Any\nfrom environment import Environment\nfrom runtime_errors import ArgumentError, TypeError\n\nclass FunctionValue:\n    \"\"\"Runtime representation of a function.\"\"\"\n    \n    def __init__(self, name: Optional[str], parameters: List[str], \n                 body: 'ASTNode', closure: Environment):\n        self.name = name  # Optional function name for recursion\n        self.parameters = parameters  # List of parameter names\n        self.body = body  # AST node for the function body\n        self.closure = closure  # The environment where the function was defined\n        \n    def call(self, arguments: List[Any]) -> Any:\n        \"\"\"\n        Execute the function with given arguments.\n        \n        Args:\n            arguments: Evaluated argument values\n            \n        Returns:\n            The function's return value\n            \n        Raises:\n            ArgumentError: If argument count doesn't match parameter count\n        \"\"\"\n        # TODO 1: Check argument count matches parameter count\n        # TODO 2: Create new environment with closure as parent\n        # TODO 3: Bind each parameter to corresponding argument\n        # TODO 4: Evaluate the body in the new environment\n        # TODO 5: Return the result (or nil if no return statement)\n        pass\n    \n    def __str__(self) -> str:\n        \"\"\"String representation for debugging.\"\"\"\n        if self.name:\n            return f\"<function {self.name}>\"\n        return \"<anonymous function>\"\n```\n\n#### D. Core Logic Skeleton Code\n\n**In `evaluator.py` (add to existing Evaluator class):**\n\n```python\n# Add these imports at the top\nfrom function_value import FunctionValue\nfrom runtime_errors import ReturnSignal, ArgumentError, TypeError\n\nclass Evaluator:\n    # ... existing code from previous milestones ...\n    \n    def _evaluate_function_decl(self, node, env):\n        \"\"\"\n        Evaluate a function declaration statement.\n        \n        Args:\n            node: FunctionDecl AST node with fields:\n                - name: str (function name)\n                - params: List[str] (parameter names)\n                - body: ASTNode (function body)\n            env: Current environment\n            \n        Returns:\n            None (function declarations don't produce values)\n        \"\"\"\n        # TODO 1: Extract function name, parameters, and body from node\n        # TODO 2: Create a FunctionValue with:\n        #         - The extracted name and parameters\n        #         - The body node  \n        #         - Current environment as closure (for lexical scope)\n        # TODO 3: Define the function name in the current environment\n        #         env.define(function_name, function_value)\n        # TODO 4: Return None (function declarations are statements)\n        pass\n    \n    def _evaluate_call_expr(self, node, env):\n        \"\"\"\n        Evaluate a function call expression.\n        \n        Args:\n            node: CallExpr AST node with fields:\n                - callee: ASTNode (expression evaluating to function)\n                - args: List[ASTNode] (argument expressions)\n            env: Current environment\n            \n        Returns:\n            The return value from the function call\n            \n        Raises:\n            TypeError: If callee is not a function\n            ArgumentError: If argument count mismatch\n        \"\"\"\n        # TODO 1: Evaluate the callee expression to get the function value\n        # TODO 2: Check if callee is a FunctionValue, raise TypeError if not\n        # TODO 3: Evaluate ALL argument expressions in the current environment\n        #         (left to right, store in a list)\n        # TODO 4: Call function_value.call(arguments) and return the result\n        # Hint: The call() method handles environment creation and body evaluation\n        pass\n    \n    def _evaluate_return_stmt(self, node, env):\n        \"\"\"\n        Evaluate a return statement.\n        \n        Args:\n            node: ReturnStmt AST node with field:\n                - value: Optional[ASTNode] (return value expression)\n            env: Current environment\n            \n        Returns:\n            Never returns normally—always raises ReturnSignal\n            \n        Raises:\n            ReturnSignal: With the return value (or nil)\n        \"\"\"\n        # TODO 1: Check if return has a value expression\n        # TODO 2: If yes, evaluate it in the current environment\n        # TODO 3: If no, use nil/None as the return value\n        # TODO 4: Raise ReturnSignal(value)\n        # Important: This method should NOT catch ReturnSignal itself\n        pass\n```\n\n#### E. Language-Specific Hints\n\n**Python Tips:**\n- Use `isinstance(value, FunctionValue)` for type checking\n- Catch `ReturnSignal` with `except ReturnSignal as signal:` and access `signal.value`\n- Remember Python's `None` represents our `nil` value\n- For recursion: functions call themselves by name, which works because the function name is bound in the environment before the function value is fully created\n\n**Key Implementation Pattern for Recursion:**\n```python\n# When evaluating a function declaration:\nfunction_value = FunctionValue(name, params, body, env)\n# Define the name IN THE SAME ENVIRONMENT (env.define)\n# This allows the function to reference itself in its body\nenv.define(name, function_value)\n```\n\n#### F. Milestone Checkpoint\n\nAfter implementing the Function Manager, test with this program:\n\n```javascript\n// Test program: functions_test.lox\nfunction factorial(n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}\n\nprint factorial(5);  // Should print: 120\n\nfunction makeCounter() {\n    var i = 0;\n    function count() {\n        i = i + 1;\n        return i;\n    }\n    return count;\n}\n\nvar counter = makeCounter();\nprint counter();  // 1\nprint counter();  // 2\nprint counter();  // 3\n```\n\n**Expected behavior:**\n1. The interpreter should parse and execute without errors\n2. `factorial(5)` should calculate and print `120` (recursion works)\n3. `makeCounter()` returns a closure that increments and remembers `i`\n4. Each call to `counter()` returns the next integer (1, 2, 3)\n\n**Signs of problems:**\n- Recursion fails with \"undefined variable 'factorial'\": Function name not bound in its own environment\n- Counter always returns 1: Closure not capturing `i`, or new environment created incorrectly\n- \"Too many/few arguments\" error when correct: Argument count checking too strict\n- Return value is `None` when expecting a number: Forgetting to extract value from `ReturnSignal`\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Function can't access outer variables | Closure not captured | Print function_value.closure during definition | Pass current environment as closure |\n| Recursion fails: \"undefined variable\" | Function name not bound before body | Check order of definition vs. environment binding | Define function name in SAME environment used as closure |\n| Return value always nil | ReturnSignal caught in wrong place | Add print before/after try-catch in call evaluation | Only catch ReturnSignal in _evaluate_call_expr |\n| Arguments evaluate to wrong values | Evaluating args in call environment | Check which environment is used for arg evaluation | Evaluate args in caller's environment, not new one |\n| Function called as method fails | Callee not a FunctionValue | Print type of callee before call | Ensure variable lookup returns FunctionValue, not raw value |\n\n\n## Interactions and Data Flow\n> **Milestone(s):** 2, 3, 4\n\nThis section illustrates the dynamic collaboration between the interpreter's core components during execution. While previous sections described each component's static design, here we trace the concrete flow of control and data as the interpreter evaluates real programs. Understanding these interactions is critical for debugging and for appreciating how lexical scoping, closures, and control flow jumps are realized through the interplay of the immutable AST, the recursive Evaluator, and the chained Environment objects.\n\nWe will examine three foundational scenarios that demonstrate increasing complexity: a simple variable lookup illustrating the environment chain, a function call with closure capture showing how functions preserve their defining scope, and a loop with a `break` statement demonstrating non-local control flow. Each scenario will be narrated step-by-step, highlighting the components involved, the messages passed, and the state transformations.\n\n### Sequence of Operations\n\nThe interpreter's execution follows a consistent pattern: the `Evaluator` receives an AST node and an `Environment` context, dispatches to a specific handler method based on the node type, and returns a result. This simple protocol enables complex behaviors through recursion and state mutation. The following walkthroughs make these abstract interactions concrete.\n\n#### Scenario 1: Variable Lookup Across Nested Scopes\n**Program:** `{ var x = 10; { var y = x + 5; } }`\n**Goal:** Illustrate environment chain creation and lexical variable resolution.\n\nThis program contains a block statement with a variable `x`, nested inside another block that defines `y` and references `x`. This demonstrates how the environment chain enables inner scopes to access outer bindings.\n\n**Step-by-Step Walkthrough:**\n\n1.  **Initialization:** The `Interpreter` creates a global `Environment` (call it `env_global`) with no parent. It parses the source code into an AST, resulting in a `Block` node containing two statements: a `Var` statement for `x` and an inner `Block` statement.\n\n2.  **Outer Block Evaluation:** The `Interpreter` calls `Evaluator.evaluate(outer_block, env_global)`. The `_evaluate_block_stmt` method is invoked.\n\n3.  **Defining `x`:** The evaluator processes the first statement, a `Var` node for `x`. It evaluates the initializer expression (the literal `10`), yielding the runtime value `10`. It then calls `env_global.define(\"x\", 10)`, which inserts the binding `\"x\": 10` into `env_global.store`.\n\n4.  **Creating Nested Scope:** The evaluator moves to the second statement, another `Block` node. To evaluate it, `_evaluate_block_stmt` creates a new `Environment` (call it `env_inner`) with its `parent` field set to `env_global`.\n\n5.  **Inner Block Execution:** Inside `env_inner`, the evaluator processes its single `Var` statement for `y`. The initializer is a `Binary` expression `x + 5`.\n\n6.  **Resolving `x` for the Addition:** To evaluate the `Binary` node's left operand (a `Variable` node for `x`), the evaluator calls `_evaluate_variable_expr`. This method calls `env_inner.get(\"x\")`.\n    1.  `env_inner` checks its own `store`; `x` is not found.\n    2.  It follows its `parent` pointer to `env_global`.\n    3.  `env_global` finds `\"x\": 10` in its store and returns the value `10`.\n\n7.  **Completing the Binding:** The binary expression evaluates to `15`. The evaluator calls `env_inner.define(\"y\", 15)`, creating a binding local to the inner block. The inner block completes, and its environment (`env_inner`) is discarded. The outer block completes, returning `None`.\n\n![Diagram: Environment Chain Lookup](./diagrams/env-chain-lookup.svg)\n\n**Key Interaction Insight:** The `get` operation recursively traverses the environment chain via parent links. The `Evaluator` is unaware of the chain's length; it simply requests a value from the current environment, which handles the lookup. This clean separation of concerns makes lexical scoping straightforward to implement and reason about.\n\n#### Scenario 2: Function Call with Closure Capture\n**Program:** `var a = 1; fun makeAdder(b) { fun adder(c) { return a + b + c; } return adder; } var addTwo = makeAdder(2); print(addTwo(3)); // prints 6`\n**Goal:** Demonstrate function definition, closure environment capture, and the call stack simulation using environments.\n\nThis classic closure example shows how a function (`adder`) retains access to variables (`a` and `b`) from its defining scope, even after that scope has exited.\n\n**Step-by-Step Walkthrough:**\n\n1.  **Global Setup:** The global environment `env_global` is created. `a` is defined as `1`. The `makeAdder` function is defined: a `FunctionValue` object `F1` is created with `parameters=[\"b\"]`, `body` (the function's block), and `closure=env_global`. `env_global.define(\"makeAdder\", F1)`.\n\n2.  **Calling `makeAdder(2)`:** The evaluator encounters the call `makeAdder(2)`. It evaluates the callee to `F1` and the argument to `2`. It then executes `F1.call([2])`.\n    1.  **New Function Environment:** `call` creates a new environment `env_makeAdder` with its `parent` set to `F1.closure` (which is `env_global`). This establishes the function's local scope.\n    2.  **Parameter Binding:** `env_makeAdder.define(\"b\", 2)` is called.\n    3.  **Body Execution:** The evaluator runs `F1.body` (a block containing a function declaration and a return statement) within `env_makeAdder`.\n    4.  **Defining `adder`:** The inner function declaration creates a new `FunctionValue` `F2` with `parameters=[\"c\"]`, `body` (the return statement `a + b + c`), and **crucially** `closure=env_makeAdder`. This captures the *entire* environment active at its definition, including the binding for `b`.\n    5.  **Returning `adder`:** The `return adder;` statement is evaluated. The evaluator's `_evaluate_return_stmt` raises a `ReturnSignal` containing the value `F2`. This signal propagates out of the `call` method, which catches it and returns `F2` to the original call site. The `env_makeAdder` environment is *retained* because `F2` holds a reference to it as its closure.\n\n3.  **Binding `addTwo`:** The returned function `F2` is assigned to the global variable `addTwo`.\n\n4.  **Calling `addTwo(3)`:** The evaluator encounters `addTwo(3)`. It evaluates the callee to `F2` and the argument to `3`. It executes `F2.call([3])`.\n    1.  **New Closure Environment:** `call` creates a new environment `env_adder` with its `parent` set to `F2.closure` (which is `env_makeAdder`). This is the key to closure: `env_adder`'s parent chain is `env_makeAdder` → `env_global`.\n    2.  **Parameter Binding:** `env_adder.define(\"c\", 3)`.\n    3.  **Body Execution:** The evaluator runs `F2.body` (the return expression `a + b + c`). To resolve these variables:\n        - `c`: Found in `env_adder.store` as `3`.\n        - `b`: Not in `env_adder`. Lookup goes to parent `env_makeAdder`, where `b` is found as `2`.\n        - `a`: Not in `env_adder` or `env_makeAdder`. Lookup goes to `env_global`, where `a` is found as `1`.\n    4.  The sum `1 + 2 + 3 = 6` is computed. A `ReturnSignal(6)` is raised, caught by `call`, and returned as the result of `addTwo(3)`. The `print` statement outputs `6`.\n\n![Sequence Diagram: Function Call with Closure](./diagrams/seq-function-call.svg)\n\n**Key Interaction Insight:** The closure is implemented by storing a reference to the *defining* environment within the function object. When the function is called, this stored environment becomes the parent of the new call-site environment. This creates a persistent scope chain that outlives the execution of the outer function, enabling closure. The `Evaluator` treats all function calls identically; the magic is in the environment link.\n\n#### Scenario 3: Loop Execution with a Break Statement\n**Program:** `var i = 0; while (i < 10) { if (i == 5) { break; } i = i + 1; }`\n**Goal:** Demonstrate how loop evaluation interacts with control flow signals and the environment.\n\nThis shows the `while` loop's repetitive evaluation and how a `break` statement causes an early, non-local exit from the loop's body.\n\n**Step-by-Step Walkthrough:**\n\n1.  **Initialization:** `env_global` defines `i = 0`. The AST contains a `While` node with a condition `(i < 10)` and a body `Block`.\n\n2.  **Entering the Loop:** `Evaluator._evaluate_while_stmt` is called with the `While` node and `env_global`.\n    1.  **Condition Check:** It evaluates the condition `i < 10` by calling `evaluate(condition, env_global)`. This involves looking up `i` (value `0`) and performing the comparison, yielding `True`.\n    2.  **Body Execution (Iteration 1):** Since the condition is truthy, it calls `evaluate(body, env_global)` to execute the loop's block. The block contains an `If` statement and an assignment.\n        - The `If` condition `i == 5` evaluates to `False`, so its then-branch (containing the `Break` node) is skipped.\n        - The assignment `i = i + 1` is evaluated, updating `i` to `1` in `env_global`.\n    3.  The loop iterates, repeating steps 2a and 2b, with `i` incrementing to `2`, `3`, `4`, and `5`.\n\n3.  **Triggering the Break (Iteration where i == 5):**\n    1.  **Condition Check:** `i < 10` is still `True`.\n    2.  **Body Execution:** The `If` condition `i == 5` is now `True`. The evaluator proceeds to evaluate the then-branch, which is a block containing a `Break` statement.\n    3.  **Break Signal Raised:** `Evaluator._evaluate_break_stmt` is called. It does **not** return normally. Instead, it raises a `BreakSignal` exception (a subclass of `ControlFlowSignal`).\n\n4.  **Signal Propagation and Loop Termination:**\n    1.  The `BreakSignal` propagates out of the `evaluate(body, ...)` call. The `_evaluate_while_stmt` method is specifically designed to catch `BreakSignal` exceptions.\n    2.  Upon catching the `BreakSignal`, the loop evaluator **immediately stops iteration**. It does not evaluate any remaining statements in the loop body (the assignment `i = i + 1` is skipped for this iteration). It then exits, returning `None`.\n    3.  The `BreakSignal` is caught and consumed by the loop evaluator; it does not propagate further up the call stack.\n\n5.  **Post-Loop State:** The loop has terminated. The variable `i` remains with the value `5`, as the increment was skipped on the iteration where the break occurred.\n\n![State Machine: While Loop Execution](./diagrams/state-machine-loop.svg)\n\n**Key Interaction Insight:** Control flow jumps like `break` are implemented as exceptions (or a similar non-local exit mechanism) that unwind the evaluator's recursion until caught by the appropriate handler (the nearest enclosing loop construct). This separates the signaling of the jump (in `_evaluate_break_stmt`) from the handling logic (in `_evaluate_while_stmt`), making the control flow explicit and avoiding the need for complex flag-passing throughout the recursion.\n\n### Message and Value Formats\n\nDuring the sequences described above, components communicate through method calls and return values. The data structures passed are simple, yet they must carry all necessary information for correct execution. The following tables catalog these formats.\n\n**Primary Evaluation Protocol:**\nThe core interaction is the `Evaluator.evaluate(node, environment)` call and its return. The `node` is an immutable AST node, and the `environment` is the current lexical scope. The return value is a runtime value or `None`.\n\n| Message | Direction | Format (Type) | Description |\n| :--- | :--- | :--- | :--- |\n| **Evaluation Request** | Caller → `Evaluator` | `(ASTNode, Environment)` | A request to evaluate a given AST node within a specific environment context. |\n| **Runtime Value Result** | `Evaluator` → Caller | `Any` (Number, String, Boolean, Nil, `FunctionValue`) | The result of evaluating an expression. For statement evaluation, the result is often `None`. |\n| **Control Flow Signal** | `Evaluator` (deep in recursion) → Loop/Function Handler | `ControlFlowSignal` subclass (`BreakSignal`, `ContinueSignal`, `ReturnSignal`) | A non-local exit signal raised by statements like `break`, `continue`, or `return`. Carries optional data (e.g., a return value). |\n\n**Environment Management Messages:**\nThe `Environment` API is called by the `Evaluator` to manage variable bindings.\n\n| Method Call | Invoked By | Parameters | Returns / Effect |\n| :--- | :--- | :--- | :--- |\n| `Environment.define(name, value)` | `Evaluator._evaluate_var_stmt` | `name: str`, `value: Any` | Creates a new binding in the current environment's store. Fails silently if name already exists (allowing redefinition in our simple interpreter). |\n| `Environment.get(name)` | `Evaluator._evaluate_variable_expr` | `name: str` | Returns the value bound to `name` by walking the parent chain. Raises `UndefinedVariableError` if not found. |\n| `Environment.assign(name, value)` | `Evaluator._evaluate_assign_expr` | `name: str`, `value: Any` | Updates the binding for `name` in the nearest enclosing environment where it is defined. Raises `UndefinedVariableError` if no binding exists. |\n\n**Function Call Protocol:**\nWhen a `FunctionValue` is called, a specific sequence of messages creates and populates a new scope.\n\n| Step | Message | Description |\n| :--- | :--- | :--- |\n| 1. **Call Initiation** | `Evaluator` → `FunctionValue`: `call(arguments)` | The evaluator, after evaluating the callee and arguments, invokes the function's `call` method. |\n| 2. **Environment Creation** | `FunctionValue` creates a new `Environment` with `parent = self.closure`. | This establishes the lexical scope link for the function call. |\n| 3. **Parameter Binding** | `FunctionValue` → new `Environment`: `define(param_name, argument_value)` for each parameter/argument pair. | Binds the call's arguments to the function's parameter names in the new local environment. |\n| 4. **Body Evaluation** | `FunctionValue` → `Evaluator`: `evaluate(self.body, new_environment)` | Executes the function body within the newly created and populated environment. |\n| 5. **Result Return** | `Evaluator` → `FunctionValue`: Returns a value or raises `ReturnSignal`. | The body's result is captured. `ReturnSignal` is caught and its value is extracted. |\n| 6. **Call Completion** | `FunctionValue` → `Evaluator`: Returns the extracted value. | The result of the function call is delivered to the original call site in the evaluator. |\n\n**Control Flow Signal Formats:**\nThese signals are implemented as exception classes (or a similar mechanism) to facilitate non-local exit. Their fields carry necessary information.\n\n| Signal Class | Fields | Purpose |\n| :--- | :--- | :--- |\n| `BreakSignal` | None | Signals that the nearest enclosing loop should terminate immediately. |\n| `ContinueSignal` | None | Signals that the nearest enclosing loop should skip to the next iteration. |\n| `ReturnSignal` | `value: Any` | Signals that a function should exit and return the attached `value`. |\n\n> **Design Insight:** The uniformity of the `evaluate(node, environment)` interface is the interpreter's greatest strength. Every piece of code, from a simple literal to a complex loop, is evaluated through the same recursive doorway. This consistency simplifies the architecture and makes it easy to extend with new node types.\n\n**ADR: Control Flow via Exceptions**\n\n> **Decision: Use exceptions for non-local control flow (break, continue, return).**\n> - **Context**: Statements like `break` and `return` need to exit multiple levels of nested evaluation (e.g., break out of a loop that is deep inside several block statements). The evaluator uses deep recursion; returning normally would require every intermediate function to check for and propagate a special flag.\n> - **Options Considered**:\n>     1.  **Exception Mechanism**: Raise a special signal (`BreakSignal`) that unwinds the stack until caught by the loop evaluator.\n>     2.  **Explicit Status Propagation**: Have `evaluate` return a tuple `(status, value)` where `status` indicates normal completion, break, continue, or return. Each caller must check and propagate this status.\n>     3.  **Continuation Passing Style (CPS)**: Transform the evaluator to manage control flow explicitly via callbacks. This is more powerful but significantly more complex.\n> - **Decision**: Use the Exception Mechanism (Option 1).\n> - **Rationale**: Exceptions are a language feature designed precisely for non-local exit. They cleanly separate the point where a control flow event is triggered from the point where it is handled, without polluting the return type of every evaluation method. This leads to simpler, more readable core logic. The performance overhead is negligible for a learning-focused tree-walking interpreter.\n> - **Consequences**: The loop and function evaluation methods must be wrapped in try-catch blocks. Control flow signals must be distinct from actual runtime errors (like `TypeError`). This approach is idiomatic in many languages (Python, Java, C#) for implementing interpreters.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **Exceptions** | Clean separation, minimal code pollution, idiomatic. | Can be confused with real errors, requires careful catch blocks. | **Yes** |\n| **Status Propagation** | Explicit control flow, no language-specific mechanism. | Clutters every function signature and call site with status checks. | No |\n| **CPS** | Ultimate control flow flexibility, enables advanced features. | Extreme complexity, fundamental rewrite of the evaluator. | No |\n\n### Implementation Guidance\n\nThis section provides the skeleton code and integration points for the interaction patterns described above. The focus is on how the components connect, not on re-implementing their internal logic.\n\n**A. Technology Recommendations Table**\n| Component | Simple Option | Advanced Option |\n| :--- | :--- | :--- |\n| Control Flow Signals | Custom Exception classes (inherit from `Exception`). | A dedicated `Result` monad type that encapsulates both value and control flow state (more functional, but complex). |\n| Environment Chain | Python dictionaries with an explicit `parent` reference. | A persistent immutable hash map (like `pyrsistent`) for efficient snapshots and undo, useful for advanced debugging or time-travel. |\n| Function Call Management | Direct recursion within the `Evaluator`. | An explicit call stack list storing `(function, environment, return_address)` tuples, which would allow for future features like stack traces and tail-call optimization. |\n\n**B. Recommended File/Module Structure**\nThe interactions span multiple files. Ensure your project structure keeps related components together.\n```\ntree_walk_interpreter/\n│\n├── interpreter.py           # Main Interpreter class (orchestrates parsing and evaluation)\n├── evaluator.py             # Evaluator class (core dispatch logic)\n├── environment.py           # Environment class and runtime error definitions\n├── ast_nodes.py             # AST node class definitions (from parser)\n├── values.py                # Runtime value wrappers (e.g., FunctionValue)\n└── control_flow.py          # ControlFlowSignal and its subclasses (BreakSignal, etc.)\n```\n\n**C. Infrastructure Starter Code: Control Flow Signals**\nThese exception classes are complete and ready to use. They form the messaging system for non-local exits.\n```python\n# control_flow.py\n\"\"\"\nSignals for non-local control flow within the interpreter.\nThese are raised as exceptions and caught by the appropriate handler.\n\"\"\"\n\nclass ControlFlowSignal(Exception):\n    \"\"\"Base class for all non-local control flow signals.\"\"\"\n    pass\n\nclass BreakSignal(ControlFlowSignal):\n    \"\"\"Raised by a `break` statement. Caught by the nearest enclosing loop evaluator.\"\"\"\n    pass\n\nclass ContinueSignal(ControlFlowSignal):\n    \"\"\"Raised by a `continue` statement. Caught by the nearest enclosing loop evaluator.\"\"\"\n    pass\n\nclass ReturnSignal(ControlFlowSignal):\n    \"\"\"Raised by a `return` statement. Carries the return value back to the function call.\"\"\"\n    def __init__(self, value):\n        super().__init__()\n        self.value = value\n```\n\n**D. Core Logic Skeleton Code: Integrating Signals and Calls**\nThe following code snippets show key integration points in the `Evaluator` where the components interact. Fill in the TODOs based on the sequence walkthroughs.\n\n**1. Loop Evaluation with Break/Continue Handling**\n```python\n# evaluator.py\nclass Evaluator:\n    # ... other methods ...\n\n    def _evaluate_while_stmt(self, node, env):\n        \"\"\"\n        Evaluate a while loop statement.\n        Handles break and continue signals.\n        \"\"\"\n        # TODO 1: Enter a loop: Evaluate the condition expression using self.evaluate\n        # TODO 2: While the condition result is truthy (use self._is_truthy):\n        #   TODO 2a: Try to evaluate the loop body statement(s) using self.evaluate\n        #   TODO 2b: If a BreakSignal is raised, break out of the while loop entirely\n        #   TODO 2c: If a ContinueSignal is raised, simply continue to the next iteration (skip any remainder of the body)\n        #   TODO 2d: Re-evaluate the condition for the next iteration\n        # TODO 3: Loop finished (condition false or break). Return None.\n        pass\n\n    def _evaluate_break_stmt(self, node, env):\n        \"\"\"Evaluate a break statement by raising the signal.\"\"\"\n        # TODO 1: Simply raise BreakSignal()\n        pass\n\n    def _evaluate_continue_stmt(self, node, env):\n        \"\"\"Evaluate a continue statement by raising the signal.\"\"\"\n        # TODO 1: Simply raise ContinueSignal()\n        pass\n```\n\n**2. Function Call Evaluation and Return Handling**\n```python\n# evaluator.py\nclass Evaluator:\n    # ... other methods ...\n\n    def _evaluate_call_expr(self, node, env):\n        \"\"\"Evaluate a function call expression.\"\"\"\n        # TODO 1: Evaluate the callee expression (node.callee) to get the callable (should be a FunctionValue)\n        # TODO 2: Evaluate each argument expression in node.arguments, producing a list of argument values\n        # TODO 3: Verify the callee is callable (e.g., isinstance(callee, FunctionValue))\n        # TODO 4: Check arity: len(arguments) should equal len(callee.parameters). Raise ArgumentError if not.\n        # TODO 5: Call callee.call(arguments) and return its result.\n        pass\n\n# values.py\nclass FunctionValue:\n    def __init__(self, name, parameters, body, closure):\n        self.name = name          # Optional, for debugging\n        self.parameters = parameters  # List of parameter name strings\n        self.body = body          # The AST block or statement for the function body\n        self.closure = closure    # The Environment where the function was defined\n\n    def call(self, arguments):\n        \"\"\"Execute the function with the given arguments.\"\"\"\n        # TODO 1: Create a new Environment for this function call. Set its parent to self.closure.\n        # TODO 2: For each parameter name and corresponding argument value, define the binding in the new environment.\n        # TODO 3: Try to evaluate self.body within the new environment.\n        # TODO 4: If a ReturnSignal is raised during evaluation, catch it and return its .value attribute.\n        # TODO 5: If evaluation completes without a ReturnSignal (i.e., falls off the end of the function), return None (implicit nil return).\n        pass\n```\n\n**E. Language-Specific Hints (Python)**\n- **Catching Multiple Exceptions:** Use separate `except` clauses for `BreakSignal`, `ContinueSignal`, and `ReturnSignal` to handle them differently. You can also catch the base `ControlFlowSignal` and then check its type.\n- **Maintaining Clean Stack Traces:** When raising a custom `RuntimeError`, include the relevant token information (like line number) for user-friendly error messages. The `ControlFlowSignal` exceptions are for internal control and should not be reported as user errors.\n- **Environment References:** Be mindful of circular references (e.g., an environment stored in a closure). Python's garbage collector will handle it, but for long-running programs, ensure you're not accidentally holding onto large environment chains unnecessarily.\n\n**F. Milestone Checkpoint: Integration Test**\nAfter implementing the components and their interactions, run this integration test to verify the scenarios from this section work correctly.\n```python\n# test_integration.py (simple script)\nfrom interpreter import Interpreter\n\nsource = \"\"\"\nvar a = 1;\nfun makeAdder(b) {\n    fun adder(c) {\n        return a + b + c;\n    }\n    return adder;\n}\nvar addTwo = makeAdder(2);\nprint(addTwo(3)); // Should print 6\n\nvar i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    i = i + 1;\n}\nprint(i); // Should print 5\n\"\"\"\n\ninterpreter = Interpreter()\nsuccess = interpreter.interpret(source)\nprint(\"Interpretation succeeded:\", success)\n```\n**Expected Output:**\n```\n6\n5\nInterpretation succeeded: True\n```\n\n**G. Debugging Tips for Interactions**\n| Symptom | Likely Cause | How to Diagnose | Fix |\n| :--- | :--- | :--- | :--- |\n| Variable lookup returns `nil` or wrong value from outer scope. | The environment chain link (`parent`) is broken or not set when creating a new scope. | Add debug prints to `Environment.get` to log each step of the lookup chain. Check that inner environment creation correctly sets `parent`. | Ensure `Environment(parent=...)` is called when creating block, function, or loop bodies. |\n| Function does not remember variables from its outer scope (closure broken). | The `FunctionValue.closure` field is set to the wrong environment (e.g., the global env instead of the defining one). | Print the `closure` field when a function is created and when it's called. Verify it's the environment active at definition time. | When evaluating a function declaration, capture the *current* environment (`env`) as the closure. |\n| `break` or `return` causes the entire interpreter to crash with an uncaught exception. | The corresponding signal is not being caught by the appropriate handler (loop or function call). | Check that `_evaluate_while_stmt` and `FunctionValue.call` have try-catch blocks for the relevant signals. | Wrap the loop body evaluation in a try-catch for `BreakSignal`. Wrap the function body evaluation in a try-catch for `ReturnSignal`. |\n| Loop runs forever even after `break` is executed. | The `BreakSignal` is being caught by a handler *outside* the loop (e.g., a block evaluator), preventing the loop from seeing it. | Ensure only the loop evaluator catches `BreakSignal`. Block evaluators should not catch it; they should let it propagate. | Remove any `except BreakSignal` from `_evaluate_block_stmt` and similar non-loop statement evaluators. |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** 1, 2, 3, 4\n>\n> This section defines the interpreter's approach to runtime failures and exceptional conditions. Unlike compiled languages that catch many errors during compilation, an interpreter must validate operations at runtime, making robust error handling critical. We'll catalog expected failure modes, define detection strategies, and establish recovery behaviors—most of which involve halting execution with a clear diagnostic message.\n\n### Runtime Error Types\n\nIn a tree-walking interpreter, **runtime errors** represent invalid operations that cannot be detected until execution time. Think of these as \"math errors\" that occur when you actually perform calculations, not when you write the equations. For example, dividing by zero isn't wrong in the syntax `10 / 0`, but becomes invalid when you attempt the division operation.\n\nOur interpreter recognizes five core error categories, each represented by a dedicated exception class that inherits from a common base:\n\n| Error Type | Trigger Condition | Typical Location in AST | Example Source |\n|------------|-------------------|-------------------------|----------------|\n| **Type Error** | Operation applied to incompatible operand types | Binary/unary expression evaluation | `\"hello\" + 42` |\n| **Undefined Variable Error** | Attempt to read or assign to undeclared variable | Variable expression or assignment | `x = 10; print y;` |\n| **Division By Zero Error** | Division operator with right operand of zero | Binary expression (division operator) | `10 / 0` |\n| **Argument Error** | Function call with incorrect argument count | Function call expression | `fn add(a,b){a+b}; add(1);` |\n| **Control Flow Error** | `break`/`continue` outside loop context | Break/continue statement | `if true { break; }` |\n\n> **Design Insight**: We separate `DivisionByZeroError` from `TypeError` because division by zero is a *domain* error (mathematically invalid) rather than a *type* error (operand-type mismatch). This distinction helps users understand whether they used the wrong operator or the wrong value.\n\nEach error class extends a common base `RuntimeError` with standardized fields:\n\n| Error Class | Parent | Fields (beyond inherited) | Description |\n|-------------|--------|---------------------------|-------------|\n| `RuntimeError` | (Base class) | `message: str`, `token: Token` | Base for all runtime errors |\n| `TypeError` | `RuntimeError` | (none) | Operation on incompatible types |\n| `UndefinedVariableError` | `RuntimeError` | (none) | Reference to undefined variable |\n| `DivisionByZeroError` | `RuntimeError` | (none) | Division by numeric zero |\n| `ArgumentError` | `RuntimeError` | (none) | Incorrect function argument count |\n\n**Mental Model: Traffic Violation Tickets**\nThink of each error type as a specific traffic violation. A `TypeError` is like trying to drive a car on a train track—wrong vehicle for the infrastructure. An `UndefinedVariableError` is like trying to deliver a package to a non-existent address. A `DivisionByZeroError` is like trying to split a pizza among zero people—mathematically undefined. Each violation requires a specific citation (error message) explaining what rule was broken.\n\nThe `RuntimeError` base class provides consistent error reporting through its fields:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `message` | `str` | Human-readable error description including contextual details |\n| `token` | `Token` | The token from the source code where the error occurred (contains line/column) |\n\n> **ADR: Granular Error Types vs. Single Generic Error**\n> - **Context**: We need to decide how specifically to categorize runtime failures for better debugging and error messages.\n> - **Options Considered**:\n>   1. **Single generic `RuntimeError`**: One class with a string error code\n>   2. **Granular error hierarchy**: Separate classes for each error category (chosen)\n>   3. **Error codes in base class**: Single class with enum error codes\n> - **Decision**: Implement granular error hierarchy with dedicated classes\n> - **Rationale**: \n>   1. **Better debugging**: Catch specific error types during testing\n>   2. **Clearer error messages**: Each class can generate tailored messages\n>   3. **Future extensibility**: Easy to add new error types without modifying existing code\n>   4. **Educational value**: Helps learners understand different failure modes\n> - **Consequences**: \n>   - More classes to maintain\n>   - Slightly more complex error handling code\n>   - Better user experience with specific error diagnostics\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Single generic error | Simple implementation, fewer classes | Vague error messages, harder to test specific cases | ✗ |\n| Granular hierarchy | Specific error handling, better debugging | More boilerplate, multiple exception classes | ✓ |\n| Error codes enum | Middle ground, single class structure | Still requires switch statements, less type safety | ✗ |\n\n### Detection and Reporting\n\nRuntime error detection follows a **proactive validation** strategy: before performing any operation that could fail, we check preconditions and raise the appropriate error if conditions aren't met. This happens at specific points in the evaluation process, typically within operator evaluation methods and environment lookup operations.\n\n#### Detection Points and Strategies\n\nEach error type has specific detection logic:\n\n| Error Type | Detection Point | Validation Logic |\n|------------|-----------------|------------------|\n| **Type Error** | Binary/unary operator evaluation | Check operand types before operation using type predicates |\n| **Undefined Variable** | `Environment.get()` method | Walk parent chain; if name not found, raise error |\n| **Division By Zero** | Division operator evaluation | Check right operand equals numeric zero before division |\n| **Argument Error** | Function call execution | Compare argument count to parameter count before binding |\n| **Control Flow Error** | Break/continue statement evaluation | Check if executing within loop context via flag or environment |\n\n**Concrete Example Walkthrough**: Consider evaluating the expression `\"hello\" * 3`:\n1. `Evaluator._evaluate_binary_expr()` is called with a `Binary` node (operator: `*`, left: `\"hello\"`, right: `3`)\n2. Both operands are evaluated recursively: left yields string `\"hello\"`, right yields number `3`\n3. Before applying multiplication, the method checks: `isinstance(left, str) and isinstance(right, (int, float))`\n4. This check fails because string multiplication isn't supported (only numeric multiplication)\n5. Raise `TypeError(\"Operands must be numbers for multiplication\")` with the `*` operator token\n\n#### Error Message Guidelines\n\nEffective error messages follow these principles:\n1. **Specificity**: State exactly what went wrong, not just \"error\"\n2. **Context**: Include the problematic operation and values involved\n3. **Location**: Reference source line and column from the token\n4. **Actionable**: Suggest possible fixes when obvious\n\nError message templates for each error type:\n\n| Error Type | Message Template | Example Output |\n|------------|------------------|----------------|\n| Type Error | `\"Operand TYPE_A for OPERATOR must be TYPE_B\"` | `\"Operand 'hello' for * must be a number at line 1:15\"` |\n| Undefined Variable | `\"Undefined variable 'NAME'\"` | `\"Undefined variable 'count' at line 3:8\"` |\n| Division By Zero | `\"Division by zero\"` | `\"Division by zero at line 2:12\"` |\n| Argument Error | `\"Expected ARITY arguments but got COUNT\"` | `\"Expected 2 arguments but got 1 at line 5:3\"` |\n| Control Flow Error | `\"BREAK/CONTINUE outside loop\"` | `\"break outside loop at line 4:5\"` |\n\n**Implementation Algorithm for Type Checking**:\n1. When evaluating a binary operation:\n   1. Evaluate left and right operands recursively\n   2. Determine required types based on operator (e.g., `+` accepts numbers or strings, `*` only numbers)\n   3. If operands don't match required types, construct error message with:\n      - Operator symbol from token\n      - Actual types of operands\n      - Expected types\n      - Source location from operator token\n   4. Raise `TypeError` with constructed message\n\n2. When looking up a variable:\n   1. Start at current environment\n   2. Walk parent chain checking `store` dictionary for name\n   3. If chain exhausted without finding name:\n      - Construct message: `f\"Undefined variable '{name}'\"`\n      - Use variable name token for location\n      - Raise `UndefinedVariableError`\n\n> **Key Insight**: Use the `token` field from AST nodes (provided by the parser) for error location. Every expression and statement node should store its relevant token (operator token for expressions, name token for variables, etc.).\n\n#### Recovery Behavior\n\nThe interpreter implements a **fail-fast** recovery strategy: when any runtime error occurs, execution halts immediately, the error is reported, and the interpreter returns to a clean state (ready for the next input). This mimics how most scripting languages handle runtime errors.\n\n**Recovery Process**:\n1. Error raised in `Evaluator.evaluate()` or any handler method\n2. Error propagates up call stack through recursive evaluations\n3. Caught at top level in `Interpreter.interpret()` method\n4. Error message printed to stderr with format: `[RUNTIME ERROR] Message at line X:Y`\n5. `Interpreter.interpret()` returns `False` indicating failed execution\n6. Environment chain remains unchanged (no partial state corruption)\n\n⚠️ **Pitfall: Error Cascading**\n- **Problem**: After catching one error, continuing execution often leads to more confusing errors (e.g., undefined variables from previous failed assignment)\n- **Why it's wrong**: Masks the root cause and creates debugging confusion\n- **Fix**: Implement fail-fast—stop at first error and provide clear diagnostics\n\n### Special Edge Cases\n\nBeyond explicit runtime errors, several language semantics require careful handling of special values and conditions. These edge cases define the \"personality\" of the language and must be implemented consistently.\n\n#### Nil Handling\n\n`nil` represents the absence of a value (similar to `null` or `None`). Its semantics include:\n\n| Context | Behavior | Rationale |\n|---------|----------|-----------|\n| **Arithmetic operations** | `TypeError` (nil is not numeric) | Prevents silent bugs from uninitialized variables |\n| **Comparison** | `nil == nil` → `true`, `nil == anything_else` → `false` | Follows equality semantics of \"no value\" |\n| **Logical operators** | `nil` is falsy | Consistent with \"absence\" being falsey |\n| **String concatenation** | Convert to `\"nil\"` string | Allows `print` to display nil values |\n| **Function return** | Default return value when no `return` statement | Functions always return something |\n\n**Algorithm for Nil Propagation**:\n1. When a variable is declared without initializer: `var x;` → binds `nil` to `x`\n2. When accessing undefined variable: raises `UndefinedVariableError` (different from nil)\n3. When function reaches end without return: implicitly returns `nil`\n4. When printing nil: `Interpreter._stringify(nil)` returns `\"nil\"`\n\n#### Truthiness Rules\n\n**Truthiness** determines which values count as \"true\" in boolean contexts (if conditions, while loops, logical operators). Our rules follow the principle of **minimal surprise**:\n\n| Value Type | Truthiness | Reasoning |\n|------------|------------|-----------|\n| Boolean `true` | `true` | Literal true |\n| Boolean `false` | `false` | Literal false |\n| `nil` | `false` | Absence of value is falsey |\n| Number `0` | `true` | Unlike some languages, zero is truthy |\n| Empty string `\"\"` | `true` | String exists, even if empty |\n| All other values | `true` | Default: everything exists is truthy |\n\n**Implementation Algorithm**:\n```python\n# In Evaluator._is_truthy(value):\nif value is None or value is False:\n    return False\nreturn True  # Everything else is truthy\n```\n\n> **ADR: Zero/Empty String Truthiness**\n> - **Context**: Need consistent rules for what values count as false in boolean contexts\n> - **Options Considered**:\n>   1. **JavaScript-style**: `0`, `\"\"`, `null`, `undefined`, `false`, `NaN` are falsey\n>   2. **Python-style**: `0`, `0.0`, `False`, `None`, empty collections are falsey  \n>   3. **Simple strict**: Only `false` and `nil` are falsey (chosen)\n> - **Decision**: Only `false` and `nil` are falsey\n> - **Rationale**:\n>   1. **Simplicity**: Easy to remember and explain\n>   2. **Predictability**: `if (0)` and `if (\"\")` work as intuitively expected\n>   3. **Consistency**: Numbers and strings always behave uniformly\n>   4. **Avoids bugs**: Common error `if (x)` where `x` is `0` still executes\n> - **Consequences**:\n>   - Different from many mainstream languages\n>   - Requires explicit `x == 0` checks for numeric zero conditions\n>   - Fewer surprises for beginners\n\n#### Empty Statement Blocks\n\nAn empty block `{}` or statement list evaluates to `nil`:\n\n1. **Empty block evaluation**: `Evaluator._evaluate_block_stmt()` returns `nil` when no statements\n2. **Empty if/else branches**: Missing else clause implicitly returns `nil`\n3. **Empty function body**: Returns `nil` when called\n\n**Example Walkthrough**: Evaluating `if (false) { 10; }`\n1. Condition evaluates to `false`\n2. Then branch is skipped (not evaluated at all)\n3. No else branch exists\n4. Entire `if` statement returns `nil`\n\n#### Implicit Return from Functions\n\nWhen a function execution reaches the end of its body without encountering a `return` statement, it **implicitly returns `nil`**. This ensures all function calls produce a value.\n\n**Execution Flow**:\n1. Function body is evaluated as a block statement\n2. If block completes normally (no `ReturnSignal` raised), evaluation returns `nil`\n3. This `nil` becomes the return value of the function call\n\n⚠️ **Pitfall: Forgetting Return in Recursive Base Case**\n- **Problem**: Recursive function without return in base case returns `nil`, contaminating result\n- **Example**: `function fact(n) { if (n <= 1) { 1; } else { n * fact(n-1); } }` (missing `return`)\n- **Why it's wrong**: Base case returns `nil`, making whole expression `n * nil` → `TypeError`\n- **Fix**: Always use explicit `return` statements in functions\n\n#### Short-Circuit Evaluation Edge Cases\n\nLogical operators `and` and `or` use short-circuit evaluation, which has subtle edge cases:\n\n| Expression | Evaluation Behavior | Result |\n|------------|---------------------|--------|\n| `false and (1/0)` | Right operand never evaluated | `false` (no division error) |\n| `true or (x = 10)` | Right operand never evaluated | `true` (assignment doesn't happen) |\n| `nil or \"default\"` | Right operand evaluated (nil is falsey) | `\"default\"` |\n\n**Implementation Algorithm**:\n1. Evaluate left operand\n2. For `and`: if left is falsey, return left (skip right)\n3. For `or`: if left is truthy, return left (skip right)  \n4. Otherwise, evaluate and return right operand\n\n#### Variable Shadowing and Redeclaration\n\nVariable **shadowing** (inner scope redefining outer variable) is allowed, but redeclaration in same scope should be detected:\n\n| Case | Behavior | Implementation |\n|------|----------|----------------|\n| `var x = 1; { var x = 2; }` | Allowed (shadowing) | `Environment.define()` always succeeds |\n| `var x = 1; var x = 2;` | Allowed (redeclaration) | Overwrites existing binding |\n| `x = 1;` (no prior `var`) | `UndefinedVariableError` | `Environment.assign()` fails if not found |\n\n> **Design Choice**: We allow redeclaration in same scope for simplicity, though some languages prohibit it. This matches JavaScript's `var` semantics rather than `let`.\n\n#### Division and Modulo by Zero\n\nWhile `DivisionByZeroError` catches `/ 0`, we must also handle:\n\n1. **Integer division by zero**: Same error (mathematically undefined)\n2. **Modulo by zero**: `10 % 0` should also raise `DivisionByZeroError` \n3. **Negative zero**: `-0` is still zero numerically, triggers error\n\n**Algorithm for Division Operators**:\n1. Evaluate right operand\n2. If right operand is numeric zero (0 or 0.0 or -0.0):\n   - Construct message: `\"Division by zero\"`\n   - Use operator token for location\n   - Raise `DivisionByZeroError`\n3. Otherwise, perform operation normally\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Types | Custom exception classes with message/token | Rich error hierarchy with error codes, suggestions |\n| Error Reporting | Simple print to stderr | Structured logging with context capture |\n| Validation | Manual type checks in each operator | Visitor pattern with type validation decorators |\n\n#### Recommended File Structure\n\n```\ninterpreter/\n├── __init__.py\n├── ast.py              # AST node definitions\n├── parser.py           # Parser (generates AST)\n├── interpreter.py      # Main Interpreter class\n├── evaluator.py        # Evaluator class with evaluation logic\n├── environment.py      # Environment class hierarchy\n├── errors.py           # Error class definitions ← NEW FILE\n└── values.py           # Runtime value wrappers (optional)\n```\n\n#### Infrastructure Starter Code: Error Classes\n\n```python\n# errors.py\n\"\"\"\nRuntime error definitions for the tree-walking interpreter.\nAll errors include source location via token reference.\n\"\"\"\n\nclass RuntimeError(Exception):\n    \"\"\"Base class for all runtime errors.\"\"\"\n    \n    def __init__(self, message: str, token):\n        \"\"\"\n        Initialize a runtime error.\n        \n        Args:\n            message: Human-readable error description\n            token: The Token from source where error occurred\n        \"\"\"\n        super().__init__(message)\n        self.message = message\n        self.token = token\n    \n    def __str__(self):\n        \"\"\"Format error for display including line number.\"\"\"\n        if self.token:\n            return f\"[RUNTIME ERROR] {self.message} at line {self.token.line}:{self.token.column}\"\n        return f\"[RUNTIME ERROR] {self.message}\"\n\n\nclass TypeError(RuntimeError):\n    \"\"\"Operation on incompatible types.\"\"\"\n    pass\n\n\nclass UndefinedVariableError(RuntimeError):\n    \"\"\"Reference to undefined variable.\"\"\"\n    pass\n\n\nclass DivisionByZeroError(RuntimeError):\n    \"\"\"Division or modulo by zero.\"\"\"\n    pass\n\n\nclass ArgumentError(RuntimeError):\n    \"\"\"Incorrect number of function arguments.\"\"\"\n    pass\n\n\n# Control flow signals (not errors, but exceptional flow)\nclass ControlFlowSignal(Exception):\n    \"\"\"Base for break/continue/return signals.\"\"\"\n    pass\n\n\nclass BreakSignal(ControlFlowSignal):\n    \"\"\"Signals a break statement.\"\"\"\n    pass\n\n\nclass ContinueSignal(ControlFlowSignal):\n    \"\"\"Signals a continue statement.\"\"\"\n    pass\n\n\nclass ReturnSignal(ControlFlowSignal):\n    \"\"\"Signals a return statement with value.\"\"\"\n    \n    def __init__(self, value):\n        super().__init__()\n        self.value = value\n```\n\n#### Core Logic Skeleton: Error Detection in Evaluator\n\n```python\n# evaluator.py (partial)\nfrom errors import (\n    TypeError, UndefinedVariableError, \n    DivisionByZeroError, ArgumentError\n)\n\nclass Evaluator:\n    \"\"\"Recursive AST evaluator with error checking.\"\"\"\n    \n    def _evaluate_binary_expr(self, node, env):\n        \"\"\"\n        Evaluate binary expression with type checking.\n        \n        Args:\n            node: Binary expression AST node\n            env: Current evaluation environment\n            \n        Returns:\n            Result of binary operation\n            \n        Raises:\n            TypeError: If operands have incompatible types\n            DivisionByZeroError: If division by zero\n        \"\"\"\n        # TODO 1: Evaluate left and right operands recursively\n        # left_val = self.evaluate(node.left, env)\n        # right_val = self.evaluate(node.right, env)\n        \n        # TODO 2: Check for division by zero for / and % operators\n        # if node.operator.type in (TokenType.SLASH, TokenType.PERCENT):\n        #     if self._is_zero(right_val):\n        #         raise DivisionByZeroError(\n        #             \"Division by zero\", \n        #             node.operator\n        #         )\n        \n        # TODO 3: Determine expected types based on operator\n        # For +: numbers or strings (but both same type)\n        # For -, *, /, %: numbers only\n        # For comparisons: numbers or strings (comparable)\n        # For equality: any types allowed\n        \n        # TODO 4: Validate operand types match expected types\n        # if not self._check_types(left_val, right_val, node.operator):\n        #     actual_types = (type(left_val).__name__, type(right_val).__name__)\n        #     raise TypeError(\n        #         f\"Operands {actual_types[0]} and {actual_types[1]} \"\n        #         f\"for {node.operator.lexeme} must be compatible\",\n        #         node.operator\n        #     )\n        \n        # TODO 5: Perform the operation based on operator type\n        # Use Python's operators with appropriate type conversions\n        \n        pass\n    \n    def _evaluate_call_expr(self, node, env):\n        \"\"\"\n        Evaluate function call expression.\n        \n        Args:\n            node: Call expression AST node\n            env: Current evaluation environment\n            \n        Returns:\n            Function return value\n            \n        Raises:\n            ArgumentError: If argument count doesn't match parameter count\n        \"\"\"\n        # TODO 1: Evaluate the callee (function) expression\n        \n        # TODO 2: Evaluate all argument expressions\n        \n        # TODO 3: Verify callee is callable (FunctionValue)\n        \n        # TODO 4: Check argument count matches parameter count\n        # if len(arguments) != len(function.parameters):\n        #     raise ArgumentError(\n        #         f\"Expected {len(function.parameters)} arguments \"\n        #         f\"but got {len(arguments)}\",\n        #         node.paren  # Use closing parenthesis token\n        #     )\n        \n        # TODO 5: Call the function with arguments\n        \n        pass\n    \n    def _is_truthy(self, value):\n        \"\"\"\n        Determine truthiness of a runtime value.\n        \n        Args:\n            value: Any runtime value\n            \n        Returns:\n            True if value is truthy, False otherwise\n        \"\"\"\n        # TODO 1: Return False for nil and False boolean\n        # TODO 2: Return True for all other values (including 0, \"\")\n        pass\n    \n    def _is_zero(self, value):\n        \"\"\"\n        Check if value is numeric zero (including negative zero).\n        \n        Args:\n            value: Any runtime value\n            \n        Returns:\n            True if value is numeric zero\n        \"\"\"\n        # TODO 1: Check if value is int or float\n        # TODO 2: Return True if value == 0 (works for 0.0 and -0.0)\n        pass\n```\n\n#### Environment with Error Detection\n\n```python\n# environment.py (partial)\nfrom errors import UndefinedVariableError\n\nclass Environment:\n    \"\"\"Lexical scope environment with error checking.\"\"\"\n    \n    def get(self, name_token):\n        \"\"\"\n        Retrieve variable value by name, walking parent chain.\n        \n        Args:\n            name_token: Token containing variable name\n            \n        Returns:\n            Variable value\n            \n        Raises:\n            UndefinedVariableError: If variable not found in any scope\n        \"\"\"\n        # TODO 1: Check current environment's store for name\n        # if name_token.lexeme in self.store:\n        #     return self.store[name_token.lexeme]\n        \n        # TODO 2: If not found and has parent, delegate to parent\n        \n        # TODO 3: If no parent (global) and not found, raise error\n        # raise UndefinedVariableError(\n        #     f\"Undefined variable '{name_token.lexeme}'\",\n        #     name_token\n        # )\n        pass\n    \n    def assign(self, name_token, value):\n        \"\"\"\n        Update existing variable binding.\n        \n        Args:\n            name_token: Token containing variable name\n            value: New value to assign\n            \n        Raises:\n            UndefinedVariableError: If variable not found in any scope\n        \"\"\"\n        # TODO 1: Check current environment for variable\n        # TODO 2: If found, update value in current environment\n        # TODO 3: If not found and has parent, delegate to parent\n        # TODO 4: If no parent and not found, raise UndefinedVariableError\n        pass\n```\n\n#### Language-Specific Hints (Python)\n\n1. **Exception Inheritance**: Use `class TypeError(RuntimeError): pass` for minimal boilerplate\n2. **Token Storage**: Store the full token object, not just line/column, for future extensions\n3. **Type Checking**: Use `isinstance(value, (int, float))` for numeric checks, not `type(value) == int`\n4. **Zero Detection**: `value == 0` works for both `int` and `float` (including `-0.0`)\n5. **String Formatting**: Use f-strings for error messages: `f\"Expected {expected} but got {actual}\"`\n\n#### Testing Error Handling\n\nCreate test programs that trigger each error type:\n\n```python\n# test_errors.py\ntest_cases = [\n    (\"1 + 'hello'\", \"TypeError\"),\n    (\"print(undefined)\", \"UndefinedVariableError\"),\n    (\"10 / 0\", \"DivisionByZeroError\"),\n    (\"function f(a,b){return a+b}; f(1)\", \"ArgumentError\"),\n    (\"break;\", \"ControlFlowError\"),\n]\n\nfor source, expected_error in test_cases:\n    try:\n        interpreter.interpret(source)\n        print(f\"FAIL: {source} should raise {expected_error}\")\n    except RuntimeError as e:\n        error_type = type(e).__name__\n        if error_type == expected_error:\n            print(f\"PASS: {source} raised {error_type}\")\n        else:\n            print(f\"FAIL: {source} raised {error_type}, expected {expected_error}\")\n```\n\n**Expected Output**:\n```\nPASS: 1 + 'hello' raised TypeError\nPASS: print(undefined) raised UndefinedVariableError  \nPASS: 10 / 0 raised DivisionByZeroError\nPASS: function f(a,b){return a+b}; f(1) raised ArgumentError\nPASS: break; raised ControlFlowError\n```\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Error message shows wrong line number | Token not passed correctly to error | Print token line/column in error handler | Ensure all error raises include the relevant token |\n| Type error on valid operation | Missing type check for specific operator | Add debug print to show operand types | Add type validation for that operator |\n| Undefined variable when variable exists | Environment chain traversal bug | Print environment chain during lookup | Fix parent traversal logic in `Environment.get()` |\n| Division by zero not caught | Float -0.0 not recognized as zero | Print value and `value == 0` check | Use `value == 0` not `value is 0` |\n| Implicit return returns wrong value | Block evaluation returns last statement, not nil | Trace block statement evaluation | Ensure empty block returns `nil` |\n\n\n## Testing Strategy\n\n> **Milestone(s):** 1, 2, 3, 4\n\nA robust testing strategy is essential for building confidence in the interpreter's correctness and for catching regressions as features are added. This section outlines a comprehensive approach that combines **unit tests** for individual components with **integration tests** for complete programs, organized by the four project milestones. The testing philosophy follows a **fail-fast** approach, where the interpreter halts at the first detected error, making it easier to isolate and diagnose issues during development.\n\n### Testing Approach and Tools\n\n**Mental Model: The Watchful Factory Inspector**  \nThink of testing as a quality control inspector in a factory assembly line. Unit tests are like inspecting individual machine parts (e.g., testing that a gear turns correctly in isolation). Integration tests are like running the entire assembly line with sample materials to verify the final product works as expected. The test suite acts as the inspector's checklist, systematically verifying each component and interaction.\n\nThe recommended testing approach uses a **pyramid structure**: many fast, focused unit tests for core components, supplemented by fewer but comprehensive integration tests that exercise the entire interpreter on complete programs. This balance ensures both deep component validation and end-to-end system correctness.\n\n**Testing Framework Selection**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Test Framework** | Built-in `unittest` module | `pytest` with richer features |\n| **Test Organization** | One test file per component/module | Feature-based test directories |\n| **Test Runner** | IDE integration or command line | CI/CD pipeline with coverage |\n\nFor the primary Python implementation, we recommend starting with Python's built-in `unittest` framework for its simplicity and zero dependencies. As the project grows, teams may transition to `pytest` for its concise syntax and powerful fixtures, but the initial focus should remain on test coverage rather than framework sophistication.\n\n**Test Organization by Language Feature**\n\nTests should be organized to mirror the project's milestones and the interpreter's feature progression:\n\n| Test Category | Corresponding Milestone | Focus Areas | Example Test Cases |\n|---------------|------------------------|-------------|-------------------|\n| **Expression Evaluation** | Milestone 1 | Literals, arithmetic, comparisons, logical operators | `2 + 3 * 4`, `!(true == false)`, `\"hello\" + \"world\"` |\n| **Variable and Scope** | Milestone 2 | Declaration, assignment, shadowing, nested environments | `var x = 5; { var x = 10; } print x;` |\n| **Control Flow** | Milestone 3 | Conditionals, loops, break/continue, return | `while (i < 5) { if (i == 2) break; i = i + 1; }` |\n| **Functions and Closures** | Milestone 4 | Function definition, calls, parameters, closures, recursion | `fun makeCounter() { var i = 0; fun count() { i = i + 1; return i; } return count; }` |\n\n**Test Structure Pattern**\n\nEach test follows a consistent pattern:\n\n1. **Setup**: Initialize the interpreter with a clean `global_env`\n2. **Execution**: Call `Interpreter.interpret(source_code)` or directly invoke evaluator methods\n3. **Verification**: Check returned values, printed output, or expected error conditions\n4. **Teardown**: Reset any shared state to ensure test isolation\n\n**Special Considerations for Runtime Errors**\n\nSince the interpreter must detect and report various runtime errors, test cases should verify both successful execution and proper error handling:\n\n| Error Type | Test Approach | Verification Method |\n|------------|---------------|---------------------|\n| `UndefinedVariableError` | Attempt to use undeclared variable | Assert exception raised with correct token |\n| `TypeError` | Apply operator to incompatible types | Assert exception message mentions types |\n| `DivisionByZeroError` | Divide by zero literal or variable | Assert exception with division token |\n| `ArgumentError` | Call function with wrong argument count | Assert exception mentions expected vs actual |\n| Invalid `break`/`continue` | Use outside loop context | Assert control flow signal caught appropriately |\n\nFor error tests, the test should verify not just that an error occurs, but that it's the *correct* error type with an informative message containing the variable name, line number, or other diagnostic information.\n\n### Milestone Checkpoints\n\nEach milestone has a **verification checkpoint**—a concrete test program that exercises the core acceptance criteria. These checkpoints serve as integration tests that validate the complete feature set for that milestone. When all checkpoint tests pass, the milestone can be considered complete.\n\n**Milestone 1 Checkpoint: Expression Evaluation**\n\nThis test verifies all expression types work correctly, including operator precedence, type conversions, and short-circuit evaluation.\n\n**Test Program:**\n```\n// Basic literals\nprint 42;                         // Expect: 42\nprint \"hello\";                    // Expect: hello\nprint true;                       // Expect: true\nprint nil;                        // Expect: nil\n\n// Arithmetic with precedence\nprint 2 + 3 * 4;                  // Expect: 14 (not 20)\nprint (2 + 3) * 4;                // Expect: 20\n\n// Comparisons\nprint 5 > 3;                      // Expect: true\nprint 5 == 5;                     // Expect: true\nprint 5 != 5;                     // Expect: false\nprint \"abc\" == \"abc\";             // Expect: true\nprint \"abc\" == \"def\";             // Expect: false\n\n// Logical operators with short-circuit\nprint false and (1 / 0);          // Expect: false (no division by zero!)\nprint true or (1 / 0);            // Expect: true (no division by zero!)\n\n// Unary operators\nprint -(-5);                      // Expect: 5\nprint !true;                      // Expect: false\nprint !false;                     // Expect: true\nprint !!true;                     // Expect: true\n```\n\n**Expected Output:**\n```\n42\nhello\ntrue\nnil\n14\n20\ntrue\ntrue\nfalse\ntrue\nfalse\nfalse\ntrue\n5\nfalse\ntrue\ntrue\n```\n\n**Verification Criteria:**\n- All literals print their correct string representation\n- Arithmetic follows standard precedence (multiplication before addition)\n- Parentheses override precedence correctly\n- Comparisons work for both numbers and strings\n- Logical operators `and`/`or` short-circuit (no division by zero occurs)\n- Unary operators correctly negate and invert values\n\n**Milestone 2 Checkpoint: Variables and Environment**\n\nThis test verifies variable declaration, assignment, scoping rules, and shadowing across nested blocks.\n\n**Test Program:**\n```\n// Global scope\nvar global = \"global\";\nprint global;                     // Expect: global\n\n// Block creates new scope\n{\n  var local = \"local\";\n  print local;                    // Expect: local\n  print global;                   // Expect: global (outer accessible)\n  \n  // Shadowing\n  var global = \"shadowed\";\n  print global;                   // Expect: shadowed\n}\n\n// Outer scope unchanged\nprint global;                     // Expect: global\n\n// Assignment in correct scope\nvar x = 1;\n{\n  x = 2;                          // Modifies outer x\n}\nprint x;                          // Expect: 2\n\n// Undefined variable error (commented for test structure)\n// print not_defined;             // Should raise UndefinedVariableError\n```\n\n**Expected Output:**\n```\nglobal\nlocal\nglobal\nshadowed\nglobal\n2\n```\n\n**Error Test (should raise exception):**\n```python\n# In test code, this should raise UndefinedVariableError\ntry:\n    interpreter.interpret(\"print not_defined;\")\n    assert False, \"Should have raised UndefinedVariableError\"\nexcept UndefinedVariableError as e:\n    assert \"not_defined\" in str(e)\n```\n\n**Verification Criteria:**\n- Variables can be declared and printed in their scope\n- Inner blocks can access outer variables (lexical scoping)\n- Inner declarations shadow outer variables without affecting them\n- Assignment finds and modifies the nearest enclosing variable definition\n- Accessing undefined variables raises a clear error with the variable name\n\n**Milestone 3 Checkpoint: Control Flow**\n\nThis test verifies conditional execution, loops, and control flow jumps with proper scoping.\n\n**Test Program:**\n```\n// If/else statements\nvar result = \"\";\nif (true) result = \"true\"; else result = \"false\";\nprint result;                     // Expect: true\n\nif (false) result = \"wrong\"; else result = \"correct\";\nprint result;                     // Expect: correct\n\n// While loop with break\nvar i = 0;\nwhile (i < 5) {\n  if (i == 3) break;\n  i = i + 1;\n}\nprint i;                          // Expect: 3\n\n// For loop desugaring (should behave like while)\nvar sum = 0;\nfor (var j = 0; j < 5; j = j + 1) {\n  if (j == 2) continue;          // Skip when j == 2\n  sum = sum + j;\n}\nprint sum;                        // Expect: 8 (0+1+3+4)\n\n// Loop variable scoping\nvar counter = 0;\nfor (var k = 0; k < 3; k = k + 1) {\n  counter = counter + 1;\n}\n// k should not be accessible here (out of scope)\nprint counter;                    // Expect: 3\n// print k;                      // Should raise UndefinedVariableError\n```\n\n**Expected Output:**\n```\ntrue\ncorrect\n3\n8\n3\n```\n\n**Verification Criteria:**\n- `if`/`else` executes correct branch based on condition truthiness\n- `while` loops execute while condition is truthy\n- `break` exits the innermost loop immediately\n- `for` loops execute initialization, condition check, and increment correctly\n- `continue` skips to next iteration without exiting loop\n- Loop variables are scoped to the loop body (not accessible after)\n- Control flow statements work correctly within nested blocks\n\n**Milestone 4 Checkpoint: Functions and Closures**\n\nThis test verifies function definition, calls, parameters, return values, closures, and recursion.\n\n**Test Program:**\n```\n// Function definition and call\nfun sayHello(name) {\n  return \"Hello, \" + name + \"!\";\n}\nprint sayHello(\"World\");          // Expect: Hello, World!\n\n// Multiple parameters\nfun add(a, b) {\n  return a + b;\n}\nprint add(3, 4);                  // Expect: 7\n\n// Closure captures enclosing scope\nfun makeCounter() {\n  var i = 0;\n  fun count() {\n    i = i + 1;\n    return i;\n  }\n  return count;\n}\n\nvar counter = makeCounter();\nprint counter();                  // Expect: 1\nprint counter();                  // Expect: 2\nprint counter();                  // Expect: 3\n\n// Each closure gets its own environment\nvar counter2 = makeCounter();\nprint counter2();                 // Expect: 1 (independent of first counter)\n\n// Recursion\nfun factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\nprint factorial(5);               // Expect: 120\n\n// Implicit return nil\nfun noReturn() {\n  var x = 1;\n  // No return statement\n}\nprint noReturn();                 // Expect: nil\n```\n\n**Expected Output:**\n```\nHello, World!\n7\n1\n2\n3\n1\n120\nnil\n```\n\n**Error Tests (should raise exceptions):**\n```python\n# Wrong argument count\ntry:\n    interpreter.interpret('fun f(a,b) { return a+b; } print f(1);')\n    assert False, \"Should have raised ArgumentError\"\nexcept ArgumentError as e:\n    assert \"arguments\" in str(e).lower()\n\n# Return from top level (if supported, should error)\n# This depends on language design - may be allowed to return nil\n```\n\n**Verification Criteria:**\n- Functions can be defined and called by name\n- Parameters are bound to argument values in function scope\n- `return` statements immediately exit function with value\n- Closures capture and maintain access to variables from defining scope\n- Each closure instance maintains independent state\n- Recursive functions work correctly (call themselves)\n- Functions without explicit `return` statement implicitly return `nil`\n- Argument count mismatches raise clear errors\n\n### Implementation Guidance\n\n**Technology Recommendations Table**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Test Framework** | Python `unittest` | `pytest` with plugins |\n| **Test Organization** | Separate test files per component | Test directories mirroring source |\n| **Test Runner** | `python -m unittest discover` | `pytest` with coverage reports |\n| **Mocking** | `unittest.mock` for isolation | Custom test doubles |\n| **Assertion Style** | `self.assertEqual()` | `assert` statements with `pytest` |\n\n**Recommended File Structure**\n\nOrganize tests to mirror the source code structure:\n\n```\ninterpreter_project/\n├── src/\n│   ├── interpreter.py           # Main Interpreter class\n│   ├── evaluator.py             # Evaluator class\n│   ├── environment.py           # Environment class\n│   ├── errors.py                # RuntimeError and subclasses\n│   └── ast_nodes.py             # AST node definitions\n└── tests/\n    ├── __init__.py\n    ├── test_evaluator.py        # Unit tests for Evaluator\n    ├── test_environment.py      # Unit tests for Environment\n    ├── test_interpreter.py      # Integration tests\n    ├── test_errors.py           # Error condition tests\n    └── milestone_checkpoints/   # Milestone verification tests\n        ├── test_milestone1.py\n        ├── test_milestone2.py\n        ├── test_milestone3.py\n        └── test_milestone4.py\n```\n\n**Infrastructure Starter Code**\n\nHere's a complete test helper module that sets up common test infrastructure:\n\n```python\n# tests/test_helpers.py\nimport unittest\nfrom src.interpreter import Interpreter\nfrom src.errors import RuntimeError, UndefinedVariableError\n\nclass InterpreterTestCase(unittest.TestCase):\n    \"\"\"Base test case with common setup and assertions.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Create a fresh interpreter for each test.\"\"\"\n        self.interpreter = Interpreter()\n    \n    def assertOutput(self, source_code, expected_output_lines):\n        \"\"\"\n        Run source code and compare printed output line by line.\n        \n        Args:\n            source_code: Program source as string\n            expected_output_lines: List of expected output strings\n        \"\"\"\n        # Capture printed output\n        import io\n        import sys\n        \n        old_stdout = sys.stdout\n        sys.stdout = io.StringIO()\n        \n        try:\n            success = self.interpreter.interpret(source_code)\n            actual_output = sys.stdout.getvalue().strip().split('\\n')\n            \n            self.assertTrue(success, \"Interpretation should succeed\")\n            self.assertEqual(\n                len(actual_output), \n                len(expected_output_lines),\n                f\"Expected {len(expected_output_lines)} output lines, got {len(actual_output)}\"\n            )\n            \n            for i, (actual, expected) in enumerate(zip(actual_output, expected_output_lines)):\n                self.assertEqual(actual.strip(), expected.strip(), \n                               f\"Line {i+1}: expected '{expected}', got '{actual}'\")\n        finally:\n            sys.stdout = old_stdout\n    \n    def assertRaisesRuntimeError(self, source_code, error_type, expected_message_substring=None):\n        \"\"\"\n        Assert that interpreting source_code raises a specific runtime error.\n        \n        Args:\n            source_code: Program source as string\n            error_type: Expected exception class\n            expected_message_substring: Optional substring that should be in error message\n        \"\"\"\n        with self.assertRaises(error_type) as context:\n            self.interpreter.interpret(source_code)\n        \n        if expected_message_substring:\n            self.assertIn(expected_message_substring, str(context.exception))\n```\n\n**Core Test Skeleton Code**\n\nExample unit test for the `Environment` class:\n\n```python\n# tests/test_environment.py\nimport unittest\nfrom src.environment import Environment\n\nclass TestEnvironment(unittest.TestCase):\n    \n    def test_define_and_get(self):\n        \"\"\"Test basic variable definition and retrieval.\"\"\"\n        env = Environment()\n        \n        # TODO 1: Define a variable 'x' with value 42\n        # TODO 2: Retrieve the value of 'x' and assert it equals 42\n        # TODO 3: Test that getting undefined variable raises UndefinedVariableError\n        \n        pass\n    \n    def test_parent_chain_lookup(self):\n        \"\"\"Test variable lookup walks up parent chain.\"\"\"\n        # TODO 1: Create parent environment with variable 'x' = 10\n        # TODO 2: Create child environment with parent chain\n        # TODO 3: Verify child can retrieve parent's 'x'\n        # TODO 4: Define 'x' in child (shadowing) and verify child gets shadowed value\n        # TODO 5: Verify parent's 'x' remains unchanged\n        \n        pass\n    \n    def test_assignment_updates_nearest_scope(self):\n        \"\"\"Test assignment modifies the nearest enclosing scope where defined.\"\"\"\n        # TODO 1: Create parent with 'x' = 1, child with no 'x'\n        # TODO 2: From child, assign 'x' = 2\n        # TODO 3: Verify parent's 'x' now equals 2 (not child's)\n        # TODO 4: Define 'x' in child, then assign to verify child's updates\n        \n        pass\n```\n\nExample integration test for milestone checkpoint:\n\n```python\n# tests/milestone_checkpoints/test_milestone2.py\nfrom tests.test_helpers import InterpreterTestCase\n\nclass TestMilestone2Variables(InterpreterTestCase):\n    \"\"\"Integration tests for Milestone 2: Variables and Environment.\"\"\"\n    \n    def test_variable_declaration_and_print(self):\n        \"\"\"Test variable declaration and printing.\"\"\"\n        source = \"\"\"\n            var x = 42;\n            print x;\n        \"\"\"\n        self.assertOutput(source, [\"42\"])\n    \n    def test_scope_and_shadowing(self):\n        \"\"\"Test nested scopes and variable shadowing.\"\"\"\n        source = \"\"\"\n            var x = \"global\";\n            {\n                var x = \"local\";\n                print x;\n            }\n            print x;\n        \"\"\"\n        self.assertOutput(source, [\"local\", \"global\"])\n    \n    def test_undefined_variable_error(self):\n        \"\"\"Test accessing undefined variable raises proper error.\"\"\"\n        source = \"print not_defined;\"\n        \n        with self.assertRaises(UndefinedVariableError) as context:\n            self.interpreter.interpret(source)\n        \n        # Verify error message contains variable name\n        self.assertIn(\"not_defined\", str(context.exception))\n```\n\n**Language-Specific Hints for Python Testing**\n\n- Use `unittest.TestCase` as base class for all test cases\n- Set up fresh interpreter instances in `setUp()` method to ensure test isolation\n- Use `self.assertRaises()` context manager for testing expected exceptions\n- Capture standard output with `io.StringIO` when testing `print` statements\n- Consider using `@unittest.skip(\"reason\")` decorator for tests not yet implemented\n- Run tests from command line with: `python -m unittest discover -s tests -v`\n\n**Milestone Checkpoint Verification**\n\nFor each milestone, after implementing the features, run the corresponding checkpoint test:\n\n```bash\n# Run all tests for a specific milestone\npython -m unittest tests.milestone_checkpoints.test_milestone1 -v\npython -m unittest tests.milestone_checkpoints.test_milestone2 -v\npython -m unittest tests.milestone_checkpoints.test_milestone3 -v\npython -m unittest tests.milestone_checkpoints.test_milestone4 -v\n\n# Run all tests\npython -m unittest discover -s tests -v\n```\n\n**Expected Success Indicators:**\n- All tests pass with \"OK\" status\n- No unexpected errors or warnings\n- Test output shows the correct number of tests run and passed\n\n**Common Failure Patterns and Diagnosis:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **All tests fail immediately** | Import errors in test files | Check Python path and imports | Ensure `src/` is in `PYTHONPATH` or use relative imports |\n| **Variable tests pass but print wrong values** | `_stringify()` method incorrect | Add debug prints in `_stringify()` | Ensure each value type converts to string properly |\n| **Scope tests fail intermittently** | Environment parent chain broken | Print environment chain during lookup | Verify `parent` references are correctly maintained |\n| **Control flow tests hang** | Infinite loop in test execution | Add loop iteration counter with guard | Ensure loop conditions eventually become false |\n| **Error tests don't raise exceptions** | Exceptions caught somewhere in call chain | Add try-catch in interpreter to see if error is swallowed | Ensure errors propagate to test level |\n| **Closure tests show wrong values** | Closure environment captured incorrectly | Print closure environment at definition vs call | Store defining environment, not current one |\n\n**Debugging Tips Table**\n\n| Debugging Technique | How to Apply | When to Use |\n|-------------------|--------------|-------------|\n| **Strategic Print Logging** | Add `print(f\"DEBUG: {variable}\")` at key points | When you need to see execution flow or variable values |\n| **AST Visualization** | Print AST structure before evaluation | When unsure how the parser is structuring the code |\n| **Environment Inspection** | Add method to print entire environment chain | When debugging scope or variable lookup issues |\n| **Step-by-Step Debugger** | Use IDE debugger or `pdb.set_trace()` | For complex control flow or hard-to-find bugs |\n| **Minimal Test Case** | Reduce failing test to smallest reproducing case | When a large test fails and you need to isolate cause |\n| **Type Annotation Checking** | Use `mypy` or IDE type hints | When dealing with complex return types or value propagation |\n\n> **Key Testing Principle:** Write tests **alongside** implementation, not after. For each feature implemented, immediately write a test that verifies it works. This **test-driven development** approach ensures the interpreter remains correct at each step and makes debugging easier by catching errors close to their introduction point.\n\n\n## Debugging Guide\n\n> **Milestone(s):** 1, 2, 3, 4\n\nEven the most carefully designed interpreters contain bugs during implementation. This section provides a systematic approach to diagnosing and fixing common issues that arise when building a tree-walking interpreter. Unlike compiled systems where bugs often manifest as crashes or incorrect outputs, interpreter bugs frequently involve subtle misunderstandings of evaluation order, environment chain traversal, or control flow semantics. This guide equips you with concrete diagnostic techniques and a symptom-based lookup table to efficiently troubleshoot your implementation.\n\nThe core challenge in debugging a tree-walking interpreter is that you're building the very tool that would normally help you debug—there's no built-in debugger or elaborate logging system. Instead, you must instrument the interpreter itself to reveal its internal state. The key insight is to treat the interpreter as a **black box that you can make transparent** by adding observation points at critical junctions: before and after evaluating each node, during environment lookups, and when handling control flow jumps.\n\n### Symptom → Cause → Fix Table\n\nThe following table catalogs the most common symptoms, their root causes, and systematic approaches to diagnosis and correction. Each entry follows a four-column structure: the observable symptom, the most likely underlying cause, a step-by-step diagnostic procedure to confirm the hypothesis, and the specific fix to apply.\n\n| Symptom | Likely Cause | Diagnostic Steps | Fix |\n|---------|--------------|------------------|-----|\n| **Variable always returns `nil` or `undefined`** | The `Environment.get()` method is not correctly walking the parent chain, or the variable was never defined in the current or any enclosing scope. | 1. Insert print statements in `Environment.get()` showing the current environment's store and whether it has a parent.<br>2. Check that `Environment.define()` was called for this variable name during declaration evaluation.<br>3. Verify the environment chain structure: ensure inner scopes have their `parent` field set to the enclosing environment. | In `Environment.get()`, ensure the while-loop correctly traverses from `self` to `self.parent` until finding the name or reaching `None`. Return `UndefinedVariableError` only after the entire chain is exhausted. |\n| **Assignment modifies wrong scope or creates new variable** | `Environment.assign()` is incorrectly creating a new binding instead of updating an existing one, or it's only checking the current environment without walking the chain. | 1. Log both `assign()` and `define()` calls with the environment's identifier (e.g., \"global\", \"function local\").<br>2. Check if `assign()` returns successfully without finding the variable—it should raise `UndefinedVariableError`.<br>3. Verify that `_evaluate_assign_expr()` calls `env.assign()` not `env.define()`. | Implement `Environment.assign()` to recursively walk the parent chain exactly like `get()`. Only update if found; if the loop exits with `current is None`, raise `UndefinedVariableError`. |\n| **Binary operators work for numbers but not strings** | The `_evaluate_binary_expr()` method has type-checking logic that only handles numeric operands, or the operator dispatch doesn't include string concatenation for `+`. | 1. Check the operator token type in your evaluation logic.<br>2. Print the types of left and right operands before applying the operator.<br>3. Verify that string concatenation is explicitly handled for `TokenType.PLUS` (or equivalent). | Extend type-checking to allow string operands for `+` and possibly comparison operators. Implement explicit concatenation: `if operator == PLUS and isinstance(left, str) and isinstance(right, str): return left + right`. |\n| **If/else condition always executes the true branch** | The `_is_truthy()` helper function incorrectly treats non-boolean values (like 0, \"\", `nil`) as truthy, or the condition evaluation returns the AST node instead of its runtime value. | 1. Print the raw value passed to `_is_truthy()` and its output.<br>2. Verify that `_evaluate_if_stmt()` calls `_is_truthy()` on the evaluated condition result, not the condition node itself.<br>3. Test `_is_truthy()` with falsey values: `0`, `\"\"`, `false`, `nil`. | Implement `_is_truthy()` following language semantics: `nil` and `false` are falsey; numbers are truthy except 0; strings are truthy except empty string. Ensure condition is fully evaluated via `self.evaluate(node.condition, env)`. |\n| **While loop runs infinitely** | The loop condition is not being re-evaluated after each iteration, or the loop body fails to modify variables referenced in the condition. | 1. Add logging inside the while loop evaluation showing the condition value on each iteration.<br>2. Check that `_evaluate_while_stmt()` re-evaluates the condition node (not reusing the first result) before each iteration.<br>3. Trace variable modifications inside the loop body to ensure they affect the condition. | In `_evaluate_while_stmt()`, ensure the condition is evaluated inside the while loop: `while self._is_truthy(self.evaluate(node.condition, env)): ...`. |\n| **Break or continue causes interpreter crash** | The control flow signals (`BreakSignal`, `ContinueSignal`) are not being caught at the appropriate level (loop evaluators), or they're being propagated as regular values. | 1. Verify that `_evaluate_break_stmt()` and `_evaluate_continue_stmt()` raise the corresponding signal instances, not return them.<br>2. Check that `_evaluate_while_stmt()` and `_evaluate_for_stmt()` wrap the body evaluation in a try-catch that catches these signals.<br>3. Ensure signals aren't caught by generic exception handlers that treat them as errors. | Wrap the loop body evaluation in a try-except block. Catch `BreakSignal` to exit the loop entirely; catch `ContinueSignal` to skip to the next iteration. Re-raise signals not intended for the current loop level. |\n| **Function call returns `nil` regardless of return statement** | The `ReturnSignal` is not being properly caught and unpacked at the function call site, or the function body evaluation doesn't propagate the return value. | 1. Add logging in `_evaluate_call_expr()` showing the value returned from `function.call(arguments)`.<br>2. Check that `_evaluate_return_stmt()` raises a `ReturnSignal` with the value.<br>3. Verify that `FunctionValue.call()` catches `ReturnSignal` and returns its value, not the signal object. | In `FunctionValue.call()`, wrap the body evaluation in a try-except that catches `ReturnSignal`. Extract the signal's `value` attribute and return it. Ensure uncaught exceptions (like `BreakSignal`) are not mistakenly caught. |\n| **Closure accesses wrong variable value (sees global instead of outer)** | The `closure` field of `FunctionValue` is set incorrectly—likely to the global environment or the environment at call time instead of definition time. | 1. Print the closure environment's store when the function is defined and when it's called.<br>2. Verify that `_evaluate_function_decl()` captures the *current* environment (where the function is defined) as the closure.<br>3. Check that `FunctionValue.call()` creates the new environment with `self.closure` as parent, not the caller's environment. | Store `env` (the environment active during function definition) in the `FunctionValue.closure` field. In `call()`, create the new environment with parent=`self.closure`. |\n| **Logical AND (`&&`) or OR (`||`) evaluates both operands always** | Short-circuit evaluation is not implemented; both left and right operands are evaluated unconditionally before applying the logical operator. | 1. Add logging showing evaluation of left and right operands.<br>2. Test with an expression like `false && someUndefinedVariable()`—if it crashes, short-circuit is missing.<br>3. Check the operator dispatch logic for `AND` and `OR` tokens. | Implement short-circuit: For `AND`, evaluate left operand; if falsey, return it; otherwise evaluate and return right. For `OR`, evaluate left; if truthy, return it; otherwise evaluate and return right. |\n| **Division by zero crashes with Python/Java exception instead of `DivisionByZeroError`** | The `_evaluate_binary_expr()` does not check for division by zero before performing the operation, letting the host language raise its own exception. | 1. Check the operator type for `TokenType.SLASH` and `TokenType.PERCENT`.<br>2. Verify that the right operand is checked against zero (using `_is_zero()` helper) before division.<br>3. Ensure the check uses interpreter's numeric representation, not host-language truthiness. | Before performing division or modulo, call `self._is_zero(right)`. If true, raise a `DivisionByZeroError` with the operator token. Ensure `_is_zero()` handles the interpreter's number type (float/int). |\n| **Variable shadowing doesn't work—inner scope sees outer value** | The environment chain lookup is incorrectly stopping at the first occurrence of the name, even if it's in a parent environment, when the name is redefined in the current environment. | 1. Log the store of each environment during a lookup.<br>2. Verify that `Environment.define()` adds the name to the current environment's store even if it exists in a parent.<br>3. Check that `Environment.get()` looks in the current store first, then recursively checks parent—this automatically implements shadowing. | Ensure `Environment.get()` uses `while current:` and checks `if name in current.store: return current.store[name]`. This gives precedence to the innermost definition, shadowing outer ones. |\n| **Block statement doesn't create new scope** | The `_evaluate_block_stmt()` evaluates statements in the same environment passed in, instead of creating a new child environment. | 1. Check if variable defined inside block is accessible outside it (should not be in lexical scoping).<br>2. Print environment identifiers before and after block execution.<br>3. Verify that `_evaluate_block_stmt()` creates a new `Environment` with the given env as parent. | In `_evaluate_block_stmt()`, create a new environment with parent=`env`. Evaluate all block statements within this new environment. The outer environment remains unchanged. |\n| **For-loop variables leak into outer scope** | The for-loop desugaring incorrectly uses the same environment for initializer, condition, increment, and body, rather than creating a enclosing block scope. | 1. Check if the loop variable (from the initializer) is accessible after the loop ends.<br>2. Examine your desugaring logic: does it wrap the while-loop in a new environment?<br>3. Verify that the initializer (often a `var` statement) is evaluated in the appropriate environment. | When desugaring a for-loop, create a new environment for the entire loop. Place the initializer, condition, increment, and body inside this environment. This contains the loop variable. |\n| **Recursive function causes infinite recursion or stack overflow** | The function's name is not bound in its own local environment, so recursive calls cannot find the function within its body. The function value exists only in the outer environment. | 1. Check if the function name is defined in the environment where the function body executes.<br>2. Print the environment store inside `FunctionValue.call()`—does it contain the function's name?<br>3. Verify that `_evaluate_function_decl()` both creates the `FunctionValue` *and* defines it in the current environment. | In `_evaluate_function_decl()`, create the `FunctionValue` with the current environment as closure, then immediately call `env.define(node.name, function_value)`. This ensures the function name is bound in the scope where it's defined, enabling recursion. |\n| **Equality operator (`==`) returns false for identical values** | The equality check is comparing object identity (like Python's `is`) instead of value equality, or it's not handling all runtime value types (numbers, strings, booleans, `nil`). | 1. Print the types and values of left and right operands.<br>2. Test equality with `nil == nil` (should be true).<br>3. Verify that the equality operator uses deep value comparison, not reference comparison. | Implement type-specific equality: compare numbers numerically, strings character-wise, booleans directly. Treat `nil` as equal only to `nil`. Consider implementing a helper `_is_equal(a, b)` that handles all types. |\n| **Unary minus (`-`) applied to boolean or string crashes** | The `_evaluate_unary_expr()` does not validate that the operand is a number for the negation operator. | 1. Check the operator type and operand type.<br>2. Verify that `_evaluate_unary_expr()` includes type checking similar to binary operators.<br>3. Test with `-\"string\"` or `-true`. | Before applying unary minus, verify the operand is a number (using `isinstance(operand, (int, float))` or similar). If not, raise a `TypeError`. |\n\n### Debugging Techniques and Tools\n\nWhen systematic deduction from the symptom table isn't sufficient, you need to actively instrument your interpreter to observe its internal state. These techniques transform the interpreter from an opaque box into a transparent observatory of execution dynamics.\n\n#### Strategic Print Logging\n\nThe most direct and effective debugging technique is to insert print statements at key points in the evaluation pipeline. This creates a trace of execution that reveals the flow through the AST, the values being computed, and the state of the environment chain.\n\n> **Design Insight:** Think of print logging as installing security cameras throughout a factory assembly line. Each camera (print statement) shows what's happening at a specific workstation (component), allowing you to see where the product (program execution) goes off track.\n\nCreate a consistent logging format that includes:\n1. **Node type and location** (line number from token if available)\n2. **Evaluation phase** (entering/exiting the node)\n3. **Current environment identifier** (e.g., \"global\", \"function:foo\", \"block@line5\")\n4. **Relevant values** (operands, results, variable names)\n\nExample logging approach:\n```python\n# In your Evaluator.evaluate() method\ndef evaluate(self, node, env):\n    print(f\"[EVAL] Entering {node.__class__.__name__} at line {node.token.line if hasattr(node, 'token') else '?'}\")\n    print(f\"      Environment: {id(env)} parent: {id(env.parent) if env.parent else None}\")\n    \n    result = self._dispatch_evaluate(node, env)\n    \n    print(f\"[EVAL] Exiting {node.__class__.__name__} -> {repr(result)}\")\n    return result\n```\n\nFor environment operations, add logging to `define`, `get`, and `assign`:\n```python\ndef get(self, name):\n    print(f\"[ENV] Lookup '{name}' in env {id(self)}\")\n    current = self\n    while current:\n        if name in current.store:\n            print(f\"[ENV] Found '{name}' = {current.store[name]} in env {id(current)}\")\n            return current.store[name]\n        print(f\"[ENV] Not in env {id(current)}, moving to parent {id(current.parent) if current.parent else None}\")\n        current = current.parent\n    # ... error handling\n```\n\nThis trace will show you exactly how variable lookups traverse the environment chain, where values are defined, and when shadowing occurs.\n\n#### AST and Environment Visualization\n\nSometimes you need to see the structure of the program and the runtime state simultaneously. Create simple visualization utilities that dump the AST as an indented tree and display the environment chain as nested dictionaries.\n\n**AST Visualizer:** Write a recursive function that prints each node with increasing indentation. This helps verify that the parser produces the expected structure, especially for complex expressions and nested statements.\n```\nProgram\n  Block\n    VarStmt (x)\n      Literal: 5\n    WhileStmt\n      Binary (<)\n        Variable: x\n        Literal: 10\n      Block\n        ExpressionStmt\n          Assign (=)\n            Variable: x\n            Binary (+)\n              Variable: x\n              Literal: 1\n```\n\n**Environment Chain Dumper:** Create a function that walks from the current environment up to the global environment, printing each level's bindings:\n```\nEnvironment @0x7f8a (global)\n  store: {'PI': 3.14159, 'print': <Function>}\nEnvironment @0x7f9b (parent=0x7f8a) [function:fib]\n  store: {'n': 5}\nEnvironment @0x7fac (parent=0x7f9b) [block]\n  store: {'a': 1, 'b': 1}\n```\n\nSeeing both the static structure (AST) and dynamic state (environment chain) side-by-side often reveals mismatches between what you think should happen and what actually happens.\n\n#### Interactive Debugger via REPL Hook\n\nFor the most powerful debugging, extend your interpreter's REPL (Read-Eval-Print Loop) to include inspection commands. Even if your interpreter doesn't have a full REPL, you can add a debug mode that pauses execution at breakpoints.\n\nImplement a simple debug command interface:\n- `env` - show current environment chain\n- `step` - evaluate next AST node\n- `continue` - run to completion\n- `print <expr>` - evaluate expression in current environment\n\nThis approach requires modifying the evaluator to accept callbacks or check for debug flags, but it pays dividends when debugging complex control flow or closure issues. The mental model here is that of a **surgical microscope**—you can pause execution at any moment, examine the precise state, and then proceed incrementally.\n\n#### Using Your Language's Debugger\n\nDon't forget that you're writing the interpreter in a host language (Python, JavaScript, etc.) that likely has its own debugger. You can use pdb (Python), debugger statements (JavaScript), or IDE debuggers to step through your interpreter's code.\n\n**Key breakpoints to set:**\n1. At the entry to `Evaluator.evaluate()` to catch every node evaluation\n2. Inside `Environment.get()` when a specific variable name is looked up\n3. Inside `FunctionValue.call()` to observe function invocation\n4. Around the try-catch blocks that handle control flow signals\n\nWhen using a host-language debugger, pay attention to the call stack—it will mirror the interpreter's own call stack as it recursively evaluates nodes. This can help identify missing base cases or infinite recursion.\n\n#### Differential Testing Against Known Implementations\n\nWhen a bug is particularly elusive, create a test suite of small programs and compare your interpreter's output against a known correct implementation (like JavaScript for a JavaScript-like syntax, or Python for a Python-like syntax). This can help isolate semantic differences in edge cases.\n\n1. Write a minimal program that exhibits the bug\n2. Run it through a reference interpreter (if available)\n3. Compare outputs step-by-step\n4. Isolate the first point of divergence—this is where your bug lies\n\nThis technique is especially useful for verifying subtle semantics of closure capture, variable hoisting (if implemented), and truthiness rules.\n\n### Implementation Guidance\n\nThe following implementation guidance provides concrete code for debugging utilities and integration points to help you instrument your interpreter effectively.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Logging | Print statements with manual formatting | Python's `logging` module with configurable levels |\n| AST Visualization | Recursive print function with indentation | Graphviz output for graphical tree representation |\n| Environment Inspection | Manual store dumping | Interactive debugger with readline support |\n| Tracing | Conditional `DEBUG` flag in evaluator | Decorator-based tracing that can be enabled/disabled per module |\n\n#### B. Recommended File/Module Structure\n\nAdd debugging utilities in a separate module to keep your core interpreter clean:\n\n```\ninterpreter/\n  ast/                    # AST node definitions\n  parser/                 # Parser components\n  interpreter.py          # Main Interpreter class\n  evaluator.py            # Core Evaluator class\n  environment.py          # Environment class\n  debug/                  # Debugging utilities\n    __init__.py\n    tracer.py             # Evaluation tracer with indented logs\n    visualizer.py         # AST and environment visualizers\n    repl_debugger.py      # Interactive debugger extension\n  errors.py               # Runtime error definitions\n  main.py                 # CLI entry point\n```\n\n#### C. Complete Debug Tracer (Ready to Use)\n\nHere's a complete tracer class that can be wrapped around your evaluator to log all evaluation steps:\n\n```python\n# debug/tracer.py\nimport sys\n\nclass DebugTracer:\n    def __init__(self, enabled=True, output=sys.stdout):\n        self.enabled = enabled\n        self.output = output\n        self.indent_level = 0\n        self.current_line = 0\n    \n    def trace(self, message, node=None):\n        if not self.enabled:\n            return\n        \n        # Update line number if node has token\n        if node and hasattr(node, 'token') and node.token:\n            self.current_line = node.token.line\n        \n        indent = \"  \" * self.indent_level\n        line_info = f\"line {self.current_line}: \" if self.current_line else \"\"\n        self.output.write(f\"{indent}[TRACE] {line_info}{message}\\n\")\n    \n    def enter_node(self, node_type, description=\"\"):\n        if not self.enabled:\n            return\n        self.trace(f\"--> {node_type} {description}\")\n        self.indent_level += 1\n    \n    def exit_node(self, node_type, result=None):\n        if not self.enabled:\n            return\n        self.indent_level -= 1\n        result_str = f\" -> {repr(result)}\" if result is not None else \"\"\n        self.trace(f\"<-- {node_type}{result_str}\")\n    \n    def env_operation(self, op, name, value=None, env_id=None):\n        if not self.enabled:\n            return\n        env_str = f\" env={env_id}\" if env_id else \"\"\n        value_str = f\" = {repr(value)}\" if value is not None else \"\"\n        self.trace(f\"[ENV] {op} '{name}'{value_str}{env_str}\")\n```\n\n#### D. Core Evaluator Integration with Tracer\n\nModify your Evaluator to optionally use the tracer:\n\n```python\n# evaluator.py\nfrom debug.tracer import DebugTracer\n\nclass Evaluator:\n    def __init__(self, debug=False):\n        self.tracer = DebugTracer(enabled=debug)\n    \n    def evaluate(self, node, env):\n        # TODO 1: Trace entering this node (use node.__class__.__name__)\n        # TODO 2: Call the appropriate evaluation method based on node type\n        # TODO 3: Trace exiting this node with the result\n        # TODO 4: Return the result\n        pass\n    \n    def _evaluate_binary_expr(self, node, env):\n        # TODO 1: Trace entering binary expression with operator\n        # TODO 2: Evaluate left operand\n        # TODO 3: Evaluate right operand  \n        # TODO 4: Apply operator with type checking\n        # TODO 5: Trace exiting with result\n        # TODO 6: Return result\n        pass\n    \n    # ... other evaluation methods with similar tracing\n```\n\n#### E. Environment Class with Debug Support\n\nAugment your Environment class to support debugging:\n\n```python\n# environment.py\nclass Environment:\n    def __init__(self, parent=None, name=\"anonymous\"):\n        self.store = {}\n        self.parent = parent\n        self.name = name\n        self.id = id(self)  # For debugging identification\n    \n    def define(self, name, value):\n        # TODO 1: Add tracing: self.tracer.env_operation('DEFINE', name, value, self.id)\n        # TODO 2: Store the name-value pair in self.store\n        pass\n    \n    def get(self, name):\n        # TODO 1: Trace the lookup attempt\n        # TODO 2: Walk the parent chain, tracing each step\n        # TODO 3: If found, trace the successful find and return value\n        # TODO 4: If not found, raise UndefinedVariableError\n        pass\n    \n    def assign(self, name, value):\n        # TODO 1: Trace the assignment attempt\n        # TODO 2: Walk the parent chain to find existing binding\n        # TODO 3: If found, update and trace\n        # TODO 4: If not found, raise UndefinedVariableError\n        pass\n```\n\n#### F. Debugging Tips for Specific Languages\n\n**Python:**\n- Use `f-string` formatting for concise debug output\n- The `id()` function returns a unique identifier for objects—useful for distinguishing environment instances\n- `repr(value)` gives a programmer-friendly string representation\n- Consider using `contextlib.redirect_stdout` to capture debug output in tests\n\n**JavaScript:**\n- `console.group()` and `console.groupEnd()` create indented debug groups\n- Use `performance.now()` for timing specific operations\n- `JSON.stringify()` with a replacer function can help inspect circular structures\n\n**Java:**\n- Use `System.identityHashCode()` for object identifiers\n- Override `toString()` in AST nodes and Environment for better debug output\n- Consider using a logging framework like SLF4J with different log levels\n\n#### G. Milestone Debugging Checkpoints\n\nAfter implementing each milestone, run these diagnostic programs to verify core functionality:\n\n**Milestone 1 (Expressions):**\n```javascript\nprint 1 + 2 * 3;        // Should print 7, not 9\nprint (1 + 2) * 3;      // Should print 9\nprint !true == false;   // Should print true\nprint 1 / 0;            // Should raise DivisionByZeroError\n```\n\n**Milestone 2 (Variables):**\n```javascript\nvar x = 10;\n{\n  var x = 20;\n  print x;  // Should print 20\n}\nprint x;    // Should print 10 (shadowing works)\nprint y;    // Should raise UndefinedVariableError\n```\n\n**Milestone 3 (Control Flow):**\n```javascript\nvar i = 0;\nwhile (i < 3) {\n  if (i == 1) break;\n  print i;\n  i = i + 1;\n}\n// Should print 0 only (break works)\n```\n\n**Milestone 4 (Functions):**\n```javascript\nvar x = \"global\";\nfunction outer() {\n  var x = \"outer\";\n  function inner() {\n    return x;\n  }\n  return inner;\n}\nvar fn = outer();\nprint fn();  // Should print \"outer\" (closure works)\n```\n\nIf any test produces unexpected output, use the debugging techniques above to trace through the execution step by step.\n\n#### H. Common Debug Workflow\n\nWhen confronted with a bug, follow this systematic workflow:\n\n1. **Minimize**: Create the smallest possible program that reproduces the bug\n2. **Observe**: Run with debug tracing enabled, capturing all output\n3. **Hypothesize**: Based on the trace, form a hypothesis about the root cause\n4. **Test**: Add additional logging to confirm or refute your hypothesis\n5. **Fix**: Implement the correction\n6. **Verify**: Run the minimized test and all existing tests to ensure no regressions\n\nRemember that most interpreter bugs stem from a few recurring themes: incorrect environment chain traversal, mishandled control flow signals, missing type checks, or improper closure capture. By methodically applying these debugging techniques, you'll develop both the skills to fix bugs and the intuition to avoid them in the first place.\n\n\n## Future Extensions\n\n> **Milestone(s):** This section explores potential enhancements beyond the four core milestones, providing a roadmap for extending the interpreter's capabilities and evolving its architecture.\n\nWhile the current interpreter implements the essential features of a dynamic, lexically-scoped language with first-class functions, its design intentionally leaves room for growth. This section outlines natural extensions that build upon the existing architecture, showing how each enhancement fits into—or requires modification of—the current component design. These extensions provide excellent pathways for deepening understanding of language implementation and interpreter architecture.\n\n### Language Feature Extensions\n\nThe interpreter's core evaluation engine and environment model provide a solid foundation for adding more sophisticated language features. These extensions would make the language more practical and expressive while demonstrating important programming language concepts.\n\n#### Arrays and Hashes (Composite Data Types)\n\n**Mental Model: The Filing Cabinet and Key-Ring Box**\nThink of arrays as numbered filing cabinets where each drawer (index) holds a value, accessible by its numerical position. Hashes (or dictionaries) are like a key-ring box where each unique key unlocks a specific compartment holding a value. Both are **compound values**—single runtime objects that contain multiple other values, requiring the interpreter to manage collections as first-class entities.\n\n**Design Impact and Integration Strategy**\nAdding arrays and hashes requires extending several interconnected components:\n\n1. **Runtime Value System**: New `ArrayValue` and `HashValue` classes would join the existing runtime value hierarchy. These must be immutable (by the AST) but mutable at runtime through operations.\n\n2. **Literal Syntax and AST Nodes**: The parser would need to recognize `[1, 2, 3]` and `{\"key\": \"value\"}` syntax, creating new `ArrayLiteral` and `HashLiteral` AST nodes containing their element expressions.\n\n3. **Indexing Operations**: Both get (`array[0]`) and set (`array[0] = 5`) operations require new expression node types and evaluation logic that integrates with the existing `Evaluator._evaluate_binary_expr` or a new specialized handler.\n\n4. **Built-in Methods**: Practical arrays and hashes need operations like `push`, `length`, `keys`, etc., which could be implemented as built-in functions or as methods on the value objects themselves.\n\n**Data Structure Extensions Table**\n| Component | Current Design | Extended Design for Collections |\n|-----------|----------------|----------------------------------|\n| Runtime Values | `Number`, `String`, `Boolean`, `Nil`, `FunctionValue` | Add `ArrayValue` (stores `list`), `HashValue` (stores `dict`) |\n| AST Nodes | `Literal`, `Binary`, `Unary`, `Call`, etc. | Add `ArrayLiteral`, `HashLiteral`, `SubscriptExpr`, `SubscriptAssign` |\n| Environment Storage | Any primitive value or `FunctionValue` | Can now store `ArrayValue` and `HashValue` references |\n| Equality Comparison | Works for primitives | Need reference vs. value semantics decision for collections |\n\n**> Decision: Reference Semantics for Compound Types**\n> - **Context**: When arrays and hashes are assigned to variables or passed as arguments, we must decide whether copies are made (value semantics) or references are shared (reference semantics).\n> - **Options Considered**:\n>   1. **Value Semantics**: Each assignment creates a deep copy of the entire collection\n>   2. **Reference Semantics**: Variables hold references to the same underlying collection object\n>   3. **Copy-on-Write Hybrid**: References until modification, then copy\n> - **Decision**: **Reference semantics** (option 2)\n> - **Rationale**: Most dynamic languages (JavaScript, Python, Ruby) use reference semantics for collections for performance and consistency. Value semantics would require expensive deep copying on every assignment and function call. The mental model of \"variables hold references to objects\" is consistent with function objects already implemented.\n> - **Consequences**: Variables can alias the same array, modifications through one variable affect all references. This requires careful implementation of equality operators (typically reference equality unless implementing deep equality).\n\n| Option | Pros | Cons | Suitable For |\n|--------|------|------|--------------|\n| Value Semantics | No aliasing surprises, simpler reasoning | Performance cost on assignment/calls, memory overhead | Languages emphasizing immutability |\n| Reference Semantics | Fast assignment/passing, matches industry norms | Aliasing can cause bugs, requires GC consideration | Most imperative dynamic languages |\n| Copy-on-Write | Best of both worlds when reading | Complex implementation, still has copy cost on write | Specialized use cases |\n\n**Common Implementation Pitfalls**\n1. ⚠️ **Pitfall: Forgetting to Clone Arrays in Literals**  \n   **Description**: Using the same list object for multiple array literals due to Python's mutable default arguments or object reuse.  \n   **Why Wrong**: Modifying one array would affect all arrays created with the same literal syntax.  \n   **Fix**: Always create fresh `list`/`dict` objects when evaluating array/hash literals.\n\n2. ⚠️ **Pitfall: Index Type Checking at Runtime**  \n   **Description**: Allowing non-integer indices for arrays or non-hashable keys for dictionaries without error.  \n   **Why Wrong**: `array[\"string\"]` should raise a `TypeError`, not silently fail or behave unpredictably.  \n   **Fix**: In `Evaluator._evaluate_subscript_expr`, validate index types before access.\n\n#### Classes and Object-Oriented Programming\n\n**Mental Model: The Factory Blueprint and Instance Stamp**\nA class is like a factory blueprint that defines (1) what attributes every object made from it contains, and (2) the operations (methods) those objects can perform. Each object instance is a stamped copy from that blueprint with its own set of attribute values. Methods are special functions that implicitly receive the instance (`this`/`self`) as their first argument.\n\n**Design Impact and Integration Strategy**\nAdding classes represents the most significant language extension, touching nearly every component:\n\n1. **Runtime Value System**: New `ClassValue` and `InstanceValue` types. `ClassValue` stores method definitions and inheritance chain; `InstanceValue` stores instance fields and class reference.\n\n2. **Environment Model Extension**: Methods need access to both instance fields (through `self`) and class-level static members. This may require a specialized environment chain linking instance → class → parent class → global.\n\n3. **Method Invocation**: The call mechanism must handle the implicit `self` binding. This could extend the existing `FunctionValue.call` or create a new `MethodValue` wrapper.\n\n4. **Inheritance**: Requires implementing property/method lookup along the prototype chain, analogous to environment chain lookup but for properties.\n\n**ADR: Class Implementation Strategy**\n\n> **Decision: Prototype-Based vs. Class-Based OOP**\n> - **Context**: We must choose between class-based inheritance (Java, Python) and prototype-based delegation (JavaScript, Lua).\n> - **Options Considered**:\n>   1. **Class-Based (Classical)**: Explicit class definitions with `class` keyword, constructor methods, and fixed inheritance hierarchies\n>   2. **Prototype-Based**: Objects inherit directly from other objects via prototype chain, more dynamic but less structured\n>   3. **Hybrid**: Class syntax that compiles to prototype chains (like JavaScript ES6)\n> - **Decision**: **Class-based with explicit syntax** (option 1)\n> - **Rationale**: More intuitive for learners coming from Java, Python, or C++. The mental model of blueprints and instances is straightforward. The implementation aligns well with the existing `Environment` chain concept (inheritance chain is similar to parent environment lookup).\n> - **Consequences**: Requires new syntax (`class`, `new`, `this`), constructor handling, and explicit inheritance resolution. Less dynamic than prototypes but more structured.\n\n| Option | Pros | Cons | Implementation Complexity |\n|--------|------|------|---------------------------|\n| Class-Based | Familiar syntax, clear mental model | Less dynamic, more syntax to parse | Medium |\n| Prototype-Based | Extremely flexible, minimal syntax | Unfamiliar to many, \"magical\" behavior | Medium-High |\n| Hybrid | Modern feel, backward compatibility | Complex transformation step | High |\n\n**Example Class Evaluation Steps**\n1. When encountering a `ClassStatement`, the evaluator creates a `ClassValue` object storing:\n   - Class name\n   - Methods dictionary (mapping method names to `FunctionValue` objects)\n   - Parent class reference (for inheritance)\n2. The class is bound to its name in the current environment\n3. When evaluating `new ClassName(args)`:\n   - Create an `InstanceValue` with a reference to its class\n   - Create a new environment for the instance (for `this` access)\n   - Call the constructor method with the instance as implicit `self`\n   - Return the instance\n4. Method calls `obj.method(arg)`:\n   - Look up method in the instance's class (walking inheritance chain)\n   - Bind `self` to the instance (creating a bound method or adjusting call context)\n   - Call with remaining arguments\n\n#### Exception Handling\n\n**Mental Model: The Emergency Exit Rope**\nExceptions are like emergency exit ropes in a building—when something goes wrong deep inside nested rooms (function calls), you can pull the rope to immediately exit multiple levels until reaching a designated rescue station (catch block). The rope carries information about what went wrong (exception object).\n\n**Design Impact and Integration Strategy**\nException handling requires non-local control flow that jumps out of multiple nested environments, similar to but more general than `return`:\n\n1. **Exception Value Type**: New `ExceptionValue` runtime type to carry error messages, types, and stack traces.\n\n2. **Control Flow Extension**: Beyond `BreakSignal`, `ContinueSignal`, and `ReturnSignal`, we'd need `ThrowSignal` carrying an exception value.\n\n3. **Unwinding Mechanism**: The evaluator must catch `ThrowSignal` at appropriate points (in `try` blocks) and unwind the evaluation stack until finding a matching `catch`.\n\n4. **Stack Trace Collection**: To provide useful error messages, the interpreter needs to track the call stack during evaluation.\n\n**> Decision: Exception Handling Implementation Strategy**\n> - **Context**: We need to implement non-local exit from arbitrary depth with resumable execution at catch blocks.\n> - **Options Considered**:\n>   1. **Exception Signals**: Extend the existing control flow signal system with `ThrowSignal` and try/catch handlers in the evaluator\n>   2. **Return Code Propagation**: Each evaluation method returns a `(value, exception)` pair that callers must check\n>   3. **True Stack Unwinding**: Maintain an explicit evaluation stack and unwind it when exceptions occur\n> - **Decision**: **Exception Signals** (option 1)\n> - **Rationale**: Consistent with the existing `ReturnSignal`, `BreakSignal`, and `ContinueSignal` pattern. The evaluator already has infrastructure to catch these signals at appropriate boundaries. Minimal disruption to existing evaluation methods.\n> - **Consequences**: All statement evaluation methods must properly propagate uncaught `ThrowSignal`. Try/catch blocks become special statement nodes that catch these signals.\n\n**Exception Handling Algorithm Overview**\n1. `throw expression` evaluates the expression to get an exception value, then raises `ThrowSignal(value)`\n2. `try { block } catch (identifier) { handler }` statement evaluation:\n   - Wrap block evaluation in a try-catch that catches `ThrowSignal`\n   - If signal caught, create new environment for catch block with identifier bound to exception value\n   - Evaluate handler in that environment\n3. The evaluator's top level catches any uncaught `ThrowSignal` and reports it as a runtime error\n\n#### Standard Library Functions\n\n**Mental Model: The Toolbox Included with the Workshop**\nA standard library is like a toolbox that comes with a workshop—basic tools (functions) for common tasks that would be tedious to build from scratch every time. These are built-in functions that are always available in the global environment.\n\n**Design Impact and Integration Strategy**\nAdding standard library functions is one of the easiest extensions:\n\n1. **Native Function Type**: Create a `NativeFunctionValue` that wraps Python/JavaScript/Java functions, distinct from user-defined `FunctionValue`.\n\n2. **Global Environment Initialization**: Populate the initial global environment with useful functions like `print`, `clock`, `input`, `toString`, `length` (for strings/arrays), etc.\n\n3. **Variadic Functions**: Some built-ins (like `print`) accept any number of arguments, requiring flexible argument handling.\n\n4. **Type Coercion Helpers**: Functions for converting between types (string to number, etc.).\n\n**Built-in Function Table Example**\n| Function Name | Arguments | Returns | Description |\n|---------------|-----------|---------|-------------|\n| `print` | Any number of values | `nil` | Converts each value to string and outputs |\n| `clock` | None | Number | Returns current time in seconds |\n| `length` | String or Array | Number | Returns character count or element count |\n| `substring` | String, start, end | String | Extracts portion of string |\n| `arrayPush` | Array, value | `nil` | Appends value to array |\n| `toNumber` | String | Number or `nil` | Converts string to number if possible |\n\n**Implementation Simplicity**: Each built-in can be implemented as a regular function in the host language that's wrapped in a `NativeFunctionValue` and added to the global environment during interpreter initialization.\n\n#### Tail-Call Optimization\n\n**Mental Model: The Recycling Elevator**\nNormally, each function call is like taking a new elevator car up a floor—you accumulate more cars (stack frames) as you nest calls. Tail-call optimization is like having a recycling elevator that reuses the same car when you immediately return to go up another floor, preventing the accumulation of cars (stack overflow) during deep recursion.\n\n**Design Impact and Integration Strategy**\nTail-call optimization (TCO) allows recursive function calls in tail position to reuse the current stack frame:\n\n1. **Tail Position Identification**: A call is in tail position if its value is immediately returned (e.g., `return f(x)` or `f(x)` at end of function).\n\n2. **Evaluation Strategy Modification**: Instead of recursively calling `Evaluator.evaluate` for the tail call, the evaluator would:\n   - Reuse the current environment (after updating parameters)\n   - Jump back to function body evaluation instead of nesting deeper\n\n3. **Implementation Approaches**:\n   - **Trampoline**: Transform evaluation to iterative loop with explicit continuation passing\n   - **Direct Optimization**: Special handling in `ReturnSignal` and function call evaluation\n   - **Source Transformation**: Rewrite tail calls during parsing/compilation\n\n**Challenges and Considerations**\n- TCO changes stack trace behavior (fewer frames available for debugging)\n- Requires careful analysis of tail positions\n- Makes infinite recursion safe from stack overflow but still infinite loops\n- Could be implemented as optional optimization flag\n\n### Architectural Evolutions\n\nBeyond adding language features, the interpreter's architecture itself can evolve in significant ways. These transformations demonstrate how real-world language implementations grow in sophistication.\n\n#### From Tree-Walking to Bytecode Compilation and Virtual Machine\n\n**Mental Model: From Interpreting Sheet Music to Playing a Recording**\nA tree-walking interpreter is like a musician reading sheet music (AST) and playing each note as they see it. A bytecode compiler translates that sheet music into a piano roll (bytecode) that can be fed into a player piano (VM) for faster, more predictable execution. The piano roll is a denser, linear representation optimized for efficient execution.\n\n**Why Transform the Architecture?**\n| Aspect | Tree-Walking Interpreter | Bytecode VM |\n|--------|--------------------------|-------------|\n| Performance | Slow: repeated AST traversal, interpreter overhead | Faster: linear bytecode, direct instruction dispatch |\n| Memory Use | High: AST stays in memory, recursion overhead | Lower: compact bytecode, explicit stack |\n| Optimization Opportunities | Few: AST is high-level | Many: peephole, constant folding, JIT potential |\n| Implementation Complexity | Lower: direct mapping to language semantics | Higher: compiler + VM dual components |\n| Educational Value | Excellent for understanding semantics | Excellent for understanding execution models |\n\n**Migration Strategy: Incremental Compilation**\nThe current design can evolve incrementally toward a bytecode system:\n\n1. **Phase 1: AST to Bytecode Compiler**  \n   - Add a `Compiler` component that walks the AST and emits bytecode instructions\n   - Keep the existing `Evaluator` but have it interpret bytecode instead of AST nodes\n   - Initially compile each function/block to bytecode on first execution (lazy compilation)\n\n2. **Phase 2: Virtual Machine Core**  \n   - Replace the `Evaluator` with a `VM` class with:\n     - Instruction pointer (IP)\n     - Value stack (operand stack)\n     - Call stack (return addresses, frames)\n   - Implement instruction dispatch loop (giant switch on opcode)\n\n3. **Phase 3: Optimization Passes**  \n   - Add constant folding during compilation\n   - Implement basic block analysis\n   - Add simple peephole optimizations\n\n**Bytecode Instruction Set Example**\n| Instruction | Operands | Description | Stack Effect |\n|-------------|----------|-------------|--------------|\n| `CONSTANT` | index | Push constant from pool | `[] → [value]` |\n| `ADD` | - | Pop two values, push sum | `[a, b] → [a+b]` |\n| `GET_LOCAL` | slot | Push local variable value | `[] → [value]` |\n| `SET_LOCAL` | slot | Pop value, store in local | `[value] → []` |\n| `CALL` | arg_count | Call function with args | `[fn, arg1...argN] → [result]` |\n| `RETURN` | - | Return from function | `[value] → []` (in caller) |\n\n**Data Flow Transformation**\nCurrent: `Source → Parser → AST → Evaluator (recursive) → Result`  \nFuture: `Source → Parser → AST → Compiler → Bytecode → VM (iterative) → Result`\n\n**> Decision: Stack-Based vs. Register-Based VM**\n> - **Context**: When designing the bytecode VM, we must choose between stack-based architecture (Java JVM, Python) and register-based architecture (Lua, Dalvik).\n> - **Options Considered**:\n>   1. **Stack-Based**: Instructions implicitly operate on top of value stack\n>   2. **Register-Based**: Instructions explicitly reference virtual registers\n> - **Decision**: **Stack-based architecture** (option 1)\n> - **Rationale**: Simpler to implement and generate code for. The operand stack concept naturally matches expression evaluation order. Most educational VMs (including from Crafting Interpreters) use stack-based design, making resources more applicable.\n> - **Consequences**: More instructions may be needed (due to stack manipulation), but each instruction is simpler. Easier to reason about and debug.\n\n#### Adding a REPL and Debugger\n\n**Mental Model: The Conversation Partner and X-Ray Glasses**\nA REPL (Read-Eval-Print Loop) transforms the interpreter from a batch processor into a conversational partner—you give it a piece of code, it responds immediately with the result. A debugger adds X-ray glasses that let you see inside the running program: variable values, call stack, and execution flow.\n\n**REPL Design and Implementation**\nA REPL is surprisingly simple to add to the existing architecture:\n\n1. **Interactive Loop**: Wrap the interpreter in a loop that:\n   - Prints a prompt (`> `)\n   - Reads a line of input\n   - Parses and evaluates it\n   - Prints the result (using `Interpreter._stringify`)\n   - Repeats\n\n2. **Special REPL Behavior**:\n   - Allow multi-line input (e.g., function definitions spanning lines)\n   - Handle incomplete expressions gracefully\n   - Maintain environment state across inputs (persistent global environment)\n   - Support special commands (like `.exit`, `.reset`)\n\n3. **Implementation Integration**:\n   - The REPL shares the same `Interpreter`, `Evaluator`, and global `Environment`\n   - Each input is parsed and evaluated in the same context\n   - Variable definitions persist across inputs\n\n**Debugger Architecture**\nA debugger is more complex but builds naturally on existing components:\n\n1. **Breakpoint System**:\n   - Store breakpoints (source line numbers or function names)\n   - Check before each statement evaluation if at breakpoint\n   - Pause execution and enter debugger loop\n\n2. **Inspection Interface**:\n   - Access to current environment chain\n   - Call stack inspection (requires maintaining evaluation stack trace)\n   - Step-by-step execution control\n\n3. **Debugger Commands**:\n   - `step` (execute next statement)\n   - `continue` (resume execution)\n   - `print <expression>` (evaluate expression in current context)\n   - `backtrace` (show call stack)\n   - `locals` (show current environment variables)\n\n4. **Implementation Approaches**:\n   - **Passive Debugging**: Add instrumentation that can be toggled, pausing at breakpoints\n   - **Active Debugging**: Run interpreter in a separate thread/process with control channel\n   - **Source Mapping**: Map execution position back to source code for meaningful breakpoints\n\n**Example REPL Session Flow**\n```\n> var x = 10\nnil\n> x + 5\n15\n> fun add(a, b) { return a + b; }\nnil\n> add(3, 4)\n7\n> .exit\n```\n\n**The Debugger-Enhanced Evaluator**\nThe `Evaluator.evaluate` method would gain additional logic:\n```python\ndef evaluate(self, node, env):\n    # Debugger hook: check if we should break here\n    if self.debugger.should_break(node):\n        self.debugger.enter_debug_mode(node, env)\n    \n    # Original evaluation logic\n    # ...\n```\n\n### Implementation Guidance\n\nThis section provides practical starting points for implementing the extensions discussed above, focusing on the Python implementation as the primary language.\n\n#### Technology Recommendations Table\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Array/Hash Values | Python `list`/`dict` as backing store | Custom collection classes with copy-on-write |\n| Class System | Single inheritance with explicit `super` | Multiple inheritance with C3 linearization |\n| Exceptions | Control flow signals (extending existing system) | True stack unwinding with traceback objects |\n| Bytecode Compiler | Simple linear bytecode generation | Basic block analysis with optimization passes |\n| VM Implementation | Stack-based with switch dispatch | Register-based with computed goto (C extension) |\n| REPL Interface | Basic line-by-line input with `readline` | Full terminal UI with syntax highlighting |\n| Debugger | Simple breakpoint inspection | Remote debugging protocol with IDE integration |\n\n#### Recommended File/Module Structure\nFor a project extending the interpreter with these features, consider this expanded structure:\n```\ntree_walker/\n├── __init__.py\n├── interpreter.py          # Main Interpreter class, REPL integration\n├── parser/\n│   ├── __init__.py\n│   ├── parser.py          # Extended parser with new syntax\n│   └── ast_nodes.py       # New AST nodes for classes, try/catch, etc.\n├── compiler/              # For bytecode evolution\n│   ├── __init__.py\n│   ├── compiler.py        # AST → Bytecode compiler\n│   └── bytecode.py        # Bytecode instruction definitions\n├── vm/                    # For bytecode evolution\n│   ├── __init__.py\n│   └── virtual_machine.py # Stack-based VM implementation\n├── runtime/\n│   ├── __init__.py\n│   ├── values.py          # Extended runtime values (ArrayValue, ClassValue, etc.)\n│   ├── environment.py     # Enhanced for class inheritance chains\n│   └── builtins.py        # Standard library function implementations\n├── eval/\n│   ├── __init__.py\n│   ├── evaluator.py       # Extended Evaluator with new statement handlers\n│   ├── control_flow.py    # Exception signal handling\n│   └── debugger.py        # Debugger integration hooks\n└── repl/\n    ├── __init__.py\n    └── interactive.py     # REPL implementation with line editing\n```\n\n#### Infrastructure Starter Code: Native Function Wrapper\n\nHere's complete starter code for implementing built-in standard library functions, a prerequisite for many extensions:\n\n```python\n# runtime/builtins.py\n\"\"\"Built-in standard library functions.\"\"\"\n\nfrom typing import List, Any\nfrom runtime.values import Value, NativeFunctionValue, NumberValue, StringValue, ArrayValue\n\nclass Builtins:\n    \"\"\"Registry of built-in functions.\"\"\"\n    \n    @staticmethod\n    def clock(args: List[Value]) -> Value:\n        \"\"\"Return current time in seconds since epoch.\"\"\"\n        import time\n        return NumberValue(time.time())\n    \n    @staticmethod\n    def print(args: List[Value]) -> Value:\n        \"\"\"Print all arguments converted to strings.\"\"\"\n        from interpreter import Interpreter\n        strings = [Interpreter._stringify(arg) for arg in args]\n        print(\" \".join(strings))\n        return NilValue()  # Assuming NilValue is defined elsewhere\n    \n    @staticmethod\n    def length(args: List[Value]) -> Value:\n        \"\"\"Return length of string or array.\"\"\"\n        if len(args) != 1:\n            raise RuntimeError(\"length() expects exactly 1 argument\")\n        \n        val = args[0]\n        if isinstance(val, StringValue):\n            return NumberValue(len(val.value))\n        elif isinstance(val, ArrayValue):\n            return NumberValue(len(val.elements))\n        else:\n            raise TypeError(\"length() expects string or array\")\n    \n    @staticmethod\n    def array_push(args: List[Value]) -> Value:\n        \"\"\"Append value to array. Returns nil.\"\"\"\n        if len(args) != 2:\n            raise RuntimeError(\"array_push() expects 2 arguments (array, value)\")\n        \n        array, value = args[0], args[1]\n        if not isinstance(array, ArrayValue):\n            raise TypeError(\"First argument to array_push() must be array\")\n        \n        array.elements.append(value)\n        return NilValue()\n    \n    # More built-in functions...\n    \n    @classmethod\n    def get_all(cls) -> dict:\n        \"\"\"Return dictionary of all built-in functions for global environment.\"\"\"\n        return {\n            \"clock\": NativeFunctionValue(\"clock\", cls.clock, arity=0),\n            \"print\": NativeFunctionValue(\"print\", cls.print, arity=-1),  # -1 = variadic\n            \"length\": NativeFunctionValue(\"length\", cls.length, arity=1),\n            \"array_push\": NativeFunctionValue(\"array_push\", cls.array_push, arity=2),\n        }\n\n# runtime/values.py addition\nclass NativeFunctionValue(Value):\n    \"\"\"Runtime value representing a built-in function implemented in host language.\"\"\"\n    \n    def __init__(self, name: str, func: callable, arity: int):\n        self.name = name\n        self.func = func\n        self.arity = arity  # -1 for variadic\n    \n    def call(self, arguments: List[Value]) -> Value:\n        \"\"\"Execute the native function with given arguments.\"\"\"\n        # Check arity unless variadic\n        if self.arity >= 0 and len(arguments) != self.arity:\n            raise RuntimeError(f\"{self.name}() expects {self.arity} arguments, got {len(arguments)}\")\n        \n        try:\n            return self.func(arguments)\n        except Exception as e:\n            # Convert host language exceptions to interpreter runtime errors\n            raise RuntimeError(f\"Built-in function error: {e}\")\n    \n    def __str__(self) -> str:\n        return f\"<native function {self.name}>\"\n```\n\n#### Core Logic Skeleton Code: Class Evaluation\n\nFor implementing class-based OOP, here's skeleton code for the key evaluator methods:\n\n```python\n# eval/evaluator.py additions\nclass Evaluator:\n    # ... existing code ...\n    \n    def _evaluate_class_stmt(self, node: ClassStmt, env: Environment) -> Value:\n        \"\"\"\n        Evaluate a class definition statement.\n        \n        Steps:\n        1. Evaluate parent class expression if present (must evaluate to ClassValue)\n        2. Create a new environment for the class's methods (parent is global/env?)\n        3. Evaluate all method definitions in the class's environment\n        4. Create ClassValue with method dictionary and parent reference\n        5. Bind class name in current environment\n        6. Return nil\n        \"\"\"\n        # TODO 1: Handle parent class inheritance\n        #   if node.parent is not None:\n        #     parent = self.evaluate(node.parent, env)\n        #     if not isinstance(parent, ClassValue):\n        #         raise TypeError(\"Parent must be a class\")\n        #   else:\n        #     parent = None\n        \n        # TODO 2: Create class environment for method definitions\n        #   class_env = Environment(store={}, parent=env)  # Or parent's class env?\n        \n        # TODO 3: Evaluate each method definition in class_env\n        #   methods = {}\n        #   for method in node.methods:\n        #     # method is a FunctionStmt node\n        #     func_value = FunctionValue(\n        #         name=method.name,\n        #         parameters=method.params,\n        #         body=method.body,\n        #         closure=class_env  # Methods close over class environment\n        #     )\n        #     methods[method.name] = func_value\n        \n        # TODO 4: Create the ClassValue\n        #   class_value = ClassValue(\n        #         name=node.name,\n        #         methods=methods,\n        #         parent=parent,\n        #         class_env=class_env\n        #   )\n        \n        # TODO 5: Bind class name in current environment\n        #   env.define(node.name, class_value)\n        \n        # TODO 6: Return nil\n        return NilValue()\n    \n    def _evaluate_new_expr(self, node: NewExpr, env: Environment) -> Value:\n        \"\"\"\n        Evaluate 'new ClassName(arguments)' expression.\n        \n        Steps:\n        1. Evaluate the class expression (should be a ClassValue)\n        2. Create a new InstanceValue with reference to the class\n        3. Create a new environment for the instance (self)\n        4. If class has constructor ('init' method), call it with arguments\n        5. Return the instance\n        \"\"\"\n        # TODO 1: Evaluate class expression\n        #   class_value = self.evaluate(node.class_expr, env)\n        #   if not isinstance(class_value, ClassValue):\n        #     raise TypeError(\"Can only instantiate classes\")\n        \n        # TODO 2: Create InstanceValue\n        #   instance = InstanceValue(class_value)\n        \n        # TODO 3: Create instance environment for 'self'\n        #   instance_env = Environment(store={}, parent=???)\n        #   instance_env.define(\"self\", instance)\n        \n        # TODO 4: Find and call constructor if exists\n        #   if \"init\" in class_value.methods:\n        #     constructor = class_value.methods[\"init\"]\n        #     # Bind 'self' as implicit first argument\n        #     bound_args = [instance] + evaluated_args\n        #     constructor.call(bound_args, instance_env)\n        \n        # TODO 5: Return the instance\n        return instance\n    \n    def _evaluate_get_expr(self, node: GetExpr, env: Environment) -> Value:\n        \"\"\"\n        Evaluate 'object.property' expression.\n        \n        Steps:\n        1. Evaluate the object expression (should be InstanceValue)\n        2. Look up property name in instance fields first\n        3. If not found, look up in class methods (walking inheritance chain)\n        4. If found as method, return it bound to the instance\n        5. If not found, raise runtime error\n        \"\"\"\n        # TODO 1: Evaluate object expression\n        #   obj = self.evaluate(node.object, env)\n        #   if not isinstance(obj, InstanceValue):\n        #     raise TypeError(\"Only instances have properties\")\n        \n        # TODO 2: Check instance fields\n        #   if node.property in obj.fields:\n        #     return obj.fields[node.property]\n        \n        # TODO 3: Look up in class method chain\n        #   method = obj.klass.find_method(node.property)\n        #   if method is not None:\n        #     # Return a bound method (function with self pre-bound)\n        #     return BoundMethodValue(instance=obj, method=method)\n        \n        # TODO 4: Raise property error if not found\n        raise RuntimeError(f\"Undefined property '{node.property}'\")\n```\n\n#### Core Logic Skeleton Code: Exception Handling\n\nFor implementing exceptions with the control flow signal pattern:\n\n```python\n# eval/control_flow.py additions\nclass ThrowSignal(ControlFlowSignal):\n    \"\"\"Signal raised when 'throw' statement is executed.\"\"\"\n    def __init__(self, value: Value):\n        self.value = value\n\n# eval/evaluator.py additions\nclass Evaluator:\n    # ... existing code ...\n    \n    def _evaluate_throw_stmt(self, node: ThrowStmt, env: Environment) -> None:\n        \"\"\"\n        Evaluate 'throw expression' statement.\n        \n        Steps:\n        1. Evaluate the exception expression\n        2. Raise ThrowSignal with the exception value\n        \"\"\"\n        # TODO 1: Evaluate the exception expression\n        #   exception_value = self.evaluate(node.expression, env)\n        \n        # TODO 2: Raise ThrowSignal\n        #   raise ThrowSignal(exception_value)\n        pass\n    \n    def _evaluate_try_stmt(self, node: TryStmt, env: Environment) -> Value:\n        \"\"\"\n        Evaluate try-catch statement.\n        \n        Steps:\n        1. Wrap try block evaluation in try-except catching ThrowSignal\n        2. If ThrowSignal caught, evaluate catch block with exception bound\n        3. If no exception, just return try block result (or nil)\n        4. Always execute finally block if present\n        \"\"\"\n        # TODO 1: Try to evaluate the try block\n        #   try:\n        #     result = self.evaluate(node.try_block, env)\n        #   except ThrowSignal as e:\n        #     # Exception was thrown\n        \n        # TODO 2: If exception caught and catch block present\n        #   if node.catch_block is not None:\n        #     # Create new environment for catch variable\n        #     catch_env = Environment(store={}, parent=env)\n        #     catch_env.define(node.catch_var, e.value)\n        #     result = self.evaluate(node.catch_block, catch_env)\n        \n        # TODO 3: If no catch or re-throw, propagate\n        \n        # TODO 4: Execute finally block if present (always)\n        #   if node.finally_block is not None:\n        #     self.evaluate(node.finally_block, env)\n        \n        return result  # Or nil\n```\n\n#### Language-Specific Hints: Python\n\n1. **For Array/Hash Values**: Use Python's `list` and `dict` as backing stores but wrap them in custom classes to control string representation and equality semantics.\n\n2. **For Class Method Lookup**: Implement method resolution order (MRO) similar to Python's C3 linearization for multiple inheritance, or simple depth-first search for single inheritance.\n\n3. **For Bytecode VM**: Use Python's `array('B')` or `bytes` for compact bytecode storage. For the dispatch loop, a `while True:` loop with a large `match` statement (Python 3.10+) or dictionary dispatch.\n\n4. **For REPL History**: Use the `readline` module on Unix or `pyreadline` on Windows for line editing and history. Handle `KeyboardInterrupt` (Ctrl+C) gracefully.\n\n5. **For Debugger Inspection**: Use the `inspect` module to examine Python call stack, but maintain your own interpreter call stack for meaningful source-level debugging.\n\n#### Milestone Checkpoint: Testing Extensions\n\nAfter implementing any extension, verify with these test programs:\n\n**Arrays Test:**\n```javascript\nvar arr = [1, 2, 3];\nprint(arr[0]);  // Should print: 1\narr[0] = 10;\nprint(arr[0]);  // Should print: 10\nprint(length(arr));  // Should print: 3\n```\n\n**Classes Test:**\n```javascript\nclass Counter {\n  init() {\n    this.value = 0;\n  }\n  increment() {\n    this.value = this.value + 1;\n  }\n}\n\nvar c = new Counter();\nc.increment();\nprint(c.value);  // Should print: 1\n```\n\n**Exceptions Test:**\n```javascript\ntry {\n  throw \"Something went wrong\";\n} catch (e) {\n  print(\"Caught:\", e);  // Should print: Caught: Something went wrong\n}\n```\n\n**REPL Test:**\n```\n$ python interpreter.py --repl\n> var x = 5\nnil\n> x * 2\n10\n> .exit\n```\n\n#### Debugging Tips for Extensions\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Array modifications affect unrelated variables** | Reference semantics issue: multiple variables reference same list object | Print object IDs or check `id(array)` in Python | Ensure array literals create new lists: `ArrayValue(elements=list(node.elements))` |\n| **Class method can't access `self` properties** | Method closure environment not set correctly | Check `FunctionValue.closure` field for methods | Methods should close over class environment, which has `self` defined during calls |\n| **Exceptions not caught by correct `catch` block** | `ThrowSignal` caught at wrong level | Add print statements showing signal propagation | Ensure `TryStmt` evaluation catches `ThrowSignal` before parent evaluators |\n| **REL doesn't preserve variable state between inputs** | New Environment created for each input | Check if REPL reuses the same global environment | Pass persistent environment to each evaluation in the REPL loop |\n| **Bytecode VM runs slower than tree-walker** | Instruction dispatch overhead | Profile to see time spent in switch/match statement | Consider computed goto (C extension) or direct threading for performance |\n\nThese extensions transform a simple educational interpreter into a more capable language implementation, providing excellent learning opportunities in language design, runtime systems, and software architecture. Each builds upon the solid foundation established in the core milestones while introducing new concepts and challenges.\n\n\n## Glossary\n\n> **Milestone(s):** 1, 2, 3, 4\n\nThis section defines key technical terms, acronyms, and domain-specific vocabulary used throughout this design document. Understanding this lexicon is essential for precise communication about the interpreter's architecture and behavior.\n\n---\n\n**Abstract Syntax Tree (AST):** A hierarchical, tree-like data structure that represents the syntactic structure of source code. Each node in the tree corresponds to a construct in the language (e.g., an expression, a statement). The AST discards irrelevant details like whitespace and parentheses (though grouping nodes preserve evaluation order). The interpreter executes programs by recursively \"walking\" this tree. Compare to a *parse tree*, which is more granular and includes every syntactic detail from the grammar.\n\n**Arity:** The number of parameters a function or operation expects. For example, a binary operator has an arity of two. The interpreter checks that the number of arguments passed in a function call matches the function's declared arity, raising an `ArgumentError` if they differ.\n\n**Binding:** The association between a variable name (an identifier) and its current runtime value. Binding occurs during variable declaration (e.g., `var x = 5;`) and reassignment (e.g., `x = 10;`). The `Environment` stores these name-to-value mappings.\n\n**Block:** A sequence of statements enclosed by braces `{}`. A block introduces a new lexical scope. When evaluated, statements within a block are executed sequentially. The result of a block is the value of the last statement executed (often `nil` if the block ends without a return statement).\n\n**Bytecode:** A compact, intermediate representation of a program designed for efficient execution by a virtual machine (VM). Bytecode is lower-level than an AST but higher-level than machine code. This design document focuses on a tree-walking interpreter, not a bytecode VM, but the Future Extensions section discusses evolving the design toward bytecode.\n\n**Closure:** A **first-class function** that \"closes over\" or captures variables from its **lexical scope** at the time of its definition. A closure consists of the function's code (its parameters and body) and a reference to its **defining environment**. This allows the function to access those captured variables even when called outside their original scope. In our interpreter, a `FunctionValue` stores its `closure` environment, enabling true lexical closures.\n\n**Control Flow:** The order in which individual statements, instructions, or function calls are executed or evaluated. Basic control flow is sequential. **Control flow statements** like `if`, `while`, `for`, `break`, `continue`, and `return` alter this sequence based on conditions or explicit jumps.\n\n**Control Flow Signal:** A special exception-like mechanism used internally by the interpreter to implement non-local jumps such as `break`, `continue`, and `return`. Instead of unwinding the call stack through normal function returns, these signals are caught by designated handlers (e.g., a loop catcher for `break`/`continue`, the function call mechanism for `return`).\n\n**Desugaring:** The process of translating syntactic sugar—convenient, higher-level syntax—into more primitive constructs already present in the core language. For example, a `for` loop can be *desugared* into an equivalent `while` loop plus some initialization and increment statements. This simplifies the interpreter's core evaluation logic by reducing the number of distinct node types it must handle directly.\n\n**Dispatch:** The mechanism by which the `Evaluator` selects the appropriate evaluation logic for a given AST node type. Our design uses a single `evaluate` function that inspects the node's type and routes it to a corresponding internal method (e.g., `_evaluate_binary_expr`). This is a form of *single dispatch* based on the node type.\n\n**Environment:** A runtime data structure that maps variable names to their current values. It represents a **scope**. Environments are linked in a chain via `parent` references, forming an **environment chain**. The `Environment` class provides three core operations: `define` (create a new binding), `get` (retrieve a value by name, walking the chain), and `assign` (update an existing binding, walking the chain to find it).\n\n**Environment Chain:** A linked list of `Environment` objects, where each link represents a nested lexical scope. When looking up a variable, the interpreter starts in the innermost (current) environment and proceeds outward through parent links until the variable is found or the global scope (with no parent) is reached. This chain implements **lexical scoping**. ![Diagram: Environment Chain Lookup](./diagrams/env-chain-lookup.svg)\n\n**Evaluator:** The core component of the interpreter responsible for traversing the AST and computing results. It is a stateless class whose main entry point is the recursive `evaluate(node, environment)` method. The evaluator contains the semantic rules of the language—it knows how to add numbers, execute an `if` statement, call a function, etc.\n\n**First-Class Function:** A function that can be treated like any other value in the language: it can be assigned to variables, stored in data structures, passed as an argument to other functions, and returned as a result from a function. Our interpreter implements first-class functions via `FunctionValue` objects.\n\n**Frame:** Another term for an **environment** or scope, often used in the context of a call stack. Each function call typically creates a new frame/environment to hold its local variables.\n\n**Global Environment:** The outermost environment in the **environment chain**. It has no parent. It typically holds built-in functions (like `print`) and globally declared variables. The global environment persists for the entire execution of the program.\n\n**Immutable AST:** A design principle where AST nodes, once created by the parser, are never modified. The interpreter treats the AST as a read-only data structure, generating new runtime values but never altering the tree itself. This simplifies reasoning about program execution and enables potential future optimizations like caching.\n\n**Interpreter:** In this context, the complete system that executes source code. Our **tree-walking interpreter** consists of a parser (which builds the AST from text) and the evaluation components (Evaluator, Environment Manager, etc.). The `Interpreter` class often serves as the public facade, with an `interpret(source_code)` method.\n\n**Lexical Scoping (Static Scoping):** A scoping rule where the visibility of a variable is determined by its location in the source code—specifically, by the static, nested block structure. A variable defined in an outer scope is accessible in all inner scopes, unless it is **shadowed**. This contrasts with *dynamic scoping*, where visibility depends on the runtime call stack. Our interpreter implements lexical scoping via the **environment chain** captured in **closures**.\n\n**Literal:** A syntactic representation of a fixed value in source code, such as a number (`42`), string (`\"hello\"`), boolean (`true`, `false`), or `nil`. In the AST, a literal node evaluates directly to the corresponding runtime value.\n\n**Lookup:** The process of retrieving the value associated with a variable name by searching the **environment chain**. This is performed by the `Environment.get(name)` method.\n\n**Mental Model:** An intuitive analogy or simplified conceptual framework used to understand a complex system without grappling with all its underlying details. This document uses mental models like \"The Math Homework Grader\" for the evaluator and \"Stack of Ledgers\" for environments to build reader intuition before presenting technical specifications.\n\n**Name Binding:** See **Binding**.\n\n**Native Function:** A function implemented in the interpreter's host language (e.g., Python) rather than in the interpreted language itself. Native functions, such as `Builtins.clock`, provide essential capabilities that would be inefficient or impossible to implement in the interpreted language. They are exposed as `NativeFunctionValue` objects.\n\n**Nil:** A special value representing the absence of a meaningful value. It is analogous to `null` in many languages. In our interpreter, `nil` is falsy in boolean contexts and is the implicit return value of statements and functions that don't execute an explicit `return`.\n\n**Non-Local Exit:** A control flow operation that transfers execution out of the current context, potentially skipping multiple levels of nested scopes or statements. `break`, `continue`, and `return` are examples. Our interpreter implements these using **control flow signals** that are caught by specific handlers higher up the call stack.\n\n**Operator Precedence:** Rules that determine the order in which different operators in an expression are evaluated when parentheses are not present. For example, multiplication has higher precedence than addition. Precedence is handled during parsing, not evaluation; the resulting AST's structure implicitly encodes the correct order.\n\n**Parse Tree (Concrete Syntax Tree):** A detailed tree representation of source code that includes every token and syntactic rule used during parsing, including punctuation and grammar artifacts. The **AST** is a simplified abstraction derived from the parse tree, focusing on semantic structure.\n\n**REPL (Read-Eval-Print Loop):** An interactive programming environment that reads a user's input, evaluates it, prints the result, and then loops to wait for the next input. While not a core milestone, a REPL is a common extension for interpreters, useful for testing and exploration.\n\n**Runtime Error:** An error that occurs during program execution (as opposed to a syntax error, which is caught during parsing). Our interpreter defines specific error types like `TypeError`, `UndefinedVariableError`, and `DivisionByZeroError`. The interpreter follows a **fail-fast** strategy, halting execution and reporting the error when one occurs.\n\n**Runtime Value:** A piece of data that exists and can be manipulated during program execution. Our interpreter's runtime values include numbers, strings, booleans, `nil`, and `FunctionValue` objects (including `NativeFunctionValue`). These are distinct from AST nodes, which represent the static structure of the code.\n\n**Scope:** A region of the source code where a variable binding is visible. Scopes are typically introduced by functions, blocks, or the global context. Our interpreter uses **lexical scoping**, meaning the scope is determined by the physical nesting of code structures.\n\n**Shadowing:** The phenomenon where a variable declared in an inner scope has the same name as a variable in an outer scope. The inner variable \"shadows\" the outer one, making the outer variable inaccessible by its name within the inner scope. The **environment chain** lookup resolves to the innermost binding, thereby implementing shadowing.\n\n**Short-Circuit Evaluation:** An optimization for logical operators `and` and `or` where the right operand is evaluated only if necessary to determine the result. For `and`, if the left operand is falsy, the result is falsy without evaluating the right. For `or`, if the left operand is truthy, the result is truthy without evaluating the right. This is both a performance optimization and a feature that allows expressions like `if (x != nil and x.value > 0)` to avoid null pointer errors.\n\n**Statement:** A unit of code that performs an action but does not produce a value (or produces a value of secondary importance). Examples include variable declarations, assignments, `if` statements, loops, and `return`. In our interpreter, statements are evaluated for their side effects; their evaluation typically returns `nil` unless they contain an expression that yields a value (like a function call inside a `print` statement).\n\n**Static vs. Dynamic:**  \n- **Static:** Properties determined by analyzing the source code without executing it (e.g., syntax, lexical scope).  \n- **Dynamic:** Properties determined only at runtime (e.g., the value of a variable, the type of an expression's result). Our interpreter performs static parsing but dynamic evaluation.\n\n**Tail-Call Optimization (TCO):** A compiler/interpreter optimization that reuses the current function's stack frame for a function call in *tail position* (the last action before returning). This allows infinite recursion without stack overflow for tail-recursive algorithms. Our interpreter does not implement TCO (it's a non-goal), but the architecture could be extended to support it.\n\n**Token:** The smallest meaningful unit in the source code, produced by the lexer/scanner. Examples include identifiers, keywords, operators, literals, and punctuation. Tokens are used by the parser to build the AST. While not directly used during evaluation, tokens are attached to AST nodes and referenced in error messages for location information.\n\n**Tree-Walking:** The evaluation strategy where the interpreter directly traverses the **AST**, executing operations at each node recursively. This is contrasted with compilation to **bytecode** or machine code. Tree-walking is simple to implement and understand but is typically slower than bytecode execution.\n\n**Truthiness:** The boolean interpretation of a non-boolean value when used in a conditional context (e.g., `if (value)`). Our interpreter's truthiness rules are: `false` and `nil` are falsy; everything else (including `0`, empty string `\"\"`) is truthy. The `Evaluator._is_truthy(value)` method encapsulates this logic.\n\n**Type Checking:** The process of verifying that the operands of an operation are of appropriate types before performing the operation. Our interpreter performs *dynamic type checking* at runtime. For example, the `+` operator checks that both operands are numbers or both are strings; if not, it raises a `TypeError`.\n\n**Undefined Variable:** A variable that is referenced (in an expression or assignment) but has not been declared in any accessible scope. Attempting to evaluate such a variable raises an `UndefinedVariableError`.\n\n**Variable:** A named reference to a **runtime value**. Variables are declared (which creates a **binding**) and can later be assigned new values. Variable lookup follows the **environment chain**.\n\n**Virtual Machine (VM):** A software simulation of a computer that executes instructions. In language implementation, a **bytecode VM** executes a compact instruction set. Our tree-walking interpreter is not a VM in this sense, but the design could evolve into one by adding a compilation phase from AST to bytecode and an execution engine for that bytecode.\n\n---\n"}