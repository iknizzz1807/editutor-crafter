{"html":"<h1 id=\"b-tree-implementation-design-document\">B-tree Implementation: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This document outlines the design for implementing a B-tree, a self-balancing tree data structure optimized for systems that read and write large blocks of data like databases and file systems. The key architectural challenge is maintaining the B-tree invariants (node key/child counts, sorted order) during insertions and deletions while ensuring disk-friendly operations through node splitting, merging, and borrowing.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"1-context-and-problem-statement\">1. Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This foundational section corresponds primarily to Milestone 1 (understanding B-tree node structure) and provides essential context for all subsequent milestones by explaining why B-trees exist and what problems they solve.</p>\n</blockquote>\n<p>Imagine you&#39;re managing a library with 10 million books. When someone asks for a specific book, you could walk through every shelf checking each spine—a linear search that would take months. Instead, you use a catalog system: first you check the main catalog (organized by topic), then a section guide, then a specific shelf index, and finally locate the book. This multi-level indexing is exactly what B-trees provide for computer systems, but with a crucial optimization: each level of the index is designed to fit perfectly into the physical storage units (pages) of disk drives, minimizing expensive disk seeks.</p>\n<h3 id=\"the-disk-access-problem-and-b-tree-solution\">The Disk Access Problem and B-tree Solution</h3>\n<p>Traditional in-memory balanced trees like AVL trees or Red-Black trees work beautifully when your entire dataset fits in RAM. Each node typically contains one key and two child pointers, creating tall, narrow trees. For memory operations where pointer dereferencing costs roughly the same regardless of location, this is optimal. However, when data exceeds available memory and must live on disk (as in databases or file systems), a fundamental hardware reality changes everything: <strong>disk access is not uniform</strong>.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> The primary cost in disk-based systems isn&#39;t CPU cycles for comparisons—it&#39;s the mechanical movement of disk heads to different positions (seeks) and the time waiting for the right sector to rotate under the head (rotational latency). Reading 1 byte from disk takes essentially the same time as reading an entire disk block (typically 4KB).</p>\n</blockquote>\n<p>Consider this physical reality: if you store one key per disk block (node) as in a binary search tree, searching for a key among 1 million records might require ~20 disk reads (log₂(1,000,000) ≈ 20). Each read involves:</p>\n<ol>\n<li><strong>Seek time</strong>: Moving the read head to the correct track (3-10ms for mechanical drives)</li>\n<li><strong>Rotational latency</strong>: Waiting for the disk to rotate to the right sector (2-8ms)</li>\n<li><strong>Transfer time</strong>: Actually reading the data (negligible for small amounts)</li>\n</ol>\n<p>Even with 20 reads at 10ms each, that&#39;s 200ms—unacceptably slow for database operations that might need thousands of lookups per second.</p>\n<p><strong>The B-tree breakthrough</strong>: Instead of storing one key per node, B-trees store <strong>many keys per node</strong>—exactly enough to fill a disk block. With a <strong>minimum degree</strong> <code>t</code> (a parameter you choose based on disk block size and key size), each node holds between <code>t-1</code> and <code>2t-1</code> keys. This &quot;fat node&quot; design has profound implications:</p>\n<ul>\n<li><strong>Height reduction</strong>: A B-tree of degree <code>t</code> storing <code>n</code> keys has height at most <code>logₜ(n)</code>. With <code>t=100</code>, a tree of 1 million keys has height at most 3 (since 100³ = 1,000,000). That&#39;s 3 disk reads instead of 20!</li>\n<li><strong>Amortized disk I/O</strong>: Each node read brings in <code>t</code> keys worth of comparison material. Even though binary searching within a node takes O(log t) comparisons, these happen in memory after the single disk read.</li>\n<li><strong>Sequential access advantage</strong>: Keys within a node are stored in sorted arrays, allowing efficient binary search and taking advantage of CPU cache locality once the node is loaded.</li>\n</ul>\n<blockquote>\n<p><strong>Design Principle:</strong> B-trees are designed around the unit of storage transfer (disk blocks/pages) rather than the unit of data comparison (individual keys). This is why they dominate disk-based indexing while binary trees dominate in-memory indexing.</p>\n</blockquote>\n<p><strong>The B-tree solution in technical terms</strong>: By carefully maintaining balance invariants (every node except root must be at least half-full, all leaves at same depth) and implementing split/merge operations during insert/delete, B-trees guarantee:</p>\n<ol>\n<li><strong>Deterministic performance</strong>: Always O(logₜ n) disk accesses</li>\n<li><strong>High storage utilization</strong>: Typically 50-100% of each disk block used</li>\n<li><strong>Stable performance</strong>: No periodic rebalancing needed (unlike some hash tables)</li>\n</ol>\n<h3 id=\"mental-model-the-library-catalog-analogy\">Mental Model: The Library Catalog Analogy</h3>\n<p>Let&#39;s build intuition through a concrete analogy. Imagine our library with the Dewey Decimal system:</p>\n<ol>\n<li><p><strong>The Root Node (Main Catalog Desk)</strong>: Contains ranges of Dewey Decimal numbers and pointers to section catalogs. Example: &quot;000-199 → Science Section Catalog,&quot; &quot;200-399 → Literature Section Catalog,&quot; etc. This fits on one index card at the main desk.</p>\n</li>\n<li><p><strong>Internal Nodes (Section Catalogs)</strong>: Each section (Science, Literature) has its own catalog with finer divisions. The Science catalog might have: &quot;000-049 → Physics shelves,&quot; &quot;050-099 → Chemistry shelves,&quot; etc. Each catalog fits on one physical card.</p>\n</li>\n<li><p><strong>Leaf Nodes (Shelf Labels)</strong>: At the shelves themselves, you find labels like &quot;Physics 000-015: Thermodynamics books&quot; listing actual books (data) on that shelf.</p>\n</li>\n<li><p><strong>The Search Process</strong>: To find book &quot;005.133&quot; (a computer science book):</p>\n<ul>\n<li>Start at main desk (root): Binary search shows &quot;000-199 → Science&quot;</li>\n<li>Go to Science catalog (internal node): Binary search shows &quot;000-049 → Physics&quot;</li>\n<li>Go to Physics shelf (leaf node): Binary search finds book &quot;005.133&quot; is actually here (or isn&#39;t if someone miscategorized it!)</li>\n</ul>\n</li>\n<li><p><strong>Insertion with Splitting</strong>: When the Physics shelf becomes too full (exceeds capacity), we:</p>\n<ul>\n<li>Take the middle book off the shelf</li>\n<li>Create a new shelf</li>\n<li>Put half the books on each shelf</li>\n<li>Update the Science catalog to now have two entries: &quot;000-024 → Old Physics Shelf&quot; and &quot;025-049 → New Physics Shelf&quot;</li>\n</ul>\n</li>\n<li><p><strong>Deletion with Merging</strong>: If the Chemistry shelf becomes too empty (below minimum), we either:</p>\n<ul>\n<li><strong>Borrow</strong>: Take a book from the adjacent Physics shelf (through the Science catalog)</li>\n<li><strong>Merge</strong>: If Physics shelf is also near minimum, combine both shelves into one and remove an entry from the Science catalog</li>\n</ul>\n</li>\n</ol>\n<p>This analogy maps directly to B-tree concepts:</p>\n<ul>\n<li><strong>Minimum degree <code>t</code></strong>: Minimum books per shelf (except possibly the first/last shelf in a section)</li>\n<li><strong>Node splitting</strong>: Shelf getting too full</li>\n<li><strong>Median promotion</strong>: Moving the middle book up to the section catalog</li>\n<li><strong>Borrowing/merging</strong>: Shelf reorganization</li>\n<li><strong>Balanced depth</strong>: All shelves are reachable through the same number of catalog lookups</li>\n</ul>\n<blockquote>\n<p><strong>Mental Model Summary:</strong> Think of a B-tree as a multi-level catalog system where each catalog card (node) is sized to fit exactly one physical storage unit (disk page), and the system automatically reorganizes cards and shelves to maintain quick access while efficiently using space.</p>\n</blockquote>\n<h3 id=\"comparison-with-other-tree-structures\">Comparison with Other Tree Structures</h3>\n<p>To understand when to choose B-trees over other tree structures, consider this comprehensive comparison:</p>\n<table>\n<thead>\n<tr>\n<th><strong>Tree Type</strong></th>\n<th><strong>Typical Keys per Node</strong></th>\n<th><strong>Height for N keys</strong></th>\n<th><strong>Primary Optimization Target</strong></th>\n<th><strong>Disk-Friendly?</strong></th>\n<th><strong>Common Use Cases</strong></th>\n<th><strong>Balance Mechanism</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Binary Search Tree (BST)</strong></td>\n<td>1</td>\n<td>O(N) worst, O(log N) average</td>\n<td>In-memory comparison speed</td>\n<td>❌ No</td>\n<td>In-memory algorithms, simple dictionaries</td>\n<td>None (unbalanced)</td>\n</tr>\n<tr>\n<td><strong>AVL Tree</strong></td>\n<td>1</td>\n<td>O(log N)</td>\n<td>Guaranteed height balance for worst-case performance</td>\n<td>❌ No</td>\n<td>In-memory databases, real-time systems where worst-case matters</td>\n<td>Rotations after insert/delete</td>\n</tr>\n<tr>\n<td><strong>Red-Black Tree</strong></td>\n<td>1</td>\n<td>O(log N)</td>\n<td>Simpler rebalancing with good amortized performance</td>\n<td>❌ No</td>\n<td>Standard library implementations (C++ STL map, Java TreeMap)</td>\n<td>Color flips and rotations</td>\n</tr>\n<tr>\n<td><strong>B-tree</strong></td>\n<td>t-1 to 2t-1 (t typically 50-1000)</td>\n<td>O(logₜ N)</td>\n<td>Minimizing disk I/O, block utilization</td>\n<td>✅ <strong>Excellent</strong></td>\n<td>Databases (MySQL, PostgreSQL), file systems (NTFS, HFS+, ext4), disk-based indices</td>\n<td>Split/merge during operations</td>\n</tr>\n<tr>\n<td><strong>B+ tree</strong></td>\n<td>t-1 to 2t-1</td>\n<td>O(logₜ N)</td>\n<td>Range queries, sequential access</td>\n<td>✅ <strong>Excellent</strong></td>\n<td>Database indices (especially with range scans), file systems</td>\n<td>Split/merge, all data at leaves</td>\n</tr>\n</tbody></table>\n<p><strong>Detailed Analysis:</strong></p>\n<p><strong>Binary Search Trees (BSTs)</strong>:</p>\n<ul>\n<li><strong>When to use</strong>: Small datasets that fit entirely in memory, simple implementations, or when you need an easy-to-understand tree structure.</li>\n<li><strong>Limitations for disk</strong>: Each node might reside in a different disk block, causing one disk read per level traversed. Worst-case height O(N) if keys are inserted in sorted order.</li>\n<li><strong>Storage overhead</strong>: For each key, you store two child pointers (typically 8 bytes each on 64-bit systems).</li>\n</ul>\n<p><strong>AVL Trees</strong>:</p>\n<ul>\n<li><strong>When to use</strong>: When guaranteed O(log N) worst-case time is critical, and the tree fits in memory. Used in real-time systems and in-memory databases.</li>\n<li><strong>Disk limitations</strong>: Same as BSTs—each node potentially causes a disk read. Frequent rotations during insertion/deletion would cause excessive disk writes if stored on disk.</li>\n<li><strong>Balance factor</strong>: Maintains height difference ≤ 1 between subtrees through rotations.</li>\n</ul>\n<p><strong>Red-Black Trees</strong>:</p>\n<ul>\n<li><strong>When to use</strong>: General-purpose in-memory sorted containers where you want good amortized performance with simpler implementation than AVL trees. Most standard libraries use them.</li>\n<li><strong>Disk limitations</strong>: Like AVL trees, not designed for disk storage. The approximately balanced nature (height ≤ 2log₂(N+1)) helps but doesn&#39;t solve the fundamental disk I/O problem.</li>\n<li><strong>Practical note</strong>: While not disk-optimized, some systems use them for in-memory indices that occasionally flush to disk.</li>\n</ul>\n<p><strong>B-trees</strong>:</p>\n<ul>\n<li><strong>When to use</strong>: Any dataset too large for memory, or when persistence to disk is required. The de facto standard for database indices and file systems.</li>\n<li><strong>Key advantages</strong>:<ol>\n<li><strong>Height reduction</strong>: With t=100, a B-tree of 1 billion keys has height at most 5 (100⁵ = 10¹⁰), meaning 5 disk reads max.</li>\n<li><strong>Sequential reads within nodes</strong>: Once a node is loaded, all its keys are in memory for efficient binary search.</li>\n<li><strong>High fanout</strong>: Many children per internal node reduces height.</li>\n<li><strong>Predictable performance</strong>: No periodic rebalancing needed.</li>\n</ol>\n</li>\n<li><strong>Trade-offs</strong>: More complex implementation than binary trees, overhead of maintaining minimum occupancy.</li>\n</ul>\n<p><strong>B+ trees</strong> (a common variant):</p>\n<ul>\n<li><strong>When to use</strong>: Database systems where range queries are common. All actual data resides in leaf nodes, with internal nodes containing only keys for routing.</li>\n<li><strong>Advantages over B-trees</strong>:<ol>\n<li><strong>Better sequential access</strong>: All leaf nodes are linked together, enabling efficient full-table scans.</li>\n<li><strong>More keys per internal node</strong>: Since internal nodes don&#39;t store data, they can have higher fanout.</li>\n<li><strong>Consistent access time</strong>: All data accesses require traversing to leaf level.</li>\n</ol>\n</li>\n<li><strong>Our implementation focus</strong>: While this document describes classic B-trees, the principles apply to B+ trees as well.</li>\n</ul>\n<blockquote>\n<p><strong>Architecture Decision Record: Why Implement Classic B-Trees Instead of B+ Trees?</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>Decision: Implement Classic B-Trees for Educational Clarity</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to choose which variant of B-tree to implement for this educational project. The core concepts of node splitting, merging, and disk-friendly design are shared across variants, but implementation details differ.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Classic B-trees</strong>: Keys and associated data can be in any node. Simpler to implement for a basic key-value store.</li>\n<li><strong>B+ trees</strong>: All data resides in leaf nodes; internal nodes contain only keys. Better for range queries and database indices.</li>\n<li><em><em>B</em> trees</em>*: Nodes kept 2/3 full minimum (vs 1/2 for B-trees), reducing splits but adding complexity.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement classic B-trees.</li>\n<li><strong>Rationale</strong>:<ol>\n<li><strong>Educational value</strong>: Classic B-trees demonstrate all fundamental operations (search, insert, delete with rebalancing) in their most direct form.</li>\n<li><strong>Implementation simplicity</strong>: No need to maintain linked lists of leaves or separate data storage.</li>\n<li><strong>Conceptual clarity</strong>: Each node clearly demonstrates the &quot;keys as separators&quot; mental model without the additional abstraction of data-only leaves.</li>\n<li><strong>Foundation for variants</strong>: Understanding classic B-trees makes it straightforward to later implement B+ or B* trees.</li>\n</ol>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Clear mapping from algorithm descriptions to implementation; easier to debug and visualize.</li>\n<li><strong>Negative</strong>: Less optimal for range scans compared to B+ trees; in practice, database systems usually implement B+ trees.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th><strong>Option</strong></th>\n<th><strong>Pros</strong></th>\n<th><strong>Cons</strong></th>\n<th><strong>Why Not Chosen</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Classic B-tree</strong></td>\n<td>Direct implementation of textbook algorithm; clear mental model; all operations self-contained in each node</td>\n<td>Less efficient for range queries; mixed data and routing keys in same nodes</td>\n<td><strong>Chosen</strong> - Best for learning fundamentals</td>\n</tr>\n<tr>\n<td><strong>B+ tree</strong></td>\n<td>Industry standard for databases; efficient range scans; higher fanout in internal nodes</td>\n<td>More complex: need leaf node linked lists; data duplication between leaves and internal nodes</td>\n<td>Better for production systems but adds learning overhead</td>\n</tr>\n<tr>\n<td><em><em>B</em> tree</em>*</td>\n<td>Better space utilization (66% vs 50% minimum); fewer splits</td>\n<td>More complex rebalancing (three-way splits); not commonly taught</td>\n<td>Adds complexity without proportional educational benefit</td>\n</tr>\n</tbody></table>\n<p><strong>Real-World Usage Context</strong>:</p>\n<p>In practice, the choice between tree structures depends entirely on the storage medium and access patterns:</p>\n<ol>\n<li><p><strong>In-memory data structures</strong>: Redis uses skip lists and hash tables for its primary structures; most programming language standard libraries use Red-Black trees for their ordered map/set implementations.</p>\n</li>\n<li><p><strong>Database indices</strong>: PostgreSQL, MySQL (InnoDB), Oracle, and SQL Server all use B+ trees for their table indices. The B+ tree variant provides optimal performance for both point lookups and range queries common in SQL.</p>\n</li>\n<li><p><strong>File systems</strong>: NTFS (Windows), HFS+ (macOS), ext4 (Linux), and many others use B-trees or B+ trees for directory indexing and file metadata storage.</p>\n</li>\n<li><p><strong>Specialized systems</strong>: Some modern databases use LSM-trees (Log-Structured Merge-trees) for write-intensive workloads, but they still often use B-trees for their in-memory components or for certain types of indices.</p>\n</li>\n</ol>\n<p>For this implementation project, we focus on classic B-trees because they capture the essential algorithmic insights while being approachable for implementation. The skills you learn—managing node capacities, implementing split/merge operations, maintaining invariants during modifications—directly transfer to understanding real-world database and file system implementations.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Note:</strong> Since this is the context section (not a component design section), we provide only minimal implementation guidance focused on setting up the project structure. Detailed code will appear in subsequent sections.</p>\n</blockquote>\n<p><strong>Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning Focus)</th>\n<th>Advanced Option (Production-Ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Language</strong></td>\n<td>C (standard library only)</td>\n<td>C with platform-specific optimizations</td>\n</tr>\n<tr>\n<td><strong>Memory Management</strong></td>\n<td>Manual <code>malloc</code>/<code>free</code></td>\n<td>Arena allocator or slab allocator</td>\n</tr>\n<tr>\n<td><strong>Disk Persistence</strong></td>\n<td>In-memory only (no persistence)</td>\n<td>Memory-mapped files with page caching</td>\n</tr>\n<tr>\n<td><strong>Key Type</strong></td>\n<td>Fixed-size integers (<code>int</code> or <code>long</code>)</td>\n<td>Generic pointers with comparison function</td>\n</tr>\n<tr>\n<td><strong>Testing Framework</strong></td>\n<td>Simple test harness with assertions</td>\n<td>Comprehensive unit test suite (Check, Unity)</td>\n</tr>\n<tr>\n<td><strong>Debugging Aids</strong></td>\n<td>Print statements and manual inspection</td>\n<td>Graphviz output for tree visualization</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<p>For a clean C implementation that separates concerns and makes testing easier:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree-project/\n├── include/                    # Public header files\n│   └── btree.h                # Main B-tree API (public functions)\n├── src/                       # Implementation source files\n│   ├── btree.c               # B-tree operations (search, insert, delete)\n│   ├── node.c                # Node manipulation functions\n│   ├── disk.c                # Disk I/O simulation (if implementing persistence)\n│   └── utils.c               # Utility functions (binary search, validation)\n├── tests/                     # Test suite\n│   ├── test_btree.c          # Comprehensive B-tree tests\n│   ├── test_node.c           # Node-specific tests\n│   └── test_runner.c         # Test runner main program\n├── examples/                  # Example usage\n│   └── basic_usage.c         # Simple demonstration program\n├── docs/                      # Documentation\n│   └── design.md             # This design document\n└── Makefile                   # Build automation</code></pre></div>\n\n<p><strong>Infrastructure Starter Code:</strong></p>\n<p>While the core B-tree algorithms are the learning focus, you&#39;ll need some basic infrastructure. Here&#39;s a complete, ready-to-use header file to start:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* include/btree.h - Main B-tree API */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Configuration constants */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_MIN_DEGREE</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#6A737D\">  /* t=3 means nodes hold 2-5 keys */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Forward declaration of internal node structure */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BTreeNode BTreeNode;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Main B-tree structure */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> root;</span><span style=\"color:#6A737D\">           /* Pointer to root node */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> t;</span><span style=\"color:#6A737D\">                     /* Minimum degree (defines capacity bounds) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> key_count;</span><span style=\"color:#6A737D\">          /* Total keys in tree (optional, for statistics) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BTree;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Search result structure */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found;</span><span style=\"color:#6A737D\">                /* Whether the key was found */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> value;</span><span style=\"color:#6A737D\">               /* Associated value (if any) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> comparisons;</span><span style=\"color:#6A737D\">           /* Number of key comparisons made (for analysis) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SearchResult;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* B-tree API functions */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Initialize a new empty B-tree with given minimum degree */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Free all memory used by the B-tree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_destroy</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Search for a key in the tree */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Insert a key (and optional value) into the tree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Delete a key from the tree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Get the number of keys in the tree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> btree_size</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Get the height of the tree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_height</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Validate tree invariants (for debugging) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Print tree structure (for debugging) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> /* BTREE_H */</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<p>For the node structure (Milestone 1), here&#39;s the skeleton you&#39;ll implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* src/node.c - Node implementation */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Internal node structure */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> BTreeNode {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int*</span><span style=\"color:#E1E4E8\"> keys;</span><span style=\"color:#6A737D\">                 /* Array of keys (size: 2*t-1 when full) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> values;</span><span style=\"color:#6A737D\">             /* Array of associated values (optional) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> children;</span><span style=\"color:#6A737D\">      /* Array of child pointers (size: 2*t) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_keys;</span><span style=\"color:#6A737D\">              /* Current number of keys in node */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> is_leaf;</span><span style=\"color:#6A737D\">              /* True if leaf node (no children) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Note: For leaf nodes, children array may be NULL or all NULL */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Create a new empty node */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Allocate memory for the BTreeNode structure */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: Allocate arrays for keys (size 2*t-1) and values (if using) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: If not leaf, allocate children array (size 2*t) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: Initialize num_keys to 0 and is_leaf flag */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 5: For safety, initialize all child pointers to NULL */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 6: Return the new node */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Free a node and all its descendants recursively */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> node_destroy</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: If node is NULL, return immediately */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: If not leaf, recursively destroy all children */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: Free the keys, values, and children arrays */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: Free the node structure itself */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Find the index where key should be in this node (binary search) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Initialize left = 0, right = node->num_keys - 1 */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: While left &#x3C;= right, do binary search */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: Compare key with node->keys[mid], increment comparisons */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: If key found, return index (might be negative for child pointer logic) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 5: If not found, return index where key should be inserted */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Check if node is full (has 2*t-1 keys) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> node_is_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO: Return true if node->num_keys == 2*t - 1 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Check if node is underfull (has fewer than t-1 keys) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> node_is_underfull</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO: Return true if node->num_keys &#x3C; t - 1 */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Special case: root can have fewer keys */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints for C:</strong></p>\n<ol>\n<li><strong>Memory allocation</strong>: Use <code>calloc</code> instead of <code>malloc</code> when you want zero-initialized memory (especially for child pointer arrays).</li>\n<li><strong>Error handling</strong>: Check every <code>malloc</code>/<code>calloc</code> return value for NULL and handle gracefully (free previous allocations and return error).</li>\n<li><strong>Const correctness</strong>: Use <code>const</code> for pointer parameters that shouldn&#39;t be modified (e.g., <code>const BTreeNode* node</code> in search functions).</li>\n<li><strong>Static functions</strong>: Mark helper functions as <code>static</code> (file scope) to avoid polluting the global namespace.</li>\n<li><strong>Integer types</strong>: Use <code>size_t</code> for counts and indices that can&#39;t be negative; use <code>int</code> for keys in this simple implementation.</li>\n<li><strong>Debugging</strong>: Compile with <code>-g -O0</code> for debugging and <code>-fsanitize=address</code> for memory error detection.</li>\n</ol>\n<p><strong>Milestone Checkpoint for Section 1:</strong></p>\n<p>After setting up your project structure and implementing the basic node infrastructure:</p>\n<ol>\n<li><strong>Compile your code</strong>: <code>gcc -c src/node.c -Iinclude -o node.o</code></li>\n<li><strong>Test node creation</strong>: Write a simple test that creates nodes with different <code>t</code> values and checks:<ul>\n<li>Memory is correctly allocated</li>\n<li>Arrays have the right sizes</li>\n<li>Fields are properly initialized</li>\n</ul>\n</li>\n<li><strong>Verify with valgrind</strong>: Run <code>valgrind ./your_test_program</code> to ensure no memory leaks.</li>\n<li><strong>Expected behavior</strong>: Nodes should be created and destroyed cleanly with no memory errors.</li>\n<li><strong>Signs of trouble</strong>: Segmentation faults indicate uninitialized pointers or array bounds errors; memory leaks mean you&#39;re not freeing all allocated memory.</li>\n</ol>\n<hr>\n<h2 id=\"2-goals-and-non-goals\">2. Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This foundational section corresponds to all milestones (1-4), establishing the functional and non-functional boundaries for the entire B-tree implementation.</p>\n</blockquote>\n<p>This section precisely defines what the B-tree implementation will and will not do. Given the educational nature of the project, we deliberately constrain the scope to focus on core algorithmic concepts while establishing a clean foundation for potential future extensions. Clear boundaries prevent scope creep and help learners concentrate on mastering the fundamental mechanics of B-tree operations.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>The primary functional goal is to implement a <strong>correct, in-memory B-tree</strong> that adheres to all classic invariants and supports the three fundamental dictionary operations. This B-tree will serve as a pedagogical model for understanding how disk-optimized tree structures maintain balance.</p>\n<blockquote>\n<p><strong>Mental Model: A Self-Organizing Filing Cabinet</strong>\nThink of the B-tree as a smart filing cabinet for index cards. Each drawer (node) can hold a fixed number of cards (keys). When a drawer becomes too full, it automatically splits into two, and a new divider card is sent to the drawer above. When a drawer becomes too empty, it either borrows a card from a neighbor or merges with one. The entire cabinet maintains a strict alphabetical order, and any card can be found by checking at most a few drawers. Our implementation builds this cabinet entirely in RAM, simulating the drawer operations that would normally occur on disk.</p>\n</blockquote>\n<p>The following table enumerates the core operations the B-tree must support, their exact behavioral specifications, and how they map to the key invariants.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Signature (C)</th>\n<th align=\"left\">Preconditions</th>\n<th align=\"left\">Postconditions &amp; Guarantees</th>\n<th align=\"left\">Key Invariants Maintained</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Create Tree</strong></td>\n<td align=\"left\"><code>BTree* btree_create(int min_degree)</code></td>\n<td align=\"left\"><code>min_degree</code> ≥ 2.</td>\n<td align=\"left\">Returns a pointer to a new, empty <code>BTree</code> struct with <code>root</code> set to <code>NULL</code>, <code>t</code> set to <code>min_degree</code>, and <code>key_count</code> set to 0. Memory is allocated for the tree structure.</td>\n<td align=\"left\">Establishes the minimum degree <code>t</code> for all future node capacity calculations.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Search Key</strong></td>\n<td align=\"left\"><code>SearchResult btree_search(BTree* tree, int key)</code></td>\n<td align=\"left\"><code>tree</code> is a valid pointer from <code>btree_create</code>. <code>key</code> is an integer.</td>\n<td align=\"left\">Returns a <code>SearchResult</code> struct. If the key exists, <code>found</code> is <code>true</code> and <code>value</code> points to the associated data (or is <code>NULL</code> if no values are stored). If not found, <code>found</code> is <code>false</code>. The <code>comparisons</code> field records the total number of key comparisons performed during the search. The tree structure remains unchanged.</td>\n<td align=\"left\">Demonstrates the <code>O(log n)</code> search path length. Relies on sorted keys within nodes and correct child pointer navigation.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Insert Key-Value</strong></td>\n<td align=\"left\"><code>bool btree_insert(BTree* tree, int key, void* value)</code></td>\n<td align=\"left\"><code>tree</code> is valid. <code>key</code> is an integer. <code>value</code> is an optional pointer to associated data (may be <code>NULL</code>).</td>\n<td align=\"left\">If the key does <strong>not</strong> already exist in the tree, it is inserted along with its value. The tree is rebalanced via proactive splitting to maintain all B-tree invariants. Returns <code>true</code> on successful insertion. If the key already exists, the operation is a <strong>no-op</strong>: the tree is unchanged, and the function returns <code>false</code>. The <code>key_count</code> in the tree is updated accordingly.</td>\n<td align=\"left\">Guarantees all nodes (except root) have between <code>t-1</code> and <code>2t-1</code> keys. Ensures all keys in the tree remain in sorted order. Handles root split, increasing tree height by one when necessary.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Delete Key</strong></td>\n<td align=\"left\"><code>bool btree_delete(BTree* tree, int key)</code></td>\n<td align=\"left\"><code>tree</code> is valid. <code>key</code> is an integer.</td>\n<td align=\"left\">If the key exists in the tree, it is removed. The tree is rebalanced via borrowing from siblings or merging nodes to maintain the minimum occupancy invariant. Returns <code>true</code> on successful deletion. If the key does not exist, the operation is a <strong>no-op</strong>: the tree is unchanged, and the function returns <code>false</code>. The <code>key_count</code> is updated.</td>\n<td align=\"left\">Maintains the minimum key count invariant (all non-root nodes have at least <code>t-1</code> keys). Handles root deletion that may reduce tree height by one. Preserves sorted order.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Utility &amp; Inspection</strong></td>\n<td align=\"left\"><code>size_t btree_size(BTree* tree)</code><br><code>int btree_height(BTree* tree)</code><br><code>bool btree_validate(BTree* tree)</code><br><code>void btree_print(BTree* tree)</code></td>\n<td align=\"left\"><code>tree</code> is valid (may be <code>NULL</code> for some functions).</td>\n<td align=\"left\">Returns the total number of keys (<code>key_count</code>), the height (root to leaf, with leaves at height 0), a boolean indicating if all B-tree invariants hold, and a textual representation of the tree structure (for debugging), respectively. These functions do not modify the tree.</td>\n<td align=\"left\">The validation function (<code>btree_validate</code>) is the ultimate correctness check, verifying every invariant listed in Section 4.</td>\n</tr>\n</tbody></table>\n<p>The sequence of these operations defines the primary data flow: creation → insertion (builds the tree) → search (queries the tree) → deletion (modifies the tree) → inspection (verifies the tree). Success is defined by the <code>btree_validate</code> function returning <code>true</code> after any sequence of these operations.</p>\n<h3 id=\"non-functional-goals-amp-non-goals\">Non-Functional Goals &amp; Non-Goals</h3>\n<p>This implementation prioritizes <strong>clarity, correctness, and educational value</strong> over performance optimizations or production-ready features. The non-functional goals define the quality attributes we will achieve, while the non-goals explicitly list features we are omitting, explaining why they are out of scope for this learning exercise.</p>\n<p><strong>Non-Functional Goals</strong></p>\n<ol>\n<li><strong>Algorithmic Complexity:</strong> All operations must achieve their theoretical time complexities. Search, insertion, and deletion must run in <code>O(log n)</code> time, where the base of the logarithm is the minimum degree <code>t</code>. This requires efficient binary search within nodes (<code>O(log t)</code>) and a tree height of <code>O(log_t n)</code>.</li>\n<li><strong>Memory Safety (C):</strong> The implementation must not leak memory. Every <code>malloc</code> or <code>calloc</code> must have a corresponding <code>free</code>. The <code>btree_destroy</code> function must completely deallocate all tree nodes and the tree structure itself.</li>\n<li><strong>Robustness to Edge Cases:</strong> The implementation must correctly handle standard edge cases: inserting into an empty tree, deleting the only key in the tree, splitting the root, merging all the way to the root, and attempting to delete a non-existent key.</li>\n<li><strong>Debuggability:</strong> The provided <code>btree_print</code> and <code>btree_validate</code> functions must offer sufficient introspection to diagnose structural issues during development. The <code>SearchResult.comparisons</code> field provides visibility into search efficiency.</li>\n<li><strong>Configurable Node Size:</strong> The B-tree&#39;s node capacity, determined by the minimum degree <code>t</code>, must be configurable at tree creation. This allows experimenting with different fanouts and observing their effect on tree height.</li>\n</ol>\n<p><strong>Non-Goals</strong>\nExplicitly excluding the following areas keeps the project focused and achievable, while the table below justifies each exclusion and suggests how they could be added later.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Feature</th>\n<th align=\"left\">Status (Non-Goal)</th>\n<th align=\"left\">Rationale for Exclusion</th>\n<th align=\"left\">Potential Extension Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Persistent Storage to Disk</strong></td>\n<td align=\"left\">Excluded</td>\n<td align=\"left\">The core learning objective is the in-memory balancing algorithm. Disk I/O (page caching, serialization, write-ahead logging) introduces significant complexity that would distract from the core B-tree mechanics.</td>\n<td align=\"left\">Add a <code>Pager</code> module that maps node IDs to disk offsets, and modify node splits/merges to write pages back to a file.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Concurrency Control (Thread Safety)</strong></td>\n<td align=\"left\">Excluded</td>\n<td align=\"left\">Managing concurrent inserts, deletes, and searches with locks (e.g., B-link tree techniques) is an advanced topic beyond introductory B-tree concepts.</td>\n<td align=\"left\">Protect the tree root with a mutex for coarse-grained locking, or implement fine-grained lock coupling on node traversal paths.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Variable-Length or Generic Keys</strong></td>\n<td align=\"left\">Excluded</td>\n<td align=\"left\">Using integer keys simplifies comparison logic and memory management, letting learners focus on structure. Supporting strings or generic types requires custom comparators and more complex node memory layout.</td>\n<td align=\"left\">Replace the <code>int* keys</code> array with a <code>void** keys</code> array and a function pointer <code>comparator</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Associated Values (Full Key-Value Store)</strong></td>\n<td align=\"left\">Partially Supported</td>\n<td align=\"left\">The <code>BTreeNode</code> struct includes a <code>values</code> array (<code>void**</code>), allowing storage of optional pointers. However, managing the lifecycle (allocation/freeing) of these values is <strong>not</strong> a goal. The implementation only stores and returns the pointer.</td>\n<td align=\"left\">Make <code>btree_insert</code> accept a <code>value_size</code> and use <code>memcpy</code> to store values inline within the node or in a separate heap allocation.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Duplicate Keys</strong></td>\n<td align=\"left\">Excluded</td>\n<td align=\"left\">Standard B-tree definitions prohibit duplicates. Supporting them requires modifying the search and insert logic (e.g., allowing multiple values per key or using a secondary index), which adds complexity.</td>\n<td align=\"left\">Modify <code>node_find_key_index</code> to find the first occurrence, and adjust insertion to allow non-unique keys, potentially storing a list of values per key.</td>\n</tr>\n<tr>\n<td align=\"left\"><em><em>B+ Tree or B</em> Tree Variants</em>*</td>\n<td align=\"left\">Excluded</td>\n<td align=\"left\">This is a classic B-tree where keys are stored in both internal nodes and leaves. B+ trees (keys only in leaves, linked leaves) are an important optimization for databases but represent a different structural variant.</td>\n<td align=\"left\">Convert the B-tree to a B+ tree by removing keys from internal nodes (keeping only separators) and adding sibling pointers between leaf nodes.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Advanced Optimizations (Bulk Loading, Compression)</strong></td>\n<td align=\"left\">Excluded</td>\n<td align=\"left\">These are performance optimizations valuable in production systems but orthogonal to understanding the core insert/split/delete/merge algorithms.</td>\n<td align=\"left\">Implement a <code>btree_bulk_load</code> function that sorts all keys and builds the tree from the bottom up for optimal packing.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The most critical trade-off in this design is <strong>abstraction vs. realism</strong>. We abstract away disk persistence—the original raison d&#39;être for B-trees—to isolate the balancing algorithm. This allows learners to build a correct, understandable mental model of node splitting and merging first. Once this core is solid, extending the design to include a pager module (for disk I/O) becomes a more manageable, separate challenge.</p>\n</blockquote>\n<h3 id=\"common-pitfalls-misinterpreting-scope\">Common Pitfalls: Misinterpreting Scope</h3>\n<p>Learners often mistakenly believe they need to implement features from the non-goals list, or they overlook subtle aspects of the defined goals.</p>\n<ul>\n<li>⚠️ <strong>Pitfall: Implementing Reactive Instead of Proactive Splitting.</strong> The design specifies <em>proactive</em> splitting during the insertion descent. A common mistake is to insert into a leaf first, find it&#39;s full, and then split (reactive). This works for leaves but fails for internal nodes if a child needs to be split during the descent. <strong>Fix:</strong> Always check if a child node is full <em>before</em> recursively descending into it during insertion.</li>\n<li>⚠️ <strong>Pitfall: Ignoring the <code>values</code> Array in Node Operations.</strong> Even though value management is a non-goal, the <code>values</code> array pointer must be maintained correctly. When splitting a node or moving keys during borrowing/merging, the associated value pointer must be moved alongside its key. Forgetting this leads to search returning incorrect <code>value</code> pointers. <strong>Fix:</strong> Treat the key and its value as a bonded pair in all node-level operations (insert, delete, split, borrow).</li>\n<li>⚠️ <strong>Pitfall: Allowing <code>t=1</code>.</strong> The minimum degree <code>t</code> must be at least 2. If <code>t=1</code>, the node capacity rules break down (a node would be allowed 1 to 1 key, making splitting nonsensical). <strong>Fix:</strong> In <code>btree_create</code>, validate that <code>min_degree &gt;= 2</code> and return <code>NULL</code> or abort if not.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete starter code and structure for the B-tree&#39;s foundational types and the goal-oriented functions. Since persistence and concurrency are non-goals, we focus on clean, memory-safe in-memory structures.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Recommended)</th>\n<th align=\"left\">Advanced Option (Post-Learning)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Memory Management</strong></td>\n<td align=\"left\">Standard <code>malloc</code>/<code>free</code> with careful manual tracking.</td>\n<td align=\"left\">Use a custom arena allocator for nodes to improve locality and simplify freeing (destroy just frees the arena).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Key Comparison</strong></td>\n<td align=\"left\">Direct integer comparison (<code>&lt;</code>, <code>==</code>, <code>&gt;</code>).</td>\n<td align=\"left\">Function pointer to a comparator for generic keys.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Tree Visualization</strong></td>\n<td align=\"left\">Recursive print to console with indentation (<code>btree_print</code>).</td>\n<td align=\"left\">Generate Graphviz DOT format output to render as an image.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Validation</strong></td>\n<td align=\"left\">Recursive invariant checker (<code>btree_validate</code>).</td>\n<td align=\"left\">Integrate the checker with a unit test framework (e.g., Google Test for C++).</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Place the core B-tree implementation in two files: a header for declarations and a source file for definitions. This separates interface from implementation.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree-project/\n├── include/\n│   └── btree.h          &lt;-- Public API and struct definitions\n├── src/\n│   ├── btree.c          &lt;-- Implementation of BTree operations\n│   ├── node.c           &lt;-- Implementation of Node-level helpers\n│   └── main.c           &lt;-- Example usage or test driver (optional)\n└── tests/\n    └── test_btree.c     &lt;-- Unit tests</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>The following is <strong>complete, compilable code</strong> for the core data structures and basic tree lifecycle functions. A learner should place this in <code>btree.h</code> and start the implementation in <code>btree.c</code>.</p>\n<p><strong>File: <code>include/btree.h</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_MIN_DEGREE</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Core Types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BTreeNode {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int*</span><span style=\"color:#E1E4E8\"> keys;</span><span style=\"color:#6A737D\">                  // Array of keys (size = 2*t - 1)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> values;</span><span style=\"color:#6A737D\">              // Optional array of associated values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> BTreeNode</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> children;</span><span style=\"color:#6A737D\">// Array of child pointers (size = 2*t)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_keys;</span><span style=\"color:#6A737D\">               // Current number of keys in node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> is_leaf;</span><span style=\"color:#6A737D\">               // True if leaf, false if internal node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BTreeNode;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BTree {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> root;</span><span style=\"color:#6A737D\">            // Pointer to root node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> t;</span><span style=\"color:#6A737D\">                      // Minimum degree (defines capacity bounds)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> key_count;</span><span style=\"color:#6A737D\">           // Total keys in entire tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BTree;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> SearchResult {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found;</span><span style=\"color:#6A737D\">                 // Whether the key exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> value;</span><span style=\"color:#6A737D\">                // Associated value if found (may be NULL)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> comparisons;</span><span style=\"color:#6A737D\">            // Number of key comparisons performed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SearchResult;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Tree Lifecycle &#x26; Public API</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_destroy</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> btree_size</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_height</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Node-level helper functions (internal use, but exposed for testing)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_destroy</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_underfull</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // BTREE_H</span></span></code></pre></div>\n\n<p><strong>File: <code>src/btree.c</code> - Starter Skeleton</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ============================================</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Tree Lifecycle Functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ============================================</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate min_degree >= 2. Return NULL if invalid.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allocate memory for BTree struct.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize fields: t = min_degree, root = NULL, key_count = 0.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the pointer to the new tree.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_destroy</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If tree->root exists, call node_destroy(tree->root) to free the entire node hierarchy.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Free the tree struct itself.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ============================================</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Public API Functions (Skeletons)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ============================================</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SearchResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> tree->root </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement recursive search starting from tree->root.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Create a helper function `search_subtree(node, key, &#x26;comparisons)`.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement proactive split insertion.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. If root is full, split it (creates new root, increases height).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Call a recursive helper `insert_non_full(starting_node, key, value)`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. If key already exists (found during descent), return false.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. On successful new insertion, increment tree->key_count and return true.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> tree->root </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement deletion with borrowing/merging.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Call a recursive helper `delete_key(node, key)`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. If key not found, return false.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. If after deletion the root has 0 keys and is not a leaf, set its only child as new root.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. On successful deletion, decrement tree->key_count and return true.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> btree_size</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#E1E4E8\"> tree->key_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_height</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> tree->root </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Empty tree height convention</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Recursively compute height by following leftmost child until a leaf.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Height definition: leaf nodes are at height 0. Root alone (leaf) = 0.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement comprehensive invariant checks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Check root key count: 0 &#x3C;= num_keys &#x3C;= 2t-1, and if root is leaf, children pointers should be NULL.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Recursively check every node:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //    a. Key count in [t-1, 2t-1] for non-root.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //    b. Keys are strictly increasing within node.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //    c. For internal nodes: num_keys + 1 == number of non-NULL children.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //    d. Leaf check: is_leaf == (all children are NULL).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Check that the tree's key_count matches the sum of keys in all nodes.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"(null tree)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement a pretty-print or debug print.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Simple approach: Print each level with indentation.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"B-Tree (t=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, keys=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">, height=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           tree->t, tree->key_count, </span><span style=\"color:#B392F0\">btree_height</span><span style=\"color:#E1E4E8\">(tree));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Call a recursive node printer.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>src/node.c</code> - Starter Skeleton</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate memory for BTreeNode struct.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allocate arrays: keys (size = 2*t - 1), values (same size), children (size = 2*t).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize all fields: num_keys = 0, is_leaf = is_leaf.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize children array to all NULLs (important for leaf nodes).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return the new node.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_destroy</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If node is not a leaf, recursively destroy all non-NULL children.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Free the keys, values, and children arrays.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Free the node struct itself.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement binary search within node->keys[0..num_keys-1].</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Initialize left=0, right=node->num_keys-1.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. While left &#x3C;= right, compute mid, compare key with node->keys[mid].</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //    Increment (*comparisons) for each comparison.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. If key found, return the exact index.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. If not found, return the index of the first key greater than the target,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //    or node->num_keys if all keys are smaller. This is the child index to descend into.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (node </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_underfull</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (node </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (t </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-milestone-checkpoint-after-setting-up-foundations\">D. Milestone Checkpoint: After Setting Up Foundations</h4>\n<p>After implementing just the skeleton and the <code>btree_create</code> and <code>btree_destroy</code> functions (with proper memory allocation/deallocation in <code>node_create</code> and <code>node_destroy</code>), you should be able to compile without errors and run a simple test.</p>\n<p><strong>Compilation Command (using GCC):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -I./include</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> src/btree.c</span><span style=\"color:#9ECBFF\"> src/node.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> btree.o</span><span style=\"color:#9ECBFF\"> node.o</span></span></code></pre></div>\n<p><strong>Expected Outcome:</strong> Successful compilation (no errors). Linking with a simple <code>main.c</code> that creates and destroys a tree should run without memory leaks (check with Valgrind).</p>\n<p><strong>Signs of Trouble:</strong></p>\n<ul>\n<li><strong>Segmentation fault on <code>btree_destroy</code>:</strong> Likely caused by not initializing the <code>children</code> array to <code>NULL</code> in <code>node_create</code>, leading to <code>free</code> on uninitialized pointers.</li>\n<li><strong>Memory leaks:</strong> Use <code>valgrind ./your_program</code> to detect leaks. Any remaining allocations indicate missing <code>free</code> in <code>node_destroy</code> or <code>btree_destroy</code>.</li>\n</ul>\n<h4 id=\"e-language-specific-hints-c\">E. Language-Specific Hints (C)</h4>\n<ul>\n<li><strong>Memory Allocation:</strong> Use <code>calloc</code> for arrays to ensure zero-initialization. For example, <code>node-&gt;children = calloc(2 * t, sizeof(BTreeNode*))</code> sets all pointers to <code>NULL</code>, which is required for leaf nodes and simplifies logic.</li>\n<li><strong>Integer Overflow:</strong> When calculating array sizes (e.g., <code>2*t - 1</code>), ensure <code>t</code> is not so large that it causes integer overflow. For this educational project, assume <code>t</code> is small (&lt; 1000).</li>\n<li><strong>Const Correctness:</strong> For search functions that don&#39;t modify the tree, consider using <code>const</code> parameters (e.g., <code>const BTree* tree</code>) to signal intent, though the skeleton omits this for simplicity.</li>\n<li><strong>Header Guards:</strong> Always use <code>#ifndef BTREE_H</code> / <code>#define BTREE_H</code> / <code>#endif</code> in headers to prevent double inclusion.</li>\n</ul>\n<hr>\n<h2 id=\"3-high-level-architecture\">3. High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This foundational section corresponds primarily to Milestone 1 (Node Structure), but also provides the overall architectural context for all subsequent milestones (2-4). Understanding how components interact is crucial before implementing search, insert, and delete operations.</p>\n</blockquote>\n<p>The B-tree implementation follows a layered, modular architecture designed to separate concerns between data storage (<code>Node</code>), tree management (<code>BTree</code>), and algorithmic operations (<code>Operations</code>). This separation allows each component to focus on a single responsibility, making the system easier to understand, test, and extend. Although our educational implementation is in-memory, the architecture mirrors patterns used in disk-based systems where each node corresponds to a disk page.</p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>Think of the B-tree architecture as a <strong>library building</strong> with three distinct roles:</p>\n<ul>\n<li><strong>The <code>Node</code> component</strong> is like an <strong>individual bookshelf</strong> within the library, holding a collection of books (keys) and possibly pointers to other shelves (child nodes). Each shelf has strict capacity rules.</li>\n<li><strong>The <code>BTree</code> component</strong> is like the <strong>library building&#39;s floor plan</strong>, maintaining a reference to the main entrance (root node) and the building&#39;s structural rules (minimum degree <code>t</code>).</li>\n<li><strong>The <code>Operations</code> component</strong> is like the <strong>librarian&#39;s procedures</strong>, defining the step-by-step processes for finding a book, adding a new book (which may require splitting a full shelf), or removing a book (which may require borrowing from neighbors or merging shelves).</li>\n</ul>\n<p>The relationship between these components is visualized in the following diagram, which shows how <code>BTree</code> orchestrates operations that manipulate <code>Node</code> instances:</p>\n<p><img src=\"/api/project/btree-impl/architecture-doc/asset?path=diagrams%2Farch-component.svg\" alt=\"B-tree System Components\"></p>\n<p>The table below details the responsibilities and key attributes of each logical component:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Key Data it Holds</th>\n<th>Key Behaviors it Manages</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>BTree</code> (Orchestrator)</strong></td>\n<td>Serves as the main entry point and container for the entire tree structure. It maintains global properties and ensures the tree invariants are preserved after operations.</td>\n<td>• Root node pointer<br>• Minimum degree (<code>t</code>)<br>• Total key count (optional)</td>\n<td>• Creating/destroying the tree<br>• Initiating search, insert, delete operations<br>• Validating tree structure<br>• Calculating tree height and size</td>\n</tr>\n<tr>\n<td><strong><code>Node</code> (Data Container)</strong></td>\n<td>Represents a single node (or disk page) in the B-tree. Stores keys and child pointers, and knows whether it is a leaf. It is the fundamental unit of data organization and transfer.</td>\n<td>• Array of integer keys<br>• Array of child node pointers (for internal nodes)<br>• Count of keys currently stored (<code>num_keys</code>)<br>• Boolean flag indicating leaf status (<code>is_leaf</code>)</td>\n<td>• Finding a key&#39;s position within its local array<br>• Reporting if it is full or underfull<br>• Splitting itself into two nodes (insert)<br>• Borrowing a key from or merging with a sibling (delete)</td>\n</tr>\n<tr>\n<td><strong><code>Operations</code> (Algorithms)</strong></td>\n<td>Encapsulates the core B-tree algorithms that traverse and modify the tree structure. These are implemented as functions that operate on the <code>BTree</code> and <code>Node</code> structures.</td>\n<td>• No persistent state of its own</td>\n<td>• Recursive tree traversal (search)<br>• Proactive node splitting during insertion descent<br>• Complex rebalancing (borrow/merge) during deletion</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Design Insight:</strong> The <code>BTree</code> struct acts as a thin facade. Its primary job is to hold the root pointer and configuration (<code>t</code>), delegating all complex logic to the operation functions which recursively navigate the node hierarchy. This keeps the tree&#39;s state simple and centralizes algorithm complexity in well-defined procedures.</p>\n</blockquote>\n<h4 id=\"component-interactions-and-data-flow\">Component Interactions and Data Flow</h4>\n<p>The components interact through a clear calling hierarchy:</p>\n<ol>\n<li><strong>Client Code</strong> calls a public function on the <code>BTree</code> component (e.g., <code>btree_insert</code>).</li>\n<li><strong><code>BTree</code> Function</strong> performs initial validation, then calls a recursive internal operation function, passing the root node and other parameters.</li>\n<li><strong>Internal Operation Function</strong> traverses nodes, calling <code>Node</code> helper functions (like <code>node_find_key_index</code>) to navigate within each node. If structural changes are needed (split, borrow, merge), the operation function orchestrates these by creating/destroying nodes and updating pointers.</li>\n<li><strong><code>Node</code> Helper Functions</strong> perform localized tasks, such as inserting a key into a node&#39;s sorted array or splitting a node&#39;s keys and children into two.</li>\n</ol>\n<p>For example, during an insertion that causes a root split:</p>\n<ol>\n<li><code>btree_insert</code> is called on the <code>BTree</code>.</li>\n<li>The internal insertion function discovers the root is full.</li>\n<li>It creates a new root node and splits the old root, promoting the median key to the new root.</li>\n<li>It updates the <code>BTree</code>&#39;s root pointer to point to the new root.</li>\n<li>Control returns to <code>btree_insert</code>, which updates the tree&#39;s key count.</li>\n</ol>\n<p>This interaction pattern ensures that the <code>BTree</code> struct remains the single source of truth for the tree&#39;s identity (its root), while algorithms are free to manipulate the node graph.</p>\n<h3 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h3>\n<p>A clean, modular code organization is essential for managing the complexity of the B-tree algorithms. The following structure separates interface from implementation, groups related functions, and provides a clear path for testing. This is particularly important in C, where module boundaries are enforced by file organization rather than language features.</p>\n<p>The recommended directory and file structure for a C implementation is as follows:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree-project/\n├── include/                    # Public header files (API)\n│   └── btree.h                # Main public interface: BTree, BTreeNode, SearchResult types and public function declarations\n├── src/                       # Private implementation source files\n│   ├── btree.c               # Implementation of public API functions (btree_create, btree_search, etc.)\n│   ├── btree_private.h       *Private header: declarations of internal helper functions and constants*\n│   ├── node.c                # Implementation of node-level functions (node_create, node_find_key_index, node_split, etc.)\n│   └── operations.c          # Implementation of core recursive algorithms (insert_recursive, delete_recursive, etc.)\n├── tests/                     # Test suite\n│   ├── test_btree.c          # Unit tests for the public API\n│   ├── test_node.c           # Unit tests for node utilities\n│   └── test_operations.c     # Unit tests for internal algorithms\n├── examples/                  # Example programs\n│   └── basic_usage.c         # Demonstrates creating a tree, inserting keys, searching, and deleting\n└── Makefile                   # Build automation</code></pre></div>\n\n<blockquote>\n<p><em>Note: <code>btree_private.h</code> is included only by <code>.c</code> files within the <code>src/</code> directory. It keeps internal implementation details (like recursive function prototypes) hidden from users of the public <code>btree.h</code> API.</em></p>\n</blockquote>\n<p>The table below justifies the purpose of each key file:</p>\n<table>\n<thead>\n<tr>\n<th>File</th>\n<th>Purpose</th>\n<th>Key Contents</th>\n<th>Visibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>include/btree.h</code></strong></td>\n<td>Public API header. This is the only file a user of the B-tree library needs to include.</td>\n<td>• <code>BTree</code>, <code>BTreeNode</code>, <code>SearchResult</code> type definitions (can be opaque pointers if desired)<br>• All public function prototypes (e.g., <code>btree_create</code>, <code>btree_insert</code>)<br>• Documentation comments for users</td>\n<td>Public</td>\n</tr>\n<tr>\n<td><strong><code>src/btree_private.h</code></strong></td>\n<td>Private implementation header. Shared internal details between <code>.c</code> files in the <code>src/</code> module.</td>\n<td>• <code>DEFAULT_MIN_DEGREE</code> constant<br>• Prototypes for internal recursive functions (e.g., <code>insert_non_full</code>, <code>delete_from_subtree</code>)<br>• Helper function prototypes used across operations</td>\n<td>Private (internal to library)</td>\n</tr>\n<tr>\n<td><strong><code>src/btree.c</code></strong></td>\n<td>Implementation of the public API facade. Contains functions that initiate operations and manage the <code>BTree</code> struct.</td>\n<td>• Definitions of <code>btree_create</code>, <code>btree_destroy</code>, <code>btree_size</code>, <code>btree_height</code><br>• <code>btree_search</code>, <code>btree_insert</code>, <code>btree_delete</code> implementations (which call internal functions in <code>operations.c</code>)<br>• Public validation and print functions</td>\n<td>Private implementation</td>\n</tr>\n<tr>\n<td><strong><code>src/node.c</code></strong></td>\n<td>Implementation of all node-level utilities. Functions here operate on a single <code>BTreeNode</code>.</td>\n<td>• <code>node_create</code>, <code>node_destroy</code><br>• <code>node_find_key_index</code> (binary search)<br>• <code>node_is_full</code>, <code>node_is_underfull</code><br>• <code>node_split_child</code> (critical for insertion)<br>• <code>node_borrow_from_left</code>, <code>node_merge_with_right</code> (for deletion)</td>\n<td>Private implementation</td>\n</tr>\n<tr>\n<td><strong><code>src/operations.c</code></strong></td>\n<td>Implementation of the core recursive algorithms that traverse and modify the tree.</td>\n<td>• <code>search_recursive</code> (called by <code>btree_search</code>)<br>• <code>insert_non_full</code> (recursive insertion helper)<br>• <code>delete_from_subtree</code> (complex recursive deletion with borrow/merge logic)</td>\n<td>Private implementation</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Modular Separation of Node Utilities and Operations</strong></p>\n<ul>\n<li><strong>Context:</strong> The B-tree algorithms require both low-level node manipulations (e.g., inserting a key into an array) and high-level recursive tree traversal logic. We needed to decide how to organize these related but distinct responsibilities.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Monolithic file:</strong> Place all functions in one large <code>btree.c</code> file.</li>\n<li><strong>Separation by abstraction level:</strong> Split node utilities (<code>node.c</code>) from tree operations (<code>operations.c</code>), with a public API layer (<code>btree.c</code>).</li>\n<li><strong>Separation by operation:</strong> Have separate files for <code>search.c</code>, <code>insert.c</code>, <code>delete.c</code>.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> We chose option 2 (separation by abstraction level).</li>\n<li><strong>Rationale:</strong> The node utilities (creating, destroying, searching within a node, splitting) are independent, reusable building blocks used by multiple operations. Separating them makes the code more modular and testable. It also mirrors the conceptual separation between the <code>Node</code> and <code>Operations</code> components. Option 1 leads to an unmanageably large file, while option 3 creates unnecessary fragmentation and duplication (e.g., both insert and delete need node-splitting logic).</li>\n<li><strong>Consequences:</strong> Build times may be slightly longer due to more compilation units, but incremental compilation is improved. Developers must understand the dependency graph: <code>operations.c</code> depends on <code>node.c</code>, and <code>btree.c</code> depends on both.</li>\n</ul>\n</blockquote>\n<p>This file structure provides a clear roadmap for implementation, aligning with the project milestones:</p>\n<ul>\n<li><strong>Milestone 1</strong> focuses on <code>node.c</code> and the data structures in <code>btree.h</code>.</li>\n<li><strong>Milestone 2</strong> focuses on <code>search_recursive</code> in <code>operations.c</code> and its exposure via <code>btree_search</code> in <code>btree.c</code>.</li>\n<li><strong>Milestone 3</strong> focuses on <code>insert_non_full</code> and <code>node_split_child</code> across <code>operations.c</code> and <code>node.c</code>.</li>\n<li><strong>Milestone 4</strong> focuses on <code>delete_from_subtree</code> and the borrow/merge helpers in <code>node.c</code>.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<p>For this C implementation, we recommend a straightforward approach suitable for learning. The &quot;Advanced Option&quot; column hints at production-ready extensions.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning)</th>\n<th>Advanced Option (Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Memory Management</strong></td>\n<td>Standard <code>malloc</code>/<code>free</code> with careful manual tracking of all allocations.</td>\n<td>Use a custom slab allocator or arena allocator to group node allocations, improving cache locality and reducing fragmentation.</td>\n</tr>\n<tr>\n<td><strong>Key Storage</strong></td>\n<td>Fixed-size array of <code>int</code> within each node. Simple and predictable.</td>\n<td>Support generic keys via function pointers (<code>compare_fn</code>) and store keys as <code>void*</code> or variable-length bytes.</td>\n</tr>\n<tr>\n<td><strong>Value Storage</strong></td>\n<td>Store <code>void*</code> values in an array parallel to <code>keys</code>. Optional for Milestones 1-3.</td>\n<td>Implement as a true key-value store with support for arbitrary value types and sizes.</td>\n</tr>\n<tr>\n<td><strong>Error Handling</strong></td>\n<td>Return boolean success/failure from public functions. Use <code>assert</code> for internal invariants during debugging.</td>\n<td>Rich error codes (<code>BTREE_ERR_MEMORY</code>, <code>BTREE_ERR_KEY_NOT_FOUND</code>). Pluggable error logging callback.</td>\n</tr>\n<tr>\n<td><strong>Persistence</strong></td>\n<td>In-memory only for simplicity.</td>\n<td>Add a <code>btree_save</code>/<code>btree_load</code> API that maps nodes to fixed-size disk pages using file I/O and <code>mmap</code>.</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure-code-layout\">B. Recommended File/Module Structure (Code Layout)</h4>\n<p>Here is the minimal starter code to set up the recommended file structure. Create these files with the following initial content.</p>\n<p><strong>File: <code>include/btree.h</code> (Public API)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Forward declaration to make BTreeNode an opaque type.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Users only handle pointers; internal structure is hidden.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BTreeNode BTreeNode;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> root;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> t;</span><span style=\"color:#6A737D\">                    // Minimum degree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> key_count;</span><span style=\"color:#6A737D\">         // Total keys in the tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BTree;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> comparisons;</span><span style=\"color:#6A737D\">          // For educational insight</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SearchResult;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Tree lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_destroy</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Core operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Inspection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> btree_size</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_height</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // BTREE_H</span></span></code></pre></div>\n\n<p><strong>File: <code>src/btree_private.h</code> (Private Implementation Details)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> BTREE_PRIVATE_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BTREE_PRIVATE_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Default minimum degree if none specified</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_MIN_DEGREE</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Internal node structure (visible only within src/)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> BTreeNode {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int*</span><span style=\"color:#E1E4E8\"> keys;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> values;</span><span style=\"color:#6A737D\">           // Parallel array to keys</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> children;</span><span style=\"color:#6A737D\">    // Array of child pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_keys;</span><span style=\"color:#6A737D\">            // Current number of keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> is_leaf;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: No 't' stored per node; it's passed as parameter where needed.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Node utilities (implemented in node.c)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_destroy</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_underfull</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Core operation helpers (implemented in operations.c)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">search_recursive</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> insert_non_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> delete_from_subtree</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // BTREE_PRIVATE_H</span></span></code></pre></div>\n\n<p><strong>File: <code>src/btree.c</code> (Public API Implementation)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree_private.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate min_degree >= 2 (or use DEFAULT_MIN_DEGREE if invalid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allocate memory for BTree struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize fields: t = min_degree, key_count = 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create an empty root node (leaf, with node_create)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set tree->root to the new node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return the tree pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_destroy</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If tree is NULL, return early</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call node_destroy on tree->root (recursively frees all nodes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Free the tree struct itself</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SearchResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If tree->root is NULL, return empty result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call search_recursive(tree->root, key) and store its result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return the result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If tree or tree->root is NULL, return false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if key already exists? (Optional, but can prevent duplicates)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If root is full, handle root split:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Create new root node (internal)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Make old root the first child of new root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Call node_split_child on new root to split the old root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Update tree->root pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Call insert_non_full(tree->root, key, value, tree->t)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If insert successful, increment tree->key_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return success status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If tree or tree->root is NULL, return false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call delete_from_subtree(tree->root, key, tree->t)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If deletion successful:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Decrement tree->key_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If root now has 0 keys and is not a leaf:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //        * Set tree->root to its only child (root->children[0])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //        * Free the old root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return success status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> btree_size</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return tree->key_count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_height</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start height = 0, current = tree->root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: While current != NULL, increment height and move to first child (if not leaf)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return height</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: (For Milestone 4) Implement recursive invariant checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check root key count: 0 &#x3C;= num_keys &#x3C; 2t (except root can have &#x3C; t-1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - For internal nodes: num_keys + 1 == number of non-NULL children</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Keys sorted within each node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - All leaves at same depth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Child pointers' keys respect B-tree ordering</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: (Debug helper) Implement recursive printing with indentation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>src/node.c</code> (Node Utilities - Starter Code)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree_private.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate memory for BTreeNode struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allocate arrays: keys (size 2*t-1), children (size 2*t), values (size 2*t-1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize fields: num_keys = 0, is_leaf = is_leaf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize children array to NULL (important!)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return the new node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_destroy</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If node is NULL, return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If not leaf, recursively destroy all non-NULL children</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Free the keys, values, children arrays</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Free the node struct itself</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize left = 0, right = node->num_keys - 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: While left &#x3C;= right, perform binary search:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - mid = (left + right) / 2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Increment *comparisons</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If node->keys[mid] == key, return mid (exact match)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If node->keys[mid] &#x3C; key, left = mid + 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Else right = mid - 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return left (the index where key should be inserted, or child index to follow)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return true if node->num_keys == 2*t - 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_underfull</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return true if node->num_keys &#x3C; t - 1 (except root case handled elsewhere)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>src/operations.c</code> (Core Algorithms - Placeholder)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree_private.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">search_recursive</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SearchResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: To be implemented in Milestone 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> insert_non_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: To be implemented in Milestone 3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> delete_from_subtree</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: To be implemented in Milestone 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"c-language-specific-hints-c\">C. Language-Specific Hints (C)</h4>\n<ol>\n<li><p><strong>Memory Allocation:</strong> Always check the return value of <code>malloc</code>. Use <code>calloc</code> for arrays you want zero-initialized (like <code>children</code> pointers). Remember to free in reverse order: first the internal arrays, then the struct.</p>\n</li>\n<li><p><strong>Array Management:</strong> When inserting/deleting keys within a node, you&#39;ll need to shift elements manually. Use <code>memmove</code> for efficiency when shifting large portions of the arrays.</p>\n</li>\n<li><p><strong>Recursive Functions:</strong> The recursive algorithms (<code>search_recursive</code>, <code>insert_non_full</code>, <code>delete_from_subtree</code>) will need the minimum degree <code>t</code> passed as a parameter at each call, since it&#39;s not stored in each node.</p>\n</li>\n<li><p><strong>Debugging:</strong> Use <code>assert</code> liberally during development to catch invariant violations (e.g., <code>assert(node-&gt;num_keys &lt;= 2*t-1)</code>). Implement the <code>btree_print</code> function early to visualize tree structure after operations.</p>\n</li>\n<li><p><strong>Build System:</strong> A simple <code>Makefile</code> with separate compilation for each <code>.c</code> file will speed up development. Ensure <code>src/</code> files include <code>btree_private.h</code>, not <code>btree.h</code>, to maintain the abstraction boundary.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-data-model\">4. Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (B-tree Node Structure), with foundational relevance to all subsequent operations (Milestones 2-4)</p>\n</blockquote>\n<p>The data model defines the core building blocks and rules that give the B-tree its unique properties. Before diving into formal definitions, let&#39;s build an intuitive understanding of how these structures work together.</p>\n<h3 id=\"core-types-and-structures\">Core Types and Structures</h3>\n<p>Think of the B-tree data model as a <strong>well-organized warehouse storage system</strong>. The entire warehouse (<code>BTree</code>) has a master floor plan (<code>root</code>) and a strict rule about shelf capacity (<code>minimum degree t</code>). Each storage shelf (<code>BTreeNode</code>) has labeled compartments (<code>keys</code>) that either point to other shelves in the warehouse (<code>children</code>) for internal nodes, or directly to stored inventory (<code>values</code>) for leaf nodes. The warehouse manager ensures every shelf follows exact capacity rules and that labels are always in alphabetical order.</p>\n<p>This mental model helps visualize why B-trees excel at disk operations: each shelf corresponds to a <strong>disk page</strong> (typically 4KB), and accessing one shelf (loading a page from disk) lets you examine many labels (keys) at once before deciding which next shelf to visit. The strict capacity rules guarantee that shelves are neither too empty (wasting disk space) nor too full (requiring frequent reorganization), optimizing both storage density and access patterns.</p>\n<p>Now let&#39;s formalize these concepts into concrete data structures. The following table defines the two primary types that constitute our B-tree implementation:</p>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>BTree</code></strong> (The entire warehouse)</td>\n<td><code>root</code></td>\n<td><code>BTreeNode*</code></td>\n<td>Pointer to the root node of the tree. The entry point for all operations. When the tree is empty, this is <code>NULL</code>.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>t</code></td>\n<td><code>int</code></td>\n<td>The <strong>minimum degree</strong> parameter that defines the capacity bounds for all nodes in the tree. This value is fixed when the tree is created and determines: <br>• Maximum keys per node: <code>2*t - 1</code> <br>• Minimum keys per node (except root): <code>t - 1</code> <br>• Maximum children per internal node: <code>2*t</code> <br>• Minimum children per internal node (except root): <code>t</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>key_count</code></td>\n<td><code>size_t</code></td>\n<td>Total number of keys stored in the entire tree. Maintained for O(1) size queries. Updated on every insertion and deletion.</td>\n</tr>\n<tr>\n<td><strong><code>BTreeNode</code></strong> (A single shelf)</td>\n<td><code>keys</code></td>\n<td><code>int*</code></td>\n<td>Dynamic array of keys stored in this node. The array has capacity for <code>2*t - 1</code> integers. Keys within a node are always maintained in <strong>ascending sorted order</strong>. For internal nodes, keys act as separators between child subtrees.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>values</code></td>\n<td><code>void**</code></td>\n<td>Optional array of opaque pointers associated with each key. In a key-value B-tree, this stores the value corresponding to each key. For educational purposes focusing only on key structure, this may be <code>NULL</code>. If implemented, it parallels the <code>keys</code> array (same length).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>children</code></td>\n<td><code>BTreeNode**</code></td>\n<td>Dynamic array of child pointers. For internal nodes, this array has size <code>2*t</code> (one more than the number of keys). For leaf nodes, this is typically <code>NULL</code> or an array of <code>NULL</code> pointers (since leaves have no children). Each child pointer <code>children[i]</code> points to a subtree where all keys are greater than <code>keys[i-1]</code> and less than <code>keys[i]</code>.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>num_keys</code></td>\n<td><code>int</code></td>\n<td>Current number of keys actually stored in this node. Must satisfy: <br>• For root: <code>0 ≤ num_keys ≤ 2*t - 1</code> <br>• For other nodes: <code>t-1 ≤ num_keys ≤ 2*t - 1</code> <br>Updated after every insertion, deletion, split, merge, or borrow operation.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>is_leaf</code></td>\n<td><code>bool</code></td>\n<td>Boolean flag indicating whether this node is a leaf (true) or an internal node (false). Determines whether <code>children</code> pointers are followed during traversal. All leaf nodes are at the same depth (height from root).</td>\n</tr>\n<tr>\n<td><strong><code>SearchResult</code></strong> (Search report)</td>\n<td><code>found</code></td>\n<td><code>bool</code></td>\n<td>True if the search key was found in the tree, false otherwise.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>value</code></td>\n<td><code>void*</code></td>\n<td>If <code>found</code> is true and values are stored, contains the opaque pointer associated with the found key. Otherwise <code>NULL</code>.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>comparisons</code></td>\n<td><code>int</code></td>\n<td>Number of key comparisons performed during the search operation. Useful for performance analysis and debugging.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The separation of <code>keys</code> and <code>children</code> into parallel arrays (rather than interleaved key-child pairs) simplifies index calculations during operations. The invariant <code>num_keys + 1 == num_children</code> for internal nodes means we can think of children as &quot;slots between and around keys&quot;: child <code>i</code> contains keys less than <code>keys[i]</code> (if <code>i &lt; num_keys</code>) and greater than <code>keys[i-1]</code> (if <code>i &gt; 0</code>).</p>\n</blockquote>\n<p>These structures relate to each other as shown in the following diagram:</p>\n<p><img src=\"/api/project/btree-impl/architecture-doc/asset?path=diagrams%2Fdata-model-class.svg\" alt=\"B-tree Data Model\"></p>\n<p>The diagram illustrates the containment hierarchy: a <code>BTree</code> contains a <code>root</code> pointer to a <code>BTreeNode</code>, which in turn contains <code>children</code> pointers to other <code>BTreeNode</code> instances. Each node maintains its <code>keys</code> in sorted order, with internal nodes having one more child than keys (creating the &quot;between and around&quot; relationship).</p>\n<h3 id=\"b-tree-invariants\">B-tree Invariants</h3>\n<p>The power of B-trees comes from maintaining five <strong>invariants</strong> (mathematical rules) that guarantee balanced height and efficient operations. These invariants are like the warehouse&#39;s operating regulations—if any is violated, the entire system becomes inefficient or incorrect.</p>\n<ol>\n<li><p><strong>Root Degree Invariant:</strong> </p>\n<blockquote>\n<p>The root node may have as few as 1 key (or 0 if the tree is empty) and at most <code>2*t - 1</code> keys. Unlike other nodes, the root is exempt from the minimum key requirement (<code>t-1</code> keys) to allow the tree to grow and shrink gracefully.</p>\n</blockquote>\n</li>\n<li><p><strong>Internal Node Key Bounds Invariant:</strong></p>\n<blockquote>\n<p>Every non-root internal node must have between <code>t-1</code> and <code>2*t - 1</code> keys inclusive. This ensures nodes are sufficiently full to justify the disk read/write cost while leaving room for insertions without immediate splits.</p>\n</blockquote>\n</li>\n<li><p><strong>Leaf Node Key Bounds Invariant:</strong></p>\n<blockquote>\n<p>Every non-root leaf node must have between <code>t-1</code> and <code>2*t - 1</code> keys inclusive. Leaves follow the same capacity rules as internal nodes, maintaining uniform node sizes across the tree.</p>\n</blockquote>\n</li>\n<li><p><strong>Child Count Invariant:</strong></p>\n<blockquote>\n<p>For any internal node with <code>k</code> keys, it must have exactly <code>k + 1</code> children. This creates the fundamental B-tree structure where each key separates two child subtrees, and there are always one more children than keys.</p>\n</blockquote>\n</li>\n<li><p><strong>Key Ordering Invariant:</strong></p>\n<blockquote>\n<p>All keys within a node are stored in <strong>strictly ascending order</strong> (no duplicates). Furthermore, for any internal node, the keys in child <code>i</code> are all less than <code>keys[i]</code>, and the keys in child <code>i+1</code> are all greater than <code>keys[i]</code>. This recursive ordering property enables efficient binary search at every level.</p>\n</blockquote>\n</li>\n</ol>\n<p>These invariants work together to guarantee that a B-tree with <code>n</code> keys has height at most <code>O(log_t n)</code>. For typical disk-based systems with <code>t</code> around 100-200, this means even terabytes of data can be accessed with only 3-4 disk reads. The following table shows how operations maintain these invariants:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Which Invariants Might Be Threatened</th>\n<th>How Operation Preserves Invariants</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Insert</strong></td>\n<td>Internal/Leaf Key Bounds (node becomes overfull with <code>2*t</code> keys)</td>\n<td><strong>Proactive splitting</strong> during descent ensures no node ever receives a key when already full. Splitting moves the median key up to the parent, creating two nodes each with <code>t-1</code> keys.</td>\n</tr>\n<tr>\n<td><strong>Delete</strong></td>\n<td>Internal/Leaf Key Bounds (node becomes underfull with <code>t-2</code> keys)</td>\n<td><strong>Borrowing</strong> from a sibling (if possible) or <strong>merging</strong> with a sibling (otherwise) ensures every non-root node maintains at least <code>t-1</code> keys.</td>\n</tr>\n<tr>\n<td><strong>Root Split</strong></td>\n<td>Root Degree (root becomes overfull)</td>\n<td>Create a new root with one key (the median from the old root) and two children (the split halves of the old root). The new root satisfies the root&#39;s relaxed bounds (1 key).</td>\n</tr>\n<tr>\n<td><strong>Root Merge</strong></td>\n<td>Root Degree (root becomes empty after merge)</td>\n<td>When the root has 0 keys after a merge from its children, make the merged child the new root. Tree height decreases by 1.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision Record: Node Capacity Representation</strong></p>\n<p><strong>Context:</strong> We need to represent a B-tree node&#39;s capacity constraints in code. The minimum degree <code>t</code> defines all bounds, but we must decide how to store and validate these bounds.</p>\n<p><strong>Options Considered:</strong></p>\n<ol>\n<li><strong>Store only <code>t</code> in <code>BTree</code>:</strong> Each node calculates its bounds using the tree&#39;s <code>t</code> value.</li>\n<li><strong>Store <code>max_keys</code> and <code>min_keys</code> in each node:</strong> Precompute <code>2*t-1</code> and <code>t-1</code> when creating a node.</li>\n<li><strong>Store <code>capacity</code> in each node:</strong> Allocate arrays of size <code>2*t-1</code> for keys and <code>2*t</code> for children, and track <code>num_keys</code>.</li>\n</ol>\n<p><strong>Decision:</strong> Option 1 (store only <code>t</code> in <code>BTree</code>) with dynamic array sizes based on <code>t</code>.</p>\n<p><strong>Rationale:</strong> </p>\n<ul>\n<li><strong>Simplicity:</strong> A single parameter <code>t</code> controls all bounds, reducing state to maintain.</li>\n<li><strong>Consistency:</strong> All nodes in a tree share the same <code>t</code>, so storing it centrally avoids duplication.</li>\n<li><strong>Flexibility:</strong> If we decide to support variable <code>t</code> per node (for advanced variants like B* trees), we can extend later.</li>\n<li><strong>Memory efficiency:</strong> Not storing redundant bounds in every node saves memory, important for large trees.</li>\n</ul>\n<p><strong>Consequences:</strong></p>\n<ul>\n<li><strong>Positive:</strong> Clean abstraction where <code>t</code> is a tree-wide property.</li>\n<li><strong>Negative:</strong> Functions manipulating nodes need access to <code>t</code>, requiring it to be passed as a parameter.</li>\n<li><strong>Mitigation:</strong> We&#39;ll pass <code>t</code> to all node operations as an explicit parameter, making dependencies clear.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Store only <code>t</code> in <code>BTree</code></td>\n<td>Simple, memory efficient, centralized control</td>\n<td>Need to pass <code>t</code> to node functions</td>\n<td>✅ Yes</td>\n</tr>\n<tr>\n<td>Store bounds in each node</td>\n<td>Node functions self-contained</td>\n<td>Memory overhead, duplicate data</td>\n<td></td>\n</tr>\n<tr>\n<td>Store capacity in each node</td>\n<td>Clear array size tracking</td>\n<td>Doesn&#39;t capture minimum bound, still needs <code>t</code> for splitting logic</td>\n<td></td>\n</tr>\n</tbody></table>\n</blockquote>\n<h3 id=\"common-pitfalls-data-model-misunderstandings\">Common Pitfalls: Data Model Misunderstandings</h3>\n<p>⚠️ <strong>Pitfall: Off-by-one in child pointer counts</strong></p>\n<ul>\n<li><strong>Description:</strong> Allocating <code>2*t</code> child pointers for a leaf node (which needs none) or allocating <code>2*t-1</code> child pointers for an internal node (which needs <code>2*t</code>).</li>\n<li><strong>Why it&#39;s wrong:</strong> Wastes memory for leaves, and causes buffer overflows for internal nodes when splitting (which requires temporarily storing <code>2*t</code> children before redistribution).</li>\n<li><strong>Fix:</strong> Only allocate child pointer array for internal nodes. For leaves, set <code>children = NULL</code>. Check <code>is_leaf</code> flag before accessing children.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to update <code>num_keys</code> after operations</strong></p>\n<ul>\n<li><strong>Description:</strong> Modifying the <code>keys</code> array (inserting, deleting, splitting) without updating the <code>num_keys</code> counter.</li>\n<li><strong>Why it&#39;s wrong:</strong> Binary search uses <code>num_keys</code> as the upper bound. If <code>num_keys</code> is too small, searches miss valid keys; if too large, searches access uninitialized memory.</li>\n<li><strong>Fix:</strong> Treat <code>num_keys</code> as the sacred source of truth. Every function that modifies <code>keys</code> must update <code>num_keys</code> as its final step. Consider writing an invariant checker that validates <code>num_keys</code> equals actual occupied slots.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Assuming all nodes have values</strong></p>\n<ul>\n<li><strong>Description:</strong> Accessing <code>values[i]</code> without checking if the tree stores values or if the implementation is key-only.</li>\n<li><strong>Why it&#39;s wrong:</strong> In a key-only B-tree (common in set implementations), <code>values</code> may be <code>NULL</code>. Even in key-value trees, internal nodes often don&#39;t store values (only keys for routing).</li>\n<li><strong>Fix:</strong> Design clearly: either implement full key-value storage (with <code>values</code> array parallel to <code>keys</code>), or omit values entirely for simplicity. Document the choice.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Now let&#39;s bridge from design to implementation. For our C implementation, we&#39;ll create the foundational data structures with careful memory management.</p>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Educational Focus)</th>\n<th>Advanced Option (Production Ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Memory Allocation</strong></td>\n<td>Standard <code>malloc/free</code> with manual tracking</td>\n<td>Memory pool allocator with slab allocation for nodes</td>\n</tr>\n<tr>\n<td><strong>Value Storage</strong></td>\n<td>Opaque <code>void*</code> pointers allowing any data type</td>\n<td>Typed unions with serialization for disk persistence</td>\n</tr>\n<tr>\n<td><strong>Capacity Management</strong></td>\n<td>Dynamic arrays reallocated on split/merge</td>\n<td>Fixed-size pages matching disk block size (e.g., 4096 bytes)</td>\n</tr>\n<tr>\n<td><strong>Debug Infrastructure</strong></td>\n<td>Simple print functions and invariant checker</td>\n<td>Comprehensive logging, visualization, and property testing</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<p>For a clean C implementation, organize files as follows:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree-project/\n├── include/\n│   └── btree.h          # Public interface declarations\n├── src/\n│   ├── btree.c          # BTree struct functions (create, destroy, public ops)\n│   ├── node.c           # BTreeNode functions (create, destroy, helpers)\n│   ├── search.c         # Search algorithm implementation\n│   ├── insert.c         # Insertion with splitting\n│   ├── delete.c         # Deletion with rebalancing\n│   └── debug.c          # Validation, printing, debugging utilities\n└── tests/\n    ├── test_btree.c     # Comprehensive test suite\n    └── test_utils.c     # Testing utilities</code></pre></div>\n\n<p>This separation follows the single responsibility principle: <code>btree.c</code> manages the tree-level operations, <code>node.c</code> handles node-level manipulations, and operation-specific files contain the algorithmic logic.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>Here&#39;s complete, working code for the foundational data structures and basic utilities. Learners should copy this as their starting point.</p>\n<p><strong>File: <code>include/btree.h</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Forward declaration for opaque pointer pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BTreeNode BTreeNode;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Search result structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> comparisons;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SearchResult;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main B-tree structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> root;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> t;</span><span style=\"color:#6A737D\">  // Minimum degree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> key_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BTree;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Public API</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_destroy</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> btree_size</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_height</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Default minimum degree if not specified</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_MIN_DEGREE</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // BTREE_H</span></span></code></pre></div>\n\n<p><strong>File: <code>src/node.c</code> - Foundation implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// B-tree node structure definition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> BTreeNode {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int*</span><span style=\"color:#E1E4E8\"> keys;</span><span style=\"color:#6A737D\">           // Array of keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> values;</span><span style=\"color:#6A737D\">       // Optional array of values (parallel to keys)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> children;</span><span style=\"color:#6A737D\"> // Array of child pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_keys;</span><span style=\"color:#6A737D\">        // Current number of keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> is_leaf;</span><span style=\"color:#6A737D\">        // Is this a leaf node?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function: Create a new empty node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> node </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(BTreeNode));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate arrays based on B-tree properties</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Maximum keys: 2*t - 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->keys </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">malloc</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Optional: allocate values array if implementing key-value store</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->values </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Or malloc((2*t - 1) * sizeof(void*)) for key-value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For internal nodes, allocate child pointers (2*t capacity)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For leaves, children remain NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node->children </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (BTreeNode</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Initialize all children to NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            node->children[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node->children </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->num_keys </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->is_leaf </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> is_leaf;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> node;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function: Destroy a node and all its descendants recursively</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_destroy</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Recursively destroy all children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> node->num_keys; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (node->children[i]) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                node_destroy</span><span style=\"color:#E1E4E8\">(node->children[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(node->children);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(node->keys);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node->values) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(node->values);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(node);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function: Check if a node is full (has 2*t - 1 keys)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function: Check if a node is underfull (has fewer than t-1 keys)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_underfull</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (t </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>src/btree.c</code> - Tree-level infrastructure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create a new empty B-tree with given minimum degree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (min_degree </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // B-tree requires t >= 2 for proper splitting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        min_degree </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_MIN_DEGREE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> tree </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(BTree));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">tree) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree->root </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree->t </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> min_degree;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree->key_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tree;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Destroy the entire B-tree and free all memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_destroy</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">tree) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree->root) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        node_destroy</span><span style=\"color:#E1E4E8\">(tree->root);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(tree);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get the number of keys in the tree (O(1) version)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> btree_size</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tree </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> tree->key_count </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Simple placeholder implementations - to be completed in milestones</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SearchResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO Milestone 2: Implement search</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)tree; (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)key;</span><span style=\"color:#6A737D\"> // Suppress unused parameter warnings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO Milestone 3: Implement insertion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)tree; (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)key; (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)value;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO Milestone 4: Implement deletion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)tree; (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)key;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_height</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement height calculation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)tree;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement invariant validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)tree;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement tree printing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)tree;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>For the core operations that learners will implement themselves (starting with Milestone 1), here are skeleton functions with detailed TODOs:</p>\n<p><strong>File: <code>src/node.c</code> - Continued (core logic skeletons)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Helper function: Find the index where a key should be in this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Uses binary search for O(log t) performance within a node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - If key is found: index of the key (0 ≤ index &#x3C; num_keys)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - If key is not found: -(insert_position + 1) where insert_position is</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//     where the key would be inserted (0 ≤ insert_position ≤ num_keys)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Also increments *comparisons if pointer is not NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize binary search bounds: left = 0, right = num_keys - 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: While left &#x3C;= right:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   TODO 2a: Calculate mid = left + (right - left) / 2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   TODO 2b: Compare key with node->keys[mid]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   TODO 2c: Increment *comparisons if comparisons pointer is not NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   TODO 2d: If key == node->keys[mid], return mid (found)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   TODO 2e: If key &#x3C; node->keys[mid], search left half (adjust right)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   TODO 2f: If key > node->keys[mid], search right half (adjust left)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If key not found, return -(left + 1) where left is insert position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: This follows standard binary search with careful handling of</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // the \"not found\" case using negative encoding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-c\">Language-Specific Hints for C</h4>\n<ul>\n<li><p><strong>Memory Management:</strong> Always check <code>malloc</code> return values for <code>NULL</code>. In production code, handle allocation failures gracefully. For educational purposes, you might use <code>assert</code> or simply exit with an error message.</p>\n</li>\n<li><p><strong>Array Bounds:</strong> C doesn&#39;t check array bounds. Be meticulous with indices, especially when accessing <code>children[i]</code> where <code>i</code> can be <code>num_keys</code> (valid for the rightmost child).</p>\n</li>\n<li><p><strong>Integer Division:</strong> When calculating the median during splitting (<code>t - 1</code>), remember C integer division truncates. With <code>t=3</code>, <code>(2*t - 1) = 5</code> keys, median index is <code>2</code> (0-based), which equals <code>t - 1</code>.</p>\n</li>\n<li><p><strong>const Correctness:</strong> For search functions that don&#39;t modify nodes, consider using <code>const BTreeNode*</code> to indicate read-only access and prevent accidental modifications.</p>\n</li>\n<li><p><strong>Header Guards:</strong> Always use <code>#ifndef/#define</code> guards in header files to prevent multiple inclusion, as shown in <code>btree.h</code>.</p>\n</li>\n</ul>\n<h4 id=\"milestone-checkpoint-data-structure-validation\">Milestone Checkpoint: Data Structure Validation</h4>\n<p>After implementing the data structures from Milestone 1 (before implementing search/insert/delete), verify your foundation:</p>\n<ol>\n<li><strong>Compilation Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   gcc</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> src/btree.c</span><span style=\"color:#9ECBFF\"> src/node.c</span><span style=\"color:#79B8FF\"> -I./include</span></span></code></pre></div>\n<p>   Should compile without errors or warnings.</p>\n<ol start=\"2\">\n<li><strong>Memory Leak Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // In a simple test program:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   #include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> tree </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Should create tree with t=3, root=NULL, key_count=0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Create a sample node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> node </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Should allocate keys array of size 5, children=NULL, is_leaf=true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Clean up</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       node_destroy</span><span style=\"color:#E1E4E8\">(node);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       btree_destroy</span><span style=\"color:#E1E4E8\">(tree);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n<p>   Run with Valgrind to ensure no memory leaks:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   valgrind</span><span style=\"color:#79B8FF\"> --leak-check=full</span><span style=\"color:#9ECBFF\"> ./test_program</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Invariant Awareness:</strong> Manually verify you understand the capacity rules:<ul>\n<li>For <code>t=3</code>, maximum keys = <code>2*3 - 1 = 5</code>, minimum keys (non-root) = <code>3 - 1 = 2</code></li>\n<li>For <code>t=3</code>, internal nodes have up to <code>2*3 = 6</code> children, at least <code>3</code> children (except root)</li>\n<li>Root can have 1-5 keys (or 0 if tree empty)</li>\n</ul>\n</li>\n</ol>\n<p>If you encounter segmentation faults, likely causes are:</p>\n<ul>\n<li><strong>Accessing <code>children</code> array on a leaf node</strong> → Check <code>is_leaf</code> before accessing <code>children</code></li>\n<li><strong>Array index out of bounds</strong> → Verify <code>num_keys</code> is correctly maintained and used as array bound</li>\n<li><strong>Double-free</strong> → Ensure <code>node_destroy</code> handles <code>NULL</code> children pointers and <code>NULL</code> values array</li>\n</ul>\n<p>With these data structures solidly implemented, you have the foundation for implementing B-tree operations in subsequent milestones.</p>\n<h2 id=\"5-component-design-b-tree-node\">5. Component Design: B-tree Node</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (B-tree Node Structure)</p>\n</blockquote>\n<p>The B-tree node is the fundamental storage unit of the entire data structure—the &quot;atom&quot; from which the entire tree is built. Every operation (search, insert, delete) begins and ends with manipulations of nodes. This component defines how keys and child pointers are organized within a single node, establishes the boundary conditions for node capacity, and differentiates between leaf nodes (which store actual data) and internal nodes (which provide navigation). Getting this foundation right is critical because all subsequent operations build upon these basic building blocks.</p>\n<h3 id=\"mental-model-a-bookshelf-with-dividers\">Mental Model: A Bookshelf with Dividers</h3>\n<p>Imagine a bookshelf in a library that can hold a fixed maximum number of books. This bookshelf has dividers (vertical partitions) that separate sections, and each section contains either:</p>\n<ol>\n<li><strong>Direct references to books</strong> (if this is a leaf shelf)</li>\n<li><strong>References to other shelves</strong> (if this is an index shelf)</li>\n</ol>\n<p><strong>Keys as dividers:</strong> Each divider has a label (the &quot;key&quot;) that indicates the range of books/shelves in the section to its left. For example, a divider labeled &quot;M&quot; means all books/shelves to the left have titles alphabetically before &quot;M&quot;.</p>\n<p><strong>Child pointers as sections:</strong> The spaces between dividers (and the ends) are &quot;slots&quot; that hold either book references (at leaves) or pointers to other shelves (in internal nodes). A node with <code>k</code> keys has exactly <code>k+1</code> child slots.</p>\n<p><strong>Capacity constraints:</strong> Each shelf has a strict capacity: it can hold between <code>t-1</code> and <code>2t-1</code> dividers (except the topmost shelf, which can have as few as 1 divider). When a shelf becomes too full (exceeds <code>2t-1</code> dividers), it must be split. When a shelf becomes too empty (falls below <code>t-1</code> dividers), it must borrow from a neighbor or merge.</p>\n<p><strong>Leaf vs. internal distinction:</strong> Leaf shelves contain actual books (data values). Index shelves contain only dividers and references to other shelves—they never store books directly. The bottommost shelves in the library are always leaves.</p>\n<p>This mental model helps visualize why B-trees are so disk-efficient: each &quot;shelf&quot; corresponds to one disk page (typically 4KB), and we maximize the number of keys per page to minimize the number of disk seeks during navigation. The strict capacity bounds ensure the tree remains balanced, guaranteeing predictable performance.</p>\n<h3 id=\"interface-and-operations\">Interface and Operations</h3>\n<p>The node component provides the following core functions for creating, manipulating, and querying individual B-tree nodes. These functions are used internally by the B-tree operations (search, insert, delete) but are not exposed directly to external callers—they form the private API of the B-tree implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>node_create</code></td>\n<td><code>t</code> (minimum degree, <code>int</code>), <code>is_leaf</code> (<code>bool</code>)</td>\n<td><code>BTreeNode*</code></td>\n<td>Allocates and initializes a new empty node. The node starts with 0 keys, and its child pointers are initialized to <code>NULL</code>. The <code>is_leaf</code> flag determines whether this node will store values directly (leaf) or child pointers (internal).</td>\n</tr>\n<tr>\n<td><code>node_destroy</code></td>\n<td><code>node</code> (<code>BTreeNode*</code>)</td>\n<td><code>void</code></td>\n<td>Recursively deallocates a node and all its descendants. For leaf nodes, this may also free associated values if the B-tree owns them.</td>\n</tr>\n<tr>\n<td><code>node_find_key_index</code></td>\n<td><code>node</code> (<code>BTreeNode*</code>), <code>key</code> (<code>int</code>), <code>comparisons</code> (<code>int*</code>)</td>\n<td><code>int</code></td>\n<td>Performs binary search within the node&#39;s sorted keys array to locate either (1) the exact position of <code>key</code> if present, or (2) the index of the child subtree where <code>key</code> would be located. The <code>comparisons</code> pointer allows counting search operations for performance analysis.</td>\n</tr>\n<tr>\n<td><code>node_is_full</code></td>\n<td><code>node</code> (<code>BTreeNode*</code>), <code>t</code> (<code>int</code>)</td>\n<td><code>bool</code></td>\n<td>Checks whether the node has reached its maximum capacity (<code>2t-1</code> keys). Used during insertion to determine if a split is needed.</td>\n</tr>\n<tr>\n<td><code>node_is_underfull</code></td>\n<td><code>node</code> (<code>BTreeNode*</code>), <code>t</code> (<code>int</code>)</td>\n<td><code>bool</code></td>\n<td>Checks whether the node has fallen below its minimum allowed capacity (<code>t-1</code> keys, except for the root). Used during deletion to trigger rebalancing operations.</td>\n</tr>\n<tr>\n<td><code>node_insert_key</code></td>\n<td><code>node</code> (<code>BTreeNode*</code>), <code>index</code> (<code>int</code>), <code>key</code> (<code>int</code>), <code>value</code> (<code>void*</code>)</td>\n<td><code>void</code></td>\n<td>Inserts a new key (and optional associated value) at position <code>index</code> within the node&#39;s keys array, shifting existing keys and child pointers right as needed. Assumes the node is not full and maintains sorted order.</td>\n</tr>\n<tr>\n<td><code>node_remove_key</code></td>\n<td><code>node</code> (<code>BTreeNode*</code>), <code>index</code> (<code>int</code>)</td>\n<td><code>void</code></td>\n<td>Removes the key at position <code>index</code>, shifting subsequent keys and child pointers left to fill the gap. For leaf nodes, may also free the associated value.</td>\n</tr>\n<tr>\n<td><code>node_split_child</code></td>\n<td><code>parent</code> (<code>BTreeNode*</code>), <code>child_index</code> (<code>int</code>), <code>t</code> (<code>int</code>)</td>\n<td><code>void</code></td>\n<td>Splits a full child node at <code>child_index</code> into two nodes, promoting the median key to the parent. The left child retains the first <code>t-1</code> keys, the right child gets the last <code>t-1</code> keys, and the median (t-th) key moves up to the parent at position <code>child_index</code>.</td>\n</tr>\n<tr>\n<td><code>node_borrow_from_left</code></td>\n<td><code>node</code> (<code>BTreeNode*</code>), <code>parent</code> (<code>BTreeNode*</code>), <code>child_index</code> (<code>int</code>)</td>\n<td><code>void</code></td>\n<td>Borrows a key from the left sibling through the parent to fix an underflow condition. The parent&#39;s key at <code>child_index-1</code> moves down into <code>node</code>, and the left sibling&#39;s last key moves up to replace it. Corresponding child pointers are also transferred.</td>\n</tr>\n<tr>\n<td><code>node_borrow_from_right</code></td>\n<td><code>node</code> (<code>BTreeNode*</code>), <code>parent</code> (<code>BTreeNode*</code>), <code>child_index</code> (<code>int</code>)</td>\n<td><code>void</code></td>\n<td>Borrows a key from the right sibling through the parent. The parent&#39;s key at <code>child_index</code> moves down into <code>node</code>, and the right sibling&#39;s first key moves up to replace it. Corresponding child pointers are transferred.</td>\n</tr>\n<tr>\n<td><code>node_merge_children</code></td>\n<td><code>parent</code> (<code>BTreeNode*</code>), <code>child_index</code> (<code>int</code>), <code>t</code> (<code>int</code>)</td>\n<td><code>void</code></td>\n<td>Merges the child at <code>child_index</code> with its right sibling, using the parent&#39;s key at <code>child_index</code> as an additional key. All keys from both children and the parent key are combined into a single node, and the empty sibling is destroyed.</td>\n</tr>\n</tbody></table>\n<h3 id=\"adr-node-memory-layout\">ADR: Node Memory Layout</h3>\n<blockquote>\n<p><strong>Decision: Separate Arrays for Keys and Children</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to store two types of data in each B-tree node: (1) an array of integer keys, and (2) an array of child pointers (for internal nodes) or value pointers (for leaf nodes). The memory layout must support efficient binary search within keys, straightforward insertion/deletion with shifting, and clear distinction between leaf and internal node behavior.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Separate arrays</strong>: One contiguous array for keys, another contiguous array for child/value pointers.</li>\n<li><strong>Unified array of structs</strong>: An array where each element is a struct containing both a key and a child/value pointer.</li>\n<li><strong>Hybrid with union</strong>: Separate key array, but child/value pointers stored in a union type that can represent either children or values based on leaf status.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use separate arrays for keys and child pointers, with leaf nodes storing values in the child pointer array (reinterpreted as <code>void*</code> values).</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Binary search efficiency</strong>: Searching within a contiguous array of keys (integers) is cache-friendly and allows standard binary search implementation without pointer dereferencing overhead.</li>\n<li><strong>Insertion/deletion simplicity</strong>: When inserting a new key, we shift only the keys array; child pointers shift independently at the same index. This maintains the invariant that child <code>i</code> contains keys less than key <code>i</code>, and child <code>i+1</code> contains keys greater than key <code>i</code>.</li>\n<li><strong>Memory alignment</strong>: Integer keys are typically 4 bytes, while pointers are 8 bytes on 64-bit systems. Keeping them separate avoids padding issues in a unified struct.</li>\n<li><strong>Clear semantics</strong>: The <code>is_leaf</code> flag determines how to interpret the pointer array: as <code>BTreeNode*</code> children for internal nodes, or as <code>void*</code> values for leaf nodes. This avoids the complexity of unions while maintaining type safety through careful casting.</li>\n<li><strong>Educational clarity</strong>: The separate-array approach matches most textbook descriptions and visualizations of B-trees, making the code easier to understand for learners.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Simple, predictable memory access patterns; easy to implement binary search; clear correspondence with theoretical B-tree diagrams.</li>\n<li><strong>Negative</strong>: Requires maintaining two arrays with coordinated indices; leaf nodes waste the child pointer capacity (they allocate space for <code>2t</code> pointers but only use them for values). This waste is acceptable for an in-memory educational implementation.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Separate arrays</strong></td>\n<td>- Efficient binary search on keys<br>- Clear index correspondence between keys and children<br>- Matches textbook descriptions<br>- Simple insertion shifting logic</td>\n<td>- Leaf nodes allocate unused child pointer capacity<br>- Requires coordinated management of two arrays</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td><strong>Unified array of structs</strong></td>\n<td>- Keys and pointers stored together (potentially better locality)<br>- Single array to manage</td>\n<td>- Binary search must access keys through structs (slightly more overhead)<br>- Insertion requires shifting larger structs<br>- Less intuitive mapping to B-tree theory</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Hybrid with union</strong></td>\n<td>- Explicit type differentiation via union tag<br>- No wasted space for leaf nodes (values stored directly)</td>\n<td>- More complex type handling<br>- Requires careful casting and union access<br>- Additional branching based on leaf status</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>The chosen layout directly corresponds to the <code>BTreeNode</code> struct definition from Section 4:</p>\n<ul>\n<li><code>keys</code>: <code>int*</code> – Dynamic array of <code>2t-1</code> integers</li>\n<li><code>children</code>: <code>BTreeNode**</code> – Dynamic array of <code>2t</code> pointers (interpreted as <code>void**</code> for leaf values)</li>\n<li><code>num_keys</code>: <code>int</code> – Current number of keys (0 to <code>2t-1</code>)</li>\n<li><code>is_leaf</code>: <code>bool</code> – Determines interpretation of <code>children</code> array</li>\n</ul>\n<p><img src=\"/api/project/btree-impl/architecture-doc/asset?path=diagrams%2Fdata-model-class.svg\" alt=\"B-tree Data Model\"></p>\n<h3 id=\"common-pitfalls-node-capacity\">Common Pitfalls: Node Capacity</h3>\n<p>B-tree nodes have strict capacity bounds that must be maintained at all times. These invariants are easy to violate accidentally, especially when implementing split and merge operations. Below are the most common mistakes learners make when implementing the node component.</p>\n<p>⚠️ <strong>Pitfall: Off-by-one errors in key counts</strong></p>\n<ul>\n<li><strong>Description</strong>: Incorrectly calculating the maximum (<code>2t-1</code>) or minimum (<code>t-1</code>) key counts, or mishandling the root&#39;s special case (can have as few as 1 key). For example, checking <code>if (node-&gt;num_keys == 2*t)</code> instead of <code>if (node-&gt;num_keys == 2*t - 1)</code> for fullness.</li>\n<li><strong>Why it&#39;s wrong</strong>: Violates B-tree invariants, leading to potential tree corruption. A node with <code>2t</code> keys would overflow its array bounds (which is sized for <code>2t-1</code> keys). A node with <code>t-2</code> keys (when not the root) would be underfull, causing search paths to become imbalanced.</li>\n<li><strong>How to fix</strong>: Define helper functions <code>node_is_full()</code> and <code>node_is_underfull()</code> that encapsulate these calculations. Use these functions consistently throughout the codebase instead of repeating the logic. Remember the root exception: <code>node_is_underfull()</code> should return <code>false</code> for the root regardless of key count.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to initialize child pointers to NULL</strong></p>\n<ul>\n<li><strong>Description</strong>: After allocating the <code>children</code> array (size <code>2t</code>), failing to set all elements to <code>NULL</code>. This is especially critical for leaf nodes, where all child pointers should be <code>NULL</code>, and for internal nodes where unused slots beyond <code>num_keys+1</code> should be <code>NULL</code>.</li>\n<li><strong>Why it&#39;s wrong</strong>: Uninitialized pointers cause undefined behavior when accessed (e.g., during recursive destruction or when checking if a child exists). This often manifests as segmentation faults during tree traversal or memory leaks during cleanup.</li>\n<li><strong>How to fix</strong>: In <code>node_create()</code>, after allocating the <code>children</code> array, loop through all <code>2t</code> slots and explicitly set them to <code>NULL</code>. Similarly, when increasing <code>num_keys</code> (e.g., during insertion), ensure new child pointers are initialized to <code>NULL</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Mis-handling the leaf flag during node splitting</strong></p>\n<ul>\n<li><strong>Description</strong>: When splitting a child node, incorrectly setting the <code>is_leaf</code> flag on the new right sibling. For example, copying the flag from the original child without considering that leaves should remain leaves and internal nodes should remain internal.</li>\n<li><strong>Why it&#39;s wrong</strong>: If an internal node&#39;s child is incorrectly marked as leaf, subsequent insertions will fail to recurse deeper, causing keys to be inserted at the wrong level. If a leaf node&#39;s child is incorrectly marked as internal, attempts to traverse further will fail (since child pointers are <code>NULL</code>).</li>\n<li><strong>How to fix</strong>: When creating the right sibling during a split, explicitly copy the <code>is_leaf</code> flag from the original child being split. Both the left half (original child, now truncated) and right half (new sibling) should have the same leaf status as the original node before splitting.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrect child pointer indexing after key insertion/removal</strong></p>\n<ul>\n<li><strong>Description</strong>: When inserting or removing a key at index <code>i</code>, forgetting to shift child pointers at the same index. The invariant is that child <code>i</code> contains keys less than key <code>i</code>, and child <code>i+1</code> contains keys greater than key <code>i</code>. After inserting a new key at index <code>i</code>, child pointers from <code>i+1</code> onward must shift right by one position.</li>\n<li><strong>Why it&#39;s wrong</strong>: Breaks the parent-child relationship, causing subtrees to become disconnected or assigned to wrong key ranges. This corrupts the tree structure and leads to missing keys during search.</li>\n<li><strong>How to fix</strong>: Implement helper functions <code>node_insert_key()</code> and <code>node_remove_key()</code> that handle both key and child pointer shifting together. Always remember that a node with <code>k</code> keys has <code>k+1</code> child pointers (even for leaves, though they&#39;re unused).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not updating num_keys after mutations</strong></p>\n<ul>\n<li><strong>Description</strong>: Forgetting to increment <code>num_keys</code> after inserting a key or decrement it after removing a key, while still updating the keys array.</li>\n<li><strong>Why it&#39;s wrong</strong>: The <code>num_keys</code> field becomes out of sync with the actual data in the arrays. This causes binary search to examine uninitialized key values and can lead to array bounds violations when accessing children.</li>\n<li><strong>How to fix</strong>: Update <code>num_keys</code> as the last step in any mutation function, after all array shifts are complete. Better yet, encapsulate all mutations in small, well-tested functions that guarantee consistency.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Technology Note</strong>: This implementation uses plain C for direct memory control, which is appropriate for understanding the low-level details of B-tree node layout. The <code>stdlib.h</code> provides dynamic memory allocation, and <code>stdbool.h</code> gives us boolean types.</p>\n</blockquote>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory Allocation</td>\n<td><code>malloc()</code>/<code>free()</code> with explicit NULL checks</td>\n<td>Memory pool allocator for fixed-size node allocations</td>\n</tr>\n<tr>\n<td>Array Management</td>\n<td>Separate <code>keys</code> and <code>children</code> arrays with manual shifting</td>\n<td>Generic array utility functions with <code>memmove()</code></td>\n</tr>\n<tr>\n<td>Debugging</td>\n<td><code>assert()</code> statements for invariants</td>\n<td>Custom invariant checker with detailed error messages</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree-project/\n├── include/\n│   └── btree.h           ← Public interface (BTree, SearchResult, etc.)\n├── src/\n│   ├── btree.c           ← Main B-tree operations (search, insert, delete)\n│   ├── node.c            ← Node-specific functions (this component)\n│   └── btree_utils.c     ← Utility functions (validation, printing)\n└── tests/\n    ├── test_node.c       ← Unit tests for node functions\n    └── test_btree.c      ← Integration tests</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>File: <code>include/btree.h</code></strong> (partial - node-related declarations)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Forward declaration for opaque pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BTreeNode BTreeNode;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// B-tree structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> root;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> t;</span><span style=\"color:#6A737D\">  // Minimum degree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> key_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BTree;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Search result structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> comparisons;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SearchResult;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Public interface functions (declarations only)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_destroy</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> btree_size</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_height</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Node functions (internal, but declared here for testing)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> BTREE_INTERNAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_destroy</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_underfull</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // BTREE_INTERNAL</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // BTREE_H</span></span></code></pre></div>\n\n<p><strong>File: <code>src/node.c</code></strong> (starter infrastructure)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// B-tree node structure definition (hidden from public header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> BTreeNode {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int*</span><span style=\"color:#E1E4E8\"> keys;</span><span style=\"color:#6A737D\">           // Array of keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> values;</span><span style=\"color:#6A737D\">       // For leaves: array of value pointers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> children;</span><span style=\"color:#6A737D\"> // For internal nodes: array of child pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_keys;</span><span style=\"color:#6A737D\">        // Current number of keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> is_leaf;</span><span style=\"color:#6A737D\">        // Leaf or internal node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: We use values for leaves and children for internal nodes,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // but they share the same memory slot in the struct.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We'll manage this through the is_leaf flag.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function to allocate and initialize arrays</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> node_allocate_arrays</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Keys array: maximum (2t-1) keys</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->keys </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node->keys) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to allocate keys array\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(EXIT_FAILURE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Children/values array: maximum 2t children</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We allocate as BTreeNode** but will interpret as void** for leaves</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->children </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (BTreeNode</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> t));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node->children) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(node->keys);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to allocate children array\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(EXIT_FAILURE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize all child pointers to NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> t; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node->children[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate minimum degree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (t </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Minimum degree t must be at least 2</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate node structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> node </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(BTreeNode));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to allocate B-tree node\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->num_keys </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->is_leaf </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> is_leaf;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate arrays</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    node_allocate_arrays</span><span style=\"color:#E1E4E8\">(node, t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> node;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_destroy</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If internal node, recursively destroy children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> node->num_keys; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (node->children[i]) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                node_destroy</span><span style=\"color:#E1E4E8\">(node->children[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // For leaf nodes, we might need to free values if they're owned</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // In this basic implementation, we assume caller manages values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // so we don't free them here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free arrays</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(node->keys);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(node->children);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free node itself</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(node);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>File: <code>src/node.c</code></strong> (continued - core functions with TODOs)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Finds the position of key within a node using binary search</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - If key is found: index of the key (0 &#x3C;= index &#x3C; node->num_keys)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - If key is not found: index of the child where key should be (0 &#x3C;= index &#x3C;= node->num_keys)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> right </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Handle empty node case (num_keys == 0) - return 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Implement binary search loop:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   while (left &#x3C;= right) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     mid = left + (right - left) / 2;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     (*comparisons)++;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     if (node->keys[mid] == key) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         return mid; // Key found at index mid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     } else if (node->keys[mid] &#x3C; key) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         left = mid + 1;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     } else {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         right = mid - 1;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Key not found in this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return the index of the child where the key would be</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This should be the value of 'left' after the loop ends</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if node has reached maximum capacity (2t-1 keys)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remember: node can be NULL (handle gracefully)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_underfull</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if node has fallen below minimum capacity (t-1 keys)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Exception: Root node is allowed to be underfull (return false for root)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: This function doesn't know if it's the root, so the caller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // must handle the root case separately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Inserts a new key into the node at the specified index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Assumes: node is not full, index is valid (0 &#x3C;= index &#x3C;= node->num_keys)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_insert_key</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Shift existing keys from index to num_keys-1 one position right</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use memmove or a for loop</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Shift child pointers from index+1 to num_keys+1 one position right</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Important: A node with k keys has k+1 child pointers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Insert the new key at keys[index]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If leaf node, store value at children[index] (interpreted as void*)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If internal node, the new child pointer should already be NULL (initialized)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Increment num_keys</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Removes the key at the specified index from the node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_remove_key</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Shift existing keys from index+1 to num_keys-1 one position left</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Shift child pointers from index+1 to num_keys one position left</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Decrement num_keys</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For leaf nodes, we might want to clear the last child pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (set children[num_keys] to NULL since we now have one fewer key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Memory Management</strong>: Always check <code>malloc()</code> return values. In production code, you&#39;d handle allocation failures gracefully; for this educational implementation, we exit with an error for simplicity.</p>\n</li>\n<li><p><strong>Type Casting</strong>: When dealing with the <code>children</code> array in leaf nodes (where it stores <code>void*</code> values), you&#39;ll need to cast: <code>(void*)node-&gt;children[i]</code>. Be consistent with these casts to avoid compiler warnings.</p>\n</li>\n<li><p><strong>Array Shifting</strong>: Use <code>memmove()</code> for shifting elements in arrays rather than manual loops—it&#39;s safer and often optimized. Example: <code>memmove(&amp;node-&gt;keys[index+1], &amp;node-&gt;keys[index], (node-&gt;num_keys - index) * sizeof(int))</code>.</p>\n</li>\n<li><p><strong>Debugging</strong>: Compile with <code>-g -DDEBUG</code> flags to include debug symbols and assertions. Use <code>assert(node-&gt;num_keys &gt;= 0 &amp;&amp; node-&gt;num_keys &lt;= 2*t-1)</code> liberally in node functions.</p>\n</li>\n<li><p><strong>Const Correctness</strong>: For read-only functions like <code>node_find_key_index</code>, mark the node parameter as <code>const</code>: <code>int node_find_key_index(const BTreeNode* node, ...)</code>.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the node infrastructure:</p>\n<ol>\n<li><strong>Compile and run unit tests</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   gcc</span><span style=\"color:#79B8FF\"> -std=c11</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -DBTREE_INTERNAL</span><span style=\"color:#79B8FF\"> -I./include</span><span style=\"color:#9ECBFF\"> src/node.c</span><span style=\"color:#9ECBFF\"> tests/test_node.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./test_node</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><p><strong>Expected behavior</strong>:</p>\n<ul>\n<li>All tests should pass (create, destroy, basic insert/remove in node).</li>\n<li>No memory leaks (verify with Valgrind: <code>valgrind --leak-check=full ./test_node</code>).</li>\n<li>The <code>node_find_key_index</code> function should correctly locate keys using binary search.</li>\n</ul>\n</li>\n<li><p><strong>Manual verification</strong>:</p>\n<ul>\n<li>Create a node with <code>t=3</code> (max 5 keys).</li>\n<li>Insert keys [10, 20, 30, 40] in order.</li>\n<li>Verify <code>num_keys</code> updates correctly.</li>\n<li>Search for key 20 should return index 1.</li>\n<li>Search for key 25 should return child index 2 (between 20 and 30).</li>\n</ul>\n</li>\n<li><p><strong>Signs of trouble</strong>:</p>\n<ul>\n<li><strong>Segmentation fault</strong>: Likely uninitialized pointers in <code>children</code> array.</li>\n<li><strong>Incorrect search results</strong>: Binary search bounds are wrong.</li>\n<li><strong>Memory leak</strong>: Forgot to free arrays in <code>node_destroy</code>.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"6-component-design-search-operation\">6. Component Design: Search Operation</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Search)</p>\n</blockquote>\n<p>The search operation is the fundamental read operation in a B-tree and serves as the foundation upon which more complex operations like insertion and deletion are built. Unlike simpler binary search trees where each node contains a single decision point, a B-tree node contains multiple keys, allowing it to make multiple comparisons at each level before deciding which child subtree to explore. This design dramatically reduces the tree&#39;s height and, consequently, the number of disk accesses required to locate a key—the core optimization that makes B-trees suitable for disk-based storage systems.</p>\n<h3 id=\"mental-model-finding-a-topic-in-a-textbook\">Mental Model: Finding a Topic in a Textbook</h3>\n<p>Imagine you&#39;re searching for information about &quot;binary search&quot; in a computer science textbook. The textbook has three levels of organization:</p>\n<ol>\n<li><strong>The index at the back</strong> (the <strong>root node</strong>): This contains high-level topic names with page ranges for each chapter.</li>\n<li><strong>Chapter opening pages</strong> (internal nodes): Each chapter has its own mini-index listing sections within that chapter.</li>\n<li><strong>Individual pages</strong> (leaf nodes): The actual content with detailed explanations.</li>\n</ol>\n<p>Your search process mirrors the B-tree search algorithm:</p>\n<ul>\n<li>You start at the index (root). Using alphabetical order, you quickly determine that &quot;binary search&quot; falls between &quot;binary trees&quot; (page 150-180) and &quot;B-trees&quot; (page 200-250). This tells you to look in Chapter 7 (pages 150-180).</li>\n<li>You turn to Chapter 7&#39;s opening page (an internal node). It lists sections: &quot;7.1 Basic Trees,&quot; &quot;7.2 Binary Search Trees,&quot; &quot;7.3 AVL Trees.&quot; You find that &quot;binary search&quot; belongs in section 7.2.</li>\n<li>You navigate to section 7.2 (a leaf node) and scan the pages until you find the exact discussion of binary search.</li>\n</ul>\n<p>At each step, you&#39;re performing a <strong>binary search within a sorted list</strong> to narrow down your search space, then descending to the next appropriate level. The B-tree&#39;s structure ensures that even with millions of keys, you only need to examine a handful of &quot;index pages&quot; (nodes) to find your target.</p>\n<h3 id=\"search-algorithm-steps\">Search Algorithm Steps</h3>\n<p>The search operation follows a recursive divide-and-conquer strategy that leverages both the sorted order within nodes and the hierarchical tree structure. The algorithm maintains the invariant that all keys in a subtree rooted at a child pointer <code>children[i]</code> are bounded by <code>keys[i-1]</code> and <code>keys[i]</code> (with special handling for the first and last child).</p>\n<p><strong>Search Algorithm (<code>search_recursive</code>):</strong></p>\n<ol>\n<li><p><strong>Initialize search at current node</strong>: Begin with the current node (initially the root) and the target key.</p>\n</li>\n<li><p><strong>Perform binary search within node</strong>: Use binary search on the node&#39;s sorted <code>keys</code> array to find the smallest index <code>i</code> such that <code>key ≤ keys[i]</code>. The binary search returns either:</p>\n<ul>\n<li>The exact index where <code>key == keys[i]</code> (found case)</li>\n<li>The index where <code>key</code> would be inserted (not found, indicates which child to descend into)</li>\n</ul>\n</li>\n<li><p><strong>Check for key match</strong>:</p>\n<ul>\n<li><strong>If found</strong> (<code>key == keys[i]</code>):<ul>\n<li>If this node is a leaf: Return a successful <code>SearchResult</code> with the key&#39;s associated value (if values are stored).</li>\n<li>If this node is internal: The key acts as a separator between child subtrees but can also store a value (in some B-tree variants). For our implementation, we&#39;ll treat all keys as potentially having associated values, so return success with the value at <code>values[i]</code>.</li>\n</ul>\n</li>\n<li><strong>If not found</strong> (<code>key &lt; keys[i]</code> or <code>i == num_keys</code>):<ul>\n<li>If this node is a leaf: The key doesn&#39;t exist in the tree. Return a &quot;not found&quot; <code>SearchResult</code>.</li>\n<li>If this node is internal: Determine the appropriate child subtree to search:<ul>\n<li>If <code>key &lt; keys[0]</code>: Descend into <code>children[0]</code> (all keys in this subtree are less than <code>keys[0]</code>).</li>\n<li>Else: Descend into <code>children[i]</code> (all keys in this subtree are between <code>keys[i-1]</code> and <code>keys[i]</code>).</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Recurse into child</strong>: Call <code>search_recursive</code> on the selected child node with the same target key.</p>\n</li>\n<li><p><strong>Return result</strong>: Propagate the result (found/not found) back up the recursion chain.</p>\n</li>\n</ol>\n<p>The algorithm&#39;s time complexity is <strong>O(logₜ n)</strong> node accesses and <strong>O(log t)</strong> comparisons per node, where <code>t</code> is the minimum degree and <code>n</code> is the total number of keys. Each node access corresponds to a potential disk read in a real system.</p>\n<h3 id=\"adr-recursive-vs-iterative-search\">ADR: Recursive vs. Iterative Search</h3>\n<blockquote>\n<p><strong>Decision: Use Recursive Implementation for Search</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to implement the search operation for an in-memory B-tree for educational purposes. The primary considerations are code clarity for learners versus potential performance optimizations. While real database systems might optimize for stack depth or cache locality, our implementation prioritizes readability and alignment with the recursive nature of tree algorithms.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Pure recursive implementation</strong>: Clear mirroring of the algorithm description, easy to understand recursion flow, but uses call stack space proportional to tree height.</li>\n<li><strong>Iterative implementation with explicit stack</strong>: Avoids recursion overhead, allows better control over memory, but adds complexity with stack management code.</li>\n<li><strong>Tail-recursive iterative implementation</strong>: Uses a while loop to follow child pointers without a stack, but only works for simple search without additional bookkeeping for future operations.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use a pure recursive implementation for the core search operation.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Educational clarity</strong>: The recursive implementation directly corresponds to the algorithm steps described in textbooks and documentation. Learners can trace the recursion to understand tree traversal.</li>\n<li><strong>Consistency with other operations</strong>: Insertion and deletion also use recursive approaches (particularly for proactive splitting during descent), so maintaining a consistent paradigm helps learners.</li>\n<li><strong>Adequate performance</strong>: For an in-memory educational implementation with typical tree heights (≤ 10 for millions of keys), recursion depth is not a practical concern. The O(logₜ n) height means even with <code>t=2</code> (worst-case fanout) and <code>n=1,000,000</code>, height ≤ 20.</li>\n<li><strong>Simpler error handling</strong>: No need to manage an explicit stack data structure, reducing code complexity.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Clean, readable code that clearly expresses the algorithm. Easy to extend for debugging (e.g., adding recursion depth tracking).</li>\n<li><strong>Negative</strong>: Theoretical risk of stack overflow for extremely large trees with small <code>t</code>, though practically improbable for educational use cases. Slight performance overhead of function calls.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Comparison of Search Implementation Approaches:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Recursive</strong></td>\n<td>- Direct algorithm translation<br>- Easy to understand and debug<br>- Consistent with insert/delete operations</td>\n<td>- Uses call stack memory<br>- Theoretical stack overflow risk<br>- Slight function call overhead</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td><strong>Iterative with explicit stack</strong></td>\n<td>- No recursion depth limits<br>- Better control over memory usage<br>- Potentially better performance</td>\n<td>- More complex code<br>- Requires stack management<br>- Less intuitive for learners</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Tail-recursive iterative</strong></td>\n<td>- Minimal memory usage<br>- Simple loop structure<br>- Good performance</td>\n<td>- Only works for pure search<br>- Cannot be extended for insertion/deletion bookkeeping<br>- Requires different paradigm</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-search-logic\">Common Pitfalls: Search Logic</h3>\n<p>Implementing B-tree search seems straightforward but contains subtle traps that can lead to incorrect results, infinite recursion, or crashes.</p>\n<p>⚠️ <strong>Pitfall: Off-by-one errors in binary search bounds</strong></p>\n<ul>\n<li><strong>Description</strong>: Using incorrect indices in the binary search loop, such as searching in range <code>[0, num_keys]</code> instead of <code>[0, num_keys-1]</code>, or incorrectly calculating the midpoint.</li>\n<li><strong>Why it&#39;s wrong</strong>: May fail to find existing keys, return incorrect child indices, or access out-of-bounds memory.</li>\n<li><strong>Fix</strong>: Implement a standard, verified binary search algorithm. Use inclusive lower bound and exclusive upper bound (<code>[low, high)</code>) consistently. Test edge cases: empty node, single key, full node.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to check leaf status before recursing</strong></p>\n<ul>\n<li><strong>Description</strong>: Attempting to access <code>children[i]</code> when <code>is_leaf</code> is true (leaf nodes have null child pointers).</li>\n<li><strong>Why it&#39;s wrong</strong>: Dereferencing a null pointer or uninitialized memory causes segmentation faults.</li>\n<li><strong>Fix</strong>: Always check <code>node-&gt;is_leaf</code> before accessing <code>node-&gt;children</code>. The check should occur after determining the key isn&#39;t in the current node but before attempting to descend.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrect child index selection when key not found</strong></p>\n<ul>\n<li><strong>Description</strong>: When <code>key</code> is not found in a node, choosing the wrong child index (e.g., using <code>i</code> when should use <code>i+1</code> or vice versa).</li>\n<li><strong>Why it&#39;s wrong</strong>: The search descends into the wrong subtree and may miss the key even if it exists in the tree.</li>\n<li><strong>Fix</strong>: Remember the invariant: all keys in subtree <code>children[i]</code> are less than <code>keys[i]</code> (for <code>i &gt; 0</code>) and greater than <code>keys[i-1]</code>. If binary search returns index <code>i</code> where <code>key &lt; keys[i]</code>, descend into <code>children[i]</code>. If <code>key &gt; all keys</code>, descend into <code>children[num_keys]</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not handling duplicate keys (if allowed)</strong></p>\n<ul>\n<li><strong>Description</strong>: The basic algorithm assumes unique keys. If duplicates are allowed, binary search may return any matching index.</li>\n<li><strong>Why it&#39;s wrong</strong>: May return different instances of the same key unpredictably, or fail to find all duplicates.</li>\n<li><strong>Fix</strong>: Define the semantics: return first/last occurrence, or return all values. Modify binary search to find leftmost/rightmost match. For simplicity, our implementation assumes unique keys.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring the return value of recursive calls</strong></p>\n<ul>\n<li><strong>Description</strong>: Calling <code>search_recursive</code> on a child but not returning its result to the caller.</li>\n<li><strong>Why it&#39;s wrong</strong>: The search always returns &quot;not found&quot; from the current node, even if a deeper node found the key.</li>\n<li><strong>Fix</strong>: Always return the result of the recursive call: <code>return search_recursive(child, key);</code>.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Search Algorithm</td>\n<td>Recursive implementation with binary search per node</td>\n<td>Iterative with manual stack for predictable memory usage</td>\n</tr>\n<tr>\n<td>Key Comparison</td>\n<td>Simple integer comparison (<code>key &lt; node-&gt;keys[i]</code>)</td>\n<td>Generic comparator function pointer for any key type</td>\n</tr>\n<tr>\n<td>Result Tracking</td>\n<td>Basic <code>found</code> boolean with value pointer</td>\n<td>Extended <code>SearchResult</code> with metadata (comparison count, node access count)</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>The search operation spans two files in the C implementation:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree/\n├── include/\n│   └── btree.h           ← Public API declarations (btree_search, SearchResult)\n├── src/\n│   ├── btree.c           ← Public API implementation (btree_search wrapper)\n│   ├── node.c            ← Node-level operations (node_find_key_index)\n│   └── search.c          ← Internal recursive search (search_recursive)\n└── tests/\n    └── test_search.c     ← Search-specific unit tests</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete <code>SearchResult</code> struct and public API wrapper (to be placed in <code>btree.h</code> and <code>btree.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* btree.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BTREE_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Search result structure */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found;</span><span style=\"color:#6A737D\">          /* Whether the key was found */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> value;</span><span style=\"color:#6A737D\">         /* Associated value (NULL if not found or no value) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> comparisons;</span><span style=\"color:#6A737D\">     /* Number of key comparisons performed (for analysis) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SearchResult;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* B-tree structure (forward declaration) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BTree BTree;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Public search API */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> /* BTREE_H ```</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* btree.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"node.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* B-tree structure definition */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> BTree {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> root;</span><span style=\"color:#6A737D\">  /* Root node */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> t;</span><span style=\"color:#6A737D\">                   /* Minimum degree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> key_count;</span><span style=\"color:#6A737D\">        /* Total keys in tree */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Public search function */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SearchResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> tree->root </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Start recursive search from root */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> search_recursive</span><span style=\"color:#E1E4E8\">(tree->root, key);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Binary search helper function (<code>node.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"node.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Performs binary search within a node's sorted keys array.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the index where the key is found, or the index where</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * it should be inserted (first position where keys[i] >= key).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Also increments the comparison count for performance tracking.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Handle empty node case - return index 0 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: Initialize binary search bounds: low = 0, high = node->num_keys */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: While low &#x3C; high:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        - Calculate mid = low + (high - low) / 2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        - Increment comparison count if comparisons pointer is not NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        - Compare key with node->keys[mid]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        - If key == node->keys[mid], return mid (exact match)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        - If key &#x3C; node->keys[mid], set high = mid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        - Else set low = mid + 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: Return low (insertion position when key not found) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> /* Placeholder */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Internal recursive search function (<code>search.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"node.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Recursively searches for a key starting from the given node.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns SearchResult indicating whether key was found and its value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">search_recursive</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SearchResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Perform binary search within current node using node_find_key_index */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*   - Pass &#x26;result.comparisons to track comparison count */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*   - Store the returned index in variable 'idx' */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: Check if key was found in current node (idx &#x3C; node->num_keys &#x26;&#x26; node->keys[idx] == key) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*   - If found:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">          - Set result.found = true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">          - Set result.value = node->values[idx] (if values exist, else NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">          - Return result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: Handle not-found case */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*   - If node is a leaf (node->is_leaf == true):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">          - Key doesn't exist in tree, return result (found = false)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: Determine correct child index for recursion */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*   - If key &#x3C; node->keys[0] or node->num_keys == 0: child_idx = 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       - Else: child_idx = idx (from binary search result)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       - Ensure child_idx is within [0, node->num_keys] range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 5: Safety check - verify child pointer is not NULL */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*   - Assert: node->children[child_idx] != NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       - If NULL, return result (found = false) as error fallback</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 6: Recursively search in the appropriate child subtree */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*   - return search_recursive(node->children[child_idx], key);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-for-c\">E. Language-Specific Hints for C</h4>\n<ul>\n<li><strong>Binary Search Implementation</strong>: Use <code>int mid = low + (high - low) / 2;</code> to avoid integer overflow that could occur with <code>(low + high) / 2</code>.</li>\n<li><strong>Comparison Counting</strong>: Increment <code>*comparisons</code> only when the pointer is not NULL to allow optional tracking.</li>\n<li><strong>Child Pointer Validation</strong>: In debug builds, use <code>assert(node-&gt;children[child_idx] != NULL);</code> to catch invariant violations early.</li>\n<li><strong>Recursion Depth</strong>: While recursion depth is limited, you can add a debug-only depth parameter to detect unexpectedly deep recursion.</li>\n<li><strong>Memory Access</strong>: Always validate array bounds before accessing <code>node-&gt;keys[idx]</code> or <code>node-&gt;children[idx]</code>.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the search operation:</p>\n<ol>\n<li><strong>Compile and run the search tests</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   gcc -o test_search src/btree.c src/node.c src/search.c tests/test_search.c -I./include\n   ./test_search</code></pre></div>\n\n<ol start=\"2\">\n<li><p><strong>Expected behavior</strong>:</p>\n<ul>\n<li>Empty tree search returns <code>found = false</code></li>\n<li>Search for existing key returns <code>found = true</code> with correct value</li>\n<li>Search for non-existent key returns <code>found = false</code></li>\n<li>All tests pass without segmentation faults</li>\n</ul>\n</li>\n<li><p><strong>Manual verification</strong>:</p>\n<ul>\n<li>Create a small B-tree manually (insert a few keys)</li>\n<li>Search for each inserted key - should succeed</li>\n<li>Search for keys between inserted values - should fail</li>\n<li>Search for key less than all keys - should fail</li>\n<li>Search for key greater than all keys - should fail</li>\n</ul>\n</li>\n<li><p><strong>Signs of problems</strong>:</p>\n<ul>\n<li><strong>Segmentation fault</strong>: Likely accessing NULL child pointer or out-of-bounds array index.</li>\n<li><strong>Incorrect found status</strong>: Binary search or child index logic is wrong.</li>\n<li><strong>Infinite recursion</strong>: Not checking leaf status or incorrect child selection.</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Search always returns &quot;not found&quot; even for inserted keys</td>\n<td>Binary search returning wrong index or not checking exact match</td>\n<td>Add debug prints in <code>node_find_key_index</code> to trace comparisons</td>\n<td>Verify binary search bounds and equality check</td>\n</tr>\n<tr>\n<td>Segmentation fault when searching deep trees</td>\n<td>Accessing <code>children[i]</code> when <code>is_leaf</code> is true</td>\n<td>Add assert: `assert(!node-&gt;is_leaf</td>\n<td></td>\n</tr>\n<tr>\n<td>Search returns wrong value for found key</td>\n<td>Values array not properly aligned with keys array</td>\n<td>Verify <code>node-&gt;values[idx]</code> corresponds to <code>node-&gt;keys[idx]</code></td>\n<td>Ensure insertion maintains key-value alignment</td>\n</tr>\n<tr>\n<td>Recursion depth exceeds expected height</td>\n<td>Child index calculation wrong, causing cycles</td>\n<td>Print recursion depth and node addresses</td>\n<td>Check child index logic for edge cases</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-component-design-insertion-with-splitting\">7. Component Design: Insertion with Splitting</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Insert with Split)</p>\n</blockquote>\n<p>The insertion operation is where a B-tree demonstrates its self-balancing nature. Unlike binary search trees that grow vertically, B-trees grow horizontally (by filling nodes) and only increase height when absolutely necessary through a controlled root split. This design maintains the <strong>disk-friendly property</strong> of keeping tree height logarithmic while ensuring each node remains densely packed, minimizing disk accesses. The insertion algorithm&#39;s core challenge is maintaining all B-tree invariants—especially the key count bounds and sorted order—while adding new keys.</p>\n<h3 id=\"mental-model-adding-a-book-to-a-full-shelf\">Mental Model: Adding a Book to a Full Shelf</h3>\n<p>Imagine organizing books in a library using a multi-level catalog system. Each catalog drawer (node) can hold a fixed number of index cards (keys). When a drawer becomes completely full, you can&#39;t simply add another card—you must split it:</p>\n<ol>\n<li><strong>Identify the target drawer</strong>: Start at the main catalog (root) and follow the alphabetical dividers to find which drawer should contain the new book&#39;s card.</li>\n<li><strong>Prevent overflow during descent</strong>: Before entering any drawer, if you see it&#39;s completely full, you split it proactively. You take out the middle card, create a new drawer, and place half the cards in each. You then add the middle card to the parent drawer as a new divider, telling you which drawer contains which range.</li>\n<li><strong>Insert the new card</strong>: Once you reach the correct leaf drawer (which now has space because you split full drawers on the way down), you insert the new card in sorted order.</li>\n<li><strong>Handle a full main catalog</strong>: If the very first catalog (root) is full when you start, you split it too. This creates a new top-level catalog with just one divider card pointing to two lower drawers, increasing the total number of catalog levels by one.</li>\n</ol>\n<p>This proactive splitting during descent ensures you never attempt to insert into a full node, simplifying the algorithm. The middle key promotion resembles adding a new divider to a parent drawer, which may cause a cascade of splits upward if parents were also full.</p>\n<h3 id=\"insertion-and-split-algorithm-steps\">Insertion and Split Algorithm Steps</h3>\n<p>The insertion algorithm follows a <strong>recursive, top-down approach</strong> that maintains the invariant that any node we descend into is not full. This is achieved by proactively splitting full nodes before recursing into them. The algorithm consists of two main functions: the public <code>btree_insert</code> wrapper and the internal recursive <code>insert_non_full</code>.</p>\n<h4 id=\"overall-insertion-flow\">Overall Insertion Flow</h4>\n<p><img src=\"/api/project/btree-impl/architecture-doc/asset?path=diagrams%2Finsert-flowchart.svg\" alt=\"Insertion with Splitting Algorithm\"></p>\n<ol>\n<li><p><strong>Public Insertion Interface</strong> (<code>btree_insert</code>):</p>\n<ul>\n<li><strong>Step 1</strong>: Validate inputs (tree pointer, key).</li>\n<li><strong>Step 2</strong>: If the root is full (<code>node_is_full(root, t)</code> returns true), create a new root node that will become the tree&#39;s new root. Split the old root by calling <code>node_split_child</code> on the new root at index 0. This increases tree height by one.</li>\n<li><strong>Step 3</strong>: Call <code>insert_non_full</code> on the (now guaranteed non-full) root to perform the actual insertion.</li>\n</ul>\n</li>\n<li><p><strong>Internal Recursive Insertion</strong> (<code>insert_non_full</code>):</p>\n<ul>\n<li><strong>Step 4</strong>: If the current node is a leaf (<code>node-&gt;is_leaf == true</code>), perform direct insertion:<ul>\n<li>Use <code>node_find_key_index</code> to find the correct position <code>i</code> for the new key.</li>\n<li>Call <code>node_insert_key</code> to insert the key (and associated value) at position <code>i</code>, shifting existing keys right.</li>\n<li>Return success.</li>\n</ul>\n</li>\n<li><strong>Step 5</strong>: If the current node is internal, find the child subtree where the key belongs:<ul>\n<li>Use <code>node_find_key_index</code> to get index <code>i</code> (position where key would be or child index).</li>\n<li><strong>Step 6</strong>: Check if the target child at <code>children[i]</code> is full using <code>node_is_full</code>.</li>\n<li><strong>Step 7</strong>: If full, split this child:<ul>\n<li>Call <code>node_split_child(current_node, i, t)</code> to split child <code>children[i]</code>.</li>\n<li>After splitting, compare the promoted key (now at <code>keys[i]</code>) with the new key to decide which of the two new children to descend into (update <code>i</code> if needed).</li>\n</ul>\n</li>\n<li><strong>Step 8</strong>: Recursively call <code>insert_non_full</code> on the appropriate child (now guaranteed non-full).</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"node-splitting-subroutine-node_split_child\">Node Splitting Subroutine (<code>node_split_child</code>)</h4>\n<p>Splitting a full child is a critical sub-operation that transforms one full node into two half-full nodes and promotes the median key to the parent.</p>\n<p><img src=\"/api/project/btree-impl/architecture-doc/asset?path=diagrams%2Fsplit-visual.svg\" alt=\"Node Split and Median Promotion\"></p>\n<p>Given a parent node <code>P</code> and child index <code>i</code> where <code>child = P-&gt;children[i]</code> is full (has <code>2t-1</code> keys):</p>\n<ol>\n<li><strong>Create a new sibling node</strong> <code>new_child</code> with the same leaf status as the original child.</li>\n<li><strong>Distribute keys</strong>: The original child keeps the first <code>t-1</code> keys (indices <code>0</code> to <code>t-2</code>). The new sibling gets the last <code>t-1</code> keys (indices <code>t</code> to <code>2t-2</code>). The median key at index <code>t-1</code> will be promoted.</li>\n<li><strong>Distribute children</strong> (if internal node): Similarly, the first <code>t</code> children pointers stay with the original child; the remaining <code>t</code> children pointers go to the new sibling.</li>\n<li><strong>Adjust key counts</strong>: Set original child&#39;s <code>num_keys = t-1</code> and new sibling&#39;s <code>num_keys = t-1</code>.</li>\n<li><strong>Promote the median key</strong>:<ul>\n<li>Make space in parent <code>P</code> at index <code>i</code> by shifting parent keys and child pointers right.</li>\n<li>Insert the median key into <code>P-&gt;keys[i]</code>.</li>\n<li>Insert <code>new_child</code> as a new child pointer at <code>P-&gt;children[i+1]</code>.</li>\n<li>Increment parent&#39;s <code>num_keys</code> by one.</li>\n</ul>\n</li>\n</ol>\n<p>This operation ensures both resulting nodes satisfy the minimum occupancy requirement (at least <code>t-1</code> keys) and the parent gains one key while maintaining the invariant that internal nodes have one more child than keys.</p>\n<h3 id=\"adr-proactive-vs-reactive-splitting\">ADR: Proactive vs. Reactive Splitting</h3>\n<blockquote>\n<p><strong>Decision: Proactive Splitting During Descent</strong></p>\n<ul>\n<li><strong>Context</strong>: The B-tree insertion algorithm must handle full nodes to maintain the key count bounds (maximum <code>2t-1</code> keys per node). Two approaches exist: proactively split full nodes during the downward traversal before insertion, or allow temporary overflow and fix it on the way back up (reactive).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Proactive splitting (top-down)</strong>: Split any full node encountered during descent before recursing into it.</li>\n<li><strong>Reactive splitting (bottom-up)</strong>: Allow insertion into full leaves, then split and propagate upward if needed.</li>\n<li><strong>Hybrid approach</strong>: Allow leaves to become temporarily overfull, but split internal nodes proactively.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement proactive splitting during the downward traversal for all nodes (both internal and leaf).</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Simplicity for learners</strong>: Proactive splitting ensures the recursive insertion function (<code>insert_non_full</code>) only ever operates on non-full nodes, reducing the number of cases to handle. The base case (leaf insertion) becomes trivial—just insert into a non-full array.</li>\n<li><strong>Single-pass algorithm</strong>: The algorithm makes only one pass from root to leaf, which is easier to reason about and debug compared to splitting on the way back up with potentially complex upward propagation logic.</li>\n<li><strong>Consistency with textbook implementations</strong>: Most academic references (e.g., CLRS) use the proactive approach, making it easier for learners to cross-reference.</li>\n<li><strong>Predictable memory access</strong>: By splitting during descent, we can allocate new nodes immediately rather than potentially allocating multiple nodes during upward propagation, which might be harder to manage in error conditions.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Slightly less efficient</strong>: Some splits may occur that wouldn&#39;t be strictly necessary if the key ends up in a different subtree (though this is rare).</li>\n<li><strong>Root split requires special handling</strong>: Since the root has no parent, we must check and split it before starting descent, which is a special case in the public <code>btree_insert</code> function.</li>\n<li><strong>Cleaner recursion</strong>: The recursive helper <code>insert_non_full</code> has a simpler precondition (node is not full), making its implementation more straightforward.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Proactive splitting</strong></td>\n<td>Single pass; simpler recursion; consistent with textbooks</td>\n<td>May split nodes unnecessarily in rare cases</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td><strong>Reactive splitting</strong></td>\n<td>Only splits when absolutely needed; can be more efficient</td>\n<td>Two-pass algorithm; more complex recursion with upward propagation</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Hybrid approach</strong></td>\n<td>Balances efficiency and simplicity</td>\n<td>Inconsistent logic between leaves and internal nodes; harder to teach</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-splitting-and-promotion\">Common Pitfalls: Splitting and Promotion</h3>\n<p>Implementing insertion with splitting involves several subtle details that can easily lead to bugs. Below are the most common pitfalls, why they&#39;re problematic, and how to avoid them.</p>\n<h4 id=\"-pitfall-1-splitting-non-full-nodes\">⚠️ <strong>Pitfall 1: Splitting Non-Full Nodes</strong></h4>\n<ul>\n<li><strong>Description</strong>: Calling the split operation on a node that has fewer than <code>2t-1</code> keys, often due to incorrect <code>node_is_full</code> check or off-by-one in the minimum degree <code>t</code>.</li>\n<li><strong>Why it&#39;s wrong</strong>: Splitting a non-full node violates B-tree invariants by creating nodes that may have fewer than <code>t-1</code> keys (underfull). This can cascade and break the tree structure during subsequent operations.</li>\n<li><strong>How to avoid</strong>: Always verify <code>node_is_full(child, t)</code> returns <code>true</code> before splitting. Double-check that <code>node_is_full</code> correctly implements <code>num_keys == 2*t - 1</code>.</li>\n</ul>\n<h4 id=\"-pitfall-2-incorrect-median-index-calculation\">⚠️ <strong>Pitfall 2: Incorrect Median Index Calculation</strong></h4>\n<ul>\n<li><strong>Description</strong>: Using the wrong index for the median key during splitting, such as using <code>t</code> instead of <code>t-1</code> (0-indexed) or miscalculating due to confusion between key counts and child counts.</li>\n<li><strong>Why it&#39;s wrong</strong>: Promoting the wrong key breaks the sorted order invariant. If the median is off by one, the resulting nodes may have incorrect key ranges, causing search failures.</li>\n<li><strong>How to avoid</strong>: Remember that for a node with <code>2t-1</code> keys (indices <code>0</code> to <code>2t-2</code>), the median key is at index <code>t-1</code>. Use concrete examples: for <code>t=3</code>, <code>2t-1=5</code> keys, indices 0-4, median at index 2.</li>\n</ul>\n<h4 id=\"-pitfall-3-forgetting-to-update-child-pointers-after-split\">⚠️ <strong>Pitfall 3: Forgetting to Update Child Pointers After Split</strong></h4>\n<ul>\n<li><strong>Description</strong>: After creating a new sibling node, failing to update the parent&#39;s child pointer array to include the new sibling at the correct position, or incorrectly shifting existing child pointers.</li>\n<li><strong>Why it&#39;s wrong</strong>: The parent will have an incomplete or incorrect list of children, potentially losing references to entire subtrees. This causes memory leaks and broken tree connectivity.</li>\n<li><strong>How to avoid</strong>: When inserting the new sibling into the parent&#39;s child array at index <code>i+1</code>, ensure all child pointers from index <code>i+1</code> onward are shifted right by one position first. Diagram the pointer arrays before and after.</li>\n</ul>\n<h4 id=\"-pitfall-4-mishandling-root-split\">⚠️ <strong>Pitfall 4: Mishandling Root Split</strong></h4>\n<ul>\n<li><strong>Description</strong>: Forgetting to handle the special case where the root is full, or incorrectly implementing the root split (e.g., not updating the tree&#39;s root pointer, not setting the new root&#39;s <code>is_leaf</code> to <code>false</code>).</li>\n<li><strong>Why it&#39;s wrong</strong>: If the root remains full, insertion cannot proceed without violating capacity bounds. If the new root isn&#39;t properly initialized, the tree becomes malformed.</li>\n<li><strong>How to avoid</strong>: In <code>btree_insert</code>, check if the root is full before any descent. If so: (1) create a new root node with <code>is_leaf = false</code>, (2) make the old root its first child, (3) split the old root via <code>node_split_child(new_root, 0, t)</code>, (4) update the tree&#39;s root pointer.</li>\n</ul>\n<h4 id=\"-pitfall-5-ignoring-the-leaf-flag-during-split\">⚠️ <strong>Pitfall 5: Ignoring the Leaf Flag During Split</strong></h4>\n<ul>\n<li><strong>Description</strong>: When creating the new sibling node during a split, copying the original node&#39;s <code>is_leaf</code> flag incorrectly (e.g., always setting to <code>true</code> or <code>false</code>).</li>\n<li><strong>Why it&#39;s wrong</strong>: If an internal node is split but the new sibling is marked as a leaf, its child pointers will be invalid (null for leaves). Conversely, splitting a leaf but marking the new sibling as internal will cause null pointer dereferences when trying to access children.</li>\n<li><strong>How to avoid</strong>: The new sibling must have the same <code>is_leaf</code> status as the node being split. Pass <code>child-&gt;is_leaf</code> to <code>node_create</code> when creating the sibling.</li>\n</ul>\n<h4 id=\"-pitfall-6-not-adjusting-search-index-after-split\">⚠️ <strong>Pitfall 6: Not Adjusting Search Index After Split</strong></h4>\n<ul>\n<li><strong>Description</strong>: After splitting a child during descent, failing to re-evaluate which child to descend into based on the promoted key. The original index <code>i</code> might no longer be correct.</li>\n<li><strong>Why it&#39;s wrong</strong>: The algorithm might descend into the wrong subtree, leading to insertion in an incorrect leaf or failed searches later.</li>\n<li><strong>How to avoid</strong>: After <code>node_split_child(parent, i, t)</code>, compare the new key with the promoted key now at <code>parent-&gt;keys[i]</code>. If the new key is less, descend into <code>parent-&gt;children[i]</code>; if greater, descend into <code>parent-&gt;children[i+1]</code>.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete implementation skeletons and guidance for the C programming language, following the naming conventions and structure outlined earlier.</p>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory Management</td>\n<td>Manual <code>malloc</code>/<code>free</code> with careful ownership tracking</td>\n<td>Reference-counted nodes or arena allocator for batch deallocation</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Return boolean success/failure, print errors to stderr</td>\n<td>Error codes enum with descriptive messages, optional error callback</td>\n</tr>\n<tr>\n<td>Debugging Aids</td>\n<td><code>printf</code> statements at key decision points</td>\n<td>Comprehensive logging macro with levels (DEBUG, INFO, ERROR)</td>\n</tr>\n<tr>\n<td>Validation</td>\n<td>Manual invariant checks in test code</td>\n<td>Built-in <code>btree_validate</code> that traverses entire tree verifying all invariants</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<p>The insertion functionality extends the existing B-tree module structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree/\n├── include/\n│   └── btree.h              ← Public interface declarations\n├── src/\n│   ├── btree.c              ← Public API implementations (btree_insert)\n│   ├── node.c               ← Node operations (node_split_child, node_insert_key)\n│   └── btree_private.h      ← Internal function declarations (insert_non_full)\n└── tests/\n    ├── test_insert.c        ← Insertion-specific tests\n    └── test_operations.c    ← Integrated tests for all operations</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>The following helper functions for node manipulation should be implemented completely as they are prerequisites for the insertion logic but not the core learning goal:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In node.c - Complete implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree_private.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Inserts a key-value pair into a node at the specified index.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Shifts existing keys and values (if any) to the right.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * For internal nodes, children pointers are NOT shifted by this function.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_insert_key</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Shift keys right from index to num_keys-1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> index; i</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node->keys[i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node->keys[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Shift values right if values array exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node->values </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> index; i</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            node->values[i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node->values[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node->values[index] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert new key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->keys[index] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> key;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->num_keys</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a new empty node with the given minimum degree and leaf status.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocates arrays for keys, values (optional), and children (if internal).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> node </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(BTreeNode));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->keys </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->values </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Optional: allocate if storing values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->children </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> is_leaf </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> :</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> t));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->num_keys </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node->is_leaf </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> is_leaf;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node->keys </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">is_leaf </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">node->children)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(node->keys);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(node->children);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(node);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize children to NULL if internal node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> t; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            node->children[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> node;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Checks if a node is full (contains 2t-1 keys).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> node_is_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Binary search within a node's keys to find the position of a key.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the index where the key is found or should be inserted.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Increments comparisons counter if provided.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> comparisons</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> right </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> mid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (left </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> right) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (right </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> left) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (comparisons) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">comparisons)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->keys[mid] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> key) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> mid;</span><span style=\"color:#6A737D\">  // Key found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (node->keys[mid] </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> key) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            left </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            right </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Key not found, return where it should be inserted</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> left;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>The following skeletons show the insertion functions with TODO comments mapping to the algorithm steps described earlier. Learners should implement the missing logic.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In btree_private.h (internal declarations)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> BTREE_PRIVATE_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BTREE_PRIVATE_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Internal recursive insertion helper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> insert_non_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Split child of parent at index i</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_split_child</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> i</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In node.c - Split implementation skeleton</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Splits the i-th child of parent, which must be full.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a new node, moves half of the child's keys and children</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * to the new node, and promotes the median key to the parent.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_split_child</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> i</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get pointer to the full child to be split</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // BTreeNode* full_child = parent->children[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create new sibling node with same leaf status as full_child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // BTreeNode* new_sibling = node_create(t, full_child->is_leaf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Copy the last (t-1) keys from full_child to new_sibling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // for (int j = 0; j &#x3C; t-1; j++) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     new_sibling->keys[j] = full_child->keys[j + t];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // new_sibling->num_keys = t-1;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If full_child is internal (not leaf), copy the last t children pointers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // if (!full_child->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     for (int j = 0; j &#x3C; t; j++) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         new_sibling->children[j] = full_child->children[j + t];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Reduce key count of full_child to t-1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // full_child->num_keys = t-1;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Make space in parent for new key and child pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Shift parent keys from index i to num_keys-1 right by one</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Shift parent children from index i+1 to num_keys right by one</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Insert median key (full_child->keys[t-1]) into parent at index i</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // parent->keys[i] = full_child->keys[t-1];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Insert new_sibling as parent's child at index i+1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // parent->children[i+1] = new_sibling;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Increment parent's key count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // parent->num_keys++;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In btree.c - Public insertion and recursive helper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree_private.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Public </span><span style=\"color:#F97583\">API:</span><span style=\"color:#6A737D\"> Insert a key-value pair into the B-tree.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns true on success, false on failure (e.g., memory allocation error).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">tree </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">tree->root) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tree->root;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Special case - if root is full, split it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // if (node_is_full(root, tree->t)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // Create new root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     BTreeNode* new_root = node_create(tree->t, false);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     if (!new_root) return false;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // Make old root the first child of new root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     new_root->children[0] = root;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // Split the old root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     node_split_child(new_root, 0, tree->t);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // Update tree root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     tree->root = new_root;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // Update root pointer for insertion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     root = new_root;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Now root is not full, call recursive helper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // bool success = insert_non_full(root, key, value, tree->t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update tree->key_count if insertion successful</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // if (success) tree->key_count++;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // return success;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Internal recursive function to insert into a subtree rooted at a non-full node.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Precondition: node is not full (node_is_full(node, t) == false).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> insert_non_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find the index where key belongs or exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // int i = node_find_key_index(node, key, NULL);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle case where key already exists (optional: update value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // if (i &#x3C; node->num_keys &#x26;&#x26; node->keys[i] == key) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     if (node->values) node->values[i] = value;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     return true; // Key updated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If node is a leaf, insert key at position i</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // if (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     node_insert_key(node, i, key, value);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     return true;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Node is internal - prepare to descend</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // BTreeNode* child = node->children[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If child is full, split it first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // if (node_is_full(child, t)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     node_split_child(node, i, t);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // After split, check which child to descend into</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // Compare key with node->keys[i] (the promoted key)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // if (key > node->keys[i]) i++;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // Update child pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     // child = node->children[i];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Recursively insert into the appropriate child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // return insert_non_full(child, key, value, t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-c\">Language-Specific Hints for C</h4>\n<ol>\n<li><strong>Memory Management</strong>: Always check <code>malloc</code> return values. When splitting nodes, ensure all allocated memory is properly freed in the destruction path (<code>node_destroy</code> should recursively free children).</li>\n<li><strong>Array Indexing</strong>: C uses 0-based indexing. The median key in a node with <code>2t-1</code> keys is at index <code>t-1</code> (0-indexed). Be careful with loop boundaries when shifting arrays.</li>\n<li><strong>Pointer Arithmetic</strong>: When shifting elements in arrays, iterate from the end backward to avoid overwriting elements: <code>for (int i = count-1; i &gt;= index; i--)</code>.</li>\n<li><strong>Boolean Values</strong>: Include <code>&lt;stdbool.h&gt;</code> for <code>bool</code>, <code>true</code>, <code>false</code>. The <code>node-&gt;is_leaf</code> flag should be set correctly when creating nodes.</li>\n<li><strong>Debugging</strong>: Use <code>assert</code> from <code>&lt;assert.h&gt;</code> to validate invariants during development (e.g., <code>assert(node-&gt;num_keys &lt;= 2*t-1)</code>).</li>\n</ol>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing insertion with splitting:</p>\n<ol>\n<li><strong>Compilation</strong>: Run <code>gcc -Wall -Wextra -g src/*.c tests/test_insert.c -o test_insert</code> to ensure no warnings.</li>\n<li><strong>Basic Test</strong>: Create a simple test that inserts keys in increasing order and verifies tree structure:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> tree </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       btree_insert</span><span style=\"color:#E1E4E8\">(tree, i, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   btree_print</span><span style=\"color:#E1E4E8\">(tree);</span><span style=\"color:#6A737D\">  // Should show balanced tree with 3-4 levels</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   btree_destroy</span><span style=\"color:#E1E4E8\">(tree);</span></span></code></pre></div>\n<ol start=\"3\">\n<li><strong>Validation</strong>: Run the tree validator after each insertion in debug mode:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">btree_validate</span><span style=\"color:#E1E4E8\">(tree) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ol start=\"4\">\n<li><strong>Expected Behavior</strong>:<ul>\n<li>Inserting 1-10 with <code>t=3</code> should produce a root with 1 key after the 7th insertion (first root split).</li>\n<li>All nodes (except root) should have between <code>t-1</code> and <code>2t-1</code> keys.</li>\n<li>In-order traversal (via search) should find all inserted keys.</li>\n</ul>\n</li>\n<li><strong>Signs of Trouble</strong>:<ul>\n<li><strong>Segmentation fault</strong>: Likely uninitialized child pointers or incorrect array bounds.</li>\n<li><strong>Missing keys</strong>: Search fails for recently inserted keys - check split logic and key promotion.</li>\n<li><strong>Too many nodes</strong>: Each split should create exactly one new node. Count nodes to verify.</li>\n<li><strong>Validation fails</strong>: Implement <code>btree_validate</code> to check invariants and pinpoint issues.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"8-component-design-deletion-with-rebalancing\">8. Component Design: Deletion with Rebalancing</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (Delete with Rebalancing)</p>\n</blockquote>\n<p>Deletion in a B-tree is the most complex operation, requiring careful maintenance of the <strong>capacity bounds</strong> invariants. Unlike binary search trees where deletion simply removes a node, B-trees must ensure every node (except the root) maintains at least <code>t-1</code> keys. When deletion would violate this minimum, the tree performs <strong>borrowing</strong> from a sibling or <strong>merging</strong> nodes to restore balance. This component handles the intricate logic of key removal, underflow detection, and structural rebalancing while preserving all B-tree invariants.</p>\n<h3 id=\"mental-model-removing-a-book-and-consolidating-shelves\">Mental Model: Removing a Book and Consolidating Shelves</h3>\n<p>Imagine a library with bookshelves organized by the B-tree system from our previous analogies. Each shelf (node) must contain between <code>t-1</code> and <code>2t-1</code> books (keys). When you remove a book from a shelf:</p>\n<ol>\n<li><p><strong>Simple removal</strong>: If the shelf still has enough books after removal (<code>≥ t-1</code>), you simply take the book out and shift the remaining books to fill the gap. The library index (parent node&#39;s keys) remains unchanged.</p>\n</li>\n<li><p><strong>Borrowing from a neighbor</strong>: If removing the book would leave the shelf with too few books (<code>&lt; t-1</code>), you first check if a neighboring shelf has extra books to spare. If the left neighbor has more than the minimum, you:</p>\n<ul>\n<li>Take the rightmost book from the left neighbor</li>\n<li>Move the dividing index card from the parent (which sits between these two shelves) down to your shelf</li>\n<li>Move the neighbor&#39;s book up to replace that parent index card</li>\n</ul>\n<p>This rotates a key through the parent, maintaining alphabetical order while fixing the underflow.</p>\n</li>\n<li><p><strong>Merging shelves</strong>: If neither neighbor has extra books, you must merge shelves. You combine your shelf with one neighbor, plus the parent&#39;s dividing index card, creating one shelf with exactly <code>2t-2</code> books (which is valid since <code>2t-2 ≤ 2t-1</code>). This reduces the number of shelves by one and may cause the parent shelf to now have too few index cards, potentially triggering borrowing or merging cascading upward.</p>\n</li>\n<li><p><strong>Empty root shelf</strong>: If merging reaches the root and leaves it with no books (keys), the merged shelf becomes the new root, reducing the tree&#39;s height by one—like removing a now-unnecessary floor from the library&#39;s catalog system.</p>\n</li>\n</ol>\n<p>This process ensures the library remains efficiently navigable: shelves never become too empty (wasting space) or too full (requiring frequent splitting), and the catalog hierarchy adjusts gracefully as books are removed.</p>\n<h3 id=\"deletion-and-rebalance-algorithm-steps\">Deletion and Rebalance Algorithm Steps</h3>\n<p>The deletion algorithm is implemented in <code>delete_from_subtree</code>, a recursive function that descends the tree, handles various deletion cases, and repairs underflows on the way back up. The public interface <code>btree_delete</code> simply calls this helper on the root.</p>\n<h4 id=\"main-deletion-procedure\">Main Deletion Procedure</h4>\n<ol>\n<li><p><strong>Locate the key in the current node</strong>: Use <code>node_find_key_index</code> to perform binary search within the current node&#39;s keys. This returns either the exact index where the key exists or the index of the child subtree where the key would be located.</p>\n</li>\n<li><p><strong>Case 1: Key found in current node (internal node)</strong>:</p>\n<ul>\n<li><strong>Subcase 1A: Current node is a leaf</strong>: If <code>node-&gt;is_leaf</code> is true, simply call <code>node_remove_key</code> at the found index. This removes the key and shifts subsequent keys left.</li>\n<li><strong>Subcase 1B: Current node is internal</strong>: The key serves as a separator between two subtrees. We cannot simply remove it without disrupting the tree structure. Instead:<ol>\n<li><strong>Check left child&#39;s capacity</strong>: If the left child (at child index <code>key_index</code>) has at least <code>t</code> keys, find the <strong>in-order predecessor</strong> (the largest key in the left subtree) by traversing rightmost in that subtree.</li>\n<li><strong>Replace and recurse</strong>: Replace the target key with this predecessor key, then recursively delete that predecessor key from the left child.</li>\n<li><strong>Alternative: right child</strong>: If the left child has only <code>t-1</code> keys but the right child (at child index <code>key_index + 1</code>) has at least <code>t</code> keys, use the <strong>in-order successor</strong> (smallest key in right subtree) instead, found by traversing leftmost in the right subtree.</li>\n<li><strong>Fallback: merge children</strong>: If both adjacent children have the minimum <code>t-1</code> keys, merge them along with the separator key into one node, then recursively delete the key from this merged node.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>Case 2: Key not found in current node</strong>:</p>\n<ul>\n<li><strong>Ensure child can lose a key</strong>: Before descending to child at index <code>child_idx</code>, check if that child has only <code>t-1</code> keys (minimum). If so, we must <strong>strengthen</strong> it by either:<ul>\n<li><strong>Borrowing from left sibling</strong>: If the immediate left sibling exists and has at least <code>t</code> keys, perform a right rotation: move a key from parent down to child, move a key from left sibling up to parent, and adjust child pointers.</li>\n<li><strong>Borrowing from right sibling</strong>: If no left sibling or it&#39;s at minimum, but right sibling exists with at least <code>t</code> keys, perform a left rotation (symmetric to above).</li>\n<li><strong>Merging with sibling</strong>: If neither sibling has extra keys, merge the child with a sibling (preferably left if exists) and the separating key from the parent.</li>\n</ul>\n</li>\n<li><strong>Recurse</strong>: After ensuring the child has at least <code>t</code> keys (or merging made it larger), recursively call <code>delete_from_subtree</code> on the appropriate child.</li>\n</ul>\n</li>\n<li><p><strong>Underflow repair on return</strong>: After the recursive deletion returns, check if the current node has become underfull (less than <code>t-1</code> keys, except if it&#39;s the root). If underfull and not root, this indicates a problem—but our proactive strengthening in step 3 should prevent this. However, some algorithms check and repair here as well for robustness.</p>\n</li>\n<li><p><strong>Root underflow special case</strong>: If after deletion the root has 0 keys but still has a child (meaning the tree height decreased), make that child the new root and free the old root.</p>\n</li>\n</ol>\n<p>The algorithm&#39;s complexity is O(logₜ n) with at most O(logₜ n) node accesses, as each recursive call processes one level and operations within a node take O(t) time.</p>\n<h4 id=\"state-transitions-during-deletion\">State Transitions During Deletion</h4>\n<p>The diagram <img src=\"/api/project/btree-impl/architecture-doc/asset?path=diagrams%2Fdelete-state-machine.svg\" alt=\"Node State During Deletion\"> shows how a node&#39;s state changes during deletion operations. The key insight is that we proactively avoid underflow before descending, making the recursive deletion simpler.</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Valid (≥ t keys)</td>\n<td>Direct key removal (leaf)</td>\n<td>Valid or Underfull</td>\n<td>Remove key, check if still ≥ t-1</td>\n</tr>\n<tr>\n<td>Valid</td>\n<td>Key removed from child (recursive return)</td>\n<td>Valid</td>\n<td>No action needed</td>\n</tr>\n<tr>\n<td>Minimum (t-1 keys)</td>\n<td>Need to descend through this child</td>\n<td>Strengthened to Valid</td>\n<td>Borrow from sibling or merge before descending</td>\n</tr>\n<tr>\n<td>Underfull (&lt; t-1 keys)</td>\n<td>Detected after child deletion (should not occur with proactive approach)</td>\n<td>Valid</td>\n<td>Borrow or merge with sibling via parent</td>\n</tr>\n<tr>\n<td>Root with 1 key, 2 children</td>\n<td>Merging of children</td>\n<td>Root with 0 keys</td>\n<td>Adopt merged child as new root, height decreases</td>\n</tr>\n</tbody></table>\n<h3 id=\"adr-predecessor-vs-successor-for-internal-delete\">ADR: Predecessor vs. Successor for Internal Delete</h3>\n<blockquote>\n<p><strong>Decision: Prefer Predecessor from Left Child for Internal Node Deletion</strong></p>\n<ul>\n<li><strong>Context</strong>: When deleting a key <code>k</code> from an internal node, we cannot simply remove it without leaving a &quot;hole&quot; in the tree structure that separates two subtrees. We must replace <code>k</code> with another key that maintains the ordering invariants, then delete that replacement key from its original location. The replacement must come from either the left subtree (predecessor) or right subtree (successor) of <code>k</code>.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Always use in-order predecessor</strong>: Find the largest key in the left subtree by following rightmost pointers until reaching a leaf.</li>\n<li><strong>Always use in-order successor</strong>: Find the smallest key in the right subtree by following leftmost pointers until reaching a leaf.</li>\n<li><strong>Choose based on child capacities</strong>: Check which adjacent child (left or right) has more than the minimum keys, and use that subtree&#39;s predecessor/successor accordingly.</li>\n<li><strong>Random selection</strong>: Arbitrarily choose predecessor or successor.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Option 3—choose based on child capacities. If left child has ≥ t keys, use predecessor; else if right child has ≥ t keys, use successor; otherwise (both have minimum), proceed to merge.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Minimizes restructuring</strong>: Using a child with extra keys avoids immediate merging/borrowing operations. The replacement key can be removed from that child without causing underflow (since it had ≥ t keys initially).</li>\n<li><strong>Preserves balance</strong>: This approach tends to keep subtree sizes more balanced than always choosing one side.</li>\n<li><strong>Standard textbook approach</strong>: Most B-tree implementations (Cormen et al.) use this capacity-based selection, making our implementation more conventional and easier to verify.</li>\n<li><strong>Simplifies implementation</strong>: The logic integrates naturally with the &quot;strengthening&quot; step—we already check child capacities before descending.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Slightly more complex logic than always using predecessor.</li>\n<li>Requires checking both child nodes&#39; key counts before deciding.</li>\n<li>May lead to more uniform tree degradation over many deletions compared to always favoring one side.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Always predecessor</td>\n<td>Simpler implementation, consistent behavior</td>\n<td>May cause unnecessary merges if left child is at minimum, could lead to left-heavy tree</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Always successor</td>\n<td>Simpler implementation</td>\n<td>May cause unnecessary merges if right child is at minimum, could lead to right-heavy tree</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Capacity-based selection</strong></td>\n<td><strong>Minimizes restructuring, balances tree, standard approach</strong></td>\n<td><strong>Slightly more logic, two checks needed</strong></td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Random selection</td>\n<td>Potentially balanced over many operations</td>\n<td>Unpredictable, harder to debug, non-deterministic</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-borrow-vs-merge-logic\">Common Pitfalls: Borrow vs. Merge Logic</h3>\n<p>⚠️ <strong>Pitfall: Incorrect borrow/merge decision condition</strong></p>\n<ul>\n<li><strong>Description</strong>: Checking whether a sibling has <code>&gt; t-1</code> keys instead of <code>≥ t</code> keys when deciding to borrow. Since the minimum is <code>t-1</code>, a sibling with exactly <code>t-1</code> keys cannot spare one without becoming underfull.</li>\n<li><strong>Why it&#39;s wrong</strong>: Borrowing from a sibling with only <code>t-1</code> keys would leave it with <code>t-2</code> keys, violating the minimum occupancy invariant. This corruption may not be detected immediately but will cause future operations to fail.</li>\n<li><strong>Fix</strong>: Always check <code>sibling-&gt;num_keys ≥ t</code> before borrowing. For merging, check that both the child and chosen sibling have exactly <code>t-1</code> keys.</li>\n</ul>\n<p><img src=\"/api/project/btree-impl/architecture-doc/asset?path=diagrams%2Fborrow-merge-visual.svg\" alt=\"Borrow vs. Merge Operations\"></p>\n<p>⚠️ <strong>Pitfall: Not handling left/right sibling symmetry</strong></p>\n<ul>\n<li><strong>Description</strong>: Implementing borrowing from only the left sibling (or only the right), or treating left and right cases with copy-pasted but not properly mirrored logic.</li>\n<li><strong>Why it&#39;s wrong</strong>: When the left sibling doesn&#39;t exist or can&#39;t lend a key, the right sibling might be able to. Missing this case causes unnecessary merges, increasing tree height prematurely. Incorrect mirroring (e.g., wrong index adjustments) corrupts key ordering.</li>\n<li><strong>Fix</strong>: Implement both left and right borrowing symmetrically. Use helper functions for rotation operations that take direction as a parameter, or carefully test both directions with symmetric test cases.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to update parent after borrowing/merging</strong></p>\n<ul>\n<li><strong>Description</strong>: When borrowing, moving a key between sibling and child but forgetting to update the parent&#39;s separating key. When merging, removing the parent&#39;s separating key but not shifting the parent&#39;s remaining keys and child pointers.</li>\n<li><strong>Why it&#39;s wrong</strong>: The parent&#39;s keys no longer correctly separate the subtrees. Searches may fail to find existing keys or descend the wrong path. The tree&#39;s ordering invariants are broken.</li>\n<li><strong>Fix</strong>: In borrowing, remember that the parent key at index <code>i</code> moves down to the child, and the sibling key moves up to replace it. In merging, after removing the parent key at index <code>i</code>, shift all keys and child pointers from <code>i+1</code> left by one position.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not recursing after borrowing/merging</strong></p>\n<ul>\n<li><strong>Description</strong>: After strengthening a child via borrow or merge, the algorithm proceeds to delete from the original child instead of the potentially changed child (in merge case, the child and sibling become one node).</li>\n<li><strong>Why it&#39;s wrong</strong>: In a merge operation, the child node pointer may become invalid (the child is merged into the sibling). The deletion must continue on the merged node, not the original child.</li>\n<li><strong>Fix</strong>: After merging child at index <code>i</code> with sibling, the merged node resides at the sibling&#39;s index. Update your recursion to target this merged node. Keep careful track of which node pointer to use for the recursive call.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring root shrinkage</strong></p>\n<ul>\n<li><strong>Description</strong>: After deletion, if the root has 0 keys but still has a child, failing to make that child the new root and free the old root.</li>\n<li><strong>Why it&#39;s wrong</strong>: The tree maintains an unnecessary empty root level, wasting memory and adding an extra traversal step for all operations. The height invariant becomes incorrect (height should decrease by 1).</li>\n<li><strong>Fix</strong>: After the top-level <code>delete_from_subtree</code> call returns, check if the root has 0 keys and is not a leaf (has one child). If so, set <code>tree-&gt;root = root-&gt;children[0]</code> and free the old root.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Deletion Algorithm</td>\n<td>Recursive implementation with explicit case handling</td>\n<td>Iterative implementation with manual stack for potential optimization</td>\n</tr>\n<tr>\n<td>Underflow Prevention</td>\n<td>Proactive strengthening before descent (as described)</td>\n<td>Reactive repair after underflow detected on return</td>\n</tr>\n<tr>\n<td>Merge/Borrow Helpers</td>\n<td>Separate functions for left/right cases</td>\n<td>Unified rotation function with direction parameter</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree/\n├── include/\n│   └── btree.h           ← Public interface declarations\n├── src/\n│   ├── btree.c           ← Public API implementations (btree_delete)\n│   ├── node.c            ← Node operations (node_remove_key, etc.)\n│   ├── delete.c          ← Internal deletion algorithms (delete_from_subtree, helpers)\n│   └── validate.c        ← Invariant checking for debugging\n└── tests/\n    ├── test_delete.c     ← Comprehensive deletion tests\n    └── test_invariants.c ← Post-deletion invariant validation</code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* FILE: src/delete.c */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Helper: Get the predecessor key from the left subtree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> get_predecessor</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start from the left child at children[index]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Traverse rightmost pointers until reaching a leaf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return the last (rightmost) key in that leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Helper: Get the successor key from the right subtree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> get_successor</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start from the right child at children[index + 1]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Traverse leftmost pointers until reaching a leaf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return the first (leftmost) key in that leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Helper: Borrow a key from left sibling */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> borrow_from_left</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> child_idx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent->children[child_idx];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> left_sibling </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent->children[child_idx </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Shift all keys in child right by one position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Shift all child pointers in child right by one (if not leaf)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Move parent key at index child_idx-1 down to child's first key position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Move left sibling's last key up to parent at index child_idx-1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If not leaves, move left sibling's last child to be child's first child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update key counts: left_sibling->num_keys--, child->num_keys++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Helper: Borrow a key from right sibling */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> borrow_from_right</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> child_idx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent->children[child_idx];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> right_sibling </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent->children[child_idx </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Move parent key at index child_idx down to child's last key position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Move right sibling's first key up to parent at index child_idx</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Shift all keys in right sibling left by one position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If not leaves, shift all child pointers in right sibling left by one</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If not leaves, move right sibling's first child to be child's last child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update key counts: right_sibling->num_keys--, child->num_keys++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Helper: Merge child at index child_idx with left sibling */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> merge_with_left_sibling</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> child_idx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> left_sibling </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent->children[child_idx </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent->children[child_idx];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Move parent key at index child_idx-1 down to left_sibling's keys at position t-1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Copy all keys from child to left_sibling (starting at position t)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If not leaves, copy all child pointers from child to left_sibling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update left_sibling->num_keys to 2*t-1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove parent key at index child_idx-1 by shifting parent keys left</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Shift parent child pointers left starting from child_idx</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Free child node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: parent->num_keys--</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Helper: Strengthen child at index child_idx (ensure it has at least t keys) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> strengthen_child</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> child_idx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent->children[child_idx];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if left sibling exists and has >= t keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If yes, borrow_from_left and return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if right sibling exists and has >= t keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If yes, borrow_from_right and return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If left sibling exists, merge_with_left_sibling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Else (only right sibling exists), merge child with right sibling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         (Note: need to adjust indices for merging with right sibling)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Main recursive deletion function */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> delete_from_subtree</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(node, key, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Case 1: Key is present in this node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> node->keys[idx] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> key) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Subcase 1A: Leaf node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            node_remove_key</span><span style=\"color:#E1E4E8\">(node, idx);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Subcase 1B: Internal node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Check if left child (children[idx]) has >= t keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: If yes:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Replace key at idx with predecessor from left subtree</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Recursively delete predecessor from left child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Return true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Else check if right child (children[idx+1]) has >= t keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: If yes:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Replace key at idx with successor from right subtree</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Recursively delete successor from right child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Return true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Else (both children have t-1 keys):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Merge left child, key, and right child into left child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Update node's keys and children (remove key at idx, shift)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Recursively delete key from the merged left child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   - Return true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Case 2: Key is not in this node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Key not found in tree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if we're descending to last possible child</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> last_child </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> node->num_keys);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: If the child we're descending to has only t-1 keys:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Call strengthen_child(node, idx, t)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - If we merged with left sibling, idx may need adjustment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Determine which child to descend to after potential merge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Recursively call delete_from_subtree on that child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return the result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Should not reach here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Public deletion API */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">tree </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">tree->root) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> deleted </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> delete_from_subtree</span><span style=\"color:#E1E4E8\">(tree->root, key, tree->t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle root underflow (root with 0 keys but has a child)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree->root->num_keys </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">tree->root->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Save old root pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Set tree->root to the root's only child (children[0])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Free the old root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Decrease tree height (optional tracking)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (deleted) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tree->key_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> deleted;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints (C):</strong></p>\n<ul>\n<li><strong>Memory Management</strong>: After merging nodes, remember to <code>free()</code> the child node that was merged into its sibling. Use <code>node_destroy()</code> if it recursively frees children, but be careful—in a merge, the children are transferred, not destroyed.</li>\n<li><strong>Array Shifting</strong>: Implement careful <code>memmove()</code> operations for shifting keys and child pointers. For example:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">  // Shift keys left from index i</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  memmove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">node</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">keys</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">node</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">keys</span><span style=\"color:#E1E4E8\">[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          (node</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Shift child pointers if internal node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      memmove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">node->children[i], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">node->children[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">              (node->num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> i) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span></code></pre></div>\n<ul>\n<li><strong>Debugging</strong>: Write a helper <code>print_tree(BTreeNode* node, int depth)</code> that indents based on depth to visualize tree structure before/after deletions.</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing deletion, verify correctness with these tests:</p>\n<ol>\n<li><strong>Simple deletions</strong>: Insert 10 keys, delete them one by one, verifying <code>btree_search</code> fails for deleted keys and <code>btree_validate</code> passes after each deletion.</li>\n<li><strong>Borrowing scenarios</strong>: Create a tree where a leaf has minimum keys (<code>t-1</code>) and its sibling has extra keys. Delete from the minimal leaf, ensuring it borrows correctly without merging.</li>\n<li><strong>Merging cascade</strong>: Build a tree where multiple levels are at minimum occupancy. Delete a key that triggers merging up to the root, potentially reducing tree height.</li>\n<li><strong>Random sequence</strong>: Generate random insert/delete sequences, validating invariants after each operation with <code>btree_validate</code>.</li>\n</ol>\n<p>Expected output from <code>btree_validate</code> should always return <code>true</code> for a correct implementation. Use the visualization from <code>btree_print</code> to manually inspect tree structure after complex deletions.</p>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Segmentation fault after delete</td>\n<td>Accessing freed memory or invalid child pointer</td>\n<td>Run with Valgrind, add <code>assert(node-&gt;num_keys &gt;= 0)</code> after deletions</td>\n<td>Ensure borrow/merge updates all pointers correctly; don&#39;t access merged nodes after free</td>\n</tr>\n<tr>\n<td>Search finds deleted keys</td>\n<td>Key not actually removed or duplicate keys</td>\n<td>Print tree after deletion, check all occurrences of the key</td>\n<td>Ensure recursive deletion actually removes the key; handle all cases in <code>delete_from_subtree</code></td>\n</tr>\n<tr>\n<td>Tree height doesn&#39;t decrease when root merges</td>\n<td>Not handling root underflow</td>\n<td>Check root&#39;s key count after deletion; add debug print</td>\n<td>Implement root reduction in <code>btree_delete</code> when root has 0 keys and a child</td>\n</tr>\n<tr>\n<td>&quot;Minimum occupancy violated&quot; in validate</td>\n<td>Borrow/merge logic incorrect</td>\n<td>Run <code>btree_validate</code> after each operation to catch which node violates</td>\n<td>Check borrow threshold (≥ t keys, not &gt; t-1); ensure merge happens when both nodes have t-1 keys</td>\n</tr>\n<tr>\n<td>Infinite recursion</td>\n<td>Child index not adjusted after merge</td>\n<td>Print node and child indices at each recursive call</td>\n<td>When merging with left sibling, the target child index decreases by 1 for subsequent recursion</td>\n</tr>\n</tbody></table>\n<h2 id=\"9-interactions-and-data-flow\">9. Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 2, 3, and 4 (Search, Insert with Split, Delete with Rebalancing)</p>\n</blockquote>\n<p>This section describes how the architectural components defined earlier collaborate to perform the core B-tree operations. While previous sections focused on individual components in isolation, here we examine their dynamic interactions—the function call sequences, data flow patterns, and state transitions that occur during search, insertion, and deletion. Understanding these interactions is crucial for debugging and for grasping how the B-tree maintains its invariants across complex operations.</p>\n<p>At the highest level, the B-tree orchestrator (<code>BTree</code>) serves as the entry point for all operations, while the recursive operation functions (<code>search_recursive</code>, <code>insert_non_full</code>, <code>delete_from_subtree</code>) navigate the tree structure, and the node manipulation functions (<code>node_split_child</code>, <code>borrow_from_left</code>, etc.) perform localized transformations. The interactions follow a consistent pattern: start at the root, traverse downward while potentially transforming nodes, perform the target operation at the leaf or internal node, then propagate changes upward through the recursion stack.</p>\n<h3 id=\"sequence-of-operations\">Sequence of Operations</h3>\n<p>Each core operation follows a specific sequence of function calls that reflects the recursive nature of B-tree algorithms. The sequences below trace through concrete examples to illustrate typical interactions.</p>\n<h4 id=\"search-operation-sequence\">Search Operation Sequence</h4>\n<p>Search demonstrates the simplest interaction pattern—pure traversal without modification. Consider searching for key 42 in a B-tree with minimum degree <code>t = 3</code> and height 3.</p>\n<p>The sequence begins with <code>btree_search(tree, 42)</code>, which immediately calls <code>search_recursive(tree-&gt;root, 42)</code>. The recursive search follows this pattern at each node:</p>\n<ol>\n<li><p><strong>Binary Search Within Node</strong>: At the current node, <code>node_find_key_index</code> performs binary search on the node&#39;s keys array, comparing the target key (42) against each key. This returns either the index where 42 was found or the index of the child subtree where 42 should be located.</p>\n</li>\n<li><p><strong>Key Found vs. Continue Search</strong>: If the key is found in the current node, the recursion terminates and returns a <code>SearchResult</code> with <code>found = true</code> and the associated value. If not found and the current node is a leaf, the recursion terminates with <code>found = false</code>. If not found in an internal node, the function recurses on the appropriate child.</p>\n</li>\n<li><p><strong>Recursive Descent</strong>: Before recursing, the function validates that the child pointer at the computed index is not <code>NULL</code> (for internal nodes). The recursion depth increases by one as control passes to the child node.</p>\n</li>\n</ol>\n<p>The following diagram illustrates this recursive descent through three levels of the tree:</p>\n<p><img src=\"/api/project/btree-impl/architecture-doc/asset?path=diagrams%2Fsearch-sequence.svg\" alt=\"Search Operation Sequence\"></p>\n<p><strong>Concrete Walkthrough Example</strong>: Suppose our B-tree has the following structure (keys shown, <code>t = 3</code>):</p>\n<ul>\n<li>Root: [30, 60] with 3 children</li>\n<li>Child 0 (keys &lt; 30): [10, 20]</li>\n<li>Child 1 (keys between 30-60): [40, 50]</li>\n<li>Child 2 (keys &gt; 60): [70, 80]</li>\n</ul>\n<p>Searching for key 42 proceeds as:</p>\n<ol>\n<li><code>btree_search(tree, 42)</code> → <code>search_recursive(root, 42)</code></li>\n<li>At root node: <code>node_find_key_index</code> compares 42 with [30, 60], determines 42 is between 30 and 60, returns child index 1</li>\n<li>Since key not found at root and root is internal, recurse: <code>search_recursive(root-&gt;children[1], 42)</code></li>\n<li>At child 1 node: <code>node_find_key_index</code> compares 42 with [40, 50], determines 42 &lt; 40, returns child index 0</li>\n<li>Recurse: <code>search_recursive(child1-&gt;children[0], 42)</code></li>\n<li>At leaf node: <code>node_find_key_index</code> finds no match in empty leaf (or in keys [35, 41] if present), returns index 0</li>\n<li>Since leaf and key not found, return <code>SearchResult{found = false, value = NULL, comparisons = total}</code></li>\n</ol>\n<p>The recursion unwinds, propagating the not-found result back to the original caller.</p>\n<h4 id=\"insertion-with-splitting-sequence\">Insertion with Splitting Sequence</h4>\n<p>Insertion involves more complex interactions because it may transform the tree structure. The sequence employs <strong>proactive splitting</strong> during the downward traversal to ensure that when we reach the target leaf, neither it nor any ancestor is full. Consider inserting key 25 into the same B-tree with <code>t = 3</code>, where the root is currently full (has 5 keys).</p>\n<p>The interaction sequence follows:</p>\n<ol>\n<li><p><strong>Public API Entry</strong>: <code>btree_insert(tree, 25, value_ptr)</code> is called. The function first checks if the root is full using <code>node_is_full(root, t)</code>.</p>\n</li>\n<li><p><strong>Root Split (Special Case)</strong>: If the root is full, the tree height must increase:</p>\n<ul>\n<li>Create a new root node using <code>node_create(t, false)</code> (internal node)</li>\n<li>Set the old root as the new root&#39;s first child (index 0)</li>\n<li>Call <code>node_split_child(new_root, 0, t)</code> to split the old root</li>\n<li>Update the tree&#39;s root pointer to the new root</li>\n<li>Call <code>insert_non_full(new_root, 25, value_ptr, t)</code> to continue insertion</li>\n</ul>\n</li>\n<li><p><strong>Proactive Splitting During Descent</strong>: <code>insert_non_full</code> implements the core recursive algorithm:</p>\n<ul>\n<li>At each node, use <code>node_find_key_index</code> to determine the appropriate child index</li>\n<li>Before descending to that child, check if the child is full using <code>node_is_full(child, t)</code></li>\n<li>If full, call <code>node_split_child(current_node, child_index, t)</code> to split the child</li>\n<li>This splitting may change which child index we should descend to (if the promoted median key affects the comparison)</li>\n</ul>\n</li>\n<li><p><strong>Leaf Insertion</strong>: When reaching a leaf node (identified by <code>node-&gt;is_leaf == true</code>), insert the key-value pair directly using <code>node_insert_key</code> at the position determined by <code>node_find_key_index</code>.</p>\n</li>\n<li><p><strong>Recursive Unwind</strong>: As the recursion unwinds, no further action is needed because all splitting occurred proactively on the way down.</p>\n</li>\n</ol>\n<p><strong>Concrete Walkthrough with Root Split</strong>: Starting with a full root [10, 20, 30, 40, 50] (t=3, max keys=5), inserting key 25:</p>\n<ol>\n<li><code>btree_insert</code> finds root full → creates new root <code>new_root</code></li>\n<li><code>node_split_child(new_root, 0, t)</code> splits old root:<ul>\n<li>Left child gets [10, 20], right child gets [40, 50]</li>\n<li>Median key 30 promoted to <code>new_root.keys[0]</code></li>\n<li>Tree height increases from 1 to 2</li>\n</ul>\n</li>\n<li><code>insert_non_full(new_root, 25, value_ptr, t)</code> begins:<ul>\n<li>At <code>new_root</code> (keys=[30]): <code>node_find_key_index</code> finds 25 &lt; 30 → child index 0</li>\n<li>Child 0 (keys=[10,20]) is not full → descend recursively</li>\n</ul>\n</li>\n<li><code>insert_non_full(child0, 25, value_ptr, t)</code>:<ul>\n<li>Child0 is leaf → <code>node_find_key_index</code> finds insertion position between 20 and end</li>\n<li><code>node_insert_key</code> inserts 25, resulting in keys [10, 20, 25]</li>\n</ul>\n</li>\n<li>Final tree: root [30] with children [10,20,25] and [40,50]</li>\n</ol>\n<h4 id=\"deletion-with-rebalancing-sequence\">Deletion with Rebalancing Sequence</h4>\n<p>Deletion has the most complex interaction pattern due to the need to handle underflow through borrowing or merging, which may cascade upward. Consider deleting key 30 from a B-tree where the target node and its siblings are at minimum capacity (<code>t-1</code> keys).</p>\n<p>The deletion sequence involves multiple helper functions and potentially cascading rebalancing:</p>\n<ol>\n<li><p><strong>Public API Entry</strong>: <code>btree_delete(tree, 30)</code> calls <code>delete_from_subtree(root, 30, t)</code>.</p>\n</li>\n<li><p><strong>Traversal to Target Key</strong>: <code>delete_from_subtree</code> recursively navigates to the node containing key 30, but with a crucial difference from insertion: it proactively <strong>strengthens</strong> nodes before descending to ensure we don&#39;t descend into an underfull node (except for the special case of the root).</p>\n</li>\n<li><p><strong>Strengthening Before Descent</strong>: At each node before recursing to a child:</p>\n<ul>\n<li>If the child has exactly <code>t-1</code> keys (minimum), call <code>strengthen_child(parent, child_index, t)</code></li>\n<li><code>strengthen_child</code> attempts to:<ol>\n<li>Borrow from left sibling if it has at least <code>t</code> keys (using <code>borrow_from_left</code>)</li>\n<li>Otherwise, borrow from right sibling if it has at least <code>t</code> keys (using <code>borrow_from_right</code>)</li>\n<li>Otherwise, merge with a sibling (using <code>merge_with_left_sibling</code> or equivalent for right)</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>Key Location and Deletion Type</strong>: Once the key is located in a node:</p>\n<ul>\n<li><strong>Case A: Key in leaf</strong>: Direct removal using <code>node_remove_key</code></li>\n<li><strong>Case B: Key in internal node</strong>: Replace with predecessor (using <code>get_predecessor</code>) or successor, then recursively delete that predecessor/successor from the leaf</li>\n<li>After deletion, check if the node is now underfull (but note: strengthening should prevent this except at root)</li>\n</ul>\n</li>\n<li><p><strong>Root Shrinking</strong>: After deletion completes, check if the root has 0 keys but has a child (height &gt; 1). If so, make that child the new root and free the old root.</p>\n</li>\n<li><p><strong>Cascading Effects</strong>: Borrowing and merging operations modify parent nodes, which may themselves become underfull, potentially causing the underflow condition to propagate upward.</p>\n</li>\n</ol>\n<p><strong>Concrete Walkthrough with Borrowing</strong>: Deleting key 30 from a node with keys [30, 40] (t=3, min=2) that has left sibling [10, 20, 25] and right sibling [50, 60]:</p>\n<ol>\n<li><code>delete_from_subtree</code> locates node containing 30</li>\n<li>Since node has exactly <code>t-1</code> keys (2), parent calls <code>strengthen_child</code> before deletion</li>\n<li><code>strengthen_child</code> checks left sibling (3 keys ≥ t) → chooses <code>borrow_from_left</code></li>\n<li><code>borrow_from_left</code>:<ul>\n<li>Moves largest key from left sibling (25) up to parent</li>\n<li>Moves parent&#39;s separator key (say, 28) down to target node</li>\n<li>Adjusts child pointers if nodes are internal</li>\n<li>Result: target node now has [28, 30, 40] (3 keys)</li>\n</ul>\n</li>\n<li>Now safe to delete 30 from the strengthened node</li>\n<li>After deletion: target node has [28, 40] (2 keys, still ≥ t-1)</li>\n</ol>\n<p><strong>Concrete Walkthrough with Merging</strong>: Same scenario but left sibling has only 2 keys (minimum):</p>\n<ol>\n<li><code>strengthen_child</code> cannot borrow from left (only 2 keys)</li>\n<li>Check right sibling: also has only 2 keys</li>\n<li>Choose to merge with left sibling using <code>merge_with_left_sibling</code></li>\n<li>Merge operation:<ul>\n<li>Bring down parent&#39;s separator key (28) into left sibling</li>\n<li>Move all keys from target node to left sibling</li>\n<li>Adjust child pointers</li>\n<li>Free the now-empty target node</li>\n<li>Parent loses one key and one child pointer</li>\n</ul>\n</li>\n<li>Parent may now be underfull, requiring recursive strengthening upward</li>\n</ol>\n<h3 id=\"state-transitions-during-operations\">State Transitions During Operations</h3>\n<p>Each B-tree node transitions through different states defined by its key count relative to the capacity bounds. The table below captures how the four fundamental operations—direct insertion, direct deletion, borrowing, and merging—affect a node&#39;s key count, along with the conditions that trigger each transition.</p>\n<p>The state machine for a node during deletion operations is visualized in the following diagram:</p>\n<p><img src=\"/api/project/btree-impl/architecture-doc/asset?path=diagrams%2Fdelete-state-machine.svg\" alt=\"Node State During Deletion\"></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Action Taken</th>\n<th>Conditions &amp; Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Valid</strong> (t-1 to 2t-1 keys)</td>\n<td><strong>Insert key</strong> (no split)</td>\n<td><strong>Valid</strong> or <strong>Overfull</strong></td>\n<td><code>node_insert_key</code> adds key at sorted position</td>\n<td>If node had 2t-2 keys before insert → becomes Overfull (2t-1 keys). Overfull state is temporary and immediately triggers a split if detected during insertion descent.</td>\n</tr>\n<tr>\n<td><strong>Overfull</strong> (2t-1 keys)</td>\n<td><strong>Split operation</strong></td>\n<td>Two <strong>Valid</strong> nodes</td>\n<td><code>node_split_child</code> creates two nodes with t-1 keys each, promotes median to parent</td>\n<td>Parent gains one key. This is the only way a node becomes Overfull—when a child is split and the parent receives the promoted key while already having 2t-2 keys.</td>\n</tr>\n<tr>\n<td><strong>Valid</strong></td>\n<td><strong>Delete key</strong> (direct removal)</td>\n<td><strong>Valid</strong> or <strong>Underfull</strong></td>\n<td><code>node_remove_key</code> removes key, shifts remaining keys left</td>\n<td>If node had exactly t-1 keys before deletion → becomes Underfull (&lt; t-1 keys). This should not happen in correctly implemented deletion due to proactive strengthening.</td>\n</tr>\n<tr>\n<td><strong>Underfull</strong> (&lt; t-1 keys)</td>\n<td><strong>Borrow from left sibling</strong></td>\n<td><strong>Valid</strong></td>\n<td><code>borrow_from_left</code> takes largest key from left sibling via parent rotation</td>\n<td>Left sibling must have ≥ t keys. Parent loses no keys (one moves down, another moves up). Right sibling borrowing is symmetric.</td>\n</tr>\n<tr>\n<td><strong>Underfull</strong></td>\n<td><strong>Borrow from right sibling</strong></td>\n<td><strong>Valid</strong></td>\n<td><code>borrow_from_right</code> takes smallest key from right sibling via parent rotation</td>\n<td>Right sibling must have ≥ t keys. Parent loses no keys (one moves down, another moves up).</td>\n</tr>\n<tr>\n<td><strong>Underfull</strong></td>\n<td><strong>Merge with left sibling</strong></td>\n<td><strong>Valid</strong> (merged node)</td>\n<td><code>merge_with_left_sibling</code> combines underfull node, left sibling, and parent separator</td>\n<td>Both siblings have exactly t-1 keys. New merged node has 2t-2 keys (valid). Parent loses one key and one child pointer.</td>\n</tr>\n<tr>\n<td><strong>Underfull</strong> (root)</td>\n<td><strong>Root shrinking</strong></td>\n<td><strong>Valid</strong> (new root) or <strong>Empty</strong></td>\n<td>Root with 0 keys and 1 child becomes that child; old root freed</td>\n<td>Only occurs when tree height decreases. New root may be Underfull if it has &lt; t-1 keys but root has relaxed minimum.</td>\n</tr>\n</tbody></table>\n<p><strong>Key Transition Insights</strong>:</p>\n<blockquote>\n<p>The most critical insight is that <strong>nodes only become underfull during direct key removal</strong>, and this should only happen at the leaf where the key is physically deleted or at internal nodes where a predecessor/successor is deleted. All other nodes are proactively strengthened before descent, ensuring that recursion never enters an underfull node (except the special case of the root).</p>\n</blockquote>\n<p><strong>State Transition Example Walkthrough</strong>: Consider a node with exactly <code>t-1</code> keys (the minimum for a non-root node):</p>\n<ul>\n<li>If we attempt to delete a key from this node, it would become underfull (violating the invariant).</li>\n<li>Therefore, before descending to delete from this node, its parent calls <code>strengthen_child</code>, which will either:<ol>\n<li><strong>Borrow</strong> from a sibling with ≥ t keys → node becomes valid (t keys)</li>\n<li><strong>Merge</strong> with a sibling that also has t-1 keys → both combine into one valid node (2t-2 keys)</li>\n</ol>\n</li>\n<li>After strengthening, the node has ≥ t keys, so deletion can proceed safely without causing underflow.</li>\n</ul>\n<p>The parent node itself may become underfull after lending a key during borrowing or after losing a key during merging. This is why deletion may require recursive strengthening that propagates upward toward the root.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Technology Note</strong>: This implementation guidance focuses on the C programming language, which provides direct memory control essential for understanding B-tree&#39;s disk-oriented design. The guidance bridges the conceptual sequences described above with concrete function implementations.</p>\n</blockquote>\n<h4 id=\"a-recommended-sequence-implementation-patterns\">A. Recommended Sequence Implementation Patterns</h4>\n<p>For each operation, follow these calling patterns in your implementation:</p>\n<p><strong>Search Pattern</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Public API: simply call the recursive helper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> search_recursive</span><span style=\"color:#E1E4E8\">(tree->root, key);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">search_recursive</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Base case: empty tree (root is NULL)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SearchResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find position within current node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> comparisons </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> node_find_key_index</span><span style=\"color:#E1E4E8\">(node, key, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">comparisons);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> node->keys[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> key) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Key found in this node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SearchResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, node->values[i], comparisons};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Key not found and we're at a leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SearchResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, comparisons};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Recurse to appropriate child</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> search_recursive</span><span style=\"color:#E1E4E8\">(node->children[i], key);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Insert Pattern</strong> (simplified structure showing call sequence):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle root split first if needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">node_is_full</span><span style=\"color:#E1E4E8\">(tree->root, tree->t)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> new_root </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(tree->t, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_root->children[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tree->root;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        node_split_child</span><span style=\"color:#E1E4E8\">(new_root, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, tree->t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tree->root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_root;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Now insert into non-full tree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> insert_non_full</span><span style=\"color:#E1E4E8\">(tree->root, key, value, tree->t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> insert_non_full</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Insert directly into leaf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Find insertion position and insert</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Find child to descend to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Find child index i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Proactive split if child is full</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">node_is_full</span><span style=\"color:#E1E4E8\">(node->children[i], t)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            node_split_child</span><span style=\"color:#E1E4E8\">(node, i, t);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // After split, need to re-check which child to descend to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // because the promoted key might affect the comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Update i if needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Recurse to child</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> insert_non_full</span><span style=\"color:#E1E4E8\">(node->children[i], key, value, t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Delete Pattern</strong> (showing strengthening logic):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> delete_from_subtree</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is a simplified version - actual implementation handles all cases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find key position</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> node->keys[idx]) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        idx</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Case 1: Key found in this node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> node->keys[idx] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> key) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Case 1A: Leaf node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            node_remove_key</span><span style=\"color:#E1E4E8\">(node, idx);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Case 1B: Internal node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Replace with predecessor/successor and recurse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Case 2: Key not in this node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Key not found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Ensure child has at least t keys before descending</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">node_is_underfull</span><span style=\"color:#E1E4E8\">(node->children[idx], t)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            strengthen_child</span><span style=\"color:#E1E4E8\">(node, idx, t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Recurse to child</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> delete_from_subtree</span><span style=\"color:#E1E4E8\">(node->children[idx], key, t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"b-interaction-debugging-helpers\">B. Interaction Debugging Helpers</h4>\n<p>To visualize the interactions during development, add these debugging helpers to trace function calls:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Enable with compile flag -DDEBUG_INTERACTIONS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> DEBUG_INTERACTIONS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACE_ENTER</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">func</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[TRACE] ENTER </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: node=</span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\">, key=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, is_leaf=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, num_keys=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           func, (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)node, key, node </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> node->is_leaf </span><span style=\"color:#F97583\">:</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, node </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">:</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACE_EXIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">func</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">result</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[TRACE] EXIT  </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: result=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, func, result)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACE_SPLIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">child_idx</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[TRACE] SPLIT: parent=</span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\">, child_idx=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)parent, child_idx)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACE_BORROW</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">child_idx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">direction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[TRACE] BORROW: parent=</span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\">, child_idx=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, from=</span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)parent, child_idx, direction)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACE_ENTER</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">func</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACE_EXIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">func</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">result</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACE_SPLIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">child_idx</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACE_BORROW</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">parent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">child_idx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">direction</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<p>Use these in your functions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">search_recursive</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TRACE_ENTER</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"search_recursive\"</span><span style=\"color:#E1E4E8\">, node, key);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... implementation ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TRACE_EXIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"search_recursive\"</span><span style=\"color:#E1E4E8\">, result.found);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"c-common-interaction-bugs-and-fixes\">C. Common Interaction Bugs and Fixes</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Infinite recursion during insertion</strong></td>\n<td>Forgetting to update child index after splitting in <code>insert_non_full</code></td>\n<td>Add trace logging before and after split; check if i needs adjustment when promoted key &gt; insertion key</td>\n<td>After <code>node_split_child</code>, compare key with promoted key; if key &gt; promoted key, increment child index</td>\n</tr>\n<tr>\n<td><strong>Key disappears after deletion</strong></td>\n<td>Merging operation incorrectly handles child pointers</td>\n<td>Use <code>btree_print</code> after each merge; verify all keys from both siblings and parent separator are present</td>\n<td>In <code>merge_with_left_sibling</code>, ensure: 1) Copy parent separator, 2) Copy all keys from right node, 3) Copy all child pointers if internal</td>\n</tr>\n<tr>\n<td><strong>Segmentation fault during search</strong></td>\n<td>Child pointer is NULL when node claims it&#39;s internal</td>\n<td>Add assertion: `assert(node-&gt;is_leaf</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>Tree height grows unnecessarily</strong></td>\n<td>Splitting root when it&#39;s not full</td>\n<td>Check <code>node_is_full</code> condition at root; might be off-by-one error</td>\n<td>Verify <code>node_is_full</code> returns true only when <code>node-&gt;num_keys == 2*t - 1</code></td>\n</tr>\n<tr>\n<td><strong>Borrowing makes sibling underfull</strong></td>\n<td>Not checking sibling has ≥ t keys before borrowing</td>\n<td>Add precondition check in borrow functions</td>\n<td>In <code>strengthen_child</code>, check sibling key count before attempting borrow</td>\n</tr>\n</tbody></table>\n<h4 id=\"d-testing-interactions\">D. Testing Interactions</h4>\n<p>Create interaction tests that verify the function call sequences:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_interactions.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_insertion_sequence</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> tree </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert until root splits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        btree_insert</span><span style=\"color:#E1E4E8\">(tree, i, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // At this point, root should have 1 key (median of 1..5 = 3)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tree->root->num_keys </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tree->root->keys[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert more to cause child splits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        btree_insert</span><span style=\"color:#E1E4E8\">(tree, i, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify structure through search</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SearchResult r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_search</span><span style=\"color:#E1E4E8\">(tree, i);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(r.found);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    btree_destroy</span><span style=\"color:#E1E4E8\">(tree);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_deletion_cascade</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> tree </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build a specific tree structure that will cascade on deletion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert keys in order that creates minimum-occupancy nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> keys</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">60</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">70</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">90</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        btree_insert</span><span style=\"color:#E1E4E8\">(tree, </span><span style=\"color:#FFAB70\">keys</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Delete a key that will trigger merge cascade</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> deleted </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(tree, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(deleted);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify tree still valid</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">btree_validate</span><span style=\"color:#E1E4E8\">(tree));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    btree_destroy</span><span style=\"color:#E1E4E8\">(tree);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Run these tests frequently during development to ensure the component interactions remain correct as you implement each operation.</p>\n<h2 id=\"10-error-handling-and-edge-cases\">10. Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 1-4 (all operations)</p>\n</blockquote>\n<p>A robust B-tree implementation must handle edge cases gracefully and provide mechanisms for detecting invariant violations. Since this is an educational implementation focused on algorithmic correctness rather than production resilience, we adopt a pragmatic approach: fail loudly on unrecoverable errors (like memory exhaustion) while maintaining data structure invariants for all valid operations. This section catalogs the failure modes specific to B-tree operations and provides strategies for both runtime handling and development-time verification.</p>\n<h3 id=\"101-failure-modes-and-edge-cases\">10.1 Failure Modes and Edge Cases</h3>\n<p>B-tree operations involve complex pointer manipulation, dynamic memory allocation, and intricate balancing logic. Understanding potential failure points is crucial for building a correct implementation. The table below enumerates common failure scenarios, their detection methods, and recommended handling strategies for this in-memory implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Strategy</th>\n<th>Recovery Approach</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Memory allocation failure</strong> (malloc returns NULL)</td>\n<td>Check return value of all allocation calls (<code>malloc</code>, <code>calloc</code>, <code>realloc</code>)</td>\n<td>Propagate failure upward by returning error indicator (NULL/false); clean up any partially allocated resources</td>\n<td>Memory exhaustion is unrecoverable for this in-memory implementation; failing gracefully prevents undefined behavior from null pointer dereferences</td>\n</tr>\n<tr>\n<td><strong>Duplicate key insertion</strong></td>\n<td>Search operation during insertion path; binary search within each node</td>\n<td>Treat as no-op (do nothing) or optionally update value if storing key-value pairs; return <code>false</code> to indicate no new key was added</td>\n<td>B-trees typically support unique keys; silently ignoring duplicates maintains set semantics and simplifies deletion logic</td>\n</tr>\n<tr>\n<td><strong>Deletion of non-existent key</strong></td>\n<td>Search during deletion path fails to find key</td>\n<td>Return <code>false</code> to indicate key was not present; tree remains unchanged</td>\n<td>Idempotent operation: deleting a missing key should not alter the tree structure or cause errors</td>\n</tr>\n<tr>\n<td><strong>Invalid minimum degree (t &lt; 2)</strong></td>\n<td>Validate parameter in <code>btree_create()</code></td>\n<td>Return NULL or use <code>DEFAULT_MIN_DEGREE</code> (3)</td>\n<td>B-tree definition requires t ≥ 2 to ensure nodes can split (2t-1 ≥ 3 when t=2); lower values violate core invariants</td>\n</tr>\n<tr>\n<td><strong>Negative key values</strong> (if domain restricted)</td>\n<td>Validate input in public API functions</td>\n<td>Return error or ignore (implementation choice)</td>\n<td>While B-trees can handle any comparable keys, some use cases may restrict domains; validation prevents logical errors</td>\n</tr>\n<tr>\n<td><strong>Node underflow during deletion</strong></td>\n<td><code>node_is_underfull()</code> check after key removal</td>\n<td>Trigger borrowing or merging via <code>strengthen_child()</code> before recursion</td>\n<td>Proactive rebalancing maintains the t-1 minimum key invariant for all non-root nodes</td>\n</tr>\n<tr>\n<td><strong>Node overflow during insertion</strong></td>\n<td><code>node_is_full()</code> check before insertion</td>\n<td>Trigger splitting via <code>node_split_child()</code> during descent</td>\n<td>Proactive splitting ensures we never insert into a full node, maintaining the 2t-1 maximum invariant</td>\n</tr>\n<tr>\n<td><strong>Invalid child index in split/borrow/merge</strong></td>\n<td>Range checks (0 ≤ i &lt; parent-&gt;num_keys+1)</td>\n<td>Assert during development; graceful failure with error return in production</td>\n<td>These are internal functions; indices should always be valid if calling code maintains invariants</td>\n</tr>\n<tr>\n<td><strong>Corrupted node pointers</strong> (dangling/recycled)</td>\n<td>Cannot detect at runtime without memory tagging</td>\n<td>Use <code>btree_validate()</code> during testing; employ Valgrind for memory error detection</td>\n<td>Pointer corruption indicates serious bugs in memory management; prevention via careful ownership discipline is essential</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> For educational implementations, <strong>failing fast with clear diagnostics</strong> is preferable to complex recovery mechanisms. Use assertions (<code>assert()</code>) liberally during development to catch invariant violations immediately, then replace with graceful error returns if building for production use.</p>\n</blockquote>\n<p>Beyond these failure modes, several edge case scenarios require special consideration in the algorithm logic:</p>\n<p><strong>Root Node Special Cases:</strong></p>\n<ol>\n<li><strong>Empty Tree Deletion:</strong> Attempting to delete from an empty tree (root is NULL or root-&gt;num_keys == 0) should return <code>false</code> without error.</li>\n<li><strong>Root Underflow:</strong> The root is exempt from the minimum key requirement (can have as few as 1 key when not a leaf). However, if the root becomes empty after deletion (0 keys), its single child should become the new root, decreasing tree height.</li>\n<li><strong>Root Split:</strong> Splitting a full root is the only operation that increases tree height. The old root becomes a child of the new root.</li>\n</ol>\n<p><strong>Leaf Node Boundary Conditions:</strong></p>\n<ol>\n<li><strong>First/Last Key Deletion:</strong> When removing the smallest or largest key from a leaf, binary search indices must be handled correctly to avoid off-by-one errors when shifting arrays.</li>\n<li><strong>Leaf with Minimum Keys:</strong> A leaf with exactly t-1 keys that loses a key becomes underfull and requires rebalancing, even though this violates the invariant only after the operation completes.</li>\n</ol>\n<p><strong>Internal Node Edge Cases:</strong></p>\n<ol>\n<li><strong>Predecessor/Successor Selection:</strong> When deleting a key from an internal node, if the chosen subtree (predecessor&#39;s left or successor&#39;s right) has exactly t-1 keys, the <code>strengthen_child()</code> function must be called before recursion to ensure we don&#39;t descend into an underfull node.</li>\n<li><strong>Leftmost/Rightmost Child:</strong> When borrowing or merging with the leftmost or rightmost child of a parent, only one sibling exists, requiring asymmetric handling.</li>\n</ol>\n<p><strong>Algorithm-Specific Edge Cases:</strong></p>\n<p><strong>For Insertion:</strong></p>\n<ul>\n<li>Inserting into a tree where all nodes along the path are full requires splitting at every level from root to leaf.</li>\n<li>Inserting a key that would become the new minimum or maximum of the entire tree must maintain sorted order across all nodes.</li>\n</ul>\n<p><strong>For Deletion:</strong></p>\n<ul>\n<li>The &quot;borrow or merge&quot; decision when a node becomes underfull: always attempt to borrow from an immediate sibling with &gt; t-1 keys; only merge if both siblings have exactly t-1 keys.</li>\n<li>When merging reduces the parent&#39;s key count, the parent may become underfull, requiring recursive rebalancing upward.</li>\n<li>Deleting the only key in a root that is a leaf results in an empty tree.</li>\n</ul>\n<p><strong>For Search:</strong></p>\n<ul>\n<li>Searching in an empty tree should return a <code>SearchResult</code> with <code>found = false</code> and <code>comparisons = 0</code>.</li>\n<li>Searching for a key smaller than all keys or larger than all keys should traverse to the leftmost or rightmost leaf respectively.</li>\n</ul>\n<p><strong>Memory Management Edge Cases:</strong></p>\n<ol>\n<li><strong>Destroying an Empty Tree:</strong> <code>btree_destroy(NULL)</code> or <code>btree_destroy()</code> on an empty but allocated tree should be safe (no-op).</li>\n<li><strong>Node Child Pointer Cleanup:</strong> When merging nodes, the right node&#39;s children array must be copied before the node is freed to prevent memory leaks.</li>\n<li><strong>Array Shifting Operations:</strong> <code>node_insert_key()</code> and <code>node_remove_key()</code> must correctly handle the trailing elements when inserting at or removing from the beginning, middle, or end of the arrays.</li>\n</ol>\n<blockquote>\n<p><strong>Mental Model: The Building Inspector Analogy</strong>\nThink of error handling as a building inspector visiting a B-tree &quot;building.&quot; The inspector checks foundational invariants (minimum/maximum keys, sorted order, pointer consistency) much like checking a building&#39;s structural integrity. Some issues are critical (memory corruption = foundation cracks) requiring immediate shutdown, while others are maintenance items (underfull nodes = slightly uneven floors) that can be fixed on the spot with borrowing or merging tools. The <code>btree_validate()</code> function is the inspector&#39;s comprehensive checklist.</p>\n</blockquote>\n<h3 id=\"102-invariant-verification-for-debugging\">10.2 Invariant Verification for Debugging</h3>\n<p>Implementing a B-tree involves complex pointer manipulations and subtle boundary conditions that can easily introduce bugs. A comprehensive <strong>invariant verification function</strong> (<code>btree_validate()</code>) is an indispensable debugging tool that programmatically checks all B-tree rules, providing immediate feedback when an operation corrupts the data structure. This function should be called after each insert/delete during development and before returning from any public API in test builds.</p>\n<p><strong>Core Invariants to Verify:</strong></p>\n<ol>\n<li><p><strong>Structural Invariants:</strong></p>\n<ul>\n<li><strong>Root Invariant:</strong> The root has between 1 and 2t-1 keys (unless the tree is empty, where root may be NULL or have 0 keys).</li>\n<li><strong>Node Capacity Invariant:</strong> Every non-root node has between t-1 and 2t-1 keys.</li>\n<li><strong>Leaf Child Invariant:</strong> All leaf node child pointers are NULL.</li>\n<li><strong>Internal Node Child Invariant:</strong> Every internal node has exactly <code>num_keys + 1</code> non-NULL child pointers.</li>\n<li><strong>Tree Height Invariant:</strong> All leaf nodes are at the same depth (same distance from root).</li>\n</ul>\n</li>\n<li><p><strong>Ordering Invariants:</strong></p>\n<ul>\n<li><strong>Intra-node Ordering:</strong> Keys within each node are stored in strictly ascending order (no duplicates).</li>\n<li><strong>Inter-node Ordering:</strong> For any internal node with key <code>K_i</code> and children <code>C_i</code> and <code>C_{i+1}</code>:<ul>\n<li>All keys in subtree <code>C_i</code> are less than <code>K_i</code></li>\n<li>All keys in subtree <code>C_{i+1}</code> are greater than <code>K_i</code></li>\n</ul>\n</li>\n<li><strong>Global Ordering:</strong> An in-order traversal of the tree yields keys in strictly ascending order.</li>\n</ul>\n</li>\n<li><p><strong>Pointer Integrity Invariants:</strong></p>\n<ul>\n<li><strong>No Cycles:</strong> The tree is a directed acyclic graph (no node is its own ancestor).</li>\n<li><strong>Parent Consistency:</strong> If parent pointers were implemented (not required in our design), each child would reference its correct parent.</li>\n<li><strong>Memory Bounds:</strong> All array accesses are within allocated bounds (<code>0 ≤ index &lt; num_keys</code> for keys, <code>0 ≤ index ≤ num_keys</code> for children).</li>\n</ul>\n</li>\n</ol>\n<p><strong>Implementation Strategy for <code>btree_validate()</code>:</strong></p>\n<p>The validation function performs a recursive depth-first traversal, checking both local node properties and global relationships. It returns <code>true</code> if all invariants hold, <code>false</code> otherwise, and can optionally print detailed error messages to stderr.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Pseudo-code for validation logic (not actual implementation code)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> validate_node</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_root</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   int*</span><span style=\"color:#FFAB70\"> min_key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> max_key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> depth</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> leaf_depth</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check 1: Node pointer validity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> is_root;</span><span style=\"color:#6A737D\"> // NULL only allowed for empty tree root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check 2: Key count bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (is_root) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check 3: Key ordering within node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(node->keys[i] </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->keys[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span><span style=\"color:#6A737D\"> // Strictly ascending</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check 4: Child pointer consistency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(all children are </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Record leaf depth for height uniformity check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">leaf_depth </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">leaf_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> depth;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#B392F0\"> assert</span><span style=\"color:#E1E4E8\">(depth </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">leaf_depth);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(node->num_keys </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#E1E4E8\"> number of non</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\"> children);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Recursively validate children with key range checks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> node->num_keys; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> child_min, child_max;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            bool</span><span style=\"color:#E1E4E8\"> child_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> validate_node</span><span style=\"color:#E1E4E8\">(node->children[i], t, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                            &#x26;</span><span style=\"color:#E1E4E8\">child_min, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">child_max, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                            depth </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, leaf_depth);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            assert</span><span style=\"color:#E1E4E8\">(child_valid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Check subtree key bounds relative to parent keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(child_max </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->keys[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys) </span><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(child_min </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> node->keys[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update min/max keys for parent checks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">min_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> node->keys[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> INT_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">max_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> node->keys[node->num_keys</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> INT_MIN;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Common Validation Failures and Their Likely Causes:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Failure</th>\n<th>Likely Bug Location</th>\n<th>Debugging Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Key count out of bounds</td>\n<td>Insertion: forgot to split full nodes<br>Deletion: incorrect borrow/merge logic</td>\n<td>Add debug prints before/after each operation; check <code>node_is_full()</code>/<code>node_is_underfull()</code> logic</td>\n</tr>\n<tr>\n<td>Keys not sorted within node</td>\n<td><code>node_insert_key()</code> or <code>node_remove_key()</code> with incorrect shift logic</td>\n<td>Test array insertion/removal in isolation; verify binary search returns correct index</td>\n</tr>\n<tr>\n<td>Leaf node has non-NULL children</td>\n<td><code>node_create()</code> initialization error or corruption during split</td>\n<td>Ensure <code>is_leaf</code> flag set correctly; check <code>node_split_child()</code> child pointer allocation</td>\n</tr>\n<tr>\n<td>Internal node has wrong child count</td>\n<td>Split/merge operations miscount children</td>\n<td>Verify that when promoting median key, we also adjust child pointer counts</td>\n</tr>\n<tr>\n<td>Leaf depths unequal</td>\n<td>Insertion: root split height increase incorrect<br>Deletion: root shrinkage incorrect</td>\n<td>Trace height changes; ensure all insertions start at same root level</td>\n</tr>\n<tr>\n<td>Subtree key range violation</td>\n<td>Binary search returns wrong child index; incorrect predecessor/successor selection</td>\n<td>Add subtree range assertions in search path; verify in-order traversal</td>\n</tr>\n<tr>\n<td>Memory access violation</td>\n<td>Array index out of bounds in <code>keys[]</code> or <code>children[]</code></td>\n<td>Use <code>assert(index &gt;= 0 &amp;&amp; index &lt; capacity)</code> before each array access</td>\n</tr>\n</tbody></table>\n<p><strong>Integration with Testing:</strong></p>\n<p>The <code>btree_validate()</code> function should be integrated into the test harness:</p>\n<ol>\n<li><strong>After every operation</strong> in unit tests, call <code>btree_validate()</code> and assert it returns true.</li>\n<li><strong>In stress tests</strong> (thousands of random insertions/deletions), periodically validate the tree.</li>\n<li><strong>As a debugging aid</strong>, when a test fails, call <code>btree_print()</code> followed by <code>btree_validate()</code> with verbose error output to identify the first violated invariant.</li>\n</ol>\n<blockquote>\n<p><strong>ADR: Comprehensive Validation vs. Performance</strong></p>\n<p><strong>Context:</strong> During development, we need to detect invariant violations immediately, but runtime validation has performance costs.</p>\n<p><strong>Options Considered:</strong></p>\n<ol>\n<li><strong>Full validation after every public API call</strong> (enabled only in debug builds via <code>#ifdef DEBUG</code>)</li>\n<li><strong>No built-in validation</strong> (rely entirely on external test suite)</li>\n<li><strong>Selective validation</strong> (check only the specific invariants relevant to the operation)</li>\n</ol>\n<p><strong>Decision:</strong> Implement full validation gated by <code>#ifdef DEBUG</code> with optional verbose output.</p>\n<p><strong>Rationale:</strong> B-tree bugs can manifest far from their source (e.g., a split error might only cause problems many operations later). Immediate detection with stack trace is invaluable for learning. The compile-time switch eliminates performance impact in release builds.</p>\n<p><strong>Consequences:</strong> Developers must remember to test with debug builds; validation code must itself be bug-free.</p>\n</blockquote>\n<p><strong>Debugging Workflow:</strong></p>\n<p>When a test fails or invariant violation is detected:</p>\n<ol>\n<li><strong>Isolate the failing operation</strong> using a minimal reproducible test case.</li>\n<li><strong>Add verbose logging</strong> to trace the operation&#39;s execution path.</li>\n<li><strong>Call <code>btree_print()</code></strong> to visualize the tree structure before and after the failing operation.</li>\n<li><strong>Use <code>btree_validate()</code> with error messages</strong> to identify the first violated invariant.</li>\n<li><strong>Check the corresponding operation&#39;s logic</strong> against the algorithm steps in Sections 6-8.</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight:</strong> The combination of <code>btree_print()</code> (visualization) and <code>btree_validate()</code> (invariant checking) forms a powerful debugging suite that can catch ~90% of B-tree implementation bugs without needing a debugger.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Detection</td>\n<td>Return <code>false</code>/<code>NULL</code> with error messages to <code>stderr</code></td>\n<td>Error codes enum with descriptive strings</td>\n</tr>\n<tr>\n<td>Invariant Checking</td>\n<td><code>assert()</code> macro from <code>&lt;assert.h&gt;</code></td>\n<td>Custom validation with detailed error logging</td>\n</tr>\n<tr>\n<td>Memory Debugging</td>\n<td>Valgrind for leak detection</td>\n<td>AddressSanitizer (<code>-fsanitize=address</code>)</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree/\n├── include/\n│   └── btree.h           # Public API declarations\n├── src/\n│   ├── btree.c           # Main implementation\n│   ├── btree_validate.c  # Invariant checking (debug only)\n│   └── btree_debug.c     # Printing utilities\n└── tests/\n    ├── test_btree.c      # Unit tests\n    └── stress_test.c     # Randomized operations</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete Validation Function):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// btree_validate.c - Complete implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;limits.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> DEBUG_VALIDATE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper for recursive validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> _validate_node</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_root</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          int*</span><span style=\"color:#FFAB70\"> min_key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> max_key</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          int</span><span style=\"color:#FFAB70\"> depth</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> leaf_depth</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> error_count</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check node exists (NULL only allowed for empty root)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (is_root) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Non-root node is NULL</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check key count bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (is_root) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Root has </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> keys, allowed [0, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    node->num_keys, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Non-root node has </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> keys, allowed [</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    node->num_keys, t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check key ordering within node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->keys[i] </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> node->keys[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Keys not sorted at index </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> >= </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    i, node->keys[i], node->keys[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle leaf nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // All child pointers must be NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (node->children[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Leaf node has non-NULL child at index </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Record leaf depth</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">leaf_depth </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">leaf_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> depth;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (depth </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">leaf_depth) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Leaf depth mismatch: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> vs </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    depth, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">leaf_depth);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Set min/max for this leaf</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">min_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> node->keys[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> INT_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">max_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> node->keys[node->num_keys</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> INT_MIN;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Internal node validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> ></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Internal node has too many children: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                node->num_keys </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Recursively validate children with key range checks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> all_children_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> node->num_keys; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->children[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Internal node has NULL child at index </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            all_children_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> child_min, child_max;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> child_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _validate_node</span><span style=\"color:#E1E4E8\">(node->children[i], t, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                         &#x26;</span><span style=\"color:#E1E4E8\">child_min, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">child_max,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                         depth </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, leaf_depth, error_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">child_valid) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            all_children_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check child's keys against parent's keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (child_max </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> node->keys[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Child </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> max key </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> >= parent key </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        i, child_max, node->keys[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                all_children_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (child_min </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> node->keys[i]) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Child </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> min key </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> &#x3C;= parent key </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        i, child_min, node->keys[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">error_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                all_children_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set min/max for this internal node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">min_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> node->keys[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> INT_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">max_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> node->keys[node->num_keys</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> INT_MIN;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> all_children_valid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Public validation function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Tree is NULL</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tree->t </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Minimum degree t=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> &#x3C; 2</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, tree->t);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> error_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> leaf_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> dummy_min, dummy_max;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _validate_node</span><span style=\"color:#E1E4E8\">(tree->root, tree->t, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               &#x26;</span><span style=\"color:#E1E4E8\">dummy_min, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dummy_max,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                               0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">leaf_depth, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">error_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (error_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Validation failed with </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> error(s)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, error_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> valid </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (error_count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Stub for non-debug builds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)tree;</span><span style=\"color:#6A737D\">  // Unused parameter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Always passes in release builds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // DEBUG_VALIDATE</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton for Error Handling:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// btree.c - Error handling in public API functions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate min_degree parameter (must be ≥ 2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allocate memory for BTree structure using malloc</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if malloc returned NULL (memory allocation failure)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize fields: root = NULL, t = min_degree, key_count = 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return the created BTree* or NULL on failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate tree parameter (not NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check for duplicate key using btree_search()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If root is NULL (empty tree), create new root node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check if root is full, if so:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   a) Create new root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   b) Split old root as child of new root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   c) Update tree->root pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Call insert_non_full on the (possibly new) root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Increment tree->key_count if insertion succeeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return true on success, false on failure (duplicate or memory error)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate tree parameter (not NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if tree is empty (root == NULL or root->num_keys == 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call delete_from_subtree on root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If root becomes empty after deletion:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   a) If root is leaf, set root = NULL (tree becomes empty)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   b) If root is internal, set root = root->children[0] (decrease height)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Decrement tree->key_count if deletion succeeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return true if key was found and deleted, false otherwise</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Example of memory allocation with error checking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_leaf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Calculate array sizes based on t (max keys = 2t-1, max children = 2t)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allocate memory for node structure using malloc</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for allocation failure, return NULL if failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Allocate keys array (size 2*t-1 * sizeof(int))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check for allocation failure, free node and return NULL if failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Allocate children array (size 2*t * sizeof(BTreeNode*))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Check for allocation failure, free keys and node, return NULL if failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Initialize all child pointers to NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Set num_keys = 0, is_leaf flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Return the allocated node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints for C:</strong></p>\n<ol>\n<li><strong>Memory Allocation Errors:</strong> Always check <code>malloc</code>/<code>calloc</code>/<code>realloc</code> return values. Use <code>perror(&quot;malloc&quot;)</code> to print system error messages.</li>\n<li><strong>Cleanup on Failure:</strong> Implement a rollback pattern: if allocation fails mid-way through node creation, free previously allocated components in reverse order.</li>\n<li><strong>Debug Builds:</strong> Compile with <code>-DDEBUG_VALIDATE</code> to enable validation, <code>-g</code> for debug symbols, and <code>-fsanitize=address</code> for memory error detection.</li>\n<li><strong>Assertions:</strong> Use <code>assert()</code> liberally during development but note they&#39;re removed in release builds (<code>-DNDEBUG</code>).</li>\n</ol>\n<p><strong>Debugging Tips Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Segmentation fault after insert</td>\n<td>Accessing child pointer beyond allocated array</td>\n<td>Run with Valgrind; add array bounds checks before each access</td>\n<td>Ensure <code>children</code> array size is 2*t, indices are 0 ≤ i ≤ num_keys</td>\n</tr>\n<tr>\n<td>Tree height grows unexpectedly</td>\n<td>Root split not increasing height properly</td>\n<td>Print tree before/after each root split; check new root creation</td>\n<td>When splitting root, create new root with old root as first child</td>\n</tr>\n<tr>\n<td>Keys disappear after deletion</td>\n<td>Incorrect merge operation losing keys</td>\n<td>Use <code>btree_print()</code> after each deletion step; validate after each operation</td>\n<td>Ensure all keys from both nodes and parent separator are preserved in merge</td>\n</tr>\n<tr>\n<td>Infinite recursion during search</td>\n<td>Child pointer points to ancestor (cycle)</td>\n<td>Add cycle detection in validation; limit recursion depth</td>\n<td>Check <code>node_split_child()</code> doesn&#39;t create circular references</td>\n</tr>\n<tr>\n<td>Memory leak after many operations</td>\n<td>Not freeing nodes during merge or tree destruction</td>\n<td>Use Valgrind; track allocations/frees</td>\n<td>Ensure <code>node_destroy()</code> recursively frees all children; call in <code>btree_destroy()</code></td>\n</tr>\n<tr>\n<td>Wrong search results</td>\n<td>Keys not sorted within nodes</td>\n<td>Validate intra-node ordering; check <code>node_insert_key()</code> shift logic</td>\n<td>Binary search requires sorted keys; verify insertion maintains order</td>\n</tr>\n<tr>\n<td>&quot;Borrow from sibling&quot; fails</td>\n<td>Not checking sibling has sufficient keys</td>\n<td>Print sibling key count before attempting borrow</td>\n<td>Only borrow if sibling has &gt; t-1 keys; otherwise merge</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone Checkpoint for Error Handling:</strong></p>\n<p>After implementing error handling and validation:</p>\n<ol>\n<li><strong>Run the test suite with validation enabled:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   gcc</span><span style=\"color:#79B8FF\"> -DDEBUG_VALIDATE</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#9ECBFF\"> src/btree.c</span><span style=\"color:#9ECBFF\"> src/btree_validate.c</span><span style=\"color:#9ECBFF\"> tests/test_btree.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_btree</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./test_btree</span></span></code></pre></div>\n<p>   Expected: All tests pass with no validation errors printed.</p>\n<ol start=\"2\">\n<li><p><strong>Test edge cases manually:</strong></p>\n<ul>\n<li>Create tree with t=1 (should fail or use default)</li>\n<li>Insert duplicate keys (should return false, tree unchanged)</li>\n<li>Delete non-existent key (should return false, tree unchanged)</li>\n<li>Insert until root splits multiple times (check height increases)</li>\n<li>Delete until root shrinks (check height decreases)</li>\n</ul>\n</li>\n<li><p><strong>Run memory checker:</strong></p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   valgrind</span><span style=\"color:#79B8FF\"> --leak-check=full</span><span style=\"color:#9ECBFF\"> ./test_btree</span></span></code></pre></div>\n<p>   Expected: &quot;All heap blocks were freed -- no leaks are possible&quot;</p>\n<ol start=\"4\">\n<li><strong>Stress test with validation:</strong>\nCreate a test that performs 10,000 random insertions/deletions, calling <code>btree_validate()</code> every 100 operations. The validation should never fail if implementation is correct.</li>\n</ol>\n<h2 id=\"11-testing-strategy\">11. Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 1-4 (all operations)</p>\n</blockquote>\n<p>A comprehensive testing strategy is crucial for implementing a complex, self-balancing data structure like a B-tree. Unlike simpler structures where bugs might cause obvious crashes, B-tree bugs can be subtle—causing silent corruption of invariants that only manifests later during specific sequences of operations. This section outlines a systematic testing approach combining unit tests, property-based tests, and milestone-specific checkpoints to build confidence incrementally.</p>\n<h3 id=\"testing-approach-and-scenarios\">Testing Approach and Scenarios</h3>\n<p>Think of testing a B-tree like <strong>testing a self-organizing library</strong>. You need to verify not only that books can be found when requested (basic search), but also that the library&#39;s internal reorganization rules—splitting shelves when full, merging shelves when too empty, and updating the catalog index—work correctly under all scenarios. The testing strategy progresses from simple unit tests (verifying individual shelves work) to property-based tests (verifying the entire library stays organized after random activity) to edge case tests (verifying extreme scenarios like emptying and refilling the library).</p>\n<p>The testing pyramid for our B-tree implementation has three layers:</p>\n<ol>\n<li><strong>Unit Tests</strong>: Test individual components (<code>BTreeNode</code> functions) in isolation.</li>\n<li><strong>Integration/Operation Tests</strong>: Test the public API (<code>btree_insert</code>, <code>btree_delete</code>, <code>btree_search</code>) and their interactions.</li>\n<li><strong>Property-Based &amp; Stress Tests</strong>: Verify that the B-tree invariants hold after thousands of random operations.</li>\n</ol>\n<h4 id=\"unit-testing-strategy\">Unit Testing Strategy</h4>\n<p>Unit tests focus on the smallest testable components: the node-level helper functions. These functions form the building blocks of the main algorithms, and their correctness is essential.</p>\n<table>\n<thead>\n<tr>\n<th>Component to Test</th>\n<th>Test Scenarios</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>node_create</code></td>\n<td>Create leaf and internal nodes with different <code>t</code> values</td>\n<td>Node memory allocated, <code>num_keys</code> = 0, <code>is_leaf</code> set correctly, arrays allocated with correct capacities</td>\n<td>Check struct field values, verify no memory leaks</td>\n</tr>\n<tr>\n<td><code>node_destroy</code></td>\n<td>Destroy a single node, destroy a subtree</td>\n<td>All memory freed, no dangling pointers</td>\n<td>Use Valgrind or address sanitizer to confirm clean deallocation</td>\n</tr>\n<tr>\n<td><code>node_find_key_index</code></td>\n<td>Binary search on empty node, node with keys, key less than all, key greater than all, key between keys, exact match</td>\n<td>Returns correct index (0 for empty, correct position for non-existent, exact index for match)</td>\n<td>Compare returned index against manual calculation, track comparison count</td>\n</tr>\n<tr>\n<td><code>node_is_full</code> / <code>node_is_underfull</code></td>\n<td>Nodes with <code>t-1</code>, <code>t</code>, <code>2t-1</code>, <code>2t</code> keys (for full), and <code>t-2</code>, <code>t-1</code>, <code>t</code> keys (for underfull)</td>\n<td>Returns true/false according to B-tree capacity rules</td>\n<td>Verify against mathematical definition: full = <code>num_keys == 2*t-1</code>, underfull = <code>num_keys &lt; t-1</code></td>\n</tr>\n<tr>\n<td><code>node_insert_key</code></td>\n<td>Insert at beginning, middle, end of key array</td>\n<td>Key inserted at correct position, existing keys shifted right, <code>num_keys</code> incremented</td>\n<td>Verify array contents and count</td>\n</tr>\n<tr>\n<td><code>node_remove_key</code></td>\n<td>Remove from beginning, middle, end</td>\n<td>Key removed, remaining keys shifted left, <code>num_keys</code> decremented</td>\n<td>Verify array contents and count</td>\n</tr>\n<tr>\n<td><code>node_split_child</code></td>\n<td>Split leaf child, split internal child, split when parent has capacity</td>\n<td>Child split into two nodes, median key promoted to parent at correct index, parent&#39;s keys/children arrays adjusted</td>\n<td>Verify all invariants: new nodes have <code>t-1</code> keys, parent gains one key, total keys preserved</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: Unit testing <code>node_split_child</code> is particularly important because it&#39;s the core operation that maintains B-tree balance during insertion. A bug here will propagate through the entire tree.</p>\n</blockquote>\n<h4 id=\"integration-testing-public-api-operations\">Integration Testing: Public API Operations</h4>\n<p>These tests verify that the main operations (<code>btree_insert</code>, <code>btree_delete</code>, <code>btree_search</code>) work together correctly and maintain all B-tree invariants.</p>\n<table>\n<thead>\n<tr>\n<th>Operation Sequence</th>\n<th>Test Scenario</th>\n<th>Invariants to Verify</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Search</strong></td>\n<td>Search in empty tree, search for existing key, search for non-existent key</td>\n<td>None (search doesn&#39;t modify tree)</td>\n<td>Correct <code>found</code> flag, correct <code>value</code> returned, <code>comparisons</code> count reasonable</td>\n</tr>\n<tr>\n<td><strong>Insert</strong></td>\n<td>Insert into empty tree, insert until root splits, insert keys in ascending/descending/random order</td>\n<td>All five B-tree invariants (see Data Model section)</td>\n<td>Tree height increases only when root splits, all keys findable after insertion</td>\n</tr>\n<tr>\n<td><strong>Delete</strong></td>\n<td>Delete from leaf with &gt; <code>t-1</code> keys, delete causing borrow from left/right sibling, delete causing merge, delete from internal node</td>\n<td>All five B-tree invariants, no underfull nodes except root</td>\n<td>Key no longer findable, tree height decreases only when root has single child</td>\n</tr>\n<tr>\n<td><strong>Mixed Operations</strong></td>\n<td>Interleave insertions and deletions, repeating same keys, deleting non-existent keys</td>\n<td>Invariants hold after each operation</td>\n<td>Tree remains balanced, no memory corruption</td>\n</tr>\n</tbody></table>\n<p>A powerful technique is to write a <strong>wrapper function</strong> that calls the public API and then immediately validates all invariants using <code>btree_validate</code>. This can be used in every test:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Pseudocode for test helper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> checked_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> success </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(tree, key, value);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(success);</span><span style=\"color:#6A737D\"> // or handle duplicates as needed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">btree_validate</span><span style=\"color:#E1E4E8\">(tree));</span><span style=\"color:#6A737D\"> // invariants must hold</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"property-based-testing\">Property-Based Testing</h4>\n<p>Property-based testing generates random sequences of operations and verifies that certain properties always hold. This is excellent for uncovering edge cases that manual test design might miss.</p>\n<table>\n<thead>\n<tr>\n<th>Property to Verify</th>\n<th>Testing Approach</th>\n<th>How to Validate</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Insertion maintains findability</strong></td>\n<td>Generate N random keys, insert all, then verify each key exists via <code>btree_search</code></td>\n<td>All searches return <code>found == true</code></td>\n</tr>\n<tr>\n<td><strong>Deletion removes keys</strong></td>\n<td>Insert N random keys, delete a random subset, verify deleted keys are gone, others remain</td>\n<td>Deleted keys return <code>found == false</code>, others <code>true</code></td>\n</tr>\n<tr>\n<td><strong>Sorted order traversal</strong></td>\n<td>After any operation sequence, perform in-order traversal (depth-first, left-to-right)</td>\n<td>Traversed keys are in strictly ascending order</td>\n</tr>\n<tr>\n<td><strong>Invariant preservation</strong></td>\n<td>After every single operation (insert/delete), call <code>btree_validate</code></td>\n<td>Validation passes for all intermediate states</td>\n</tr>\n<tr>\n<td><strong>Height bounds</strong></td>\n<td>After any operation sequence, verify tree height ≤ <code>log_t((n+1)/2) + 1</code> where n = key count</td>\n<td>Height remains within theoretical B-tree bounds</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Implementation Note</strong>: For property-based tests in C, consider using a simple deterministic pseudo-random number generator with a fixed seed for reproducible tests. Run thousands of operations to stress the implementation.</p>\n</blockquote>\n<h4 id=\"edge-case-and-scenario-testing\">Edge Case and Scenario Testing</h4>\n<p>Specific scenarios known to trigger bugs in B-tree implementations:</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Description</th>\n<th>Why It&#39;s Tricky</th>\n<th>Test Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Root split</strong></td>\n<td>Inserting into a full root (tree height increases)</td>\n<td>Requires creating new root, special case in insertion algorithm</td>\n<td>Insert exactly <code>2t-1</code> keys in ascending order, forcing root fills and splits</td>\n</tr>\n<tr>\n<td><strong>Cascading merges</strong></td>\n<td>Deletion causing underflow that propagates up multiple levels</td>\n<td>Must correctly handle sequential merges up to root</td>\n<td>Build tree of height 3, delete specific keys to trigger multiple merges</td>\n</tr>\n<tr>\n<td><strong>Borrow from left vs right</strong></td>\n<td>Underflow node with left sibling that has extra keys, vs right sibling</td>\n<td>Symmetry bugs: implementation might work for one side but not the other</td>\n<td>Create asymmetric sibling capacities, test deletions that require each borrow direction</td>\n</tr>\n<tr>\n<td><strong>Internal node deletion</strong></td>\n<td>Deleting a key from an internal node (requires predecessor/successor swap)</td>\n<td>Must choose correct predecessor/successor, handle leaf deletion after swap</td>\n<td>Delete keys that appear at various positions in internal nodes</td>\n</tr>\n<tr>\n<td><strong>Duplicate key insertion</strong></td>\n<td>Attempting to insert a key that already exists</td>\n<td>Implementation may assume unique keys; must handle gracefully (return false or overwrite)</td>\n<td>Depending on design choice, test that duplicates are rejected or values are updated</td>\n</tr>\n<tr>\n<td><strong>Minimum degree variations</strong></td>\n<td>Testing with different <code>t</code> values (e.g., t=2, t=3, t=10)</td>\n<td>Different <code>t</code> affects node capacities and tree shape</td>\n<td>Run same test suite with multiple <code>t</code> values</td>\n</tr>\n<tr>\n<td><strong>Empty tree operations</strong></td>\n<td>Deleting from empty tree, searching empty tree</td>\n<td>Edge cases for root being <code>NULL</code></td>\n<td>Verify graceful handling (return false, not crash)</td>\n</tr>\n<tr>\n<td><strong>Single node tree</strong></td>\n<td>All operations when tree has only root (no children)</td>\n<td>Special cases in deletion (root can become empty)</td>\n<td>Insert then delete all keys, verify root can become empty</td>\n</tr>\n</tbody></table>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Each milestone in the project has specific deliverables that should be testable. The following table provides concrete checkpoints to verify your implementation is on track after completing each milestone.</p>\n<table>\n<thead>\n<tr>\n<th>Milestone</th>\n<th>What to Test</th>\n<th>Expected Output</th>\n<th>How to Verify Success</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Milestone 1: Node Structure</strong></td>\n<td>Node creation with different <code>t</code> values, leaf vs internal flag, key array capacity, child pointer array for internal nodes</td>\n<td>Nodes created with correct field values, arrays of appropriate size</td>\n<td>Use debug prints or a test function to inspect node fields. Memory allocators should allocate <code>(2*t-1)*sizeof(int)</code> for keys and <code>(2*t)*sizeof(BTreeNode*)</code> for children.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>node_insert_key</code> and <code>node_remove_key</code> on a node</td>\n<td>Keys maintain sorted order after insert/remove, <code>num_keys</code> updated correctly</td>\n<td>Manually verify key array contents after series of operations.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>node_is_full</code> and <code>node_is_underfull</code></td>\n<td>Returns true precisely when <code>num_keys == 2t-1</code> (full) or <code>num_keys &lt; t-1</code> (underfull)</td>\n<td>Test with nodes having <code>t-2</code>, <code>t-1</code>, <code>t</code>, <code>2t-1</code>, <code>2t</code> keys (the last should not occur in practice).</td>\n</tr>\n<tr>\n<td><strong>Milestone 2: Search</strong></td>\n<td>Search in empty tree</td>\n<td>Returns <code>found = false</code>, <code>value = NULL</code></td>\n<td>Basic sanity check.</td>\n</tr>\n<tr>\n<td></td>\n<td>Search in single-node tree (leaf) for existing and non-existent keys</td>\n<td>Correct <code>found</code> flag, correct value returned for existing key</td>\n<td>Insert a few keys, search for each.</td>\n</tr>\n<tr>\n<td></td>\n<td>Search in multi-level tree</td>\n<td>Recursively descends through internal nodes, finds keys at all levels</td>\n<td>Build a small tree manually (by calling node functions) with known structure, verify search finds all keys.</td>\n</tr>\n<tr>\n<td></td>\n<td>Binary search within node (<code>node_find_key_index</code>)</td>\n<td>Returns correct index for key position, comparison count increments appropriately</td>\n<td>Test with keys less than all, greater than all, between, and exact matches.</td>\n</tr>\n<tr>\n<td><strong>Milestone 3: Insert with Split</strong></td>\n<td>Insert into non-full leaf</td>\n<td>Key added in sorted position, no splits occur</td>\n<td>Insert up to <code>2t-2</code> keys into an empty tree (root is leaf), verify tree remains single node.</td>\n</tr>\n<tr>\n<td></td>\n<td>Insert causing leaf split</td>\n<td>Leaf splits, median promoted to parent (root), new leaf created</td>\n<td>Insert <code>2t-1</code> keys in ascending order; after the <code>(2t-1)</code>th insertion, root should split (height becomes 2). Verify all keys findable.</td>\n</tr>\n<tr>\n<td></td>\n<td>Insert causing internal node split</td>\n<td>Split propagates upward, tree height increases only when root splits</td>\n<td>Build tree of height 2, fill internal nodes until they split, verify invariants.</td>\n</tr>\n<tr>\n<td></td>\n<td>Insertion with random key order</td>\n<td>All invariants maintained, tree remains balanced</td>\n<td>Insert 100 random keys, validate after each insertion.</td>\n</tr>\n<tr>\n<td><strong>Milestone 4: Delete with Rebalancing</strong></td>\n<td>Delete from leaf with sufficient keys (<code>num_keys &gt; t-1</code>)</td>\n<td>Key removed, no structural changes</td>\n<td>Build tree, delete key from leaf that won&#39;t cause underflow, verify key gone, tree valid.</td>\n</tr>\n<tr>\n<td></td>\n<td>Delete from leaf causing borrow from right sibling</td>\n<td>Key borrowed from right sibling through parent, parent key updated</td>\n<td>Create specific tree structure where leaf has <code>t-1</code> keys after deletion, right sibling has ≥ <code>t</code> keys. Verify borrow occurs.</td>\n</tr>\n<tr>\n<td></td>\n<td>Delete from leaf causing borrow from left sibling</td>\n<td>Symmetric case to above.</td>\n<td>Test both directions to catch asymmetry bugs.</td>\n</tr>\n<tr>\n<td></td>\n<td>Delete from leaf causing merge with sibling</td>\n<td>Two siblings and parent separator merge into one node</td>\n<td>Create scenario where both siblings have exactly <code>t-1</code> keys, deletion causes underflow, merge occurs.</td>\n</tr>\n<tr>\n<td></td>\n<td>Delete from internal node (using predecessor)</td>\n<td>Key replaced with predecessor from leaf, predecessor deleted from leaf</td>\n<td>Delete key from internal node, verify tree valid and key replaced correctly.</td>\n</tr>\n<tr>\n<td></td>\n<td>Delete from internal node (using successor)</td>\n<td>Similar to predecessor case.</td>\n<td>Ensure both predecessor and successor work if your implementation chooses one.</td>\n</tr>\n<tr>\n<td></td>\n<td>Cascading merges up to root</td>\n<td>Multiple merges cause root to have single child, height decreases</td>\n<td>Build tree of height 3, delete specific sequence to cause merges up to root.</td>\n</tr>\n<tr>\n<td></td>\n<td>Delete all keys (tree emptying)</td>\n<td>Tree can become empty (root = NULL) or root with 0 keys (depending on implementation choice)</td>\n<td>Insert N keys, delete all, verify tree empty or root empty.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Testing Principle</strong>: After completing each milestone, re-run all previous milestone tests to ensure new code hasn&#39;t broken existing functionality. This is especially important when moving from insertion to deletion, as deletion builds upon insertion&#39;s tree structure.</p>\n</blockquote>\n<h4 id=\"automated-test-harness-recommendation\">Automated Test Harness Recommendation</h4>\n<p>For efficiency, implement a simple test harness that:</p>\n<ol>\n<li><strong>Runs unit tests</strong> for each component.</li>\n<li><strong>Runs operation sequences</strong> and validates invariants after each step.</li>\n<li><strong>Runs property-based tests</strong> with random seeds.</li>\n<li><strong>Reports failures</strong> with detailed information (tree state, operation that failed).</li>\n</ol>\n<p>A sample test progression might look like:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>$ ./test_btree --milestone 1  # Node structure tests\n$ ./test_btree --milestone 2  # Search tests (also runs milestone 1 tests)\n$ ./test_btree --milestone 3  # Insert tests (runs milestones 1-2)\n$ ./test_btree --milestone 4  # Delete tests (runs all)\n$ ./test_btree --property 10000  # Run 10,000 random operations</code></pre></div>\n\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td>Custom test harness with asserts and counters</td>\n<td>Use a testing framework like <strong>Check</strong> (C unit testing framework) or <strong>Google Test</strong> (if using C++)</td>\n</tr>\n<tr>\n<td>Randomness</td>\n<td><code>rand()</code> with fixed seed for reproducibility</td>\n<td>Use a more robust PRNG like PCG or Mersenne Twister</td>\n</tr>\n<tr>\n<td>Memory Checking</td>\n<td>Manual tracking with <code>malloc</code>/<code>free</code> wrappers</td>\n<td>Use <strong>Valgrind</strong> or <strong>AddressSanitizer</strong> for automatic detection</td>\n</tr>\n<tr>\n<td>Invariant Validation</td>\n<td>Implement <code>btree_validate</code> as described in Section 10</td>\n<td>Extend validation with more detailed error messages and graph output for debugging</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<p>Add test files to your project structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree-project/\n├── include/\n│   └── btree.h              # Public API declarations\n├── src/\n│   ├── btree.c              # B-tree implementation\n│   ├── node.c               # Node-level functions\n│   └── operations.c         # Search, insert, delete algorithms\n└── tests/                   # Test directory\n    ├── test_harness.c       # Main test runner\n    ├── test_node.c          # Milestone 1: Node tests\n    ├── test_search.c        # Milestone 2: Search tests\n    ├── test_insert.c        # Milestone 3: Insert tests\n    ├── test_delete.c        # Milestone 4: Delete tests\n    ├── test_property.c      # Property-based tests\n    └── test_utils.c         # Test utilities (tree printing, validation helpers)</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-test-harness\">Infrastructure Starter Code: Test Harness</h4>\n<p>Here&#39;s a complete, reusable test harness foundation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* test_harness.c - Simple test framework for B-tree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../include/btree.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TEST_START</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TEST: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">... \"</span><span style=\"color:#E1E4E8\">, name); </span><span style=\"color:#B392F0\">fflush</span><span style=\"color:#E1E4E8\">(stdout)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TEST_PASS</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TEST_FAIL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"FAIL: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, reason); </span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Global test counters */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> tests_run </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> tests_passed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Wrapper for btree_insert that validates after each insert */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> checked_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests_run</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> success </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(tree, key, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">success) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        TEST_FAIL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"insert returned false (duplicate key?)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">btree_validate</span><span style=\"color:#E1E4E8\">(tree)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        TEST_FAIL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tree invariant violated after insert\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests_passed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Wrapper for btree_delete */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> checked_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests_run</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> success </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(tree, key);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">success) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        TEST_FAIL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"delete returned false (key not found?)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">btree_validate</span><span style=\"color:#E1E4E8\">(tree)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        TEST_FAIL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tree invariant violated after delete\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests_passed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Verify search returns expected result */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> verify_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> expected_found</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> expected_value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests_run</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SearchResult res </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_search</span><span style=\"color:#E1E4E8\">(tree, key);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (res.found </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expected_found) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"FAIL: key </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: expected found=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               key, expected_found, res.found);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (expected_found </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> res.value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expected_value) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"FAIL: key </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: value mismatch</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, key);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests_passed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Run all milestone tests */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> run_milestone1_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> run_milestone2_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> run_milestone3_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> run_milestone4_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> run_property_tests</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num_ops</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char**</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== B-tree Test Suite ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Run specific milestone tests based on command line */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Run all tests */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone1_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone2_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone3_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone4_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_property_tests</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"--milestone1\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone1_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"--milestone2\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone1_tests</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  /* Milestone 2 depends on 1 */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone2_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"--milestone3\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone1_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone2_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone3_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"--milestone4\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone1_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone2_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone3_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_milestone4_tests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"--property\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> num_ops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> argc </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run_property_tests</span><span style=\"color:#E1E4E8\">(num_ops);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== Summary: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> tests passed ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, tests_passed, tests_run);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tests_passed </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> tests_run </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-for-test-utilities\">Core Logic Skeleton for Test Utilities</h4>\n<p>For the test utilities that you&#39;ll need to implement (like tree validation and printing), here are skeletons with TODOs:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* test_utils.c - Utilities for testing */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../include/btree.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Recursive helper for btree_validate */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> validate_node</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_root</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   int*</span><span style=\"color:#FFAB70\"> min_key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> max_key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> depth</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> leaf_depth</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check that node pointer is not NULL (unless empty tree handled by caller)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify key count: </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If is_root: 0 &#x3C;= num_keys &#x3C;= 2t-1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Else: t-1 &#x3C;= num_keys &#x3C;= 2t-1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify keys are in strictly increasing order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If leaf node:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Verify children pointers are all NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Record leaf depth (first leaf found sets *leaf_depth, others must match)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If internal node:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Verify num_keys + 1 == number of non-NULL children</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Verify each child's keys are in correct range relative to parent keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Recursively validate each child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update min_key and max_key for this subtree for parent validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Handle empty tree (root == NULL): return true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize leaf_depth to -1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call validate_node on root with is_root = true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check that all leaves are at same depth (via leaf_depth)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_node</span><span style=\"color:#E1E4E8\">(BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> depth</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Print indentation based on depth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Print node type (leaf/internal) and key count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Print keys in format like [k1, k2, ..., kn]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If internal node, recursively print children with depth+1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Print tree header with t, height, size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If root is NULL, print \"Empty tree\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Otherwise, call print_node(root, 0)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-c-testing\">Language-Specific Hints: C Testing</h4>\n<ul>\n<li><strong>Memory Leak Detection</strong>: Always run tests with Valgrind: <code>valgrind --leak-check=full ./test_btree</code></li>\n<li><strong>Random Number Generation</strong>: Use <code>srand(42)</code> for reproducible tests during development, but also test with different seeds.</li>\n<li><strong>Assertions</strong>: Use <code>assert()</code> from <code>&lt;assert.h&gt;</code> for invariants that should never fail in correct code.</li>\n<li><strong>Modular Compilation</strong>: Compile tests separately from main implementation: <code>gcc -c src/btree.c -o build/btree.o</code> then link with test files.</li>\n</ul>\n<h4 id=\"milestone-checkpoint-commands\">Milestone Checkpoint Commands</h4>\n<p>After implementing each milestone, run these commands to verify:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># After Milestone 1 (Node Structure):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> gcc</span><span style=\"color:#79B8FF\"> -std=c99</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -Iinclude</span><span style=\"color:#9ECBFF\"> src/node.c</span><span style=\"color:#9ECBFF\"> tests/test_node.c</span><span style=\"color:#9ECBFF\"> tests/test_harness.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_node</span><span style=\"color:#79B8FF\"> --milestone1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: \"PASS\" for all tests, no Valgrind errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># After Milestone 2 (Search):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> gcc</span><span style=\"color:#79B8FF\"> -std=c99</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -Iinclude</span><span style=\"color:#9ECBFF\"> src/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.c</span><span style=\"color:#9ECBFF\"> tests/test_search.c</span><span style=\"color:#9ECBFF\"> tests/test_harness.c</span><span style=\"color:#9ECBFF\"> tests/test_utils.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_search</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_search</span><span style=\"color:#79B8FF\"> --milestone2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Search finds all inserted keys, returns false for non-existent keys</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># After Milestone 3 (Insert):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> gcc</span><span style=\"color:#79B8FF\"> -std=c99</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -Iinclude</span><span style=\"color:#9ECBFF\"> src/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.c</span><span style=\"color:#9ECBFF\"> tests/test_insert.c</span><span style=\"color:#9ECBFF\"> tests/test_harness.c</span><span style=\"color:#9ECBFF\"> tests/test_utils.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_insert</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_insert</span><span style=\"color:#79B8FF\"> --milestone3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Tree validates after every insertion, root splits correctly</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># After Milestone 4 (Delete):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> gcc</span><span style=\"color:#79B8FF\"> -std=c99</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -Iinclude</span><span style=\"color:#9ECBFF\"> src/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.c</span><span style=\"color:#9ECBFF\"> tests/test_delete.c</span><span style=\"color:#9ECBFF\"> tests/test_harness.c</span><span style=\"color:#9ECBFF\"> tests/test_utils.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_delete</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_delete</span><span style=\"color:#79B8FF\"> --milestone4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All deletion cases handled, tree validates, no memory leaks</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Final comprehensive test:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> gcc</span><span style=\"color:#79B8FF\"> -std=c99</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -Iinclude</span><span style=\"color:#9ECBFF\"> src/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.c</span><span style=\"color:#9ECBFF\"> tests/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_all</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> valgrind</span><span style=\"color:#79B8FF\"> --leak-check=full</span><span style=\"color:#9ECBFF\"> ./test_all</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests pass, \"0 errors from Valgrind\"</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips-for-tests\">Debugging Tips for Tests</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Segmentation fault in <code>node_create</code></strong></td>\n<td>Memory allocation failure, or accessing uninitialized pointer</td>\n<td>Check <code>malloc</code> return values, ensure all array indices are within bounds</td>\n<td>Add NULL checks after malloc, verify <code>t &gt; 1</code></td>\n</tr>\n<tr>\n<td><strong>Tree validation fails after insert</strong></td>\n<td>Invariant violation (e.g., keys not sorted, wrong key count)</td>\n<td>Use <code>btree_print</code> to visualize tree structure before/after failing operation</td>\n<td>Check <code>node_insert_key</code> shifting logic, verify split median calculation</td>\n</tr>\n<tr>\n<td><strong>Search finds keys after insert but not after delete</strong></td>\n<td>Deletion incorrectly removes extra keys or corrupts pointers</td>\n<td>Print tree before and after deletion, check borrow/merge logic</td>\n<td>Verify sibling indices are correct during borrow/merge</td>\n</tr>\n<tr>\n<td><strong>Memory leak reported by Valgrind</strong></td>\n<td><code>node_destroy</code> not recursive, or missing free for arrays</td>\n<td>Run Valgrind with <code>--track-origins=yes</code>, check which allocation isn&#39;t freed</td>\n<td>Ensure <code>node_destroy</code> frees keys, children, then the node itself</td>\n</tr>\n<tr>\n<td><strong>Infinite recursion during search/insert</strong></td>\n<td>Base case missing (leaf check), or child pointer incorrect</td>\n<td>Add debug prints showing node address and depth</td>\n<td>Ensure <code>is_leaf</code> is set correctly, recursion stops at leaves</td>\n</tr>\n<tr>\n<td><strong>Tree height grows too quickly</strong></td>\n<td>Splitting too aggressively (splitting non-full nodes)</td>\n<td>Check <code>node_is_full</code> logic, verify split only called when <code>num_keys == 2*t-1</code></td>\n<td>Fix <code>node_is_full</code> condition</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Pro Tip</strong>: Implement <code>btree_print</code> early (even as a simple text dump) and use it liberally in tests. Visualizing the tree structure is the fastest way to spot structural bugs.</p>\n</blockquote>\n<h2 id=\"12-debugging-guide\">12. Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 1-4 (all operations)</p>\n</blockquote>\n<p>Implementing a B-tree is a complex undertaking involving recursive algorithms, careful pointer management, and maintenance of multiple invariants. Even with a solid design, bugs are inevitable. This section provides a structured approach to identifying, diagnosing, and fixing the most common categories of bugs you&#39;ll encounter during implementation. Think of this as your troubleshooting manual—a collection of known failure patterns and the tools to resolve them.</p>\n<p>Debugging a B-tree is like being a building inspector for a multi-story library. You need to check each floor (node) to ensure it has the right number of books (keys), that the floor plans (child pointers) lead to the correct sub-floors, and that the entire structure follows building codes (B-tree invariants). When something collapses (segmentation fault) or books go missing (lost keys), you need systematic inspection techniques to find the root cause.</p>\n<h3 id=\"common-bug-symptoms-and-fixes\">Common Bug Symptoms and Fixes</h3>\n<p>The following table catalogues the most frequent symptoms, their likely underlying causes, and specific fixes. These are drawn from common patterns observed when implementing B-trees in C.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Segmentation fault immediately after insertion or deletion</strong></td>\n<td>Accessing a <code>children</code> pointer at an index beyond the current <code>num_keys</code> (remember: internal nodes have <code>num_keys + 1</code> children).</td>\n<td>Before accessing <code>node-&gt;children[i]</code>, verify <code>i &lt;= node-&gt;num_keys</code> for internal nodes. For leaf nodes, never access children. Use `assert(node-&gt;is_leaf</td>\n</tr>\n<tr>\n<td><strong>Keys disappearing after a split operation</strong></td>\n<td>Incorrect calculation of the median index during <code>node_split_child</code>, leading to wrong key distribution between the old and new nodes. The median key should be at index <code>t-1</code> (0-based) in a node with <code>2t-1</code> keys.</td>\n<td>Double-check the split logic: the original node keeps the first <code>t-1</code> keys (indices 0 to <code>t-2</code>), the new node gets the last <code>t-1</code> keys (indices <code>t</code> to <code>2t-2</code>), and the median key at index <code>t-1</code> is promoted.</td>\n</tr>\n<tr>\n<td><strong>Infinite recursion during search/insert/delete</strong></td>\n<td>Forgetting to check the <code>is_leaf</code> flag before attempting to recurse into child nodes. The recursive call is made even when <code>node-&gt;is_leaf</code> is true, leading to endless descent into invalid memory.</td>\n<td>Ensure every recursive function has a base case that checks <code>if (node-&gt;is_leaf) return ...</code> before attempting to access <code>node-&gt;children</code>.</td>\n</tr>\n<tr>\n<td><strong>Tree height increases unnecessarily (more than one root split)</strong></td>\n<td>Failing to update the tree&#39;s root pointer after a root split. The old root remains, and a new root is created but not assigned to <code>tree-&gt;root</code>.</td>\n<td>In <code>btree_insert</code>, after calling a helper that may split the root, check if the root was split (e.g., if the old root is full). If so, create a new root with the promoted key and two children.</td>\n</tr>\n<tr>\n<td><strong>&quot;Key not found&quot; for keys that were definitely inserted</strong></td>\n<td>Keys are not maintained in sorted order within nodes, breaking the binary search assumption. Insertion or split operations may place keys in wrong positions.</td>\n<td>After any key insertion or movement (during insert, borrow, merge), ensure the keys array remains sorted. Write a helper <code>node_validate_order(node)</code> that asserts ascending order for debugging.</td>\n</tr>\n<tr>\n<td><strong>Memory leak (Valgrind reports lost blocks)</strong></td>\n<td>Not recursively freeing child nodes in <code>node_destroy</code>. Only freeing the node&#39;s own arrays but not its children&#39;s arrays for internal nodes.</td>\n<td>In <code>node_destroy</code>, if <code>!node-&gt;is_leaf</code>, iterate through <code>i = 0 to node-&gt;num_keys</code> and call <code>node_destroy(node-&gt;children[i])</code> before freeing the node&#39;s own arrays.</td>\n</tr>\n<tr>\n<td><strong>Underflow (node has &lt; t-1 keys) after deletion</strong></td>\n<td>The <code>strengthen_child</code> (or equivalent preemptive borrowing/merging during descent) was not performed correctly, or the borrow/merge logic itself is flawed.</td>\n<td>During deletion descent, before recursing into a child, ensure the child has at least <code>t</code> keys. If not, borrow from a sibling or merge with a sibling. Re-check the conditions for borrowing (sibling has ≥ t keys) vs. merging (sibling has exactly t-1 keys).</td>\n</tr>\n<tr>\n<td><strong>Child pointer becomes NULL after merge, causing segfault later</strong></td>\n<td>When merging two children, the right child node is freed but its pointer in the parent&#39;s <code>children</code> array is not set to NULL or removed. The array may later be accessed assuming all entries are valid.</td>\n<td>After <code>merge_with_left_sibling</code>, the right child is absorbed. You must shift the parent&#39;s child pointers left to remove the now-empty slot. For <code>borrow</code> operations, child pointers are rearranged but not removed.</td>\n</tr>\n<tr>\n<td><strong>Duplicate keys appear in the tree</strong></td>\n<td>The insertion logic does not check for existing keys before inserting. B-trees typically allow duplicates? (Usually not; we assume unique keys for this implementation).</td>\n<td>In <code>btree_insert</code>, before starting the insertion process, call <code>btree_search</code>. If found, decide whether to replace the value or reject the insertion. The design assumes unique keys, so you may choose to return false.</td>\n</tr>\n<tr>\n<td><strong>Binary search returns incorrect index (off-by-one)</strong></td>\n<td>Incorrect handling of the <code>high</code> index (should be <code>num_keys - 1</code> initially) or confusion between &quot;index where key is found&quot; and &quot;index where key should be inserted&quot;.</td>\n<td>The <code>node_find_key_index</code> should return the first index where <code>key &lt;= node-&gt;keys[i]</code>. If <code>key</code> is greater than all keys, return <code>num_keys</code>. Test with a simple linear search as a reference implementation.</td>\n</tr>\n<tr>\n<td><strong>After many insertions and deletions, tree invariants break</strong></td>\n<td>Cumulative error from small mistakes in edge cases, e.g., root&#39;s minimum key count (can be 1), handling of the last child pointer during split, etc.</td>\n<td>Implement <code>btree_validate</code> and call it after every operation in debug mode. This function recursively checks all invariants: key count bounds, ordering, leaf property consistency, and child pointer counts.</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-techniques-and-tools\">Debugging Techniques and Tools</h3>\n<p>Effective debugging requires more than just guessing. You need a systematic approach and the right tools. Below are techniques specifically tailored for B-tree implementations in C.</p>\n<h4 id=\"1-verbose-logging-with-function-tracing\">1. <strong>Verbose Logging with Function Tracing</strong></h4>\n<p>Add logging macros that print the execution flow and key data structures. This lets you see exactly how the tree evolves.</p>\n<blockquote>\n<p><strong>Mental Model:</strong> This is like adding security cameras at every staircase and bookshelf in the library. You can replay the footage to see exactly when and where a book was misplaced.</p>\n</blockquote>\n<p><strong>How to implement:</strong></p>\n<ul>\n<li>Create a <code>DEBUG</code> macro that can be enabled/disabled at compile time.</li>\n<li>At the entrance and exit of each major function (<code>search_recursive</code>, <code>insert_non_full</code>, <code>delete_from_subtree</code>), log the function name, parameters (e.g., node address, key), and key state (e.g., <code>num_keys</code>).</li>\n<li>Before and after critical operations (split, borrow, merge), print the entire state of the affected nodes.</li>\n</ul>\n<p><strong>Example log output snippet:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[INSERT] insert_non_full node=0x1234, key=42, is_leaf=0, num_keys=3\n[SPLIT] Splitting child at index 1 of parent 0x1234\n  Before split: child keys=[10,20,30,40,50]\n  After split: left keys=[10,20], promoted=30, right keys=[40,50]</code></pre></div>\n\n<p>This allows you to trace the exact sequence of operations leading to a bug.</p>\n<h4 id=\"2-tree-visualization-function\">2. <strong>Tree Visualization Function</strong></h4>\n<p>A text-based tree printer is invaluable for seeing the overall structure. Implement <code>btree_print</code> that outputs the tree in a readable format.</p>\n<p><strong>Recommended format (indentation-based):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>B-Tree (t=3, height=2, keys=10)\n[Root] keys=30\n  [Child 0] keys=10 20\n    [Leaf] keys=5 7 9\n    [Leaf] keys=12 15\n    [Leaf] keys=22 25\n  [Child 1] keys=40 50\n    [Leaf] keys=32 35 38\n    [Leaf] keys=42 45 48\n    [Leaf] keys=52 55</code></pre></div>\n<p>This reveals structural problems like missing nodes, incorrect key distributions, or broken parent-child relationships.</p>\n<p><strong>Implementation Guidance:</strong> Use a recursive helper that takes a node and an indentation level. For each node, print its keys. If not a leaf, recursively print each child with increased indentation.</p>\n<h4 id=\"3-invariant-verification-function\">3. <strong>Invariant Verification Function</strong></h4>\n<p>The single most powerful debugging tool is an automatic invariant checker. Implement <code>btree_validate</code> that traverses the entire tree and asserts every B-tree rule.</p>\n<p><strong>What to check:</strong></p>\n<ol>\n<li><strong>Key count bounds:</strong> For root: <code>0 &lt;= num_keys &lt;= 2t-1</code>. For others: <code>t-1 &lt;= num_keys &lt;= 2t-1</code>.</li>\n<li><strong>Key ordering:</strong> Keys within each node are strictly increasing.</li>\n<li><strong>Leaf consistency:</strong> If <code>is_leaf</code> is true, all child pointers are NULL. If false, all child pointers are non-NULL (for indices <code>0..num_keys</code>).</li>\n<li><strong>Child count:</strong> Internal nodes have exactly <code>num_keys + 1</code> children.</li>\n<li><strong>Recursive child validation:</strong> For internal nodes, every key in child <code>i</code> is less than <code>node-&gt;keys[i]</code>, and every key in child <code>i+1</code> is greater than <code>node-&gt;keys[i]</code>. Also recursively validate each child.</li>\n<li><strong>Tree height consistency:</strong> All leaf nodes are at the same depth (same distance from root).</li>\n</ol>\n<p>Call <code>btree_validate</code> after every insert and delete operation during development. When a violation occurs, print the node state and abort. This catches bugs immediately at their source rather than allowing corruption to propagate.</p>\n<h4 id=\"4-memory-debuggers-valgrind-and-addresssanitizer\">4. <strong>Memory Debuggers: Valgrind and AddressSanitizer</strong></h4>\n<p>Memory errors are common in C. Use these tools to detect:</p>\n<ul>\n<li>Use of uninitialized memory</li>\n<li>Buffer overflows (writing beyond allocated arrays)</li>\n<li>Memory leaks</li>\n<li>Use-after-free errors</li>\n</ul>\n<p><strong>Valgrind usage:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">valgrind</span><span style=\"color:#79B8FF\"> --leak-check=full</span><span style=\"color:#9ECBFF\"> ./your_btree_program</span></span></code></pre></div>\n\n<p><strong>AddressSanitizer (faster, compile-time instrumentation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -fsanitize=address</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#9ECBFF\"> your_code.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> your_btree_program</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./your_btree_program</span></span></code></pre></div>\n\n<p>These tools will pinpoint the exact line where illegal memory access occurs, which is especially helpful for segmentation faults.</p>\n<h4 id=\"5-interactive-debugging-with-gdb\">5. <strong>Interactive Debugging with GDB</strong></h4>\n<p>When you have a reproducible crash, use GDB to inspect program state at the moment of failure.</p>\n<p><strong>Essential GDB commands:</strong></p>\n<ul>\n<li><code>break function_name</code> – Set a breakpoint</li>\n<li><code>run</code> – Start program</li>\n<li><code>backtrace</code> or <code>bt</code> – Show call stack at crash</li>\n<li><code>print node-&gt;num_keys</code> – Inspect variable</li>\n<li><code>x/10wx node-&gt;keys</code> – Examine memory as array of words</li>\n<li><code>step</code> and <code>next</code> – Single-step execution</li>\n</ul>\n<p><strong>Pro tip:</strong> Create a GDB script that sets breakpoints at key functions and prints node information automatically.</p>\n<h4 id=\"6-unit-test-with-known-sequences\">6. <strong>Unit Test with Known Sequences</strong></h4>\n<p>Create small, focused test cases that exercise specific operations in isolation. For example:</p>\n<ol>\n<li><strong>Test root split:</strong> Insert exactly <code>2t-1</code> keys in ascending order, forcing a single root split.</li>\n<li><strong>Test borrow from right sibling:</strong> Create a specific tree configuration, then delete a key that triggers borrowing.</li>\n<li><strong>Test merge cascade:</strong> Build a tree where deletion causes a merge that propagates upward.</li>\n</ol>\n<p>By isolating scenarios, you simplify the debugging surface. Compare your tree&#39;s state after each operation against a manually computed expected state.</p>\n<h4 id=\"7-property-based-testing\">7. <strong>Property-Based Testing</strong></h4>\n<p>After basic operations work, use property-based testing to find edge cases. The key properties of a B-tree are:</p>\n<ul>\n<li>All keys are always present after insertion.</li>\n<li>No keys are present after deletion.</li>\n<li>The tree remains balanced (all leaves at same depth).</li>\n<li>Keys are always in sorted order when traversed in-order.</li>\n</ul>\n<p>Generate random sequences of insertions and deletions, and after each operation, verify these properties using your <code>btree_validate</code> function. This can uncover subtle bugs that only appear with specific sequences.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete code and tools to implement the debugging techniques described above.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Debug Logging</td>\n<td>Custom <code>DEBUG</code> macro with <code>printf</code></td>\n<td>Logging library (e.g., <code>zlog</code> for C) with configurable levels</td>\n</tr>\n<tr>\n<td>Memory Debugging</td>\n<td>Valgrind</td>\n<td>AddressSanitizer (ASan) + UndefinedBehaviorSanitizer (UBSan)</td>\n</tr>\n<tr>\n<td>Interactive Debugging</td>\n<td>GDB with basic commands</td>\n<td>GDB with Python scripting for custom pretty-printers</td>\n</tr>\n<tr>\n<td>Visualization</td>\n<td>Simple text indentation</td>\n<td>Graphviz DOT format generation for graphical output</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Add debugging utilities to your project structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree/\n  include/\n    btree.h          ← Main public interface\n    debug.h          ← Debugging macros and utilities\n  src/\n    btree.c          ← Core B-tree implementation\n    debug.c          ← Debugging implementations (validate, print)\n  tests/\n    test_btree.c     ← Unit and property tests\n  examples/\n    demo.c           ← Demonstration program</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>Here&#39;s complete, ready-to-use code for debugging macros and validation helpers:</p>\n<p><strong><code>include/debug.h</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> DEBUG_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEBUG_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"btree.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Enable/disable debug logging at compile time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// #define DEBUG 1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] \"</span><span style=\"color:#E1E4E8\"> fmt, __func__, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Assert with custom message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cond</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(cond)) { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Assertion failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, msg, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            abort</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Function prototypes for debugging utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> node_print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> indent</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // DEBUG_H</span></span></code></pre></div>\n\n<p><strong><code>src/debug.c</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"debug.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper to validate a subtree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> node_validate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> depth</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         int*</span><span style=\"color:#FFAB70\"> leaf_depth</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> max_key</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         bool</span><span style=\"color:#FFAB70\"> is_root</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check key count bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (is_root) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Root key count violation: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, node->num_keys);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Node key count violation: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, node->num_keys);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check keys are sorted</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->keys[i] </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> node->keys[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Keys not sorted at index </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> >= </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                i, node->keys[i], node->keys[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check key range (optional, for thorough validation)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->keys[i] </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> min_key </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> node->keys[i] </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> max_key) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Key </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> out of range (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, node->keys[i], min_key, max_key);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // For leaves, check all children are NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> node->num_keys; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (node->children[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Leaf has non-NULL child at index </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check leaf depth consistency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">leaf_depth </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">leaf_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> depth;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">leaf_depth </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> depth) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Leaf depth mismatch: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> vs </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">leaf_depth, depth);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Internal node: check child count and pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (node->num_keys </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#E1E4E8\"> node->num_children) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Child count mismatch: keys=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, children=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                node->num_keys, node->num_children);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Validate each child recursively</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> node->num_keys; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (node->children[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Internal node has NULL child at index </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Determine key bounds for child</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> child_min </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> min_key </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> node->keys[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> child_max </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> node->num_keys) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> max_key </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> node->keys[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">node_validate</span><span style=\"color:#E1E4E8\">(node->children[i], t, depth </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              leaf_depth, child_min, child_max, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_validate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">tree </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">tree->root) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> leaf_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> node_validate</span><span style=\"color:#E1E4E8\">(tree->root, tree->t, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">leaf_depth, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        INT_MIN, INT_MAX, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> print_node</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> indent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> indent; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] \"</span><span style=\"color:#E1E4E8\">, node->is_leaf </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"Leaf\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"Node\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"keys=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: \"</span><span style=\"color:#E1E4E8\">, node->num_keys);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> node->num_keys; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">, node->keys[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> btree_print_recursive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> indent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_node</span><span style=\"color:#E1E4E8\">(node, indent);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">node->is_leaf) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> node->num_keys; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            btree_print_recursive</span><span style=\"color:#E1E4E8\">(node->children[i], indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> btree_print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">tree) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BTree: NULL</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"B-Tree (t=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, height=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, total_keys=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           tree->t, </span><span style=\"color:#B392F0\">btree_height</span><span style=\"color:#E1E4E8\">(tree), </span><span style=\"color:#B392F0\">btree_size</span><span style=\"color:#E1E4E8\">(tree));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    btree_print_recursive</span><span style=\"color:#E1E4E8\">(tree->root, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>For the main operations, add debugging hooks. Here&#39;s how to instrument <code>btree_insert</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Inserting key=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, key);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check for duplicate key (if desired)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SearchResult res = btree_search(tree, key);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // if (res.found) return false; // or replace value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If root is full, split it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">node_is_full</span><span style=\"color:#E1E4E8\">(tree->root, tree->t)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Root is full, splitting</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create new root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> new_root </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> node_create</span><span style=\"color:#E1E4E8\">(tree->t, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_root->children[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tree->root;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        node_split_child</span><span style=\"color:#E1E4E8\">(new_root, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, tree->t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tree->root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_root;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call insert_non_full on the root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> insert_non_full</span><span style=\"color:#E1E4E8\">(tree->root, key, value, tree->t);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate tree in debug mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">btree_validate</span><span style=\"color:#E1E4E8\">(tree)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Invariant violated after insertion of key=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, key);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        btree_print</span><span style=\"color:#E1E4E8\">(tree);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Insertion </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, result </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"succeeded\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-c\">E. Language-Specific Hints (C)</h4>\n<ul>\n<li><strong>Use <code>assert</code> liberally:</strong> Include <code>&lt;assert.h&gt;</code> and use <code>assert(condition)</code> to catch logic errors early. Assertions can be disabled in release builds with <code>-DNDEBUG</code>.</li>\n<li><strong>Compile with debugging symbols:</strong> Always use <code>-g</code> flag when compiling debug builds: <code>gcc -g -O0 -DDEBUG -o btree btree.c debug.c</code></li>\n<li><strong>Enable all warnings:</strong> Use <code>-Wall -Wextra -Werror</code> to catch potential issues at compile time.</li>\n<li><strong>Use <code>typedef</code> for function pointers:</strong> If you need callback functions for tree traversal or value freeing, use typedefs for clarity.</li>\n<li><strong>Memory initialization:</strong> Always initialize allocated memory with <code>calloc</code> or explicit loops. Uninitialized pointers cause non-deterministic bugs.</li>\n</ul>\n<h4 id=\"f-debugging-tips-table\">F. Debugging Tips Table</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Valgrind reports &quot;invalid read&quot; at <code>node_find_key_index</code></strong></td>\n<td>Reading beyond allocated <code>keys</code> array in binary search.</td>\n<td>Add logging to print <code>num_keys</code> and the search bounds. Use GDB to break at that function and examine the array.</td>\n<td>Ensure binary search limits are <code>[0, num_keys)</code> for key comparisons, and <code>num_keys</code> is correctly maintained.</td>\n</tr>\n<tr>\n<td><strong>Tree prints show duplicate keys at different levels</strong></td>\n<td>During split, the median key was not removed from the child node, or was inserted twice.</td>\n<td>Print the state of both child nodes and the parent before and after split.</td>\n<td>In <code>node_split_child</code>, after promoting the median key, reduce the original child&#39;s <code>num_keys</code> to <code>t-1</code> (removing keys from index <code>t</code> onward).</td>\n</tr>\n<tr>\n<td><strong>Deletion causes underflow even after borrow/merge</strong></td>\n<td>The <code>strengthen_child</code> function is not called during descent, or the wrong sibling is chosen for borrowing.</td>\n<td>Add logging to show which child is strengthened, which sibling is chosen, and why.</td>\n<td>Ensure you check left sibling first for borrowing, then right sibling. The sibling must have at least <code>t</code> keys to borrow.</td>\n</tr>\n<tr>\n<td><strong>Height increases but root has only one key</strong></td>\n<td>This is correct after a root split. If height increases multiple times unnecessarily, the root split logic may be called when root is not full.</td>\n<td>Check the condition before splitting root: <code>if (node_is_full(tree-&gt;root, tree-&gt;t))</code>.</td>\n<td>Only split the root when it&#39;s full (<code>num_keys == 2*t-1</code>).</td>\n</tr>\n<tr>\n<td><strong>Segmentation fault in <code>node_destroy</code></strong></td>\n<td>Double-free or accessing freed memory. Child pointers might be invalid.</td>\n<td>Run with Valgrind to see invalid access. Check that <code>node_destroy</code> only frees child pointers for internal nodes.</td>\n<td>In <code>node_destroy</code>, check <code>if (!node-&gt;is_leaf)</code> before iterating through children. Set pointers to NULL after freeing.</td>\n</tr>\n</tbody></table>\n<h4 id=\"g-milestone-checkpoint-for-debugging\">G. Milestone Checkpoint for Debugging</h4>\n<p>After implementing each milestone, run these debugging checks:</p>\n<p><strong>Milestone 1 (Node Structure):</strong></p>\n<ul>\n<li>Run: <code>./test_btree --test-node-creation</code></li>\n<li>Expected: No memory leaks (Valgrind clean), nodes created with correct capacity.</li>\n<li>Verify: Use a debugger to inspect a node&#39;s memory layout. Check that <code>keys</code> and <code>children</code> arrays are properly allocated.</li>\n</ul>\n<p><strong>Milestone 2 (Search):</strong></p>\n<ul>\n<li>Run: <code>./test_btree --test-search</code></li>\n<li>Expected: Search finds all inserted keys, returns correct &quot;not found&quot; for absent keys.</li>\n<li>Debugging: Insert 10 keys, print tree, then search for each. Add logging to trace the search path.</li>\n</ul>\n<p><strong>Milestone 3 (Insert with Split):</strong></p>\n<ul>\n<li>Run: <code>./test_btree --test-insert</code></li>\n<li>Expected: Tree maintains all invariants after each insertion. Root splits when appropriate.</li>\n<li>Debugging: Insert exactly <code>2t-1</code> ascending keys and validate tree after each insertion. Check that height increases by 1 only when root splits.</li>\n</ul>\n<p><strong>Milestone 4 (Delete with Rebalancing):</strong></p>\n<ul>\n<li>Run: <code>./test_btree --test-delete</code></li>\n<li>Expected: All keys remain findable after random insert/delete sequences. Tree height may decrease.</li>\n<li>Debugging: Create a known tree structure, delete a specific key that triggers borrow, then merge. Print tree before and after each operation.</li>\n</ul>\n<p>When something goes wrong, use this systematic approach:</p>\n<ol>\n<li><strong>Reproduce minimally:</strong> Create the smallest test case that triggers the bug.</li>\n<li><strong>Add instrumentation:</strong> Enable debug logging around the failing operation.</li>\n<li><strong>Validate invariants:</strong> Call <code>btree_validate</code> before and after the operation.</li>\n<li><strong>Inspect state:</strong> Use <code>btree_print</code> to visualize the tree structure.</li>\n<li><strong>Debug step-by-step:</strong> Use GDB to step through the failing function.</li>\n<li><strong>Check memory:</strong> Run Valgrind to catch memory corruption.</li>\n</ol>\n<p>Remember, B-tree bugs often manifest far from their source—a missing key might result from a split that happened hours of operations earlier. The invariant checker is your best defense against these subtle, cumulative errors.</p>\n<h2 id=\"13-future-extensions\">13. Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section builds upon all four milestones (Node Structure, Search, Insert with Split, Delete with Rebalancing) and explores how the foundational B-tree implementation can be extended for real-world use cases beyond the educational scope.</p>\n</blockquote>\n<p>The current B-tree implementation provides a solid in-memory foundation that correctly maintains all structural invariants. However, production database systems and file systems extend this core design in several critical directions. This section outlines potential enhancements, explaining how each would modify the architecture, the technical challenges involved, and the benefits they would provide. These extensions transform the academic B-tree into a practical component suitable for building storage engines, indexing systems, and other disk-resident data structures.</p>\n<h3 id=\"131-extension-ideas\">13.1 Extension Ideas</h3>\n<p>The following extensions represent natural evolution paths for the B-tree implementation. Each addresses a specific limitation of the current design for production environments.</p>\n<h4 id=\"1311-persistence-to-disk-disk-io-layer\">13.1.1 Persistence to Disk (Disk I/O Layer)</h4>\n<p><strong>Mental Model: The Filing Cabinet System</strong>\nThink of the current in-memory B-tree as a temporary workspace on a desk—fast to access but lost when the power goes off. Adding disk persistence transforms it into a filing cabinet system: each node corresponds to a labeled folder (disk page) stored in a drawer (disk). To work with a document, you must first retrieve the entire folder from the cabinet (disk read), make changes, and then file it back (disk write). The cabinet&#39;s organization (the B-tree structure) survives power cycles, but accessing folders is slower than grabbing papers from your desk.</p>\n<p><strong>Current Limitation:</strong> The implementation stores all nodes in volatile RAM using <code>malloc</code>. A system crash or program termination loses all data.</p>\n<p><strong>Proposed Extension:</strong> Add a disk storage layer where each <code>BTreeNode</code> corresponds to a fixed-size disk page (e.g., 4KB). The <code>BTree</code> structure would manage a cache of recently accessed pages in memory and a mapping from node identifiers to disk locations.</p>\n<p><strong>Key Design Changes:</strong></p>\n<ol>\n<li><strong>Page-Oriented Node Allocation:</strong> Replace pointer-based child references (<code>BTreeNode** children</code>) with disk page IDs (e.g., <code>uint64_t</code>). Each node would have a unique <code>page_id</code>.</li>\n<li><strong>Buffer Pool Manager:</strong> Introduce a fixed-size cache (buffer pool) of loaded pages. The <code>btree_search/insert/delete</code> operations would request nodes from the buffer manager, which handles loading from disk and writing dirty pages back.</li>\n<li><strong>Serialization/Deserialization:</strong> Add functions <code>node_serialize</code> and <code>node_deserialize</code> to convert between in-memory <code>BTreeNode</code> structures and raw byte arrays (disk pages).</li>\n<li><strong>Free Space Management:</strong> Track unused pages (e.g., with a free list or bitmap) to reuse space from deleted nodes.</li>\n<li><strong>Root Pointer Persistence:</strong> Store the <code>page_id</code> of the root node at a fixed location on disk (e.g., the first 8 bytes of the file) to bootstrap the tree.</li>\n</ol>\n<blockquote>\n<p><strong>ADR: Page-Oriented vs. Log-Structured Node Storage</strong></p>\n<ul>\n<li><strong>Context:</strong> Need to persist B-tree nodes to disk with efficient read/write patterns.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Page-Oriented (Traditional):</strong> Each node occupies a fixed-size disk page at a stable location. Updates overwrite the page in-place.</li>\n<li><strong>Log-Structured (Append-Only):</strong> All node modifications are appended to a sequential log. A separate in-memory table maps node IDs to their latest log offsets.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Page-oriented storage for initial persistence extension.</li>\n<li><strong>Rationale:</strong> Page-oriented design is simpler to implement and matches the classic B-tree assumption of fixed-size disk blocks. It allows direct access to any node given its page ID without scanning a log. Overwrite-in-place is acceptable for a single-threaded implementation.</li>\n<li><strong>Consequences:</strong> Enables traditional database-style B-tree persistence. Requires careful handling of crash consistency (e.g., write-ahead logging for atomic operations) and fragmentation management over time.</li>\n</ul>\n</blockquote>\n<p><strong>Comparison of Disk Storage Approaches:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Page-Oriented (Fixed Location)</strong></td>\n<td>• Direct node access by page ID<br>• Simple implementation<br>• Matches textbook B-tree model</td>\n<td>• Fragmentation from deletions<br>• Crash consistency requires additional logging (WAL)<br>• Random writes may be slow on HDDs</td>\n<td>Traditional databases, educational clarity</td>\n</tr>\n<tr>\n<td><strong>Log-Structured (Append-Only)</strong></td>\n<td>• Sequential writes (faster on HDD/SSD)<br>• Built-in versioning/history<br>• Simplifies crash recovery (no torn pages)</td>\n<td>• Requires garbage collection (compaction)<br>• Need mapping table in memory (or itself logged)<br>• Extra indirection for reads</td>\n<td>Write-intensive workloads, SSDs, experimental storage engines</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Considerations:</strong></p>\n<ul>\n<li><strong>Page Size:</strong> Typically 4KB (file system block size) or larger (8KB, 16KB). Must fit <code>(2t-1)</code> keys, <code>(2t)</code> child pointers, and metadata.</li>\n<li><strong>Cache Eviction Policy:</strong> Least Recently Used (LRU) is a common choice for the buffer pool.</li>\n<li><strong>Concurrency:</strong> Disk I/O operations should be non-blocking (asynchronous) to avoid stalling the main thread during page loads.</li>\n</ul>\n<p><strong>Common Challenges:</strong></p>\n<ul>\n<li>⚠️ <strong>Pitfall: Ignoring Alignment</strong> — Disk pages must be aligned to block boundaries. Serializing structures with <code>sizeof(BTreeNode)</code> may not produce the exact page size, leading to wasted space or read errors.</li>\n<li>⚠️ <strong>Pitfall: No Crash Consistency</strong> — Writing a split node without ensuring the parent is updated can corrupt the tree after a crash. Requires a write-ahead log (WAL) for atomic multi-page operations.</li>\n</ul>\n<h4 id=\"1312-key-value-storage-with-associated-values\">13.1.2 Key-Value Storage with Associated Values</h4>\n<p><strong>Mental Model: The Library Card Catalog</strong>\nThe current B-tree acts like a simple index of book accession numbers (keys). Adding associated values transforms it into a full card catalog: each card (node entry) contains both the accession number (key) and detailed information about the book—title, author, location (value). The tree organizes the cards by accession number for quick lookup, but the valuable data is the book information attached to each key.</p>\n<p><strong>Current Limitation:</strong> The <code>BTreeNode</code> structure includes a <code>values void**</code> array, but the core algorithms ignore it. The <code>btree_insert</code> accepts a <code>value void*</code> but doesn&#39;t store or retrieve it.</p>\n<p><strong>Proposed Extension:</strong> Fully integrate the value pointers into all operations. Each key in a leaf node would have an associated value pointer. Internal nodes would continue to have <code>NULL</code> values for their keys (which are only separators).</p>\n<p><strong>Key Design Changes:</strong></p>\n<ol>\n<li><strong>Value Storage in Leaves:</strong> Modify <code>node_insert_key</code> and <code>node_remove_key</code> to handle the parallel <code>values</code> array. When inserting a key at index <code>i</code>, also insert the value pointer at the same index in the <code>values</code> array.</li>\n<li><strong>Search Returns Value:</strong> Update <code>btree_search</code> and <code>search_recursive</code> to return the <code>value void*</code> in the <code>SearchResult</code> when a key is found at a leaf.</li>\n<li><strong>Value Propagation During Splits:</strong> When splitting a leaf node, copy value pointers along with keys to the new node. For internal node splits, values for the promoted key are irrelevant (can be <code>NULL</code>).</li>\n<li><strong>Value Deletion:</strong> Ensure <code>btree_delete</code> properly handles the value pointer—either freeing it if the tree owns the memory, or returning it to the caller for external management.</li>\n</ol>\n<blockquote>\n<p><strong>ADR: Inline Values vs. Indirect Storage</strong></p>\n<ul>\n<li><strong>Context:</strong> Need to store variable-sized or large values associated with keys.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Inline Storage (Current):</strong> Store value pointers directly in the node&#39;s <code>values</code> array. The pointer points to external memory.</li>\n<li><strong>Indirect Storage (Value Log):</strong> Store values in a separate append-only log or heap file. The node stores only a small value handle (e.g., offset in log) instead of a pointer.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Keep inline storage with <code>void*</code> pointers for simplicity in the initial extension.</li>\n<li><strong>Rationale:</strong> Direct pointers are easiest to implement and understand. They allow the B-tree to store references to any data structure. The caller manages memory allocation for values, keeping the B-tree focused on structure.</li>\n<li><strong>Consequences:</strong> Values must fit in memory. The tree doesn&#39;t handle variable-sized values efficiently (all pointers are same size). For disk persistence, values would need separate storage strategy.</li>\n</ul>\n</blockquote>\n<p><strong>Comparison of Value Storage Strategies:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Strategy</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Inline Pointers (Current)</strong></td>\n<td>• Simple implementation<br>• Fast in-memory access<br>• Can point to any data type</td>\n<td>• Not disk-persistent directly<br>• Variable-sized values waste space or require separate allocation<br>• Pointers become invalid after program restart</td>\n<td>In-memory caches, indices over existing objects</td>\n</tr>\n<tr>\n<td><strong>Separate Value Log</strong></td>\n<td>• Values can be variable-sized<br>• Efficient disk persistence (sequential writes)<br>• Can compress values independently</td>\n<td>• Extra indirection (slower)<br>• Requires garbage collection for deleted values<br>• More complex to implement</td>\n<td>Database storage engines, key-value stores (e.g., RocksDB)</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Considerations:</strong></p>\n<ul>\n<li><strong>Memory Management:</strong> Who owns the value memory? The B-tree could adopt values (free on delete) or just store references (caller manages). A hybrid approach with a <code>free_value_fn</code> callback is flexible.</li>\n<li><strong>Duplicate Keys:</strong> The B-tree typically assumes unique keys. If duplicates are allowed, values must be stored for each duplicate, possibly as a list per key.</li>\n</ul>\n<p><strong>Common Challenges:</strong></p>\n<ul>\n<li>⚠️ <strong>Pitfall: Value Pointer Misalignment</strong> — When splitting or merging nodes, forgetting to copy/move value pointers along with keys corrupts the value-key association.</li>\n<li>⚠️ <strong>Pitfall: Memory Leaks</strong> — Deleting a key without freeing its associated value (if the tree owns it) leaks memory. Similarly, overwriting a key during insertion might leak the old value.</li>\n</ul>\n<h4 id=\"1313-concurrency-control-multi-threading\">13.1.3 Concurrency Control (Multi-Threading)</h4>\n<p><strong>Mental Model: The Library with Multiple Librarians</strong>\nImagine a library where several librarians (threads) can simultaneously help patrons. Without coordination, two librarians might try to update the same catalog drawer (node) at once, leading to chaos. Concurrency control provides a system like &quot;sign-out sheets&quot; for drawers: a librarian must acquire a lock on a drawer before modifying it, and perhaps follow a protocol to prevent deadlock (e.g., always request locks top-down).</p>\n<p><strong>Current Limitation:</strong> The implementation is single-threaded. Concurrent <code>insert</code> and <code>search</code> operations from multiple threads would cause data races, leading to corruption or crashes.</p>\n<p><strong>Proposed Extension:</strong> Add fine-grained locking to allow safe concurrent operations. Common approaches include:</p>\n<ul>\n<li><strong>Readers-Writer Locks (Pessimistic):</strong> Each node has a read-write lock. Searches acquire read locks; insertions/deletions acquire write locks on nodes along their path.</li>\n<li><strong>B-link Tree (Optimistic):</strong> A variant where nodes have a &quot;high key&quot; and a link pointer to the right sibling. Searches can proceed without locks; insertions use careful atomic operations and retry mechanisms.</li>\n<li><strong>Copy-on-Write (Persistent):</strong> Each modification creates new versions of nodes along the path, enabling snapshot isolation and lock-free reads.</li>\n</ul>\n<p><strong>Key Design Changes:</strong></p>\n<ol>\n<li><strong>Node-Level Locking:</strong> Add a <code>pthread_rwlock_t</code> (or equivalent) field to <code>BTreeNode</code>. All operations must acquire appropriate locks as they traverse.</li>\n<li><strong>Lock Coupling (Crabbing):</strong> To prevent deadlock and ensure consistency, hold the lock on a parent while acquiring the lock on a child. Release parent lock after child is locked (for writes).</li>\n<li><strong>Deadlock Avoidance:</strong> Always acquire locks in a consistent order (e.g., top-down, left-to-right).</li>\n<li><strong>Root Handling:</strong> The root may change during splits. Need a special lock or version number for the root pointer.</li>\n</ol>\n<blockquote>\n<p><strong>ADR: Fine-Grained Locking vs. B-link Tree</strong></p>\n<ul>\n<li><strong>Context:</strong> Need to support concurrent operations without sacrificing correctness.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Fine-Grained Read-Write Locks:</strong> Traditional approach using lock coupling (crabbing). Simple to understand but can lead to contention at high levels.</li>\n<li><strong>B-link Tree with Optimistic Concurrency:</strong> A B-tree variant with sibling links that allows lock-free searches and non-blocking inserts using atomic compare-and-swap (CAS) operations.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Start with fine-grained read-write locks for educational purposes.</li>\n<li><strong>Rationale:</strong> Lock coupling directly extends the existing algorithms with clear critical sections. It&#39;s easier to implement and debug than B-link trees, which require significant algorithmic changes.</li>\n<li><strong>Consequences:</strong> Provides thread safety but may limit scalability under high contention. Deadlock risk requires careful lock ordering.</li>\n</ul>\n</blockquote>\n<p><strong>Comparison of Concurrency Approaches:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fine-Grained Read-Write Locks</strong></td>\n<td>• Conceptually straightforward<br>• Minimal changes to existing algorithms<br>• Well-understood deadlock avoidance protocols</td>\n<td>• Lock overhead per node<br>• Contention at root and hot nodes<br>• Deadlock risk if ordering violated</td>\n<td>Moderate concurrency, educational implementation</td>\n</tr>\n<tr>\n<td><strong>B-link Tree (Optimistic)</strong></td>\n<td>• Lock-free reads (scalable)<br>• Non-blocking inserts<br>• Avoids deadlock by design</td>\n<td>• Complex to implement correctly<br>• Requires atomic operations (CAS)<br>• Algorithm differs from classic B-tree</td>\n<td>High-concurrency databases (e.g., LMDB, WiredTiger)</td>\n</tr>\n<tr>\n<td><strong>Copy-on-Write (Persistent)</strong></td>\n<td>• Naturally provides snapshot isolation<br>• Readers never block writers<br>• Good for versioned data</td>\n<td>• High write amplification<br>• Requires garbage collection of old nodes<br>• Memory/disk overhead</td>\n<td>Multi-version systems, temporal databases, file systems (ZFS, Btrfs)</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Considerations:</strong></p>\n<ul>\n<li><strong>Lock Granularity:</strong> Locking at the node level is fine-grained but adds memory overhead. Coarser granularity (e.g., locking entire tree) would destroy concurrency.</li>\n<li><strong>Recovery from Deadlocks:</strong> Use timeout mechanisms or deadlock detection if not strictly ordering locks.</li>\n<li><strong>Performance:</strong> Under high contention, the root node becomes a bottleneck. Techniques like root splitting or root versioning can help.</li>\n</ul>\n<p><strong>Common Challenges:</strong></p>\n<ul>\n<li>⚠️ <strong>Pitfall: Forgotten Unlock</strong> — In complex recursive functions with multiple return paths, failing to unlock a node before returning leads to deadlock.</li>\n<li>⚠️ <strong>Pitfall: Lock Ordering Violation</strong> — Acquiring locks on two children in arbitrary order (e.g., during borrowing from sibling) can cause deadlock. Must always lock left-to-right or right-to-left.</li>\n</ul>\n<h4 id=\"1314-b-tree-and-b-tree-variants\">13.1.4 B+ Tree and B* Tree Variants</h4>\n<p><strong>Mental Model: Specialized Library Catalog Systems</strong></p>\n<ul>\n<li><strong>B+ Tree:</strong> Imagine a library catalog where the main index (internal nodes) contains only guide keys, and all actual book records (values) are stored in a separate, linked set of leaf pages. This is like having an index volume that points to specific shelves where books are stored contiguously.</li>\n<li><em><em>B</em> Tree:</em>* Imagine a library that avoids creating new shelves until absolutely necessary. When a shelf becomes full, instead of immediately splitting it, librarians first try to redistribute books to neighboring shelves. Only when three adjacent shelves are all full do they split two of them into three. This maximizes space utilization.</li>\n</ul>\n<p><strong>Current Limitation:</strong> The implementation is a classic B-tree where values <em>could</em> be stored in internal nodes (though our design leaves them NULL). This is less efficient for range scans and has lower node occupancy on average than B* trees.</p>\n<p><strong>Proposed Extensions:</strong></p>\n<p><strong>B+ Tree Modifications:</strong></p>\n<ol>\n<li><strong>Leaf Node Linking:</strong> Add <code>BTreeNode* next</code> pointer to each leaf node, creating a linked list of all leaves in key order.</li>\n<li><strong>Value Storage Only in Leaves:</strong> Internal nodes store only keys and child pointers—no value pointers. All values reside in leaf nodes.</li>\n<li><strong>Search Always Goes to Leaf:</strong> Even if a key is found in an internal node during search, continue descending to the leaf to retrieve the associated value.</li>\n<li><strong>Range Scans:</strong> Implement <code>btree_range_scan(start_key, end_key)</code> that finds the leaf for <code>start_key</code> and traverses the leaf linked list until exceeding <code>end_key</code>.</li>\n<li><strong>Split Differences:</strong> When splitting a leaf, update the <code>next</code> pointers accordingly. The promoted key to the parent is the <em>first key of the right sibling</em> (not necessarily a key that exists in the left sibling).</li>\n</ol>\n<p><em><em>B</em> Tree Modifications:</em>*</p>\n<ol>\n<li><strong>Higher Minimum Occupancy:</strong> Instead of splitting a node when it reaches <code>2t-1</code> keys, try to redistribute keys to a sibling first. Only split when both the node and its immediate sibling are full.</li>\n<li><strong>Three-Node Split:</strong> When splitting is unavoidable, involve two full siblings and distribute keys among three nodes (two original plus one new), leading to better space utilization (nodes are at least 2/3 full).</li>\n<li><strong>Modified Insertion Algorithm:</strong> During descent, if a child is full, first check if an adjacent sibling has space. If yes, redistribute keys between the child, sibling, and parent. If no adjacent sibling has space, then perform a split that involves the child and one sibling.</li>\n</ol>\n<blockquote>\n<p><strong>ADR: B+ Tree vs. Classic B-tree for Range Queries</strong></p>\n<ul>\n<li><strong>Context:</strong> Need efficient range scans (e.g., &quot;find all keys between 100 and 200&quot;) and sequential access.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Classic B-tree:</strong> Values can be anywhere. Range scans require complex traversal jumping between internal and leaf nodes.</li>\n<li><strong>B+ Tree:</strong> All values in leaves, with leaves linked sequentially.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Implement B+ tree extension if range queries are important.</li>\n<li><strong>Rationale:</strong> B+ trees are the standard for database indices because they optimize for both random lookups and range scans. The leaf linkage makes scanning orders of magnitude faster (no need to backtrack up the tree).</li>\n<li><strong>Consequences:</strong> Slightly more complex insertion/deletion due to leaf linking. Internal nodes store only keys (smaller, higher fanout). Duplicate key handling is cleaner (all duplicates go to leaves).</li>\n</ul>\n</blockquote>\n<p><strong>Comparison of B-tree Variants:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Variant</th>\n<th>Key Characteristics</th>\n<th>Advantages</th>\n<th>Disadvantages</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Classic B-tree</strong></td>\n<td>Keys and values may be in internal nodes</td>\n<td>• Simpler algorithms<br>• Can store &quot;hot&quot; data higher in tree</td>\n<td>• Less efficient for range scans<br>• Lower fanout if values are large</td>\n</tr>\n<tr>\n<td><strong>B+ Tree</strong></td>\n<td>All values in leaves, leaves linked</td>\n<td>• Excellent for range scans/sequential access<br>• Higher fanout in internal nodes<br>• Predictable access pattern (always to leaf)</td>\n<td>• Extra pointer per leaf<br>• Two different node types (internal vs leaf)</td>\n</tr>\n<tr>\n<td><em><em>B</em> Tree</em>*</td>\n<td>Redistributes before splitting, nodes ≥ 2/3 full</td>\n<td>• Higher space utilization (less wasted disk)<br>• Fewer splits, potentially lower height</td>\n<td>• More complex insertion logic<br>• Redistribution overhead</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Considerations:</strong></p>\n<ul>\n<li><strong>Backward Compatibility:</strong> Could maintain the same external API (<code>btree_insert</code>, <code>btree_search</code>) but change internal behavior. Range scan would be a new API.</li>\n<li><strong>Hybrid Approach:</strong> Allow configuration at tree creation time (<code>btree_create(t, variant)</code>).</li>\n<li><strong>Testing:</strong> Each variant requires specific test cases for redistribution and linking.</li>\n</ul>\n<p><strong>Common Challenges:</strong></p>\n<ul>\n<li>⚠️ <strong>Pitfall: Broken Leaf Links</strong> — During split or merge of leaves, incorrectly updating <code>next</code> pointers breaks the sequential scan.</li>\n<li>⚠️ <strong>Pitfall: Redistribution Complexity</strong> — B* tree redistribution requires careful handling of keys and children across three nodes (two siblings and parent). Off-by-one errors are common.</li>\n</ul>\n<h3 id=\"132-additional-extension-opportunities\">13.2 Additional Extension Opportunities</h3>\n<p>Beyond the major extensions above, several other enhancements could improve utility or performance:</p>\n<ul>\n<li><strong>Bulk Loading:</strong> Construct a B-tree efficiently from a pre-sorted set of keys (e.g., from a CSV file) by building the tree bottom-up rather than repeated insertion. This produces a perfectly balanced tree with higher leaf occupancy and is much faster.</li>\n<li><strong>Compression:</strong> Store keys in nodes using prefix compression (especially useful for string keys) to increase effective fanout and reduce I/O.</li>\n<li><strong>Variable-Length Keys:</strong> Support keys of arbitrary length (e.g., strings) by storing them within the node&#39;s byte array with offset pointers, rather than fixed-size <code>int</code> keys.</li>\n<li><strong>Transactional Support:</strong> Group multiple insert/delete operations into atomic transactions with rollback capability, using an undo log.</li>\n<li><strong>Monitoring and Metrics:</strong> Expose internal statistics (node counts, split/merge frequencies, average occupancy) for performance tuning.</li>\n</ul>\n<h3 id=\"133-implementation-guidance\">13.3 Implementation Guidance</h3>\n<blockquote>\n<p><strong>Note:</strong> The following guidance provides starting points for the most practical extension: adding associated values and simple persistence. These are the most likely next steps for a learner wanting to build a usable key-value store.</p>\n</blockquote>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Persistence Layer</strong></td>\n<td>Fixed-size binary file with direct I/O (<code>fread</code>/<code>fwrite</code>)</td>\n<td>Memory-mapped files (<code>mmap</code>) with page fault handling</td>\n</tr>\n<tr>\n<td><strong>Concurrency Control</strong></td>\n<td>Single global mutex for entire tree (<code>pthread_mutex</code>)</td>\n<td>Fine-grained per-node read-write locks (<code>pthread_rwlock_t</code>)</td>\n</tr>\n<tr>\n<td><strong>Value Storage</strong></td>\n<td><code>void*</code> pointers to caller-managed memory</td>\n<td>Separate value log file with offset-based handles</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure for Extended Project:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>btree/\n├── include/\n│   └── btree.h                 # Public API (unchanged)\n├── src/\n│   ├── btree.c                # Core B-tree algorithms (modified for values)\n│   ├── node.c                 # Node operations\n│   ├── disk_pager.c           # NEW: Buffer pool and disk I/O\n│   ├── value_log.c            # NEW: Optional value storage\n│   └── concurrent.c           # NEW: Locking wrappers (if adding concurrency)\n├── tests/\n│   └── test_extended.c        # Tests for extended features\n└── tools/\n    └── btree_dump.c           # Utility to inspect on-disk structure</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Disk Pager Header):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// disk_pager.h - Simple disk persistence layer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> DISK_PAGER_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DISK_PAGER_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_SIZE</span><span style=\"color:#79B8FF\"> 4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> INVALID_PAGE_ID</span><span style=\"color:#E1E4E8\"> UINT64_MAX</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#79B8FF\"> page_id_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Disk page representation (matches node serialized size)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> bytes</span><span style=\"color:#E1E4E8\">[PAGE_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">disk_page_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Buffer pool entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> bp_entry {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_id_t</span><span style=\"color:#E1E4E8\"> page_id;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    disk_page_t</span><span style=\"color:#E1E4E8\"> page;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> is_dirty;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> bp_entry</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\">   // For LRU list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> bp_entry</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">bp_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main pager structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd;</span><span style=\"color:#6A737D\">                     // File descriptor for database file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> num_pages;</span><span style=\"color:#6A737D\">         // Total pages in file</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    bp_entry_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> lru_head;</span><span style=\"color:#6A737D\">       // Most recently used</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    bp_entry_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> lru_tail;</span><span style=\"color:#6A737D\">       // Least recently used</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    bp_entry_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> entries;</span><span style=\"color:#6A737D\">        // Array of all buffer entries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_entries;</span><span style=\"color:#6A737D\">            // Size of buffer pool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">disk_pager_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Public interface</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">disk_pager_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> pager_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> filename</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> cache_pages</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pager_close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">disk_pager_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> pager</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">disk_page_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> pager_fetch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">disk_pager_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> pager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_id_t</span><span style=\"color:#FFAB70\"> page_id</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pager_mark_dirty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">disk_pager_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> pager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_id_t</span><span style=\"color:#FFAB70\"> page_id</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">page_id_t</span><span style=\"color:#B392F0\"> pager_allocate_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">disk_pager_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> pager</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pager_deallocate_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">disk_pager_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> pager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_id_t</span><span style=\"color:#FFAB70\"> page_id</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">page_id_t</span><span style=\"color:#B392F0\"> pager_get_root_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">disk_pager_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> pager</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pager_set_root_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">disk_pager_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> pager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_id_t</span><span style=\"color:#FFAB70\"> root_id</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // DISK_PAGER_H</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton (B-tree with Values and Disk Integration):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Modified BTree structure with disk pager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_id_t</span><span style=\"color:#E1E4E8\"> root_page_id;</span><span style=\"color:#6A737D\">   // Disk page ID of root (instead of pointer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> t;</span><span style=\"color:#6A737D\">                    // Minimum degree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> key_count;</span><span style=\"color:#6A737D\">         // Total keys (cached for O(1) access)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    disk_pager_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> pager;</span><span style=\"color:#6A737D\">      // Disk pager instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BTree;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Public API with values (unchanged signatures, but now values are stored)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> btree_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> filename</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> min_degree</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SearchResult </span><span style=\"color:#B392F0\">btree_search</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> btree_delete</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Internal function now works with page IDs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> node_load</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_id_t</span><span style=\"color:#FFAB70\"> page_id</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Call pager_fetch to get disk page for page_id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Deserialize disk page bytes into a BTreeNode structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return the in-memory node (caller must eventually release)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> node_save</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, BTreeNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_id_t</span><span style=\"color:#FFAB70\"> page_id</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Serialize BTreeNode into disk_page_t.bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call pager_mark_dirty so page gets written back eventually</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If this is a new node, assign it a page_id via pager_allocate_page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Example modified search recursive function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> SearchResult </span><span style=\"color:#B392F0\">search_recursive_disk</span><span style=\"color:#E1E4E8\">(BTree</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_id_t</span><span style=\"color:#FFAB70\"> current_page_id</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load node using node_load(tree, current_page_id)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Perform binary search within node's keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If key found and node is leaf, return value from node->values[index]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If key not found and node is leaf, return not found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If internal node, determine child index and recursively call search_recursive_disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Release node from buffer pool (implementation dependent)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints (C):</strong></p>\n<ul>\n<li>Use <code>open()</code> with <code>O_DIRECT</code> flag for aligned direct I/O (bypasses kernel cache, more realistic for database engines).</li>\n<li>For serialization, consider using <code>memcpy()</code> between struct fields and byte arrays, but beware of padding bytes. Explicitly pack structures with <code>#pragma pack(1)</code> or manual byte-by-byte copying.</li>\n<li>Memory management for values: Provide a callback registration mechanism: <code>btree_set_free_value_callback(BTree*, void (*free_fn)(void*))</code> to allow custom cleanup.</li>\n<li>For concurrency, use <code>pthread_rwlock_init</code> in <code>node_create</code> and <code>pthread_rwlock_destroy</code> in <code>node_destroy</code>.</li>\n</ul>\n<p><strong>Milestone Checkpoint for Persistence Extension:</strong></p>\n<ol>\n<li><strong>Implement pager with LRU cache:</strong> Test by creating a file, allocating pages, and reading them back.</li>\n<li><strong>Add node serialization:</strong> Write a test that creates a small tree in memory, serializes all nodes to disk, then reloads and verifies structure with <code>btree_validate</code>.</li>\n<li><strong>Integrated operations:</strong> After full integration, run a sequence of insertions, persist, close/reopen the file, and verify searches return correct values. Use a tool like <code>hexdump</code> to inspect the raw disk file.</li>\n</ol>\n<p><strong>Debugging Tips for Disk Extensions:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Read wrong data after reload&quot;</td>\n<td>Serialization/deserialization mismatch</td>\n<td>Add debug prints showing byte-by-byte comparison of original vs loaded node</td>\n<td>Ensure all fields (especially child pointers converted to page IDs) are serialized</td>\n</tr>\n<tr>\n<td>&quot;Segfault in buffer pool&quot;</td>\n<td>LRU list corruption</td>\n<td>Add assertions after each list operation; draw diagram of list before/after each fetch</td>\n<td>Carefully maintain <code>next</code>/<code>prev</code> pointers in doubly-linked LRU</td>\n</tr>\n<tr>\n<td>&quot;File size grows uncontrollably&quot;</td>\n<td>Never deallocate pages on delete</td>\n<td>Log each <code>pager_allocate_page</code> and <code>pager_deallocate_page</code> call</td>\n<td>Implement free page list in pager header page</td>\n</tr>\n<tr>\n<td>&quot;Value pointer becomes invalid after reload&quot;</td>\n<td>Storing raw pointers instead of data</td>\n<td>Pointers are memory addresses; they have no meaning after restart</td>\n<td>For persistence, store values inline or in separate value log with offsets</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"14-glossary\">14. Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 1-4 (all operations)<br>This section provides concise definitions for key terminology used throughout the B-tree design document, serving as a quick reference for readers encountering unfamiliar terms. Each entry references the primary section where the concept is first introduced or explained in detail.</p>\n</blockquote>\n<h3 id=\"term-definitions\">Term Definitions</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Primary Reference</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Binary search</strong></td>\n<td>An algorithm for finding a target value within a sorted array by repeatedly dividing the search interval in half. In B-trees, used within a node&#39;s key array to efficiently locate a target key or determine which child to traverse to.</td>\n<td>Section 6: Component Design: Search Operation</td>\n</tr>\n<tr>\n<td><strong>Borrowing</strong></td>\n<td>An operation during deletion that transfers a key from a sibling node through the parent to fix an underflow condition in a node. This redistributes keys without merging nodes, preserving tree structure when possible.</td>\n<td>Section 8: Component Design: Deletion with Rebalancing</td>\n</tr>\n<tr>\n<td><strong>B+ tree</strong></td>\n<td>A B-tree variant where all data values are stored only in leaf nodes, and internal nodes contain only keys for routing. Leaf nodes are typically linked together to support efficient range scans.</td>\n<td>Section 13: Future Extensions</td>\n</tr>\n<tr>\n<td><strong>B* tree</strong></td>\n<td>A B-tree variant that delays splitting by first attempting to redistribute keys to neighboring nodes when a node becomes full, resulting in higher average node occupancy.</td>\n<td>Section 13: Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Buffer pool</strong></td>\n<td>A cache of recently accessed disk pages maintained in memory, used in persistent storage implementations to reduce disk I/O by keeping frequently accessed nodes available without reading from disk each time.</td>\n<td>Section 13: Future Extensions (Future Extensions)</td>\n</tr>\n<tr>\n<td><strong>B-tree</strong></td>\n<td>A self-balancing tree data structure optimized for systems that read and write large blocks of data (like databases and file systems). Maintains sorted data and allows search, insertion, and deletion in logarithmic time while minimizing disk accesses through high fanout.</td>\n<td>Section 1: Context and Problem Statement</td>\n</tr>\n<tr>\n<td><strong>Capacity bounds</strong></td>\n<td>The minimum and maximum number of keys allowed in a B-tree node based on the minimum degree <em>t</em>. Every node except the root must contain between <em>t</em>-1 and 2<em>t</em>-1 keys. The root may have as few as 1 key.</td>\n<td>Section 5: Component Design: B-tree Node</td>\n</tr>\n<tr>\n<td><strong>Disk block/page</strong></td>\n<td>The unit of data transfer between disk and memory, typically 4KB. B-tree nodes are designed to align with these fixed-size blocks to optimize I/O efficiency.</td>\n<td>Section 1: Context and Problem Statement</td>\n</tr>\n<tr>\n<td><strong>Fanout</strong></td>\n<td>The number of children per internal node in a tree. In B-trees, the fanout is typically high (dozens to hundreds) because each node holds many keys, which reduces tree height and disk seeks.</td>\n<td>Section 4: Data Model</td>\n</tr>\n<tr>\n<td><strong>Height</strong></td>\n<td>The number of levels from the root node to the leaf nodes in a tree. B-trees maintain logarithmic height relative to the total number of keys, ensuring efficient operations.</td>\n<td>Section 4: Data Model</td>\n</tr>\n<tr>\n<td><strong>In-order predecessor</strong></td>\n<td>The largest key in the left subtree of a given key. Used during deletion from internal nodes when replacing the target key before recursively deleting the replacement.</td>\n<td>Section 8: Component Design: Deletion with Rebalancing</td>\n</tr>\n<tr>\n<td><strong>In-order successor</strong></td>\n<td>The smallest key in the right subtree of a given key. Alternative to the predecessor for internal node deletion.</td>\n<td>Section 8: Component Design: Deletion with Rebalancing</td>\n</tr>\n<tr>\n<td><strong>Invariants</strong></td>\n<td>Mathematical rules that must always hold true for the data structure to be valid. B-tree invariants include key count bounds, sorted order of keys within nodes, and balanced height of all leaf nodes.</td>\n<td>Section 4: Data Model</td>\n</tr>\n<tr>\n<td><strong>Lock coupling</strong></td>\n<td>A concurrency control technique where a thread holds a lock on a parent node while acquiring a lock on a child node, preventing deadlock in multi-threaded B-tree implementations.</td>\n<td>Section 13: Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Minimum degree (t)</strong></td>\n<td>The fundamental parameter defining capacity bounds in a B-tree. Each node (except root) must have at least <em>t</em>-1 keys and at most 2<em>t</em>-1 keys. The value <em>t</em> determines the tree&#39;s fanout and balance properties.</td>\n<td>Section 5: Component Design: B-tree Node</td>\n</tr>\n<tr>\n<td><strong>Node access</strong></td>\n<td>The act of reading a node from disk or memory. A key performance metric for B-trees, as operations aim to minimize node accesses (especially disk I/O) by keeping tree height low.</td>\n<td>Section 6: Component Design: Search Operation</td>\n</tr>\n<tr>\n<td><strong>Node merging</strong></td>\n<td>An operation during deletion that combines two underfull sibling nodes and the separating key from their parent into one node when borrowing is not possible. Reduces the number of nodes and may propagate up the tree.</td>\n<td>Section 8: Component Design: Deletion with Rebalancing</td>\n</tr>\n<tr>\n<td><strong>Node splitting</strong></td>\n<td>An operation during insertion that divides a full node (with 2<em>t</em>-1 keys) into two nodes, each with <em>t</em>-1 keys, and promotes the middle key to the parent node. Maintains capacity bounds when inserting into a full node.</td>\n<td>Section 7: Component Design: Insertion with Splitting</td>\n</tr>\n<tr>\n<td><strong>Opaque pointer</strong></td>\n<td>A pointer to an incomplete (forward-declared) type that hides implementation details from the user, promoting encapsulation. Used in the public API to abstract the internal <code>BTreeNode</code> structure.</td>\n<td>Section 3: High-Level Architecture</td>\n</tr>\n<tr>\n<td><strong>Page-oriented storage</strong></td>\n<td>A persistence model where each B-tree node occupies a fixed-size disk block (page) at a stable location, enabling direct mapping between node pointers and disk addresses.</td>\n<td>Section 5: Component Design: B-tree Node (Milestone 1 Deliverables)</td>\n</tr>\n<tr>\n<td><strong>Proactive splitting</strong></td>\n<td>A strategy where full nodes are split during the downward traversal for insertion, before the actual insertion occurs. This ensures that any node we descend into has room for an extra key if needed.</td>\n<td>Section 7: Component Design: Insertion with Splitting</td>\n</tr>\n<tr>\n<td><strong>Range scan</strong></td>\n<td>An operation that retrieves all keys and their associated values within a specified interval [start_key, end_key]. Efficiently supported in B+ trees through linked leaf nodes.</td>\n<td>Section 13: Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Recursive traversal</strong></td>\n<td>A method of traversing tree structures where a function calls itself to process subtrees. Used in B-tree operations to navigate from the root to leaves.</td>\n<td>Section 6: Component Design: Search Operation</td>\n</tr>\n<tr>\n<td><strong>Strengthening</strong></td>\n<td>The process of proactively ensuring a child node has at least <em>t</em> keys before descending into it during deletion. Achieved through borrowing from a sibling or merging with a sibling, preventing underflow during the recursive deletion process.</td>\n<td>Section 8: Component Design: Deletion with Rebalancing</td>\n</tr>\n<tr>\n<td><strong>Underflow</strong></td>\n<td>A condition where a node has fewer than <em>t</em>-1 keys, violating the B-tree invariant. Occurs after deletion and must be resolved through borrowing or merging to restore the minimum occupancy requirement.</td>\n<td>Section 8: Component Design: Deletion with Rebalancing</td>\n</tr>\n</tbody></table>\n","toc":[{"level":1,"text":"B-tree Implementation: Design Document","id":"b-tree-implementation-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"1. Context and Problem Statement","id":"1-context-and-problem-statement"},{"level":3,"text":"The Disk Access Problem and B-tree Solution","id":"the-disk-access-problem-and-b-tree-solution"},{"level":3,"text":"Mental Model: The Library Catalog Analogy","id":"mental-model-the-library-catalog-analogy"},{"level":3,"text":"Comparison with Other Tree Structures","id":"comparison-with-other-tree-structures"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"2. Goals and Non-Goals","id":"2-goals-and-non-goals"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":3,"text":"Non-Functional Goals &amp; Non-Goals","id":"non-functional-goals-amp-non-goals"},{"level":3,"text":"Common Pitfalls: Misinterpreting Scope","id":"common-pitfalls-misinterpreting-scope"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Milestone Checkpoint: After Setting Up Foundations","id":"d-milestone-checkpoint-after-setting-up-foundations"},{"level":4,"text":"E. Language-Specific Hints (C)","id":"e-language-specific-hints-c"},{"level":2,"text":"3. High-Level Architecture","id":"3-high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":4,"text":"Component Interactions and Data Flow","id":"component-interactions-and-data-flow"},{"level":3,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure (Code Layout)","id":"b-recommended-filemodule-structure-code-layout"},{"level":4,"text":"C. Language-Specific Hints (C)","id":"c-language-specific-hints-c"},{"level":2,"text":"4. Data Model","id":"4-data-model"},{"level":3,"text":"Core Types and Structures","id":"core-types-and-structures"},{"level":3,"text":"B-tree Invariants","id":"b-tree-invariants"},{"level":3,"text":"Common Pitfalls: Data Model Misunderstandings","id":"common-pitfalls-data-model-misunderstandings"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints for C","id":"language-specific-hints-for-c"},{"level":4,"text":"Milestone Checkpoint: Data Structure Validation","id":"milestone-checkpoint-data-structure-validation"},{"level":2,"text":"5. Component Design: B-tree Node","id":"5-component-design-b-tree-node"},{"level":3,"text":"Mental Model: A Bookshelf with Dividers","id":"mental-model-a-bookshelf-with-dividers"},{"level":3,"text":"Interface and Operations","id":"interface-and-operations"},{"level":3,"text":"ADR: Node Memory Layout","id":"adr-node-memory-layout"},{"level":3,"text":"Common Pitfalls: Node Capacity","id":"common-pitfalls-node-capacity"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"6. Component Design: Search Operation","id":"6-component-design-search-operation"},{"level":3,"text":"Mental Model: Finding a Topic in a Textbook","id":"mental-model-finding-a-topic-in-a-textbook"},{"level":3,"text":"Search Algorithm Steps","id":"search-algorithm-steps"},{"level":3,"text":"ADR: Recursive vs. Iterative Search","id":"adr-recursive-vs-iterative-search"},{"level":3,"text":"Common Pitfalls: Search Logic","id":"common-pitfalls-search-logic"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints for C","id":"e-language-specific-hints-for-c"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"7. Component Design: Insertion with Splitting","id":"7-component-design-insertion-with-splitting"},{"level":3,"text":"Mental Model: Adding a Book to a Full Shelf","id":"mental-model-adding-a-book-to-a-full-shelf"},{"level":3,"text":"Insertion and Split Algorithm Steps","id":"insertion-and-split-algorithm-steps"},{"level":4,"text":"Overall Insertion Flow","id":"overall-insertion-flow"},{"level":4,"text":"Node Splitting Subroutine (node_split_child)","id":"node-splitting-subroutine-node_split_child"},{"level":3,"text":"ADR: Proactive vs. Reactive Splitting","id":"adr-proactive-vs-reactive-splitting"},{"level":3,"text":"Common Pitfalls: Splitting and Promotion","id":"common-pitfalls-splitting-and-promotion"},{"level":4,"text":"⚠️ Pitfall 1: Splitting Non-Full Nodes","id":"-pitfall-1-splitting-non-full-nodes"},{"level":4,"text":"⚠️ Pitfall 2: Incorrect Median Index Calculation","id":"-pitfall-2-incorrect-median-index-calculation"},{"level":4,"text":"⚠️ Pitfall 3: Forgetting to Update Child Pointers After Split","id":"-pitfall-3-forgetting-to-update-child-pointers-after-split"},{"level":4,"text":"⚠️ Pitfall 4: Mishandling Root Split","id":"-pitfall-4-mishandling-root-split"},{"level":4,"text":"⚠️ Pitfall 5: Ignoring the Leaf Flag During Split","id":"-pitfall-5-ignoring-the-leaf-flag-during-split"},{"level":4,"text":"⚠️ Pitfall 6: Not Adjusting Search Index After Split","id":"-pitfall-6-not-adjusting-search-index-after-split"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints for C","id":"language-specific-hints-for-c"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"8. Component Design: Deletion with Rebalancing","id":"8-component-design-deletion-with-rebalancing"},{"level":3,"text":"Mental Model: Removing a Book and Consolidating Shelves","id":"mental-model-removing-a-book-and-consolidating-shelves"},{"level":3,"text":"Deletion and Rebalance Algorithm Steps","id":"deletion-and-rebalance-algorithm-steps"},{"level":4,"text":"Main Deletion Procedure","id":"main-deletion-procedure"},{"level":4,"text":"State Transitions During Deletion","id":"state-transitions-during-deletion"},{"level":3,"text":"ADR: Predecessor vs. Successor for Internal Delete","id":"adr-predecessor-vs-successor-for-internal-delete"},{"level":3,"text":"Common Pitfalls: Borrow vs. Merge Logic","id":"common-pitfalls-borrow-vs-merge-logic"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"9. Interactions and Data Flow","id":"9-interactions-and-data-flow"},{"level":3,"text":"Sequence of Operations","id":"sequence-of-operations"},{"level":4,"text":"Search Operation Sequence","id":"search-operation-sequence"},{"level":4,"text":"Insertion with Splitting Sequence","id":"insertion-with-splitting-sequence"},{"level":4,"text":"Deletion with Rebalancing Sequence","id":"deletion-with-rebalancing-sequence"},{"level":3,"text":"State Transitions During Operations","id":"state-transitions-during-operations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Recommended Sequence Implementation Patterns","id":"a-recommended-sequence-implementation-patterns"},{"level":4,"text":"B. Interaction Debugging Helpers","id":"b-interaction-debugging-helpers"},{"level":4,"text":"C. Common Interaction Bugs and Fixes","id":"c-common-interaction-bugs-and-fixes"},{"level":4,"text":"D. Testing Interactions","id":"d-testing-interactions"},{"level":2,"text":"10. Error Handling and Edge Cases","id":"10-error-handling-and-edge-cases"},{"level":3,"text":"10.1 Failure Modes and Edge Cases","id":"101-failure-modes-and-edge-cases"},{"level":3,"text":"10.2 Invariant Verification for Debugging","id":"102-invariant-verification-for-debugging"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"11. Testing Strategy","id":"11-testing-strategy"},{"level":3,"text":"Testing Approach and Scenarios","id":"testing-approach-and-scenarios"},{"level":4,"text":"Unit Testing Strategy","id":"unit-testing-strategy"},{"level":4,"text":"Integration Testing: Public API Operations","id":"integration-testing-public-api-operations"},{"level":4,"text":"Property-Based Testing","id":"property-based-testing"},{"level":4,"text":"Edge Case and Scenario Testing","id":"edge-case-and-scenario-testing"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Automated Test Harness Recommendation","id":"automated-test-harness-recommendation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code: Test Harness","id":"infrastructure-starter-code-test-harness"},{"level":4,"text":"Core Logic Skeleton for Test Utilities","id":"core-logic-skeleton-for-test-utilities"},{"level":4,"text":"Language-Specific Hints: C Testing","id":"language-specific-hints-c-testing"},{"level":4,"text":"Milestone Checkpoint Commands","id":"milestone-checkpoint-commands"},{"level":4,"text":"Debugging Tips for Tests","id":"debugging-tips-for-tests"},{"level":2,"text":"12. Debugging Guide","id":"12-debugging-guide"},{"level":3,"text":"Common Bug Symptoms and Fixes","id":"common-bug-symptoms-and-fixes"},{"level":3,"text":"Debugging Techniques and Tools","id":"debugging-techniques-and-tools"},{"level":4,"text":"1. Verbose Logging with Function Tracing","id":"1-verbose-logging-with-function-tracing"},{"level":4,"text":"2. Tree Visualization Function","id":"2-tree-visualization-function"},{"level":4,"text":"3. Invariant Verification Function","id":"3-invariant-verification-function"},{"level":4,"text":"4. Memory Debuggers: Valgrind and AddressSanitizer","id":"4-memory-debuggers-valgrind-and-addresssanitizer"},{"level":4,"text":"5. Interactive Debugging with GDB","id":"5-interactive-debugging-with-gdb"},{"level":4,"text":"6. Unit Test with Known Sequences","id":"6-unit-test-with-known-sequences"},{"level":4,"text":"7. Property-Based Testing","id":"7-property-based-testing"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints (C)","id":"e-language-specific-hints-c"},{"level":4,"text":"F. Debugging Tips Table","id":"f-debugging-tips-table"},{"level":4,"text":"G. Milestone Checkpoint for Debugging","id":"g-milestone-checkpoint-for-debugging"},{"level":2,"text":"13. Future Extensions","id":"13-future-extensions"},{"level":3,"text":"13.1 Extension Ideas","id":"131-extension-ideas"},{"level":4,"text":"13.1.1 Persistence to Disk (Disk I/O Layer)","id":"1311-persistence-to-disk-disk-io-layer"},{"level":4,"text":"13.1.2 Key-Value Storage with Associated Values","id":"1312-key-value-storage-with-associated-values"},{"level":4,"text":"13.1.3 Concurrency Control (Multi-Threading)","id":"1313-concurrency-control-multi-threading"},{"level":4,"text":"13.1.4 B+ Tree and B* Tree Variants","id":"1314-b-tree-and-b-tree-variants"},{"level":3,"text":"13.2 Additional Extension Opportunities","id":"132-additional-extension-opportunities"},{"level":3,"text":"13.3 Implementation Guidance","id":"133-implementation-guidance"},{"level":2,"text":"14. Glossary","id":"14-glossary"},{"level":3,"text":"Term Definitions","id":"term-definitions"}],"title":"B-tree Implementation: Design Document","markdown":"# B-tree Implementation: Design Document\n\n\n## Overview\n\nThis document outlines the design for implementing a B-tree, a self-balancing tree data structure optimized for systems that read and write large blocks of data like databases and file systems. The key architectural challenge is maintaining the B-tree invariants (node key/child counts, sorted order) during insertions and deletions while ensuring disk-friendly operations through node splitting, merging, and borrowing.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## 1. Context and Problem Statement\n\n> **Milestone(s):** This foundational section corresponds primarily to Milestone 1 (understanding B-tree node structure) and provides essential context for all subsequent milestones by explaining why B-trees exist and what problems they solve.\n\nImagine you're managing a library with 10 million books. When someone asks for a specific book, you could walk through every shelf checking each spine—a linear search that would take months. Instead, you use a catalog system: first you check the main catalog (organized by topic), then a section guide, then a specific shelf index, and finally locate the book. This multi-level indexing is exactly what B-trees provide for computer systems, but with a crucial optimization: each level of the index is designed to fit perfectly into the physical storage units (pages) of disk drives, minimizing expensive disk seeks.\n\n### The Disk Access Problem and B-tree Solution\n\nTraditional in-memory balanced trees like AVL trees or Red-Black trees work beautifully when your entire dataset fits in RAM. Each node typically contains one key and two child pointers, creating tall, narrow trees. For memory operations where pointer dereferencing costs roughly the same regardless of location, this is optimal. However, when data exceeds available memory and must live on disk (as in databases or file systems), a fundamental hardware reality changes everything: **disk access is not uniform**.\n\n> **Key Insight:** The primary cost in disk-based systems isn't CPU cycles for comparisons—it's the mechanical movement of disk heads to different positions (seeks) and the time waiting for the right sector to rotate under the head (rotational latency). Reading 1 byte from disk takes essentially the same time as reading an entire disk block (typically 4KB).\n\nConsider this physical reality: if you store one key per disk block (node) as in a binary search tree, searching for a key among 1 million records might require ~20 disk reads (log₂(1,000,000) ≈ 20). Each read involves:\n1. **Seek time**: Moving the read head to the correct track (3-10ms for mechanical drives)\n2. **Rotational latency**: Waiting for the disk to rotate to the right sector (2-8ms)\n3. **Transfer time**: Actually reading the data (negligible for small amounts)\n\nEven with 20 reads at 10ms each, that's 200ms—unacceptably slow for database operations that might need thousands of lookups per second.\n\n**The B-tree breakthrough**: Instead of storing one key per node, B-trees store **many keys per node**—exactly enough to fill a disk block. With a **minimum degree** `t` (a parameter you choose based on disk block size and key size), each node holds between `t-1` and `2t-1` keys. This \"fat node\" design has profound implications:\n\n- **Height reduction**: A B-tree of degree `t` storing `n` keys has height at most `logₜ(n)`. With `t=100`, a tree of 1 million keys has height at most 3 (since 100³ = 1,000,000). That's 3 disk reads instead of 20!\n- **Amortized disk I/O**: Each node read brings in `t` keys worth of comparison material. Even though binary searching within a node takes O(log t) comparisons, these happen in memory after the single disk read.\n- **Sequential access advantage**: Keys within a node are stored in sorted arrays, allowing efficient binary search and taking advantage of CPU cache locality once the node is loaded.\n\n> **Design Principle:** B-trees are designed around the unit of storage transfer (disk blocks/pages) rather than the unit of data comparison (individual keys). This is why they dominate disk-based indexing while binary trees dominate in-memory indexing.\n\n**The B-tree solution in technical terms**: By carefully maintaining balance invariants (every node except root must be at least half-full, all leaves at same depth) and implementing split/merge operations during insert/delete, B-trees guarantee:\n1. **Deterministic performance**: Always O(logₜ n) disk accesses\n2. **High storage utilization**: Typically 50-100% of each disk block used\n3. **Stable performance**: No periodic rebalancing needed (unlike some hash tables)\n\n### Mental Model: The Library Catalog Analogy\n\nLet's build intuition through a concrete analogy. Imagine our library with the Dewey Decimal system:\n\n1. **The Root Node (Main Catalog Desk)**: Contains ranges of Dewey Decimal numbers and pointers to section catalogs. Example: \"000-199 → Science Section Catalog,\" \"200-399 → Literature Section Catalog,\" etc. This fits on one index card at the main desk.\n\n2. **Internal Nodes (Section Catalogs)**: Each section (Science, Literature) has its own catalog with finer divisions. The Science catalog might have: \"000-049 → Physics shelves,\" \"050-099 → Chemistry shelves,\" etc. Each catalog fits on one physical card.\n\n3. **Leaf Nodes (Shelf Labels)**: At the shelves themselves, you find labels like \"Physics 000-015: Thermodynamics books\" listing actual books (data) on that shelf.\n\n4. **The Search Process**: To find book \"005.133\" (a computer science book):\n   - Start at main desk (root): Binary search shows \"000-199 → Science\"\n   - Go to Science catalog (internal node): Binary search shows \"000-049 → Physics\"\n   - Go to Physics shelf (leaf node): Binary search finds book \"005.133\" is actually here (or isn't if someone miscategorized it!)\n\n5. **Insertion with Splitting**: When the Physics shelf becomes too full (exceeds capacity), we:\n   - Take the middle book off the shelf\n   - Create a new shelf\n   - Put half the books on each shelf\n   - Update the Science catalog to now have two entries: \"000-024 → Old Physics Shelf\" and \"025-049 → New Physics Shelf\"\n\n6. **Deletion with Merging**: If the Chemistry shelf becomes too empty (below minimum), we either:\n   - **Borrow**: Take a book from the adjacent Physics shelf (through the Science catalog)\n   - **Merge**: If Physics shelf is also near minimum, combine both shelves into one and remove an entry from the Science catalog\n\nThis analogy maps directly to B-tree concepts:\n- **Minimum degree `t`**: Minimum books per shelf (except possibly the first/last shelf in a section)\n- **Node splitting**: Shelf getting too full\n- **Median promotion**: Moving the middle book up to the section catalog\n- **Borrowing/merging**: Shelf reorganization\n- **Balanced depth**: All shelves are reachable through the same number of catalog lookups\n\n> **Mental Model Summary:** Think of a B-tree as a multi-level catalog system where each catalog card (node) is sized to fit exactly one physical storage unit (disk page), and the system automatically reorganizes cards and shelves to maintain quick access while efficiently using space.\n\n### Comparison with Other Tree Structures\n\nTo understand when to choose B-trees over other tree structures, consider this comprehensive comparison:\n\n| **Tree Type** | **Typical Keys per Node** | **Height for N keys** | **Primary Optimization Target** | **Disk-Friendly?** | **Common Use Cases** | **Balance Mechanism** |\n|---------------|---------------------------|------------------------|----------------------------------|---------------------|----------------------|----------------------|\n| **Binary Search Tree (BST)** | 1 | O(N) worst, O(log N) average | In-memory comparison speed | ❌ No | In-memory algorithms, simple dictionaries | None (unbalanced) |\n| **AVL Tree** | 1 | O(log N) | Guaranteed height balance for worst-case performance | ❌ No | In-memory databases, real-time systems where worst-case matters | Rotations after insert/delete |\n| **Red-Black Tree** | 1 | O(log N) | Simpler rebalancing with good amortized performance | ❌ No | Standard library implementations (C++ STL map, Java TreeMap) | Color flips and rotations |\n| **B-tree** | t-1 to 2t-1 (t typically 50-1000) | O(logₜ N) | Minimizing disk I/O, block utilization | ✅ **Excellent** | Databases (MySQL, PostgreSQL), file systems (NTFS, HFS+, ext4), disk-based indices | Split/merge during operations |\n| **B+ tree** | t-1 to 2t-1 | O(logₜ N) | Range queries, sequential access | ✅ **Excellent** | Database indices (especially with range scans), file systems | Split/merge, all data at leaves |\n\n**Detailed Analysis:**\n\n**Binary Search Trees (BSTs)**:\n- **When to use**: Small datasets that fit entirely in memory, simple implementations, or when you need an easy-to-understand tree structure.\n- **Limitations for disk**: Each node might reside in a different disk block, causing one disk read per level traversed. Worst-case height O(N) if keys are inserted in sorted order.\n- **Storage overhead**: For each key, you store two child pointers (typically 8 bytes each on 64-bit systems).\n\n**AVL Trees**:\n- **When to use**: When guaranteed O(log N) worst-case time is critical, and the tree fits in memory. Used in real-time systems and in-memory databases.\n- **Disk limitations**: Same as BSTs—each node potentially causes a disk read. Frequent rotations during insertion/deletion would cause excessive disk writes if stored on disk.\n- **Balance factor**: Maintains height difference ≤ 1 between subtrees through rotations.\n\n**Red-Black Trees**:\n- **When to use**: General-purpose in-memory sorted containers where you want good amortized performance with simpler implementation than AVL trees. Most standard libraries use them.\n- **Disk limitations**: Like AVL trees, not designed for disk storage. The approximately balanced nature (height ≤ 2log₂(N+1)) helps but doesn't solve the fundamental disk I/O problem.\n- **Practical note**: While not disk-optimized, some systems use them for in-memory indices that occasionally flush to disk.\n\n**B-trees**:\n- **When to use**: Any dataset too large for memory, or when persistence to disk is required. The de facto standard for database indices and file systems.\n- **Key advantages**:\n  1. **Height reduction**: With t=100, a B-tree of 1 billion keys has height at most 5 (100⁵ = 10¹⁰), meaning 5 disk reads max.\n  2. **Sequential reads within nodes**: Once a node is loaded, all its keys are in memory for efficient binary search.\n  3. **High fanout**: Many children per internal node reduces height.\n  4. **Predictable performance**: No periodic rebalancing needed.\n- **Trade-offs**: More complex implementation than binary trees, overhead of maintaining minimum occupancy.\n\n**B+ trees** (a common variant):\n- **When to use**: Database systems where range queries are common. All actual data resides in leaf nodes, with internal nodes containing only keys for routing.\n- **Advantages over B-trees**:\n  1. **Better sequential access**: All leaf nodes are linked together, enabling efficient full-table scans.\n  2. **More keys per internal node**: Since internal nodes don't store data, they can have higher fanout.\n  3. **Consistent access time**: All data accesses require traversing to leaf level.\n- **Our implementation focus**: While this document describes classic B-trees, the principles apply to B+ trees as well.\n\n> **Architecture Decision Record: Why Implement Classic B-Trees Instead of B+ Trees?**\n\n> **Decision: Implement Classic B-Trees for Educational Clarity**\n> - **Context**: We need to choose which variant of B-tree to implement for this educational project. The core concepts of node splitting, merging, and disk-friendly design are shared across variants, but implementation details differ.\n> - **Options Considered**:\n>   1. **Classic B-trees**: Keys and associated data can be in any node. Simpler to implement for a basic key-value store.\n>   2. **B+ trees**: All data resides in leaf nodes; internal nodes contain only keys. Better for range queries and database indices.\n>   3. **B* trees**: Nodes kept 2/3 full minimum (vs 1/2 for B-trees), reducing splits but adding complexity.\n> - **Decision**: Implement classic B-trees.\n> - **Rationale**:\n>   1. **Educational value**: Classic B-trees demonstrate all fundamental operations (search, insert, delete with rebalancing) in their most direct form.\n>   2. **Implementation simplicity**: No need to maintain linked lists of leaves or separate data storage.\n>   3. **Conceptual clarity**: Each node clearly demonstrates the \"keys as separators\" mental model without the additional abstraction of data-only leaves.\n>   4. **Foundation for variants**: Understanding classic B-trees makes it straightforward to later implement B+ or B* trees.\n> - **Consequences**:\n>   - **Positive**: Clear mapping from algorithm descriptions to implementation; easier to debug and visualize.\n>   - **Negative**: Less optimal for range scans compared to B+ trees; in practice, database systems usually implement B+ trees.\n\n| **Option** | **Pros** | **Cons** | **Why Not Chosen** |\n|------------|----------|----------|-------------------|\n| **Classic B-tree** | Direct implementation of textbook algorithm; clear mental model; all operations self-contained in each node | Less efficient for range queries; mixed data and routing keys in same nodes | **Chosen** - Best for learning fundamentals |\n| **B+ tree** | Industry standard for databases; efficient range scans; higher fanout in internal nodes | More complex: need leaf node linked lists; data duplication between leaves and internal nodes | Better for production systems but adds learning overhead |\n| **B* tree** | Better space utilization (66% vs 50% minimum); fewer splits | More complex rebalancing (three-way splits); not commonly taught | Adds complexity without proportional educational benefit |\n\n**Real-World Usage Context**:\n\nIn practice, the choice between tree structures depends entirely on the storage medium and access patterns:\n\n1. **In-memory data structures**: Redis uses skip lists and hash tables for its primary structures; most programming language standard libraries use Red-Black trees for their ordered map/set implementations.\n\n2. **Database indices**: PostgreSQL, MySQL (InnoDB), Oracle, and SQL Server all use B+ trees for their table indices. The B+ tree variant provides optimal performance for both point lookups and range queries common in SQL.\n\n3. **File systems**: NTFS (Windows), HFS+ (macOS), ext4 (Linux), and many others use B-trees or B+ trees for directory indexing and file metadata storage.\n\n4. **Specialized systems**: Some modern databases use LSM-trees (Log-Structured Merge-trees) for write-intensive workloads, but they still often use B-trees for their in-memory components or for certain types of indices.\n\nFor this implementation project, we focus on classic B-trees because they capture the essential algorithmic insights while being approachable for implementation. The skills you learn—managing node capacities, implementing split/merge operations, maintaining invariants during modifications—directly transfer to understanding real-world database and file system implementations.\n\n### Implementation Guidance\n\n> **Note:** Since this is the context section (not a component design section), we provide only minimal implementation guidance focused on setting up the project structure. Detailed code will appear in subsequent sections.\n\n**Technology Recommendations Table:**\n\n| Component | Simple Option (Learning Focus) | Advanced Option (Production-Ready) |\n|-----------|--------------------------------|-----------------------------------|\n| **Language** | C (standard library only) | C with platform-specific optimizations |\n| **Memory Management** | Manual `malloc`/`free` | Arena allocator or slab allocator |\n| **Disk Persistence** | In-memory only (no persistence) | Memory-mapped files with page caching |\n| **Key Type** | Fixed-size integers (`int` or `long`) | Generic pointers with comparison function |\n| **Testing Framework** | Simple test harness with assertions | Comprehensive unit test suite (Check, Unity) |\n| **Debugging Aids** | Print statements and manual inspection | Graphviz output for tree visualization |\n\n**Recommended File/Module Structure:**\n\nFor a clean C implementation that separates concerns and makes testing easier:\n\n```\nbtree-project/\n├── include/                    # Public header files\n│   └── btree.h                # Main B-tree API (public functions)\n├── src/                       # Implementation source files\n│   ├── btree.c               # B-tree operations (search, insert, delete)\n│   ├── node.c                # Node manipulation functions\n│   ├── disk.c                # Disk I/O simulation (if implementing persistence)\n│   └── utils.c               # Utility functions (binary search, validation)\n├── tests/                     # Test suite\n│   ├── test_btree.c          # Comprehensive B-tree tests\n│   ├── test_node.c           # Node-specific tests\n│   └── test_runner.c         # Test runner main program\n├── examples/                  # Example usage\n│   └── basic_usage.c         # Simple demonstration program\n├── docs/                      # Documentation\n│   └── design.md             # This design document\n└── Makefile                   # Build automation\n```\n\n**Infrastructure Starter Code:**\n\nWhile the core B-tree algorithms are the learning focus, you'll need some basic infrastructure. Here's a complete, ready-to-use header file to start:\n\n```c\n/* include/btree.h - Main B-tree API */\n#ifndef BTREE_H\n#define BTREE_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n/* Configuration constants */\n#define DEFAULT_MIN_DEGREE 3  /* t=3 means nodes hold 2-5 keys */\n\n/* Forward declaration of internal node structure */\ntypedef struct BTreeNode BTreeNode;\n\n/* Main B-tree structure */\ntypedef struct {\n    BTreeNode* root;           /* Pointer to root node */\n    int t;                     /* Minimum degree (defines capacity bounds) */\n    size_t key_count;          /* Total keys in tree (optional, for statistics) */\n} BTree;\n\n/* Search result structure */\ntypedef struct {\n    bool found;                /* Whether the key was found */\n    void* value;               /* Associated value (if any) */\n    int comparisons;           /* Number of key comparisons made (for analysis) */\n} SearchResult;\n\n/* B-tree API functions */\n\n/* Initialize a new empty B-tree with given minimum degree */\nBTree* btree_create(int min_degree);\n\n/* Free all memory used by the B-tree */\nvoid btree_destroy(BTree* tree);\n\n/* Search for a key in the tree */\nSearchResult btree_search(BTree* tree, int key);\n\n/* Insert a key (and optional value) into the tree */\nbool btree_insert(BTree* tree, int key, void* value);\n\n/* Delete a key from the tree */\nbool btree_delete(BTree* tree, int key);\n\n/* Get the number of keys in the tree */\nsize_t btree_size(BTree* tree);\n\n/* Get the height of the tree */\nint btree_height(BTree* tree);\n\n/* Validate tree invariants (for debugging) */\nbool btree_validate(BTree* tree);\n\n/* Print tree structure (for debugging) */\nvoid btree_print(BTree* tree);\n\n#endif /* BTREE_H */\n```\n\n**Core Logic Skeleton Code:**\n\nFor the node structure (Milestone 1), here's the skeleton you'll implement:\n\n```c\n/* src/node.c - Node implementation */\n#include \"btree.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\n/* Internal node structure */\nstruct BTreeNode {\n    int* keys;                 /* Array of keys (size: 2*t-1 when full) */\n    void** values;             /* Array of associated values (optional) */\n    BTreeNode** children;      /* Array of child pointers (size: 2*t) */\n    int num_keys;              /* Current number of keys in node */\n    bool is_leaf;              /* True if leaf node (no children) */\n    /* Note: For leaf nodes, children array may be NULL or all NULL */\n};\n\n/* Create a new empty node */\nstatic BTreeNode* node_create(int t, bool is_leaf) {\n    /* TODO 1: Allocate memory for the BTreeNode structure */\n    /* TODO 2: Allocate arrays for keys (size 2*t-1) and values (if using) */\n    /* TODO 3: If not leaf, allocate children array (size 2*t) */\n    /* TODO 4: Initialize num_keys to 0 and is_leaf flag */\n    /* TODO 5: For safety, initialize all child pointers to NULL */\n    /* TODO 6: Return the new node */\n}\n\n/* Free a node and all its descendants recursively */\nstatic void node_destroy(BTreeNode* node) {\n    /* TODO 1: If node is NULL, return immediately */\n    /* TODO 2: If not leaf, recursively destroy all children */\n    /* TODO 3: Free the keys, values, and children arrays */\n    /* TODO 4: Free the node structure itself */\n}\n\n/* Find the index where key should be in this node (binary search) */\nstatic int node_find_key_index(BTreeNode* node, int key, int* comparisons) {\n    /* TODO 1: Initialize left = 0, right = node->num_keys - 1 */\n    /* TODO 2: While left <= right, do binary search */\n    /* TODO 3: Compare key with node->keys[mid], increment comparisons */\n    /* TODO 4: If key found, return index (might be negative for child pointer logic) */\n    /* TODO 5: If not found, return index where key should be inserted */\n}\n\n/* Check if node is full (has 2*t-1 keys) */\nstatic bool node_is_full(BTreeNode* node, int t) {\n    /* TODO: Return true if node->num_keys == 2*t - 1 */\n}\n\n/* Check if node is underfull (has fewer than t-1 keys) */\nstatic bool node_is_underfull(BTreeNode* node, int t) {\n    /* TODO: Return true if node->num_keys < t - 1 */\n    /* Special case: root can have fewer keys */\n}\n```\n\n**Language-Specific Hints for C:**\n\n1. **Memory allocation**: Use `calloc` instead of `malloc` when you want zero-initialized memory (especially for child pointer arrays).\n2. **Error handling**: Check every `malloc`/`calloc` return value for NULL and handle gracefully (free previous allocations and return error).\n3. **Const correctness**: Use `const` for pointer parameters that shouldn't be modified (e.g., `const BTreeNode* node` in search functions).\n4. **Static functions**: Mark helper functions as `static` (file scope) to avoid polluting the global namespace.\n5. **Integer types**: Use `size_t` for counts and indices that can't be negative; use `int` for keys in this simple implementation.\n6. **Debugging**: Compile with `-g -O0` for debugging and `-fsanitize=address` for memory error detection.\n\n**Milestone Checkpoint for Section 1:**\n\nAfter setting up your project structure and implementing the basic node infrastructure:\n\n1. **Compile your code**: `gcc -c src/node.c -Iinclude -o node.o`\n2. **Test node creation**: Write a simple test that creates nodes with different `t` values and checks:\n   - Memory is correctly allocated\n   - Arrays have the right sizes\n   - Fields are properly initialized\n3. **Verify with valgrind**: Run `valgrind ./your_test_program` to ensure no memory leaks.\n4. **Expected behavior**: Nodes should be created and destroyed cleanly with no memory errors.\n5. **Signs of trouble**: Segmentation faults indicate uninitialized pointers or array bounds errors; memory leaks mean you're not freeing all allocated memory.\n\n---\n\n\n## 2. Goals and Non-Goals\n\n> **Milestone(s):** This foundational section corresponds to all milestones (1-4), establishing the functional and non-functional boundaries for the entire B-tree implementation.\n\nThis section precisely defines what the B-tree implementation will and will not do. Given the educational nature of the project, we deliberately constrain the scope to focus on core algorithmic concepts while establishing a clean foundation for potential future extensions. Clear boundaries prevent scope creep and help learners concentrate on mastering the fundamental mechanics of B-tree operations.\n\n### Functional Goals\nThe primary functional goal is to implement a **correct, in-memory B-tree** that adheres to all classic invariants and supports the three fundamental dictionary operations. This B-tree will serve as a pedagogical model for understanding how disk-optimized tree structures maintain balance.\n\n> **Mental Model: A Self-Organizing Filing Cabinet**\n> Think of the B-tree as a smart filing cabinet for index cards. Each drawer (node) can hold a fixed number of cards (keys). When a drawer becomes too full, it automatically splits into two, and a new divider card is sent to the drawer above. When a drawer becomes too empty, it either borrows a card from a neighbor or merges with one. The entire cabinet maintains a strict alphabetical order, and any card can be found by checking at most a few drawers. Our implementation builds this cabinet entirely in RAM, simulating the drawer operations that would normally occur on disk.\n\nThe following table enumerates the core operations the B-tree must support, their exact behavioral specifications, and how they map to the key invariants.\n\n| Operation | Signature (C) | Preconditions | Postconditions & Guarantees | Key Invariants Maintained |\n| :--- | :--- | :--- | :--- | :--- |\n| **Create Tree** | `BTree* btree_create(int min_degree)` | `min_degree` ≥ 2. | Returns a pointer to a new, empty `BTree` struct with `root` set to `NULL`, `t` set to `min_degree`, and `key_count` set to 0. Memory is allocated for the tree structure. | Establishes the minimum degree `t` for all future node capacity calculations. |\n| **Search Key** | `SearchResult btree_search(BTree* tree, int key)` | `tree` is a valid pointer from `btree_create`. `key` is an integer. | Returns a `SearchResult` struct. If the key exists, `found` is `true` and `value` points to the associated data (or is `NULL` if no values are stored). If not found, `found` is `false`. The `comparisons` field records the total number of key comparisons performed during the search. The tree structure remains unchanged. | Demonstrates the `O(log n)` search path length. Relies on sorted keys within nodes and correct child pointer navigation. |\n| **Insert Key-Value** | `bool btree_insert(BTree* tree, int key, void* value)` | `tree` is valid. `key` is an integer. `value` is an optional pointer to associated data (may be `NULL`). | If the key does **not** already exist in the tree, it is inserted along with its value. The tree is rebalanced via proactive splitting to maintain all B-tree invariants. Returns `true` on successful insertion. If the key already exists, the operation is a **no-op**: the tree is unchanged, and the function returns `false`. The `key_count` in the tree is updated accordingly. | Guarantees all nodes (except root) have between `t-1` and `2t-1` keys. Ensures all keys in the tree remain in sorted order. Handles root split, increasing tree height by one when necessary. |\n| **Delete Key** | `bool btree_delete(BTree* tree, int key)` | `tree` is valid. `key` is an integer. | If the key exists in the tree, it is removed. The tree is rebalanced via borrowing from siblings or merging nodes to maintain the minimum occupancy invariant. Returns `true` on successful deletion. If the key does not exist, the operation is a **no-op**: the tree is unchanged, and the function returns `false`. The `key_count` is updated. | Maintains the minimum key count invariant (all non-root nodes have at least `t-1` keys). Handles root deletion that may reduce tree height by one. Preserves sorted order. |\n| **Utility & Inspection** | `size_t btree_size(BTree* tree)`<br>`int btree_height(BTree* tree)`<br>`bool btree_validate(BTree* tree)`<br>`void btree_print(BTree* tree)` | `tree` is valid (may be `NULL` for some functions). | Returns the total number of keys (`key_count`), the height (root to leaf, with leaves at height 0), a boolean indicating if all B-tree invariants hold, and a textual representation of the tree structure (for debugging), respectively. These functions do not modify the tree. | The validation function (`btree_validate`) is the ultimate correctness check, verifying every invariant listed in Section 4. |\n\nThe sequence of these operations defines the primary data flow: creation → insertion (builds the tree) → search (queries the tree) → deletion (modifies the tree) → inspection (verifies the tree). Success is defined by the `btree_validate` function returning `true` after any sequence of these operations.\n\n### Non-Functional Goals & Non-Goals\nThis implementation prioritizes **clarity, correctness, and educational value** over performance optimizations or production-ready features. The non-functional goals define the quality attributes we will achieve, while the non-goals explicitly list features we are omitting, explaining why they are out of scope for this learning exercise.\n\n**Non-Functional Goals**\n1.  **Algorithmic Complexity:** All operations must achieve their theoretical time complexities. Search, insertion, and deletion must run in `O(log n)` time, where the base of the logarithm is the minimum degree `t`. This requires efficient binary search within nodes (`O(log t)`) and a tree height of `O(log_t n)`.\n2.  **Memory Safety (C):** The implementation must not leak memory. Every `malloc` or `calloc` must have a corresponding `free`. The `btree_destroy` function must completely deallocate all tree nodes and the tree structure itself.\n3.  **Robustness to Edge Cases:** The implementation must correctly handle standard edge cases: inserting into an empty tree, deleting the only key in the tree, splitting the root, merging all the way to the root, and attempting to delete a non-existent key.\n4.  **Debuggability:** The provided `btree_print` and `btree_validate` functions must offer sufficient introspection to diagnose structural issues during development. The `SearchResult.comparisons` field provides visibility into search efficiency.\n5.  **Configurable Node Size:** The B-tree's node capacity, determined by the minimum degree `t`, must be configurable at tree creation. This allows experimenting with different fanouts and observing their effect on tree height.\n\n**Non-Goals**\nExplicitly excluding the following areas keeps the project focused and achievable, while the table below justifies each exclusion and suggests how they could be added later.\n\n| Feature | Status (Non-Goal) | Rationale for Exclusion | Potential Extension Path |\n| :--- | :--- | :--- | :--- |\n| **Persistent Storage to Disk** | Excluded | The core learning objective is the in-memory balancing algorithm. Disk I/O (page caching, serialization, write-ahead logging) introduces significant complexity that would distract from the core B-tree mechanics. | Add a `Pager` module that maps node IDs to disk offsets, and modify node splits/merges to write pages back to a file. |\n| **Concurrency Control (Thread Safety)** | Excluded | Managing concurrent inserts, deletes, and searches with locks (e.g., B-link tree techniques) is an advanced topic beyond introductory B-tree concepts. | Protect the tree root with a mutex for coarse-grained locking, or implement fine-grained lock coupling on node traversal paths. |\n| **Variable-Length or Generic Keys** | Excluded | Using integer keys simplifies comparison logic and memory management, letting learners focus on structure. Supporting strings or generic types requires custom comparators and more complex node memory layout. | Replace the `int* keys` array with a `void** keys` array and a function pointer `comparator`. |\n| **Associated Values (Full Key-Value Store)** | Partially Supported | The `BTreeNode` struct includes a `values` array (`void**`), allowing storage of optional pointers. However, managing the lifecycle (allocation/freeing) of these values is **not** a goal. The implementation only stores and returns the pointer. | Make `btree_insert` accept a `value_size` and use `memcpy` to store values inline within the node or in a separate heap allocation. |\n| **Duplicate Keys** | Excluded | Standard B-tree definitions prohibit duplicates. Supporting them requires modifying the search and insert logic (e.g., allowing multiple values per key or using a secondary index), which adds complexity. | Modify `node_find_key_index` to find the first occurrence, and adjust insertion to allow non-unique keys, potentially storing a list of values per key. |\n| **B+ Tree or B* Tree Variants** | Excluded | This is a classic B-tree where keys are stored in both internal nodes and leaves. B+ trees (keys only in leaves, linked leaves) are an important optimization for databases but represent a different structural variant. | Convert the B-tree to a B+ tree by removing keys from internal nodes (keeping only separators) and adding sibling pointers between leaf nodes. |\n| **Advanced Optimizations (Bulk Loading, Compression)** | Excluded | These are performance optimizations valuable in production systems but orthogonal to understanding the core insert/split/delete/merge algorithms. | Implement a `btree_bulk_load` function that sorts all keys and builds the tree from the bottom up for optimal packing. |\n\n> **Design Insight:** The most critical trade-off in this design is **abstraction vs. realism**. We abstract away disk persistence—the original raison d'être for B-trees—to isolate the balancing algorithm. This allows learners to build a correct, understandable mental model of node splitting and merging first. Once this core is solid, extending the design to include a pager module (for disk I/O) becomes a more manageable, separate challenge.\n\n### Common Pitfalls: Misinterpreting Scope\nLearners often mistakenly believe they need to implement features from the non-goals list, or they overlook subtle aspects of the defined goals.\n- ⚠️ **Pitfall: Implementing Reactive Instead of Proactive Splitting.** The design specifies *proactive* splitting during the insertion descent. A common mistake is to insert into a leaf first, find it's full, and then split (reactive). This works for leaves but fails for internal nodes if a child needs to be split during the descent. **Fix:** Always check if a child node is full *before* recursively descending into it during insertion.\n- ⚠️ **Pitfall: Ignoring the `values` Array in Node Operations.** Even though value management is a non-goal, the `values` array pointer must be maintained correctly. When splitting a node or moving keys during borrowing/merging, the associated value pointer must be moved alongside its key. Forgetting this leads to search returning incorrect `value` pointers. **Fix:** Treat the key and its value as a bonded pair in all node-level operations (insert, delete, split, borrow).\n- ⚠️ **Pitfall: Allowing `t=1`.** The minimum degree `t` must be at least 2. If `t=1`, the node capacity rules break down (a node would be allowed 1 to 1 key, making splitting nonsensical). **Fix:** In `btree_create`, validate that `min_degree >= 2` and return `NULL` or abort if not.\n\n### Implementation Guidance\n\nThis section provides concrete starter code and structure for the B-tree's foundational types and the goal-oriented functions. Since persistence and concurrency are non-goals, we focus on clean, memory-safe in-memory structures.\n\n#### A. Technology Recommendations Table\n| Component | Simple Option (Recommended) | Advanced Option (Post-Learning) |\n| :--- | :--- | :--- |\n| **Memory Management** | Standard `malloc`/`free` with careful manual tracking. | Use a custom arena allocator for nodes to improve locality and simplify freeing (destroy just frees the arena). |\n| **Key Comparison** | Direct integer comparison (`<`, `==`, `>`). | Function pointer to a comparator for generic keys. |\n| **Tree Visualization** | Recursive print to console with indentation (`btree_print`). | Generate Graphviz DOT format output to render as an image. |\n| **Validation** | Recursive invariant checker (`btree_validate`). | Integrate the checker with a unit test framework (e.g., Google Test for C++). |\n\n#### B. Recommended File/Module Structure\nPlace the core B-tree implementation in two files: a header for declarations and a source file for definitions. This separates interface from implementation.\n```\nbtree-project/\n├── include/\n│   └── btree.h          <-- Public API and struct definitions\n├── src/\n│   ├── btree.c          <-- Implementation of BTree operations\n│   ├── node.c           <-- Implementation of Node-level helpers\n│   └── main.c           <-- Example usage or test driver (optional)\n└── tests/\n    └── test_btree.c     <-- Unit tests\n```\n\n#### C. Infrastructure Starter Code\nThe following is **complete, compilable code** for the core data structures and basic tree lifecycle functions. A learner should place this in `btree.h` and start the implementation in `btree.c`.\n\n**File: `include/btree.h`**\n```c\n#ifndef BTREE_H\n#define BTREE_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n// Constants\n#define DEFAULT_MIN_DEGREE 3\n\n// Core Types\ntypedef struct BTreeNode {\n    int* keys;                  // Array of keys (size = 2*t - 1)\n    void** values;              // Optional array of associated values\n    struct BTreeNode** children;// Array of child pointers (size = 2*t)\n    int num_keys;               // Current number of keys in node\n    bool is_leaf;               // True if leaf, false if internal node\n} BTreeNode;\n\ntypedef struct BTree {\n    BTreeNode* root;            // Pointer to root node\n    int t;                      // Minimum degree (defines capacity bounds)\n    size_t key_count;           // Total keys in entire tree\n} BTree;\n\ntypedef struct SearchResult {\n    bool found;                 // Whether the key exists\n    void* value;                // Associated value if found (may be NULL)\n    int comparisons;            // Number of key comparisons performed\n} SearchResult;\n\n// Tree Lifecycle & Public API\nBTree* btree_create(int min_degree);\nvoid btree_destroy(BTree* tree);\nSearchResult btree_search(BTree* tree, int key);\nbool btree_insert(BTree* tree, int key, void* value);\nbool btree_delete(BTree* tree, int key);\nsize_t btree_size(BTree* tree);\nint btree_height(BTree* tree);\nbool btree_validate(BTree* tree);\nvoid btree_print(BTree* tree);\n\n// Node-level helper functions (internal use, but exposed for testing)\nBTreeNode* node_create(int t, bool is_leaf);\nvoid node_destroy(BTreeNode* node);\nint node_find_key_index(BTreeNode* node, int key, int* comparisons);\nbool node_is_full(BTreeNode* node, int t);\nbool node_is_underfull(BTreeNode* node, int t);\n\n#endif // BTREE_H\n```\n\n**File: `src/btree.c` - Starter Skeleton**\n```c\n#include \"btree.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n// ============================================\n// Tree Lifecycle Functions\n// ============================================\n\nBTree* btree_create(int min_degree) {\n    // TODO 1: Validate min_degree >= 2. Return NULL if invalid.\n    // TODO 2: Allocate memory for BTree struct.\n    // TODO 3: Initialize fields: t = min_degree, root = NULL, key_count = 0.\n    // TODO 4: Return the pointer to the new tree.\n}\n\nvoid btree_destroy(BTree* tree) {\n    if (tree == NULL) return;\n    // TODO 1: If tree->root exists, call node_destroy(tree->root) to free the entire node hierarchy.\n    // TODO 2: Free the tree struct itself.\n}\n\n// ============================================\n// Public API Functions (Skeletons)\n// ============================================\n\nSearchResult btree_search(BTree* tree, int key) {\n    SearchResult result = {false, NULL, 0};\n    if (tree == NULL || tree->root == NULL) return result;\n    // TODO: Implement recursive search starting from tree->root.\n    // Hint: Create a helper function `search_subtree(node, key, &comparisons)`.\n    return result;\n}\n\nbool btree_insert(BTree* tree, int key, void* value) {\n    if (tree == NULL) return false;\n    // TODO: Implement proactive split insertion.\n    // 1. If root is full, split it (creates new root, increases height).\n    // 2. Call a recursive helper `insert_non_full(starting_node, key, value)`.\n    // 3. If key already exists (found during descent), return false.\n    // 4. On successful new insertion, increment tree->key_count and return true.\n    return false;\n}\n\nbool btree_delete(BTree* tree, int key) {\n    if (tree == NULL || tree->root == NULL) return false;\n    // TODO: Implement deletion with borrowing/merging.\n    // 1. Call a recursive helper `delete_key(node, key)`.\n    // 2. If key not found, return false.\n    // 3. If after deletion the root has 0 keys and is not a leaf, set its only child as new root.\n    // 4. On successful deletion, decrement tree->key_count and return true.\n    return false;\n}\n\nsize_t btree_size(BTree* tree) {\n    return (tree == NULL) ? 0 : tree->key_count;\n}\n\nint btree_height(BTree* tree) {\n    if (tree == NULL || tree->root == NULL) return -1; // Empty tree height convention\n    // TODO: Recursively compute height by following leftmost child until a leaf.\n    // Height definition: leaf nodes are at height 0. Root alone (leaf) = 0.\n    return 0;\n}\n\nbool btree_validate(BTree* tree) {\n    if (tree == NULL) return false;\n    // TODO: Implement comprehensive invariant checks.\n    // 1. Check root key count: 0 <= num_keys <= 2t-1, and if root is leaf, children pointers should be NULL.\n    // 2. Recursively check every node:\n    //    a. Key count in [t-1, 2t-1] for non-root.\n    //    b. Keys are strictly increasing within node.\n    //    c. For internal nodes: num_keys + 1 == number of non-NULL children.\n    //    d. Leaf check: is_leaf == (all children are NULL).\n    // 3. Check that the tree's key_count matches the sum of keys in all nodes.\n    return false;\n}\n\nvoid btree_print(BTree* tree) {\n    if (tree == NULL) {\n        printf(\"(null tree)\\n\");\n        return;\n    }\n    // TODO: Implement a pretty-print or debug print.\n    // Simple approach: Print each level with indentation.\n    printf(\"B-Tree (t=%d, keys=%zu, height=%d)\\n\",\n           tree->t, tree->key_count, btree_height(tree));\n    // TODO: Call a recursive node printer.\n}\n```\n\n**File: `src/node.c` - Starter Skeleton**\n```c\n#include \"btree.h\"\n#include <stdlib.h>\n\nBTreeNode* node_create(int t, bool is_leaf) {\n    // TODO 1: Allocate memory for BTreeNode struct.\n    // TODO 2: Allocate arrays: keys (size = 2*t - 1), values (same size), children (size = 2*t).\n    // TODO 3: Initialize all fields: num_keys = 0, is_leaf = is_leaf.\n    // TODO 4: Initialize children array to all NULLs (important for leaf nodes).\n    // TODO 5: Return the new node.\n    return NULL;\n}\n\nvoid node_destroy(BTreeNode* node) {\n    if (node == NULL) return;\n    // TODO 1: If node is not a leaf, recursively destroy all non-NULL children.\n    // TODO 2: Free the keys, values, and children arrays.\n    // TODO 3: Free the node struct itself.\n}\n\nint node_find_key_index(BTreeNode* node, int key, int* comparisons) {\n    // TODO: Implement binary search within node->keys[0..num_keys-1].\n    // 1. Initialize left=0, right=node->num_keys-1.\n    // 2. While left <= right, compute mid, compare key with node->keys[mid].\n    //    Increment (*comparisons) for each comparison.\n    // 3. If key found, return the exact index.\n    // 4. If not found, return the index of the first key greater than the target,\n    //    or node->num_keys if all keys are smaller. This is the child index to descend into.\n    return 0;\n}\n\nbool node_is_full(BTreeNode* node, int t) {\n    return (node != NULL) && (node->num_keys == (2 * t - 1));\n}\n\nbool node_is_underfull(BTreeNode* node, int t) {\n    return (node != NULL) && (node->num_keys < (t - 1));\n}\n```\n\n#### D. Milestone Checkpoint: After Setting Up Foundations\nAfter implementing just the skeleton and the `btree_create` and `btree_destroy` functions (with proper memory allocation/deallocation in `node_create` and `node_destroy`), you should be able to compile without errors and run a simple test.\n\n**Compilation Command (using GCC):**\n```bash\ngcc -I./include -c src/btree.c src/node.c -o btree.o node.o\n```\n**Expected Outcome:** Successful compilation (no errors). Linking with a simple `main.c` that creates and destroys a tree should run without memory leaks (check with Valgrind).\n\n**Signs of Trouble:**\n- **Segmentation fault on `btree_destroy`:** Likely caused by not initializing the `children` array to `NULL` in `node_create`, leading to `free` on uninitialized pointers.\n- **Memory leaks:** Use `valgrind ./your_program` to detect leaks. Any remaining allocations indicate missing `free` in `node_destroy` or `btree_destroy`.\n\n#### E. Language-Specific Hints (C)\n- **Memory Allocation:** Use `calloc` for arrays to ensure zero-initialization. For example, `node->children = calloc(2 * t, sizeof(BTreeNode*))` sets all pointers to `NULL`, which is required for leaf nodes and simplifies logic.\n- **Integer Overflow:** When calculating array sizes (e.g., `2*t - 1`), ensure `t` is not so large that it causes integer overflow. For this educational project, assume `t` is small (< 1000).\n- **Const Correctness:** For search functions that don't modify the tree, consider using `const` parameters (e.g., `const BTree* tree`) to signal intent, though the skeleton omits this for simplicity.\n- **Header Guards:** Always use `#ifndef BTREE_H` / `#define BTREE_H` / `#endif` in headers to prevent double inclusion.\n\n---\n\n\n## 3. High-Level Architecture\n\n> **Milestone(s):** This foundational section corresponds primarily to Milestone 1 (Node Structure), but also provides the overall architectural context for all subsequent milestones (2-4). Understanding how components interact is crucial before implementing search, insert, and delete operations.\n\nThe B-tree implementation follows a layered, modular architecture designed to separate concerns between data storage (`Node`), tree management (`BTree`), and algorithmic operations (`Operations`). This separation allows each component to focus on a single responsibility, making the system easier to understand, test, and extend. Although our educational implementation is in-memory, the architecture mirrors patterns used in disk-based systems where each node corresponds to a disk page.\n\n### Component Overview\n\nThink of the B-tree architecture as a **library building** with three distinct roles:\n- **The `Node` component** is like an **individual bookshelf** within the library, holding a collection of books (keys) and possibly pointers to other shelves (child nodes). Each shelf has strict capacity rules.\n- **The `BTree` component** is like the **library building's floor plan**, maintaining a reference to the main entrance (root node) and the building's structural rules (minimum degree `t`).\n- **The `Operations` component** is like the **librarian's procedures**, defining the step-by-step processes for finding a book, adding a new book (which may require splitting a full shelf), or removing a book (which may require borrowing from neighbors or merging shelves).\n\nThe relationship between these components is visualized in the following diagram, which shows how `BTree` orchestrates operations that manipulate `Node` instances:\n\n![B-tree System Components](./diagrams/arch-component.svg)\n\nThe table below details the responsibilities and key attributes of each logical component:\n\n| Component | Responsibility | Key Data it Holds | Key Behaviors it Manages |\n|-----------|----------------|-------------------|---------------------------|\n| **`BTree` (Orchestrator)** | Serves as the main entry point and container for the entire tree structure. It maintains global properties and ensures the tree invariants are preserved after operations. | • Root node pointer<br>• Minimum degree (`t`)<br>• Total key count (optional) | • Creating/destroying the tree<br>• Initiating search, insert, delete operations<br>• Validating tree structure<br>• Calculating tree height and size |\n| **`Node` (Data Container)** | Represents a single node (or disk page) in the B-tree. Stores keys and child pointers, and knows whether it is a leaf. It is the fundamental unit of data organization and transfer. | • Array of integer keys<br>• Array of child node pointers (for internal nodes)<br>• Count of keys currently stored (`num_keys`)<br>• Boolean flag indicating leaf status (`is_leaf`) | • Finding a key's position within its local array<br>• Reporting if it is full or underfull<br>• Splitting itself into two nodes (insert)<br>• Borrowing a key from or merging with a sibling (delete) |\n| **`Operations` (Algorithms)** | Encapsulates the core B-tree algorithms that traverse and modify the tree structure. These are implemented as functions that operate on the `BTree` and `Node` structures. | • No persistent state of its own | • Recursive tree traversal (search)<br>• Proactive node splitting during insertion descent<br>• Complex rebalancing (borrow/merge) during deletion |\n\n> **Key Design Insight:** The `BTree` struct acts as a thin facade. Its primary job is to hold the root pointer and configuration (`t`), delegating all complex logic to the operation functions which recursively navigate the node hierarchy. This keeps the tree's state simple and centralizes algorithm complexity in well-defined procedures.\n\n#### Component Interactions and Data Flow\n\nThe components interact through a clear calling hierarchy:\n1. **Client Code** calls a public function on the `BTree` component (e.g., `btree_insert`).\n2. **`BTree` Function** performs initial validation, then calls a recursive internal operation function, passing the root node and other parameters.\n3. **Internal Operation Function** traverses nodes, calling `Node` helper functions (like `node_find_key_index`) to navigate within each node. If structural changes are needed (split, borrow, merge), the operation function orchestrates these by creating/destroying nodes and updating pointers.\n4. **`Node` Helper Functions** perform localized tasks, such as inserting a key into a node's sorted array or splitting a node's keys and children into two.\n\nFor example, during an insertion that causes a root split:\n1. `btree_insert` is called on the `BTree`.\n2. The internal insertion function discovers the root is full.\n3. It creates a new root node and splits the old root, promoting the median key to the new root.\n4. It updates the `BTree`'s root pointer to point to the new root.\n5. Control returns to `btree_insert`, which updates the tree's key count.\n\nThis interaction pattern ensures that the `BTree` struct remains the single source of truth for the tree's identity (its root), while algorithms are free to manipulate the node graph.\n\n### Recommended File/Module Structure\n\nA clean, modular code organization is essential for managing the complexity of the B-tree algorithms. The following structure separates interface from implementation, groups related functions, and provides a clear path for testing. This is particularly important in C, where module boundaries are enforced by file organization rather than language features.\n\nThe recommended directory and file structure for a C implementation is as follows:\n\n```\nbtree-project/\n├── include/                    # Public header files (API)\n│   └── btree.h                # Main public interface: BTree, BTreeNode, SearchResult types and public function declarations\n├── src/                       # Private implementation source files\n│   ├── btree.c               # Implementation of public API functions (btree_create, btree_search, etc.)\n│   ├── btree_private.h       *Private header: declarations of internal helper functions and constants*\n│   ├── node.c                # Implementation of node-level functions (node_create, node_find_key_index, node_split, etc.)\n│   └── operations.c          # Implementation of core recursive algorithms (insert_recursive, delete_recursive, etc.)\n├── tests/                     # Test suite\n│   ├── test_btree.c          # Unit tests for the public API\n│   ├── test_node.c           # Unit tests for node utilities\n│   └── test_operations.c     # Unit tests for internal algorithms\n├── examples/                  # Example programs\n│   └── basic_usage.c         # Demonstrates creating a tree, inserting keys, searching, and deleting\n└── Makefile                   # Build automation\n```\n\n> *Note: `btree_private.h` is included only by `.c` files within the `src/` directory. It keeps internal implementation details (like recursive function prototypes) hidden from users of the public `btree.h` API.*\n\nThe table below justifies the purpose of each key file:\n\n| File | Purpose | Key Contents | Visibility |\n|------|---------|--------------|------------|\n| **`include/btree.h`** | Public API header. This is the only file a user of the B-tree library needs to include. | • `BTree`, `BTreeNode`, `SearchResult` type definitions (can be opaque pointers if desired)<br>• All public function prototypes (e.g., `btree_create`, `btree_insert`)<br>• Documentation comments for users | Public |\n| **`src/btree_private.h`** | Private implementation header. Shared internal details between `.c` files in the `src/` module. | • `DEFAULT_MIN_DEGREE` constant<br>• Prototypes for internal recursive functions (e.g., `insert_non_full`, `delete_from_subtree`)<br>• Helper function prototypes used across operations | Private (internal to library) |\n| **`src/btree.c`** | Implementation of the public API facade. Contains functions that initiate operations and manage the `BTree` struct. | • Definitions of `btree_create`, `btree_destroy`, `btree_size`, `btree_height`<br>• `btree_search`, `btree_insert`, `btree_delete` implementations (which call internal functions in `operations.c`)<br>• Public validation and print functions | Private implementation |\n| **`src/node.c`** | Implementation of all node-level utilities. Functions here operate on a single `BTreeNode`. | • `node_create`, `node_destroy`<br>• `node_find_key_index` (binary search)<br>• `node_is_full`, `node_is_underfull`<br>• `node_split_child` (critical for insertion)<br>• `node_borrow_from_left`, `node_merge_with_right` (for deletion) | Private implementation |\n| **`src/operations.c`** | Implementation of the core recursive algorithms that traverse and modify the tree. | • `search_recursive` (called by `btree_search`)<br>• `insert_non_full` (recursive insertion helper)<br>• `delete_from_subtree` (complex recursive deletion with borrow/merge logic) | Private implementation |\n\n> **Architecture Decision: Modular Separation of Node Utilities and Operations**\n> - **Context:** The B-tree algorithms require both low-level node manipulations (e.g., inserting a key into an array) and high-level recursive tree traversal logic. We needed to decide how to organize these related but distinct responsibilities.\n> - **Options Considered:**\n>   1. **Monolithic file:** Place all functions in one large `btree.c` file.\n>   2. **Separation by abstraction level:** Split node utilities (`node.c`) from tree operations (`operations.c`), with a public API layer (`btree.c`).\n>   3. **Separation by operation:** Have separate files for `search.c`, `insert.c`, `delete.c`.\n> - **Decision:** We chose option 2 (separation by abstraction level).\n> - **Rationale:** The node utilities (creating, destroying, searching within a node, splitting) are independent, reusable building blocks used by multiple operations. Separating them makes the code more modular and testable. It also mirrors the conceptual separation between the `Node` and `Operations` components. Option 1 leads to an unmanageably large file, while option 3 creates unnecessary fragmentation and duplication (e.g., both insert and delete need node-splitting logic).\n> - **Consequences:** Build times may be slightly longer due to more compilation units, but incremental compilation is improved. Developers must understand the dependency graph: `operations.c` depends on `node.c`, and `btree.c` depends on both.\n\nThis file structure provides a clear roadmap for implementation, aligning with the project milestones:\n- **Milestone 1** focuses on `node.c` and the data structures in `btree.h`.\n- **Milestone 2** focuses on `search_recursive` in `operations.c` and its exposure via `btree_search` in `btree.c`.\n- **Milestone 3** focuses on `insert_non_full` and `node_split_child` across `operations.c` and `node.c`.\n- **Milestone 4** focuses on `delete_from_subtree` and the borrow/merge helpers in `node.c`.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\nFor this C implementation, we recommend a straightforward approach suitable for learning. The \"Advanced Option\" column hints at production-ready extensions.\n\n| Component | Simple Option (Learning) | Advanced Option (Production) |\n|-----------|--------------------------|-----------------------------|\n| **Memory Management** | Standard `malloc`/`free` with careful manual tracking of all allocations. | Use a custom slab allocator or arena allocator to group node allocations, improving cache locality and reducing fragmentation. |\n| **Key Storage** | Fixed-size array of `int` within each node. Simple and predictable. | Support generic keys via function pointers (`compare_fn`) and store keys as `void*` or variable-length bytes. |\n| **Value Storage** | Store `void*` values in an array parallel to `keys`. Optional for Milestones 1-3. | Implement as a true key-value store with support for arbitrary value types and sizes. |\n| **Error Handling** | Return boolean success/failure from public functions. Use `assert` for internal invariants during debugging. | Rich error codes (`BTREE_ERR_MEMORY`, `BTREE_ERR_KEY_NOT_FOUND`). Pluggable error logging callback. |\n| **Persistence** | In-memory only for simplicity. | Add a `btree_save`/`btree_load` API that maps nodes to fixed-size disk pages using file I/O and `mmap`. |\n\n#### B. Recommended File/Module Structure (Code Layout)\nHere is the minimal starter code to set up the recommended file structure. Create these files with the following initial content.\n\n**File: `include/btree.h` (Public API)**\n```c\n#ifndef BTREE_H\n#define BTREE_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n// Forward declaration to make BTreeNode an opaque type.\n// Users only handle pointers; internal structure is hidden.\ntypedef struct BTreeNode BTreeNode;\n\ntypedef struct {\n    BTreeNode* root;\n    int t;                    // Minimum degree\n    size_t key_count;         // Total keys in the tree\n} BTree;\n\ntypedef struct {\n    bool found;\n    void* value;\n    int comparisons;          // For educational insight\n} SearchResult;\n\n// Tree lifecycle\nBTree* btree_create(int min_degree);\nvoid btree_destroy(BTree* tree);\n\n// Core operations\nSearchResult btree_search(BTree* tree, int key);\nbool btree_insert(BTree* tree, int key, void* value);\nbool btree_delete(BTree* tree, int key);\n\n// Inspection\nsize_t btree_size(BTree* tree);\nint btree_height(BTree* tree);\nbool btree_validate(BTree* tree);\nvoid btree_print(BTree* tree);\n\n#endif // BTREE_H\n```\n\n**File: `src/btree_private.h` (Private Implementation Details)**\n```c\n#ifndef BTREE_PRIVATE_H\n#define BTREE_PRIVATE_H\n\n#include \"btree.h\"\n\n// Default minimum degree if none specified\n#define DEFAULT_MIN_DEGREE 3\n\n// Internal node structure (visible only within src/)\nstruct BTreeNode {\n    int* keys;\n    void** values;           // Parallel array to keys\n    BTreeNode** children;    // Array of child pointers\n    int num_keys;            // Current number of keys\n    bool is_leaf;\n    // Note: No 't' stored per node; it's passed as parameter where needed.\n};\n\n// Node utilities (implemented in node.c)\nBTreeNode* node_create(int t, bool is_leaf);\nvoid node_destroy(BTreeNode* node);\nint node_find_key_index(BTreeNode* node, int key, int* comparisons);\nbool node_is_full(BTreeNode* node, int t);\nbool node_is_underfull(BTreeNode* node, int t);\n\n// Core operation helpers (implemented in operations.c)\nSearchResult search_recursive(BTreeNode* node, int key);\nbool insert_non_full(BTreeNode* node, int key, void* value, int t);\nbool delete_from_subtree(BTreeNode* node, int key, int t);\n\n#endif // BTREE_PRIVATE_H\n```\n\n**File: `src/btree.c` (Public API Implementation)**\n```c\n#include \"btree_private.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nBTree* btree_create(int min_degree) {\n    // TODO 1: Validate min_degree >= 2 (or use DEFAULT_MIN_DEGREE if invalid)\n    // TODO 2: Allocate memory for BTree struct\n    // TODO 3: Initialize fields: t = min_degree, key_count = 0\n    // TODO 4: Create an empty root node (leaf, with node_create)\n    // TODO 5: Set tree->root to the new node\n    // TODO 6: Return the tree pointer\n    return NULL;\n}\n\nvoid btree_destroy(BTree* tree) {\n    // TODO 1: If tree is NULL, return early\n    // TODO 2: Call node_destroy on tree->root (recursively frees all nodes)\n    // TODO 3: Free the tree struct itself\n}\n\nSearchResult btree_search(BTree* tree, int key) {\n    SearchResult result = {false, NULL, 0};\n    // TODO 1: If tree->root is NULL, return empty result\n    // TODO 2: Call search_recursive(tree->root, key) and store its result\n    // TODO 3: Return the result\n    return result;\n}\n\nbool btree_insert(BTree* tree, int key, void* value) {\n    // TODO 1: If tree or tree->root is NULL, return false\n    // TODO 2: Check if key already exists? (Optional, but can prevent duplicates)\n    // TODO 3: If root is full, handle root split:\n    //   - Create new root node (internal)\n    //   - Make old root the first child of new root\n    //   - Call node_split_child on new root to split the old root\n    //   - Update tree->root pointer\n    // TODO 4: Call insert_non_full(tree->root, key, value, tree->t)\n    // TODO 5: If insert successful, increment tree->key_count\n    // TODO 6: Return success status\n    return false;\n}\n\nbool btree_delete(BTree* tree, int key) {\n    // TODO 1: If tree or tree->root is NULL, return false\n    // TODO 2: Call delete_from_subtree(tree->root, key, tree->t)\n    // TODO 3: If deletion successful:\n    //   - Decrement tree->key_count\n    //   - If root now has 0 keys and is not a leaf:\n    //        * Set tree->root to its only child (root->children[0])\n    //        * Free the old root\n    // TODO 4: Return success status\n    return false;\n}\n\nsize_t btree_size(BTree* tree) {\n    // TODO: Return tree->key_count\n    return 0;\n}\n\nint btree_height(BTree* tree) {\n    // TODO 1: Start height = 0, current = tree->root\n    // TODO 2: While current != NULL, increment height and move to first child (if not leaf)\n    // TODO 3: Return height\n    return 0;\n}\n\nbool btree_validate(BTree* tree) {\n    // TODO: (For Milestone 4) Implement recursive invariant checking\n    //   - Check root key count: 0 <= num_keys < 2t (except root can have < t-1)\n    //   - For internal nodes: num_keys + 1 == number of non-NULL children\n    //   - Keys sorted within each node\n    //   - All leaves at same depth\n    //   - Child pointers' keys respect B-tree ordering\n    return false;\n}\n\nvoid btree_print(BTree* tree) {\n    // TODO: (Debug helper) Implement recursive printing with indentation\n}\n```\n\n**File: `src/node.c` (Node Utilities - Starter Code)**\n```c\n#include \"btree_private.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\nBTreeNode* node_create(int t, bool is_leaf) {\n    // TODO 1: Allocate memory for BTreeNode struct\n    // TODO 2: Allocate arrays: keys (size 2*t-1), children (size 2*t), values (size 2*t-1)\n    // TODO 3: Initialize fields: num_keys = 0, is_leaf = is_leaf\n    // TODO 4: Initialize children array to NULL (important!)\n    // TODO 5: Return the new node\n    return NULL;\n}\n\nvoid node_destroy(BTreeNode* node) {\n    // TODO 1: If node is NULL, return\n    // TODO 2: If not leaf, recursively destroy all non-NULL children\n    // TODO 3: Free the keys, values, children arrays\n    // TODO 4: Free the node struct itself\n}\n\nint node_find_key_index(BTreeNode* node, int key, int* comparisons) {\n    // TODO 1: Initialize left = 0, right = node->num_keys - 1\n    // TODO 2: While left <= right, perform binary search:\n    //   - mid = (left + right) / 2\n    //   - Increment *comparisons\n    //   - If node->keys[mid] == key, return mid (exact match)\n    //   - If node->keys[mid] < key, left = mid + 1\n    //   - Else right = mid - 1\n    // TODO 3: Return left (the index where key should be inserted, or child index to follow)\n    return 0;\n}\n\nbool node_is_full(BTreeNode* node, int t) {\n    // TODO: Return true if node->num_keys == 2*t - 1\n    return false;\n}\n\nbool node_is_underfull(BTreeNode* node, int t) {\n    // TODO: Return true if node->num_keys < t - 1 (except root case handled elsewhere)\n    return false;\n}\n```\n\n**File: `src/operations.c` (Core Algorithms - Placeholder)**\n```c\n#include \"btree_private.h\"\n\nSearchResult search_recursive(BTreeNode* node, int key) {\n    SearchResult result = {false, NULL, 0};\n    // TODO: To be implemented in Milestone 2\n    return result;\n}\n\nbool insert_non_full(BTreeNode* node, int key, void* value, int t) {\n    // TODO: To be implemented in Milestone 3\n    return false;\n}\n\nbool delete_from_subtree(BTreeNode* node, int key, int t) {\n    // TODO: To be implemented in Milestone 4\n    return false;\n}\n```\n\n#### C. Language-Specific Hints (C)\n\n1. **Memory Allocation:** Always check the return value of `malloc`. Use `calloc` for arrays you want zero-initialized (like `children` pointers). Remember to free in reverse order: first the internal arrays, then the struct.\n\n2. **Array Management:** When inserting/deleting keys within a node, you'll need to shift elements manually. Use `memmove` for efficiency when shifting large portions of the arrays.\n\n3. **Recursive Functions:** The recursive algorithms (`search_recursive`, `insert_non_full`, `delete_from_subtree`) will need the minimum degree `t` passed as a parameter at each call, since it's not stored in each node.\n\n4. **Debugging:** Use `assert` liberally during development to catch invariant violations (e.g., `assert(node->num_keys <= 2*t-1)`). Implement the `btree_print` function early to visualize tree structure after operations.\n\n5. **Build System:** A simple `Makefile` with separate compilation for each `.c` file will speed up development. Ensure `src/` files include `btree_private.h`, not `btree.h`, to maintain the abstraction boundary.\n\n---\n\n\n## 4. Data Model\n\n> **Milestone(s):** Milestone 1 (B-tree Node Structure), with foundational relevance to all subsequent operations (Milestones 2-4)\n\nThe data model defines the core building blocks and rules that give the B-tree its unique properties. Before diving into formal definitions, let's build an intuitive understanding of how these structures work together.\n\n### Core Types and Structures\n\nThink of the B-tree data model as a **well-organized warehouse storage system**. The entire warehouse (`BTree`) has a master floor plan (`root`) and a strict rule about shelf capacity (`minimum degree t`). Each storage shelf (`BTreeNode`) has labeled compartments (`keys`) that either point to other shelves in the warehouse (`children`) for internal nodes, or directly to stored inventory (`values`) for leaf nodes. The warehouse manager ensures every shelf follows exact capacity rules and that labels are always in alphabetical order.\n\nThis mental model helps visualize why B-trees excel at disk operations: each shelf corresponds to a **disk page** (typically 4KB), and accessing one shelf (loading a page from disk) lets you examine many labels (keys) at once before deciding which next shelf to visit. The strict capacity rules guarantee that shelves are neither too empty (wasting disk space) nor too full (requiring frequent reorganization), optimizing both storage density and access patterns.\n\nNow let's formalize these concepts into concrete data structures. The following table defines the two primary types that constitute our B-tree implementation:\n\n| Type Name | Field Name | Type | Description |\n|-----------|------------|------|-------------|\n| **`BTree`** (The entire warehouse) | `root` | `BTreeNode*` | Pointer to the root node of the tree. The entry point for all operations. When the tree is empty, this is `NULL`. |\n| | `t` | `int` | The **minimum degree** parameter that defines the capacity bounds for all nodes in the tree. This value is fixed when the tree is created and determines: <br>• Maximum keys per node: `2*t - 1` <br>• Minimum keys per node (except root): `t - 1` <br>• Maximum children per internal node: `2*t` <br>• Minimum children per internal node (except root): `t` |\n| | `key_count` | `size_t` | Total number of keys stored in the entire tree. Maintained for O(1) size queries. Updated on every insertion and deletion. |\n| **`BTreeNode`** (A single shelf) | `keys` | `int*` | Dynamic array of keys stored in this node. The array has capacity for `2*t - 1` integers. Keys within a node are always maintained in **ascending sorted order**. For internal nodes, keys act as separators between child subtrees. |\n| | `values` | `void**` | Optional array of opaque pointers associated with each key. In a key-value B-tree, this stores the value corresponding to each key. For educational purposes focusing only on key structure, this may be `NULL`. If implemented, it parallels the `keys` array (same length). |\n| | `children` | `BTreeNode**` | Dynamic array of child pointers. For internal nodes, this array has size `2*t` (one more than the number of keys). For leaf nodes, this is typically `NULL` or an array of `NULL` pointers (since leaves have no children). Each child pointer `children[i]` points to a subtree where all keys are greater than `keys[i-1]` and less than `keys[i]`. |\n| | `num_keys` | `int` | Current number of keys actually stored in this node. Must satisfy: <br>• For root: `0 ≤ num_keys ≤ 2*t - 1` <br>• For other nodes: `t-1 ≤ num_keys ≤ 2*t - 1` <br>Updated after every insertion, deletion, split, merge, or borrow operation. |\n| | `is_leaf` | `bool` | Boolean flag indicating whether this node is a leaf (true) or an internal node (false). Determines whether `children` pointers are followed during traversal. All leaf nodes are at the same depth (height from root). |\n| **`SearchResult`** (Search report) | `found` | `bool` | True if the search key was found in the tree, false otherwise. |\n| | `value` | `void*` | If `found` is true and values are stored, contains the opaque pointer associated with the found key. Otherwise `NULL`. |\n| | `comparisons` | `int` | Number of key comparisons performed during the search operation. Useful for performance analysis and debugging. |\n\n> **Design Insight:** The separation of `keys` and `children` into parallel arrays (rather than interleaved key-child pairs) simplifies index calculations during operations. The invariant `num_keys + 1 == num_children` for internal nodes means we can think of children as \"slots between and around keys\": child `i` contains keys less than `keys[i]` (if `i < num_keys`) and greater than `keys[i-1]` (if `i > 0`).\n\nThese structures relate to each other as shown in the following diagram:\n\n![B-tree Data Model](./diagrams/data-model-class.svg)\n\nThe diagram illustrates the containment hierarchy: a `BTree` contains a `root` pointer to a `BTreeNode`, which in turn contains `children` pointers to other `BTreeNode` instances. Each node maintains its `keys` in sorted order, with internal nodes having one more child than keys (creating the \"between and around\" relationship).\n\n### B-tree Invariants\n\nThe power of B-trees comes from maintaining five **invariants** (mathematical rules) that guarantee balanced height and efficient operations. These invariants are like the warehouse's operating regulations—if any is violated, the entire system becomes inefficient or incorrect.\n\n1. **Root Degree Invariant:** \n   > The root node may have as few as 1 key (or 0 if the tree is empty) and at most `2*t - 1` keys. Unlike other nodes, the root is exempt from the minimum key requirement (`t-1` keys) to allow the tree to grow and shrink gracefully.\n\n2. **Internal Node Key Bounds Invariant:**\n   > Every non-root internal node must have between `t-1` and `2*t - 1` keys inclusive. This ensures nodes are sufficiently full to justify the disk read/write cost while leaving room for insertions without immediate splits.\n\n3. **Leaf Node Key Bounds Invariant:**\n   > Every non-root leaf node must have between `t-1` and `2*t - 1` keys inclusive. Leaves follow the same capacity rules as internal nodes, maintaining uniform node sizes across the tree.\n\n4. **Child Count Invariant:**\n   > For any internal node with `k` keys, it must have exactly `k + 1` children. This creates the fundamental B-tree structure where each key separates two child subtrees, and there are always one more children than keys.\n\n5. **Key Ordering Invariant:**\n   > All keys within a node are stored in **strictly ascending order** (no duplicates). Furthermore, for any internal node, the keys in child `i` are all less than `keys[i]`, and the keys in child `i+1` are all greater than `keys[i]`. This recursive ordering property enables efficient binary search at every level.\n\nThese invariants work together to guarantee that a B-tree with `n` keys has height at most `O(log_t n)`. For typical disk-based systems with `t` around 100-200, this means even terabytes of data can be accessed with only 3-4 disk reads. The following table shows how operations maintain these invariants:\n\n| Operation | Which Invariants Might Be Threatened | How Operation Preserves Invariants |\n|-----------|--------------------------------------|------------------------------------|\n| **Insert** | Internal/Leaf Key Bounds (node becomes overfull with `2*t` keys) | **Proactive splitting** during descent ensures no node ever receives a key when already full. Splitting moves the median key up to the parent, creating two nodes each with `t-1` keys. |\n| **Delete** | Internal/Leaf Key Bounds (node becomes underfull with `t-2` keys) | **Borrowing** from a sibling (if possible) or **merging** with a sibling (otherwise) ensures every non-root node maintains at least `t-1` keys. |\n| **Root Split** | Root Degree (root becomes overfull) | Create a new root with one key (the median from the old root) and two children (the split halves of the old root). The new root satisfies the root's relaxed bounds (1 key). |\n| **Root Merge** | Root Degree (root becomes empty after merge) | When the root has 0 keys after a merge from its children, make the merged child the new root. Tree height decreases by 1. |\n\n> **Architecture Decision Record: Node Capacity Representation**\n> \n> **Context:** We need to represent a B-tree node's capacity constraints in code. The minimum degree `t` defines all bounds, but we must decide how to store and validate these bounds.\n> \n> **Options Considered:**\n> 1. **Store only `t` in `BTree`:** Each node calculates its bounds using the tree's `t` value.\n> 2. **Store `max_keys` and `min_keys` in each node:** Precompute `2*t-1` and `t-1` when creating a node.\n> 3. **Store `capacity` in each node:** Allocate arrays of size `2*t-1` for keys and `2*t` for children, and track `num_keys`.\n> \n> **Decision:** Option 1 (store only `t` in `BTree`) with dynamic array sizes based on `t`.\n> \n> **Rationale:** \n> - **Simplicity:** A single parameter `t` controls all bounds, reducing state to maintain.\n> - **Consistency:** All nodes in a tree share the same `t`, so storing it centrally avoids duplication.\n> - **Flexibility:** If we decide to support variable `t` per node (for advanced variants like B* trees), we can extend later.\n> - **Memory efficiency:** Not storing redundant bounds in every node saves memory, important for large trees.\n> \n> **Consequences:**\n> - **Positive:** Clean abstraction where `t` is a tree-wide property.\n> - **Negative:** Functions manipulating nodes need access to `t`, requiring it to be passed as a parameter.\n> - **Mitigation:** We'll pass `t` to all node operations as an explicit parameter, making dependencies clear.\n> \n> | Option | Pros | Cons | Chosen? |\n> |--------|------|------|---------|\n> | Store only `t` in `BTree` | Simple, memory efficient, centralized control | Need to pass `t` to node functions | ✅ Yes |\n> | Store bounds in each node | Node functions self-contained | Memory overhead, duplicate data | |\n> | Store capacity in each node | Clear array size tracking | Doesn't capture minimum bound, still needs `t` for splitting logic | |\n\n### Common Pitfalls: Data Model Misunderstandings\n\n⚠️ **Pitfall: Off-by-one in child pointer counts**\n- **Description:** Allocating `2*t` child pointers for a leaf node (which needs none) or allocating `2*t-1` child pointers for an internal node (which needs `2*t`).\n- **Why it's wrong:** Wastes memory for leaves, and causes buffer overflows for internal nodes when splitting (which requires temporarily storing `2*t` children before redistribution).\n- **Fix:** Only allocate child pointer array for internal nodes. For leaves, set `children = NULL`. Check `is_leaf` flag before accessing children.\n\n⚠️ **Pitfall: Forgetting to update `num_keys` after operations**\n- **Description:** Modifying the `keys` array (inserting, deleting, splitting) without updating the `num_keys` counter.\n- **Why it's wrong:** Binary search uses `num_keys` as the upper bound. If `num_keys` is too small, searches miss valid keys; if too large, searches access uninitialized memory.\n- **Fix:** Treat `num_keys` as the sacred source of truth. Every function that modifies `keys` must update `num_keys` as its final step. Consider writing an invariant checker that validates `num_keys` equals actual occupied slots.\n\n⚠️ **Pitfall: Assuming all nodes have values**\n- **Description:** Accessing `values[i]` without checking if the tree stores values or if the implementation is key-only.\n- **Why it's wrong:** In a key-only B-tree (common in set implementations), `values` may be `NULL`. Even in key-value trees, internal nodes often don't store values (only keys for routing).\n- **Fix:** Design clearly: either implement full key-value storage (with `values` array parallel to `keys`), or omit values entirely for simplicity. Document the choice.\n\n### Implementation Guidance\n\nNow let's bridge from design to implementation. For our C implementation, we'll create the foundational data structures with careful memory management.\n\n#### Technology Recommendations Table\n\n| Component | Simple Option (Educational Focus) | Advanced Option (Production Ready) |\n|-----------|-----------------------------------|------------------------------------|\n| **Memory Allocation** | Standard `malloc/free` with manual tracking | Memory pool allocator with slab allocation for nodes |\n| **Value Storage** | Opaque `void*` pointers allowing any data type | Typed unions with serialization for disk persistence |\n| **Capacity Management** | Dynamic arrays reallocated on split/merge | Fixed-size pages matching disk block size (e.g., 4096 bytes) |\n| **Debug Infrastructure** | Simple print functions and invariant checker | Comprehensive logging, visualization, and property testing |\n\n#### Recommended File/Module Structure\n\nFor a clean C implementation, organize files as follows:\n\n```\nbtree-project/\n├── include/\n│   └── btree.h          # Public interface declarations\n├── src/\n│   ├── btree.c          # BTree struct functions (create, destroy, public ops)\n│   ├── node.c           # BTreeNode functions (create, destroy, helpers)\n│   ├── search.c         # Search algorithm implementation\n│   ├── insert.c         # Insertion with splitting\n│   ├── delete.c         # Deletion with rebalancing\n│   └── debug.c          # Validation, printing, debugging utilities\n└── tests/\n    ├── test_btree.c     # Comprehensive test suite\n    └── test_utils.c     # Testing utilities\n```\n\nThis separation follows the single responsibility principle: `btree.c` manages the tree-level operations, `node.c` handles node-level manipulations, and operation-specific files contain the algorithmic logic.\n\n#### Infrastructure Starter Code\n\nHere's complete, working code for the foundational data structures and basic utilities. Learners should copy this as their starting point.\n\n**File: `include/btree.h`**\n```c\n#ifndef BTREE_H\n#define BTREE_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n// Forward declaration for opaque pointer pattern\ntypedef struct BTreeNode BTreeNode;\n\n// Search result structure\ntypedef struct {\n    bool found;\n    void* value;\n    int comparisons;\n} SearchResult;\n\n// Main B-tree structure\ntypedef struct {\n    BTreeNode* root;\n    int t;  // Minimum degree\n    size_t key_count;\n} BTree;\n\n// Public API\nBTree* btree_create(int min_degree);\nvoid btree_destroy(BTree* tree);\nSearchResult btree_search(BTree* tree, int key);\nbool btree_insert(BTree* tree, int key, void* value);\nbool btree_delete(BTree* tree, int key);\nsize_t btree_size(BTree* tree);\nint btree_height(BTree* tree);\nbool btree_validate(BTree* tree);\nvoid btree_print(BTree* tree);\n\n// Default minimum degree if not specified\n#define DEFAULT_MIN_DEGREE 3\n\n#endif // BTREE_H\n```\n\n**File: `src/node.c` - Foundation implementation**\n```c\n#include \"btree.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n// B-tree node structure definition\nstruct BTreeNode {\n    int* keys;           // Array of keys\n    void** values;       // Optional array of values (parallel to keys)\n    BTreeNode** children; // Array of child pointers\n    int num_keys;        // Current number of keys\n    bool is_leaf;        // Is this a leaf node?\n};\n\n// Helper function: Create a new empty node\nBTreeNode* node_create(int t, bool is_leaf) {\n    BTreeNode* node = (BTreeNode*)malloc(sizeof(BTreeNode));\n    if (!node) return NULL;\n    \n    // Allocate arrays based on B-tree properties\n    // Maximum keys: 2*t - 1\n    node->keys = (int*)malloc((2*t - 1) * sizeof(int));\n    // Optional: allocate values array if implementing key-value store\n    node->values = NULL; // Or malloc((2*t - 1) * sizeof(void*)) for key-value\n    \n    // For internal nodes, allocate child pointers (2*t capacity)\n    // For leaves, children remain NULL\n    if (!is_leaf) {\n        node->children = (BTreeNode**)malloc(2*t * sizeof(BTreeNode*));\n        // Initialize all children to NULL\n        for (int i = 0; i < 2*t; i++) {\n            node->children[i] = NULL;\n        }\n    } else {\n        node->children = NULL;\n    }\n    \n    node->num_keys = 0;\n    node->is_leaf = is_leaf;\n    \n    return node;\n}\n\n// Helper function: Destroy a node and all its descendants recursively\nvoid node_destroy(BTreeNode* node) {\n    if (!node) return;\n    \n    // Recursively destroy all children\n    if (!node->is_leaf) {\n        for (int i = 0; i <= node->num_keys; i++) {\n            if (node->children[i]) {\n                node_destroy(node->children[i]);\n            }\n        }\n        free(node->children);\n    }\n    \n    free(node->keys);\n    if (node->values) {\n        free(node->values);\n    }\n    free(node);\n}\n\n// Helper function: Check if a node is full (has 2*t - 1 keys)\nbool node_is_full(BTreeNode* node, int t) {\n    return node->num_keys == (2*t - 1);\n}\n\n// Helper function: Check if a node is underfull (has fewer than t-1 keys)\nbool node_is_underfull(BTreeNode* node, int t) {\n    return node->num_keys < (t - 1);\n}\n```\n\n**File: `src/btree.c` - Tree-level infrastructure**\n```c\n#include \"btree.h\"\n#include <stdlib.h>\n\n// Create a new empty B-tree with given minimum degree\nBTree* btree_create(int min_degree) {\n    if (min_degree < 2) {\n        // B-tree requires t >= 2 for proper splitting\n        min_degree = DEFAULT_MIN_DEGREE;\n    }\n    \n    BTree* tree = (BTree*)malloc(sizeof(BTree));\n    if (!tree) return NULL;\n    \n    tree->root = NULL;\n    tree->t = min_degree;\n    tree->key_count = 0;\n    \n    return tree;\n}\n\n// Destroy the entire B-tree and free all memory\nvoid btree_destroy(BTree* tree) {\n    if (!tree) return;\n    \n    if (tree->root) {\n        node_destroy(tree->root);\n    }\n    \n    free(tree);\n}\n\n// Get the number of keys in the tree (O(1) version)\nsize_t btree_size(BTree* tree) {\n    return tree ? tree->key_count : 0;\n}\n\n// Simple placeholder implementations - to be completed in milestones\nSearchResult btree_search(BTree* tree, int key) {\n    SearchResult result = {false, NULL, 0};\n    // TODO Milestone 2: Implement search\n    (void)tree; (void)key; // Suppress unused parameter warnings\n    return result;\n}\n\nbool btree_insert(BTree* tree, int key, void* value) {\n    // TODO Milestone 3: Implement insertion\n    (void)tree; (void)key; (void)value;\n    return false;\n}\n\nbool btree_delete(BTree* tree, int key) {\n    // TODO Milestone 4: Implement deletion\n    (void)tree; (void)key;\n    return false;\n}\n\nint btree_height(BTree* tree) {\n    // TODO: Implement height calculation\n    (void)tree;\n    return 0;\n}\n\nbool btree_validate(BTree* tree) {\n    // TODO: Implement invariant validation\n    (void)tree;\n    return true;\n}\n\nvoid btree_print(BTree* tree) {\n    // TODO: Implement tree printing\n    (void)tree;\n}\n```\n\n#### Core Logic Skeleton Code\n\nFor the core operations that learners will implement themselves (starting with Milestone 1), here are skeleton functions with detailed TODOs:\n\n**File: `src/node.c` - Continued (core logic skeletons)**\n```c\n// Helper function: Find the index where a key should be in this node\n// Uses binary search for O(log t) performance within a node\n// Returns:\n//   - If key is found: index of the key (0 ≤ index < num_keys)\n//   - If key is not found: -(insert_position + 1) where insert_position is\n//     where the key would be inserted (0 ≤ insert_position ≤ num_keys)\n// Also increments *comparisons if pointer is not NULL\nint node_find_key_index(BTreeNode* node, int key, int* comparisons) {\n    // TODO 1: Initialize binary search bounds: left = 0, right = num_keys - 1\n    // TODO 2: While left <= right:\n    //   TODO 2a: Calculate mid = left + (right - left) / 2\n    //   TODO 2b: Compare key with node->keys[mid]\n    //   TODO 2c: Increment *comparisons if comparisons pointer is not NULL\n    //   TODO 2d: If key == node->keys[mid], return mid (found)\n    //   TODO 2e: If key < node->keys[mid], search left half (adjust right)\n    //   TODO 2f: If key > node->keys[mid], search right half (adjust left)\n    // TODO 3: If key not found, return -(left + 1) where left is insert position\n    // Hint: This follows standard binary search with careful handling of\n    // the \"not found\" case using negative encoding\n    return 0;\n}\n```\n\n#### Language-Specific Hints for C\n\n- **Memory Management:** Always check `malloc` return values for `NULL`. In production code, handle allocation failures gracefully. For educational purposes, you might use `assert` or simply exit with an error message.\n\n- **Array Bounds:** C doesn't check array bounds. Be meticulous with indices, especially when accessing `children[i]` where `i` can be `num_keys` (valid for the rightmost child).\n\n- **Integer Division:** When calculating the median during splitting (`t - 1`), remember C integer division truncates. With `t=3`, `(2*t - 1) = 5` keys, median index is `2` (0-based), which equals `t - 1`.\n\n- **const Correctness:** For search functions that don't modify nodes, consider using `const BTreeNode*` to indicate read-only access and prevent accidental modifications.\n\n- **Header Guards:** Always use `#ifndef/#define` guards in header files to prevent multiple inclusion, as shown in `btree.h`.\n\n#### Milestone Checkpoint: Data Structure Validation\n\nAfter implementing the data structures from Milestone 1 (before implementing search/insert/delete), verify your foundation:\n\n1. **Compilation Test:**\n   ```bash\n   gcc -c src/btree.c src/node.c -I./include\n   ```\n   Should compile without errors or warnings.\n\n2. **Memory Leak Test:**\n   ```c\n   // In a simple test program:\n   #include \"btree.h\"\n   int main() {\n       BTree* tree = btree_create(3);\n       // Should create tree with t=3, root=NULL, key_count=0\n       \n       // Create a sample node\n       BTreeNode* node = node_create(3, true);\n       // Should allocate keys array of size 5, children=NULL, is_leaf=true\n       \n       // Clean up\n       node_destroy(node);\n       btree_destroy(tree);\n       return 0;\n   }\n   ```\n   Run with Valgrind to ensure no memory leaks:\n   ```bash\n   valgrind --leak-check=full ./test_program\n   ```\n\n3. **Invariant Awareness:** Manually verify you understand the capacity rules:\n   - For `t=3`, maximum keys = `2*3 - 1 = 5`, minimum keys (non-root) = `3 - 1 = 2`\n   - For `t=3`, internal nodes have up to `2*3 = 6` children, at least `3` children (except root)\n   - Root can have 1-5 keys (or 0 if tree empty)\n\nIf you encounter segmentation faults, likely causes are:\n- **Accessing `children` array on a leaf node** → Check `is_leaf` before accessing `children`\n- **Array index out of bounds** → Verify `num_keys` is correctly maintained and used as array bound\n- **Double-free** → Ensure `node_destroy` handles `NULL` children pointers and `NULL` values array\n\nWith these data structures solidly implemented, you have the foundation for implementing B-tree operations in subsequent milestones.\n\n\n## 5. Component Design: B-tree Node\n\n> **Milestone(s):** Milestone 1 (B-tree Node Structure)\n\nThe B-tree node is the fundamental storage unit of the entire data structure—the \"atom\" from which the entire tree is built. Every operation (search, insert, delete) begins and ends with manipulations of nodes. This component defines how keys and child pointers are organized within a single node, establishes the boundary conditions for node capacity, and differentiates between leaf nodes (which store actual data) and internal nodes (which provide navigation). Getting this foundation right is critical because all subsequent operations build upon these basic building blocks.\n\n### Mental Model: A Bookshelf with Dividers\n\nImagine a bookshelf in a library that can hold a fixed maximum number of books. This bookshelf has dividers (vertical partitions) that separate sections, and each section contains either:\n1. **Direct references to books** (if this is a leaf shelf)\n2. **References to other shelves** (if this is an index shelf)\n\n**Keys as dividers:** Each divider has a label (the \"key\") that indicates the range of books/shelves in the section to its left. For example, a divider labeled \"M\" means all books/shelves to the left have titles alphabetically before \"M\".\n\n**Child pointers as sections:** The spaces between dividers (and the ends) are \"slots\" that hold either book references (at leaves) or pointers to other shelves (in internal nodes). A node with `k` keys has exactly `k+1` child slots.\n\n**Capacity constraints:** Each shelf has a strict capacity: it can hold between `t-1` and `2t-1` dividers (except the topmost shelf, which can have as few as 1 divider). When a shelf becomes too full (exceeds `2t-1` dividers), it must be split. When a shelf becomes too empty (falls below `t-1` dividers), it must borrow from a neighbor or merge.\n\n**Leaf vs. internal distinction:** Leaf shelves contain actual books (data values). Index shelves contain only dividers and references to other shelves—they never store books directly. The bottommost shelves in the library are always leaves.\n\nThis mental model helps visualize why B-trees are so disk-efficient: each \"shelf\" corresponds to one disk page (typically 4KB), and we maximize the number of keys per page to minimize the number of disk seeks during navigation. The strict capacity bounds ensure the tree remains balanced, guaranteeing predictable performance.\n\n### Interface and Operations\n\nThe node component provides the following core functions for creating, manipulating, and querying individual B-tree nodes. These functions are used internally by the B-tree operations (search, insert, delete) but are not exposed directly to external callers—they form the private API of the B-tree implementation.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `node_create` | `t` (minimum degree, `int`), `is_leaf` (`bool`) | `BTreeNode*` | Allocates and initializes a new empty node. The node starts with 0 keys, and its child pointers are initialized to `NULL`. The `is_leaf` flag determines whether this node will store values directly (leaf) or child pointers (internal). |\n| `node_destroy` | `node` (`BTreeNode*`) | `void` | Recursively deallocates a node and all its descendants. For leaf nodes, this may also free associated values if the B-tree owns them. |\n| `node_find_key_index` | `node` (`BTreeNode*`), `key` (`int`), `comparisons` (`int*`) | `int` | Performs binary search within the node's sorted keys array to locate either (1) the exact position of `key` if present, or (2) the index of the child subtree where `key` would be located. The `comparisons` pointer allows counting search operations for performance analysis. |\n| `node_is_full` | `node` (`BTreeNode*`), `t` (`int`) | `bool` | Checks whether the node has reached its maximum capacity (`2t-1` keys). Used during insertion to determine if a split is needed. |\n| `node_is_underfull` | `node` (`BTreeNode*`), `t` (`int`) | `bool` | Checks whether the node has fallen below its minimum allowed capacity (`t-1` keys, except for the root). Used during deletion to trigger rebalancing operations. |\n| `node_insert_key` | `node` (`BTreeNode*`), `index` (`int`), `key` (`int`), `value` (`void*`) | `void` | Inserts a new key (and optional associated value) at position `index` within the node's keys array, shifting existing keys and child pointers right as needed. Assumes the node is not full and maintains sorted order. |\n| `node_remove_key` | `node` (`BTreeNode*`), `index` (`int`) | `void` | Removes the key at position `index`, shifting subsequent keys and child pointers left to fill the gap. For leaf nodes, may also free the associated value. |\n| `node_split_child` | `parent` (`BTreeNode*`), `child_index` (`int`), `t` (`int`) | `void` | Splits a full child node at `child_index` into two nodes, promoting the median key to the parent. The left child retains the first `t-1` keys, the right child gets the last `t-1` keys, and the median (t-th) key moves up to the parent at position `child_index`. |\n| `node_borrow_from_left` | `node` (`BTreeNode*`), `parent` (`BTreeNode*`), `child_index` (`int`) | `void` | Borrows a key from the left sibling through the parent to fix an underflow condition. The parent's key at `child_index-1` moves down into `node`, and the left sibling's last key moves up to replace it. Corresponding child pointers are also transferred. |\n| `node_borrow_from_right` | `node` (`BTreeNode*`), `parent` (`BTreeNode*`), `child_index` (`int`) | `void` | Borrows a key from the right sibling through the parent. The parent's key at `child_index` moves down into `node`, and the right sibling's first key moves up to replace it. Corresponding child pointers are transferred. |\n| `node_merge_children` | `parent` (`BTreeNode*`), `child_index` (`int`), `t` (`int`) | `void` | Merges the child at `child_index` with its right sibling, using the parent's key at `child_index` as an additional key. All keys from both children and the parent key are combined into a single node, and the empty sibling is destroyed. |\n\n### ADR: Node Memory Layout\n\n> **Decision: Separate Arrays for Keys and Children**\n> - **Context**: We need to store two types of data in each B-tree node: (1) an array of integer keys, and (2) an array of child pointers (for internal nodes) or value pointers (for leaf nodes). The memory layout must support efficient binary search within keys, straightforward insertion/deletion with shifting, and clear distinction between leaf and internal node behavior.\n> - **Options Considered**:\n>   1. **Separate arrays**: One contiguous array for keys, another contiguous array for child/value pointers.\n>   2. **Unified array of structs**: An array where each element is a struct containing both a key and a child/value pointer.\n>   3. **Hybrid with union**: Separate key array, but child/value pointers stored in a union type that can represent either children or values based on leaf status.\n> - **Decision**: Use separate arrays for keys and child pointers, with leaf nodes storing values in the child pointer array (reinterpreted as `void*` values).\n> - **Rationale**:\n>   - **Binary search efficiency**: Searching within a contiguous array of keys (integers) is cache-friendly and allows standard binary search implementation without pointer dereferencing overhead.\n>   - **Insertion/deletion simplicity**: When inserting a new key, we shift only the keys array; child pointers shift independently at the same index. This maintains the invariant that child `i` contains keys less than key `i`, and child `i+1` contains keys greater than key `i`.\n>   - **Memory alignment**: Integer keys are typically 4 bytes, while pointers are 8 bytes on 64-bit systems. Keeping them separate avoids padding issues in a unified struct.\n>   - **Clear semantics**: The `is_leaf` flag determines how to interpret the pointer array: as `BTreeNode*` children for internal nodes, or as `void*` values for leaf nodes. This avoids the complexity of unions while maintaining type safety through careful casting.\n>   - **Educational clarity**: The separate-array approach matches most textbook descriptions and visualizations of B-trees, making the code easier to understand for learners.\n> - **Consequences**:\n>   - **Positive**: Simple, predictable memory access patterns; easy to implement binary search; clear correspondence with theoretical B-tree diagrams.\n>   - **Negative**: Requires maintaining two arrays with coordinated indices; leaf nodes waste the child pointer capacity (they allocate space for `2t` pointers but only use them for values). This waste is acceptable for an in-memory educational implementation.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **Separate arrays** | - Efficient binary search on keys<br>- Clear index correspondence between keys and children<br>- Matches textbook descriptions<br>- Simple insertion shifting logic | - Leaf nodes allocate unused child pointer capacity<br>- Requires coordinated management of two arrays | **Yes** |\n| **Unified array of structs** | - Keys and pointers stored together (potentially better locality)<br>- Single array to manage | - Binary search must access keys through structs (slightly more overhead)<br>- Insertion requires shifting larger structs<br>- Less intuitive mapping to B-tree theory | No |\n| **Hybrid with union** | - Explicit type differentiation via union tag<br>- No wasted space for leaf nodes (values stored directly) | - More complex type handling<br>- Requires careful casting and union access<br>- Additional branching based on leaf status | No |\n\nThe chosen layout directly corresponds to the `BTreeNode` struct definition from Section 4:\n- `keys`: `int*` – Dynamic array of `2t-1` integers\n- `children`: `BTreeNode**` – Dynamic array of `2t` pointers (interpreted as `void**` for leaf values)\n- `num_keys`: `int` – Current number of keys (0 to `2t-1`)\n- `is_leaf`: `bool` – Determines interpretation of `children` array\n\n![B-tree Data Model](./diagrams/data-model-class.svg)\n\n### Common Pitfalls: Node Capacity\n\nB-tree nodes have strict capacity bounds that must be maintained at all times. These invariants are easy to violate accidentally, especially when implementing split and merge operations. Below are the most common mistakes learners make when implementing the node component.\n\n⚠️ **Pitfall: Off-by-one errors in key counts**\n- **Description**: Incorrectly calculating the maximum (`2t-1`) or minimum (`t-1`) key counts, or mishandling the root's special case (can have as few as 1 key). For example, checking `if (node->num_keys == 2*t)` instead of `if (node->num_keys == 2*t - 1)` for fullness.\n- **Why it's wrong**: Violates B-tree invariants, leading to potential tree corruption. A node with `2t` keys would overflow its array bounds (which is sized for `2t-1` keys). A node with `t-2` keys (when not the root) would be underfull, causing search paths to become imbalanced.\n- **How to fix**: Define helper functions `node_is_full()` and `node_is_underfull()` that encapsulate these calculations. Use these functions consistently throughout the codebase instead of repeating the logic. Remember the root exception: `node_is_underfull()` should return `false` for the root regardless of key count.\n\n⚠️ **Pitfall: Forgetting to initialize child pointers to NULL**\n- **Description**: After allocating the `children` array (size `2t`), failing to set all elements to `NULL`. This is especially critical for leaf nodes, where all child pointers should be `NULL`, and for internal nodes where unused slots beyond `num_keys+1` should be `NULL`.\n- **Why it's wrong**: Uninitialized pointers cause undefined behavior when accessed (e.g., during recursive destruction or when checking if a child exists). This often manifests as segmentation faults during tree traversal or memory leaks during cleanup.\n- **How to fix**: In `node_create()`, after allocating the `children` array, loop through all `2t` slots and explicitly set them to `NULL`. Similarly, when increasing `num_keys` (e.g., during insertion), ensure new child pointers are initialized to `NULL`.\n\n⚠️ **Pitfall: Mis-handling the leaf flag during node splitting**\n- **Description**: When splitting a child node, incorrectly setting the `is_leaf` flag on the new right sibling. For example, copying the flag from the original child without considering that leaves should remain leaves and internal nodes should remain internal.\n- **Why it's wrong**: If an internal node's child is incorrectly marked as leaf, subsequent insertions will fail to recurse deeper, causing keys to be inserted at the wrong level. If a leaf node's child is incorrectly marked as internal, attempts to traverse further will fail (since child pointers are `NULL`).\n- **How to fix**: When creating the right sibling during a split, explicitly copy the `is_leaf` flag from the original child being split. Both the left half (original child, now truncated) and right half (new sibling) should have the same leaf status as the original node before splitting.\n\n⚠️ **Pitfall: Incorrect child pointer indexing after key insertion/removal**\n- **Description**: When inserting or removing a key at index `i`, forgetting to shift child pointers at the same index. The invariant is that child `i` contains keys less than key `i`, and child `i+1` contains keys greater than key `i`. After inserting a new key at index `i`, child pointers from `i+1` onward must shift right by one position.\n- **Why it's wrong**: Breaks the parent-child relationship, causing subtrees to become disconnected or assigned to wrong key ranges. This corrupts the tree structure and leads to missing keys during search.\n- **How to fix**: Implement helper functions `node_insert_key()` and `node_remove_key()` that handle both key and child pointer shifting together. Always remember that a node with `k` keys has `k+1` child pointers (even for leaves, though they're unused).\n\n⚠️ **Pitfall: Not updating num_keys after mutations**\n- **Description**: Forgetting to increment `num_keys` after inserting a key or decrement it after removing a key, while still updating the keys array.\n- **Why it's wrong**: The `num_keys` field becomes out of sync with the actual data in the arrays. This causes binary search to examine uninitialized key values and can lead to array bounds violations when accessing children.\n- **How to fix**: Update `num_keys` as the last step in any mutation function, after all array shifts are complete. Better yet, encapsulate all mutations in small, well-tested functions that guarantee consistency.\n\n### Implementation Guidance\n\n> **Technology Note**: This implementation uses plain C for direct memory control, which is appropriate for understanding the low-level details of B-tree node layout. The `stdlib.h` provides dynamic memory allocation, and `stdbool.h` gives us boolean types.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Memory Allocation | `malloc()`/`free()` with explicit NULL checks | Memory pool allocator for fixed-size node allocations |\n| Array Management | Separate `keys` and `children` arrays with manual shifting | Generic array utility functions with `memmove()` |\n| Debugging | `assert()` statements for invariants | Custom invariant checker with detailed error messages |\n\n#### B. Recommended File/Module Structure\n\n```\nbtree-project/\n├── include/\n│   └── btree.h           ← Public interface (BTree, SearchResult, etc.)\n├── src/\n│   ├── btree.c           ← Main B-tree operations (search, insert, delete)\n│   ├── node.c            ← Node-specific functions (this component)\n│   └── btree_utils.c     ← Utility functions (validation, printing)\n└── tests/\n    ├── test_node.c       ← Unit tests for node functions\n    └── test_btree.c      ← Integration tests\n```\n\n#### C. Infrastructure Starter Code\n\n**File: `include/btree.h`** (partial - node-related declarations)\n```c\n#ifndef BTREE_H\n#define BTREE_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n// Forward declaration for opaque pointer\ntypedef struct BTreeNode BTreeNode;\n\n// B-tree structure\ntypedef struct {\n    BTreeNode* root;\n    int t;  // Minimum degree\n    size_t key_count;\n} BTree;\n\n// Search result structure\ntypedef struct {\n    bool found;\n    void* value;\n    int comparisons;\n} SearchResult;\n\n// Public interface functions (declarations only)\nBTree* btree_create(int min_degree);\nvoid btree_destroy(BTree* tree);\nSearchResult btree_search(BTree* tree, int key);\nbool btree_insert(BTree* tree, int key, void* value);\nbool btree_delete(BTree* tree, int key);\nsize_t btree_size(BTree* tree);\nint btree_height(BTree* tree);\nbool btree_validate(BTree* tree);\nvoid btree_print(BTree* tree);\n\n// Node functions (internal, but declared here for testing)\n#ifdef BTREE_INTERNAL\nBTreeNode* node_create(int t, bool is_leaf);\nvoid node_destroy(BTreeNode* node);\nint node_find_key_index(BTreeNode* node, int key, int* comparisons);\nbool node_is_full(BTreeNode* node, int t);\nbool node_is_underfull(BTreeNode* node, int t);\n#endif // BTREE_INTERNAL\n\n#endif // BTREE_H\n```\n\n**File: `src/node.c`** (starter infrastructure)\n```c\n#include \"btree.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\n// B-tree node structure definition (hidden from public header)\nstruct BTreeNode {\n    int* keys;           // Array of keys\n    void** values;       // For leaves: array of value pointers\n    BTreeNode** children; // For internal nodes: array of child pointers\n    int num_keys;        // Current number of keys\n    bool is_leaf;        // Leaf or internal node\n    // Note: We use values for leaves and children for internal nodes,\n    // but they share the same memory slot in the struct.\n    // We'll manage this through the is_leaf flag.\n};\n\n// Helper function to allocate and initialize arrays\nstatic void node_allocate_arrays(BTreeNode* node, int t) {\n    // Keys array: maximum (2t-1) keys\n    node->keys = (int*)malloc(sizeof(int) * (2 * t - 1));\n    if (!node->keys) {\n        perror(\"Failed to allocate keys array\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // Children/values array: maximum 2t children\n    // We allocate as BTreeNode** but will interpret as void** for leaves\n    node->children = (BTreeNode**)malloc(sizeof(BTreeNode*) * (2 * t));\n    if (!node->children) {\n        free(node->keys);\n        perror(\"Failed to allocate children array\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // Initialize all child pointers to NULL\n    for (int i = 0; i < 2 * t; i++) {\n        node->children[i] = NULL;\n    }\n}\n\nBTreeNode* node_create(int t, bool is_leaf) {\n    // Validate minimum degree\n    if (t < 2) {\n        fprintf(stderr, \"Minimum degree t must be at least 2\\n\");\n        return NULL;\n    }\n    \n    // Allocate node structure\n    BTreeNode* node = (BTreeNode*)malloc(sizeof(BTreeNode));\n    if (!node) {\n        perror(\"Failed to allocate B-tree node\");\n        return NULL;\n    }\n    \n    // Initialize fields\n    node->num_keys = 0;\n    node->is_leaf = is_leaf;\n    \n    // Allocate arrays\n    node_allocate_arrays(node, t);\n    \n    return node;\n}\n\nvoid node_destroy(BTreeNode* node) {\n    if (!node) return;\n    \n    // If internal node, recursively destroy children\n    if (!node->is_leaf) {\n        for (int i = 0; i <= node->num_keys; i++) {\n            if (node->children[i]) {\n                node_destroy(node->children[i]);\n            }\n        }\n    } else {\n        // For leaf nodes, we might need to free values if they're owned\n        // In this basic implementation, we assume caller manages values\n        // so we don't free them here\n    }\n    \n    // Free arrays\n    free(node->keys);\n    free(node->children);\n    \n    // Free node itself\n    free(node);\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**File: `src/node.c`** (continued - core functions with TODOs)\n```c\n// Finds the position of key within a node using binary search\n// Returns:\n// - If key is found: index of the key (0 <= index < node->num_keys)\n// - If key is not found: index of the child where key should be (0 <= index <= node->num_keys)\nint node_find_key_index(BTreeNode* node, int key, int* comparisons) {\n    if (!node) {\n        return 0;\n    }\n    \n    int left = 0;\n    int right = node->num_keys - 1;\n    int mid = 0;\n    \n    // TODO 1: Handle empty node case (num_keys == 0) - return 0\n    \n    // TODO 2: Implement binary search loop:\n    //   while (left <= right) {\n    //     mid = left + (right - left) / 2;\n    //     (*comparisons)++;\n    //     if (node->keys[mid] == key) {\n    //         return mid; // Key found at index mid\n    //     } else if (node->keys[mid] < key) {\n    //         left = mid + 1;\n    //     } else {\n    //         right = mid - 1;\n    //     }\n    //   }\n    \n    // TODO 3: Key not found in this node\n    // Return the index of the child where the key would be\n    // This should be the value of 'left' after the loop ends\n}\n\nbool node_is_full(BTreeNode* node, int t) {\n    // TODO: Check if node has reached maximum capacity (2t-1 keys)\n    // Remember: node can be NULL (handle gracefully)\n}\n\nbool node_is_underfull(BTreeNode* node, int t) {\n    // TODO: Check if node has fallen below minimum capacity (t-1 keys)\n    // Exception: Root node is allowed to be underfull (return false for root)\n    // Hint: This function doesn't know if it's the root, so the caller\n    // must handle the root case separately\n}\n\n// Inserts a new key into the node at the specified index\n// Assumes: node is not full, index is valid (0 <= index <= node->num_keys)\nvoid node_insert_key(BTreeNode* node, int index, int key, void* value) {\n    // TODO 1: Shift existing keys from index to num_keys-1 one position right\n    // Use memmove or a for loop\n    \n    // TODO 2: Shift child pointers from index+1 to num_keys+1 one position right\n    // Important: A node with k keys has k+1 child pointers\n    \n    // TODO 3: Insert the new key at keys[index]\n    \n    // TODO 4: If leaf node, store value at children[index] (interpreted as void*)\n    // If internal node, the new child pointer should already be NULL (initialized)\n    \n    // TODO 5: Increment num_keys\n}\n\n// Removes the key at the specified index from the node\nvoid node_remove_key(BTreeNode* node, int index) {\n    // TODO 1: Shift existing keys from index+1 to num_keys-1 one position left\n    \n    // TODO 2: Shift child pointers from index+1 to num_keys one position left\n    \n    // TODO 3: Decrement num_keys\n    \n    // TODO 4: For leaf nodes, we might want to clear the last child pointer\n    // (set children[num_keys] to NULL since we now have one fewer key)\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **Memory Management**: Always check `malloc()` return values. In production code, you'd handle allocation failures gracefully; for this educational implementation, we exit with an error for simplicity.\n\n2. **Type Casting**: When dealing with the `children` array in leaf nodes (where it stores `void*` values), you'll need to cast: `(void*)node->children[i]`. Be consistent with these casts to avoid compiler warnings.\n\n3. **Array Shifting**: Use `memmove()` for shifting elements in arrays rather than manual loops—it's safer and often optimized. Example: `memmove(&node->keys[index+1], &node->keys[index], (node->num_keys - index) * sizeof(int))`.\n\n4. **Debugging**: Compile with `-g -DDEBUG` flags to include debug symbols and assertions. Use `assert(node->num_keys >= 0 && node->num_keys <= 2*t-1)` liberally in node functions.\n\n5. **Const Correctness**: For read-only functions like `node_find_key_index`, mark the node parameter as `const`: `int node_find_key_index(const BTreeNode* node, ...)`.\n\n#### F. Milestone Checkpoint\n\nAfter implementing the node infrastructure:\n\n1. **Compile and run unit tests**:\n   ```bash\n   gcc -std=c11 -g -DBTREE_INTERNAL -I./include src/node.c tests/test_node.c -o test_node\n   ./test_node\n   ```\n\n2. **Expected behavior**:\n   - All tests should pass (create, destroy, basic insert/remove in node).\n   - No memory leaks (verify with Valgrind: `valgrind --leak-check=full ./test_node`).\n   - The `node_find_key_index` function should correctly locate keys using binary search.\n\n3. **Manual verification**:\n   - Create a node with `t=3` (max 5 keys).\n   - Insert keys [10, 20, 30, 40] in order.\n   - Verify `num_keys` updates correctly.\n   - Search for key 20 should return index 1.\n   - Search for key 25 should return child index 2 (between 20 and 30).\n\n4. **Signs of trouble**:\n   - **Segmentation fault**: Likely uninitialized pointers in `children` array.\n   - **Incorrect search results**: Binary search bounds are wrong.\n   - **Memory leak**: Forgot to free arrays in `node_destroy`.\n\n\n## 6. Component Design: Search Operation\n\n> **Milestone(s):** Milestone 2 (Search)\n\nThe search operation is the fundamental read operation in a B-tree and serves as the foundation upon which more complex operations like insertion and deletion are built. Unlike simpler binary search trees where each node contains a single decision point, a B-tree node contains multiple keys, allowing it to make multiple comparisons at each level before deciding which child subtree to explore. This design dramatically reduces the tree's height and, consequently, the number of disk accesses required to locate a key—the core optimization that makes B-trees suitable for disk-based storage systems.\n\n### Mental Model: Finding a Topic in a Textbook\n\nImagine you're searching for information about \"binary search\" in a computer science textbook. The textbook has three levels of organization:\n\n1. **The index at the back** (the **root node**): This contains high-level topic names with page ranges for each chapter.\n2. **Chapter opening pages** (internal nodes): Each chapter has its own mini-index listing sections within that chapter.\n3. **Individual pages** (leaf nodes): The actual content with detailed explanations.\n\nYour search process mirrors the B-tree search algorithm:\n- You start at the index (root). Using alphabetical order, you quickly determine that \"binary search\" falls between \"binary trees\" (page 150-180) and \"B-trees\" (page 200-250). This tells you to look in Chapter 7 (pages 150-180).\n- You turn to Chapter 7's opening page (an internal node). It lists sections: \"7.1 Basic Trees,\" \"7.2 Binary Search Trees,\" \"7.3 AVL Trees.\" You find that \"binary search\" belongs in section 7.2.\n- You navigate to section 7.2 (a leaf node) and scan the pages until you find the exact discussion of binary search.\n\nAt each step, you're performing a **binary search within a sorted list** to narrow down your search space, then descending to the next appropriate level. The B-tree's structure ensures that even with millions of keys, you only need to examine a handful of \"index pages\" (nodes) to find your target.\n\n### Search Algorithm Steps\n\nThe search operation follows a recursive divide-and-conquer strategy that leverages both the sorted order within nodes and the hierarchical tree structure. The algorithm maintains the invariant that all keys in a subtree rooted at a child pointer `children[i]` are bounded by `keys[i-1]` and `keys[i]` (with special handling for the first and last child).\n\n**Search Algorithm (`search_recursive`):**\n\n1. **Initialize search at current node**: Begin with the current node (initially the root) and the target key.\n\n2. **Perform binary search within node**: Use binary search on the node's sorted `keys` array to find the smallest index `i` such that `key ≤ keys[i]`. The binary search returns either:\n   - The exact index where `key == keys[i]` (found case)\n   - The index where `key` would be inserted (not found, indicates which child to descend into)\n\n3. **Check for key match**:\n   - **If found** (`key == keys[i]`):\n     - If this node is a leaf: Return a successful `SearchResult` with the key's associated value (if values are stored).\n     - If this node is internal: The key acts as a separator between child subtrees but can also store a value (in some B-tree variants). For our implementation, we'll treat all keys as potentially having associated values, so return success with the value at `values[i]`.\n   - **If not found** (`key < keys[i]` or `i == num_keys`):\n     - If this node is a leaf: The key doesn't exist in the tree. Return a \"not found\" `SearchResult`.\n     - If this node is internal: Determine the appropriate child subtree to search:\n       - If `key < keys[0]`: Descend into `children[0]` (all keys in this subtree are less than `keys[0]`).\n       - Else: Descend into `children[i]` (all keys in this subtree are between `keys[i-1]` and `keys[i]`).\n\n4. **Recurse into child**: Call `search_recursive` on the selected child node with the same target key.\n\n5. **Return result**: Propagate the result (found/not found) back up the recursion chain.\n\nThe algorithm's time complexity is **O(logₜ n)** node accesses and **O(log t)** comparisons per node, where `t` is the minimum degree and `n` is the total number of keys. Each node access corresponds to a potential disk read in a real system.\n\n### ADR: Recursive vs. Iterative Search\n\n> **Decision: Use Recursive Implementation for Search**\n> - **Context**: We need to implement the search operation for an in-memory B-tree for educational purposes. The primary considerations are code clarity for learners versus potential performance optimizations. While real database systems might optimize for stack depth or cache locality, our implementation prioritizes readability and alignment with the recursive nature of tree algorithms.\n> - **Options Considered**:\n>   1. **Pure recursive implementation**: Clear mirroring of the algorithm description, easy to understand recursion flow, but uses call stack space proportional to tree height.\n>   2. **Iterative implementation with explicit stack**: Avoids recursion overhead, allows better control over memory, but adds complexity with stack management code.\n>   3. **Tail-recursive iterative implementation**: Uses a while loop to follow child pointers without a stack, but only works for simple search without additional bookkeeping for future operations.\n> - **Decision**: Use a pure recursive implementation for the core search operation.\n> - **Rationale**:\n>   - **Educational clarity**: The recursive implementation directly corresponds to the algorithm steps described in textbooks and documentation. Learners can trace the recursion to understand tree traversal.\n>   - **Consistency with other operations**: Insertion and deletion also use recursive approaches (particularly for proactive splitting during descent), so maintaining a consistent paradigm helps learners.\n>   - **Adequate performance**: For an in-memory educational implementation with typical tree heights (≤ 10 for millions of keys), recursion depth is not a practical concern. The O(logₜ n) height means even with `t=2` (worst-case fanout) and `n=1,000,000`, height ≤ 20.\n>   - **Simpler error handling**: No need to manage an explicit stack data structure, reducing code complexity.\n> - **Consequences**:\n>   - **Positive**: Clean, readable code that clearly expresses the algorithm. Easy to extend for debugging (e.g., adding recursion depth tracking).\n>   - **Negative**: Theoretical risk of stack overflow for extremely large trees with small `t`, though practically improbable for educational use cases. Slight performance overhead of function calls.\n\n**Comparison of Search Implementation Approaches:**\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **Recursive** | - Direct algorithm translation<br>- Easy to understand and debug<br>- Consistent with insert/delete operations | - Uses call stack memory<br>- Theoretical stack overflow risk<br>- Slight function call overhead | **Yes** |\n| **Iterative with explicit stack** | - No recursion depth limits<br>- Better control over memory usage<br>- Potentially better performance | - More complex code<br>- Requires stack management<br>- Less intuitive for learners | No |\n| **Tail-recursive iterative** | - Minimal memory usage<br>- Simple loop structure<br>- Good performance | - Only works for pure search<br>- Cannot be extended for insertion/deletion bookkeeping<br>- Requires different paradigm | No |\n\n### Common Pitfalls: Search Logic\n\nImplementing B-tree search seems straightforward but contains subtle traps that can lead to incorrect results, infinite recursion, or crashes.\n\n⚠️ **Pitfall: Off-by-one errors in binary search bounds**\n- **Description**: Using incorrect indices in the binary search loop, such as searching in range `[0, num_keys]` instead of `[0, num_keys-1]`, or incorrectly calculating the midpoint.\n- **Why it's wrong**: May fail to find existing keys, return incorrect child indices, or access out-of-bounds memory.\n- **Fix**: Implement a standard, verified binary search algorithm. Use inclusive lower bound and exclusive upper bound (`[low, high)`) consistently. Test edge cases: empty node, single key, full node.\n\n⚠️ **Pitfall: Forgetting to check leaf status before recursing**\n- **Description**: Attempting to access `children[i]` when `is_leaf` is true (leaf nodes have null child pointers).\n- **Why it's wrong**: Dereferencing a null pointer or uninitialized memory causes segmentation faults.\n- **Fix**: Always check `node->is_leaf` before accessing `node->children`. The check should occur after determining the key isn't in the current node but before attempting to descend.\n\n⚠️ **Pitfall: Incorrect child index selection when key not found**\n- **Description**: When `key` is not found in a node, choosing the wrong child index (e.g., using `i` when should use `i+1` or vice versa).\n- **Why it's wrong**: The search descends into the wrong subtree and may miss the key even if it exists in the tree.\n- **Fix**: Remember the invariant: all keys in subtree `children[i]` are less than `keys[i]` (for `i > 0`) and greater than `keys[i-1]`. If binary search returns index `i` where `key < keys[i]`, descend into `children[i]`. If `key > all keys`, descend into `children[num_keys]`.\n\n⚠️ **Pitfall: Not handling duplicate keys (if allowed)**\n- **Description**: The basic algorithm assumes unique keys. If duplicates are allowed, binary search may return any matching index.\n- **Why it's wrong**: May return different instances of the same key unpredictably, or fail to find all duplicates.\n- **Fix**: Define the semantics: return first/last occurrence, or return all values. Modify binary search to find leftmost/rightmost match. For simplicity, our implementation assumes unique keys.\n\n⚠️ **Pitfall: Ignoring the return value of recursive calls**\n- **Description**: Calling `search_recursive` on a child but not returning its result to the caller.\n- **Why it's wrong**: The search always returns \"not found\" from the current node, even if a deeper node found the key.\n- **Fix**: Always return the result of the recursive call: `return search_recursive(child, key);`.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Search Algorithm | Recursive implementation with binary search per node | Iterative with manual stack for predictable memory usage |\n| Key Comparison | Simple integer comparison (`key < node->keys[i]`) | Generic comparator function pointer for any key type |\n| Result Tracking | Basic `found` boolean with value pointer | Extended `SearchResult` with metadata (comparison count, node access count) |\n\n#### B. Recommended File/Module Structure\n\nThe search operation spans two files in the C implementation:\n\n```\nbtree/\n├── include/\n│   └── btree.h           ← Public API declarations (btree_search, SearchResult)\n├── src/\n│   ├── btree.c           ← Public API implementation (btree_search wrapper)\n│   ├── node.c            ← Node-level operations (node_find_key_index)\n│   └── search.c          ← Internal recursive search (search_recursive)\n└── tests/\n    └── test_search.c     ← Search-specific unit tests\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete `SearchResult` struct and public API wrapper (to be placed in `btree.h` and `btree.c`):**\n\n```c\n/* btree.h */\n#ifndef BTREE_H\n#define BTREE_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n/* Search result structure */\ntypedef struct {\n    bool found;          /* Whether the key was found */\n    void* value;         /* Associated value (NULL if not found or no value) */\n    int comparisons;     /* Number of key comparisons performed (for analysis) */\n} SearchResult;\n\n/* B-tree structure (forward declaration) */\ntypedef struct BTree BTree;\n\n/* Public search API */\nSearchResult btree_search(BTree* tree, int key);\n\n#endif /* BTREE_H ```\n```\n\n```c\n/* btree.c */\n#include \"btree.h\"\n#include \"node.h\"\n#include <stdlib.h>\n\n/* B-tree structure definition */\nstruct BTree {\n    struct BTreeNode* root;  /* Root node */\n    int t;                   /* Minimum degree */\n    size_t key_count;        /* Total keys in tree */\n};\n\n/* Public search function */\nSearchResult btree_search(BTree* tree, int key) {\n    SearchResult result = {false, NULL, 0};\n    \n    if (tree == NULL || tree->root == NULL) {\n        return result;\n    }\n    \n    /* Start recursive search from root */\n    return search_recursive(tree->root, key);\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**Binary search helper function (`node.c`):**\n\n```c\n#include \"node.h\"\n#include <assert.h>\n\n/*\n * Performs binary search within a node's sorted keys array.\n * Returns the index where the key is found, or the index where\n * it should be inserted (first position where keys[i] >= key).\n *\n * Also increments the comparison count for performance tracking.\n */\nint node_find_key_index(BTreeNode* node, int key, int* comparisons) {\n    /* TODO 1: Handle empty node case - return index 0 */\n    \n    /* TODO 2: Initialize binary search bounds: low = 0, high = node->num_keys */\n    \n    /* TODO 3: While low < high:\n        - Calculate mid = low + (high - low) / 2\n        - Increment comparison count if comparisons pointer is not NULL\n        - Compare key with node->keys[mid]\n        - If key == node->keys[mid], return mid (exact match)\n        - If key < node->keys[mid], set high = mid\n        - Else set low = mid + 1\n     */\n    \n    /* TODO 4: Return low (insertion position when key not found) */\n    \n    return 0; /* Placeholder */\n}\n```\n\n**Internal recursive search function (`search.c`):**\n\n```c\n#include \"btree.h\"\n#include \"node.h\"\n#include <stdlib.h>\n\n/*\n * Recursively searches for a key starting from the given node.\n * Returns SearchResult indicating whether key was found and its value.\n */\nSearchResult search_recursive(BTreeNode* node, int key) {\n    SearchResult result = {false, NULL, 0};\n    \n    if (node == NULL) {\n        return result;\n    }\n    \n    /* TODO 1: Perform binary search within current node using node_find_key_index */\n    /*   - Pass &result.comparisons to track comparison count */\n    /*   - Store the returned index in variable 'idx' */\n    \n    /* TODO 2: Check if key was found in current node (idx < node->num_keys && node->keys[idx] == key) */\n    /*   - If found:\n          - Set result.found = true\n          - Set result.value = node->values[idx] (if values exist, else NULL)\n          - Return result\n     */\n    \n    /* TODO 3: Handle not-found case */\n    /*   - If node is a leaf (node->is_leaf == true):\n          - Key doesn't exist in tree, return result (found = false)\n     */\n    \n    /* TODO 4: Determine correct child index for recursion */\n    /*   - If key < node->keys[0] or node->num_keys == 0: child_idx = 0\n       - Else: child_idx = idx (from binary search result)\n       - Ensure child_idx is within [0, node->num_keys] range\n     */\n    \n    /* TODO 5: Safety check - verify child pointer is not NULL */\n    /*   - Assert: node->children[child_idx] != NULL\n       - If NULL, return result (found = false) as error fallback\n     */\n    \n    /* TODO 6: Recursively search in the appropriate child subtree */\n    /*   - return search_recursive(node->children[child_idx], key);\n     */\n    \n    return result;\n}\n```\n\n#### E. Language-Specific Hints for C\n\n- **Binary Search Implementation**: Use `int mid = low + (high - low) / 2;` to avoid integer overflow that could occur with `(low + high) / 2`.\n- **Comparison Counting**: Increment `*comparisons` only when the pointer is not NULL to allow optional tracking.\n- **Child Pointer Validation**: In debug builds, use `assert(node->children[child_idx] != NULL);` to catch invariant violations early.\n- **Recursion Depth**: While recursion depth is limited, you can add a debug-only depth parameter to detect unexpectedly deep recursion.\n- **Memory Access**: Always validate array bounds before accessing `node->keys[idx]` or `node->children[idx]`.\n\n#### F. Milestone Checkpoint\n\nAfter implementing the search operation:\n\n1. **Compile and run the search tests**:\n   ```\n   gcc -o test_search src/btree.c src/node.c src/search.c tests/test_search.c -I./include\n   ./test_search\n   ```\n\n2. **Expected behavior**:\n   - Empty tree search returns `found = false`\n   - Search for existing key returns `found = true` with correct value\n   - Search for non-existent key returns `found = false`\n   - All tests pass without segmentation faults\n\n3. **Manual verification**:\n   - Create a small B-tree manually (insert a few keys)\n   - Search for each inserted key - should succeed\n   - Search for keys between inserted values - should fail\n   - Search for key less than all keys - should fail\n   - Search for key greater than all keys - should fail\n\n4. **Signs of problems**:\n   - **Segmentation fault**: Likely accessing NULL child pointer or out-of-bounds array index.\n   - **Incorrect found status**: Binary search or child index logic is wrong.\n   - **Infinite recursion**: Not checking leaf status or incorrect child selection.\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Search always returns \"not found\" even for inserted keys | Binary search returning wrong index or not checking exact match | Add debug prints in `node_find_key_index` to trace comparisons | Verify binary search bounds and equality check |\n| Segmentation fault when searching deep trees | Accessing `children[i]` when `is_leaf` is true | Add assert: `assert(!node->is_leaf || node->children[i] == NULL)` | Add leaf check before accessing children |\n| Search returns wrong value for found key | Values array not properly aligned with keys array | Verify `node->values[idx]` corresponds to `node->keys[idx]` | Ensure insertion maintains key-value alignment |\n| Recursion depth exceeds expected height | Child index calculation wrong, causing cycles | Print recursion depth and node addresses | Check child index logic for edge cases |\n\n---\n\n\n## 7. Component Design: Insertion with Splitting\n\n> **Milestone(s):** Milestone 3 (Insert with Split)\n\nThe insertion operation is where a B-tree demonstrates its self-balancing nature. Unlike binary search trees that grow vertically, B-trees grow horizontally (by filling nodes) and only increase height when absolutely necessary through a controlled root split. This design maintains the **disk-friendly property** of keeping tree height logarithmic while ensuring each node remains densely packed, minimizing disk accesses. The insertion algorithm's core challenge is maintaining all B-tree invariants—especially the key count bounds and sorted order—while adding new keys.\n\n### Mental Model: Adding a Book to a Full Shelf\n\nImagine organizing books in a library using a multi-level catalog system. Each catalog drawer (node) can hold a fixed number of index cards (keys). When a drawer becomes completely full, you can't simply add another card—you must split it:\n\n1. **Identify the target drawer**: Start at the main catalog (root) and follow the alphabetical dividers to find which drawer should contain the new book's card.\n2. **Prevent overflow during descent**: Before entering any drawer, if you see it's completely full, you split it proactively. You take out the middle card, create a new drawer, and place half the cards in each. You then add the middle card to the parent drawer as a new divider, telling you which drawer contains which range.\n3. **Insert the new card**: Once you reach the correct leaf drawer (which now has space because you split full drawers on the way down), you insert the new card in sorted order.\n4. **Handle a full main catalog**: If the very first catalog (root) is full when you start, you split it too. This creates a new top-level catalog with just one divider card pointing to two lower drawers, increasing the total number of catalog levels by one.\n\nThis proactive splitting during descent ensures you never attempt to insert into a full node, simplifying the algorithm. The middle key promotion resembles adding a new divider to a parent drawer, which may cause a cascade of splits upward if parents were also full.\n\n### Insertion and Split Algorithm Steps\n\nThe insertion algorithm follows a **recursive, top-down approach** that maintains the invariant that any node we descend into is not full. This is achieved by proactively splitting full nodes before recursing into them. The algorithm consists of two main functions: the public `btree_insert` wrapper and the internal recursive `insert_non_full`.\n\n#### Overall Insertion Flow\n\n![Insertion with Splitting Algorithm](./diagrams/insert-flowchart.svg)\n\n1. **Public Insertion Interface** (`btree_insert`):\n   - **Step 1**: Validate inputs (tree pointer, key).\n   - **Step 2**: If the root is full (`node_is_full(root, t)` returns true), create a new root node that will become the tree's new root. Split the old root by calling `node_split_child` on the new root at index 0. This increases tree height by one.\n   - **Step 3**: Call `insert_non_full` on the (now guaranteed non-full) root to perform the actual insertion.\n\n2. **Internal Recursive Insertion** (`insert_non_full`):\n   - **Step 4**: If the current node is a leaf (`node->is_leaf == true`), perform direct insertion:\n     - Use `node_find_key_index` to find the correct position `i` for the new key.\n     - Call `node_insert_key` to insert the key (and associated value) at position `i`, shifting existing keys right.\n     - Return success.\n   - **Step 5**: If the current node is internal, find the child subtree where the key belongs:\n     - Use `node_find_key_index` to get index `i` (position where key would be or child index).\n     - **Step 6**: Check if the target child at `children[i]` is full using `node_is_full`.\n     - **Step 7**: If full, split this child:\n       - Call `node_split_child(current_node, i, t)` to split child `children[i]`.\n       - After splitting, compare the promoted key (now at `keys[i]`) with the new key to decide which of the two new children to descend into (update `i` if needed).\n     - **Step 8**: Recursively call `insert_non_full` on the appropriate child (now guaranteed non-full).\n\n#### Node Splitting Subroutine (`node_split_child`)\n\nSplitting a full child is a critical sub-operation that transforms one full node into two half-full nodes and promotes the median key to the parent.\n\n![Node Split and Median Promotion](./diagrams/split-visual.svg)\n\nGiven a parent node `P` and child index `i` where `child = P->children[i]` is full (has `2t-1` keys):\n\n1. **Create a new sibling node** `new_child` with the same leaf status as the original child.\n2. **Distribute keys**: The original child keeps the first `t-1` keys (indices `0` to `t-2`). The new sibling gets the last `t-1` keys (indices `t` to `2t-2`). The median key at index `t-1` will be promoted.\n3. **Distribute children** (if internal node): Similarly, the first `t` children pointers stay with the original child; the remaining `t` children pointers go to the new sibling.\n4. **Adjust key counts**: Set original child's `num_keys = t-1` and new sibling's `num_keys = t-1`.\n5. **Promote the median key**:\n   - Make space in parent `P` at index `i` by shifting parent keys and child pointers right.\n   - Insert the median key into `P->keys[i]`.\n   - Insert `new_child` as a new child pointer at `P->children[i+1]`.\n   - Increment parent's `num_keys` by one.\n\nThis operation ensures both resulting nodes satisfy the minimum occupancy requirement (at least `t-1` keys) and the parent gains one key while maintaining the invariant that internal nodes have one more child than keys.\n\n### ADR: Proactive vs. Reactive Splitting\n\n> **Decision: Proactive Splitting During Descent**\n> - **Context**: The B-tree insertion algorithm must handle full nodes to maintain the key count bounds (maximum `2t-1` keys per node). Two approaches exist: proactively split full nodes during the downward traversal before insertion, or allow temporary overflow and fix it on the way back up (reactive).\n> - **Options Considered**:\n>   1. **Proactive splitting (top-down)**: Split any full node encountered during descent before recursing into it.\n>   2. **Reactive splitting (bottom-up)**: Allow insertion into full leaves, then split and propagate upward if needed.\n>   3. **Hybrid approach**: Allow leaves to become temporarily overfull, but split internal nodes proactively.\n> - **Decision**: Implement proactive splitting during the downward traversal for all nodes (both internal and leaf).\n> - **Rationale**:\n>   - **Simplicity for learners**: Proactive splitting ensures the recursive insertion function (`insert_non_full`) only ever operates on non-full nodes, reducing the number of cases to handle. The base case (leaf insertion) becomes trivial—just insert into a non-full array.\n>   - **Single-pass algorithm**: The algorithm makes only one pass from root to leaf, which is easier to reason about and debug compared to splitting on the way back up with potentially complex upward propagation logic.\n>   - **Consistency with textbook implementations**: Most academic references (e.g., CLRS) use the proactive approach, making it easier for learners to cross-reference.\n>   - **Predictable memory access**: By splitting during descent, we can allocate new nodes immediately rather than potentially allocating multiple nodes during upward propagation, which might be harder to manage in error conditions.\n> - **Consequences**:\n>   - **Slightly less efficient**: Some splits may occur that wouldn't be strictly necessary if the key ends up in a different subtree (though this is rare).\n>   - **Root split requires special handling**: Since the root has no parent, we must check and split it before starting descent, which is a special case in the public `btree_insert` function.\n>   - **Cleaner recursion**: The recursive helper `insert_non_full` has a simpler precondition (node is not full), making its implementation more straightforward.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **Proactive splitting** | Single pass; simpler recursion; consistent with textbooks | May split nodes unnecessarily in rare cases | **Yes** |\n| **Reactive splitting** | Only splits when absolutely needed; can be more efficient | Two-pass algorithm; more complex recursion with upward propagation | No |\n| **Hybrid approach** | Balances efficiency and simplicity | Inconsistent logic between leaves and internal nodes; harder to teach | No |\n\n### Common Pitfalls: Splitting and Promotion\n\nImplementing insertion with splitting involves several subtle details that can easily lead to bugs. Below are the most common pitfalls, why they're problematic, and how to avoid them.\n\n#### ⚠️ **Pitfall 1: Splitting Non-Full Nodes**\n- **Description**: Calling the split operation on a node that has fewer than `2t-1` keys, often due to incorrect `node_is_full` check or off-by-one in the minimum degree `t`.\n- **Why it's wrong**: Splitting a non-full node violates B-tree invariants by creating nodes that may have fewer than `t-1` keys (underfull). This can cascade and break the tree structure during subsequent operations.\n- **How to avoid**: Always verify `node_is_full(child, t)` returns `true` before splitting. Double-check that `node_is_full` correctly implements `num_keys == 2*t - 1`.\n\n#### ⚠️ **Pitfall 2: Incorrect Median Index Calculation**\n- **Description**: Using the wrong index for the median key during splitting, such as using `t` instead of `t-1` (0-indexed) or miscalculating due to confusion between key counts and child counts.\n- **Why it's wrong**: Promoting the wrong key breaks the sorted order invariant. If the median is off by one, the resulting nodes may have incorrect key ranges, causing search failures.\n- **How to avoid**: Remember that for a node with `2t-1` keys (indices `0` to `2t-2`), the median key is at index `t-1`. Use concrete examples: for `t=3`, `2t-1=5` keys, indices 0-4, median at index 2.\n\n#### ⚠️ **Pitfall 3: Forgetting to Update Child Pointers After Split**\n- **Description**: After creating a new sibling node, failing to update the parent's child pointer array to include the new sibling at the correct position, or incorrectly shifting existing child pointers.\n- **Why it's wrong**: The parent will have an incomplete or incorrect list of children, potentially losing references to entire subtrees. This causes memory leaks and broken tree connectivity.\n- **How to avoid**: When inserting the new sibling into the parent's child array at index `i+1`, ensure all child pointers from index `i+1` onward are shifted right by one position first. Diagram the pointer arrays before and after.\n\n#### ⚠️ **Pitfall 4: Mishandling Root Split**\n- **Description**: Forgetting to handle the special case where the root is full, or incorrectly implementing the root split (e.g., not updating the tree's root pointer, not setting the new root's `is_leaf` to `false`).\n- **Why it's wrong**: If the root remains full, insertion cannot proceed without violating capacity bounds. If the new root isn't properly initialized, the tree becomes malformed.\n- **How to avoid**: In `btree_insert`, check if the root is full before any descent. If so: (1) create a new root node with `is_leaf = false`, (2) make the old root its first child, (3) split the old root via `node_split_child(new_root, 0, t)`, (4) update the tree's root pointer.\n\n#### ⚠️ **Pitfall 5: Ignoring the Leaf Flag During Split**\n- **Description**: When creating the new sibling node during a split, copying the original node's `is_leaf` flag incorrectly (e.g., always setting to `true` or `false`).\n- **Why it's wrong**: If an internal node is split but the new sibling is marked as a leaf, its child pointers will be invalid (null for leaves). Conversely, splitting a leaf but marking the new sibling as internal will cause null pointer dereferences when trying to access children.\n- **How to avoid**: The new sibling must have the same `is_leaf` status as the node being split. Pass `child->is_leaf` to `node_create` when creating the sibling.\n\n#### ⚠️ **Pitfall 6: Not Adjusting Search Index After Split**\n- **Description**: After splitting a child during descent, failing to re-evaluate which child to descend into based on the promoted key. The original index `i` might no longer be correct.\n- **Why it's wrong**: The algorithm might descend into the wrong subtree, leading to insertion in an incorrect leaf or failed searches later.\n- **How to avoid**: After `node_split_child(parent, i, t)`, compare the new key with the promoted key now at `parent->keys[i]`. If the new key is less, descend into `parent->children[i]`; if greater, descend into `parent->children[i+1]`.\n\n### Implementation Guidance\n\nThis section provides concrete implementation skeletons and guidance for the C programming language, following the naming conventions and structure outlined earlier.\n\n#### Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Memory Management | Manual `malloc`/`free` with careful ownership tracking | Reference-counted nodes or arena allocator for batch deallocation |\n| Error Handling | Return boolean success/failure, print errors to stderr | Error codes enum with descriptive messages, optional error callback |\n| Debugging Aids | `printf` statements at key decision points | Comprehensive logging macro with levels (DEBUG, INFO, ERROR) |\n| Validation | Manual invariant checks in test code | Built-in `btree_validate` that traverses entire tree verifying all invariants |\n\n#### Recommended File/Module Structure\n\nThe insertion functionality extends the existing B-tree module structure:\n\n```\nbtree/\n├── include/\n│   └── btree.h              ← Public interface declarations\n├── src/\n│   ├── btree.c              ← Public API implementations (btree_insert)\n│   ├── node.c               ← Node operations (node_split_child, node_insert_key)\n│   └── btree_private.h      ← Internal function declarations (insert_non_full)\n└── tests/\n    ├── test_insert.c        ← Insertion-specific tests\n    └── test_operations.c    ← Integrated tests for all operations\n```\n\n#### Infrastructure Starter Code\n\nThe following helper functions for node manipulation should be implemented completely as they are prerequisites for the insertion logic but not the core learning goal:\n\n```c\n// In node.c - Complete implementation\n#include <stdlib.h>\n#include <string.h>\n#include \"btree_private.h\"\n\n/**\n * Inserts a key-value pair into a node at the specified index.\n * Shifts existing keys and values (if any) to the right.\n * For internal nodes, children pointers are NOT shifted by this function.\n */\nvoid node_insert_key(BTreeNode* node, int index, int key, void* value) {\n    // Shift keys right from index to num_keys-1\n    for (int i = node->num_keys - 1; i >= index; i--) {\n        node->keys[i + 1] = node->keys[i];\n    }\n    \n    // Shift values right if values array exists\n    if (node->values != NULL) {\n        for (int i = node->num_keys - 1; i >= index; i--) {\n            node->values[i + 1] = node->values[i];\n        }\n        node->values[index] = value;\n    }\n    \n    // Insert new key\n    node->keys[index] = key;\n    node->num_keys++;\n}\n\n/**\n * Creates a new empty node with the given minimum degree and leaf status.\n * Allocates arrays for keys, values (optional), and children (if internal).\n */\nBTreeNode* node_create(int t, bool is_leaf) {\n    BTreeNode* node = malloc(sizeof(BTreeNode));\n    if (!node) return NULL;\n    \n    node->keys = malloc(sizeof(int) * (2 * t - 1));\n    node->values = NULL;  // Optional: allocate if storing values\n    node->children = is_leaf ? NULL : malloc(sizeof(BTreeNode*) * (2 * t));\n    node->num_keys = 0;\n    node->is_leaf = is_leaf;\n    \n    if (!node->keys || (!is_leaf && !node->children)) {\n        free(node->keys);\n        free(node->children);\n        free(node);\n        return NULL;\n    }\n    \n    // Initialize children to NULL if internal node\n    if (!is_leaf) {\n        for (int i = 0; i < 2 * t; i++) {\n            node->children[i] = NULL;\n        }\n    }\n    \n    return node;\n}\n\n/**\n * Checks if a node is full (contains 2t-1 keys).\n */\nbool node_is_full(BTreeNode* node, int t) {\n    return node->num_keys == (2 * t - 1);\n}\n\n/**\n * Binary search within a node's keys to find the position of a key.\n * Returns the index where the key is found or should be inserted.\n * Increments comparisons counter if provided.\n */\nint node_find_key_index(BTreeNode* node, int key, int* comparisons) {\n    int left = 0;\n    int right = node->num_keys - 1;\n    int mid;\n    \n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        if (comparisons) (*comparisons)++;\n        \n        if (node->keys[mid] == key) {\n            return mid;  // Key found\n        } else if (node->keys[mid] < key) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    // Key not found, return where it should be inserted\n    return left;\n}\n```\n\n#### Core Logic Skeleton Code\n\nThe following skeletons show the insertion functions with TODO comments mapping to the algorithm steps described earlier. Learners should implement the missing logic.\n\n```c\n// In btree_private.h (internal declarations)\n#ifndef BTREE_PRIVATE_H\n#define BTREE_PRIVATE_H\n\n#include \"btree.h\"\n\n// Internal recursive insertion helper\nbool insert_non_full(BTreeNode* node, int key, void* value, int t);\n\n// Split child of parent at index i\nvoid node_split_child(BTreeNode* parent, int i, int t);\n\n#endif\n```\n\n```c\n// In node.c - Split implementation skeleton\n/**\n * Splits the i-th child of parent, which must be full.\n * Creates a new node, moves half of the child's keys and children\n * to the new node, and promotes the median key to the parent.\n */\nvoid node_split_child(BTreeNode* parent, int i, int t) {\n    // TODO 1: Get pointer to the full child to be split\n    // BTreeNode* full_child = parent->children[i];\n    \n    // TODO 2: Create new sibling node with same leaf status as full_child\n    // BTreeNode* new_sibling = node_create(t, full_child->is_leaf);\n    \n    // TODO 3: Copy the last (t-1) keys from full_child to new_sibling\n    // for (int j = 0; j < t-1; j++) {\n    //     new_sibling->keys[j] = full_child->keys[j + t];\n    // }\n    // new_sibling->num_keys = t-1;\n    \n    // TODO 4: If full_child is internal (not leaf), copy the last t children pointers\n    // if (!full_child->is_leaf) {\n    //     for (int j = 0; j < t; j++) {\n    //         new_sibling->children[j] = full_child->children[j + t];\n    //     }\n    // }\n    \n    // TODO 5: Reduce key count of full_child to t-1\n    // full_child->num_keys = t-1;\n    \n    // TODO 6: Make space in parent for new key and child pointer\n    // Shift parent keys from index i to num_keys-1 right by one\n    // Shift parent children from index i+1 to num_keys right by one\n    \n    // TODO 7: Insert median key (full_child->keys[t-1]) into parent at index i\n    // parent->keys[i] = full_child->keys[t-1];\n    \n    // TODO 8: Insert new_sibling as parent's child at index i+1\n    // parent->children[i+1] = new_sibling;\n    \n    // TODO 9: Increment parent's key count\n    // parent->num_keys++;\n}\n```\n\n```c\n// In btree.c - Public insertion and recursive helper\n#include \"btree_private.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\n/**\n * Public API: Insert a key-value pair into the B-tree.\n * Returns true on success, false on failure (e.g., memory allocation error).\n */\nbool btree_insert(BTree* tree, int key, void* value) {\n    if (!tree || !tree->root) return false;\n    \n    BTreeNode* root = tree->root;\n    \n    // TODO 1: Special case - if root is full, split it\n    // if (node_is_full(root, tree->t)) {\n    //     // Create new root\n    //     BTreeNode* new_root = node_create(tree->t, false);\n    //     if (!new_root) return false;\n    //     \n    //     // Make old root the first child of new root\n    //     new_root->children[0] = root;\n    //     \n    //     // Split the old root\n    //     node_split_child(new_root, 0, tree->t);\n    //     \n    //     // Update tree root\n    //     tree->root = new_root;\n    //     \n    //     // Update root pointer for insertion\n    //     root = new_root;\n    // }\n    \n    // TODO 2: Now root is not full, call recursive helper\n    // bool success = insert_non_full(root, key, value, tree->t);\n    \n    // TODO 3: Update tree->key_count if insertion successful\n    // if (success) tree->key_count++;\n    \n    // return success;\n    return false; // placeholder\n}\n\n/**\n * Internal recursive function to insert into a subtree rooted at a non-full node.\n * Precondition: node is not full (node_is_full(node, t) == false).\n */\nbool insert_non_full(BTreeNode* node, int key, void* value, int t) {\n    // TODO 1: Find the index where key belongs or exists\n    // int i = node_find_key_index(node, key, NULL);\n    \n    // TODO 2: Handle case where key already exists (optional: update value)\n    // if (i < node->num_keys && node->keys[i] == key) {\n    //     if (node->values) node->values[i] = value;\n    //     return true; // Key updated\n    // }\n    \n    // TODO 3: If node is a leaf, insert key at position i\n    // if (node->is_leaf) {\n    //     node_insert_key(node, i, key, value);\n    //     return true;\n    // }\n    \n    // TODO 4: Node is internal - prepare to descend\n    // BTreeNode* child = node->children[i];\n    \n    // TODO 5: If child is full, split it first\n    // if (node_is_full(child, t)) {\n    //     node_split_child(node, i, t);\n    //     \n    //     // After split, check which child to descend into\n    //     // Compare key with node->keys[i] (the promoted key)\n    //     // if (key > node->keys[i]) i++;\n    //     // Update child pointer\n    //     // child = node->children[i];\n    // }\n    \n    // TODO 6: Recursively insert into the appropriate child\n    // return insert_non_full(child, key, value, t);\n    \n    return false; // placeholder\n}\n```\n\n#### Language-Specific Hints for C\n\n1. **Memory Management**: Always check `malloc` return values. When splitting nodes, ensure all allocated memory is properly freed in the destruction path (`node_destroy` should recursively free children).\n2. **Array Indexing**: C uses 0-based indexing. The median key in a node with `2t-1` keys is at index `t-1` (0-indexed). Be careful with loop boundaries when shifting arrays.\n3. **Pointer Arithmetic**: When shifting elements in arrays, iterate from the end backward to avoid overwriting elements: `for (int i = count-1; i >= index; i--)`.\n4. **Boolean Values**: Include `<stdbool.h>` for `bool`, `true`, `false`. The `node->is_leaf` flag should be set correctly when creating nodes.\n5. **Debugging**: Use `assert` from `<assert.h>` to validate invariants during development (e.g., `assert(node->num_keys <= 2*t-1)`).\n\n#### Milestone Checkpoint\n\nAfter implementing insertion with splitting:\n\n1. **Compilation**: Run `gcc -Wall -Wextra -g src/*.c tests/test_insert.c -o test_insert` to ensure no warnings.\n2. **Basic Test**: Create a simple test that inserts keys in increasing order and verifies tree structure:\n   ```c\n   BTree* tree = btree_create(3);\n   for (int i = 1; i <= 20; i++) {\n       btree_insert(tree, i, NULL);\n   }\n   btree_print(tree);  // Should show balanced tree with 3-4 levels\n   btree_destroy(tree);\n   ```\n3. **Validation**: Run the tree validator after each insertion in debug mode:\n   ```c\n   assert(btree_validate(tree) == true);\n   ```\n4. **Expected Behavior**:\n   - Inserting 1-10 with `t=3` should produce a root with 1 key after the 7th insertion (first root split).\n   - All nodes (except root) should have between `t-1` and `2t-1` keys.\n   - In-order traversal (via search) should find all inserted keys.\n5. **Signs of Trouble**:\n   - **Segmentation fault**: Likely uninitialized child pointers or incorrect array bounds.\n   - **Missing keys**: Search fails for recently inserted keys - check split logic and key promotion.\n   - **Too many nodes**: Each split should create exactly one new node. Count nodes to verify.\n   - **Validation fails**: Implement `btree_validate` to check invariants and pinpoint issues.\n\n\n## 8. Component Design: Deletion with Rebalancing\n\n> **Milestone(s):** Milestone 4 (Delete with Rebalancing)\n\nDeletion in a B-tree is the most complex operation, requiring careful maintenance of the **capacity bounds** invariants. Unlike binary search trees where deletion simply removes a node, B-trees must ensure every node (except the root) maintains at least `t-1` keys. When deletion would violate this minimum, the tree performs **borrowing** from a sibling or **merging** nodes to restore balance. This component handles the intricate logic of key removal, underflow detection, and structural rebalancing while preserving all B-tree invariants.\n\n### Mental Model: Removing a Book and Consolidating Shelves\n\nImagine a library with bookshelves organized by the B-tree system from our previous analogies. Each shelf (node) must contain between `t-1` and `2t-1` books (keys). When you remove a book from a shelf:\n\n1. **Simple removal**: If the shelf still has enough books after removal (`≥ t-1`), you simply take the book out and shift the remaining books to fill the gap. The library index (parent node's keys) remains unchanged.\n\n2. **Borrowing from a neighbor**: If removing the book would leave the shelf with too few books (`< t-1`), you first check if a neighboring shelf has extra books to spare. If the left neighbor has more than the minimum, you:\n   - Take the rightmost book from the left neighbor\n   - Move the dividing index card from the parent (which sits between these two shelves) down to your shelf\n   - Move the neighbor's book up to replace that parent index card\n   \n   This rotates a key through the parent, maintaining alphabetical order while fixing the underflow.\n\n3. **Merging shelves**: If neither neighbor has extra books, you must merge shelves. You combine your shelf with one neighbor, plus the parent's dividing index card, creating one shelf with exactly `2t-2` books (which is valid since `2t-2 ≤ 2t-1`). This reduces the number of shelves by one and may cause the parent shelf to now have too few index cards, potentially triggering borrowing or merging cascading upward.\n\n4. **Empty root shelf**: If merging reaches the root and leaves it with no books (keys), the merged shelf becomes the new root, reducing the tree's height by one—like removing a now-unnecessary floor from the library's catalog system.\n\nThis process ensures the library remains efficiently navigable: shelves never become too empty (wasting space) or too full (requiring frequent splitting), and the catalog hierarchy adjusts gracefully as books are removed.\n\n### Deletion and Rebalance Algorithm Steps\n\nThe deletion algorithm is implemented in `delete_from_subtree`, a recursive function that descends the tree, handles various deletion cases, and repairs underflows on the way back up. The public interface `btree_delete` simply calls this helper on the root.\n\n#### Main Deletion Procedure\n\n1. **Locate the key in the current node**: Use `node_find_key_index` to perform binary search within the current node's keys. This returns either the exact index where the key exists or the index of the child subtree where the key would be located.\n\n2. **Case 1: Key found in current node (internal node)**:\n   - **Subcase 1A: Current node is a leaf**: If `node->is_leaf` is true, simply call `node_remove_key` at the found index. This removes the key and shifts subsequent keys left.\n   - **Subcase 1B: Current node is internal**: The key serves as a separator between two subtrees. We cannot simply remove it without disrupting the tree structure. Instead:\n     1. **Check left child's capacity**: If the left child (at child index `key_index`) has at least `t` keys, find the **in-order predecessor** (the largest key in the left subtree) by traversing rightmost in that subtree.\n     2. **Replace and recurse**: Replace the target key with this predecessor key, then recursively delete that predecessor key from the left child.\n     3. **Alternative: right child**: If the left child has only `t-1` keys but the right child (at child index `key_index + 1`) has at least `t` keys, use the **in-order successor** (smallest key in right subtree) instead, found by traversing leftmost in the right subtree.\n     4. **Fallback: merge children**: If both adjacent children have the minimum `t-1` keys, merge them along with the separator key into one node, then recursively delete the key from this merged node.\n\n3. **Case 2: Key not found in current node**:\n   - **Ensure child can lose a key**: Before descending to child at index `child_idx`, check if that child has only `t-1` keys (minimum). If so, we must **strengthen** it by either:\n     - **Borrowing from left sibling**: If the immediate left sibling exists and has at least `t` keys, perform a right rotation: move a key from parent down to child, move a key from left sibling up to parent, and adjust child pointers.\n     - **Borrowing from right sibling**: If no left sibling or it's at minimum, but right sibling exists with at least `t` keys, perform a left rotation (symmetric to above).\n     - **Merging with sibling**: If neither sibling has extra keys, merge the child with a sibling (preferably left if exists) and the separating key from the parent.\n   - **Recurse**: After ensuring the child has at least `t` keys (or merging made it larger), recursively call `delete_from_subtree` on the appropriate child.\n\n4. **Underflow repair on return**: After the recursive deletion returns, check if the current node has become underfull (less than `t-1` keys, except if it's the root). If underfull and not root, this indicates a problem—but our proactive strengthening in step 3 should prevent this. However, some algorithms check and repair here as well for robustness.\n\n5. **Root underflow special case**: If after deletion the root has 0 keys but still has a child (meaning the tree height decreased), make that child the new root and free the old root.\n\nThe algorithm's complexity is O(logₜ n) with at most O(logₜ n) node accesses, as each recursive call processes one level and operations within a node take O(t) time.\n\n#### State Transitions During Deletion\n\nThe diagram ![Node State During Deletion](./diagrams/delete-state-machine.svg) shows how a node's state changes during deletion operations. The key insight is that we proactively avoid underflow before descending, making the recursive deletion simpler.\n\n| Current State | Event | Next State | Actions Taken |\n|---------------|-------|------------|---------------|\n| Valid (≥ t keys) | Direct key removal (leaf) | Valid or Underfull | Remove key, check if still ≥ t-1 |\n| Valid | Key removed from child (recursive return) | Valid | No action needed |\n| Minimum (t-1 keys) | Need to descend through this child | Strengthened to Valid | Borrow from sibling or merge before descending |\n| Underfull (< t-1 keys) | Detected after child deletion (should not occur with proactive approach) | Valid | Borrow or merge with sibling via parent |\n| Root with 1 key, 2 children | Merging of children | Root with 0 keys | Adopt merged child as new root, height decreases |\n\n### ADR: Predecessor vs. Successor for Internal Delete\n\n> **Decision: Prefer Predecessor from Left Child for Internal Node Deletion**\n> - **Context**: When deleting a key `k` from an internal node, we cannot simply remove it without leaving a \"hole\" in the tree structure that separates two subtrees. We must replace `k` with another key that maintains the ordering invariants, then delete that replacement key from its original location. The replacement must come from either the left subtree (predecessor) or right subtree (successor) of `k`.\n> - **Options Considered**:\n>   1. **Always use in-order predecessor**: Find the largest key in the left subtree by following rightmost pointers until reaching a leaf.\n>   2. **Always use in-order successor**: Find the smallest key in the right subtree by following leftmost pointers until reaching a leaf.\n>   3. **Choose based on child capacities**: Check which adjacent child (left or right) has more than the minimum keys, and use that subtree's predecessor/successor accordingly.\n>   4. **Random selection**: Arbitrarily choose predecessor or successor.\n> - **Decision**: Option 3—choose based on child capacities. If left child has ≥ t keys, use predecessor; else if right child has ≥ t keys, use successor; otherwise (both have minimum), proceed to merge.\n> - **Rationale**:\n>   - **Minimizes restructuring**: Using a child with extra keys avoids immediate merging/borrowing operations. The replacement key can be removed from that child without causing underflow (since it had ≥ t keys initially).\n>   - **Preserves balance**: This approach tends to keep subtree sizes more balanced than always choosing one side.\n>   - **Standard textbook approach**: Most B-tree implementations (Cormen et al.) use this capacity-based selection, making our implementation more conventional and easier to verify.\n>   - **Simplifies implementation**: The logic integrates naturally with the \"strengthening\" step—we already check child capacities before descending.\n> - **Consequences**:\n>   - Slightly more complex logic than always using predecessor.\n>   - Requires checking both child nodes' key counts before deciding.\n>   - May lead to more uniform tree degradation over many deletions compared to always favoring one side.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Always predecessor | Simpler implementation, consistent behavior | May cause unnecessary merges if left child is at minimum, could lead to left-heavy tree | No |\n| Always successor | Simpler implementation | May cause unnecessary merges if right child is at minimum, could lead to right-heavy tree | No |\n| **Capacity-based selection** | **Minimizes restructuring, balances tree, standard approach** | **Slightly more logic, two checks needed** | **Yes** |\n| Random selection | Potentially balanced over many operations | Unpredictable, harder to debug, non-deterministic | No |\n\n### Common Pitfalls: Borrow vs. Merge Logic\n\n⚠️ **Pitfall: Incorrect borrow/merge decision condition**\n- **Description**: Checking whether a sibling has `> t-1` keys instead of `≥ t` keys when deciding to borrow. Since the minimum is `t-1`, a sibling with exactly `t-1` keys cannot spare one without becoming underfull.\n- **Why it's wrong**: Borrowing from a sibling with only `t-1` keys would leave it with `t-2` keys, violating the minimum occupancy invariant. This corruption may not be detected immediately but will cause future operations to fail.\n- **Fix**: Always check `sibling->num_keys ≥ t` before borrowing. For merging, check that both the child and chosen sibling have exactly `t-1` keys.\n\n![Borrow vs. Merge Operations](./diagrams/borrow-merge-visual.svg)\n\n⚠️ **Pitfall: Not handling left/right sibling symmetry**\n- **Description**: Implementing borrowing from only the left sibling (or only the right), or treating left and right cases with copy-pasted but not properly mirrored logic.\n- **Why it's wrong**: When the left sibling doesn't exist or can't lend a key, the right sibling might be able to. Missing this case causes unnecessary merges, increasing tree height prematurely. Incorrect mirroring (e.g., wrong index adjustments) corrupts key ordering.\n- **Fix**: Implement both left and right borrowing symmetrically. Use helper functions for rotation operations that take direction as a parameter, or carefully test both directions with symmetric test cases.\n\n⚠️ **Pitfall: Forgetting to update parent after borrowing/merging**\n- **Description**: When borrowing, moving a key between sibling and child but forgetting to update the parent's separating key. When merging, removing the parent's separating key but not shifting the parent's remaining keys and child pointers.\n- **Why it's wrong**: The parent's keys no longer correctly separate the subtrees. Searches may fail to find existing keys or descend the wrong path. The tree's ordering invariants are broken.\n- **Fix**: In borrowing, remember that the parent key at index `i` moves down to the child, and the sibling key moves up to replace it. In merging, after removing the parent key at index `i`, shift all keys and child pointers from `i+1` left by one position.\n\n⚠️ **Pitfall: Not recursing after borrowing/merging**\n- **Description**: After strengthening a child via borrow or merge, the algorithm proceeds to delete from the original child instead of the potentially changed child (in merge case, the child and sibling become one node).\n- **Why it's wrong**: In a merge operation, the child node pointer may become invalid (the child is merged into the sibling). The deletion must continue on the merged node, not the original child.\n- **Fix**: After merging child at index `i` with sibling, the merged node resides at the sibling's index. Update your recursion to target this merged node. Keep careful track of which node pointer to use for the recursive call.\n\n⚠️ **Pitfall: Ignoring root shrinkage**\n- **Description**: After deletion, if the root has 0 keys but still has a child, failing to make that child the new root and free the old root.\n- **Why it's wrong**: The tree maintains an unnecessary empty root level, wasting memory and adding an extra traversal step for all operations. The height invariant becomes incorrect (height should decrease by 1).\n- **Fix**: After the top-level `delete_from_subtree` call returns, check if the root has 0 keys and is not a leaf (has one child). If so, set `tree->root = root->children[0]` and free the old root.\n\n### Implementation Guidance\n\n**Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Deletion Algorithm | Recursive implementation with explicit case handling | Iterative implementation with manual stack for potential optimization |\n| Underflow Prevention | Proactive strengthening before descent (as described) | Reactive repair after underflow detected on return |\n| Merge/Borrow Helpers | Separate functions for left/right cases | Unified rotation function with direction parameter |\n\n**Recommended File/Module Structure:**\n```\nbtree/\n├── include/\n│   └── btree.h           ← Public interface declarations\n├── src/\n│   ├── btree.c           ← Public API implementations (btree_delete)\n│   ├── node.c            ← Node operations (node_remove_key, etc.)\n│   ├── delete.c          ← Internal deletion algorithms (delete_from_subtree, helpers)\n│   └── validate.c        ← Invariant checking for debugging\n└── tests/\n    ├── test_delete.c     ← Comprehensive deletion tests\n    └── test_invariants.c ← Post-deletion invariant validation\n```\n\n**Core Logic Skeleton Code:**\n\n```c\n/* FILE: src/delete.c */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"btree.h\"\n\n/* Helper: Get the predecessor key from the left subtree */\nstatic int get_predecessor(BTreeNode* node, int index) {\n    // TODO 1: Start from the left child at children[index]\n    // TODO 2: Traverse rightmost pointers until reaching a leaf\n    // TODO 3: Return the last (rightmost) key in that leaf\n}\n\n/* Helper: Get the successor key from the right subtree */\nstatic int get_successor(BTreeNode* node, int index) {\n    // TODO 1: Start from the right child at children[index + 1]\n    // TODO 2: Traverse leftmost pointers until reaching a leaf\n    // TODO 3: Return the first (leftmost) key in that leaf\n}\n\n/* Helper: Borrow a key from left sibling */\nstatic void borrow_from_left(BTreeNode* parent, int child_idx, int t) {\n    BTreeNode* child = parent->children[child_idx];\n    BTreeNode* left_sibling = parent->children[child_idx - 1];\n    \n    // TODO 1: Shift all keys in child right by one position\n    // TODO 2: Shift all child pointers in child right by one (if not leaf)\n    // TODO 3: Move parent key at index child_idx-1 down to child's first key position\n    // TODO 4: Move left sibling's last key up to parent at index child_idx-1\n    // TODO 5: If not leaves, move left sibling's last child to be child's first child\n    // TODO 6: Update key counts: left_sibling->num_keys--, child->num_keys++\n}\n\n/* Helper: Borrow a key from right sibling */\nstatic void borrow_from_right(BTreeNode* parent, int child_idx, int t) {\n    BTreeNode* child = parent->children[child_idx];\n    BTreeNode* right_sibling = parent->children[child_idx + 1];\n    \n    // TODO 1: Move parent key at index child_idx down to child's last key position\n    // TODO 2: Move right sibling's first key up to parent at index child_idx\n    // TODO 3: Shift all keys in right sibling left by one position\n    // TODO 4: If not leaves, shift all child pointers in right sibling left by one\n    // TODO 5: If not leaves, move right sibling's first child to be child's last child\n    // TODO 6: Update key counts: right_sibling->num_keys--, child->num_keys++\n}\n\n/* Helper: Merge child at index child_idx with left sibling */\nstatic void merge_with_left_sibling(BTreeNode* parent, int child_idx, int t) {\n    BTreeNode* left_sibling = parent->children[child_idx - 1];\n    BTreeNode* child = parent->children[child_idx];\n    \n    // TODO 1: Move parent key at index child_idx-1 down to left_sibling's keys at position t-1\n    // TODO 2: Copy all keys from child to left_sibling (starting at position t)\n    // TODO 3: If not leaves, copy all child pointers from child to left_sibling\n    // TODO 4: Update left_sibling->num_keys to 2*t-1\n    // TODO 5: Remove parent key at index child_idx-1 by shifting parent keys left\n    // TODO 6: Shift parent child pointers left starting from child_idx\n    // TODO 7: Free child node\n    // TODO 8: parent->num_keys--\n}\n\n/* Helper: Strengthen child at index child_idx (ensure it has at least t keys) */\nstatic void strengthen_child(BTreeNode* parent, int child_idx, int t) {\n    BTreeNode* child = parent->children[child_idx];\n    \n    // TODO 1: Check if left sibling exists and has >= t keys\n    // TODO 2: If yes, borrow_from_left and return\n    // TODO 3: Check if right sibling exists and has >= t keys\n    // TODO 4: If yes, borrow_from_right and return\n    // TODO 5: If left sibling exists, merge_with_left_sibling\n    // TODO 6: Else (only right sibling exists), merge child with right sibling\n    //         (Note: need to adjust indices for merging with right sibling)\n}\n\n/* Main recursive deletion function */\nbool delete_from_subtree(BTreeNode* node, int key, int t) {\n    int idx = node_find_key_index(node, key, NULL);\n    \n    // Case 1: Key is present in this node\n    if (idx < node->num_keys && node->keys[idx] == key) {\n        if (node->is_leaf) {\n            // Subcase 1A: Leaf node\n            node_remove_key(node, idx);\n            return true;\n        } else {\n            // Subcase 1B: Internal node\n            // TODO 1: Check if left child (children[idx]) has >= t keys\n            // TODO 2: If yes:\n            //   - Replace key at idx with predecessor from left subtree\n            //   - Recursively delete predecessor from left child\n            //   - Return true\n            // TODO 3: Else check if right child (children[idx+1]) has >= t keys\n            // TODO 4: If yes:\n            //   - Replace key at idx with successor from right subtree\n            //   - Recursively delete successor from right child\n            //   - Return true\n            // TODO 5: Else (both children have t-1 keys):\n            //   - Merge left child, key, and right child into left child\n            //   - Update node's keys and children (remove key at idx, shift)\n            //   - Recursively delete key from the merged left child\n            //   - Return true\n        }\n    } else {\n        // Case 2: Key is not in this node\n        if (node->is_leaf) {\n            // Key not found in tree\n            return false;\n        }\n        \n        // Check if we're descending to last possible child\n        bool last_child = (idx == node->num_keys);\n        \n        // TODO 1: If the child we're descending to has only t-1 keys:\n        //   - Call strengthen_child(node, idx, t)\n        //   - If we merged with left sibling, idx may need adjustment\n        \n        // TODO 2: Determine which child to descend to after potential merge\n        // TODO 3: Recursively call delete_from_subtree on that child\n        // TODO 4: Return the result\n    }\n    \n    return false; // Should not reach here\n}\n\n/* Public deletion API */\nbool btree_delete(BTree* tree, int key) {\n    if (!tree || !tree->root) return false;\n    \n    bool deleted = delete_from_subtree(tree->root, key, tree->t);\n    \n    // Handle root underflow (root with 0 keys but has a child)\n    if (tree->root->num_keys == 0 && !tree->root->is_leaf) {\n        // TODO 1: Save old root pointer\n        // TODO 2: Set tree->root to the root's only child (children[0])\n        // TODO 3: Free the old root\n        // TODO 4: Decrease tree height (optional tracking)\n    }\n    \n    if (deleted) {\n        tree->key_count--;\n    }\n    \n    return deleted;\n}\n```\n\n**Language-Specific Hints (C):**\n\n- **Memory Management**: After merging nodes, remember to `free()` the child node that was merged into its sibling. Use `node_destroy()` if it recursively frees children, but be careful—in a merge, the children are transferred, not destroyed.\n- **Array Shifting**: Implement careful `memmove()` operations for shifting keys and child pointers. For example:\n  ```c\n  // Shift keys left from index i\n  memmove(&node->keys[i], &node->keys[i+1], \n          (node->num_keys - i - 1) * sizeof(int));\n  // Shift child pointers if internal node\n  if (!node->is_leaf) {\n      memmove(&node->children[i], &node->children[i+1],\n              (node->num_keys - i) * sizeof(BTreeNode*));\n  }\n  ```\n- **Debugging**: Write a helper `print_tree(BTreeNode* node, int depth)` that indents based on depth to visualize tree structure before/after deletions.\n\n**Milestone Checkpoint:**\n\nAfter implementing deletion, verify correctness with these tests:\n\n1. **Simple deletions**: Insert 10 keys, delete them one by one, verifying `btree_search` fails for deleted keys and `btree_validate` passes after each deletion.\n2. **Borrowing scenarios**: Create a tree where a leaf has minimum keys (`t-1`) and its sibling has extra keys. Delete from the minimal leaf, ensuring it borrows correctly without merging.\n3. **Merging cascade**: Build a tree where multiple levels are at minimum occupancy. Delete a key that triggers merging up to the root, potentially reducing tree height.\n4. **Random sequence**: Generate random insert/delete sequences, validating invariants after each operation with `btree_validate`.\n\nExpected output from `btree_validate` should always return `true` for a correct implementation. Use the visualization from `btree_print` to manually inspect tree structure after complex deletions.\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Segmentation fault after delete | Accessing freed memory or invalid child pointer | Run with Valgrind, add `assert(node->num_keys >= 0)` after deletions | Ensure borrow/merge updates all pointers correctly; don't access merged nodes after free |\n| Search finds deleted keys | Key not actually removed or duplicate keys | Print tree after deletion, check all occurrences of the key | Ensure recursive deletion actually removes the key; handle all cases in `delete_from_subtree` |\n| Tree height doesn't decrease when root merges | Not handling root underflow | Check root's key count after deletion; add debug print | Implement root reduction in `btree_delete` when root has 0 keys and a child |\n| \"Minimum occupancy violated\" in validate | Borrow/merge logic incorrect | Run `btree_validate` after each operation to catch which node violates | Check borrow threshold (≥ t keys, not > t-1); ensure merge happens when both nodes have t-1 keys |\n| Infinite recursion | Child index not adjusted after merge | Print node and child indices at each recursive call | When merging with left sibling, the target child index decreases by 1 for subsequent recursion |\n\n\n## 9. Interactions and Data Flow\n\n> **Milestone(s):** Milestones 2, 3, and 4 (Search, Insert with Split, Delete with Rebalancing)\n\nThis section describes how the architectural components defined earlier collaborate to perform the core B-tree operations. While previous sections focused on individual components in isolation, here we examine their dynamic interactions—the function call sequences, data flow patterns, and state transitions that occur during search, insertion, and deletion. Understanding these interactions is crucial for debugging and for grasping how the B-tree maintains its invariants across complex operations.\n\nAt the highest level, the B-tree orchestrator (`BTree`) serves as the entry point for all operations, while the recursive operation functions (`search_recursive`, `insert_non_full`, `delete_from_subtree`) navigate the tree structure, and the node manipulation functions (`node_split_child`, `borrow_from_left`, etc.) perform localized transformations. The interactions follow a consistent pattern: start at the root, traverse downward while potentially transforming nodes, perform the target operation at the leaf or internal node, then propagate changes upward through the recursion stack.\n\n### Sequence of Operations\n\nEach core operation follows a specific sequence of function calls that reflects the recursive nature of B-tree algorithms. The sequences below trace through concrete examples to illustrate typical interactions.\n\n#### Search Operation Sequence\n\nSearch demonstrates the simplest interaction pattern—pure traversal without modification. Consider searching for key 42 in a B-tree with minimum degree `t = 3` and height 3.\n\nThe sequence begins with `btree_search(tree, 42)`, which immediately calls `search_recursive(tree->root, 42)`. The recursive search follows this pattern at each node:\n\n1. **Binary Search Within Node**: At the current node, `node_find_key_index` performs binary search on the node's keys array, comparing the target key (42) against each key. This returns either the index where 42 was found or the index of the child subtree where 42 should be located.\n\n2. **Key Found vs. Continue Search**: If the key is found in the current node, the recursion terminates and returns a `SearchResult` with `found = true` and the associated value. If not found and the current node is a leaf, the recursion terminates with `found = false`. If not found in an internal node, the function recurses on the appropriate child.\n\n3. **Recursive Descent**: Before recursing, the function validates that the child pointer at the computed index is not `NULL` (for internal nodes). The recursion depth increases by one as control passes to the child node.\n\nThe following diagram illustrates this recursive descent through three levels of the tree:\n\n![Search Operation Sequence](./diagrams/search-sequence.svg)\n\n**Concrete Walkthrough Example**: Suppose our B-tree has the following structure (keys shown, `t = 3`):\n- Root: [30, 60] with 3 children\n- Child 0 (keys < 30): [10, 20]\n- Child 1 (keys between 30-60): [40, 50]\n- Child 2 (keys > 60): [70, 80]\n\nSearching for key 42 proceeds as:\n1. `btree_search(tree, 42)` → `search_recursive(root, 42)`\n2. At root node: `node_find_key_index` compares 42 with [30, 60], determines 42 is between 30 and 60, returns child index 1\n3. Since key not found at root and root is internal, recurse: `search_recursive(root->children[1], 42)`\n4. At child 1 node: `node_find_key_index` compares 42 with [40, 50], determines 42 < 40, returns child index 0\n5. Recurse: `search_recursive(child1->children[0], 42)`\n6. At leaf node: `node_find_key_index` finds no match in empty leaf (or in keys [35, 41] if present), returns index 0\n7. Since leaf and key not found, return `SearchResult{found = false, value = NULL, comparisons = total}`\n\nThe recursion unwinds, propagating the not-found result back to the original caller.\n\n#### Insertion with Splitting Sequence\n\nInsertion involves more complex interactions because it may transform the tree structure. The sequence employs **proactive splitting** during the downward traversal to ensure that when we reach the target leaf, neither it nor any ancestor is full. Consider inserting key 25 into the same B-tree with `t = 3`, where the root is currently full (has 5 keys).\n\nThe interaction sequence follows:\n\n1. **Public API Entry**: `btree_insert(tree, 25, value_ptr)` is called. The function first checks if the root is full using `node_is_full(root, t)`.\n\n2. **Root Split (Special Case)**: If the root is full, the tree height must increase:\n   - Create a new root node using `node_create(t, false)` (internal node)\n   - Set the old root as the new root's first child (index 0)\n   - Call `node_split_child(new_root, 0, t)` to split the old root\n   - Update the tree's root pointer to the new root\n   - Call `insert_non_full(new_root, 25, value_ptr, t)` to continue insertion\n\n3. **Proactive Splitting During Descent**: `insert_non_full` implements the core recursive algorithm:\n   - At each node, use `node_find_key_index` to determine the appropriate child index\n   - Before descending to that child, check if the child is full using `node_is_full(child, t)`\n   - If full, call `node_split_child(current_node, child_index, t)` to split the child\n   - This splitting may change which child index we should descend to (if the promoted median key affects the comparison)\n\n4. **Leaf Insertion**: When reaching a leaf node (identified by `node->is_leaf == true`), insert the key-value pair directly using `node_insert_key` at the position determined by `node_find_key_index`.\n\n5. **Recursive Unwind**: As the recursion unwinds, no further action is needed because all splitting occurred proactively on the way down.\n\n**Concrete Walkthrough with Root Split**: Starting with a full root [10, 20, 30, 40, 50] (t=3, max keys=5), inserting key 25:\n1. `btree_insert` finds root full → creates new root `new_root`\n2. `node_split_child(new_root, 0, t)` splits old root:\n   - Left child gets [10, 20], right child gets [40, 50]\n   - Median key 30 promoted to `new_root.keys[0]`\n   - Tree height increases from 1 to 2\n3. `insert_non_full(new_root, 25, value_ptr, t)` begins:\n   - At `new_root` (keys=[30]): `node_find_key_index` finds 25 < 30 → child index 0\n   - Child 0 (keys=[10,20]) is not full → descend recursively\n4. `insert_non_full(child0, 25, value_ptr, t)`:\n   - Child0 is leaf → `node_find_key_index` finds insertion position between 20 and end\n   - `node_insert_key` inserts 25, resulting in keys [10, 20, 25]\n5. Final tree: root [30] with children [10,20,25] and [40,50]\n\n#### Deletion with Rebalancing Sequence\n\nDeletion has the most complex interaction pattern due to the need to handle underflow through borrowing or merging, which may cascade upward. Consider deleting key 30 from a B-tree where the target node and its siblings are at minimum capacity (`t-1` keys).\n\nThe deletion sequence involves multiple helper functions and potentially cascading rebalancing:\n\n1. **Public API Entry**: `btree_delete(tree, 30)` calls `delete_from_subtree(root, 30, t)`.\n\n2. **Traversal to Target Key**: `delete_from_subtree` recursively navigates to the node containing key 30, but with a crucial difference from insertion: it proactively **strengthens** nodes before descending to ensure we don't descend into an underfull node (except for the special case of the root).\n\n3. **Strengthening Before Descent**: At each node before recursing to a child:\n   - If the child has exactly `t-1` keys (minimum), call `strengthen_child(parent, child_index, t)`\n   - `strengthen_child` attempts to:\n     1. Borrow from left sibling if it has at least `t` keys (using `borrow_from_left`)\n     2. Otherwise, borrow from right sibling if it has at least `t` keys (using `borrow_from_right`)\n     3. Otherwise, merge with a sibling (using `merge_with_left_sibling` or equivalent for right)\n\n4. **Key Location and Deletion Type**: Once the key is located in a node:\n   - **Case A: Key in leaf**: Direct removal using `node_remove_key`\n   - **Case B: Key in internal node**: Replace with predecessor (using `get_predecessor`) or successor, then recursively delete that predecessor/successor from the leaf\n   - After deletion, check if the node is now underfull (but note: strengthening should prevent this except at root)\n\n5. **Root Shrinking**: After deletion completes, check if the root has 0 keys but has a child (height > 1). If so, make that child the new root and free the old root.\n\n6. **Cascading Effects**: Borrowing and merging operations modify parent nodes, which may themselves become underfull, potentially causing the underflow condition to propagate upward.\n\n**Concrete Walkthrough with Borrowing**: Deleting key 30 from a node with keys [30, 40] (t=3, min=2) that has left sibling [10, 20, 25] and right sibling [50, 60]:\n1. `delete_from_subtree` locates node containing 30\n2. Since node has exactly `t-1` keys (2), parent calls `strengthen_child` before deletion\n3. `strengthen_child` checks left sibling (3 keys ≥ t) → chooses `borrow_from_left`\n4. `borrow_from_left`:\n   - Moves largest key from left sibling (25) up to parent\n   - Moves parent's separator key (say, 28) down to target node\n   - Adjusts child pointers if nodes are internal\n   - Result: target node now has [28, 30, 40] (3 keys)\n5. Now safe to delete 30 from the strengthened node\n6. After deletion: target node has [28, 40] (2 keys, still ≥ t-1)\n\n**Concrete Walkthrough with Merging**: Same scenario but left sibling has only 2 keys (minimum):\n1. `strengthen_child` cannot borrow from left (only 2 keys)\n2. Check right sibling: also has only 2 keys\n3. Choose to merge with left sibling using `merge_with_left_sibling`\n4. Merge operation:\n   - Bring down parent's separator key (28) into left sibling\n   - Move all keys from target node to left sibling\n   - Adjust child pointers\n   - Free the now-empty target node\n   - Parent loses one key and one child pointer\n5. Parent may now be underfull, requiring recursive strengthening upward\n\n### State Transitions During Operations\n\nEach B-tree node transitions through different states defined by its key count relative to the capacity bounds. The table below captures how the four fundamental operations—direct insertion, direct deletion, borrowing, and merging—affect a node's key count, along with the conditions that trigger each transition.\n\nThe state machine for a node during deletion operations is visualized in the following diagram:\n\n![Node State During Deletion](./diagrams/delete-state-machine.svg)\n\n| Current State | Event | Next State | Action Taken | Conditions & Notes |\n|---------------|-------|------------|--------------|-------------------|\n| **Valid** (t-1 to 2t-1 keys) | **Insert key** (no split) | **Valid** or **Overfull** | `node_insert_key` adds key at sorted position | If node had 2t-2 keys before insert → becomes Overfull (2t-1 keys). Overfull state is temporary and immediately triggers a split if detected during insertion descent. |\n| **Overfull** (2t-1 keys) | **Split operation** | Two **Valid** nodes | `node_split_child` creates two nodes with t-1 keys each, promotes median to parent | Parent gains one key. This is the only way a node becomes Overfull—when a child is split and the parent receives the promoted key while already having 2t-2 keys. |\n| **Valid** | **Delete key** (direct removal) | **Valid** or **Underfull** | `node_remove_key` removes key, shifts remaining keys left | If node had exactly t-1 keys before deletion → becomes Underfull (< t-1 keys). This should not happen in correctly implemented deletion due to proactive strengthening. |\n| **Underfull** (< t-1 keys) | **Borrow from left sibling** | **Valid** | `borrow_from_left` takes largest key from left sibling via parent rotation | Left sibling must have ≥ t keys. Parent loses no keys (one moves down, another moves up). Right sibling borrowing is symmetric. |\n| **Underfull** | **Borrow from right sibling** | **Valid** | `borrow_from_right` takes smallest key from right sibling via parent rotation | Right sibling must have ≥ t keys. Parent loses no keys (one moves down, another moves up). |\n| **Underfull** | **Merge with left sibling** | **Valid** (merged node) | `merge_with_left_sibling` combines underfull node, left sibling, and parent separator | Both siblings have exactly t-1 keys. New merged node has 2t-2 keys (valid). Parent loses one key and one child pointer. |\n| **Underfull** (root) | **Root shrinking** | **Valid** (new root) or **Empty** | Root with 0 keys and 1 child becomes that child; old root freed | Only occurs when tree height decreases. New root may be Underfull if it has < t-1 keys but root has relaxed minimum. |\n\n**Key Transition Insights**:\n> The most critical insight is that **nodes only become underfull during direct key removal**, and this should only happen at the leaf where the key is physically deleted or at internal nodes where a predecessor/successor is deleted. All other nodes are proactively strengthened before descent, ensuring that recursion never enters an underfull node (except the special case of the root).\n\n**State Transition Example Walkthrough**: Consider a node with exactly `t-1` keys (the minimum for a non-root node):\n- If we attempt to delete a key from this node, it would become underfull (violating the invariant).\n- Therefore, before descending to delete from this node, its parent calls `strengthen_child`, which will either:\n  1. **Borrow** from a sibling with ≥ t keys → node becomes valid (t keys)\n  2. **Merge** with a sibling that also has t-1 keys → both combine into one valid node (2t-2 keys)\n- After strengthening, the node has ≥ t keys, so deletion can proceed safely without causing underflow.\n\nThe parent node itself may become underfull after lending a key during borrowing or after losing a key during merging. This is why deletion may require recursive strengthening that propagates upward toward the root.\n\n### Implementation Guidance\n\n> **Technology Note**: This implementation guidance focuses on the C programming language, which provides direct memory control essential for understanding B-tree's disk-oriented design. The guidance bridges the conceptual sequences described above with concrete function implementations.\n\n#### A. Recommended Sequence Implementation Patterns\n\nFor each operation, follow these calling patterns in your implementation:\n\n**Search Pattern**:\n```c\nSearchResult btree_search(BTree* tree, int key) {\n    // Public API: simply call the recursive helper\n    return search_recursive(tree->root, key);\n}\n\nSearchResult search_recursive(BTreeNode* node, int key) {\n    // Base case: empty tree (root is NULL)\n    if (node == NULL) {\n        SearchResult result = {false, NULL, 0};\n        return result;\n    }\n    \n    // Find position within current node\n    int comparisons = 0;\n    int i = node_find_key_index(node, key, &comparisons);\n    \n    if (i < node->num_keys && node->keys[i] == key) {\n        // Key found in this node\n        SearchResult result = {true, node->values[i], comparisons};\n        return result;\n    } else if (node->is_leaf) {\n        // Key not found and we're at a leaf\n        SearchResult result = {false, NULL, comparisons};\n        return result;\n    } else {\n        // Recurse to appropriate child\n        return search_recursive(node->children[i], key);\n    }\n}\n```\n\n**Insert Pattern** (simplified structure showing call sequence):\n```c\nbool btree_insert(BTree* tree, int key, void* value) {\n    // Handle root split first if needed\n    if (node_is_full(tree->root, tree->t)) {\n        BTreeNode* new_root = node_create(tree->t, false);\n        new_root->children[0] = tree->root;\n        node_split_child(new_root, 0, tree->t);\n        tree->root = new_root;\n    }\n    \n    // Now insert into non-full tree\n    return insert_non_full(tree->root, key, value, tree->t);\n}\n\nbool insert_non_full(BTreeNode* node, int key, void* value, int t) {\n    int i = node->num_keys - 1;\n    \n    if (node->is_leaf) {\n        // Insert directly into leaf\n        // TODO: Find insertion position and insert\n        return true;\n    } else {\n        // Find child to descend to\n        // TODO: Find child index i\n        \n        // Proactive split if child is full\n        if (node_is_full(node->children[i], t)) {\n            node_split_child(node, i, t);\n            // After split, need to re-check which child to descend to\n            // because the promoted key might affect the comparison\n            // TODO: Update i if needed\n        }\n        \n        // Recurse to child\n        return insert_non_full(node->children[i], key, value, t);\n    }\n}\n```\n\n**Delete Pattern** (showing strengthening logic):\n```c\nbool delete_from_subtree(BTreeNode* node, int key, int t) {\n    // This is a simplified version - actual implementation handles all cases\n    \n    // Find key position\n    int idx = 0;\n    while (idx < node->num_keys && key > node->keys[idx]) {\n        idx++;\n    }\n    \n    // Case 1: Key found in this node\n    if (idx < node->num_keys && node->keys[idx] == key) {\n        if (node->is_leaf) {\n            // Case 1A: Leaf node\n            node_remove_key(node, idx);\n        } else {\n            // Case 1B: Internal node\n            // TODO: Replace with predecessor/successor and recurse\n        }\n        return true;\n    } else {\n        // Case 2: Key not in this node\n        if (node->is_leaf) {\n            return false; // Key not found\n        }\n        \n        // Ensure child has at least t keys before descending\n        if (node_is_underfull(node->children[idx], t)) {\n            strengthen_child(node, idx, t);\n        }\n        \n        // Recurse to child\n        return delete_from_subtree(node->children[idx], key, t);\n    }\n}\n```\n\n#### B. Interaction Debugging Helpers\n\nTo visualize the interactions during development, add these debugging helpers to trace function calls:\n\n```c\n// Enable with compile flag -DDEBUG_INTERACTIONS\n#ifdef DEBUG_INTERACTIONS\n#define TRACE_ENTER(func, node, key) \\\n    printf(\"[TRACE] ENTER %s: node=%p, key=%d, is_leaf=%d, num_keys=%d\\n\", \\\n           func, (void*)node, key, node ? node->is_leaf : -1, node ? node->num_keys : -1)\n\n#define TRACE_EXIT(func, result) \\\n    printf(\"[TRACE] EXIT  %s: result=%d\\n\", func, result)\n\n#define TRACE_SPLIT(parent, child_idx) \\\n    printf(\"[TRACE] SPLIT: parent=%p, child_idx=%d\\n\", (void*)parent, child_idx)\n\n#define TRACE_BORROW(parent, child_idx, direction) \\\n    printf(\"[TRACE] BORROW: parent=%p, child_idx=%d, from=%s\\n\", \\\n           (void*)parent, child_idx, direction)\n#else\n#define TRACE_ENTER(func, node, key)\n#define TRACE_EXIT(func, result)\n#define TRACE_SPLIT(parent, child_idx)\n#define TRACE_BORROW(parent, child_idx, direction)\n#endif\n```\n\nUse these in your functions:\n```c\nSearchResult search_recursive(BTreeNode* node, int key) {\n    TRACE_ENTER(\"search_recursive\", node, key);\n    \n    // ... implementation ...\n    \n    TRACE_EXIT(\"search_recursive\", result.found);\n    return result;\n}\n```\n\n#### C. Common Interaction Bugs and Fixes\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|-----------------|-----|\n| **Infinite recursion during insertion** | Forgetting to update child index after splitting in `insert_non_full` | Add trace logging before and after split; check if i needs adjustment when promoted key > insertion key | After `node_split_child`, compare key with promoted key; if key > promoted key, increment child index |\n| **Key disappears after deletion** | Merging operation incorrectly handles child pointers | Use `btree_print` after each merge; verify all keys from both siblings and parent separator are present | In `merge_with_left_sibling`, ensure: 1) Copy parent separator, 2) Copy all keys from right node, 3) Copy all child pointers if internal |\n| **Segmentation fault during search** | Child pointer is NULL when node claims it's internal | Add assertion: `assert(node->is_leaf || node->children[i] != NULL)` before recursing | Ensure `node_create` initializes all child pointers to NULL and `node_split_child` properly transfers them |\n| **Tree height grows unnecessarily** | Splitting root when it's not full | Check `node_is_full` condition at root; might be off-by-one error | Verify `node_is_full` returns true only when `node->num_keys == 2*t - 1` |\n| **Borrowing makes sibling underfull** | Not checking sibling has ≥ t keys before borrowing | Add precondition check in borrow functions | In `strengthen_child`, check sibling key count before attempting borrow |\n\n#### D. Testing Interactions\n\nCreate interaction tests that verify the function call sequences:\n\n```c\n// test_interactions.c\nvoid test_insertion_sequence() {\n    BTree* tree = btree_create(3);\n    \n    // Insert until root splits\n    for (int i = 1; i <= 5; i++) {\n        btree_insert(tree, i, NULL);\n    }\n    // At this point, root should have 1 key (median of 1..5 = 3)\n    assert(tree->root->num_keys == 1);\n    assert(tree->root->keys[0] == 3);\n    \n    // Insert more to cause child splits\n    for (int i = 6; i <= 10; i++) {\n        btree_insert(tree, i, NULL);\n    }\n    // Verify structure through search\n    for (int i = 1; i <= 10; i++) {\n        SearchResult r = btree_search(tree, i);\n        assert(r.found);\n    }\n    \n    btree_destroy(tree);\n}\n\nvoid test_deletion_cascade() {\n    BTree* tree = btree_create(3);\n    \n    // Build a specific tree structure that will cascade on deletion\n    // Insert keys in order that creates minimum-occupancy nodes\n    int keys[] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n    for (int i = 0; i < 10; i++) {\n        btree_insert(tree, keys[i], NULL);\n    }\n    \n    // Delete a key that will trigger merge cascade\n    bool deleted = btree_delete(tree, 10);\n    assert(deleted);\n    \n    // Verify tree still valid\n    assert(btree_validate(tree));\n    \n    btree_destroy(tree);\n}\n```\n\nRun these tests frequently during development to ensure the component interactions remain correct as you implement each operation.\n\n\n## 10. Error Handling and Edge Cases\n\n> **Milestone(s):** Milestones 1-4 (all operations)\n\nA robust B-tree implementation must handle edge cases gracefully and provide mechanisms for detecting invariant violations. Since this is an educational implementation focused on algorithmic correctness rather than production resilience, we adopt a pragmatic approach: fail loudly on unrecoverable errors (like memory exhaustion) while maintaining data structure invariants for all valid operations. This section catalogs the failure modes specific to B-tree operations and provides strategies for both runtime handling and development-time verification.\n\n### 10.1 Failure Modes and Edge Cases\n\nB-tree operations involve complex pointer manipulation, dynamic memory allocation, and intricate balancing logic. Understanding potential failure points is crucial for building a correct implementation. The table below enumerates common failure scenarios, their detection methods, and recommended handling strategies for this in-memory implementation.\n\n| Failure Mode | Detection Strategy | Recovery Approach | Rationale |\n|--------------|-------------------|-------------------|-----------|\n| **Memory allocation failure** (malloc returns NULL) | Check return value of all allocation calls (`malloc`, `calloc`, `realloc`) | Propagate failure upward by returning error indicator (NULL/false); clean up any partially allocated resources | Memory exhaustion is unrecoverable for this in-memory implementation; failing gracefully prevents undefined behavior from null pointer dereferences |\n| **Duplicate key insertion** | Search operation during insertion path; binary search within each node | Treat as no-op (do nothing) or optionally update value if storing key-value pairs; return `false` to indicate no new key was added | B-trees typically support unique keys; silently ignoring duplicates maintains set semantics and simplifies deletion logic |\n| **Deletion of non-existent key** | Search during deletion path fails to find key | Return `false` to indicate key was not present; tree remains unchanged | Idempotent operation: deleting a missing key should not alter the tree structure or cause errors |\n| **Invalid minimum degree (t < 2)** | Validate parameter in `btree_create()` | Return NULL or use `DEFAULT_MIN_DEGREE` (3) | B-tree definition requires t ≥ 2 to ensure nodes can split (2t-1 ≥ 3 when t=2); lower values violate core invariants |\n| **Negative key values** (if domain restricted) | Validate input in public API functions | Return error or ignore (implementation choice) | While B-trees can handle any comparable keys, some use cases may restrict domains; validation prevents logical errors |\n| **Node underflow during deletion** | `node_is_underfull()` check after key removal | Trigger borrowing or merging via `strengthen_child()` before recursion | Proactive rebalancing maintains the t-1 minimum key invariant for all non-root nodes |\n| **Node overflow during insertion** | `node_is_full()` check before insertion | Trigger splitting via `node_split_child()` during descent | Proactive splitting ensures we never insert into a full node, maintaining the 2t-1 maximum invariant |\n| **Invalid child index in split/borrow/merge** | Range checks (0 ≤ i < parent->num_keys+1) | Assert during development; graceful failure with error return in production | These are internal functions; indices should always be valid if calling code maintains invariants |\n| **Corrupted node pointers** (dangling/recycled) | Cannot detect at runtime without memory tagging | Use `btree_validate()` during testing; employ Valgrind for memory error detection | Pointer corruption indicates serious bugs in memory management; prevention via careful ownership discipline is essential |\n\n> **Design Insight:** For educational implementations, **failing fast with clear diagnostics** is preferable to complex recovery mechanisms. Use assertions (`assert()`) liberally during development to catch invariant violations immediately, then replace with graceful error returns if building for production use.\n\nBeyond these failure modes, several edge case scenarios require special consideration in the algorithm logic:\n\n**Root Node Special Cases:**\n1. **Empty Tree Deletion:** Attempting to delete from an empty tree (root is NULL or root->num_keys == 0) should return `false` without error.\n2. **Root Underflow:** The root is exempt from the minimum key requirement (can have as few as 1 key when not a leaf). However, if the root becomes empty after deletion (0 keys), its single child should become the new root, decreasing tree height.\n3. **Root Split:** Splitting a full root is the only operation that increases tree height. The old root becomes a child of the new root.\n\n**Leaf Node Boundary Conditions:**\n1. **First/Last Key Deletion:** When removing the smallest or largest key from a leaf, binary search indices must be handled correctly to avoid off-by-one errors when shifting arrays.\n2. **Leaf with Minimum Keys:** A leaf with exactly t-1 keys that loses a key becomes underfull and requires rebalancing, even though this violates the invariant only after the operation completes.\n\n**Internal Node Edge Cases:**\n1. **Predecessor/Successor Selection:** When deleting a key from an internal node, if the chosen subtree (predecessor's left or successor's right) has exactly t-1 keys, the `strengthen_child()` function must be called before recursion to ensure we don't descend into an underfull node.\n2. **Leftmost/Rightmost Child:** When borrowing or merging with the leftmost or rightmost child of a parent, only one sibling exists, requiring asymmetric handling.\n\n**Algorithm-Specific Edge Cases:**\n\n**For Insertion:**\n- Inserting into a tree where all nodes along the path are full requires splitting at every level from root to leaf.\n- Inserting a key that would become the new minimum or maximum of the entire tree must maintain sorted order across all nodes.\n\n**For Deletion:**\n- The \"borrow or merge\" decision when a node becomes underfull: always attempt to borrow from an immediate sibling with > t-1 keys; only merge if both siblings have exactly t-1 keys.\n- When merging reduces the parent's key count, the parent may become underfull, requiring recursive rebalancing upward.\n- Deleting the only key in a root that is a leaf results in an empty tree.\n\n**For Search:**\n- Searching in an empty tree should return a `SearchResult` with `found = false` and `comparisons = 0`.\n- Searching for a key smaller than all keys or larger than all keys should traverse to the leftmost or rightmost leaf respectively.\n\n**Memory Management Edge Cases:**\n1. **Destroying an Empty Tree:** `btree_destroy(NULL)` or `btree_destroy()` on an empty but allocated tree should be safe (no-op).\n2. **Node Child Pointer Cleanup:** When merging nodes, the right node's children array must be copied before the node is freed to prevent memory leaks.\n3. **Array Shifting Operations:** `node_insert_key()` and `node_remove_key()` must correctly handle the trailing elements when inserting at or removing from the beginning, middle, or end of the arrays.\n\n> **Mental Model: The Building Inspector Analogy**\n> Think of error handling as a building inspector visiting a B-tree \"building.\" The inspector checks foundational invariants (minimum/maximum keys, sorted order, pointer consistency) much like checking a building's structural integrity. Some issues are critical (memory corruption = foundation cracks) requiring immediate shutdown, while others are maintenance items (underfull nodes = slightly uneven floors) that can be fixed on the spot with borrowing or merging tools. The `btree_validate()` function is the inspector's comprehensive checklist.\n\n### 10.2 Invariant Verification for Debugging\n\nImplementing a B-tree involves complex pointer manipulations and subtle boundary conditions that can easily introduce bugs. A comprehensive **invariant verification function** (`btree_validate()`) is an indispensable debugging tool that programmatically checks all B-tree rules, providing immediate feedback when an operation corrupts the data structure. This function should be called after each insert/delete during development and before returning from any public API in test builds.\n\n**Core Invariants to Verify:**\n\n1. **Structural Invariants:**\n   - **Root Invariant:** The root has between 1 and 2t-1 keys (unless the tree is empty, where root may be NULL or have 0 keys).\n   - **Node Capacity Invariant:** Every non-root node has between t-1 and 2t-1 keys.\n   - **Leaf Child Invariant:** All leaf node child pointers are NULL.\n   - **Internal Node Child Invariant:** Every internal node has exactly `num_keys + 1` non-NULL child pointers.\n   - **Tree Height Invariant:** All leaf nodes are at the same depth (same distance from root).\n\n2. **Ordering Invariants:**\n   - **Intra-node Ordering:** Keys within each node are stored in strictly ascending order (no duplicates).\n   - **Inter-node Ordering:** For any internal node with key `K_i` and children `C_i` and `C_{i+1}`:\n     - All keys in subtree `C_i` are less than `K_i`\n     - All keys in subtree `C_{i+1}` are greater than `K_i`\n   - **Global Ordering:** An in-order traversal of the tree yields keys in strictly ascending order.\n\n3. **Pointer Integrity Invariants:**\n   - **No Cycles:** The tree is a directed acyclic graph (no node is its own ancestor).\n   - **Parent Consistency:** If parent pointers were implemented (not required in our design), each child would reference its correct parent.\n   - **Memory Bounds:** All array accesses are within allocated bounds (`0 ≤ index < num_keys` for keys, `0 ≤ index ≤ num_keys` for children).\n\n**Implementation Strategy for `btree_validate()`:**\n\nThe validation function performs a recursive depth-first traversal, checking both local node properties and global relationships. It returns `true` if all invariants hold, `false` otherwise, and can optionally print detailed error messages to stderr.\n\n```c\n// Pseudo-code for validation logic (not actual implementation code)\nbool validate_node(BTreeNode* node, int t, bool is_root, \n                   int* min_key, int* max_key, int depth, int* leaf_depth) {\n    // Check 1: Node pointer validity\n    if (node == NULL) return is_root; // NULL only allowed for empty tree root\n    \n    // Check 2: Key count bounds\n    if (is_root) {\n        assert(0 <= node->num_keys && node->num_keys <= 2*t-1);\n    } else {\n        assert(t-1 <= node->num_keys && node->num_keys <= 2*t-1);\n    }\n    \n    // Check 3: Key ordering within node\n    for (int i = 0; i < node->num_keys - 1; i++) {\n        assert(node->keys[i] < node->keys[i+1]); // Strictly ascending\n    }\n    \n    // Check 4: Child pointer consistency\n    if (node->is_leaf) {\n        assert(all children are NULL);\n        // Record leaf depth for height uniformity check\n        if (*leaf_depth == -1) *leaf_depth = depth;\n        else assert(depth == *leaf_depth);\n    } else {\n        assert(node->num_keys + 1 == number of non-NULL children);\n        // Recursively validate children with key range checks\n        for (int i = 0; i <= node->num_keys; i++) {\n            int child_min, child_max;\n            bool child_valid = validate_node(node->children[i], t, false,\n                                            &child_min, &child_max, \n                                            depth + 1, leaf_depth);\n            assert(child_valid);\n            // Check subtree key bounds relative to parent keys\n            if (i > 0) assert(child_max < node->keys[i-1]);\n            if (i < node->num_keys) assert(child_min > node->keys[i]);\n        }\n    }\n    \n    // Update min/max keys for parent checks\n    *min_key = (node->num_keys > 0) ? node->keys[0] : INT_MAX;\n    *max_key = (node->num_keys > 0) ? node->keys[node->num_keys-1] : INT_MIN;\n    \n    return true;\n}\n```\n\n**Common Validation Failures and Their Likely Causes:**\n\n| Validation Failure | Likely Bug Location | Debugging Approach |\n|-------------------|---------------------|-------------------|\n| Key count out of bounds | Insertion: forgot to split full nodes<br>Deletion: incorrect borrow/merge logic | Add debug prints before/after each operation; check `node_is_full()`/`node_is_underfull()` logic |\n| Keys not sorted within node | `node_insert_key()` or `node_remove_key()` with incorrect shift logic | Test array insertion/removal in isolation; verify binary search returns correct index |\n| Leaf node has non-NULL children | `node_create()` initialization error or corruption during split | Ensure `is_leaf` flag set correctly; check `node_split_child()` child pointer allocation |\n| Internal node has wrong child count | Split/merge operations miscount children | Verify that when promoting median key, we also adjust child pointer counts |\n| Leaf depths unequal | Insertion: root split height increase incorrect<br>Deletion: root shrinkage incorrect | Trace height changes; ensure all insertions start at same root level |\n| Subtree key range violation | Binary search returns wrong child index; incorrect predecessor/successor selection | Add subtree range assertions in search path; verify in-order traversal |\n| Memory access violation | Array index out of bounds in `keys[]` or `children[]` | Use `assert(index >= 0 && index < capacity)` before each array access |\n\n**Integration with Testing:**\n\nThe `btree_validate()` function should be integrated into the test harness:\n\n1. **After every operation** in unit tests, call `btree_validate()` and assert it returns true.\n2. **In stress tests** (thousands of random insertions/deletions), periodically validate the tree.\n3. **As a debugging aid**, when a test fails, call `btree_print()` followed by `btree_validate()` with verbose error output to identify the first violated invariant.\n\n> **ADR: Comprehensive Validation vs. Performance**\n> \n> **Context:** During development, we need to detect invariant violations immediately, but runtime validation has performance costs.\n> \n> **Options Considered:**\n> 1. **Full validation after every public API call** (enabled only in debug builds via `#ifdef DEBUG`)\n> 2. **No built-in validation** (rely entirely on external test suite)\n> 3. **Selective validation** (check only the specific invariants relevant to the operation)\n> \n> **Decision:** Implement full validation gated by `#ifdef DEBUG` with optional verbose output.\n> \n> **Rationale:** B-tree bugs can manifest far from their source (e.g., a split error might only cause problems many operations later). Immediate detection with stack trace is invaluable for learning. The compile-time switch eliminates performance impact in release builds.\n> \n> **Consequences:** Developers must remember to test with debug builds; validation code must itself be bug-free.\n\n**Debugging Workflow:**\n\nWhen a test fails or invariant violation is detected:\n\n1. **Isolate the failing operation** using a minimal reproducible test case.\n2. **Add verbose logging** to trace the operation's execution path.\n3. **Call `btree_print()`** to visualize the tree structure before and after the failing operation.\n4. **Use `btree_validate()` with error messages** to identify the first violated invariant.\n5. **Check the corresponding operation's logic** against the algorithm steps in Sections 6-8.\n\n> **Key Insight:** The combination of `btree_print()` (visualization) and `btree_validate()` (invariant checking) forms a powerful debugging suite that can catch ~90% of B-tree implementation bugs without needing a debugger.\n\n### Implementation Guidance\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|--------------|-----------------|\n| Error Detection | Return `false`/`NULL` with error messages to `stderr` | Error codes enum with descriptive strings |\n| Invariant Checking | `assert()` macro from `<assert.h>` | Custom validation with detailed error logging |\n| Memory Debugging | Valgrind for leak detection | AddressSanitizer (`-fsanitize=address`) |\n\n**Recommended File Structure:**\n\n```\nbtree/\n├── include/\n│   └── btree.h           # Public API declarations\n├── src/\n│   ├── btree.c           # Main implementation\n│   ├── btree_validate.c  # Invariant checking (debug only)\n│   └── btree_debug.c     # Printing utilities\n└── tests/\n    ├── test_btree.c      # Unit tests\n    └── stress_test.c     # Randomized operations\n```\n\n**Infrastructure Starter Code (Complete Validation Function):**\n\n```c\n// btree_validate.c - Complete implementation\n#include \"btree.h\"\n#include <assert.h>\n#include <stdio.h>\n#include <limits.h>\n\n#ifdef DEBUG_VALIDATE\n\n// Helper for recursive validation\nstatic bool _validate_node(BTreeNode* node, int t, bool is_root,\n                          int* min_key, int* max_key, \n                          int depth, int* leaf_depth, int* error_count) {\n    // Check node exists (NULL only allowed for empty root)\n    if (node == NULL) {\n        if (is_root) return true;\n        fprintf(stderr, \"ERROR: Non-root node is NULL\\n\");\n        (*error_count)++;\n        return false;\n    }\n    \n    // Check key count bounds\n    if (is_root) {\n        if (node->num_keys < 0 || node->num_keys > 2*t-1) {\n            fprintf(stderr, \"ERROR: Root has %d keys, allowed [0, %d]\\n\", \n                    node->num_keys, 2*t-1);\n            (*error_count)++;\n            return false;\n        }\n    } else {\n        if (node->num_keys < t-1 || node->num_keys > 2*t-1) {\n            fprintf(stderr, \"ERROR: Non-root node has %d keys, allowed [%d, %d]\\n\", \n                    node->num_keys, t-1, 2*t-1);\n            (*error_count)++;\n            return false;\n        }\n    }\n    \n    // Check key ordering within node\n    for (int i = 0; i < node->num_keys - 1; i++) {\n        if (node->keys[i] >= node->keys[i+1]) {\n            fprintf(stderr, \"ERROR: Keys not sorted at index %d: %d >= %d\\n\",\n                    i, node->keys[i], node->keys[i+1]);\n            (*error_count)++;\n            return false;\n        }\n    }\n    \n    // Handle leaf nodes\n    if (node->is_leaf) {\n        // All child pointers must be NULL\n        for (int i = 0; i <= 2*t; i++) {\n            if (node->children[i] != NULL) {\n                fprintf(stderr, \"ERROR: Leaf node has non-NULL child at index %d\\n\", i);\n                (*error_count)++;\n                return false;\n            }\n        }\n        \n        // Record leaf depth\n        if (*leaf_depth == -1) {\n            *leaf_depth = depth;\n        } else if (depth != *leaf_depth) {\n            fprintf(stderr, \"ERROR: Leaf depth mismatch: %d vs %d\\n\", \n                    depth, *leaf_depth);\n            (*error_count)++;\n            return false;\n        }\n        \n        // Set min/max for this leaf\n        *min_key = (node->num_keys > 0) ? node->keys[0] : INT_MAX;\n        *max_key = (node->num_keys > 0) ? node->keys[node->num_keys-1] : INT_MIN;\n        return true;\n    }\n    \n    // Internal node validation\n    if (node->num_keys + 1 > 2*t) {\n        fprintf(stderr, \"ERROR: Internal node has too many children: %d\\n\",\n                node->num_keys + 1);\n        (*error_count)++;\n        return false;\n    }\n    \n    // Recursively validate children with key range checks\n    bool all_children_valid = true;\n    for (int i = 0; i <= node->num_keys; i++) {\n        if (node->children[i] == NULL) {\n            fprintf(stderr, \"ERROR: Internal node has NULL child at index %d\\n\", i);\n            (*error_count)++;\n            all_children_valid = false;\n            continue;\n        }\n        \n        int child_min, child_max;\n        bool child_valid = _validate_node(node->children[i], t, false,\n                                         &child_min, &child_max,\n                                         depth + 1, leaf_depth, error_count);\n        \n        if (!child_valid) {\n            all_children_valid = false;\n        }\n        \n        // Check child's keys against parent's keys\n        if (i > 0) {\n            if (child_max >= node->keys[i-1]) {\n                fprintf(stderr, \"ERROR: Child %d max key %d >= parent key %d\\n\",\n                        i, child_max, node->keys[i-1]);\n                (*error_count)++;\n                all_children_valid = false;\n            }\n        }\n        \n        if (i < node->num_keys) {\n            if (child_min <= node->keys[i]) {\n                fprintf(stderr, \"ERROR: Child %d min key %d <= parent key %d\\n\",\n                        i, child_min, node->keys[i]);\n                (*error_count)++;\n                all_children_valid = false;\n            }\n        }\n    }\n    \n    // Set min/max for this internal node\n    *min_key = (node->num_keys > 0) ? node->keys[0] : INT_MAX;\n    *max_key = (node->num_keys > 0) ? node->keys[node->num_keys-1] : INT_MIN;\n    \n    return all_children_valid;\n}\n\n// Public validation function\nbool btree_validate(BTree* tree) {\n    if (tree == NULL) {\n        fprintf(stderr, \"ERROR: Tree is NULL\\n\");\n        return false;\n    }\n    \n    if (tree->t < 2) {\n        fprintf(stderr, \"ERROR: Minimum degree t=%d < 2\\n\", tree->t);\n        return false;\n    }\n    \n    int error_count = 0;\n    int leaf_depth = -1;\n    int dummy_min, dummy_max;\n    \n    bool valid = _validate_node(tree->root, tree->t, true,\n                               &dummy_min, &dummy_max,\n                               0, &leaf_depth, &error_count);\n    \n    if (error_count > 0) {\n        fprintf(stderr, \"Validation failed with %d error(s)\\n\", error_count);\n    }\n    \n    return valid && (error_count == 0);\n}\n\n#else\n// Stub for non-debug builds\nbool btree_validate(BTree* tree) {\n    (void)tree;  // Unused parameter\n    return true; // Always passes in release builds\n}\n#endif // DEBUG_VALIDATE\n```\n\n**Core Logic Skeleton for Error Handling:**\n\n```c\n// btree.c - Error handling in public API functions\n\nBTree* btree_create(int min_degree) {\n    // TODO 1: Validate min_degree parameter (must be ≥ 2)\n    // TODO 2: Allocate memory for BTree structure using malloc\n    // TODO 3: Check if malloc returned NULL (memory allocation failure)\n    // TODO 4: Initialize fields: root = NULL, t = min_degree, key_count = 0\n    // TODO 5: Return the created BTree* or NULL on failure\n}\n\nbool btree_insert(BTree* tree, int key, void* value) {\n    // TODO 1: Validate tree parameter (not NULL)\n    // TODO 2: Check for duplicate key using btree_search()\n    // TODO 3: If root is NULL (empty tree), create new root node\n    // TODO 4: Check if root is full, if so:\n    //   a) Create new root\n    //   b) Split old root as child of new root\n    //   c) Update tree->root pointer\n    // TODO 5: Call insert_non_full on the (possibly new) root\n    // TODO 6: Increment tree->key_count if insertion succeeded\n    // TODO 7: Return true on success, false on failure (duplicate or memory error)\n}\n\nbool btree_delete(BTree* tree, int key) {\n    // TODO 1: Validate tree parameter (not NULL)\n    // TODO 2: Check if tree is empty (root == NULL or root->num_keys == 0)\n    // TODO 3: Call delete_from_subtree on root\n    // TODO 4: If root becomes empty after deletion:\n    //   a) If root is leaf, set root = NULL (tree becomes empty)\n    //   b) If root is internal, set root = root->children[0] (decrease height)\n    // TODO 5: Decrement tree->key_count if deletion succeeded\n    // TODO 6: Return true if key was found and deleted, false otherwise\n}\n\n// Example of memory allocation with error checking\nBTreeNode* node_create(int t, bool is_leaf) {\n    // TODO 1: Calculate array sizes based on t (max keys = 2t-1, max children = 2t)\n    // TODO 2: Allocate memory for node structure using malloc\n    // TODO 3: Check for allocation failure, return NULL if failed\n    // TODO 4: Allocate keys array (size 2*t-1 * sizeof(int))\n    // TODO 5: Check for allocation failure, free node and return NULL if failed\n    // TODO 6: Allocate children array (size 2*t * sizeof(BTreeNode*))\n    // TODO 7: Check for allocation failure, free keys and node, return NULL if failed\n    // TODO 8: Initialize all child pointers to NULL\n    // TODO 9: Set num_keys = 0, is_leaf flag\n    // TODO 10: Return the allocated node\n}\n```\n\n**Language-Specific Hints for C:**\n\n1. **Memory Allocation Errors:** Always check `malloc`/`calloc`/`realloc` return values. Use `perror(\"malloc\")` to print system error messages.\n2. **Cleanup on Failure:** Implement a rollback pattern: if allocation fails mid-way through node creation, free previously allocated components in reverse order.\n3. **Debug Builds:** Compile with `-DDEBUG_VALIDATE` to enable validation, `-g` for debug symbols, and `-fsanitize=address` for memory error detection.\n4. **Assertions:** Use `assert()` liberally during development but note they're removed in release builds (`-DNDEBUG`).\n\n**Debugging Tips Table:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Segmentation fault after insert | Accessing child pointer beyond allocated array | Run with Valgrind; add array bounds checks before each access | Ensure `children` array size is 2*t, indices are 0 ≤ i ≤ num_keys |\n| Tree height grows unexpectedly | Root split not increasing height properly | Print tree before/after each root split; check new root creation | When splitting root, create new root with old root as first child |\n| Keys disappear after deletion | Incorrect merge operation losing keys | Use `btree_print()` after each deletion step; validate after each operation | Ensure all keys from both nodes and parent separator are preserved in merge |\n| Infinite recursion during search | Child pointer points to ancestor (cycle) | Add cycle detection in validation; limit recursion depth | Check `node_split_child()` doesn't create circular references |\n| Memory leak after many operations | Not freeing nodes during merge or tree destruction | Use Valgrind; track allocations/frees | Ensure `node_destroy()` recursively frees all children; call in `btree_destroy()` |\n| Wrong search results | Keys not sorted within nodes | Validate intra-node ordering; check `node_insert_key()` shift logic | Binary search requires sorted keys; verify insertion maintains order |\n| \"Borrow from sibling\" fails | Not checking sibling has sufficient keys | Print sibling key count before attempting borrow | Only borrow if sibling has > t-1 keys; otherwise merge |\n\n**Milestone Checkpoint for Error Handling:**\n\nAfter implementing error handling and validation:\n\n1. **Run the test suite with validation enabled:**\n   ```bash\n   gcc -DDEBUG_VALIDATE -g src/btree.c src/btree_validate.c tests/test_btree.c -o test_btree\n   ./test_btree\n   ```\n   Expected: All tests pass with no validation errors printed.\n\n2. **Test edge cases manually:**\n   - Create tree with t=1 (should fail or use default)\n   - Insert duplicate keys (should return false, tree unchanged)\n   - Delete non-existent key (should return false, tree unchanged)\n   - Insert until root splits multiple times (check height increases)\n   - Delete until root shrinks (check height decreases)\n\n3. **Run memory checker:**\n   ```bash\n   valgrind --leak-check=full ./test_btree\n   ```\n   Expected: \"All heap blocks were freed -- no leaks are possible\"\n\n4. **Stress test with validation:**\n   Create a test that performs 10,000 random insertions/deletions, calling `btree_validate()` every 100 operations. The validation should never fail if implementation is correct.\n\n\n## 11. Testing Strategy\n\n> **Milestone(s):** Milestones 1-4 (all operations)\n\nA comprehensive testing strategy is crucial for implementing a complex, self-balancing data structure like a B-tree. Unlike simpler structures where bugs might cause obvious crashes, B-tree bugs can be subtle—causing silent corruption of invariants that only manifests later during specific sequences of operations. This section outlines a systematic testing approach combining unit tests, property-based tests, and milestone-specific checkpoints to build confidence incrementally.\n\n### Testing Approach and Scenarios\n\nThink of testing a B-tree like **testing a self-organizing library**. You need to verify not only that books can be found when requested (basic search), but also that the library's internal reorganization rules—splitting shelves when full, merging shelves when too empty, and updating the catalog index—work correctly under all scenarios. The testing strategy progresses from simple unit tests (verifying individual shelves work) to property-based tests (verifying the entire library stays organized after random activity) to edge case tests (verifying extreme scenarios like emptying and refilling the library).\n\nThe testing pyramid for our B-tree implementation has three layers:\n1. **Unit Tests**: Test individual components (`BTreeNode` functions) in isolation.\n2. **Integration/Operation Tests**: Test the public API (`btree_insert`, `btree_delete`, `btree_search`) and their interactions.\n3. **Property-Based & Stress Tests**: Verify that the B-tree invariants hold after thousands of random operations.\n\n#### Unit Testing Strategy\n\nUnit tests focus on the smallest testable components: the node-level helper functions. These functions form the building blocks of the main algorithms, and their correctness is essential.\n\n| Component to Test | Test Scenarios | Expected Behavior | Validation Method |\n|-------------------|----------------|-------------------|-------------------|\n| `node_create` | Create leaf and internal nodes with different `t` values | Node memory allocated, `num_keys` = 0, `is_leaf` set correctly, arrays allocated with correct capacities | Check struct field values, verify no memory leaks |\n| `node_destroy` | Destroy a single node, destroy a subtree | All memory freed, no dangling pointers | Use Valgrind or address sanitizer to confirm clean deallocation |\n| `node_find_key_index` | Binary search on empty node, node with keys, key less than all, key greater than all, key between keys, exact match | Returns correct index (0 for empty, correct position for non-existent, exact index for match) | Compare returned index against manual calculation, track comparison count |\n| `node_is_full` / `node_is_underfull` | Nodes with `t-1`, `t`, `2t-1`, `2t` keys (for full), and `t-2`, `t-1`, `t` keys (for underfull) | Returns true/false according to B-tree capacity rules | Verify against mathematical definition: full = `num_keys == 2*t-1`, underfull = `num_keys < t-1` |\n| `node_insert_key` | Insert at beginning, middle, end of key array | Key inserted at correct position, existing keys shifted right, `num_keys` incremented | Verify array contents and count |\n| `node_remove_key` | Remove from beginning, middle, end | Key removed, remaining keys shifted left, `num_keys` decremented | Verify array contents and count |\n| `node_split_child` | Split leaf child, split internal child, split when parent has capacity | Child split into two nodes, median key promoted to parent at correct index, parent's keys/children arrays adjusted | Verify all invariants: new nodes have `t-1` keys, parent gains one key, total keys preserved |\n\n> **Key Insight**: Unit testing `node_split_child` is particularly important because it's the core operation that maintains B-tree balance during insertion. A bug here will propagate through the entire tree.\n\n#### Integration Testing: Public API Operations\n\nThese tests verify that the main operations (`btree_insert`, `btree_delete`, `btree_search`) work together correctly and maintain all B-tree invariants.\n\n| Operation Sequence | Test Scenario | Invariants to Verify | Expected Outcome |\n|-------------------|---------------|----------------------|------------------|\n| **Search** | Search in empty tree, search for existing key, search for non-existent key | None (search doesn't modify tree) | Correct `found` flag, correct `value` returned, `comparisons` count reasonable |\n| **Insert** | Insert into empty tree, insert until root splits, insert keys in ascending/descending/random order | All five B-tree invariants (see Data Model section) | Tree height increases only when root splits, all keys findable after insertion |\n| **Delete** | Delete from leaf with > `t-1` keys, delete causing borrow from left/right sibling, delete causing merge, delete from internal node | All five B-tree invariants, no underfull nodes except root | Key no longer findable, tree height decreases only when root has single child |\n| **Mixed Operations** | Interleave insertions and deletions, repeating same keys, deleting non-existent keys | Invariants hold after each operation | Tree remains balanced, no memory corruption |\n\nA powerful technique is to write a **wrapper function** that calls the public API and then immediately validates all invariants using `btree_validate`. This can be used in every test:\n\n```c\n// Pseudocode for test helper\nvoid checked_insert(BTree* tree, int key, void* value) {\n    bool success = btree_insert(tree, key, value);\n    assert(success); // or handle duplicates as needed\n    assert(btree_validate(tree)); // invariants must hold\n}\n```\n\n#### Property-Based Testing\n\nProperty-based testing generates random sequences of operations and verifies that certain properties always hold. This is excellent for uncovering edge cases that manual test design might miss.\n\n| Property to Verify | Testing Approach | How to Validate |\n|-------------------|------------------|-----------------|\n| **Insertion maintains findability** | Generate N random keys, insert all, then verify each key exists via `btree_search` | All searches return `found == true` |\n| **Deletion removes keys** | Insert N random keys, delete a random subset, verify deleted keys are gone, others remain | Deleted keys return `found == false`, others `true` |\n| **Sorted order traversal** | After any operation sequence, perform in-order traversal (depth-first, left-to-right) | Traversed keys are in strictly ascending order |\n| **Invariant preservation** | After every single operation (insert/delete), call `btree_validate` | Validation passes for all intermediate states |\n| **Height bounds** | After any operation sequence, verify tree height ≤ `log_t((n+1)/2) + 1` where n = key count | Height remains within theoretical B-tree bounds |\n\n> **Implementation Note**: For property-based tests in C, consider using a simple deterministic pseudo-random number generator with a fixed seed for reproducible tests. Run thousands of operations to stress the implementation.\n\n#### Edge Case and Scenario Testing\n\nSpecific scenarios known to trigger bugs in B-tree implementations:\n\n| Scenario | Description | Why It's Tricky | Test Approach |\n|----------|-------------|-----------------|---------------|\n| **Root split** | Inserting into a full root (tree height increases) | Requires creating new root, special case in insertion algorithm | Insert exactly `2t-1` keys in ascending order, forcing root fills and splits |\n| **Cascading merges** | Deletion causing underflow that propagates up multiple levels | Must correctly handle sequential merges up to root | Build tree of height 3, delete specific keys to trigger multiple merges |\n| **Borrow from left vs right** | Underflow node with left sibling that has extra keys, vs right sibling | Symmetry bugs: implementation might work for one side but not the other | Create asymmetric sibling capacities, test deletions that require each borrow direction |\n| **Internal node deletion** | Deleting a key from an internal node (requires predecessor/successor swap) | Must choose correct predecessor/successor, handle leaf deletion after swap | Delete keys that appear at various positions in internal nodes |\n| **Duplicate key insertion** | Attempting to insert a key that already exists | Implementation may assume unique keys; must handle gracefully (return false or overwrite) | Depending on design choice, test that duplicates are rejected or values are updated |\n| **Minimum degree variations** | Testing with different `t` values (e.g., t=2, t=3, t=10) | Different `t` affects node capacities and tree shape | Run same test suite with multiple `t` values |\n| **Empty tree operations** | Deleting from empty tree, searching empty tree | Edge cases for root being `NULL` | Verify graceful handling (return false, not crash) |\n| **Single node tree** | All operations when tree has only root (no children) | Special cases in deletion (root can become empty) | Insert then delete all keys, verify root can become empty |\n\n### Milestone Checkpoints\n\nEach milestone in the project has specific deliverables that should be testable. The following table provides concrete checkpoints to verify your implementation is on track after completing each milestone.\n\n| Milestone | What to Test | Expected Output | How to Verify Success |\n|-----------|--------------|-----------------|----------------------|\n| **Milestone 1: Node Structure** | Node creation with different `t` values, leaf vs internal flag, key array capacity, child pointer array for internal nodes | Nodes created with correct field values, arrays of appropriate size | Use debug prints or a test function to inspect node fields. Memory allocators should allocate `(2*t-1)*sizeof(int)` for keys and `(2*t)*sizeof(BTreeNode*)` for children. |\n| | `node_insert_key` and `node_remove_key` on a node | Keys maintain sorted order after insert/remove, `num_keys` updated correctly | Manually verify key array contents after series of operations. |\n| | `node_is_full` and `node_is_underfull` | Returns true precisely when `num_keys == 2t-1` (full) or `num_keys < t-1` (underfull) | Test with nodes having `t-2`, `t-1`, `t`, `2t-1`, `2t` keys (the last should not occur in practice). |\n| **Milestone 2: Search** | Search in empty tree | Returns `found = false`, `value = NULL` | Basic sanity check. |\n| | Search in single-node tree (leaf) for existing and non-existent keys | Correct `found` flag, correct value returned for existing key | Insert a few keys, search for each. |\n| | Search in multi-level tree | Recursively descends through internal nodes, finds keys at all levels | Build a small tree manually (by calling node functions) with known structure, verify search finds all keys. |\n| | Binary search within node (`node_find_key_index`) | Returns correct index for key position, comparison count increments appropriately | Test with keys less than all, greater than all, between, and exact matches. |\n| **Milestone 3: Insert with Split** | Insert into non-full leaf | Key added in sorted position, no splits occur | Insert up to `2t-2` keys into an empty tree (root is leaf), verify tree remains single node. |\n| | Insert causing leaf split | Leaf splits, median promoted to parent (root), new leaf created | Insert `2t-1` keys in ascending order; after the `(2t-1)`th insertion, root should split (height becomes 2). Verify all keys findable. |\n| | Insert causing internal node split | Split propagates upward, tree height increases only when root splits | Build tree of height 2, fill internal nodes until they split, verify invariants. |\n| | Insertion with random key order | All invariants maintained, tree remains balanced | Insert 100 random keys, validate after each insertion. |\n| **Milestone 4: Delete with Rebalancing** | Delete from leaf with sufficient keys (`num_keys > t-1`) | Key removed, no structural changes | Build tree, delete key from leaf that won't cause underflow, verify key gone, tree valid. |\n| | Delete from leaf causing borrow from right sibling | Key borrowed from right sibling through parent, parent key updated | Create specific tree structure where leaf has `t-1` keys after deletion, right sibling has ≥ `t` keys. Verify borrow occurs. |\n| | Delete from leaf causing borrow from left sibling | Symmetric case to above. | Test both directions to catch asymmetry bugs. |\n| | Delete from leaf causing merge with sibling | Two siblings and parent separator merge into one node | Create scenario where both siblings have exactly `t-1` keys, deletion causes underflow, merge occurs. |\n| | Delete from internal node (using predecessor) | Key replaced with predecessor from leaf, predecessor deleted from leaf | Delete key from internal node, verify tree valid and key replaced correctly. |\n| | Delete from internal node (using successor) | Similar to predecessor case. | Ensure both predecessor and successor work if your implementation chooses one. |\n| | Cascading merges up to root | Multiple merges cause root to have single child, height decreases | Build tree of height 3, delete specific sequence to cause merges up to root. |\n| | Delete all keys (tree emptying) | Tree can become empty (root = NULL) or root with 0 keys (depending on implementation choice) | Insert N keys, delete all, verify tree empty or root empty. |\n\n> **Critical Testing Principle**: After completing each milestone, re-run all previous milestone tests to ensure new code hasn't broken existing functionality. This is especially important when moving from insertion to deletion, as deletion builds upon insertion's tree structure.\n\n#### Automated Test Harness Recommendation\n\nFor efficiency, implement a simple test harness that:\n\n1. **Runs unit tests** for each component.\n2. **Runs operation sequences** and validates invariants after each step.\n3. **Runs property-based tests** with random seeds.\n4. **Reports failures** with detailed information (tree state, operation that failed).\n\nA sample test progression might look like:\n```\n$ ./test_btree --milestone 1  # Node structure tests\n$ ./test_btree --milestone 2  # Search tests (also runs milestone 1 tests)\n$ ./test_btree --milestone 3  # Insert tests (runs milestones 1-2)\n$ ./test_btree --milestone 4  # Delete tests (runs all)\n$ ./test_btree --property 10000  # Run 10,000 random operations\n```\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Test Framework | Custom test harness with asserts and counters | Use a testing framework like **Check** (C unit testing framework) or **Google Test** (if using C++) |\n| Randomness | `rand()` with fixed seed for reproducibility | Use a more robust PRNG like PCG or Mersenne Twister |\n| Memory Checking | Manual tracking with `malloc`/`free` wrappers | Use **Valgrind** or **AddressSanitizer** for automatic detection |\n| Invariant Validation | Implement `btree_validate` as described in Section 10 | Extend validation with more detailed error messages and graph output for debugging |\n\n#### Recommended File/Module Structure\n\nAdd test files to your project structure:\n\n```\nbtree-project/\n├── include/\n│   └── btree.h              # Public API declarations\n├── src/\n│   ├── btree.c              # B-tree implementation\n│   ├── node.c               # Node-level functions\n│   └── operations.c         # Search, insert, delete algorithms\n└── tests/                   # Test directory\n    ├── test_harness.c       # Main test runner\n    ├── test_node.c          # Milestone 1: Node tests\n    ├── test_search.c        # Milestone 2: Search tests\n    ├── test_insert.c        # Milestone 3: Insert tests\n    ├── test_delete.c        # Milestone 4: Delete tests\n    ├── test_property.c      # Property-based tests\n    └── test_utils.c         # Test utilities (tree printing, validation helpers)\n```\n\n#### Infrastructure Starter Code: Test Harness\n\nHere's a complete, reusable test harness foundation:\n\n```c\n/* test_harness.c - Simple test framework for B-tree */\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <time.h>\n#include \"../include/btree.h\"\n\n#define TEST_START(name) printf(\"TEST: %s... \", name); fflush(stdout)\n#define TEST_PASS() printf(\"PASS\\n\")\n#define TEST_FAIL(reason) printf(\"FAIL: %s\\n\", reason); exit(1)\n\n/* Global test counters */\nstatic int tests_run = 0;\nstatic int tests_passed = 0;\n\n/* Wrapper for btree_insert that validates after each insert */\nvoid checked_insert(BTree* tree, int key, void* value) {\n    tests_run++;\n    bool success = btree_insert(tree, key, value);\n    if (!success) {\n        TEST_FAIL(\"insert returned false (duplicate key?)\");\n    }\n    if (!btree_validate(tree)) {\n        TEST_FAIL(\"tree invariant violated after insert\");\n    }\n    tests_passed++;\n}\n\n/* Wrapper for btree_delete */\nvoid checked_delete(BTree* tree, int key) {\n    tests_run++;\n    bool success = btree_delete(tree, key);\n    if (!success) {\n        TEST_FAIL(\"delete returned false (key not found?)\");\n    }\n    if (!btree_validate(tree)) {\n        TEST_FAIL(\"tree invariant violated after delete\");\n    }\n    tests_passed++;\n}\n\n/* Verify search returns expected result */\nvoid verify_search(BTree* tree, int key, bool expected_found, void* expected_value) {\n    tests_run++;\n    SearchResult res = btree_search(tree, key);\n    if (res.found != expected_found) {\n        printf(\"FAIL: key %d: expected found=%d, got %d\\n\", \n               key, expected_found, res.found);\n        exit(1);\n    }\n    if (expected_found && res.value != expected_value) {\n        printf(\"FAIL: key %d: value mismatch\\n\", key);\n        exit(1);\n    }\n    tests_passed++;\n}\n\n/* Run all milestone tests */\nvoid run_milestone1_tests();\nvoid run_milestone2_tests();\nvoid run_milestone3_tests();\nvoid run_milestone4_tests();\nvoid run_property_tests(int num_ops);\n\nint main(int argc, char** argv) {\n    printf(\"=== B-tree Test Suite ===\\n\");\n    \n    /* Run specific milestone tests based on command line */\n    if (argc < 2) {\n        /* Run all tests */\n        run_milestone1_tests();\n        run_milestone2_tests();\n        run_milestone3_tests();\n        run_milestone4_tests();\n        run_property_tests(1000);\n    } else if (strcmp(argv[1], \"--milestone1\") == 0) {\n        run_milestone1_tests();\n    } else if (strcmp(argv[1], \"--milestone2\") == 0) {\n        run_milestone1_tests();  /* Milestone 2 depends on 1 */\n        run_milestone2_tests();\n    } else if (strcmp(argv[1], \"--milestone3\") == 0) {\n        run_milestone1_tests();\n        run_milestone2_tests();\n        run_milestone3_tests();\n    } else if (strcmp(argv[1], \"--milestone4\") == 0) {\n        run_milestone1_tests();\n        run_milestone2_tests();\n        run_milestone3_tests();\n        run_milestone4_tests();\n    } else if (strcmp(argv[1], \"--property\") == 0) {\n        int num_ops = argc > 2 ? atoi(argv[2]) : 1000;\n        run_property_tests(num_ops);\n    }\n    \n    printf(\"\\n=== Summary: %d/%d tests passed ===\\n\", tests_passed, tests_run);\n    return tests_passed == tests_run ? 0 : 1;\n}\n```\n\n#### Core Logic Skeleton for Test Utilities\n\nFor the test utilities that you'll need to implement (like tree validation and printing), here are skeletons with TODOs:\n\n```c\n/* test_utils.c - Utilities for testing */\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"../include/btree.h\"\n\n/* Recursive helper for btree_validate */\nbool validate_node(BTreeNode* node, int t, bool is_root, \n                   int* min_key, int* max_key, int depth, int* leaf_depth) {\n    // TODO 1: Check that node pointer is not NULL (unless empty tree handled by caller)\n    // TODO 2: Verify key count: \n    //   - If is_root: 0 <= num_keys <= 2t-1\n    //   - Else: t-1 <= num_keys <= 2t-1\n    // TODO 3: Verify keys are in strictly increasing order\n    // TODO 4: If leaf node:\n    //   - Verify children pointers are all NULL\n    //   - Record leaf depth (first leaf found sets *leaf_depth, others must match)\n    // TODO 5: If internal node:\n    //   - Verify num_keys + 1 == number of non-NULL children\n    //   - Verify each child's keys are in correct range relative to parent keys\n    //   - Recursively validate each child\n    // TODO 6: Update min_key and max_key for this subtree for parent validation\n    return true;  // Placeholder\n}\n\nbool btree_validate(BTree* tree) {\n    // TODO 1: Handle empty tree (root == NULL): return true\n    // TODO 2: Initialize leaf_depth to -1\n    // TODO 3: Call validate_node on root with is_root = true\n    // TODO 4: Check that all leaves are at same depth (via leaf_depth)\n    return false;  // Placeholder\n}\n\nvoid print_node(BTreeNode* node, int depth) {\n    // TODO 1: Print indentation based on depth\n    // TODO 2: Print node type (leaf/internal) and key count\n    // TODO 3: Print keys in format like [k1, k2, ..., kn]\n    // TODO 4: If internal node, recursively print children with depth+1\n}\n\nvoid btree_print(BTree* tree) {\n    // TODO 1: Print tree header with t, height, size\n    // TODO 2: If root is NULL, print \"Empty tree\"\n    // TODO 3: Otherwise, call print_node(root, 0)\n}\n```\n\n#### Language-Specific Hints: C Testing\n\n- **Memory Leak Detection**: Always run tests with Valgrind: `valgrind --leak-check=full ./test_btree`\n- **Random Number Generation**: Use `srand(42)` for reproducible tests during development, but also test with different seeds.\n- **Assertions**: Use `assert()` from `<assert.h>` for invariants that should never fail in correct code.\n- **Modular Compilation**: Compile tests separately from main implementation: `gcc -c src/btree.c -o build/btree.o` then link with test files.\n\n#### Milestone Checkpoint Commands\n\nAfter implementing each milestone, run these commands to verify:\n\n```bash\n# After Milestone 1 (Node Structure):\n$ gcc -std=c99 -g -Iinclude src/node.c tests/test_node.c tests/test_harness.c -o test_node\n$ ./test_node --milestone1\n# Expected: \"PASS\" for all tests, no Valgrind errors\n\n# After Milestone 2 (Search):\n$ gcc -std=c99 -g -Iinclude src/*.c tests/test_search.c tests/test_harness.c tests/test_utils.c -o test_search\n$ ./test_search --milestone2\n# Expected: Search finds all inserted keys, returns false for non-existent keys\n\n# After Milestone 3 (Insert):\n$ gcc -std=c99 -g -Iinclude src/*.c tests/test_insert.c tests/test_harness.c tests/test_utils.c -o test_insert\n$ ./test_insert --milestone3\n# Expected: Tree validates after every insertion, root splits correctly\n\n# After Milestone 4 (Delete):\n$ gcc -std=c99 -g -Iinclude src/*.c tests/test_delete.c tests/test_harness.c tests/test_utils.c -o test_delete\n$ ./test_delete --milestone4\n# Expected: All deletion cases handled, tree validates, no memory leaks\n\n# Final comprehensive test:\n$ gcc -std=c99 -g -Iinclude src/*.c tests/*.c -o test_all\n$ valgrind --leak-check=full ./test_all\n# Expected: All tests pass, \"0 errors from Valgrind\"\n```\n\n#### Debugging Tips for Tests\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Segmentation fault in `node_create`** | Memory allocation failure, or accessing uninitialized pointer | Check `malloc` return values, ensure all array indices are within bounds | Add NULL checks after malloc, verify `t > 1` |\n| **Tree validation fails after insert** | Invariant violation (e.g., keys not sorted, wrong key count) | Use `btree_print` to visualize tree structure before/after failing operation | Check `node_insert_key` shifting logic, verify split median calculation |\n| **Search finds keys after insert but not after delete** | Deletion incorrectly removes extra keys or corrupts pointers | Print tree before and after deletion, check borrow/merge logic | Verify sibling indices are correct during borrow/merge |\n| **Memory leak reported by Valgrind** | `node_destroy` not recursive, or missing free for arrays | Run Valgrind with `--track-origins=yes`, check which allocation isn't freed | Ensure `node_destroy` frees keys, children, then the node itself |\n| **Infinite recursion during search/insert** | Base case missing (leaf check), or child pointer incorrect | Add debug prints showing node address and depth | Ensure `is_leaf` is set correctly, recursion stops at leaves |\n| **Tree height grows too quickly** | Splitting too aggressively (splitting non-full nodes) | Check `node_is_full` logic, verify split only called when `num_keys == 2*t-1` | Fix `node_is_full` condition |\n\n> **Pro Tip**: Implement `btree_print` early (even as a simple text dump) and use it liberally in tests. Visualizing the tree structure is the fastest way to spot structural bugs.\n\n\n## 12. Debugging Guide\n\n> **Milestone(s):** Milestones 1-4 (all operations)\n\nImplementing a B-tree is a complex undertaking involving recursive algorithms, careful pointer management, and maintenance of multiple invariants. Even with a solid design, bugs are inevitable. This section provides a structured approach to identifying, diagnosing, and fixing the most common categories of bugs you'll encounter during implementation. Think of this as your troubleshooting manual—a collection of known failure patterns and the tools to resolve them.\n\nDebugging a B-tree is like being a building inspector for a multi-story library. You need to check each floor (node) to ensure it has the right number of books (keys), that the floor plans (child pointers) lead to the correct sub-floors, and that the entire structure follows building codes (B-tree invariants). When something collapses (segmentation fault) or books go missing (lost keys), you need systematic inspection techniques to find the root cause.\n\n### Common Bug Symptoms and Fixes\n\nThe following table catalogues the most frequent symptoms, their likely underlying causes, and specific fixes. These are drawn from common patterns observed when implementing B-trees in C.\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| **Segmentation fault immediately after insertion or deletion** | Accessing a `children` pointer at an index beyond the current `num_keys` (remember: internal nodes have `num_keys + 1` children). | Before accessing `node->children[i]`, verify `i <= node->num_keys` for internal nodes. For leaf nodes, never access children. Use `assert(node->is_leaf || (i >= 0 && i <= node->num_keys))` in debug builds. |\n| **Keys disappearing after a split operation** | Incorrect calculation of the median index during `node_split_child`, leading to wrong key distribution between the old and new nodes. The median key should be at index `t-1` (0-based) in a node with `2t-1` keys. | Double-check the split logic: the original node keeps the first `t-1` keys (indices 0 to `t-2`), the new node gets the last `t-1` keys (indices `t` to `2t-2`), and the median key at index `t-1` is promoted. |\n| **Infinite recursion during search/insert/delete** | Forgetting to check the `is_leaf` flag before attempting to recurse into child nodes. The recursive call is made even when `node->is_leaf` is true, leading to endless descent into invalid memory. | Ensure every recursive function has a base case that checks `if (node->is_leaf) return ...` before attempting to access `node->children`. |\n| **Tree height increases unnecessarily (more than one root split)** | Failing to update the tree's root pointer after a root split. The old root remains, and a new root is created but not assigned to `tree->root`. | In `btree_insert`, after calling a helper that may split the root, check if the root was split (e.g., if the old root is full). If so, create a new root with the promoted key and two children. |\n| **\"Key not found\" for keys that were definitely inserted** | Keys are not maintained in sorted order within nodes, breaking the binary search assumption. Insertion or split operations may place keys in wrong positions. | After any key insertion or movement (during insert, borrow, merge), ensure the keys array remains sorted. Write a helper `node_validate_order(node)` that asserts ascending order for debugging. |\n| **Memory leak (Valgrind reports lost blocks)** | Not recursively freeing child nodes in `node_destroy`. Only freeing the node's own arrays but not its children's arrays for internal nodes. | In `node_destroy`, if `!node->is_leaf`, iterate through `i = 0 to node->num_keys` and call `node_destroy(node->children[i])` before freeing the node's own arrays. |\n| **Underflow (node has < t-1 keys) after deletion** | The `strengthen_child` (or equivalent preemptive borrowing/merging during descent) was not performed correctly, or the borrow/merge logic itself is flawed. | During deletion descent, before recursing into a child, ensure the child has at least `t` keys. If not, borrow from a sibling or merge with a sibling. Re-check the conditions for borrowing (sibling has ≥ t keys) vs. merging (sibling has exactly t-1 keys). |\n| **Child pointer becomes NULL after merge, causing segfault later** | When merging two children, the right child node is freed but its pointer in the parent's `children` array is not set to NULL or removed. The array may later be accessed assuming all entries are valid. | After `merge_with_left_sibling`, the right child is absorbed. You must shift the parent's child pointers left to remove the now-empty slot. For `borrow` operations, child pointers are rearranged but not removed. |\n| **Duplicate keys appear in the tree** | The insertion logic does not check for existing keys before inserting. B-trees typically allow duplicates? (Usually not; we assume unique keys for this implementation). | In `btree_insert`, before starting the insertion process, call `btree_search`. If found, decide whether to replace the value or reject the insertion. The design assumes unique keys, so you may choose to return false. |\n| **Binary search returns incorrect index (off-by-one)** | Incorrect handling of the `high` index (should be `num_keys - 1` initially) or confusion between \"index where key is found\" and \"index where key should be inserted\". | The `node_find_key_index` should return the first index where `key <= node->keys[i]`. If `key` is greater than all keys, return `num_keys`. Test with a simple linear search as a reference implementation. |\n| **After many insertions and deletions, tree invariants break** | Cumulative error from small mistakes in edge cases, e.g., root's minimum key count (can be 1), handling of the last child pointer during split, etc. | Implement `btree_validate` and call it after every operation in debug mode. This function recursively checks all invariants: key count bounds, ordering, leaf property consistency, and child pointer counts. |\n\n### Debugging Techniques and Tools\n\nEffective debugging requires more than just guessing. You need a systematic approach and the right tools. Below are techniques specifically tailored for B-tree implementations in C.\n\n#### 1. **Verbose Logging with Function Tracing**\n\nAdd logging macros that print the execution flow and key data structures. This lets you see exactly how the tree evolves.\n\n> **Mental Model:** This is like adding security cameras at every staircase and bookshelf in the library. You can replay the footage to see exactly when and where a book was misplaced.\n\n**How to implement:**\n- Create a `DEBUG` macro that can be enabled/disabled at compile time.\n- At the entrance and exit of each major function (`search_recursive`, `insert_non_full`, `delete_from_subtree`), log the function name, parameters (e.g., node address, key), and key state (e.g., `num_keys`).\n- Before and after critical operations (split, borrow, merge), print the entire state of the affected nodes.\n\n**Example log output snippet:**\n```\n[INSERT] insert_non_full node=0x1234, key=42, is_leaf=0, num_keys=3\n[SPLIT] Splitting child at index 1 of parent 0x1234\n  Before split: child keys=[10,20,30,40,50]\n  After split: left keys=[10,20], promoted=30, right keys=[40,50]\n```\n\nThis allows you to trace the exact sequence of operations leading to a bug.\n\n#### 2. **Tree Visualization Function**\n\nA text-based tree printer is invaluable for seeing the overall structure. Implement `btree_print` that outputs the tree in a readable format.\n\n**Recommended format (indentation-based):**\n```\nB-Tree (t=3, height=2, keys=10)\n[Root] keys=30\n  [Child 0] keys=10 20\n    [Leaf] keys=5 7 9\n    [Leaf] keys=12 15\n    [Leaf] keys=22 25\n  [Child 1] keys=40 50\n    [Leaf] keys=32 35 38\n    [Leaf] keys=42 45 48\n    [Leaf] keys=52 55\n```\nThis reveals structural problems like missing nodes, incorrect key distributions, or broken parent-child relationships.\n\n**Implementation Guidance:** Use a recursive helper that takes a node and an indentation level. For each node, print its keys. If not a leaf, recursively print each child with increased indentation.\n\n#### 3. **Invariant Verification Function**\n\nThe single most powerful debugging tool is an automatic invariant checker. Implement `btree_validate` that traverses the entire tree and asserts every B-tree rule.\n\n**What to check:**\n1. **Key count bounds:** For root: `0 <= num_keys <= 2t-1`. For others: `t-1 <= num_keys <= 2t-1`.\n2. **Key ordering:** Keys within each node are strictly increasing.\n3. **Leaf consistency:** If `is_leaf` is true, all child pointers are NULL. If false, all child pointers are non-NULL (for indices `0..num_keys`).\n4. **Child count:** Internal nodes have exactly `num_keys + 1` children.\n5. **Recursive child validation:** For internal nodes, every key in child `i` is less than `node->keys[i]`, and every key in child `i+1` is greater than `node->keys[i]`. Also recursively validate each child.\n6. **Tree height consistency:** All leaf nodes are at the same depth (same distance from root).\n\nCall `btree_validate` after every insert and delete operation during development. When a violation occurs, print the node state and abort. This catches bugs immediately at their source rather than allowing corruption to propagate.\n\n#### 4. **Memory Debuggers: Valgrind and AddressSanitizer**\n\nMemory errors are common in C. Use these tools to detect:\n- Use of uninitialized memory\n- Buffer overflows (writing beyond allocated arrays)\n- Memory leaks\n- Use-after-free errors\n\n**Valgrind usage:**\n```bash\nvalgrind --leak-check=full ./your_btree_program\n```\n\n**AddressSanitizer (faster, compile-time instrumentation):**\n```bash\ngcc -fsanitize=address -g your_code.c -o your_btree_program\n./your_btree_program\n```\n\nThese tools will pinpoint the exact line where illegal memory access occurs, which is especially helpful for segmentation faults.\n\n#### 5. **Interactive Debugging with GDB**\n\nWhen you have a reproducible crash, use GDB to inspect program state at the moment of failure.\n\n**Essential GDB commands:**\n- `break function_name` – Set a breakpoint\n- `run` – Start program\n- `backtrace` or `bt` – Show call stack at crash\n- `print node->num_keys` – Inspect variable\n- `x/10wx node->keys` – Examine memory as array of words\n- `step` and `next` – Single-step execution\n\n**Pro tip:** Create a GDB script that sets breakpoints at key functions and prints node information automatically.\n\n#### 6. **Unit Test with Known Sequences**\n\nCreate small, focused test cases that exercise specific operations in isolation. For example:\n\n1. **Test root split:** Insert exactly `2t-1` keys in ascending order, forcing a single root split.\n2. **Test borrow from right sibling:** Create a specific tree configuration, then delete a key that triggers borrowing.\n3. **Test merge cascade:** Build a tree where deletion causes a merge that propagates upward.\n\nBy isolating scenarios, you simplify the debugging surface. Compare your tree's state after each operation against a manually computed expected state.\n\n#### 7. **Property-Based Testing**\n\nAfter basic operations work, use property-based testing to find edge cases. The key properties of a B-tree are:\n- All keys are always present after insertion.\n- No keys are present after deletion.\n- The tree remains balanced (all leaves at same depth).\n- Keys are always in sorted order when traversed in-order.\n\nGenerate random sequences of insertions and deletions, and after each operation, verify these properties using your `btree_validate` function. This can uncover subtle bugs that only appear with specific sequences.\n\n### Implementation Guidance\n\nThis section provides concrete code and tools to implement the debugging techniques described above.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Debug Logging | Custom `DEBUG` macro with `printf` | Logging library (e.g., `zlog` for C) with configurable levels |\n| Memory Debugging | Valgrind | AddressSanitizer (ASan) + UndefinedBehaviorSanitizer (UBSan) |\n| Interactive Debugging | GDB with basic commands | GDB with Python scripting for custom pretty-printers |\n| Visualization | Simple text indentation | Graphviz DOT format generation for graphical output |\n\n#### B. Recommended File/Module Structure\n\nAdd debugging utilities to your project structure:\n```\nbtree/\n  include/\n    btree.h          ← Main public interface\n    debug.h          ← Debugging macros and utilities\n  src/\n    btree.c          ← Core B-tree implementation\n    debug.c          ← Debugging implementations (validate, print)\n  tests/\n    test_btree.c     ← Unit and property tests\n  examples/\n    demo.c           ← Demonstration program\n```\n\n#### C. Infrastructure Starter Code\n\nHere's complete, ready-to-use code for debugging macros and validation helpers:\n\n**`include/debug.h`:**\n```c\n#ifndef DEBUG_H\n#define DEBUG_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include \"btree.h\"\n\n// Enable/disable debug logging at compile time\n// #define DEBUG 1\n\n#ifdef DEBUG\n#define LOG(fmt, ...) printf(\"[%s:%d] \" fmt, __func__, __LINE__, ##__VA_ARGS__)\n#else\n#define LOG(fmt, ...) \n#endif\n\n// Assert with custom message\n#define ASSERT(cond, msg) \\\n    do { \\\n        if (!(cond)) { \\\n            fprintf(stderr, \"Assertion failed: %s (%s:%d)\\n\", msg, __FILE__, __LINE__); \\\n            abort(); \\\n        } \\\n    } while(0)\n\n// Function prototypes for debugging utilities\nbool btree_validate(const BTree* tree);\nvoid btree_print(const BTree* tree);\nvoid node_print(const BTreeNode* node, int indent);\n\n#endif // DEBUG_H\n```\n\n**`src/debug.c`:**\n```c\n#include \"debug.h\"\n#include <stdlib.h>\n#include <assert.h>\n\n// Helper to validate a subtree\nstatic bool node_validate(const BTreeNode* node, int t, int depth, \n                         int* leaf_depth, int min_key, int max_key, \n                         bool is_root) {\n    if (!node) return true;\n    \n    // Check key count bounds\n    if (is_root) {\n        if (node->num_keys < 0 || node->num_keys > 2*t-1) {\n            LOG(\"Root key count violation: %d\\n\", node->num_keys);\n            return false;\n        }\n    } else {\n        if (node->num_keys < t-1 || node->num_keys > 2*t-1) {\n            LOG(\"Node key count violation: %d\\n\", node->num_keys);\n            return false;\n        }\n    }\n    \n    // Check keys are sorted\n    for (int i = 0; i < node->num_keys - 1; i++) {\n        if (node->keys[i] >= node->keys[i+1]) {\n            LOG(\"Keys not sorted at index %d: %d >= %d\\n\", \n                i, node->keys[i], node->keys[i+1]);\n            return false;\n        }\n    }\n    \n    // Check key range (optional, for thorough validation)\n    for (int i = 0; i < node->num_keys; i++) {\n        if (node->keys[i] <= min_key || node->keys[i] >= max_key) {\n            LOG(\"Key %d out of range (%d, %d)\\n\", node->keys[i], min_key, max_key);\n            return false;\n        }\n    }\n    \n    if (node->is_leaf) {\n        // For leaves, check all children are NULL\n        for (int i = 0; i <= node->num_keys; i++) {\n            if (node->children[i] != NULL) {\n                LOG(\"Leaf has non-NULL child at index %d\\n\", i);\n                return false;\n            }\n        }\n        \n        // Check leaf depth consistency\n        if (*leaf_depth == -1) {\n            *leaf_depth = depth;\n        } else if (*leaf_depth != depth) {\n            LOG(\"Leaf depth mismatch: %d vs %d\\n\", *leaf_depth, depth);\n            return false;\n        }\n        return true;\n    } else {\n        // Internal node: check child count and pointers\n        if (node->num_keys + 1 != node->num_children) {\n            LOG(\"Child count mismatch: keys=%d, children=%d\\n\", \n                node->num_keys, node->num_children);\n            return false;\n        }\n        \n        // Validate each child recursively\n        for (int i = 0; i <= node->num_keys; i++) {\n            if (node->children[i] == NULL) {\n                LOG(\"Internal node has NULL child at index %d\\n\", i);\n                return false;\n            }\n            \n            // Determine key bounds for child\n            int child_min = (i == 0) ? min_key : node->keys[i-1];\n            int child_max = (i == node->num_keys) ? max_key : node->keys[i];\n            \n            if (!node_validate(node->children[i], t, depth + 1, \n                              leaf_depth, child_min, child_max, false)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nbool btree_validate(const BTree* tree) {\n    if (!tree || !tree->root) return true;\n    \n    int leaf_depth = -1;\n    return node_validate(tree->root, tree->t, 0, &leaf_depth, \n                        INT_MIN, INT_MAX, true);\n}\n\nstatic void print_node(const BTreeNode* node, int indent) {\n    for (int i = 0; i < indent; i++) printf(\"  \");\n    \n    printf(\"[%s] \", node->is_leaf ? \"Leaf\" : \"Node\");\n    printf(\"keys=%d: \", node->num_keys);\n    for (int i = 0; i < node->num_keys; i++) {\n        printf(\"%d \", node->keys[i]);\n    }\n    printf(\"\\n\");\n}\n\nstatic void btree_print_recursive(const BTreeNode* node, int indent) {\n    if (!node) return;\n    \n    print_node(node, indent);\n    \n    if (!node->is_leaf) {\n        for (int i = 0; i <= node->num_keys; i++) {\n            btree_print_recursive(node->children[i], indent + 1);\n        }\n    }\n}\n\nvoid btree_print(const BTree* tree) {\n    if (!tree) {\n        printf(\"BTree: NULL\\n\");\n        return;\n    }\n    \n    printf(\"B-Tree (t=%d, height=%d, total_keys=%zu)\\n\", \n           tree->t, btree_height(tree), btree_size(tree));\n    btree_print_recursive(tree->root, 0);\n    printf(\"\\n\");\n}\n```\n\n#### D. Core Logic Skeleton Code\n\nFor the main operations, add debugging hooks. Here's how to instrument `btree_insert`:\n\n```c\nbool btree_insert(BTree* tree, int key, void* value) {\n    LOG(\"Inserting key=%d\\n\", key);\n    \n    // TODO 1: Check for duplicate key (if desired)\n    // SearchResult res = btree_search(tree, key);\n    // if (res.found) return false; // or replace value\n    \n    // TODO 2: If root is full, split it\n    if (node_is_full(tree->root, tree->t)) {\n        LOG(\"Root is full, splitting\\n\");\n        // Create new root\n        BTreeNode* new_root = node_create(tree->t, false);\n        new_root->children[0] = tree->root;\n        node_split_child(new_root, 0, tree->t);\n        tree->root = new_root;\n    }\n    \n    // TODO 3: Call insert_non_full on the root\n    bool result = insert_non_full(tree->root, key, value, tree->t);\n    \n    // TODO 4: Validate tree in debug mode\n    #ifdef DEBUG\n    if (!btree_validate(tree)) {\n        fprintf(stderr, \"Invariant violated after insertion of key=%d\\n\", key);\n        btree_print(tree);\n        abort();\n    }\n    #endif\n    \n    LOG(\"Insertion %s\\n\", result ? \"succeeded\" : \"failed\");\n    return result;\n}\n```\n\n#### E. Language-Specific Hints (C)\n\n- **Use `assert` liberally:** Include `<assert.h>` and use `assert(condition)` to catch logic errors early. Assertions can be disabled in release builds with `-DNDEBUG`.\n- **Compile with debugging symbols:** Always use `-g` flag when compiling debug builds: `gcc -g -O0 -DDEBUG -o btree btree.c debug.c`\n- **Enable all warnings:** Use `-Wall -Wextra -Werror` to catch potential issues at compile time.\n- **Use `typedef` for function pointers:** If you need callback functions for tree traversal or value freeing, use typedefs for clarity.\n- **Memory initialization:** Always initialize allocated memory with `calloc` or explicit loops. Uninitialized pointers cause non-deterministic bugs.\n\n#### F. Debugging Tips Table\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Valgrind reports \"invalid read\" at `node_find_key_index`** | Reading beyond allocated `keys` array in binary search. | Add logging to print `num_keys` and the search bounds. Use GDB to break at that function and examine the array. | Ensure binary search limits are `[0, num_keys)` for key comparisons, and `num_keys` is correctly maintained. |\n| **Tree prints show duplicate keys at different levels** | During split, the median key was not removed from the child node, or was inserted twice. | Print the state of both child nodes and the parent before and after split. | In `node_split_child`, after promoting the median key, reduce the original child's `num_keys` to `t-1` (removing keys from index `t` onward). |\n| **Deletion causes underflow even after borrow/merge** | The `strengthen_child` function is not called during descent, or the wrong sibling is chosen for borrowing. | Add logging to show which child is strengthened, which sibling is chosen, and why. | Ensure you check left sibling first for borrowing, then right sibling. The sibling must have at least `t` keys to borrow. |\n| **Height increases but root has only one key** | This is correct after a root split. If height increases multiple times unnecessarily, the root split logic may be called when root is not full. | Check the condition before splitting root: `if (node_is_full(tree->root, tree->t))`. | Only split the root when it's full (`num_keys == 2*t-1`). |\n| **Segmentation fault in `node_destroy`** | Double-free or accessing freed memory. Child pointers might be invalid. | Run with Valgrind to see invalid access. Check that `node_destroy` only frees child pointers for internal nodes. | In `node_destroy`, check `if (!node->is_leaf)` before iterating through children. Set pointers to NULL after freeing. |\n\n#### G. Milestone Checkpoint for Debugging\n\nAfter implementing each milestone, run these debugging checks:\n\n**Milestone 1 (Node Structure):**\n- Run: `./test_btree --test-node-creation`\n- Expected: No memory leaks (Valgrind clean), nodes created with correct capacity.\n- Verify: Use a debugger to inspect a node's memory layout. Check that `keys` and `children` arrays are properly allocated.\n\n**Milestone 2 (Search):**\n- Run: `./test_btree --test-search`\n- Expected: Search finds all inserted keys, returns correct \"not found\" for absent keys.\n- Debugging: Insert 10 keys, print tree, then search for each. Add logging to trace the search path.\n\n**Milestone 3 (Insert with Split):**\n- Run: `./test_btree --test-insert`\n- Expected: Tree maintains all invariants after each insertion. Root splits when appropriate.\n- Debugging: Insert exactly `2t-1` ascending keys and validate tree after each insertion. Check that height increases by 1 only when root splits.\n\n**Milestone 4 (Delete with Rebalancing):**\n- Run: `./test_btree --test-delete`\n- Expected: All keys remain findable after random insert/delete sequences. Tree height may decrease.\n- Debugging: Create a known tree structure, delete a specific key that triggers borrow, then merge. Print tree before and after each operation.\n\nWhen something goes wrong, use this systematic approach:\n1. **Reproduce minimally:** Create the smallest test case that triggers the bug.\n2. **Add instrumentation:** Enable debug logging around the failing operation.\n3. **Validate invariants:** Call `btree_validate` before and after the operation.\n4. **Inspect state:** Use `btree_print` to visualize the tree structure.\n5. **Debug step-by-step:** Use GDB to step through the failing function.\n6. **Check memory:** Run Valgrind to catch memory corruption.\n\nRemember, B-tree bugs often manifest far from their source—a missing key might result from a split that happened hours of operations earlier. The invariant checker is your best defense against these subtle, cumulative errors.\n\n\n## 13. Future Extensions\n\n> **Milestone(s):** This section builds upon all four milestones (Node Structure, Search, Insert with Split, Delete with Rebalancing) and explores how the foundational B-tree implementation can be extended for real-world use cases beyond the educational scope.\n\nThe current B-tree implementation provides a solid in-memory foundation that correctly maintains all structural invariants. However, production database systems and file systems extend this core design in several critical directions. This section outlines potential enhancements, explaining how each would modify the architecture, the technical challenges involved, and the benefits they would provide. These extensions transform the academic B-tree into a practical component suitable for building storage engines, indexing systems, and other disk-resident data structures.\n\n### 13.1 Extension Ideas\n\nThe following extensions represent natural evolution paths for the B-tree implementation. Each addresses a specific limitation of the current design for production environments.\n\n#### 13.1.1 Persistence to Disk (Disk I/O Layer)\n\n**Mental Model: The Filing Cabinet System**\nThink of the current in-memory B-tree as a temporary workspace on a desk—fast to access but lost when the power goes off. Adding disk persistence transforms it into a filing cabinet system: each node corresponds to a labeled folder (disk page) stored in a drawer (disk). To work with a document, you must first retrieve the entire folder from the cabinet (disk read), make changes, and then file it back (disk write). The cabinet's organization (the B-tree structure) survives power cycles, but accessing folders is slower than grabbing papers from your desk.\n\n**Current Limitation:** The implementation stores all nodes in volatile RAM using `malloc`. A system crash or program termination loses all data.\n\n**Proposed Extension:** Add a disk storage layer where each `BTreeNode` corresponds to a fixed-size disk page (e.g., 4KB). The `BTree` structure would manage a cache of recently accessed pages in memory and a mapping from node identifiers to disk locations.\n\n**Key Design Changes:**\n1. **Page-Oriented Node Allocation:** Replace pointer-based child references (`BTreeNode** children`) with disk page IDs (e.g., `uint64_t`). Each node would have a unique `page_id`.\n2. **Buffer Pool Manager:** Introduce a fixed-size cache (buffer pool) of loaded pages. The `btree_search/insert/delete` operations would request nodes from the buffer manager, which handles loading from disk and writing dirty pages back.\n3. **Serialization/Deserialization:** Add functions `node_serialize` and `node_deserialize` to convert between in-memory `BTreeNode` structures and raw byte arrays (disk pages).\n4. **Free Space Management:** Track unused pages (e.g., with a free list or bitmap) to reuse space from deleted nodes.\n5. **Root Pointer Persistence:** Store the `page_id` of the root node at a fixed location on disk (e.g., the first 8 bytes of the file) to bootstrap the tree.\n\n> **ADR: Page-Oriented vs. Log-Structured Node Storage**\n> - **Context:** Need to persist B-tree nodes to disk with efficient read/write patterns.\n> - **Options Considered:**\n>   1. **Page-Oriented (Traditional):** Each node occupies a fixed-size disk page at a stable location. Updates overwrite the page in-place.\n>   2. **Log-Structured (Append-Only):** All node modifications are appended to a sequential log. A separate in-memory table maps node IDs to their latest log offsets.\n> - **Decision:** Page-oriented storage for initial persistence extension.\n> - **Rationale:** Page-oriented design is simpler to implement and matches the classic B-tree assumption of fixed-size disk blocks. It allows direct access to any node given its page ID without scanning a log. Overwrite-in-place is acceptable for a single-threaded implementation.\n> - **Consequences:** Enables traditional database-style B-tree persistence. Requires careful handling of crash consistency (e.g., write-ahead logging for atomic operations) and fragmentation management over time.\n\n**Comparison of Disk Storage Approaches:**\n\n| Approach | Pros | Cons | Best For |\n|----------|------|------|----------|\n| **Page-Oriented (Fixed Location)** | • Direct node access by page ID<br>• Simple implementation<br>• Matches textbook B-tree model | • Fragmentation from deletions<br>• Crash consistency requires additional logging (WAL)<br>• Random writes may be slow on HDDs | Traditional databases, educational clarity |\n| **Log-Structured (Append-Only)** | • Sequential writes (faster on HDD/SSD)<br>• Built-in versioning/history<br>• Simplifies crash recovery (no torn pages) | • Requires garbage collection (compaction)<br>• Need mapping table in memory (or itself logged)<br>• Extra indirection for reads | Write-intensive workloads, SSDs, experimental storage engines |\n\n**Implementation Considerations:**\n- **Page Size:** Typically 4KB (file system block size) or larger (8KB, 16KB). Must fit `(2t-1)` keys, `(2t)` child pointers, and metadata.\n- **Cache Eviction Policy:** Least Recently Used (LRU) is a common choice for the buffer pool.\n- **Concurrency:** Disk I/O operations should be non-blocking (asynchronous) to avoid stalling the main thread during page loads.\n\n**Common Challenges:**\n- ⚠️ **Pitfall: Ignoring Alignment** — Disk pages must be aligned to block boundaries. Serializing structures with `sizeof(BTreeNode)` may not produce the exact page size, leading to wasted space or read errors.\n- ⚠️ **Pitfall: No Crash Consistency** — Writing a split node without ensuring the parent is updated can corrupt the tree after a crash. Requires a write-ahead log (WAL) for atomic multi-page operations.\n\n#### 13.1.2 Key-Value Storage with Associated Values\n\n**Mental Model: The Library Card Catalog**\nThe current B-tree acts like a simple index of book accession numbers (keys). Adding associated values transforms it into a full card catalog: each card (node entry) contains both the accession number (key) and detailed information about the book—title, author, location (value). The tree organizes the cards by accession number for quick lookup, but the valuable data is the book information attached to each key.\n\n**Current Limitation:** The `BTreeNode` structure includes a `values void**` array, but the core algorithms ignore it. The `btree_insert` accepts a `value void*` but doesn't store or retrieve it.\n\n**Proposed Extension:** Fully integrate the value pointers into all operations. Each key in a leaf node would have an associated value pointer. Internal nodes would continue to have `NULL` values for their keys (which are only separators).\n\n**Key Design Changes:**\n1. **Value Storage in Leaves:** Modify `node_insert_key` and `node_remove_key` to handle the parallel `values` array. When inserting a key at index `i`, also insert the value pointer at the same index in the `values` array.\n2. **Search Returns Value:** Update `btree_search` and `search_recursive` to return the `value void*` in the `SearchResult` when a key is found at a leaf.\n3. **Value Propagation During Splits:** When splitting a leaf node, copy value pointers along with keys to the new node. For internal node splits, values for the promoted key are irrelevant (can be `NULL`).\n4. **Value Deletion:** Ensure `btree_delete` properly handles the value pointer—either freeing it if the tree owns the memory, or returning it to the caller for external management.\n\n> **ADR: Inline Values vs. Indirect Storage**\n> - **Context:** Need to store variable-sized or large values associated with keys.\n> - **Options Considered:**\n>   1. **Inline Storage (Current):** Store value pointers directly in the node's `values` array. The pointer points to external memory.\n>   2. **Indirect Storage (Value Log):** Store values in a separate append-only log or heap file. The node stores only a small value handle (e.g., offset in log) instead of a pointer.\n> - **Decision:** Keep inline storage with `void*` pointers for simplicity in the initial extension.\n> - **Rationale:** Direct pointers are easiest to implement and understand. They allow the B-tree to store references to any data structure. The caller manages memory allocation for values, keeping the B-tree focused on structure.\n> - **Consequences:** Values must fit in memory. The tree doesn't handle variable-sized values efficiently (all pointers are same size). For disk persistence, values would need separate storage strategy.\n\n**Comparison of Value Storage Strategies:**\n\n| Strategy | Pros | Cons | Best For |\n|----------|------|------|----------|\n| **Inline Pointers (Current)** | • Simple implementation<br>• Fast in-memory access<br>• Can point to any data type | • Not disk-persistent directly<br>• Variable-sized values waste space or require separate allocation<br>• Pointers become invalid after program restart | In-memory caches, indices over existing objects |\n| **Separate Value Log** | • Values can be variable-sized<br>• Efficient disk persistence (sequential writes)<br>• Can compress values independently | • Extra indirection (slower)<br>• Requires garbage collection for deleted values<br>• More complex to implement | Database storage engines, key-value stores (e.g., RocksDB) |\n\n**Implementation Considerations:**\n- **Memory Management:** Who owns the value memory? The B-tree could adopt values (free on delete) or just store references (caller manages). A hybrid approach with a `free_value_fn` callback is flexible.\n- **Duplicate Keys:** The B-tree typically assumes unique keys. If duplicates are allowed, values must be stored for each duplicate, possibly as a list per key.\n\n**Common Challenges:**\n- ⚠️ **Pitfall: Value Pointer Misalignment** — When splitting or merging nodes, forgetting to copy/move value pointers along with keys corrupts the value-key association.\n- ⚠️ **Pitfall: Memory Leaks** — Deleting a key without freeing its associated value (if the tree owns it) leaks memory. Similarly, overwriting a key during insertion might leak the old value.\n\n#### 13.1.3 Concurrency Control (Multi-Threading)\n\n**Mental Model: The Library with Multiple Librarians**\nImagine a library where several librarians (threads) can simultaneously help patrons. Without coordination, two librarians might try to update the same catalog drawer (node) at once, leading to chaos. Concurrency control provides a system like \"sign-out sheets\" for drawers: a librarian must acquire a lock on a drawer before modifying it, and perhaps follow a protocol to prevent deadlock (e.g., always request locks top-down).\n\n**Current Limitation:** The implementation is single-threaded. Concurrent `insert` and `search` operations from multiple threads would cause data races, leading to corruption or crashes.\n\n**Proposed Extension:** Add fine-grained locking to allow safe concurrent operations. Common approaches include:\n- **Readers-Writer Locks (Pessimistic):** Each node has a read-write lock. Searches acquire read locks; insertions/deletions acquire write locks on nodes along their path.\n- **B-link Tree (Optimistic):** A variant where nodes have a \"high key\" and a link pointer to the right sibling. Searches can proceed without locks; insertions use careful atomic operations and retry mechanisms.\n- **Copy-on-Write (Persistent):** Each modification creates new versions of nodes along the path, enabling snapshot isolation and lock-free reads.\n\n**Key Design Changes:**\n1. **Node-Level Locking:** Add a `pthread_rwlock_t` (or equivalent) field to `BTreeNode`. All operations must acquire appropriate locks as they traverse.\n2. **Lock Coupling (Crabbing):** To prevent deadlock and ensure consistency, hold the lock on a parent while acquiring the lock on a child. Release parent lock after child is locked (for writes).\n3. **Deadlock Avoidance:** Always acquire locks in a consistent order (e.g., top-down, left-to-right).\n4. **Root Handling:** The root may change during splits. Need a special lock or version number for the root pointer.\n\n> **ADR: Fine-Grained Locking vs. B-link Tree**\n> - **Context:** Need to support concurrent operations without sacrificing correctness.\n> - **Options Considered:**\n>   1. **Fine-Grained Read-Write Locks:** Traditional approach using lock coupling (crabbing). Simple to understand but can lead to contention at high levels.\n>   2. **B-link Tree with Optimistic Concurrency:** A B-tree variant with sibling links that allows lock-free searches and non-blocking inserts using atomic compare-and-swap (CAS) operations.\n> - **Decision:** Start with fine-grained read-write locks for educational purposes.\n> - **Rationale:** Lock coupling directly extends the existing algorithms with clear critical sections. It's easier to implement and debug than B-link trees, which require significant algorithmic changes.\n> - **Consequences:** Provides thread safety but may limit scalability under high contention. Deadlock risk requires careful lock ordering.\n\n**Comparison of Concurrency Approaches:**\n\n| Approach | Pros | Cons | Best For |\n|----------|------|------|----------|\n| **Fine-Grained Read-Write Locks** | • Conceptually straightforward<br>• Minimal changes to existing algorithms<br>• Well-understood deadlock avoidance protocols | • Lock overhead per node<br>• Contention at root and hot nodes<br>• Deadlock risk if ordering violated | Moderate concurrency, educational implementation |\n| **B-link Tree (Optimistic)** | • Lock-free reads (scalable)<br>• Non-blocking inserts<br>• Avoids deadlock by design | • Complex to implement correctly<br>• Requires atomic operations (CAS)<br>• Algorithm differs from classic B-tree | High-concurrency databases (e.g., LMDB, WiredTiger) |\n| **Copy-on-Write (Persistent)** | • Naturally provides snapshot isolation<br>• Readers never block writers<br>• Good for versioned data | • High write amplification<br>• Requires garbage collection of old nodes<br>• Memory/disk overhead | Multi-version systems, temporal databases, file systems (ZFS, Btrfs) |\n\n**Implementation Considerations:**\n- **Lock Granularity:** Locking at the node level is fine-grained but adds memory overhead. Coarser granularity (e.g., locking entire tree) would destroy concurrency.\n- **Recovery from Deadlocks:** Use timeout mechanisms or deadlock detection if not strictly ordering locks.\n- **Performance:** Under high contention, the root node becomes a bottleneck. Techniques like root splitting or root versioning can help.\n\n**Common Challenges:**\n- ⚠️ **Pitfall: Forgotten Unlock** — In complex recursive functions with multiple return paths, failing to unlock a node before returning leads to deadlock.\n- ⚠️ **Pitfall: Lock Ordering Violation** — Acquiring locks on two children in arbitrary order (e.g., during borrowing from sibling) can cause deadlock. Must always lock left-to-right or right-to-left.\n\n#### 13.1.4 B+ Tree and B* Tree Variants\n\n**Mental Model: Specialized Library Catalog Systems**\n- **B+ Tree:** Imagine a library catalog where the main index (internal nodes) contains only guide keys, and all actual book records (values) are stored in a separate, linked set of leaf pages. This is like having an index volume that points to specific shelves where books are stored contiguously.\n- **B* Tree:** Imagine a library that avoids creating new shelves until absolutely necessary. When a shelf becomes full, instead of immediately splitting it, librarians first try to redistribute books to neighboring shelves. Only when three adjacent shelves are all full do they split two of them into three. This maximizes space utilization.\n\n**Current Limitation:** The implementation is a classic B-tree where values *could* be stored in internal nodes (though our design leaves them NULL). This is less efficient for range scans and has lower node occupancy on average than B* trees.\n\n**Proposed Extensions:**\n\n**B+ Tree Modifications:**\n1. **Leaf Node Linking:** Add `BTreeNode* next` pointer to each leaf node, creating a linked list of all leaves in key order.\n2. **Value Storage Only in Leaves:** Internal nodes store only keys and child pointers—no value pointers. All values reside in leaf nodes.\n3. **Search Always Goes to Leaf:** Even if a key is found in an internal node during search, continue descending to the leaf to retrieve the associated value.\n4. **Range Scans:** Implement `btree_range_scan(start_key, end_key)` that finds the leaf for `start_key` and traverses the leaf linked list until exceeding `end_key`.\n5. **Split Differences:** When splitting a leaf, update the `next` pointers accordingly. The promoted key to the parent is the *first key of the right sibling* (not necessarily a key that exists in the left sibling).\n\n**B* Tree Modifications:**\n1. **Higher Minimum Occupancy:** Instead of splitting a node when it reaches `2t-1` keys, try to redistribute keys to a sibling first. Only split when both the node and its immediate sibling are full.\n2. **Three-Node Split:** When splitting is unavoidable, involve two full siblings and distribute keys among three nodes (two original plus one new), leading to better space utilization (nodes are at least 2/3 full).\n3. **Modified Insertion Algorithm:** During descent, if a child is full, first check if an adjacent sibling has space. If yes, redistribute keys between the child, sibling, and parent. If no adjacent sibling has space, then perform a split that involves the child and one sibling.\n\n> **ADR: B+ Tree vs. Classic B-tree for Range Queries**\n> - **Context:** Need efficient range scans (e.g., \"find all keys between 100 and 200\") and sequential access.\n> - **Options Considered:**\n>   1. **Classic B-tree:** Values can be anywhere. Range scans require complex traversal jumping between internal and leaf nodes.\n>   2. **B+ Tree:** All values in leaves, with leaves linked sequentially.\n> - **Decision:** Implement B+ tree extension if range queries are important.\n> - **Rationale:** B+ trees are the standard for database indices because they optimize for both random lookups and range scans. The leaf linkage makes scanning orders of magnitude faster (no need to backtrack up the tree).\n> - **Consequences:** Slightly more complex insertion/deletion due to leaf linking. Internal nodes store only keys (smaller, higher fanout). Duplicate key handling is cleaner (all duplicates go to leaves).\n\n**Comparison of B-tree Variants:**\n\n| Variant | Key Characteristics | Advantages | Disadvantages |\n|---------|---------------------|------------|---------------|\n| **Classic B-tree** | Keys and values may be in internal nodes | • Simpler algorithms<br>• Can store \"hot\" data higher in tree | • Less efficient for range scans<br>• Lower fanout if values are large |\n| **B+ Tree** | All values in leaves, leaves linked | • Excellent for range scans/sequential access<br>• Higher fanout in internal nodes<br>• Predictable access pattern (always to leaf) | • Extra pointer per leaf<br>• Two different node types (internal vs leaf) |\n| **B* Tree** | Redistributes before splitting, nodes ≥ 2/3 full | • Higher space utilization (less wasted disk)<br>• Fewer splits, potentially lower height | • More complex insertion logic<br>• Redistribution overhead |\n\n**Implementation Considerations:**\n- **Backward Compatibility:** Could maintain the same external API (`btree_insert`, `btree_search`) but change internal behavior. Range scan would be a new API.\n- **Hybrid Approach:** Allow configuration at tree creation time (`btree_create(t, variant)`).\n- **Testing:** Each variant requires specific test cases for redistribution and linking.\n\n**Common Challenges:**\n- ⚠️ **Pitfall: Broken Leaf Links** — During split or merge of leaves, incorrectly updating `next` pointers breaks the sequential scan.\n- ⚠️ **Pitfall: Redistribution Complexity** — B* tree redistribution requires careful handling of keys and children across three nodes (two siblings and parent). Off-by-one errors are common.\n\n### 13.2 Additional Extension Opportunities\n\nBeyond the major extensions above, several other enhancements could improve utility or performance:\n\n- **Bulk Loading:** Construct a B-tree efficiently from a pre-sorted set of keys (e.g., from a CSV file) by building the tree bottom-up rather than repeated insertion. This produces a perfectly balanced tree with higher leaf occupancy and is much faster.\n- **Compression:** Store keys in nodes using prefix compression (especially useful for string keys) to increase effective fanout and reduce I/O.\n- **Variable-Length Keys:** Support keys of arbitrary length (e.g., strings) by storing them within the node's byte array with offset pointers, rather than fixed-size `int` keys.\n- **Transactional Support:** Group multiple insert/delete operations into atomic transactions with rollback capability, using an undo log.\n- **Monitoring and Metrics:** Expose internal statistics (node counts, split/merge frequencies, average occupancy) for performance tuning.\n\n### 13.3 Implementation Guidance\n\n> **Note:** The following guidance provides starting points for the most practical extension: adding associated values and simple persistence. These are the most likely next steps for a learner wanting to build a usable key-value store.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Persistence Layer** | Fixed-size binary file with direct I/O (`fread`/`fwrite`) | Memory-mapped files (`mmap`) with page fault handling |\n| **Concurrency Control** | Single global mutex for entire tree (`pthread_mutex`) | Fine-grained per-node read-write locks (`pthread_rwlock_t`) |\n| **Value Storage** | `void*` pointers to caller-managed memory | Separate value log file with offset-based handles |\n\n**Recommended File Structure for Extended Project:**\n\n```\nbtree/\n├── include/\n│   └── btree.h                 # Public API (unchanged)\n├── src/\n│   ├── btree.c                # Core B-tree algorithms (modified for values)\n│   ├── node.c                 # Node operations\n│   ├── disk_pager.c           # NEW: Buffer pool and disk I/O\n│   ├── value_log.c            # NEW: Optional value storage\n│   └── concurrent.c           # NEW: Locking wrappers (if adding concurrency)\n├── tests/\n│   └── test_extended.c        # Tests for extended features\n└── tools/\n    └── btree_dump.c           # Utility to inspect on-disk structure\n```\n\n**Infrastructure Starter Code (Disk Pager Header):**\n\n```c\n// disk_pager.h - Simple disk persistence layer\n#ifndef DISK_PAGER_H\n#define DISK_PAGER_H\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#define PAGE_SIZE 4096\n#define INVALID_PAGE_ID UINT64_MAX\n\ntypedef uint64_t page_id_t;\n\n// Disk page representation (matches node serialized size)\ntypedef struct {\n    uint8_t bytes[PAGE_SIZE];\n} disk_page_t;\n\n// Buffer pool entry\ntypedef struct bp_entry {\n    page_id_t page_id;\n    disk_page_t page;\n    bool is_dirty;\n    struct bp_entry* next;   // For LRU list\n    struct bp_entry* prev;\n} bp_entry_t;\n\n// Main pager structure\ntypedef struct {\n    int fd;                     // File descriptor for database file\n    uint64_t num_pages;         // Total pages in file\n    bp_entry_t* lru_head;       // Most recently used\n    bp_entry_t* lru_tail;       // Least recently used\n    bp_entry_t* entries;        // Array of all buffer entries\n    int num_entries;            // Size of buffer pool\n} disk_pager_t;\n\n// Public interface\ndisk_pager_t* pager_open(const char* filename, int cache_pages);\nvoid pager_close(disk_pager_t* pager);\ndisk_page_t* pager_fetch(disk_pager_t* pager, page_id_t page_id);\nvoid pager_mark_dirty(disk_pager_t* pager, page_id_t page_id);\npage_id_t pager_allocate_page(disk_pager_t* pager);\nvoid pager_deallocate_page(disk_pager_t* pager, page_id_t page_id);\npage_id_t pager_get_root_page(disk_pager_t* pager);\nvoid pager_set_root_page(disk_pager_t* pager, page_id_t root_id);\n\n#endif // DISK_PAGER_H\n```\n\n**Core Logic Skeleton (B-tree with Values and Disk Integration):**\n\n```c\n// Modified BTree structure with disk pager\ntypedef struct {\n    page_id_t root_page_id;   // Disk page ID of root (instead of pointer)\n    int t;                    // Minimum degree\n    size_t key_count;         // Total keys (cached for O(1) access)\n    disk_pager_t* pager;      // Disk pager instance\n} BTree;\n\n// Public API with values (unchanged signatures, but now values are stored)\nBTree* btree_create(const char* filename, int min_degree);\nSearchResult btree_search(BTree* tree, int key);\nbool btree_insert(BTree* tree, int key, void* value);\nbool btree_delete(BTree* tree, int key);\n\n// Internal function now works with page IDs\nstatic BTreeNode* node_load(BTree* tree, page_id_t page_id) {\n    // TODO 1: Call pager_fetch to get disk page for page_id\n    // TODO 2: Deserialize disk page bytes into a BTreeNode structure\n    // TODO 3: Return the in-memory node (caller must eventually release)\n}\n\nstatic void node_save(BTree* tree, BTreeNode* node, page_id_t page_id) {\n    // TODO 1: Serialize BTreeNode into disk_page_t.bytes\n    // TODO 2: Call pager_mark_dirty so page gets written back eventually\n    // TODO 3: If this is a new node, assign it a page_id via pager_allocate_page\n}\n\n// Example modified search recursive function\nstatic SearchResult search_recursive_disk(BTree* tree, page_id_t current_page_id, int key) {\n    // TODO 1: Load node using node_load(tree, current_page_id)\n    // TODO 2: Perform binary search within node's keys\n    // TODO 3: If key found and node is leaf, return value from node->values[index]\n    // TODO 4: If key not found and node is leaf, return not found\n    // TODO 5: If internal node, determine child index and recursively call search_recursive_disk\n    // TODO 6: Release node from buffer pool (implementation dependent)\n}\n```\n\n**Language-Specific Hints (C):**\n- Use `open()` with `O_DIRECT` flag for aligned direct I/O (bypasses kernel cache, more realistic for database engines).\n- For serialization, consider using `memcpy()` between struct fields and byte arrays, but beware of padding bytes. Explicitly pack structures with `#pragma pack(1)` or manual byte-by-byte copying.\n- Memory management for values: Provide a callback registration mechanism: `btree_set_free_value_callback(BTree*, void (*free_fn)(void*))` to allow custom cleanup.\n- For concurrency, use `pthread_rwlock_init` in `node_create` and `pthread_rwlock_destroy` in `node_destroy`.\n\n**Milestone Checkpoint for Persistence Extension:**\n1. **Implement pager with LRU cache:** Test by creating a file, allocating pages, and reading them back.\n2. **Add node serialization:** Write a test that creates a small tree in memory, serializes all nodes to disk, then reloads and verifies structure with `btree_validate`.\n3. **Integrated operations:** After full integration, run a sequence of insertions, persist, close/reopen the file, and verify searches return correct values. Use a tool like `hexdump` to inspect the raw disk file.\n\n**Debugging Tips for Disk Extensions:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"Read wrong data after reload\" | Serialization/deserialization mismatch | Add debug prints showing byte-by-byte comparison of original vs loaded node | Ensure all fields (especially child pointers converted to page IDs) are serialized |\n| \"Segfault in buffer pool\" | LRU list corruption | Add assertions after each list operation; draw diagram of list before/after each fetch | Carefully maintain `next`/`prev` pointers in doubly-linked LRU |\n| \"File size grows uncontrollably\" | Never deallocate pages on delete | Log each `pager_allocate_page` and `pager_deallocate_page` call | Implement free page list in pager header page |\n| \"Value pointer becomes invalid after reload\" | Storing raw pointers instead of data | Pointers are memory addresses; they have no meaning after restart | For persistence, store values inline or in separate value log with offsets |\n\n---\n\n\n## 14. Glossary\n\n> **Milestone(s):** Milestones 1-4 (all operations)  \n> This section provides concise definitions for key terminology used throughout the B-tree design document, serving as a quick reference for readers encountering unfamiliar terms. Each entry references the primary section where the concept is first introduced or explained in detail.\n\n### Term Definitions\n\n| Term | Definition | Primary Reference |\n|------|------------|-------------------|\n| **Binary search** | An algorithm for finding a target value within a sorted array by repeatedly dividing the search interval in half. In B-trees, used within a node's key array to efficiently locate a target key or determine which child to traverse to. | Section 6: Component Design: Search Operation |\n| **Borrowing** | An operation during deletion that transfers a key from a sibling node through the parent to fix an underflow condition in a node. This redistributes keys without merging nodes, preserving tree structure when possible. | Section 8: Component Design: Deletion with Rebalancing |\n| **B+ tree** | A B-tree variant where all data values are stored only in leaf nodes, and internal nodes contain only keys for routing. Leaf nodes are typically linked together to support efficient range scans. | Section 13: Future Extensions |\n| **B\\* tree** | A B-tree variant that delays splitting by first attempting to redistribute keys to neighboring nodes when a node becomes full, resulting in higher average node occupancy. | Section 13: Future Extensions |\n| **Buffer pool** | A cache of recently accessed disk pages maintained in memory, used in persistent storage implementations to reduce disk I/O by keeping frequently accessed nodes available without reading from disk each time. | Section 13: Future Extensions (Future Extensions) |\n| **B-tree** | A self-balancing tree data structure optimized for systems that read and write large blocks of data (like databases and file systems). Maintains sorted data and allows search, insertion, and deletion in logarithmic time while minimizing disk accesses through high fanout. | Section 1: Context and Problem Statement |\n| **Capacity bounds** | The minimum and maximum number of keys allowed in a B-tree node based on the minimum degree *t*. Every node except the root must contain between *t*-1 and 2*t*-1 keys. The root may have as few as 1 key. | Section 5: Component Design: B-tree Node |\n| **Disk block/page** | The unit of data transfer between disk and memory, typically 4KB. B-tree nodes are designed to align with these fixed-size blocks to optimize I/O efficiency. | Section 1: Context and Problem Statement |\n| **Fanout** | The number of children per internal node in a tree. In B-trees, the fanout is typically high (dozens to hundreds) because each node holds many keys, which reduces tree height and disk seeks. | Section 4: Data Model |\n| **Height** | The number of levels from the root node to the leaf nodes in a tree. B-trees maintain logarithmic height relative to the total number of keys, ensuring efficient operations. | Section 4: Data Model |\n| **In-order predecessor** | The largest key in the left subtree of a given key. Used during deletion from internal nodes when replacing the target key before recursively deleting the replacement. | Section 8: Component Design: Deletion with Rebalancing |\n| **In-order successor** | The smallest key in the right subtree of a given key. Alternative to the predecessor for internal node deletion. | Section 8: Component Design: Deletion with Rebalancing |\n| **Invariants** | Mathematical rules that must always hold true for the data structure to be valid. B-tree invariants include key count bounds, sorted order of keys within nodes, and balanced height of all leaf nodes. | Section 4: Data Model |\n| **Lock coupling** | A concurrency control technique where a thread holds a lock on a parent node while acquiring a lock on a child node, preventing deadlock in multi-threaded B-tree implementations. | Section 13: Future Extensions |\n| **Minimum degree (t)** | The fundamental parameter defining capacity bounds in a B-tree. Each node (except root) must have at least *t*-1 keys and at most 2*t*-1 keys. The value *t* determines the tree's fanout and balance properties. | Section 5: Component Design: B-tree Node |\n| **Node access** | The act of reading a node from disk or memory. A key performance metric for B-trees, as operations aim to minimize node accesses (especially disk I/O) by keeping tree height low. | Section 6: Component Design: Search Operation |\n| **Node merging** | An operation during deletion that combines two underfull sibling nodes and the separating key from their parent into one node when borrowing is not possible. Reduces the number of nodes and may propagate up the tree. | Section 8: Component Design: Deletion with Rebalancing |\n| **Node splitting** | An operation during insertion that divides a full node (with 2*t*-1 keys) into two nodes, each with *t*-1 keys, and promotes the middle key to the parent node. Maintains capacity bounds when inserting into a full node. | Section 7: Component Design: Insertion with Splitting |\n| **Opaque pointer** | A pointer to an incomplete (forward-declared) type that hides implementation details from the user, promoting encapsulation. Used in the public API to abstract the internal `BTreeNode` structure. | Section 3: High-Level Architecture |\n| **Page-oriented storage** | A persistence model where each B-tree node occupies a fixed-size disk block (page) at a stable location, enabling direct mapping between node pointers and disk addresses. | Section 5: Component Design: B-tree Node (Milestone 1 Deliverables) |\n| **Proactive splitting** | A strategy where full nodes are split during the downward traversal for insertion, before the actual insertion occurs. This ensures that any node we descend into has room for an extra key if needed. | Section 7: Component Design: Insertion with Splitting |\n| **Range scan** | An operation that retrieves all keys and their associated values within a specified interval [start_key, end_key]. Efficiently supported in B+ trees through linked leaf nodes. | Section 13: Future Extensions |\n| **Recursive traversal** | A method of traversing tree structures where a function calls itself to process subtrees. Used in B-tree operations to navigate from the root to leaves. | Section 6: Component Design: Search Operation |\n| **Strengthening** | The process of proactively ensuring a child node has at least *t* keys before descending into it during deletion. Achieved through borrowing from a sibling or merging with a sibling, preventing underflow during the recursive deletion process. | Section 8: Component Design: Deletion with Rebalancing |\n| **Underflow** | A condition where a node has fewer than *t*-1 keys, violating the B-tree invariant. Occurs after deletion and must be resolved through borrowing or merging to restore the minimum occupancy requirement. | Section 8: Component Design: Deletion with Rebalancing |\n"}